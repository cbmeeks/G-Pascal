Sections:
00: "seg8000" (8000-DA6E)
01: "segfffa" (FFFA-0)


Source: "gpascal.asm"
                        	     1: ;***********************************************
                        	     2: ; G-PASCAL COMPILER
                        	     3: ; for Ben Eater's breadboard computer
                        	     4: ;
                        	     5: ; Author: Nick Gammon
                        	     6: ; Date: 20 January 2022
                        	     7: ;
                        	     8: ; To compile:
                        	     9: ;
                        	    10: ;  vasm6502_oldstyle gpascal.asm -wdc02 -esc -Fbin -o gpascal.bin -dotdir -L gpascal.list
                        	    11: ;
                        	    12: ; To program EEPROM:
                        	    13: ;
                        	    14: ;  minipro -p AT28C256 -w gpascal.bin
                        	    15: ;
                        	    16: ;
                        	    17: ;
                        	    18: ; To communicate, I suggest: miniterm /dev/ttyUSB0 4800 -e
                        	    19: ;
                        	    20: ;   Miniterm: Ctrl+]        : to exit.
                        	    21: ;             Ctrl+T Ctrl+H : help
                        	    22: ;             Ctrl+T Ctrl+E : toggle local echo
                        	    23: ;
                        	    24: ;
                        	    25: ;  Copyright 2022 by Nick Gammon
                        	    26: ;
                        	    27: ;  Permission is hereby granted, free of charge, to any person obtaining a copy
                        	    28: ;  of this software and associated documentation files (the "Software"), to deal
                        	    29: ;  in the Software without restriction, including without limitation the rights
                        	    30: ;  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                        	    31: ;  copies of the Software, and to permit persons to whom the Software is
                        	    32: ;  furnished to do so, subject to the following conditions:
                        	    33: ;
                        	    34: ;  The above copyright notice and this permission notice shall be included in all
                        	    35: ;  copies or substantial portions of the Software.
                        	    36: ;
                        	    37: ;  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                        	    38: ;  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                        	    39: ;  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                        	    40: ;  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                        	    41: ;  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                        	    42: ;  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
                        	    43: ;  SOFTWARE.
                        	    44: ;
                        	    45: ;***********************************************
                        	    46: ;
                        	    47: 
                        	    48: ; Note: BCC == BLT and BCS == BGE
                        	    49: ;
                        	    50: 
                        	    51: ;
                        	    52: ;  CONDITIONAL COMPILES
                        	    53: 
                        	    54: EMULATOR = 0          ; for testing on a PC running an emulator
                        	    55: LCD_SUPPORT = 1       ; 1 = support LCD, 0 = not. Unset if you have removed the LCD.
                        	    56: SERIAL_DEBUGGING = 0  ; if set, toggle VIA PA2 when reading a bit, and PA3 when writing a bit
                        	    57:                       ;  DO NOT USE I2C if this is on, as I2C functions use these two pins
                        	    58: USE_CP437_FONT = 1    ; include the symbols for the CP437 font for use with MAX7219 chip
                        	    59: 
                        	    60: ;
                        	    61: ;  CONFIGURATION
                        	    62: ;
                        	    63: CLOCK_RATE   = 1000000   ; 1 Mhz
                        	    64: START_OF_ROM = $8000     ; where the ROM chip starts
                        	    65: HIGHEST_RAM  = $3FFF      ; original board hardware
                        	    66: ;HIGHEST_RAM  = $5FFF    ; with suggested additional AND gate
                        	    67: 
                        	    68: ;
                        	    69: ;  serial output
                        	    70: ;
                        	    71: BAUD_RATE    = 4800         ; baud
                        	    72: BIT_INTERVAL = CLOCK_RATE / BAUD_RATE ; time between bits in Âµs
                        	    73: 
                        	    74: ;
                        	    75: ;  serial input - input commences on the interrupt generated by the falling edge
                        	    76: ;    of the start bit. Bits are then clocked in with a timed loop.
                        	    77: ;  - these delays can be tweaked if you believe the serial input is not being
                        	    78: ;    sampled at the right moment, confirm by turning SERIAL_DEBUGGING on
                        	    79: ;    and checking the debugging pulses compared to the middle of the bit times
                        	    80: ;    with an oscilloscope or logic analyser
                        	    81: ;
                        	    82: SERIAL_DELAY1 = 48    ; initial delay (count) - higher because it is 1.5 bit times
                        	    83: SERIAL_DELAY2 = 35    ; subsequent delays between bits (count)
                        	    84: 
                        	    85: SYMBOL_TABLE_START = HIGHEST_RAM  ; symbol table pointer (ENDSYM) is decremented before being used
                        	    86: 
                        	    87: STACK            =  $100  ; hardware stack address
                        	    88: SPACE            =  $20   ; uh-huh
                        	    89: SINGLE_QUOTE     =  $27
                        	    90: NL               =  $0A   ; newline
                        	    91: CR               =  $0D   ; carriage-return
                        	    92: BACKSPACE        =  $08   ; backspace
                        	    93: 
                        	    94: MAX_STK          =  32
                        	    95: NEW_STK          =  $FF
                        	    96: 
                        	    97:     .if EMULATOR
                        	    98: END_EDITOR_INPUT =  '`'   ; backtick terminates input
                        	    99:     .else
                        	   100: END_EDITOR_INPUT =  $1B   ; Esc terminates editor input
                        	   101:     .endif
                        	   102: 
                        	   103: KEY_DEBUG      = 'D'-$40   ; Ctrl+D start debugging
                        	   104: KEY_TRACE      = 'T'-$40   ; Ctrl+T start tracing
                        	   105: KEY_STOP_TRACE = 'N'-$40   ; Ctrl+N stop tracing
                        	   106: KEY_ABORT      = 'C'-$40   ; Ctrl+C abort execution
                        	   107: 
                        	   108: 
                        	   109:   .if LCD_SUPPORT
                        	   110: ;
                        	   111: ;  Pins connected from the VIA to the LCD
                        	   112: ;
                        	   113: LCD_RS             = %00100000  ; PA 5 - 0 = instruction, 1 = data
                        	   114: LCD_RW             = %01000000  ; PA 6 - 0 = write, 1 = read
                        	   115: LCD_E              = %10000000  ; PA 7 - toggle (0 -> 1 -> 0) to clock out a command or data
                        	   116:   .endif
                        	   117: 
                        	   118:   .include "zp_variables.inc"

Source: "zp_variables.inc"
                        	     1: ;***********************************************
                        	     2: ;
                        	     3: ; Zero-page variables (currently 64 (decimal) bytes are free for your use).
                        	     4: ;  I suggest using the high ones and working down in case there is a change to the code.
                        	     5: ;  For example, start with 0xFF, then 0xFE and so on.
                        	     6: ;
                        	     7: ;***********************************************
                        	     8: 
                        	     9:   .dsect
                        	    10: 
                        	    11: 
                        	    12: ;
                        	    13: ;  General work-areas for arithmetic routines (eg. add, subtract, divide, multiply)
                        	    14: ;   3-byte signed numbers: -8388608 to +8388607
                        	    15: ;
00:0000 00              	    16: VALUE    reserve 3    ; the current value of the token (ie. if a number)
00:0001 *
00:0003 00              	    17: VALUE2   reserve 3    ; used by the assembler expression evaluator
00:0004 *
                        	    18: 
                        	    19: ; SRCE and DEST used in compiler and editor, particularly for string comparisons
                        	    20: ;   (re-using VALUE and VALUE2)
                        	    21: 
                        	    22: SRCE     =  VALUE
                        	    23: DEST     =  VALUE2
                        	    24: 
00:0006 00              	    25: REMAIN   reserve 3    ; division remainder
00:0007 *
                        	    26: 
                        	    27: ;
                        	    28: ;  work "register" - re-using VALUE and VALUE2 again
                        	    29: ;
                        	    30: REG   = VALUE
                        	    31: REGB  = VALUE+2
                        	    32: REG2  = VALUE2
                        	    33: REG2B = VALUE2+2
                        	    34: 
                        	    35: ;
                        	    36: ;  re-using above for CRC-16 calculations
                        	    37: ;
                        	    38: crc_addr = VALUE      ; the address to take a CRC of (2 bytes)
                        	    39: crc_num  = VALUE2     ; the number of bytes to take a CRC of (2 bytes)
                        	    40: crc_val  = REMAIN     ; the current CRC value (2 bytes)
                        	    41: 
                        	    42: ;
                        	    43: ;  current random number - change this to reseed it
                        	    44: ;
00:0009 00              	    45: random         reserve 4 ; 32-bit random number
00:000A *
00:000D 00              	    46: typing_latency reserve 3 ; incremented while waiting for input
00:000E *
                        	    47: 
                        	    48: ;
                        	    49: ;  Used for seeding registers when calling machine code from Pascal
                        	    50: ;
00:0010 00              	    51: call_a reserve 1      ; used when doing a machine code call:  A register
00:0011 00              	    52: call_x reserve 1      ;  ditto: X register
00:0012 00              	    53: call_y reserve 1      ;  ditto: Y register
00:0013 00              	    54: call_p reserve 1      ;  ditto: status register
00:0014 00              	    55: call_s reserve 1      ; stack register, used by BRK
00:0015 00              	    56: brk_address reserve 2 ; BRK address
00:0016 *
                        	    57: 
                        	    58: ;
                        	    59: ;  address of write function (2 bytes)
                        	    60: ;
                        	    61: ;  This is called by "character out" function COUT. It writes the character in "A" to
                        	    62: ;   serial port or LCD. You could conceivably put another function address here if
                        	    63: ;   you wanted to capture output (eg. from calling DISP_BIN) and putting it somewhere else
                        	    64: ;   like into a series of memory locations, or to output to SPI.
                        	    65: ;  The functions write_to_serial and write_to_lcd
                        	    66: ;   put the appropriate outputting functions into this location.
                        	    67: ;
00:0017 00              	    68: write_function reserve 2  ; address of function to write to serial or LCD
00:0018 *
                        	    69: 
                        	    70: 
00:0019 00              	    71: LINE_CNT  reserve 2   ; line counter during compile
00:001A *
                        	    72: LINE_NO  =  LINE_CNT
                        	    73: 
00:001B 00              	    74: WX       reserve 2    ; 2-byte address used during compilation (reserved word lookup)
00:001C *
00:001D 00              	    75: LIST     reserve 1    ; 0 = no listing, 1 = list source during compile
00:001E 00              	    76: DIGIT    reserve 1    ; used only in GET_NUM to process a decimal number
00:001F 00              	    77: SIGN     reserve 1    ; used in compiling and inputting a number - is there a minus sign?
                        	    78: 
00:0020 00              	    79: FRAME    reserve 2    ; stack frame number - not totally certain but it used for procedure calls at runtime
00:0021 *
00:0022 00              	    80: LEVEL    reserve 1    ; current nested procedure/function level (how far we are nested)
00:0023 00              	    81: PCODE    reserve 2    ; current P-code address (increments during compile and running)
00:0024 *
                        	    82: PNTR     =  PCODE     ; 2-byte work pointer used in editor (eg. in find/replace etc.)
00:0025 00              	    83: ACT_PCDA reserve 2    ; start of P-codes (after source) - does not increment
00:0026 *
00:0027 00              	    84: DISPL    reserve 2    ; level? ahhh ... I don't know
00:0028 *
00:0029 00              	    85: OFFSET   reserve 2    ; variable offset? maybe just a work area
00:002A *
00:002B 00              	    86: OPND     reserve 3    ; jump operand ... not sure
00:002C *
00:002E 00              	    87: DCODE    reserve 1     ; 0 = no display, 1 = display P-codes during compile
00:002F 00              	    88: STARTSYM reserve 2    ; start of symbol table
00:0030 *
00:0031 00              	    89: ENDSYM   reserve 2    ; end of symbol table - used for reverse searching symbols
00:0032 *
                        	    90: T        =  ENDSYM     ; stack pointer 2 bytes
00:0033 00              	    91: WORKD    reserve 2    ; work area for holding P-code address
00:0034 *
00:0035 00              	    92: ERRNO    reserve 1    ; current error number, if ERROR called
00:0036 00              	    93: BSAVE    reserve 1    ; seems to be used to save "A" register, lol
00:0037 00              	    94: WORK     reserve 2    ; work area, used for pushing 2-bytes onto the (processor) stack
00:0038 *
00:0039 00              	    95: PRCITM   reserve 2    ; seems to hold the current procedure/function symbol
00:003A *
00:003B 00              	    96: BASE     reserve 2    ; the base interpreter stack frame (for this procedure)
00:003C *
                        	    97: TO       =  BASE      ; Used in editor (from/to list ranges, and copying text)
00:003D 00              	    98: DATA     reserve 2    ; 2-byte address work-area for calculating the address of a variable at runtime
00:003E *
00:003F 00              	    99: RUNNING  reserve 1    ; 0x40 - in editor, 0x80 - executing - affects stuff like numeric conversion
00:0040 00              	   100: SYMITM   reserve 2    ; current symbol table item (found by searching)
00:0041 *
                        	   101: FROM     =  SYMITM    ; Used in editor (from/to list ranges, and copying text)
00:0042 00              	   102: SYNTAX   reserve 1    ; 0 = full compile, 1 = syntax-only compile (no writing to memory)
00:0043 00              	   103: END_PCD  reserve 2    ; where the P-codes ended after a compile
00:0044 *
00:0045 00              	   104: TEMP     reserve 2    ; temporary work area?
00:0046 *
00:0047 00              	   105: CALL     reserve 2    ; the procedure address we are calling
00:0048 *
00:0049 00              	   106: DBGFLG   reserve 1    ; 0 = not debugging, 1 = debugging, $80 = tracing
00:004A 00              	   107: DATTYP   reserve 1    ; 0 for integers and 1 for characters
00:004B 00              	   108: COUNT1   reserve 1    ; work counter
00:004C 00              	   109: COUNT2   reserve 1    ; and another
00:004D 00              	   110: LASTP    reserve 2    ; 2-byte last P-code address executed at runtime (start of this P-code)
00:004E *
00:004F 00              	   111: IO_A     reserve 1    ; dunno
00:0050 00              	   112: IO_Y     reserve 1    ; seems to be used to save and restore Y
00:0051 00              	   113: IO_X     reserve 1    ;  ditto for X
00:0052 00              	   114: RES      reserve 3    ; multiplication result
00:0053 *
00:0055 00              	   115: DIVISOR  reserve 3      ; divisor for division
00:0056 *
00:0058 00              	   116: DVDN     reserve 3    ; dividend
00:0059 *
00:005B 00              	   117: RMNDR    reserve 1    ; for division, 0 if positive, 0x80 if negative
00:005C 00              	   118: bcd_work    reserve 4    ; work area for converting binary to decimal (packed)
00:005D *
00:0060 00              	   119: bcd_result  reserve 8    ; work area for turning numbers into printable (unpacked)
00:0061 *
00:0068 00              	   120: spi_mode   reserve 1   ; SPI mode: 0 to 3
00:0069 00              	   121: QUOT_SYM reserve 1     ; current quote symbol
00:006A 00              	   122: QT_SIZE  reserve 1    ; number of characters in reserved words
00:006B 00              	   123: ASS_OPERAND reserve 1 ; assembler operand type = see defines below
00:006C 00              	   124: OPCODE   reserve 2    ; address of opcode in assembler
00:006D *
00:006E 00              	   125: OPCODE_LEN reserve 1  ; length of opcode
00:006F 00              	   126: ASS_EMIT_COUNT reserve 1 ; number of bytes emitted on this line
00:0070 00              	   127: ASS_OPCODE_WORK reserve 2; for opcode lookups
00:0071 *
00:0072 00              	   128: ASS_COUNT reserve 1 ; for counting opcode matches
00:0073 00              	   129: ASS_VALUE reserve 3 ; the assembler operand (address or immediate) will be here
00:0074 *
00:0076 00              	   130: ASS_PASS  reserve 1 ; which assembler pass we are up to
00:0077 00              	   131: ass_emit_bytes reserve 2 ; how many bytes the assembler emitted altogether
00:0078 *
00:0079 00              	   132: exp_value_stack reserve 2  ; address of assembler value stack
00:007A *
00:007B 00              	   133: exp_value_stack_count reserve 1 ; how far through value stack we are (0 = empty)
00:007C 00              	   134: exp_operator_stack_count reserve 1 ;  how far through operator stack we are (0 = empty)
00:007D 00              	   135: exp_operator reserve 1  ; current operator for expression evaluation
00:007E 00              	   136: exp_operator_precedence reserve 1 ; current operator precedence
00:007F 00              	   137: exp_evaluation_function reserve 2 ; function to evaluate an expression
00:0080 *
00:0081 00              	   138: exp_unary_ok reserve 1  ; true if the next token can be a unary operator (like: - < >)
00:0082 00              	   139: show_symbols reserve 1  ; true to list the symbol table after an assemble
00:0083 00              	   140: ass_current_label reserve 2 ; current symbol table address of the label on this line
00:0084 *
00:0085 00              	   141: str_work reserve 1      ; work byte for string compares
                        	   142:   .if LCD_SUPPORT
00:0086 00              	   143: lcd_work  reserve 1 ; used by the LCD routines
                        	   144:   .endif
                        	   145: 
                        	   146: ;
                        	   147: ;  serial work
                        	   148: ;
00:0087 00              	   149: serial_out_byte reserve 2 ; current byte we are sending
00:0088 *
00:0089 00              	   150: serial_out_bit  reserve 1 ; current bit count
00:008A 00              	   151: serial_in_byte  reserve 1 ; current byte we are receiving
00:008B 00              	   152: serial_in_byte_received  reserve 1 ; last received byte
                        	   153: 
                        	   154: ;
                        	   155: ; hardware
                        	   156: ;
00:008C 00              	   157: hardware_work  reserve 1  ; work for use during interpreting
                        	   158: 
                        	   159: ;
                        	   160: ; maths
                        	   161: ;
00:008D 00              	   162: maths_work  reserve 1 ; work for multiply/divide
                        	   163: ;
                        	   164: ;  for get_token
                        	   165: ;
00:008E 00              	   166: token_start      reserve 2  ; where to start looking for a token
00:008F *
00:0090 00              	   167: token_address    reserve 2  ; where the token actually started
00:0091 *
00:0092 00              	   168: token_length     reserve 1  ; length of the token
00:0093 00              	   169: token_type       reserve 1  ; what type of token it is
00:0094 00              	   170: token_value      reserve 3  ; the value of numeric tokens
00:0095 *
00:0097 00              	   171: token_sign       reserve 1  ; non-zero if negative value
00:0098 00              	   172: token_work       reserve 3  ; temporary work area - also used by handlerLookup
00:0099 *
00:009B 00              	   173: token_digit      reserve 1  ; used by get_token
00:009C 00              	   174: token_line_start reserve 2  ; where the current line starts
00:009D *
                        	   175: 
                        	   176: ;
                        	   177: ;  for editor
                        	   178: ;
00:009E 00              	   179: from_line       reserve 2     ; list, delete, modify: FROM line number
00:009F *
00:00A0 00              	   180: to_line         reserve 2     ; list, delete, modify: TO line number
00:00A1 *
00:00A2 00              	   181: current_line    reserve 2     ; current editor line number
00:00A3 *
00:00A4 00              	   182: insert_limit    reserve 2     ; maximum we can input to
00:00A5 *
00:00A6 00              	   183: mem_move_src    reserve 2     ; for copying memory - source of move
00:00A7 *
00:00A8 00              	   184: mem_move_dest   reserve 2     ; for copying memory - destination of move
00:00A9 *
00:00AA 00              	   185: mem_move_len    reserve 2     ; for copying memory - length of move
00:00AB *
00:00AC 00              	   186: this_line       reserve 2     ; which line we are searching for
00:00AD *
00:00AE 00              	   187: this_line_addr  reserve 2     ; address of the "this" line
00:00AF *
00:00B0 00              	   188: find_from       reserve 1     ; editor find: from offset in INBUF (start of target string)
00:00B1 00              	   189: find_to         reserve 1     ; editor find: to offset in INBUF (end of target string)
00:00B2 00              	   190: find_pos        reserve 1     ; which offset in the current line we are currently searching from
00:00B3 00              	   191: find_len        reserve 1     ; the length of the find text
00:00B4 00              	   192: find_delimiter  reserve 1     ; the find/replace delimiter
00:00B5 00              	   193: rep_from        reserve 1     ; editor replace: start of replacement string
00:00B6 00              	   194: rep_to          reserve 1     ; editor replace: end of replacement string
00:00B7 00              	   195: rep_diff        reserve 2     ; difference in find/replace string lengths (signed 2 bytes)
00:00B8 *
00:00B9 00              	   196: find_count      reserve 2     ; count of find/replace
00:00BA *
00:00BB 00              	   197: found_this_line reserve 1     ; did we find something on this line?
                        	   198: insert_last_char = find_from  ; the last character we inserted in INSERT/LOAD mode
                        	   199: 
00:00BC 00              	   200: editor_flags    reserve 1     ; various flags, see below
                        	   201: 
                        	   202: EFLAG_SHOW_LINE        = %00000001    ; set after receiving a newline, so we display the next line
                        	   203: EFLAG_ALLOW_ZERO_FROM  = %00000010    ; for use with MEMORY, allow them to start from $0000
                        	   204: EFLAG_LOAD             = %00000100    ; doing a LOAD, do not show line numbers when inserting
                        	   205: EFLAG_SAVE             = %00001000    ; doing a SAVE, do not show line numbers
                        	   206: EFLAG_FIND             = %00010000    ; doing a FIND
                        	   207: EFLAG_REPLACE          = %00100000    ; doing a REPLACE
                        	   208: EFLAG_SUPPRESS_NEWLINE = %01000000    ; don't show newlines
                        	   209: EFLAG_NO_LINE_NUMBERS  = %10000000    ; don't show line numbers
                        	   210: 
00:00BD 00              	   211: find_flags     reserve 1      ; find/replace flags, see below
                        	   212: 
                        	   213: FFLAG_IGNORE_CASE = %00000001
                        	   214: FFLAG_GLOBAL      = %00000010
                        	   215: FFLAG_QUIET       = %00000100
                        	   216: 
                        	   217: ;
                        	   218: ;  system flags
                        	   219: ;
                        	   220: 
00:00BE 00              	   221: system_flags    reserve 1    ; general flags
                        	   222: 
                        	   223: FLAG_COMPILING      = %00000001
                        	   224: FLAG_ASSEMBLING     = %00000010
                        	   225: FLAG_LIST_SOURCE    = %00000100
                        	   226: FLAG_VALID_COMPILE  = %00001000
                        	   227: FLAG_VALID_ASSEMBLE = %00010000
                        	   228: FLAG_RUNNING        = %00100000
                        	   229: FLAG_ONLY_ALPHA     = %01000000   ; for editor, so you can L5 to do LIST 5
                        	   230: FLAG_ABORTED        = %10000000   ; Ctrl+C pressed during printing
                        	   231: 

Source: "gpascal.asm"
                        	   119: 
                        	   120: ;
                        	   121: ;  A general work-buffer is allocated from $200 to $2FF for use during keyboard input, and also
                        	   122: ;  for converting strings during tokenisation (eg. two quotes in a row to one quote, and handling
                        	   123: ;  string escape sequences). It is also used during assembly as a 256-byte operator stack.
                        	   124: ;
                        	   125:   .org $200
                        	   126: INBUF_SIZE = 256          ; we use this for string storage during tokenisation
01:0200 00              	   127: INBUF  reserve INBUF_SIZE ; and also for preprocessing string literals (eg. backslash expansion)
01:0201 *
                        	   128: TEXT_START = *            ; where source goes in memory (currently $300)
                        	   129:   .dend
                        	   130: 
                        	   131: 
                        	   132: 
                        	   133: ;------------------------------------------
                        	   134: ;  Macros
                        	   135: ;------------------------------------------
                        	   136: 
                        	   137:  .macro tknjmpItem ; tknjmp entry: token, handler
                        	   138:    dfb   \1
                        	   139:    word  \2
                        	   140:  .endmacro
                        	   141: 
                        	   142:  .macro makeHandler ; table of words and handlers: word, handler
                        	   143:    asciiz   \1
                        	   144:    word  \2
                        	   145:  .endmacro
                        	   146: 
                        	   147: ;
                        	   148: ; makePasLibraryFunction NAME (SYMNAM), TYPE (SYMTYP), ARG_COUNT (SYMARG), EXECUTION_ADDRESS (SYMDSP)
                        	   149: ;
                        	   150: ;   TYPE = SYMBOL_LIBRARY_PROCEDURE or SYMBOL_LIBRARY_FUNCTION
                        	   151:    .macro makePasLibraryFunction
                        	   152:      asciiz   \1
                        	   153:      dfb      \2
                        	   154:      dfb      \3
                        	   155:      word     \4
                        	   156:    .endmacro
                        	   157: 
                        	   158: ;
                        	   159: ; makeAsmLibraryFunction NAME (SYMNAM), EXECUTION_ADDRESS (SYMDSP)
                        	   160: ;
                        	   161:    .macro makeAsmLibraryFunction
                        	   162:      asciiz   \1
                        	   163:      word     \2
                        	   164:    .endmacro
                        	   165: 
                        	   166:   ORG  START_OF_ROM   ; normally $8000 in the case of Ben Eater's board
                        	   167: 
00:8000 4C39DA          	   168:   JMP  START   ; where RESET takes us - a cold start
00:8003 4C55DA          	   169:   JMP  RESTART ; where NMI takes us - a warm start
                        	   170: 
                        	   171: ;***********************************************
                        	   172: ; INCLUDES
                        	   173: ;***********************************************
                        	   174: 
                        	   175:   .include "memory.inc"

Source: "memory.inc"
                        	     1: ;---------------------------
                        	     2: ; standard library stuff
                        	     3: ;---------------------------
                        	     4: 
                        	     5: ;
                        	     6: ;  character type masks
                        	     7: ;
                        	     8: m_upper   = %00000001    ; $01
                        	     9: m_lower   = %00000010    ; $02
                        	    10: m_alpha   = %00000100    ; $04
                        	    11: m_digit   = %00001000    ; $08
                        	    12: m_xdigit  = %00010000    ; $10
                        	    13: m_space   = %00100000    ; $20
                        	    14: m_cntrl   = %01000000    ; $40
                        	    15: m_alnum   = %10000000    ; $80
                        	    16: 
                        	    17: ;
                        	    18: ;  for fast checks which corrupt registers
                        	    19: ;
                        	    20: ;    ldx THE_CHARACTER_TO_BE_TESTED
                        	    21: ;    lda character_types_table,X
                        	    22: ;    bne IS_IN_THAT_CLASS
                        	    23: ;
                        	    24: 
                        	    25: character_types_table = *
00:8006 40              	    26:   dfb $40,$40,$40,$40,$40,$40,$40,$40    ; 0x00
00:8007 40
00:8008 40
00:8009 40
00:800A 40
00:800B 40
00:800C 40
00:800D 40
00:800E 40              	    27:   dfb $40,$60,$60,$60,$60,$60,$40,$40    ; 0x08
00:800F 60
00:8010 60
00:8011 60
00:8012 60
00:8013 60
00:8014 40
00:8015 40
00:8016 40              	    28:   dfb $40,$40,$40,$40,$40,$40,$40,$40    ; 0x10
00:8017 40
00:8018 40
00:8019 40
00:801A 40
00:801B 40
00:801C 40
00:801D 40
00:801E 40              	    29:   dfb $40,$40,$40,$40,$40,$40,$40,$40    ; 0x18
00:801F 40
00:8020 40
00:8021 40
00:8022 40
00:8023 40
00:8024 40
00:8025 40
00:8026 20              	    30:   dfb $20,$00,$00,$00,$00,$00,$00,$00    ; 0x20   !"#$%&'
00:8027 00
00:8028 00
00:8029 00
00:802A 00
00:802B 00
00:802C 00
00:802D 00
00:802E 00              	    31:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x28  ()*+,-./
00:802F 00
00:8030 00
00:8031 00
00:8032 00
00:8033 00
00:8034 00
00:8035 00
00:8036 98              	    32:   dfb $98,$98,$98,$98,$98,$98,$98,$98    ; 0x30  01234567
00:8037 98
00:8038 98
00:8039 98
00:803A 98
00:803B 98
00:803C 98
00:803D 98
00:803E 98              	    33:   dfb $98,$98,$00,$00,$00,$00,$00,$00    ; 0x38  89:;<=>?
00:803F 98
00:8040 00
00:8041 00
00:8042 00
00:8043 00
00:8044 00
00:8045 00
00:8046 00              	    34:   dfb $00,$95,$95,$95,$95,$95,$95,$85    ; 0x40  @ABCDEFG
00:8047 95
00:8048 95
00:8049 95
00:804A 95
00:804B 95
00:804C 95
00:804D 85
00:804E 85              	    35:   dfb $85,$85,$85,$85,$85,$85,$85,$85    ; 0x48  HIJKLMNO
00:804F 85
00:8050 85
00:8051 85
00:8052 85
00:8053 85
00:8054 85
00:8055 85
00:8056 85              	    36:   dfb $85,$85,$85,$85,$85,$85,$85,$85    ; 0x50  PQRSTUVW
00:8057 85
00:8058 85
00:8059 85
00:805A 85
00:805B 85
00:805C 85
00:805D 85
00:805E 85              	    37:   dfb $85,$85,$85,$00,$00,$00,$00,$00    ; 0x58  XYZ[\]^_
00:805F 85
00:8060 85
00:8061 00
00:8062 00
00:8063 00
00:8064 00
00:8065 00
00:8066 00              	    38:   dfb $00,$96,$96,$96,$96,$96,$96,$86    ; 0x60  `abcdefg
00:8067 96
00:8068 96
00:8069 96
00:806A 96
00:806B 96
00:806C 96
00:806D 86
00:806E 86              	    39:   dfb $86,$86,$86,$86,$86,$86,$86,$86    ; 0x68  hijklmno
00:806F 86
00:8070 86
00:8071 86
00:8072 86
00:8073 86
00:8074 86
00:8075 86
00:8076 86              	    40:   dfb $86,$86,$86,$86,$86,$86,$86,$86    ; 0x70  pqrstuvw
00:8077 86
00:8078 86
00:8079 86
00:807A 86
00:807B 86
00:807C 86
00:807D 86
00:807E 86              	    41:   dfb $86,$86,$86,$00,$00,$00,$00,$40    ; 0x78  xyz{|}~
00:807F 86
00:8080 86
00:8081 00
00:8082 00
00:8083 00
00:8084 00
00:8085 40
00:8086 00              	    42:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x80
00:8087 00
00:8088 00
00:8089 00
00:808A 00
00:808B 00
00:808C 00
00:808D 00
00:808E 00              	    43:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x88
00:808F 00
00:8090 00
00:8091 00
00:8092 00
00:8093 00
00:8094 00
00:8095 00
00:8096 00              	    44:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x90
00:8097 00
00:8098 00
00:8099 00
00:809A 00
00:809B 00
00:809C 00
00:809D 00
00:809E 00              	    45:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x98
00:809F 00
00:80A0 00
00:80A1 00
00:80A2 00
00:80A3 00
00:80A4 00
00:80A5 00
00:80A6 00              	    46:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xA0
00:80A7 00
00:80A8 00
00:80A9 00
00:80AA 00
00:80AB 00
00:80AC 00
00:80AD 00
00:80AE 00              	    47:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xA8
00:80AF 00
00:80B0 00
00:80B1 00
00:80B2 00
00:80B3 00
00:80B4 00
00:80B5 00
00:80B6 00              	    48:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xB0
00:80B7 00
00:80B8 00
00:80B9 00
00:80BA 00
00:80BB 00
00:80BC 00
00:80BD 00
00:80BE 00              	    49:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xB8
00:80BF 00
00:80C0 00
00:80C1 00
00:80C2 00
00:80C3 00
00:80C4 00
00:80C5 00
00:80C6 00              	    50:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xC0
00:80C7 00
00:80C8 00
00:80C9 00
00:80CA 00
00:80CB 00
00:80CC 00
00:80CD 00
00:80CE 00              	    51:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xC8
00:80CF 00
00:80D0 00
00:80D1 00
00:80D2 00
00:80D3 00
00:80D4 00
00:80D5 00
00:80D6 00              	    52:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xD0
00:80D7 00
00:80D8 00
00:80D9 00
00:80DA 00
00:80DB 00
00:80DC 00
00:80DD 00
00:80DE 00              	    53:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xD8
00:80DF 00
00:80E0 00
00:80E1 00
00:80E2 00
00:80E3 00
00:80E4 00
00:80E5 00
00:80E6 00              	    54:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xE0
00:80E7 00
00:80E8 00
00:80E9 00
00:80EA 00
00:80EB 00
00:80EC 00
00:80ED 00
00:80EE 00              	    55:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xE8
00:80EF 00
00:80F0 00
00:80F1 00
00:80F2 00
00:80F3 00
00:80F4 00
00:80F5 00
00:80F6 00              	    56:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xF0
00:80F7 00
00:80F8 00
00:80F9 00
00:80FA 00
00:80FB 00
00:80FC 00
00:80FD 00
00:80FE 00              	    57:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xF8
00:80FF 00
00:8100 00
00:8101 00
00:8102 00
00:8103 00
00:8104 00
00:8105 00
                        	    58: 
                        	    59: ;
                        	    60: ;  character type tests: test character in A, Carry set if true, carry clear if false
                        	    61: ;    -no registers changed
                        	    62: ;
                        	    63: is_xxx_fail:
00:8106 FA              	    64:   plx
00:8107 68              	    65:   pla
00:8108 18              	    66:   clc
00:8109 60              	    67:   rts
                        	    68: 
                        	    69: is_xxx_pass:
00:810A FA              	    70:   plx
00:810B 68              	    71:   pla
00:810C 38              	    72:   sec
00:810D 60              	    73:   rts
                        	    74: 
                        	    75:   .macro isXXX
                        	    76: \1 = *
                        	    77:   pha
                        	    78:   phx
                        	    79:   tax
                        	    80:   lda character_types_table,x
                        	    81:   and #\2
                        	    82:   beq is_xxx_fail
                        	    83:   bra is_xxx_pass
                        	    84:   .endmacro
                        	    85: 
                        	    86: ;
                        	    87: ;  generate the various character type tests - done by fast table lookup
                        	    88: ;
                        	    89:   isXXX isupper,  m_upper
                        	     1M isupper = *
00:810E 48              	     2M   pha
00:810F DA              	     3M   phx
00:8110 AA              	     4M   tax
00:8111 BD0680          	     5M   lda character_types_table,x
00:8114 2901            	     6M   and #m_upper
00:8116 F0EE            	     7M   beq is_xxx_fail
00:8118 80F0            	     8M   bra is_xxx_pass
                        	    90:   isXXX islower,  m_lower
                        	     1M islower = *
00:811A 48              	     2M   pha
00:811B DA              	     3M   phx
00:811C AA              	     4M   tax
00:811D BD0680          	     5M   lda character_types_table,x
00:8120 2902            	     6M   and #m_lower
00:8122 F0E2            	     7M   beq is_xxx_fail
00:8124 80E4            	     8M   bra is_xxx_pass
                        	    91:   isXXX isalpha,  m_alpha
                        	     1M isalpha = *
00:8126 48              	     2M   pha
00:8127 DA              	     3M   phx
00:8128 AA              	     4M   tax
00:8129 BD0680          	     5M   lda character_types_table,x
00:812C 2904            	     6M   and #m_alpha
00:812E F0D6            	     7M   beq is_xxx_fail
00:8130 80D8            	     8M   bra is_xxx_pass
                        	    92:   isXXX isdigit,  m_digit
                        	     1M isdigit = *
00:8132 48              	     2M   pha
00:8133 DA              	     3M   phx
00:8134 AA              	     4M   tax
00:8135 BD0680          	     5M   lda character_types_table,x
00:8138 2908            	     6M   and #m_digit
00:813A F0CA            	     7M   beq is_xxx_fail
00:813C 80CC            	     8M   bra is_xxx_pass
                        	    93:   isXXX isxdigit, m_xdigit
                        	     1M isxdigit = *
00:813E 48              	     2M   pha
00:813F DA              	     3M   phx
00:8140 AA              	     4M   tax
00:8141 BD0680          	     5M   lda character_types_table,x
00:8144 2910            	     6M   and #m_xdigit
00:8146 F0BE            	     7M   beq is_xxx_fail
00:8148 80C0            	     8M   bra is_xxx_pass
                        	    94:   isXXX isspace,  m_space
                        	     1M isspace = *
00:814A 48              	     2M   pha
00:814B DA              	     3M   phx
00:814C AA              	     4M   tax
00:814D BD0680          	     5M   lda character_types_table,x
00:8150 2920            	     6M   and #m_space
00:8152 F0B2            	     7M   beq is_xxx_fail
00:8154 80B4            	     8M   bra is_xxx_pass
                        	    95:   isXXX iscntrl,  m_cntrl
                        	     1M iscntrl = *
00:8156 48              	     2M   pha
00:8157 DA              	     3M   phx
00:8158 AA              	     4M   tax
00:8159 BD0680          	     5M   lda character_types_table,x
00:815C 2940            	     6M   and #m_cntrl
00:815E F0A6            	     7M   beq is_xxx_fail
00:8160 80A8            	     8M   bra is_xxx_pass
                        	    96:   isXXX isalnum,  m_alnum
                        	     1M isalnum = *
00:8162 48              	     2M   pha
00:8163 DA              	     3M   phx
00:8164 AA              	     4M   tax
00:8165 BD0680          	     5M   lda character_types_table,x
00:8168 2980            	     6M   and #m_alnum
00:816A F09A            	     7M   beq is_xxx_fail
00:816C 809C            	     8M   bra is_xxx_pass
                        	    97: 
                        	    98: ;
                        	    99: ;  ran out of bits so implemented this one manually
                        	   100: ;
                        	   101: isbinary   =  *
00:816E C930            	   102:          cmp  #'0'
00:8170 F004            	   103:          beq  isbin
00:8172 C931            	   104:          cmp  #'1'
00:8174 D002            	   105:          bne  notbin
                        	   106: isbin:
00:8176 38              	   107:          sec
00:8177 60              	   108:          rts
                        	   109: notbin:
00:8178 18              	   110:          clc
00:8179 60              	   111:          rts
                        	   112: 
                        	   113: ;
                        	   114: ; Move memory down  (mem_move_dest is < mem_move_src)
                        	   115: ;
                        	   116: ;  Copies first byte first, working upwards
                        	   117: ;
                        	   118: ; mem_move_src = source start address
                        	   119: ; mem_move_dest = destination start address
                        	   120: ; mem_move_len = number of bytes mem_move_dest move
                        	   121: ;
                        	   122: movedown:
00:817A A5AA            	   123:   lda mem_move_len
00:817C 05AB            	   124:   ora mem_move_len+1
00:817E F01C            	   125:   beq movedown_done
00:8180 A000            	   126:   ldy #0
00:8182 8498            	   127:   sty  token_work      ; counter
00:8184 8499            	   128:   sty  token_work+1
                        	   129: ;
                        	   130: ;  copy one byte, increment counter
                        	   131: ;
                        	   132: movedown_loop:
00:8186 B1A6            	   133:   lda (mem_move_src),Y
00:8188 91A8            	   134:   sta (mem_move_dest),Y
00:818A E698            	   135:   inc token_work
00:818C D002            	   136:   bne movedown2
00:818E E699            	   137:   inc token_work+1
                        	   138: ;
                        	   139: ;  see if length reached
                        	   140: ;
                        	   141: movedown2:
                        	   142: 
00:8190 A598            	   143:   lda  token_work
00:8192 C5AA            	   144:   cmp  mem_move_len
00:8194 D007            	   145:   bne  movedown1
00:8196 A599            	   146:   lda  token_work+1
00:8198 C5AB            	   147:   cmp  mem_move_len+1
00:819A D001            	   148:   bne  movedown1
                        	   149: movedown_done:
00:819C 60              	   150:   rts
                        	   151: 
                        	   152: ;
                        	   153: ; increment Y, and increment high-order address bytes if necessary
                        	   154: ;
                        	   155: movedown1:
00:819D C8              	   156:   iny
00:819E D0E6            	   157:   bne  movedown_loop
00:81A0 E6A7            	   158:   inc  mem_move_src+1
00:81A2 E6A9            	   159:   inc  mem_move_dest+1
00:81A4 80E0            	   160:   bra  movedown_loop
                        	   161: 
                        	   162: ; Move memory up (mem_move_dest is > mem_move_src)
                        	   163: ;
                        	   164: ;   Copies last byte first, moving downwards
                        	   165: ;
                        	   166: ; mem_move_src = source start address
                        	   167: ; mem_move_dest = destination start address
                        	   168: ; mem_move_len = number of bytes mem_move_dest move
                        	   169: ;
                        	   170: moveup:
00:81A6 A5AA            	   171:   lda mem_move_len
00:81A8 05AB            	   172:   ora mem_move_len+1
00:81AA F038            	   173:   beq moveup_done
00:81AC A000            	   174:   ldy #0
00:81AE 8498            	   175:   sty  token_work      ; counter
00:81B0 8499            	   176:   sty  token_work+1
                        	   177:   ;
                        	   178:   ;  calculate final address of source
                        	   179:   ;
00:81B2 18              	   180:   clc
00:81B3 A5A6            	   181:   lda mem_move_src
00:81B5 65AA            	   182:   adc mem_move_len
00:81B7 85A6            	   183:   sta mem_move_src
00:81B9 A5A7            	   184:   lda mem_move_src+1
00:81BB 65AB            	   185:   adc mem_move_len+1
00:81BD 85A7            	   186:   sta mem_move_src+1
                        	   187:   ;
                        	   188:   ;  calculate final address of destination
                        	   189:   ;
00:81BF 18              	   190:   clc
00:81C0 A5A8            	   191:   lda mem_move_dest
00:81C2 65AA            	   192:   adc mem_move_len
00:81C4 85A8            	   193:   sta mem_move_dest
00:81C6 A5A9            	   194:   lda mem_move_dest+1
00:81C8 65AB            	   195:   adc mem_move_len+1
00:81CA 85A9            	   196:   sta mem_move_dest+1
00:81CC 8017            	   197:   bra moveup_next   ; have to decrement first
                        	   198: ;
                        	   199: ; move one byte, count moves
                        	   200: ;
                        	   201: moveup_loop:
00:81CE B1A6            	   202:   lda (mem_move_src),Y
00:81D0 91A8            	   203:   sta (mem_move_dest),Y
00:81D2 E698            	   204:   inc token_work
00:81D4 D002            	   205:   bne moveup3
00:81D6 E699            	   206:   inc token_work+1
                        	   207: moveup3:
                        	   208: ;
                        	   209: ;  see if length reached
                        	   210: ;
00:81D8 A598            	   211:   lda token_work
00:81DA C5AA            	   212:   cmp mem_move_len
00:81DC D007            	   213:   bne moveup_next
00:81DE A599            	   214:   lda token_work+1
00:81E0 C5AB            	   215:   cmp mem_move_len+1
00:81E2 D001            	   216:   bne moveup_next
                        	   217: moveup_done:
00:81E4 60              	   218:   rts
                        	   219: ;
                        	   220: ;  decrement Y, and decrement high-order address bytes if necessary
                        	   221: ;
                        	   222: moveup_next   =  *
00:81E5 88              	   223:   dey
00:81E6 C0FF            	   224:   cpy #$FF
00:81E8 D0E4            	   225:   bne moveup_loop
00:81EA C6A7            	   226:   dec mem_move_src+1
00:81EC C6A9            	   227:   dec mem_move_dest+1
00:81EE 80DE            	   228:   bra moveup_loop
                        	   229: 
                        	   230: ;
                        	   231: ;
                        	   232: ; String compare - case significant (max 128 byte strings)
                        	   233: ;
                        	   234: ; SRCE = source start address
                        	   235: ; DEST = destination start address
                        	   236: ; Y    = length of both strings (range 1 to 128)
                        	   237: ;
                        	   238: ;  returns Z set if strings are equal
                        	   239: ;
                        	   240: 
                        	   241: str_compare:
00:81F0 88              	   242:   dey             ; make zero-relative
00:81F1 300B            	   243:   bmi str_compare_done
00:81F3 B100            	   244:   lda (SRCE),y
00:81F5 8585            	   245:   sta str_work
00:81F7 B103            	   246:   lda (DEST),y
00:81F9 C585            	   247:   cmp str_work
00:81FB F0F3            	   248:   beq str_compare
00:81FD 60              	   249:   rts   ; no match, zero flag not set
                        	   250: str_compare_done:
00:81FE A900            	   251:   lda #0    ; set Z flag
00:8200 60              	   252:   rts
                        	   253: 
                        	   254: ;
                        	   255: ; String compare - case NOT significant (max 128 byte strings)
                        	   256: ;
                        	   257: ; SRCE = source start address
                        	   258: ; DEST = destination start address
                        	   259: ; Y    = length of both strings (range 1 to 128)
                        	   260: ;
                        	   261: ;  returns Z set if strings are equal
                        	   262: ;
                        	   263: 
                        	   264: str_ic_compare:
00:8201 88              	   265:   dey
00:8202 301F            	   266:   bmi str_ic_compare_done
00:8204 B100            	   267:   lda (SRCE),y
00:8206 C97B            	   268:   cmp #'z'+1
00:8208 B006            	   269:   bcs str_ic_compare_fixed_srce  ; BGE
00:820A C961            	   270:   cmp #'a'
00:820C 9002            	   271:   bcc str_ic_compare_fixed_srce  ; BLT
00:820E E920            	   272:   sbc #$20    ; make upper-case
                        	   273: str_ic_compare_fixed_srce:
00:8210 8585            	   274:   sta str_work
00:8212 B103            	   275:   lda (DEST),y
00:8214 C97B            	   276:   cmp #'z'+1
00:8216 B006            	   277:   bcs str_ic_compare_fixed_dest  ; BGE
00:8218 C961            	   278:   cmp #'a'
00:821A 9002            	   279:   bcc str_ic_compare_fixed_dest  ; BLT
00:821C E920            	   280:   sbc #$20    ; make upper-case
                        	   281: str_ic_compare_fixed_dest:
00:821E C585            	   282:   cmp str_work
00:8220 F0DF            	   283:   beq str_ic_compare
00:8222 60              	   284:   rts       ; no match, zero flag not set
                        	   285: str_ic_compare_done:
00:8223 A900            	   286:   lda #0    ; set Z flag
00:8225 60              	   287:   rts
                        	   288: 
                        	   289: 

Source: "gpascal.asm"
                        	   176:   .include "editor.inc"

Source: "editor.inc"
                        	     1: ;-------------------------------------------------
                        	     2: ;
                        	     3: ;  Shell, and text editor
                        	     4: ;
                        	     5: ;-------------------------------------------------
                        	     6: 
                        	     7: 
                        	     8: ;-------------------------------------------------
                        	     9: ;  print null-terminated message, message in A (lo) and X (hi)
                        	    10: ;  returns the length of the message in Y
                        	    11: ;-------------------------------------------------
                        	    12: print:
00:8226 A8              	    13:   tay   ; save A
00:8227 A503            	    14:   lda REG2 ; save REG2
00:8229 48              	    15:   pha
00:822A A504            	    16:   lda REG2+1  ; save REG2+1
00:822C 48              	    17:   pha
00:822D 98              	    18:   tya   ; get original A back
00:822E 8503            	    19:   sta REG2
00:8230 8604            	    20:   stx REG2+1
00:8232 A000            	    21:   ldy #0
                        	    22: print_loop:
00:8234 A58B            	    23:   lda  serial_in_byte_received
00:8236 F00A            	    24:   beq  print_not_abort
00:8238 C903            	    25:   cmp  #KEY_ABORT
00:823A D010            	    26:   bne  print_done
00:823C A980            	    27:   lda  #FLAG_ABORTED    ; set aborted flag
00:823E 04BE            	    28:   tsb  system_flags
00:8240 800A            	    29:   bra  print_done
                        	    30: print_not_abort:
00:8242 B103            	    31:   lda (REG2),y
00:8244 F006            	    32:   beq print_done
00:8246 20CE93          	    33:   jsr COUT
00:8249 C8              	    34:   iny
00:824A D0E8            	    35:   bne print_loop  ; give up if we overflow
                        	    36: print_done:
00:824C 648B            	    37:   stz serial_in_byte_received
                        	    38: ;
                        	    39: ;  get REG2 back
                        	    40: ;
00:824E 68              	    41:   pla
00:824F 8504            	    42:   sta REG2+1
00:8251 68              	    43:   pla
00:8252 8503            	    44:   sta REG2
00:8254 60              	    45:   rts
                        	    46: 
00:8255 3A20            	    47: prompt       asciiz ": "
00:8257 00
00:8258 556E6B6E6F776E20	    48: bad_command  asciiz "Unknown command, type H for help.\n"
00:8260 636F6D6D616E642C
00:8268 2074797065204820
00:8270 666F722068656C70
00:8278 2E0A
00:827A 00
                        	    49: 
                        	    50: ;-------------------------------------------------
                        	    51: ; Start here after Reset or NMI - show introduction
                        	    52: ;-------------------------------------------------
                        	    53: 
                        	    54: main_start:
00:827B A9CF            	    55:   lda #<introduction
00:827D A2D9            	    56:   ldx #>introduction
00:827F 202682          	    57:   jsr print
                        	    58: 
                        	    59: main_prompt:
00:8282 A2FF            	    60:   ldx  #NEW_STK
00:8284 9A              	    61:   txs
00:8285 D8              	    62:   cld
                        	    63: 
00:8286 A955            	    64:   lda #<prompt
00:8288 A282            	    65:   ldx #>prompt
00:828A 202682          	    66:   jsr print
                        	    67: 
00:828D 20A693          	    68:   jsr  GET_LINE
                        	    69: 
00:8290 A900            	    70:   lda #<INBUF
00:8292 858E            	    71:   sta token_start
00:8294 A902            	    72:   lda #>INBUF
00:8296 858F            	    73:   sta token_start+1
                        	    74: 
00:8298 A901            	    75:   lda #1
00:829A 853F            	    76:   sta RUNNING
                        	    77: 
                        	    78: ;-------------------------------------------------
                        	    79: ; EDITOR (SHELL) MAIN LOOP
                        	    80: ;-------------------------------------------------
                        	    81: 
                        	    82: main_loop:
00:829C 64BC            	    83:   stz editor_flags  ; no flags yet
00:829E 64BD            	    84:   stz find_flags    ;  ditto
00:82A0 A901            	    85:   lda #FLAG_COMPILING
00:82A2 0902            	    86:   ora #FLAG_ASSEMBLING
00:82A4 14BE            	    87:   trb system_flags  ; not compiling or assembling now
                        	    88: 
00:82A6 A940            	    89:   lda #FLAG_ONLY_ALPHA
00:82A8 04BE            	    90:   tsb system_flags  ; we only want alpha commands, thus we can enter L1 and be the same as List 1
                        	    91: 
00:82AA 2098C9          	    92:   jsr get_token
00:82AD F0D3            	    93:   beq main_prompt   ; no input
                        	    94: 
                        	    95: ;
                        	    96: ;  Shortcut: If the input is "R" or "r" followed directly by a newline, assume they want to Run
                        	    97: ;
00:82AF C949            	    98:   cmp #TOKEN_IDENTIFIER
00:82B1 D015            	    99:   bne main_loop_not_run
                        	   100: 
00:82B3 A000            	   101:   ldy #0
00:82B5 B190            	   102:   lda (token_address),y
00:82B7 20E38F          	   103:   jsr MAKE_UPPER
00:82BA C952            	   104:   cmp #'R'
00:82BC D00A            	   105:   bne main_loop_not_run
00:82BE C8              	   106:   iny
00:82BF B190            	   107:   lda (token_address),y
00:82C1 C90A            	   108:   cmp #NL
00:82C3 D003            	   109:   bne main_loop_not_run
00:82C5 4CB88E          	   110:   jmp editor_run
                        	   111: 
                        	   112: ;
                        	   113: ;  Not a RUN shortcut, look up the command in our table
                        	   114: ;
                        	   115: main_loop_not_run:
                        	   116: ;
                        	   117: ;  set up our input line as where to find tokens
                        	   118: ;
00:82C8 A590            	   119:   lda token_address
00:82CA 8500            	   120:   sta SRCE
00:82CC A591            	   121:   lda token_address+1
00:82CE 8501            	   122:   sta SRCE+1
                        	   123: 
                        	   124: ;
                        	   125: ;  get editor handlers
                        	   126: ;
00:82D0 A9E6            	   127:   lda #<editor_handlers
00:82D2 8503            	   128:   sta DEST
00:82D4 A982            	   129:   lda #>editor_handlers
00:82D6 8504            	   130:   sta DEST+1
                        	   131: 
                        	   132: ;
                        	   133: ;  get the token length and look up the handler
                        	   134: ;
00:82D8 A592            	   135:   lda token_length
00:82DA 206C8F          	   136:   jsr partial_handler_Lookup
                        	   137: 
                        	   138: ;
                        	   139: ;  if we returned, unknown command
                        	   140: ;
00:82DD A958            	   141:   lda #<bad_command
00:82DF A282            	   142:   ldx #>bad_command
00:82E1 202682          	   143:   jsr print
00:82E4 809C            	   144:   bra  main_prompt
                        	   145: 
                        	   146: 
                        	   147: editor_handlers:
                        	   148:   makeHandler "LIST",    editor_list
00:82E6 4C495354        	     1M    asciiz   "LIST"
00:82EA 00
00:82EB 3187            	     2M    word  editor_list
                        	   149:   makeHandler "INSERT",  editor_insert
00:82ED 494E53455254    	     1M    asciiz   "INSERT"
00:82F3 00
00:82F4 E489            	     2M    word  editor_insert
                        	   150:   makeHandler "LOAD",    editor_load
00:82F6 4C4F4144        	     1M    asciiz   "LOAD"
00:82FA 00
00:82FB E089            	     2M    word  editor_load
                        	   151:   makeHandler "DELETE",  editor_delete
00:82FD 44454C455445    	     1M    asciiz   "DELETE"
00:8303 00
00:8304 728B            	     2M    word  editor_delete
                        	   152:   makeHandler "HELP",    editor_help
00:8306 48454C50        	     1M    asciiz   "HELP"
00:830A 00
00:830B E984            	     2M    word  editor_help
                        	   153:   makeHandler "COMPILE" ,editor_compile
00:830D 434F4D50494C45  	     1M    asciiz   "COMPILE" 
00:8314 00
00:8315 A48E            	     2M    word  editor_compile
                        	   154:   makeHandler "SYNTAX",  editor_syntax
00:8317 53594E544158    	     1M    asciiz   "SYNTAX"
00:831D 00
00:831E AE8E            	     2M    word  editor_syntax
                        	   155:   makeHandler "SAVE",    editor_save
00:8320 53415645        	     1M    asciiz   "SAVE"
00:8324 00
00:8325 2B87            	     2M    word  editor_save
                        	   156: ;  makeHandler "TEST",    editor_test
                        	   157:   makeHandler "MEMORY",  editor_memory
00:8327 4D454D4F5259    	     1M    asciiz   "MEMORY"
00:832D 00
00:832E CA8C            	     2M    word  editor_memory
                        	   158:  ; makeHandler "SYMTBL", editor_symbol_table_list
                        	   159:   makeHandler "INFO",    editor_info
00:8330 494E464F        	     1M    asciiz   "INFO"
00:8334 00
00:8335 958E            	     2M    word  editor_info
                        	   160:   makeHandler "TRACE",   editor_trace
00:8337 5452414345      	     1M    asciiz   "TRACE"
00:833C 00
00:833D 898E            	     2M    word  editor_trace
                        	   161:   makeHandler "DEBUG",   editor_debug
00:833F 4445425547      	     1M    asciiz   "DEBUG"
00:8344 00
00:8345 7D8E            	     2M    word  editor_debug
                        	   162:   makeHandler "ASSEMBLE",editor_assemble
00:8347 415353454D424C45	     1M    asciiz   "ASSEMBLE"
00:834F 00
00:8350 238F            	     2M    word  editor_assemble
                        	   163:   makeHandler "FIND",    editor_find
00:8352 46494E44        	     1M    asciiz   "FIND"
00:8356 00
00:8357 2587            	     2M    word  editor_find
                        	   164:   makeHandler "REPLACE", editor_replace
00:8359 5245504C414345  	     1M    asciiz   "REPLACE"
00:8360 00
00:8361 1D87            	     2M    word  editor_replace
                        	   165:   makeHandler "RUN",     editor_run
00:8363 52554E          	     1M    asciiz   "RUN"
00:8366 00
00:8367 B88E            	     2M    word  editor_run
                        	   166:   makeHandler "RECOVER", editor_recover
00:8369 5245434F564552  	     1M    asciiz   "RECOVER"
00:8370 00
00:8371 548E            	     2M    word  editor_recover
00:8373 00              	   167:   dfb 0
                        	   168: 
                        	   169: editor_help_info:
00:8374 417661696C61626C	   170:   asc "Available actions:\n\n"
00:837C 6520616374696F6E
00:8384 733A0A0A
00:8388 4C6973742F534176	   171:   asc "List/SAve   line_number_range\n"
00:8390 652020206C696E65
00:8398 5F6E756D6265725F
00:83A0 72616E67650A
00:83A6 44656C6574652020	   172:   asc "Delete      line_number_range\n"
00:83AE 202020206C696E65
00:83B6 5F6E756D6265725F
00:83BE 72616E67650A
00:83C4 496E736572742F4C	   173:   asc "Insert/LOad after_line\n"
00:83CC 4F61642061667465
00:83D4 725F6C696E650A
00:83DB 46696E6420202020	   174:   asc "Find        line_number_range /target/flags\n"
00:83E3 202020206C696E65
00:83EB 5F6E756D6265725F
00:83F3 72616E6765202F74
00:83FB 61726765742F666C
00:8403 6167730A
00:8407 5265706C61636520	   175:   asc "Replace     line_number_range /target/replacement/flags\n"
00:840F 202020206C696E65
00:8417 5F6E756D6265725F
00:841F 72616E6765202F74
00:8427 61726765742F7265
00:842F 706C6163656D656E
00:8437 742F666C6167730A
00:843F 0A              	   176:   asc "\n"
00:8440 48656C700A      	   177:   asc "Help\n"
00:8445 494E666F0A      	   178:   asc "INfo\n"
00:844A 4D656D6F72792020	   179:   asc "Memory      first_address last_address\n"
00:8452 2020202066697273
00:845A 745F616464726573
00:8462 73206C6173745F61
00:846A 6464726573730A
00:8471 436F6D70696C652F	   180:   asc "Compile/Syntax/Assemble\n"
00:8479 53796E7461782F41
00:8481 7373656D626C650A
00:8489 52556E2F44454275	   181:   asc "RUn/DEBug/Trace\n"
00:8491 672F54726163650A
00:8499 5245436F7665720A	   182:   asc "RECover\n"
00:84A1 28416374696F6E73	   183:   asc "(Actions may be abbreviated)\n"
00:84A9 206D617920626520
00:84B1 6162627265766961
00:84B9 746564290A
00:84BE 28466C6167733A20	   184:   asc "(Flags: 'I'gnore case, 'G'lobal, 'Q'uiet)\n"
00:84C6 274927676E6F7265
00:84CE 20636173652C2027
00:84D6 47276C6F62616C2C
00:84DE 2027512775696574
00:84E6 290A
00:84E8 00              	   185:   dfb 0
                        	   186: 
                        	   187: 
                        	   188: ;--------------------------------------------
                        	   189: ;  HELP
                        	   190: ;--------------------------------------------
                        	   191: editor_help:
00:84E9 200E86          	   192:   jsr editor_check_no_more
00:84EC A974            	   193:   lda #<editor_help_info
00:84EE 8500            	   194:   sta REG
00:84F0 A983            	   195:   lda #>editor_help_info
00:84F2 8501            	   196:   sta REG+1
                        	   197: editor_help_loop:
00:84F4 A000            	   198:   ldy #0
00:84F6 B100            	   199:   lda (REG),Y
00:84F8 F00B            	   200:   beq editor_help_done
00:84FA 20CE93          	   201:   jsr COUT
00:84FD E600            	   202:   inc REG
00:84FF D0F3            	   203:   bne editor_help_loop
00:8501 E601            	   204:   inc REG+1
00:8503 80EF            	   205:   bra editor_help_loop
                        	   206: editor_help_done:
00:8505 4C8282          	   207:   jmp main_prompt
                        	   208: 
                        	   209: ;
                        	   210: ;  Sets default range from 1 to 65535
                        	   211: ;
                        	   212: editor_default_range:
                        	   213: ;
                        	   214: ;  default to all lines
                        	   215: ;
00:8508 A901            	   216:   lda #1
00:850A 859E            	   217:   sta from_line
00:850C 649F            	   218:   stz from_line+1
00:850E A9FF            	   219:   lda #$FF
00:8510 85A0            	   220:   sta to_line
00:8512 85A1            	   221:   sta to_line+1
00:8514 60              	   222:   rts
                        	   223: 
                        	   224: number_expected_message:
00:8515 4E756D6265722065	   225:   asciiz "Number expected\n"
00:851D 787065637465640A
00:8525 00
                        	   226: 
                        	   227: editor_bad_number:
00:8526 A915            	   228:   lda #<number_expected_message
00:8528 A285            	   229:   ldx #>number_expected_message
00:852A 202682          	   230:   jsr print
00:852D 4C8282          	   231:   jmp main_prompt
                        	   232: 
                        	   233: ;
                        	   234: ;  get a number for the editor: accepts eof or newline as "no number"
                        	   235: ;  otherwise must be a number and in the range 0x0001 to 0xFFFF
                        	   236: ;  returns carry set if a number (in token_value) and carry clear if
                        	   237: ;  no number. Raises an error otherwise
                        	   238: ;
                        	   239: editor_get_number:
00:8530 2046CF          	   240:   jsr pas_get_token   ; use this to find END as a token
00:8533 F065            	   241:   beq editor_get_number_none ; no token? return with carry set
00:8535 C90A            	   242:   cmp #NL
00:8537 F061            	   243:   beq editor_get_number_none ; newline counts as no token
00:8539 C94E            	   244:   cmp #TOKEN_NUMBER
00:853B F04B            	   245:   beq editor_get_number_ok
00:853D C989            	   246:   cmp #TOKEN_END
00:853F F05B            	   247:   beq editor_get_number_end
00:8541 C949            	   248:   cmp #TOKEN_IDENTIFIER
00:8543 D02D            	   249:   bne editor_get_number_not_identifier
00:8545 A592            	   250:   lda token_length
00:8547 C903            	   251:   cmp #3
00:8549 D0DB            	   252:   bne editor_bad_number
00:854B A000            	   253:   ldy #0
00:854D B190            	   254:   lda (token_address),y
00:854F 20E38F          	   255:   jsr MAKE_UPPER
00:8552 C941            	   256:   cmp #'A'
00:8554 D0D0            	   257:   bne editor_bad_number
00:8556 C8              	   258:   iny
00:8557 B190            	   259:   lda (token_address),y
00:8559 20E38F          	   260:   jsr MAKE_UPPER
00:855C C94C            	   261:   cmp #'L'
00:855E D0C6            	   262:   bne editor_bad_number
00:8560 C8              	   263:   iny
00:8561 B190            	   264:   lda (token_address),y
00:8563 20E38F          	   265:   jsr MAKE_UPPER
00:8566 C94C            	   266:   cmp #'L'
00:8568 D0BC            	   267:   bne editor_bad_number
00:856A 200885          	   268:   jsr editor_default_range
00:856D 200E86          	   269:   jsr editor_check_no_more ; can't have ALL - something
00:8570 8028            	   270:   bra editor_get_number_none
                        	   271: ;
                        	   272: ;  find / replace can go straight to the delimiter
                        	   273: ;
                        	   274: editor_get_number_not_identifier:
00:8572 A910            	   275:   lda #EFLAG_FIND
00:8574 0920            	   276:   ora #EFLAG_REPLACE
00:8576 25BC            	   277:   and editor_flags
00:8578 F0AC            	   278:   beq editor_bad_number
00:857A A592            	   279:   lda token_length
00:857C C901            	   280:   cmp #1
00:857E D0A6            	   281:   bne editor_bad_number
                        	   282: ;
                        	   283: ;  go back one character, we need get_token to find this again later
                        	   284: ;
00:8580 C68E            	   285:   dec token_start
00:8582 D016            	   286:   bne editor_get_number_none
00:8584 C68F            	   287:   dec token_start+1
00:8586 8012            	   288:   bra editor_get_number_none
                        	   289: 
                        	   290: editor_get_number_ok:
00:8588 A596            	   291:   lda token_value+2         ; must be a number
00:858A D03C            	   292:   bne editor_line_number_too_big
00:858C A5BC            	   293:   lda editor_flags
00:858E 2902            	   294:   and #EFLAG_ALLOW_ZERO_FROM
00:8590 D006            	   295:   bne editor_get_number_done
00:8592 A594            	   296:   lda token_value
00:8594 0595            	   297:   ora token_value+1
00:8596 F030            	   298:   beq editor_line_number_too_big  ; too small actually
                        	   299: editor_get_number_done:
00:8598 38              	   300:   sec
00:8599 60              	   301:   rts
                        	   302: 
                        	   303: editor_get_number_none:
00:859A 18              	   304:   clc
00:859B 60              	   305:   rts
                        	   306: 
                        	   307: ;
                        	   308: ;  the word "END" will count as the highest possible line number
                        	   309: ;
                        	   310: editor_get_number_end:
00:859C A9FF            	   311:   lda #$FF
00:859E 8594            	   312:   sta token_value
00:85A0 8595            	   313:   sta token_value+1
00:85A2 6496            	   314:   stz token_value+2
00:85A4 200E86          	   315:   jsr editor_check_no_more ; can't have END - something
00:85A7 38              	   316:   sec
00:85A8 60              	   317:   rts
                        	   318: 
                        	   319: number_too_large_message:
00:85A9 4E756D6265722074	   320:   asciiz "Number too large or too small\n"
00:85B1 6F6F206C61726765
00:85B9 206F7220746F6F20
00:85C1 736D616C6C0A
00:85C7 00
                        	   321: 
                        	   322: editor_line_number_too_big:
00:85C8 A9A9            	   323:   lda #<number_too_large_message
00:85CA A285            	   324:   ldx #>number_too_large_message
00:85CC 202682          	   325:   jsr print
00:85CF 4C8282          	   326:   jmp main_prompt
                        	   327: 
                        	   328: number_bad_range_message:
00:85D2 52616E676520696E	   329:   asciiz "Range invalid\n"
00:85DA 76616C69640A
00:85E0 00
                        	   330: 
                        	   331: editor_bad_range:
00:85E1 A9D2            	   332:   lda #<number_bad_range_message
00:85E3 A285            	   333:   ldx #>number_bad_range_message
00:85E5 202682          	   334:   jsr print
00:85E8 4C8282          	   335:   jmp main_prompt
                        	   336: 
                        	   337: too_much_on_line:
00:85EB 556E657870656374	   338:   asciiz "Unexpected trailing input on line\n"
00:85F3 656420747261696C
00:85FB 696E6720696E7075
00:8603 74206F6E206C696E
00:860B 650A
00:860D 00
                        	   339: 
                        	   340: ;
                        	   341: ;  check that all is left on the line is spaces
                        	   342: ;
                        	   343: editor_check_no_more:
00:860E A000            	   344:   ldy #0
                        	   345: editor_check_no_more_loop:
00:8610 B18E            	   346:   lda (token_start),y
00:8612 F016            	   347:   beq editor_check_no_more_ok   ; end of file
00:8614 C90A            	   348:   cmp #NL
00:8616 F012            	   349:   beq editor_check_no_more_ok   ; newline is OK
00:8618 204A81          	   350:   jsr isspace
00:861B 9003            	   351:   bcc editor_check_no_more_failed ; not spaces is bad
00:861D C8              	   352:   iny
00:861E D0F0            	   353:   bne editor_check_no_more_loop   ; skip spaces
                        	   354: 
                        	   355: editor_check_no_more_failed:
00:8620 A9EB            	   356:   lda #<too_much_on_line
00:8622 A285            	   357:   ldx #>too_much_on_line
00:8624 202682          	   358:   jsr print
00:8627 4C8282          	   359:   jmp main_prompt
                        	   360: editor_check_no_more_ok:
00:862A 60              	   361:   rts
                        	   362: 
                        	   363: 
                        	   364: 
                        	   365: ;--------------------------------------------
                        	   366: ;  get a range of line numbers (eg. L 1,10; D 4; M 6,10 )
                        	   367: ;--------------------------------------------
                        	   368: 
                        	   369: editor_get_range:
                        	   370: 
                        	   371: 
                        	   372: ;
                        	   373: ;  get the first line number (if any)
                        	   374: ;
00:862B 203085          	   375:   jsr editor_get_number
00:862E 9049            	   376:   bcc editor_get_range_done ; no token? take defaults
                        	   377: ;
                        	   378: ;  store the from line
                        	   379: ;
00:8630 A594            	   380:   lda token_value
00:8632 859E            	   381:   sta from_line
00:8634 85A0            	   382:   sta to_line
00:8636 A595            	   383:   lda token_value+1
00:8638 859F            	   384:   sta from_line+1
00:863A 85A1            	   385:   sta to_line+1
                        	   386: 
                        	   387: ;
                        	   388: ;  comma or hyphen?
                        	   389: ;
00:863C 2098C9          	   390:   jsr get_token
00:863F F038            	   391:   beq editor_get_range_done   ; line done, just the single line wanted
                        	   392: 
00:8641 C92D            	   393:   cmp #'-'
00:8643 F01C            	   394:   beq editor_get_range_hyphen
00:8645 C94E            	   395:   cmp #TOKEN_NUMBER
00:8647 F01D            	   396:   beq editor_get_range_number
00:8649 C989            	   397:   cmp #TOKEN_END
00:864B F019            	   398:   beq editor_get_range_number
00:864D C92C            	   399:   cmp #','
00:864F F010            	   400:   beq editor_get_range_hyphen
                        	   401: ;
                        	   402: ;  find and replace may have another character after the first line number
                        	   403: ;  which isn't a second line number or a hyphen/comma
                        	   404: ;
00:8651 A910            	   405:   lda #EFLAG_FIND
00:8653 0920            	   406:   ora #EFLAG_REPLACE
00:8655 25BC            	   407:   and editor_flags
00:8657 F088            	   408:   beq editor_bad_range
                        	   409: 
                        	   410: ;
                        	   411: ;  go back one character, we need get_token to find this again later
                        	   412: ;
00:8659 C68E            	   413:   dec token_start
00:865B D01C            	   414:   bne editor_get_range_done
00:865D C68F            	   415:   dec token_start+1
00:865F 8018            	   416:   bra editor_get_range_done
                        	   417: 
                        	   418: editor_get_range_hyphen:
                        	   419: ;
                        	   420: ;  get the second line number
                        	   421: ;
00:8661 203085          	   422:   jsr editor_get_number
00:8664 9014            	   423:   bcc editor_bad_rangeJ
                        	   424: 
                        	   425: editor_get_range_number:
00:8666 A594            	   426:   lda token_value
00:8668 85A0            	   427:   sta to_line
00:866A A595            	   428:   lda token_value+1
00:866C 85A1            	   429:   sta to_line+1
                        	   430: 
                        	   431: ;
                        	   432: ;  make sure range ascends
                        	   433: ;
00:866E 38              	   434:   sec
00:866F A5A0            	   435:   lda to_line
00:8671 E59E            	   436:   sbc from_line
00:8673 A5A1            	   437:   lda to_line+1
00:8675 E59F            	   438:   sbc from_line+1
00:8677 9001            	   439:   bcc editor_bad_rangeJ    ; <sigh> because of the way SBC works
                        	   440: 
                        	   441: editor_get_range_done:
00:8679 60              	   442:   rts
                        	   443: 
00:867A 4CE185          	   444: editor_bad_rangeJ jmp editor_bad_range
                        	   445: 
                        	   446: ;
                        	   447: 
00:867D 20666F756E640A  	   448: found_message asciiz  ' found\n'
00:8684 00
                        	   449: 
                        	   450: 
                        	   451: 
00:8685 46726F6D3A20    	   452: from_msg: asciiz "From: "
00:868B 00
00:868C 20746F20        	   453: to_msg:   asciiz " to "
00:8690 00
                        	   454: 
00:8691 4261642064656C69	   455: bad_delimiter_message asciiz "Bad delimiter\n"
00:8699 6D697465720A
00:869F 00
                        	   456: 
                        	   457: editor_bad_delimiter:
00:86A0 A991            	   458:   lda #<bad_delimiter_message
00:86A2 A286            	   459:   ldx #>bad_delimiter_message
                        	   460: editor_find_problem:
00:86A4 202682          	   461:   jsr print
00:86A7 4C8282          	   462:   jmp main_prompt
                        	   463: 
00:86AA 46696E642F726570	   464: find_string_too_long_message asciiz "Find/replace string too long\n"
00:86B2 6C61636520737472
00:86BA 696E6720746F6F20
00:86C2 6C6F6E670A
00:86C7 00
                        	   465: 
                        	   466: find_string_too_long:
00:86C8 A9AA            	   467:   lda #<find_string_too_long_message
00:86CA A286            	   468:   ldx #>find_string_too_long_message
00:86CC 80D6            	   469:   bra editor_find_problem
                        	   470: 
                        	   471: editor_get_delimiter:
00:86CE 2098C9          	   472:   jsr get_token
00:86D1 C949            	   473:   cmp #TOKEN_IDENTIFIER
00:86D3 F0CB            	   474:   beq editor_bad_delimiter
00:86D5 C94E            	   475:   cmp #TOKEN_NUMBER
00:86D7 F0C7            	   476:   beq editor_bad_delimiter
00:86D9 C922            	   477:   cmp #TOKEN_STRING
00:86DB F0C3            	   478:   beq editor_bad_delimiter
00:86DD A692            	   479:   ldx token_length
00:86DF E001            	   480:   cpx #1
00:86E1 D0BD            	   481:   bne editor_bad_delimiter
00:86E3 85B4            	   482:   sta find_delimiter
00:86E5 60              	   483:   rts
                        	   484: 
00:86E6 4E6F20636C6F7369	   485: editor_no_closing_delimiter_message asciiz "No closing delimiter\n"
00:86EE 6E672064656C696D
00:86F6 697465720A
00:86FB 00
                        	   486: 
                        	   487: editor_no_closing_delimiter:
00:86FC A9E6            	   488:   lda #<editor_no_closing_delimiter_message
00:86FE A286            	   489:   ldx #>editor_no_closing_delimiter_message
00:8700 80A2            	   490:   bra editor_find_problem
                        	   491: 
00:8702 5461726765742073	   492: no_find_message asciiz "Target string empty\n"
00:870A 7472696E6720656D
00:8712 7074790A
00:8716 00
                        	   493: 
                        	   494: editor_no_find_string:
00:8717 A902            	   495:   lda #<no_find_message
00:8719 A287            	   496:   ldx #>no_find_message
00:871B 8087            	   497:   bra editor_find_problem
                        	   498: 
                        	   499: ;--------------------------------------------
                        	   500: ;  LIST / SAVE / FIND / REPLACE / MODIFY
                        	   501: ;
                        	   502: ;  This rather complex routine lists the source between from_line and to_line
                        	   503: ;   In the process it can show or omit line numbers  (omit for SAVE)
                        	   504: ;  Also, it can find the target text, and optionally replace it with the replacement text
                        	   505: ;  In find/replace mode the lines are not shown unless they had something found (unless
                        	   506: ;   the Quiet flag is set)
                        	   507: ;
                        	   508: ;--------------------------------------------
                        	   509: 
                        	   510: editor_replace:
00:871D A920            	   511:   lda #EFLAG_REPLACE
00:871F 0910            	   512:   ora #EFLAG_FIND   ; makes things simpler later on
00:8721 85BC            	   513:   sta editor_flags
00:8723 800C            	   514:   bra editor_list
                        	   515: 
                        	   516: editor_find:
                        	   517: 
00:8725 A910            	   518:   lda #EFLAG_FIND
00:8727 85BC            	   519:   sta editor_flags
00:8729 8006            	   520:   bra editor_list
                        	   521: 
                        	   522: editor_save
                        	   523: 
00:872B A980            	   524:   lda #EFLAG_NO_LINE_NUMBERS
00:872D 0908            	   525:   ora #EFLAG_SAVE
00:872F 85BC            	   526:   sta editor_flags
                        	   527: 
                        	   528: ;
                        	   529: ;  main entry point - get the from and to lines
                        	   530: ;
                        	   531: editor_list:
00:8731 200885          	   532:   jsr editor_default_range
00:8734 202B86          	   533:   jsr editor_get_range
                        	   534: 
                        	   535: ;
                        	   536: ;  turn the from_line into an address and put it into PCODE
                        	   537: ;
00:8737 A59E            	   538:   lda from_line
00:8739 85AC            	   539:   sta this_line
00:873B A59F            	   540:   lda from_line+1
00:873D 85AD            	   541:   sta this_line+1
00:873F 20538C          	   542:   jsr find_line    ; find the "from" line address (this_line in fact)
00:8742 A5AE            	   543:   lda this_line_addr
00:8744 8523            	   544:   sta PCODE
00:8746 A5AF            	   545:   lda this_line_addr+1
00:8748 8524            	   546:   sta PCODE+1
00:874A 64B9            	   547:   stz find_count
00:874C 64BA            	   548:   stz find_count+1
                        	   549: 
                        	   550: ;
                        	   551: ;  for FIND and REPLACE, get the first delimiter
                        	   552: ;
00:874E A5BC            	   553:   lda editor_flags
00:8750 2910            	   554:   and #EFLAG_FIND
00:8752 D003            	   555:   bne editor_list_doing_find
00:8754 4C2188          	   556:   jmp editor_list_not_find
                        	   557: 
                        	   558: editor_list_doing_find:
00:8757 20CE86          	   559:   jsr editor_get_delimiter
                        	   560: ;
                        	   561: ;  token_next should now be the start of what we are searching for
                        	   562: ;
00:875A 38              	   563:   sec
00:875B A58E            	   564:   lda token_start
00:875D E900            	   565:   sbc #<INBUF
00:875F 85B0            	   566:   sta find_from
00:8761 B00B            	   567:   bcs editor_list_got_from_point ; delimiter should be a single byte
                        	   568: 
                        	   569: editor_find_bug:
00:8763 A214            	   570:   ldx #20  ; ERROR: bug
00:8765 4C8397          	   571:   jmp ERROR
                        	   572: 
00:8768 4CC886          	   573: find_string_too_longJ         jmp find_string_too_long
00:876B 4CFC86          	   574: editor_no_closing_delimiterJ  jmp editor_no_closing_delimiter
                        	   575: 
                        	   576: editor_list_got_from_point:
                        	   577: 
                        	   578: ;
                        	   579: ;  Now find closing delimiter by a simple scan as we will pass who-knows-what on the way
                        	   580: ;
00:876E A6B0            	   581:   ldx find_from
                        	   582: editor_find_second_delimiter_loop:
00:8770 E8              	   583:   inx
00:8771 BD0002          	   584:   lda INBUF,x
00:8774 F0F5            	   585:   beq editor_no_closing_delimiterJ
00:8776 C90A            	   586:   cmp #NL
00:8778 F0F1            	   587:   beq editor_no_closing_delimiterJ
00:877A C5B4            	   588:   cmp find_delimiter
00:877C D0F2            	   589:   bne editor_find_second_delimiter_loop
                        	   590: 
                        	   591: ;
                        	   592: ;  found the closing delimiter
                        	   593: ;
00:877E 86B1            	   594:   stx find_to
00:8780 E4B0            	   595:   cpx find_from
00:8782 F093            	   596:   beq editor_no_find_string
                        	   597: ;
                        	   598: ;  maximum 127 byte find string
                        	   599: ;
00:8784 38              	   600:   sec
00:8785 A5B1            	   601:   lda find_to
00:8787 E5B0            	   602:   sbc find_from
00:8789 30DD            	   603:   bmi find_string_too_longJ
00:878B 85B3            	   604:   sta find_len    ; save for later memory move calculations
                        	   605: 
00:878D A920            	   606:   lda #EFLAG_REPLACE
00:878F 25BC            	   607:   and editor_flags
00:8791 F02A            	   608:   beq editor_find_get_flags
                        	   609: 
                        	   610: ;
                        	   611: ;  doing a replace - find second delimiter
                        	   612: ;
                        	   613: 
00:8793 86B5            	   614:   stx rep_from
00:8795 E6B5            	   615:   inc rep_from    ; get past the delimiter
                        	   616: 
                        	   617: editor_find_third_delimiter_loop:
00:8797 E8              	   618:   inx
00:8798 BD0002          	   619:   lda INBUF,x
00:879B F0CE            	   620:   beq editor_no_closing_delimiterJ
00:879D C90A            	   621:   cmp #NL
00:879F F0CA            	   622:   beq editor_no_closing_delimiterJ
00:87A1 C5B4            	   623:   cmp find_delimiter
00:87A3 D0F2            	   624:   bne editor_find_third_delimiter_loop
                        	   625: 
                        	   626: ;
                        	   627: ;  found the replacement closing delimiter
00:87A5 86B6            	   628:   stx rep_to
                        	   629: 
                        	   630: ;
                        	   631: ;  maximum 127 byte replacement string
                        	   632: ;
00:87A7 38              	   633:   sec
00:87A8 A5B6            	   634:   lda rep_to
00:87AA E5B5            	   635:   sbc rep_from
00:87AC 30BA            	   636:   bmi find_string_too_longJ
                        	   637: 
                        	   638: ;
                        	   639: ;  now find the signed difference between the find and replace strings
                        	   640: ;  namely: (rep_to - rep_from) - find_len
                        	   641: ;
00:87AE 64B8            	   642:   stz rep_diff+1
00:87B0 38              	   643:   sec
00:87B1 A5B6            	   644:   lda rep_to
00:87B3 E5B5            	   645:   sbc rep_from
00:87B5 E5B3            	   646:   sbc find_len
00:87B7 85B7            	   647:   sta rep_diff
00:87B9 1002            	   648:   bpl editor_find_get_flags
00:87BB C6B8            	   649:   dec rep_diff+1   ; make that $ff
                        	   650: 
                        	   651: ;
                        	   652: ; get any find/replace flags
                        	   653: ;
                        	   654: editor_find_get_flags:
00:87BD 64BD            	   655:   stz find_flags
                        	   656: 
                        	   657: editor_flags_loop:
00:87BF E8              	   658:   inx
00:87C0 BD0002          	   659:   lda INBUF,X
00:87C3 C90A            	   660:   cmp #NL
00:87C5 F042            	   661:   beq editor_list_fix_target_string
00:87C7 204A81          	   662:   jsr isspace
00:87CA B0F3            	   663:   bcs editor_flags_loop
00:87CC 20E38F          	   664:   jsr MAKE_UPPER
00:87CF C951            	   665:   cmp #'Q'
00:87D1 D00A            	   666:   bne editor_flags1
00:87D3 A904            	   667:   lda #FFLAG_QUIET
00:87D5 04BD            	   668:   tsb find_flags
00:87D7 A980            	   669:   lda #EFLAG_NO_LINE_NUMBERS
00:87D9 04BC            	   670:   tsb editor_flags
00:87DB 80E2            	   671:   bra editor_flags_loop
                        	   672: editor_flags1:
00:87DD C947            	   673:   cmp #'G'
00:87DF D006            	   674:   bne editor_flags2
00:87E1 A902            	   675:   lda #FFLAG_GLOBAL
00:87E3 04BD            	   676:   tsb find_flags
00:87E5 80D8            	   677:   bra editor_flags_loop
                        	   678: editor_flags2:
00:87E7 C949            	   679:   cmp #'I'
00:87E9 D006            	   680:   bne editor_flags3
00:87EB A901            	   681:   lda #FFLAG_IGNORE_CASE
00:87ED 04BD            	   682:   tsb find_flags
00:87EF 80CE            	   683:   bra editor_flags_loop
                        	   684: editor_flags3:
00:87F1 A9FB            	   685:   lda #<bad_flag_message
00:87F3 A287            	   686:   ldx #>bad_flag_message
00:87F5 202682          	   687:   jsr print
00:87F8 4C8282          	   688:   jmp main_prompt
                        	   689: 
00:87FB 556E6B6E6F776E20	   690: bad_flag_message: asciiz "Unknown flag\n"
00:8803 666C61670A
00:8808 00
                        	   691: 
                        	   692: editor_list_fix_target_string:
                        	   693: 
00:8809 A901            	   694:   lda #FFLAG_IGNORE_CASE
00:880B 25BD            	   695:   and find_flags
00:880D F015            	   696:   beq editor_list_get_on_with_it
                        	   697: 
                        	   698: ;
                        	   699: ;  for case insensitive compare force target to be upper case
                        	   700: ;
00:880F A6B0            	   701:   ldx find_from
                        	   702: editor_list_fixup_loop:
00:8811 E4B1            	   703:   cpx find_to
00:8813 F00F            	   704:   beq editor_list_get_on_with_it
00:8815 BD0002          	   705:   lda INBUF,X
00:8818 20E38F          	   706:   jsr MAKE_UPPER
00:881B 9D0002          	   707:   sta INBUF,X
00:881E E8              	   708:   inx
00:881F 80F0            	   709:   bra editor_list_fixup_loop
                        	   710: 
                        	   711: 
                        	   712: editor_list_not_find:
                        	   713: ;
                        	   714: ;  we should have no more tokens now
                        	   715: ;
00:8821 200E86          	   716:   jsr editor_check_no_more
                        	   717: 
                        	   718: editor_list_get_on_with_it:
                        	   719: ;
                        	   720: ;  make sure current_line is correct
                        	   721: ;
00:8824 A59E            	   722:   lda from_line
00:8826 85A2            	   723:   sta current_line
00:8828 A59F            	   724:   lda from_line+1
00:882A 85A3            	   725:   sta current_line+1
                        	   726: 
                        	   727: ;
                        	   728: ;  exit immediately if no source from here on
                        	   729: ;
00:882C A000            	   730:   ldy #0
00:882E B123            	   731:   lda (PCODE),Y
00:8830 D003            	   732:   bne editor_list_have_source
00:8832 4C5089          	   733:   jmp editor_list_done
                        	   734: 
                        	   735: editor_list_have_source:
00:8835 A901            	   736:   lda #EFLAG_SHOW_LINE
00:8837 04BC            	   737:   tsb editor_flags
00:8839 8006            	   738:   bra editor_list_loop
                        	   739: 
00:883B 4C5089          	   740: editor_list_doneJ jmp editor_list_done
00:883E 4C1289          	   741: editor_list_no_line_numberJ jmp editor_list_no_line_number
                        	   742: 
                        	   743: editor_list_loop:
00:8841 A58B            	   744:   lda serial_in_byte_received
00:8843 C903            	   745:   cmp  #KEY_ABORT
00:8845 F021            	   746:   beq  editor_list_aborted
00:8847 64BB            	   747:   stz  found_this_line
00:8849 A000            	   748:   ldy #0
00:884B B123            	   749:   lda (PCODE),Y
00:884D F0EC            	   750:   beq editor_list_doneJ
00:884F A5BC            	   751:   lda editor_flags
00:8851 2901            	   752:   and #EFLAG_SHOW_LINE
00:8853 F0E9            	   753:   beq  editor_list_no_line_numberJ
00:8855 A5BC            	   754:   lda editor_flags
00:8857 2908            	   755:   and #EFLAG_SAVE
00:8859 D0E3            	   756:   bne editor_list_no_line_numberJ
                        	   757: ;
                        	   758: ;  At this exact point we know we are at the start of a line
                        	   759: ;  and we aren't doing a Save. Now, if we are doing a Find then
                        	   760: ;  we need to know if this line (from here to the next newline)
                        	   761: ;  matches our find string, and if not, to skip it
                        	   762: 
00:885B A940            	   763:   lda #EFLAG_SUPPRESS_NEWLINE
00:885D 14BC            	   764:   trb editor_flags              ; we can show newlines now
                        	   765: 
00:885F A5BC            	   766:   lda editor_flags
00:8861 2910            	   767:   and #EFLAG_FIND
00:8863 D010            	   768:   bne editor_find_or_replacing
                        	   769: 
00:8865 4C0589          	   770:   jmp  editor_list_not_finding
                        	   771: 
                        	   772: ;
                        	   773: ;  Here when Ctrl+C pressed
                        	   774: ;
                        	   775: editor_list_aborted:
00:8868 A232            	   776:   ldx #50
00:886A A000            	   777:   ldy #0
00:886C 20F490          	   778:   jsr delay   ; 50 ms delay to allow serial to settle
00:886F 204792          	   779:   jsr CROUT
00:8872 4C5089          	   780:   jmp editor_list_done
                        	   781: 
                        	   782: editor_find_or_replacing:
                        	   783: 
                        	   784: ;
                        	   785: ;  here if finding or replacing
                        	   786: ;
                        	   787: 
00:8875 A900            	   788:   lda #0
                        	   789: 
                        	   790: ;
                        	   791: ;  we come back here for multiple replacements with a new starting pos
                        	   792: ;
                        	   793: editor_replacement_loop:
00:8877 85B2            	   794:   sta find_pos    ; searching line from beginning (or not, if doing a multiple replace)
                        	   795: 
                        	   796: editor_find_loop:
00:8879 A6B0            	   797:   ldx find_from   ; out target string position in INBUF
00:887B A4B2            	   798:   ldy find_pos    ; where we are on the line
                        	   799: editor_find_inner_loop:
00:887D E4B1            	   800:   cpx find_to     ; reached end of target, found the string!
00:887F F037            	   801:   beq editor_find_found_it
00:8881 B123            	   802:   lda (PCODE),Y
00:8883 C90A            	   803:   cmp #NL
00:8885 F01B            	   804:   beq editor_find_no_match ; hit end of line without matching
                        	   805: 
                        	   806: ;
                        	   807: ;  force to upper-case if required
                        	   808: ;
00:8887 48              	   809:   pha
00:8888 A901            	   810:   lda #FFLAG_IGNORE_CASE
00:888A 25BD            	   811:   and find_flags
00:888C F006            	   812:   beq editor_find_case_sensitive
00:888E 68              	   813:   pla
00:888F 20E38F          	   814:   jsr MAKE_UPPER
00:8892 8001            	   815:   bra editor_find_test_character
                        	   816: editor_find_case_sensitive:
00:8894 68              	   817:   pla
                        	   818: editor_find_test_character:
00:8895 DD0002          	   819:   cmp INBUF,X     ; does source byte match target byte?
00:8898 D004            	   820:   bne editor_find_skip_this
00:889A C8              	   821:   iny
00:889B E8              	   822:   inx
00:889C 80DF            	   823:   bra editor_find_inner_loop
                        	   824: 
                        	   825: editor_find_skip_this:
00:889E E6B2            	   826:   inc find_pos
00:88A0 D0D7            	   827:   bne editor_find_loop  ; if it wraps, give up
                        	   828: 
                        	   829: ;
                        	   830: ;  we are at the newline without a match, increment PCODE to match
                        	   831: ;  where we are and go onto newline processing
                        	   832: ;
                        	   833: editor_find_no_match:
00:88A2 A5BB            	   834:    lda found_this_line
00:88A4 D05F            	   835:    bne editor_list_not_finding
00:88A6 18              	   836:    clc
00:88A7 98              	   837:    tya
00:88A8 6523            	   838:    adc PCODE
00:88AA 8523            	   839:    sta PCODE
00:88AC A900            	   840:    lda #0
00:88AE 6524            	   841:    adc PCODE+1
00:88B0 8524            	   842:    sta PCODE+1
00:88B2 A940            	   843:    lda #EFLAG_SUPPRESS_NEWLINE
00:88B4 04BC            	   844:    tsb editor_flags
00:88B6 8062            	   845:    bra editor_newline_processing
                        	   846: 
                        	   847: ;
                        	   848: ;  here when find succeeded
                        	   849: ;
                        	   850: editor_find_found_it:
00:88B8 E6B9            	   851:   inc find_count
00:88BA D002            	   852:   bne editor_find_found_it1
00:88BC E6BA            	   853:   inc find_count+1
                        	   854: editor_find_found_it1:
00:88BE A901            	   855:   lda #1
00:88C0 85BB            	   856:   sta found_this_line
00:88C2 A920            	   857:   lda #EFLAG_REPLACE
00:88C4 25BC            	   858:   and editor_flags
00:88C6 D00E            	   859:   bne editor_do_the_replace
                        	   860: 
00:88C8 A902            	   861:   lda #FFLAG_GLOBAL
00:88CA 25BD            	   862:   and find_flags
00:88CC F037            	   863:   beq editor_list_not_finding   ; one replace is enough
                        	   864: 
                        	   865: ;
                        	   866: ;  add the find length to Y (moving past what we just found)
                        	   867: ;
                        	   868: ;
00:88CE 18              	   869:   clc
00:88CF A5B2            	   870:   lda find_pos
00:88D1 65B3            	   871:   adc find_len
00:88D3 4C7788          	   872:   jmp editor_replacement_loop
                        	   873: 
                        	   874: ;
                        	   875: ;  here when replacing
                        	   876: ;
                        	   877: editor_do_the_replace:
00:88D6 A908            	   878:   lda #FLAG_VALID_COMPILE   ; compile or assemble no longer valid
00:88D8 0910            	   879:   ora #FLAG_VALID_ASSEMBLE
00:88DA 14BE            	   880:   trb system_flags
                        	   881: 
00:88DC A5B7            	   882:   lda rep_diff ; same length?
00:88DE F003            	   883:   beq editor_easy_replace
00:88E0 4C7089          	   884:   jmp editor_do_replace
                        	   885: 
                        	   886: editor_easy_replace:
00:88E3 A4B2            	   887:   ldy find_pos
00:88E5 A6B5            	   888:   ldx rep_from
                        	   889: editor_easy_replace_loop:
00:88E7 E4B6            	   890:   cpx rep_to
00:88E9 F009            	   891:   beq editor_easy_replace_done
00:88EB BD0002          	   892:   lda INBUF,x
00:88EE 9123            	   893:   sta (PCODE),y
00:88F0 C8              	   894:   iny
00:88F1 E8              	   895:   inx
00:88F2 D0F3            	   896:   bne editor_easy_replace_loop  ; keep replacing
                        	   897: 
                        	   898: editor_easy_replace_done:
00:88F4 A902            	   899:   lda #FFLAG_GLOBAL
00:88F6 25BD            	   900:   and find_flags
00:88F8 F00B            	   901:   beq editor_list_not_finding   ; one replace is enough
                        	   902: 
                        	   903: ;
                        	   904: ;  add the replacement length to Y (moving past what we just replaced)
                        	   905: ;   the replacement length is rep_to - rep_from
                        	   906: ;
00:88FA 18              	   907:   clc
00:88FB A5B2            	   908:   lda find_pos
00:88FD 65B6            	   909:   adc rep_to
00:88FF 38              	   910:   sec
00:8900 E5B5            	   911:   sbc rep_from
00:8902 4C7788          	   912:   jmp editor_replacement_loop
                        	   913: 
                        	   914: ;
                        	   915: ;
                        	   916: ;  display the line number
                        	   917: ;
                        	   918: editor_list_not_finding:
00:8905 A901            	   919:   lda #EFLAG_SHOW_LINE
00:8907 14BC            	   920:   trb editor_flags      ; cancel flag until next newline
00:8909 A980            	   921:   lda #EFLAG_NO_LINE_NUMBERS
00:890B 25BC            	   922:   and editor_flags
00:890D D003            	   923:   bne editor_list_no_line_number
00:890F 20158C          	   924:   jsr show_current_line_number
                        	   925: 
                        	   926: editor_list_no_line_number:
00:8912 A000            	   927:   ldy  #0
00:8914 B123            	   928:   lda  (PCODE),Y
00:8916 C90A            	   929:   cmp  #NL
00:8918 D022            	   930:   bne  editor_list_not_newline
                        	   931: 
                        	   932: editor_newline_processing:
00:891A A901            	   933:   lda  #EFLAG_SHOW_LINE
00:891C 04BC            	   934:   tsb  editor_flags
00:891E E6A2            	   935:   inc  current_line
00:8920 D002            	   936:   bne  editor_list_check_to_line
00:8922 E6A3            	   937:   inc  current_line+1
                        	   938: 
                        	   939: ;
                        	   940: ;  see if we hit the wanted "to" line
                        	   941: ;
                        	   942: editor_list_check_to_line:
00:8924 A5A3            	   943:   lda  current_line+1
00:8926 C5A1            	   944:   cmp  to_line+1
00:8928 900A            	   945:   bcc  editor_list_check_to_line_ok
00:892A D024            	   946:   bne  editor_list_done
00:892C A5A2            	   947:   lda  current_line
00:892E C5A0            	   948:   cmp  to_line
00:8930 9002            	   949:   bcc  editor_list_check_to_line_ok
00:8932 D01C            	   950:   bne  editor_list_done
                        	   951: 
                        	   952: editor_list_check_to_line_ok:
                        	   953: 
00:8934 A940            	   954:   lda #EFLAG_SUPPRESS_NEWLINE
00:8936 25BC            	   955:   and editor_flags
00:8938 D00D            	   956:   bne editor_list_skip_newline
00:893A A90A            	   957:   lda #NL   ; put the newline back
                        	   958: 
                        	   959: ;
                        	   960: ;  just echo the character, and increment the memory address
                        	   961: ;
                        	   962: editor_list_not_newline:
00:893C AA              	   963:   tax
00:893D A904            	   964:   lda #FFLAG_QUIET
00:893F 25BD            	   965:   and find_flags
00:8941 D004            	   966:   bne editor_list_skip_newline
00:8943 8A              	   967:   txa
00:8944 20A492          	   968:   jsr PRCHAR
                        	   969: 
                        	   970: editor_list_skip_newline:
00:8947 E623            	   971:   inc PCODE
00:8949 D002            	   972:   bne editor_list_loopJ
00:894B E624            	   973:   inc PCODE+1
                        	   974: 
                        	   975: editor_list_loopJ:
00:894D 4C4188          	   976:   jmp editor_list_loop
                        	   977: 
                        	   978: editor_list_done:
00:8950 204792          	   979:   jsr CROUT
                        	   980: 
00:8953 A5B9            	   981:   lda find_count
00:8955 05BA            	   982:   ora find_count+1
00:8957 F014            	   983:   beq  editor_list_completely_done
00:8959 A5B9            	   984:   lda find_count
00:895B 8500            	   985:   sta REG
00:895D A5BA            	   986:   lda find_count+1
00:895F 8501            	   987:   sta REG+1
00:8961 6402            	   988:   stz REGB
00:8963 207191          	   989:   jsr display_in_decimal
00:8966 A97D            	   990:   lda #<found_message
00:8968 A286            	   991:   ldx #>found_message
00:896A 202682          	   992:   jsr print
                        	   993: 
                        	   994: editor_list_completely_done:
00:896D 4C8282          	   995:   jmp main_prompt
                        	   996: 
                        	   997: ;
                        	   998: ;  This if for replacing when the lengths differ
                        	   999: ;
                        	  1000: editor_do_replace:
                        	  1001: ;
                        	  1002: ; add our current find_pos to PCODE to get where we are in memory
                        	  1003: ;
00:8970 18              	  1004:   clc
00:8971 A523            	  1005:   lda  PCODE
00:8973 48              	  1006:   pha   ; save where we currently are
00:8974 65B2            	  1007:   adc  find_pos
00:8976 85A6            	  1008:   sta  mem_move_src
00:8978 A524            	  1009:   lda  PCODE+1
00:897A 48              	  1010:   pha
00:897B 6900            	  1011:   adc  #0
00:897D 85A7            	  1012:   sta  mem_move_src+1
                        	  1013: 
                        	  1014: ;
                        	  1015: ;  add the source string length as we don't need to copy that
                        	  1016: ;
00:897F 18              	  1017:   clc
00:8980 A5A6            	  1018:   lda mem_move_src
00:8982 65B3            	  1019:   adc find_len
00:8984 85A6            	  1020:   sta mem_move_src
00:8986 A5A7            	  1021:   lda mem_move_src+1
00:8988 6900            	  1022:   adc #0
00:898A 85A7            	  1023:   sta mem_move_src+1
                        	  1024: 
                        	  1025: ;
                        	  1026: ;  the move destination is the source plus the replacement length
                        	  1027: ;   (ie. a gap of the difference in bytes)
                        	  1028: 
00:898C 18              	  1029:   clc
00:898D A5A6            	  1030:   lda mem_move_src
00:898F 65B7            	  1031:   adc rep_diff
00:8991 85A8            	  1032:   sta mem_move_dest
00:8993 A5A7            	  1033:   lda mem_move_src+1
00:8995 65B8            	  1034:   adc rep_diff+1
00:8997 85A9            	  1035:   sta mem_move_dest+1
                        	  1036: 
                        	  1037: 
00:8999 20878C          	  1038:   jsr find_source_end   ; goes into PCODE
                        	  1039: ;
                        	  1040: ;  the length to move will be (the end of the source) - (the start of the move)
                        	  1041: ;
00:899C 38              	  1042:   sec
00:899D A523            	  1043:   lda PCODE
00:899F E5A6            	  1044:   sbc mem_move_src
00:89A1 85AA            	  1045:   sta mem_move_len
00:89A3 A524            	  1046:   lda PCODE+1
00:89A5 E5A7            	  1047:   sbc mem_move_src+1
00:89A7 85AB            	  1048:   sta mem_move_len+1
                        	  1049: 
00:89A9 A5B8            	  1050:   lda rep_diff+1
00:89AB 3005            	  1051:   bmi editor_do_replace_smaller
00:89AD 20A681          	  1052:   jsr moveup      ; replacing with larger string
00:89B0 8003            	  1053:   bra editor_do_replace_copy_done
                        	  1054: 
                        	  1055: editor_do_replace_smaller:
00:89B2 207A81          	  1056:   jsr movedown    ; replacing with smaller string
                        	  1057: 
                        	  1058: editor_do_replace_copy_done:
                        	  1059: ;
                        	  1060: ;  get the current source address back
                        	  1061: ;
00:89B5 68              	  1062:   pla
00:89B6 8524            	  1063:   sta  PCODE+1
00:89B8 68              	  1064:   pla
00:89B9 8523            	  1065:   sta  PCODE
00:89BB 4CE388          	  1066:   jmp  editor_easy_replace    ; now move in new string
                        	  1067: 
                        	  1068: 
00:89BE 456E74657220736F	  1069: load_message asciiz "Enter source, terminate with Esc\n"
00:89C6 757263652C207465
00:89CE 726D696E61746520
00:89D6 7769746820457363
00:89DE 0A
00:89DF 00
                        	  1070: 
                        	  1071: ;--------------------------------------------
                        	  1072: ;  INSERT / LOAD
                        	  1073: ;--------------------------------------------
                        	  1074: editor_load:
                        	  1075: 
00:89E0 A904            	  1076:   lda #EFLAG_LOAD
00:89E2 85BC            	  1077:   sta editor_flags
                        	  1078: 
                        	  1079: editor_insert:
00:89E4 203085          	  1080:   jsr editor_get_number
00:89E7 9015            	  1081:   bcc editor_insert_at_start
                        	  1082: 
                        	  1083:   ;
                        	  1084:   ; I really want to insert AFTER this line so I'll add 1 to whatever line number they gave
                        	  1085:   ; To insert at the start use Insert without a line number
                        	  1086:   ;
00:89E9 18              	  1087:   clc
00:89EA A594            	  1088:   lda token_value
00:89EC 6901            	  1089:   adc #1
00:89EE 85AC            	  1090:   sta this_line
00:89F0 A595            	  1091:   lda token_value+1
00:89F2 6900            	  1092:   adc #0
00:89F4 85AD            	  1093:   sta this_line+1
                        	  1094: 
00:89F6 200E86          	  1095:   jsr editor_check_no_more
00:89F9 20538C          	  1096:   jsr find_line    ; find the "from" line address
00:89FC 800E            	  1097:   bra editor_insert_common
                        	  1098: 
                        	  1099: editor_insert_at_start:
00:89FE A900            	  1100:   lda #<TEXT_START
00:8A00 85AE            	  1101:   sta this_line_addr
00:8A02 A903            	  1102:   lda #>TEXT_START
00:8A04 85AF            	  1103:   sta this_line_addr+1
00:8A06 A901            	  1104:   lda #1
00:8A08 85A2            	  1105:   sta current_line    ; current line number (1)
00:8A0A 64A3            	  1106:   stz current_line+1
                        	  1107: 
                        	  1108: editor_insert_common:
00:8A0C 20878C          	  1109:   jsr find_source_end
                        	  1110: 
                        	  1111: ;
                        	  1112: ;  move existing source to end of RAM
                        	  1113: ;
00:8A0F 38              	  1114:   sec
00:8A10 A523            	  1115:   lda PCODE
00:8A12 E5AE            	  1116:   sbc this_line_addr
00:8A14 85AA            	  1117:   sta mem_move_len
00:8A16 A524            	  1118:   lda PCODE+1
00:8A18 E5AF            	  1119:   sbc this_line_addr+1
00:8A1A 85AB            	  1120:   sta mem_move_len+1
                        	  1121: 
                        	  1122: ;
                        	  1123: ;  find where to move to
                        	  1124: ;
00:8A1C 38              	  1125:   sec
00:8A1D A9FF            	  1126:   lda #<HIGHEST_RAM
00:8A1F E5AA            	  1127:   sbc mem_move_len
00:8A21 85A8            	  1128:   sta mem_move_dest
00:8A23 85A4            	  1129:   sta insert_limit
00:8A25 A93F            	  1130:   lda #>HIGHEST_RAM
00:8A27 E5AB            	  1131:   sbc mem_move_len+1
00:8A29 85A9            	  1132:   sta mem_move_dest+1
00:8A2B 85A5            	  1133:   sta insert_limit+1
                        	  1134: 
                        	  1135: ;
                        	  1136: ;  the source of the move
                        	  1137: ;
00:8A2D A5AE            	  1138:   lda this_line_addr
00:8A2F 85A6            	  1139:   sta mem_move_src
00:8A31 A5AF            	  1140:   lda this_line_addr+1
00:8A33 85A7            	  1141:   sta mem_move_src+1
                        	  1142: 
00:8A35 20A681          	  1143:   jsr moveup
                        	  1144: 
                        	  1145: ;
                        	  1146: ;  put input at from_line_addr
                        	  1147: ;
                        	  1148: 
00:8A38 A5AE            	  1149:   lda this_line_addr
00:8A3A 8523            	  1150:   sta PCODE
00:8A3C A5AF            	  1151:   lda this_line_addr+1
00:8A3E 8524            	  1152:   sta PCODE+1
                        	  1153: 
00:8A40 A9BE            	  1154:   lda  #<load_message
00:8A42 A289            	  1155:   ldx  #>load_message
00:8A44 202682          	  1156:   jsr  print
                        	  1157: 
                        	  1158: ;
                        	  1159: ;  show the first line number
                        	  1160: ;
                        	  1161: 
00:8A47 A901            	  1162:   lda #EFLAG_SHOW_LINE
00:8A49 04BC            	  1163:   tsb editor_flags
00:8A4B A000            	  1164:   ldy #0    ; offset from PCODE for inserting (should always be zero)
00:8A4D A200            	  1165:   ldx #0    ; last character we inserted
                        	  1166: 
                        	  1167: editor_insert_loop:
00:8A4F A904            	  1168:   lda #EFLAG_LOAD         ; no line numbers on load
00:8A51 25BC            	  1169:   and editor_flags
00:8A53 D00B            	  1170:   bne editor_insert_no_line_number
                        	  1171: 
00:8A55 A5BC            	  1172:   lda editor_flags
00:8A57 2901            	  1173:   and #EFLAG_SHOW_LINE
00:8A59 F005            	  1174:   beq  editor_insert_no_line_number
                        	  1175: ;
                        	  1176: ;  display the line number
                        	  1177: ;
                        	  1178: 
00:8A5B 64BC            	  1179:   stz editor_flags      ; cancel flag until next newline
00:8A5D 20158C          	  1180:   jsr show_current_line_number
                        	  1181: 
                        	  1182: editor_insert_no_line_number:
00:8A60 2018C9          	  1183:   jsr  CHRIN
00:8A63 C90D            	  1184:   cmp  #CR                          ; carriage-return?
00:8A65 F0F9            	  1185:   beq  editor_insert_no_line_number ; yes, ignore
00:8A67 C91B            	  1186:   cmp  #END_EDITOR_INPUT            ; Esc?
00:8A69 F04F            	  1187:   beq  editor_insert_done
00:8A6B C908            	  1188:   cmp  #BACKSPACE
00:8A6D F029            	  1189:   beq  editor_insert_backspace
00:8A6F C90A            	  1190:   cmp  #NL
00:8A71 D00C            	  1191:   bne  editor_insert_not_newline
00:8A73 A901            	  1192:   lda  #EFLAG_SHOW_LINE
00:8A75 04BC            	  1193:   tsb  editor_flags
00:8A77 A90A            	  1194:   lda  #NL            ; get the newline back
00:8A79 E6A2            	  1195:   inc  current_line
00:8A7B D002            	  1196:   bne  editor_insert_not_newline
00:8A7D E6A3            	  1197:   inc  current_line+1
                        	  1198: editor_insert_not_newline:
00:8A7F 9123            	  1199:   sta  (PCODE),y
00:8A81 AA              	  1200:   tax                ; for detecting final newline
00:8A82 E623            	  1201:   inc  PCODE
00:8A84 D002            	  1202:   bne  editor_insert_loop1
00:8A86 E624            	  1203:   inc  PCODE+1
                        	  1204: 
                        	  1205: editor_insert_loop1:
00:8A88 A5A5            	  1206:   lda  insert_limit+1
00:8A8A C524            	  1207:   cmp  PCODE+1
00:8A8C B0C1            	  1208:   bcs  editor_insert_loop   ; carry is SET if we didn't borrow
00:8A8E D056            	  1209:   bne  editor_too_full
00:8A90 A5A4            	  1210:   lda  insert_limit
00:8A92 C523            	  1211:   cmp  PCODE
00:8A94 F050            	  1212:   beq  editor_too_full
00:8A96 80B7            	  1213:   bra  editor_insert_loop
                        	  1214: 
                        	  1215: ;
                        	  1216: ;  backspace reduces our pointer by one, unless we are at the start
                        	  1217: ;
                        	  1218: editor_insert_backspace:
00:8A98 A523            	  1219:   lda PCODE
00:8A9A C5AE            	  1220:   cmp this_line_addr
00:8A9C D006            	  1221:   bne editor_insert_backspace_not_at_start
00:8A9E A524            	  1222:   lda PCODE+1
00:8AA0 C5AF            	  1223:   cmp this_line_addr+1
00:8AA2 F0AB            	  1224:   beq editor_insert_loop    ; at start, ignore backspace
                        	  1225: 
                        	  1226: editor_insert_backspace_not_at_start:
00:8AA4 38              	  1227:   sec                       ; move source pointer back one
00:8AA5 A523            	  1228:   lda PCODE
00:8AA7 E901            	  1229:   sbc #1
00:8AA9 8523            	  1230:   sta PCODE
00:8AAB A524            	  1231:   lda PCODE+1
00:8AAD E900            	  1232:   sbc #0
00:8AAF 8524            	  1233:   sta PCODE+1
00:8AB1 B123            	  1234:   lda (PCODE),y
00:8AB3 AA              	  1235:   tax                      ; this is now the last character we inserted
                        	  1236: ;
                        	  1237: ;  however we don't want them backspacing over a previous line, so if we detect a newline
                        	  1238: ;  just go back up and put it back (and increment PCODE back to where it was)
                        	  1239: ;
00:8AB4 C90A            	  1240:   cmp #NL
00:8AB6 F0C7            	  1241:   beq editor_insert_not_newline
00:8AB8 8095            	  1242:   bra editor_insert_loop
                        	  1243: 
                        	  1244: editor_insert_done:
00:8ABA 8A              	  1245:   txa
00:8ABB F00E            	  1246:   beq editor_insert_done_with_newline   ; nothing got inserted at all
00:8ABD C90A            	  1247:   cmp #NL
00:8ABF F00A            	  1248:   beq editor_insert_done_with_newline  ; skip inserting a newline if we just got a newline
                        	  1249: ;
                        	  1250: ;  They finished inserting, but without a newline ... add one
                        	  1251: ;
00:8AC1 A90A            	  1252:   lda #NL
00:8AC3 9123            	  1253:   sta (PCODE),y
00:8AC5 E623            	  1254:   inc PCODE
00:8AC7 D002            	  1255:   bne editor_insert_done_with_newline
00:8AC9 E624            	  1256:   inc PCODE+1
                        	  1257: 
                        	  1258: ;
                        	  1259: ;  they are done - copy the rest back to the end of where they just inserted
                        	  1260: ;
                        	  1261: editor_insert_done_with_newline:
                        	  1262: 
00:8ACB 64BE            	  1263:   stz system_flags     ; compile is not valid any more
                        	  1264: 
00:8ACD A523            	  1265:   lda PCODE
00:8ACF 85A8            	  1266:   sta mem_move_dest
00:8AD1 A524            	  1267:   lda PCODE+1
00:8AD3 85A9            	  1268:   sta mem_move_dest+1
                        	  1269: 
00:8AD5 A5A4            	  1270:   lda insert_limit
00:8AD7 85A6            	  1271:   sta mem_move_src
00:8AD9 A5A5            	  1272:   lda insert_limit+1
00:8ADB 85A7            	  1273:   sta mem_move_src+1
                        	  1274: 
00:8ADD 207A81          	  1275:   jsr movedown
                        	  1276: 
00:8AE0 204792          	  1277:   jsr CROUT   ; put a newline after the ESC character
00:8AE3 4C8282          	  1278:   jmp main_prompt
                        	  1279: 
                        	  1280: editor_too_full:
00:8AE6 A911            	  1281:   lda #<memory_full
00:8AE8 A28B            	  1282:   ldx #>memory_full
00:8AEA 202682          	  1283:   jsr print
                        	  1284: ;
                        	  1285: ;  consume input so it isn't mistaken for a command
                        	  1286: ;
                        	  1287: editor_too_full_loop:
00:8AED 2018C9          	  1288:   jsr CHRIN
00:8AF0 C91B            	  1289:   cmp #END_EDITOR_INPUT
00:8AF2 D0F9            	  1290:   bne editor_too_full_loop
                        	  1291: ;
                        	  1292: ;  another message, they may miss the first one during a bulk load
                        	  1293: ;
00:8AF4 A92C            	  1294:   lda #<memory_filled_up
00:8AF6 A28B            	  1295:   ldx #>memory_filled_up
00:8AF8 202682          	  1296:   jsr print
00:8AFB 4CBA8A          	  1297:   jmp editor_insert_done
                        	  1298: 
00:8AFE 4E6F2072616E6765	  1299: editor_no_lines  asciiz "No range supplied\n"
00:8B06 20737570706C6965
00:8B0E 640A
00:8B10 00
00:8B11 0A0A4D656D6F7279	  1300: memory_full      asciiz "\n\nMemory full - press Esc\n"
00:8B19 2066756C6C202D20
00:8B21 7072657373204573
00:8B29 630A
00:8B2B 00
00:8B2C 0A0A4E6F20726F6F	  1301: memory_filled_up asciiz "\n\nNo room for source during load/input\n\n"
00:8B34 6D20666F7220736F
00:8B3C 7572636520647572
00:8B44 696E67206C6F6164
00:8B4C 2F696E7075740A0A
00:8B54 00
                        	  1302: 
                        	  1303: ;
                        	  1304: ;  subroutine to check we got a range for certain actions
                        	  1305: ;
                        	  1306: editor_argument_check:
00:8B55 A000            	  1307:   ldy #0
                        	  1308: ;
                        	  1309: ;  skip spaces to make sure we got a range
                        	  1310: ;
                        	  1311: editor_argument_check_loop:
00:8B57 B18E            	  1312:   lda (token_start),y
00:8B59 F00C            	  1313:   beq editor_argument_check_failed
00:8B5B C90A            	  1314:   cmp #NL
00:8B5D F008            	  1315:   beq editor_argument_check_failed
00:8B5F 204A81          	  1316:   jsr isspace
00:8B62 900D            	  1317:   bcc editor_argument_check_got_argument
00:8B64 C8              	  1318:   iny
00:8B65 D0F0            	  1319:   bne editor_argument_check_loop
                        	  1320: 
                        	  1321: ;
                        	  1322: ;  only found spaces, not good enough
                        	  1323: ;
                        	  1324: editor_argument_check_failed:
00:8B67 A9FE            	  1325:   lda #<editor_no_lines
00:8B69 A28A            	  1326:   ldx #>editor_no_lines
00:8B6B 202682          	  1327:   jsr print
00:8B6E 4C8282          	  1328:   jmp  main_prompt
                        	  1329: 
                        	  1330: editor_argument_check_got_argument:
00:8B71 60              	  1331:   rts
                        	  1332: 
                        	  1333: 
                        	  1334: ;--------------------------------------------
                        	  1335: ;  DELETE
                        	  1336: ;--------------------------------------------
                        	  1337: editor_delete:
                        	  1338: ;
                        	  1339: ;  default to no lines
                        	  1340: ;
00:8B72 649E            	  1341:   stz from_line
00:8B74 649F            	  1342:   stz from_line+1
00:8B76 64A0            	  1343:   stz to_line
00:8B78 64A1            	  1344:   stz to_line+1
                        	  1345: 
00:8B7A 64B9            	  1346:   stz find_count      ; delete count in this case
00:8B7C 64BA            	  1347:   stz find_count+1
00:8B7E 20558B          	  1348:   jsr editor_argument_check ; cannot get away with no arguments
                        	  1349: 
00:8B81 202B86          	  1350:   jsr editor_get_range
00:8B84 200E86          	  1351:   jsr editor_check_no_more
                        	  1352: 
00:8B87 A59E            	  1353:   lda from_line
00:8B89 85AC            	  1354:   sta this_line
00:8B8B A59F            	  1355:   lda from_line+1
00:8B8D 85AD            	  1356:   sta this_line+1
00:8B8F 20538C          	  1357:   jsr find_line       ; find the "from" line address
00:8B92 A5AE            	  1358:   lda this_line_addr  ; that becomes the destination of the move
00:8B94 85A8            	  1359:   sta mem_move_dest
00:8B96 A5AF            	  1360:   lda this_line_addr+1
00:8B98 85A9            	  1361:   sta mem_move_dest+1
00:8B9A 64AA            	  1362:   stz mem_move_len
00:8B9C 64AB            	  1363:   stz mem_move_len+1
                        	  1364: ;
                        	  1365: ;  now we'll work our way up until we get to the to_line, however we'll
                        	  1366: ;  add one because we want the final address to actually be the start of
                        	  1367: ;  the NEXT line
                        	  1368: ;
00:8B9E 18              	  1369:   clc
00:8B9F A5A0            	  1370:   lda to_line
00:8BA1 6901            	  1371:   adc #1
00:8BA3 85AC            	  1372:   sta this_line
00:8BA5 A5A1            	  1373:   lda to_line+1
00:8BA7 6900            	  1374:   adc #0
00:8BA9 85AD            	  1375:   sta this_line+1
00:8BAB 20618C          	  1376:   jsr find_line_loop    ; find the "to" line address
00:8BAE A5AE            	  1377:   lda this_line_addr  ; that becomes the destination of the move
00:8BB0 85A6            	  1378:   sta mem_move_src
00:8BB2 A5AF            	  1379:   lda this_line_addr+1
00:8BB4 85A7            	  1380:   sta mem_move_src+1
                        	  1381: 
                        	  1382: ;
                        	  1383: ;  count how many lines we delete by counting newlines from
                        	  1384: ;   mem_move_dest to mem_move_src
                        	  1385: ;
                        	  1386: 
00:8BB6 A5A8            	  1387:   lda mem_move_dest
00:8BB8 8523            	  1388:   sta PCODE
00:8BBA A5A9            	  1389:   lda mem_move_dest+1
00:8BBC 8524            	  1390:   sta PCODE+1
00:8BBE A000            	  1391:   ldy #0
                        	  1392: 
                        	  1393: editor_delete_line_count_loop:
00:8BC0 A523            	  1394:   lda PCODE
00:8BC2 C5A6            	  1395:   cmp mem_move_src
00:8BC4 D006            	  1396:   bne editor_delete_line_count_not_done
00:8BC6 A524            	  1397:   lda PCODE+1
00:8BC8 C5A7            	  1398:   cmp mem_move_src+1
00:8BCA F014            	  1399:   beq editor_delete_line_count_done
                        	  1400: 
                        	  1401: editor_delete_line_count_not_done:
00:8BCC B123            	  1402:   lda (PCODE),y
00:8BCE C90A            	  1403:   cmp #NL
00:8BD0 D006            	  1404:   bne editor_delete_line_count_not_newline
00:8BD2 E6B9            	  1405:   inc find_count
00:8BD4 D002            	  1406:   bne editor_delete_line_count_not_newline
00:8BD6 E6BA            	  1407:   inc find_count+1
                        	  1408: editor_delete_line_count_not_newline:
00:8BD8 E623            	  1409:   inc PCODE
00:8BDA D0E4            	  1410:   bne editor_delete_line_count_loop
00:8BDC E624            	  1411:   inc PCODE+1
00:8BDE 80E0            	  1412:   bra editor_delete_line_count_loop
                        	  1413: 
                        	  1414: ;
                        	  1415: ;  now find where the source ends
                        	  1416: ;  PCODE will now be at the first line to not be deleted
                        	  1417: ;
                        	  1418: editor_delete_line_count_done:
                        	  1419: 
00:8BE0 208F8C          	  1420:   jsr find_source_end_loop
00:8BE3 38              	  1421:   sec
00:8BE4 A523            	  1422:   lda PCODE
00:8BE6 E5AE            	  1423:   sbc this_line_addr
00:8BE8 85AA            	  1424:   sta mem_move_len
00:8BEA A524            	  1425:   lda PCODE+1
00:8BEC E5AF            	  1426:   sbc this_line_addr+1
00:8BEE 85AB            	  1427:   sta mem_move_len+1
00:8BF0 207A81          	  1428:   jsr movedown  ; that should do it
                        	  1429: 
00:8BF3 A5B9            	  1430:   lda find_count
00:8BF5 8500            	  1431:   sta REG
00:8BF7 A5BA            	  1432:   lda find_count+1
00:8BF9 8501            	  1433:   sta REG+1
00:8BFB 6402            	  1434:   stz REGB
00:8BFD 207191          	  1435:   jsr display_in_decimal
00:8C00 A90A            	  1436:   lda #<lines_deleted_message
00:8C02 A28C            	  1437:   ldx #>lines_deleted_message
00:8C04 202682          	  1438:   jsr print
00:8C07 4C8282          	  1439:   jmp main_prompt
                        	  1440: 
00:8C0A 2064656C65746564	  1441: lines_deleted_message asciiz " deleted.\n"
00:8C12 2E0A
00:8C14 00
                        	  1442: 
                        	  1443: ;--------------------------------------------
                        	  1444: ;  show current line number with leading spaces
                        	  1445: ;--------------------------------------------
                        	  1446: show_current_line_number:
00:8C15 48              	  1447:   pha
00:8C16 DA              	  1448:   phx
00:8C17 5A              	  1449:   phy
                        	  1450: ;
                        	  1451: ;  get the line number into REG ready for printing
                        	  1452: ;
00:8C18 A5A2            	  1453:   lda current_line
00:8C1A 8500            	  1454:   sta REG
00:8C1C A6A3            	  1455:   ldx current_line+1
00:8C1E 8601            	  1456:   stx REG+1
00:8C20 A000            	  1457:   ldy #0        ; count of leading spaces
00:8C22 8402            	  1458:   sty REGB
00:8C24 E003            	  1459:   cpx #>1000    ; if the number is >= 1000 don't print any spaces
00:8C26 9006            	  1460:   bcc line_number_lt_1000
00:8C28 D013            	  1461:   bne line_number_output_spaces
00:8C2A C9E8            	  1462:   cmp #<1000
00:8C2C B00F            	  1463:   bcs line_number_output_spaces
                        	  1464: line_number_lt_1000:
00:8C2E C8              	  1465:   iny           ; output one space
00:8C2F E000            	  1466:   cpx  #0       ; if line number > 255 then one space is all we need
00:8C31 D00A            	  1467:   bne  line_number_output_spaces
00:8C33 C964            	  1468:   cmp  #100     ; if line number >= 100 then one space is all we need
00:8C35 B006            	  1469:   bcs  line_number_output_spaces
00:8C37 C8              	  1470:   iny           ; output two spaces
00:8C38 C90A            	  1471:   cmp  #10      ; if line number >= 10 then two spaces are all we need
00:8C3A B001            	  1472:   bcs  line_number_output_spaces
00:8C3C C8              	  1473:   iny           ; output three spaces
                        	  1474: line_number_output_spaces:
00:8C3D C000            	  1475:   cpy #0            ; leading spaces in front of line number
00:8C3F F008            	  1476:   beq  show_current_line_number_done
00:8C41 5A              	  1477:   phy
00:8C42 20D292          	  1478:   jsr  PUTSP      ; output the space
00:8C45 7A              	  1479:   ply
00:8C46 88              	  1480:   dey             ; count them
00:8C47 D0F4            	  1481:   bne  line_number_output_spaces  ; more spaces to go
                        	  1482: show_current_line_number_done:
00:8C49 207191          	  1483:   jsr  display_in_decimal    ; now the actual number
00:8C4C 20D292          	  1484:   jsr  PUTSP      ; and a space after it
00:8C4F 7A              	  1485:   ply
00:8C50 FA              	  1486:   plx
00:8C51 68              	  1487:   pla
00:8C52 60              	  1488:   rts
                        	  1489: 
                        	  1490: ;--------------------------------------------
                        	  1491: ;  find_line
                        	  1492: ;
                        	  1493: ;  finds address of this_line in memory - returns in this_line_addr
                        	  1494: ;--------------------------------------------
                        	  1495: find_line:
00:8C53 A901            	  1496:   lda #1
00:8C55 85A2            	  1497:   sta current_line    ; current line number (1)
00:8C57 64A3            	  1498:   stz current_line+1
00:8C59 A900            	  1499:   lda #<TEXT_START   ; start at start of source
00:8C5B 85AE            	  1500:   sta this_line_addr
00:8C5D A903            	  1501:   lda #>TEXT_START
00:8C5F 85AF            	  1502:   sta this_line_addr+1
                        	  1503: find_line_loop:
00:8C61 A000            	  1504:   ldy #0
00:8C63 A5A2            	  1505:   lda current_line
00:8C65 C5AC            	  1506:   cmp this_line
00:8C67 D007            	  1507:   bne find_line_next
00:8C69 A5A3            	  1508:   lda current_line+1
00:8C6B C5AD            	  1509:   cmp this_line+1
00:8C6D D001            	  1510:   bne find_line_next
00:8C6F 60              	  1511:   rts
                        	  1512: find_line_next:
00:8C70 B1AE            	  1513:   lda (this_line_addr),Y
00:8C72 F012            	  1514:   beq find_line_eof
00:8C74 C90A            	  1515:   cmp #NL
00:8C76 D006            	  1516:   bne find_line_same_line
00:8C78 E6A2            	  1517:   inc current_line       ; add 1 to our line number counter
00:8C7A D002            	  1518:   bne find_line_same_line
00:8C7C E6A3            	  1519:   inc current_line+1
                        	  1520: find_line_same_line:
00:8C7E E6AE            	  1521:   inc this_line_addr     ; onto next address - which means that a newline
00:8C80 D0DF            	  1522:   bne find_line_loop     ; will actually end up being the start of the new
00:8C82 E6AF            	  1523:   inc this_line_addr+1   ; line, which is what we want
00:8C84 80DB            	  1524:   bra find_line_loop
                        	  1525: find_line_eof:           ; we are pointing to 0x00 - make that the address
00:8C86 60              	  1526:   rts
                        	  1527: 
                        	  1528: 
                        	  1529: 
                        	  1530: ;***********************************************
                        	  1531: ; Find text end
                        	  1532: ;***********************************************
                        	  1533: find_source_end:
00:8C87 A900            	  1534:   lda  #<TEXT_START        ; start at start of source
00:8C89 8523            	  1535:   sta  PCODE
00:8C8B A903            	  1536:   lda  #>TEXT_START
00:8C8D 8524            	  1537:   sta  PCODE+1
                        	  1538: find_source_end_loop =  *
00:8C8F A000            	  1539:   ldy  #0
00:8C91 B123            	  1540:   lda  (PCODE),Y             ; keep going until 0x00 indicates end of source
00:8C93 F008            	  1541:   beq  find_source_end_wrap
00:8C95 E623            	  1542:   inc  PCODE
00:8C97 D0F6            	  1543:   bne  find_source_end_loop
00:8C99 E624            	  1544:   inc  PCODE+1
00:8C9B 80F2            	  1545:   bra  find_source_end_loop
                        	  1546: ;
                        	  1547: ;  include final 0x00
                        	  1548: ;
                        	  1549: find_source_end_wrap =  *
00:8C9D E623            	  1550:   inc  PCODE
00:8C9F D002            	  1551:   bne  find_source_end_done
00:8CA1 E624            	  1552:   inc  PCODE+1
                        	  1553: find_source_end_done =  *
00:8CA3 60              	  1554:   rts
                        	  1555: 
                        	  1556: ;
                        	  1557: ;  testing BRK handling
                        	  1558: ;
00:8CA4 0A526573756D6564	  1559: brk_resumed asciiz "\nResumed after BRK\n"
00:8CAC 2061667465722042
00:8CB4 524B0A
00:8CB7 00
                        	  1560: 
                        	  1561: editor_test:
00:8CB8 A912            	  1562:   lda #$12
00:8CBA A223            	  1563:   ldx #$23
00:8CBC A042            	  1564:   ldy #$42
00:8CBE C912            	  1565:   cmp #$12
00:8CC0 00              	  1566:   brk
00:8CC1 99              	  1567:   dfb $99   ; break number
00:8CC2 A9A4            	  1568:   lda #<brk_resumed
00:8CC4 A28C            	  1569:   ldx #>brk_resumed
00:8CC6 202682          	  1570:   jsr print
00:8CC9 60              	  1571:   rts
                        	  1572: 
                        	  1573: ;
                        	  1574: ;  memory dump
                        	  1575: ;
                        	  1576: editor_memory:
00:8CCA 20558B          	  1577:   jsr editor_argument_check  ; check they supplied some sort of range
00:8CCD 200885          	  1578:   jsr editor_default_range
00:8CD0 A902            	  1579:   lda #EFLAG_ALLOW_ZERO_FROM
00:8CD2 85BC            	  1580:   sta editor_flags
00:8CD4 202B86          	  1581:   jsr editor_get_range
00:8CD7 200E86          	  1582:   jsr editor_check_no_more
00:8CDA 64A2            	  1583:   stz current_line      ; count of bytes shown
00:8CDC A59E            	  1584:   lda from_line
00:8CDE 85AE            	  1585:   sta this_line_addr
00:8CE0 A59F            	  1586:   lda from_line+1
00:8CE2 85AF            	  1587:   sta this_line_addr+1
                        	  1588: 
                        	  1589: editor_memory_loop:
00:8CE4 A58B            	  1590:   lda serial_in_byte_received
00:8CE6 C903            	  1591:   cmp  #KEY_ABORT
00:8CE8 F056            	  1592:   beq  editor_memory_aborted
                        	  1593: 
00:8CEA A5A2            	  1594:   lda current_line
00:8CEC D017            	  1595:   bne editor_memory_loop1
                        	  1596: ;
                        	  1597: ;  show address
                        	  1598: ;
00:8CEE A924            	  1599:   lda #'$'
00:8CF0 20CE93          	  1600:   jsr COUT
00:8CF3 A59F            	  1601:   lda from_line+1
00:8CF5 20BC92          	  1602:   jsr PRBYTE
00:8CF8 A59E            	  1603:   lda from_line
00:8CFA 20BC92          	  1604:   jsr PRBYTE
00:8CFD A93A            	  1605:   lda #':'
00:8CFF 20CE93          	  1606:   jsr COUT
00:8D02 20D292          	  1607:   jsr PUTSP
                        	  1608: editor_memory_loop1:
00:8D05 A000            	  1609:   ldy #0
00:8D07 B19E            	  1610:   lda (from_line),Y
00:8D09 20BC92          	  1611:   jsr PRBYTE
00:8D0C 20D292          	  1612:   jsr PUTSP
00:8D0F E6A2            	  1613:   inc current_line
00:8D11 E69E            	  1614:   inc from_line
00:8D13 D002            	  1615:   bne editor_memory_loop2
00:8D15 E69F            	  1616:   inc from_line+1
                        	  1617: editor_memory_loop2:
                        	  1618: ;
                        	  1619: ;  if we wrap around back to zero, stop
                        	  1620: ;
00:8D17 A59E            	  1621:   lda from_line
00:8D19 059F            	  1622:   ora from_line+1
00:8D1B F020            	  1623:   beq editor_memory_done
00:8D1D A59F            	  1624:   lda from_line+1
00:8D1F C5A1            	  1625:   cmp to_line+1
00:8D21 900A            	  1626:   bcc editor_memory_loop3   ; less than
00:8D23 D018            	  1627:   bne editor_memory_done    ; greater than
00:8D25 A59E            	  1628:   lda from_line             ; equal, so try low-order byte
00:8D27 C5A0            	  1629:   cmp to_line
00:8D29 9002            	  1630:   bcc editor_memory_loop3   ; less than
00:8D2B D010            	  1631:   bne editor_memory_done    ; greater than
                        	  1632: editor_memory_loop3:
00:8D2D A5A2            	  1633:   lda current_line
00:8D2F C910            	  1634:   cmp #16
00:8D31 90B1            	  1635:   bcc editor_memory_loop
00:8D33 20D292          	  1636:   jsr PUTSP
00:8D36 20468D          	  1637:   jsr editor_memory_show_ascii
00:8D39 64A2            	  1638:   stz current_line      ; count of bytes shown
00:8D3B 80A7            	  1639:   bra editor_memory_loop
                        	  1640: 
                        	  1641: editor_memory_done:
00:8D3D 20468D          	  1642:   jsr editor_memory_show_ascii
                        	  1643: editor_memory_aborted:
00:8D40 204792          	  1644:   jsr CROUT
00:8D43 4C8282          	  1645:   jmp  main_prompt
                        	  1646: 
                        	  1647: editor_memory_show_ascii:
                        	  1648: ;
                        	  1649: ;  now the ASCII equivalents
                        	  1650: ;
00:8D46 A000            	  1651:   ldy #0
                        	  1652: editor_memory_ascii:
00:8D48 B1AE            	  1653:   lda (this_line_addr),Y
00:8D4A C920            	  1654:   cmp #$20
00:8D4C B002            	  1655:   bcs editor_memory_not_control
00:8D4E 8004            	  1656:   bra editor_memory_show_dot
                        	  1657: editor_memory_not_control:
00:8D50 C97F            	  1658:   cmp #$7F
00:8D52 9002            	  1659:   bcc editor_memory_not_high
                        	  1660: editor_memory_show_dot
00:8D54 A92E            	  1661:   lda #'.'
                        	  1662: editor_memory_not_high:
00:8D56 20CE93          	  1663:   jsr COUT
00:8D59 20D292          	  1664:   jsr PUTSP
00:8D5C C8              	  1665:   iny
00:8D5D C6A2            	  1666:   dec current_line
00:8D5F D0E7            	  1667:   bne editor_memory_ascii
                        	  1668: ;
                        	  1669: ;  adjust the ASCII printing address
                        	  1670: ;
00:8D61 A59E            	  1671:   lda from_line
00:8D63 85AE            	  1672:   sta this_line_addr
00:8D65 A59F            	  1673:   lda from_line+1
00:8D67 85AF            	  1674:   sta this_line_addr+1
                        	  1675: 
00:8D69 204792          	  1676:   jsr CROUT
00:8D6C 60              	  1677:   rts
                        	  1678: 
                        	  1679: 
                        	  1680: 
                        	  1681: 
00:8D6D 4164647220507265	  1682: symbol_table_message asciiz "Addr Prev L  T Dsp  Ar Da Ln Name\n"
00:8D75 76204C2020542044
00:8D7D 7370202041722044
00:8D85 61204C6E204E616D
00:8D8D 650A
00:8D8F 00
                        	  1683: 
                        	  1684: editor_symbol_table_list  = *
00:8D90 A96D            	  1685:   lda #<symbol_table_message
00:8D92 A28D            	  1686:   ldx #>symbol_table_message
00:8D94 202682          	  1687:   jsr print
                        	  1688: 
00:8D97 A532            	  1689:   lda  ENDSYM+1    ; get the end of the symbol table
00:8D99 8541            	  1690:   sta  SYMITM+1    ; make it the current symbol
00:8D9B A531            	  1691:   lda  ENDSYM
00:8D9D 800B            	  1692:   bra  ST_SYMTBL_LIST_CHECK
                        	  1693: 
                        	  1694: ST_SYMTBL_LIST_NEXT =  *
00:8D9F A000            	  1695:   ldy  #SYMPRV
00:8DA1 B140            	  1696:   lda  (SYMITM),Y
00:8DA3 AA              	  1697:   tax
00:8DA4 C8              	  1698:   iny
00:8DA5 B140            	  1699:   lda  (SYMITM),Y
00:8DA7 8541            	  1700:   sta  SYMITM+1   ; previous link
00:8DA9 8A              	  1701:   txa
                        	  1702: ;
                        	  1703: ;  go to the previous symbol table item
                        	  1704: ;
                        	  1705: ST_SYMTBL_LIST_CHECK     =  *
00:8DAA 8540            	  1706:   sta  SYMITM
00:8DAC C9FF            	  1707:   cmp  #<SYMBOL_TABLE_START
00:8DAE D009            	  1708:   bne  ST_SYMTBL_LIST_LINE
00:8DB0 A541            	  1709:   lda  SYMITM+1
00:8DB2 C93F            	  1710:   cmp  #>SYMBOL_TABLE_START
00:8DB4 D003            	  1711:   bne  ST_SYMTBL_LIST_LINE       ; more to go
00:8DB6 4C3F8E          	  1712:   jmp  ST_SYMTBL_LIST_DONE       ; finished if symitm and symitm+1 are both zero
                        	  1713: 
                        	  1714: ST_SYMTBL_LIST_LINE = *
00:8DB9 A541            	  1715:   lda  SYMITM+1
00:8DBB 20BC92          	  1716:   jsr  PRBYTE
00:8DBE A540            	  1717:   lda  SYMITM
00:8DC0 20BC92          	  1718:   jsr  PRBYTE
00:8DC3 A920            	  1719:   lda  #' '
00:8DC5 20A492          	  1720:   jsr  PRCHAR
00:8DC8 A001            	  1721:   ldy  #SYMPRV+1
00:8DCA B140            	  1722:   lda  (SYMITM),Y
00:8DCC 20BC92          	  1723:   jsr  PRBYTE
00:8DCF 88              	  1724:   dey
00:8DD0 B140            	  1725:   lda  (SYMITM),Y
00:8DD2 20BC92          	  1726:   jsr  PRBYTE
00:8DD5 A920            	  1727:   lda  #' '
00:8DD7 20A492          	  1728:   jsr  PRCHAR
00:8DDA A002            	  1729:   ldy  #SYMLVL
00:8DDC B140            	  1730:   lda  (SYMITM),Y  ; level
00:8DDE 20BC92          	  1731:   jsr  PRBYTE
00:8DE1 A920            	  1732:   lda  #' '
00:8DE3 20A492          	  1733:   jsr  PRCHAR
00:8DE6 A003            	  1734:   ldy  #SYMTYP
00:8DE8 B140            	  1735:   lda  (SYMITM),Y  ; type
00:8DEA 20A492          	  1736:   jsr  PRCHAR
00:8DED A920            	  1737:   lda  #' '
00:8DEF 20A492          	  1738:   jsr  PRCHAR
00:8DF2 A004            	  1739:   ldy  #SYMDSP
00:8DF4 C8              	  1740:   iny
00:8DF5 B140            	  1741:   lda  (SYMITM),Y  ; displacement
00:8DF7 20BC92          	  1742:   jsr  PRBYTE
00:8DFA 88              	  1743:   dey
00:8DFB B140            	  1744:   lda  (SYMITM),Y  ; displacement
00:8DFD 20BC92          	  1745:   jsr  PRBYTE
00:8E00 A920            	  1746:   lda  #' '
00:8E02 20A492          	  1747:   jsr  PRCHAR
00:8E05 A006            	  1748:   ldy  #SYMARG
00:8E07 B140            	  1749:   lda  (SYMITM),Y  ; argument count
00:8E09 20BC92          	  1750:   jsr  PRBYTE
00:8E0C A920            	  1751:   lda  #' '
00:8E0E 20A492          	  1752:   jsr  PRCHAR
00:8E11 A008            	  1753:   ldy  #SYMDAT
00:8E13 B140            	  1754:   lda  (SYMITM),Y  ; data type
00:8E15 20BC92          	  1755:   jsr  PRBYTE
00:8E18 A920            	  1756:   lda  #' '
00:8E1A 20A492          	  1757:   jsr  PRCHAR
00:8E1D A009            	  1758:   ldy  #SYMLEN
00:8E1F B140            	  1759:   lda  (SYMITM),Y  ; length
00:8E21 48              	  1760:   pha
00:8E22 20BC92          	  1761:   jsr  PRBYTE
00:8E25 A920            	  1762:   lda  #' '
00:8E27 20A492          	  1763:   jsr  PRCHAR
00:8E2A A00A            	  1764:   ldy  #SYMNAM
00:8E2C 68              	  1765:   pla
00:8E2D AA              	  1766:   tax
                        	  1767: ST_SYMTBL_LIST_NAME = *
00:8E2E B140            	  1768:   lda  (SYMITM),Y  ; name
00:8E30 5A              	  1769:   phy
00:8E31 20A492          	  1770:   jsr  PRCHAR
00:8E34 7A              	  1771:   ply
00:8E35 C8              	  1772:   iny
00:8E36 CA              	  1773:   dex
00:8E37 D0F5            	  1774:   bne ST_SYMTBL_LIST_NAME
00:8E39 204792          	  1775:   jsr CROUT
00:8E3C 4C9F8D          	  1776:   jmp ST_SYMTBL_LIST_NEXT
                        	  1777: 
                        	  1778: ST_SYMTBL_LIST_DONE = *
                        	  1779: 
00:8E3F 4C8282          	  1780:   jmp main_prompt
                        	  1781: 
                        	  1782: 
00:8E42 446F6E650A      	  1783: recover_done asciiz "Done\n"
00:8E47 00
00:8E48 4E6F74206E656564	  1784: recover_not_needed asciiz "Not needed\n"
00:8E50 65640A
00:8E53 00
                        	  1785: 
                        	  1786: ;
                        	  1787: ; Recover: if the first byte of the source is 0x00, change it to a space
                        	  1788: ;
                        	  1789: editor_recover:
00:8E54 200E86          	  1790:   jsr editor_check_no_more
00:8E57 A900            	  1791:   lda  #<TEXT_START
00:8E59 8540            	  1792:   sta  FROM
00:8E5B A903            	  1793:   lda  #>TEXT_START
00:8E5D 8541            	  1794:   sta  FROM+1
00:8E5F A000            	  1795:   ldy  #0
00:8E61 B140            	  1796:   lda  (FROM),Y
00:8E63 D00E            	  1797:   bne  editor_recover_not_needed
00:8E65 A920            	  1798:   lda  #' '
00:8E67 9140            	  1799:   sta  (FROM),Y
00:8E69 A942            	  1800:   lda #<recover_done
00:8E6B A28E            	  1801:   ldx #>recover_done
00:8E6D 202682          	  1802:   jsr print
00:8E70 4C8282          	  1803:   jmp main_prompt
                        	  1804: 
                        	  1805: editor_recover_not_needed:
00:8E73 A948            	  1806:   lda #<recover_not_needed
00:8E75 A28E            	  1807:   ldx #>recover_not_needed
00:8E77 202682          	  1808:   jsr print
00:8E7A 4C8282          	  1809:   jmp main_prompt
                        	  1810: 
                        	  1811: 
                        	  1812: editor_debug:
00:8E7D 200E86          	  1813:   jsr editor_check_no_more
00:8E80 A901            	  1814:   lda #1
00:8E82 8549            	  1815:   sta  DBGFLG
00:8E84 852E            	  1816:   sta  DCODE
00:8E86 4C8A93          	  1817:   jmp  CHK_RUN
                        	  1818: 
                        	  1819: editor_trace:
00:8E89 200E86          	  1820:   jsr editor_check_no_more
00:8E8C A980            	  1821:   lda  #$80
00:8E8E 8549            	  1822:   sta  DBGFLG
00:8E90 852E            	  1823:   sta  DCODE
00:8E92 4C8A93          	  1824:   jmp  CHK_RUN
                        	  1825: 
                        	  1826: 
                        	  1827: editor_info  = *
00:8E95 200E86          	  1828:   jsr editor_check_no_more
00:8E98 20118F          	  1829:   jsr show_source_start
00:8E9B 20E98E          	  1830:   jsr show_source_end
00:8E9E 20A290          	  1831:   jsr crc_source
00:8EA1 4C8282          	  1832:   jmp main_prompt
                        	  1833: 
                        	  1834: editor_compile:
00:8EA4 200E86          	  1835:   jsr editor_check_no_more
00:8EA7 A900            	  1836:   lda  #0
00:8EA9 8542            	  1837:   sta  SYNTAX
00:8EAB 4C4FBA          	  1838:   jmp  COMPIL
                        	  1839: 
                        	  1840: editor_syntax:
00:8EAE 200E86          	  1841:   jsr editor_check_no_more
00:8EB1 A901            	  1842:   lda #1
00:8EB3 8542            	  1843:   sta  SYNTAX
00:8EB5 4C4FBA          	  1844:   jmp  COMPIL
                        	  1845: 
                        	  1846: editor_run:
00:8EB8 200E86          	  1847:   jsr editor_check_no_more
00:8EBB A900            	  1848:   lda  #0
00:8EBD 8549            	  1849:   sta  DBGFLG
00:8EBF 852E            	  1850:   sta  DCODE
00:8EC1 4C8A93          	  1851:   jmp  CHK_RUN
                        	  1852: 
                        	  1853:   ;
                        	  1854: show_symbol_table_end:
00:8EC4 A92F            	  1855:   lda  #<symbol_table_ended_message    ; Symbol table ended at
00:8EC6 A293            	  1856:   ldx  #>symbol_table_ended_message
00:8EC8 202682          	  1857:   jsr  print
00:8ECB A532            	  1858:   lda  ENDSYM+1
00:8ECD 20BC92          	  1859:   jsr  PRBYTE
00:8ED0 A531            	  1860:   lda  ENDSYM
00:8ED2 207193          	  1861:   jsr  PRBYTECR
00:8ED5 60              	  1862:   rts
                        	  1863: 
                        	  1864: 
00:8ED6 536F757263652065	  1865: source_ended_message asciiz "Source ends   at $"
00:8EDE 6E64732020206174
00:8EE6 2024
00:8EE8 00
                        	  1866: show_source_end:
00:8EE9 A9D6            	  1867:   lda #<source_ended_message
00:8EEB A28E            	  1868:   ldx #>source_ended_message
00:8EED 202682          	  1869:   jsr print
00:8EF0 20878C          	  1870:   jsr find_source_end
00:8EF3 A524            	  1871:   lda PCODE+1
00:8EF5 20BC92          	  1872:   jsr PRBYTE
00:8EF8 A523            	  1873:   lda PCODE
00:8EFA 207193          	  1874:   jsr PRBYTECR
00:8EFD 60              	  1875:   rts
                        	  1876: 
00:8EFE 536F757263652073	  1877: source_starts_message asciiz "Source starts at $"    ; source starts at
00:8F06 7461727473206174
00:8F0E 2024
00:8F10 00
                        	  1878: show_source_start:
00:8F11 A9FE            	  1879:   lda #<source_starts_message
00:8F13 A28E            	  1880:   ldx #>source_starts_message
00:8F15 202682          	  1881:   jsr print
00:8F18 A903            	  1882:   lda #>TEXT_START
00:8F1A 20BC92          	  1883:   jsr PRBYTE
00:8F1D A900            	  1884:   lda #<TEXT_START
00:8F1F 207193          	  1885:   jsr PRBYTECR
00:8F22 60              	  1886:   rts
                        	  1887: 
                        	  1888: editor_assemble:
00:8F23 200E86          	  1889:   jsr editor_check_no_more
00:8F26 4C6198          	  1890:   jmp ASSEMBLE
                        	  1891: 
                        	  1892: 
                        	  1893: 
                        	  1894: 
                        	  1895: ;16-bit number comparison...
                        	  1896: ;
                        	  1897: ;         lda #>x               ; MSB of 1st number
                        	  1898: ;         cmp #>y               ; MSB of 2nd number
                        	  1899: ;         bcc islower           ; X < Y
                        	  1900: ;
                        	  1901: ;         bne ishigher          ; X > Y
                        	  1902: ;
                        	  1903: ;         lda #<x               ; LSB of 1st number
                        	  1904: ;         cmp #<y               ; LSB of 2nd number
                        	  1905: ;         bcc islower           ; X < Y
                        	  1906: ;
                        	  1907: ;         beq issame            ; X = Y
                        	  1908: ;
                        	  1909: ;         bne ishigher          ; X > Y
                        	  1910: ;
                        	  1911: ;
                        	  1912: 

Source: "gpascal.asm"
                        	   177:   .include "utilities.inc"

Source: "utilities.inc"
                        	     1: ;
                        	     2: ;  function to look up a handler for a word (eg. assembler directive)
                        	     3: ;
                        	     4: ;  word in SRCE
                        	     5: ;
                        	     6: ;  table of words/handlers in DEST
                        	     7: ;
                        	     8: ;  length of word in A
                        	     9: ;
                        	    10: ;  see makeHandler for making the table
                        	    11: ;
                        	    12: ;  Basically:
                        	    13: ;    asciiz "foo"
                        	    14: ;    word   foo_handler
                        	    15: ;
                        	    16: ;  In other words:
                        	    17: ;    makeHandler "foo",foo_handler
                        	    18: ;
                        	    19: ;  Returns with carry set if no match, otherwise calls the handler which should clear carry
                        	    20: ;
                        	    21: 
                        	    22: handlerLookup:
00:8F29 8598            	    23:   sta token_work    ; save length
                        	    24: 
                        	    25: ;
                        	    26: ;  find the length of the word
                        	    27: ;
                        	    28: handler_loop:
00:8F2B A000            	    29:   ldy #0
00:8F2D B103            	    30:   lda (DEST),y
00:8F2F F036            	    31:   beq handlers_done
                        	    32: handler_find_length:
00:8F31 B103            	    33:   lda (DEST),y
00:8F33 F005            	    34:   beq handler_found_length
00:8F35 C8              	    35:   iny
00:8F36 F02F            	    36:   beq handlers_done   ; sanity clause
00:8F38 80F7            	    37:   bra handler_find_length
                        	    38: handler_found_length:
                        	    39: 
                        	    40: ;  lda #'i'
                        	    41: ;  jsr ass_debug_point
                        	    42: 
00:8F3A C498            	    43:   cpy token_work
00:8F3C F010            	    44:   beq handler_same_length
                        	    45: ;
                        	    46: ;  not the same length, or no match on the string
                        	    47: ;
                        	    48: handler_next:
00:8F3E 98              	    49:   tya
00:8F3F 18              	    50:   clc
00:8F40 6903            	    51:   adc #3  ; skip the 0x00 and the execution address
00:8F42 6503            	    52:   adc DEST
00:8F44 8503            	    53:   sta DEST
00:8F46 A504            	    54:   lda DEST+1
00:8F48 6900            	    55:   adc #0
00:8F4A 8504            	    56:   sta DEST+1
00:8F4C 80DD            	    57:   bra handler_loop
                        	    58: 
                        	    59: handler_same_length:
                        	    60: 
                        	    61: ;  lda #'j'
                        	    62: ;  jsr ass_debug_point
                        	    63: 
00:8F4E 5A              	    64:   phy  ; save the length
00:8F4F 204C92          	    65:   jsr COMSTL
00:8F52 F003            	    66:   beq  handler_found_directive
00:8F54 7A              	    67:   ply
00:8F55 80E7            	    68:   bra handler_next
                        	    69: handler_found_directive:
00:8F57 7A              	    70:   ply  ; get the length back
00:8F58 C8              	    71:   iny  ; skip past the 0x00 byte
00:8F59 B103            	    72:   lda (DEST),y
00:8F5B 8599            	    73:   sta token_work+1
00:8F5D C8              	    74:   iny
00:8F5E B103            	    75:   lda (DEST),y
00:8F60 859A            	    76:   sta token_work+2
00:8F62 20698F          	    77:   jsr call_handler
00:8F65 18              	    78:   clc
00:8F66 60              	    79:   rts
                        	    80: 
                        	    81: handlers_done:
                        	    82: ;  lda #'h'
                        	    83: ;  jsr ass_debug_point
00:8F67 38              	    84:   sec     ; error flag
00:8F68 60              	    85:   rts
                        	    86: 
                        	    87: call_handler:
                        	    88: ;  lda #'g'
                        	    89: ;  jsr ass_debug_point
                        	    90: 
00:8F69 6C9900          	    91:   jmp (token_work+1)   ; do handler - it will RTS for us
                        	    92: 
                        	    93: 
                        	    94: ;
                        	    95: ;  function to look up a handler for a word on a partial match (eg. editor command)
                        	    96: ;
                        	    97: ;  word in SRCE
                        	    98: ;
                        	    99: ;  table of words/handlers in DEST - in UPPER CASE
                        	   100: ;
                        	   101: ;  length of word in A
                        	   102: ;
                        	   103: ;  see makeHandler for making the table
                        	   104: ;
                        	   105: ;  Basically:
                        	   106: ;    asciiz "FOO"
                        	   107: ;    word   foo_handler
                        	   108: ;
                        	   109: ;  In other words:
                        	   110: ;    makeHandler "FOO",foo_handler
                        	   111: ;
                        	   112: ;  Returns if no match, otherwise jumps to the handler and thus doesn't return
                        	   113: ;
                        	   114: 
                        	   115: partial_handler_Lookup:
00:8F6C 8598            	   116:   sta token_work    ; save length
                        	   117: ;
                        	   118: ;  here for a new table item
                        	   119: ;
                        	   120: partial_handler_next_item:
00:8F6E A000            	   121:   ldy #0
00:8F70 B103            	   122:   lda (DEST),y
00:8F72 F03C            	   123:   beq partial_handler_done
00:8F74 A698            	   124:   ldx token_work        ; source length
                        	   125: partial_handler_next_loop:
                        	   126: ;
                        	   127: ;  ensure the nth character matches until the source runs out
                        	   128: ;
00:8F76 B100            	   129:   lda (SRCE),y
00:8F78 20E38F          	   130:   jsr MAKE_UPPER
00:8F7B D103            	   131:   cmp (DEST),y
00:8F7D D006            	   132:   bne partial_handler_next
00:8F7F C8              	   133:   iny
00:8F80 CA              	   134:   dex     ; one less count
00:8F81 F019            	   135:   beq partial_handler_found_directive ; source has finished and we found the directive
00:8F83 80F1            	   136:   bra partial_handler_next_loop       ; try matching the next one
                        	   137: ;
                        	   138: ;  no match on the string - advance Y to the end of the destination string
                        	   139: ;
                        	   140: partial_handler_next:
00:8F85 B103            	   141:   lda (DEST),y
00:8F87 F003            	   142:   beq partial_handler_next_found_item_length
00:8F89 C8              	   143:   iny
00:8F8A 80F9            	   144:   bra partial_handler_next
                        	   145: partial_handler_next_found_item_length:
00:8F8C 98              	   146:   tya     ; length of the word in the table
00:8F8D 18              	   147:   clc
00:8F8E 6903            	   148:   adc #3  ; skip the 0x00 and the execution address
00:8F90 6503            	   149:   adc DEST
00:8F92 8503            	   150:   sta DEST
00:8F94 A504            	   151:   lda DEST+1
00:8F96 6900            	   152:   adc #0
00:8F98 8504            	   153:   sta DEST+1
00:8F9A 80D2            	   154:   bra partial_handler_next_item
                        	   155: 
                        	   156: partial_handler_found_directive:
00:8F9C B103            	   157:   lda (DEST),y
00:8F9E F003            	   158:   beq partial_handler_skipped_string
00:8FA0 C8              	   159:   iny
00:8FA1 80F9            	   160:   bra partial_handler_found_directive
                        	   161: partial_handler_skipped_string:
00:8FA3 C8              	   162:   iny  ; skip past the 0x00 byte
00:8FA4 B103            	   163:   lda (DEST),y
00:8FA6 8599            	   164:   sta token_work+1
00:8FA8 C8              	   165:   iny
00:8FA9 B103            	   166:   lda (DEST),y
00:8FAB 859A            	   167:   sta token_work+2
00:8FAD 6C9900          	   168:   jmp (token_work+1)   ; do partial_partial_handler_ - it will RTS for us
                        	   169: 
                        	   170: partial_handler_done:
00:8FB0 60              	   171:   rts
                        	   172: 
                        	   173: ;***********************************************
                        	   174: ; JUMP ON TOKEN
                        	   175: ; X/Y = START OF TABLE
                        	   176: ; END OF TABLE IS A NULL
                        	   177: ; A = TOKEN
                        	   178: ;***********************************************
                        	   179: TKNJMP   =  *
00:8FB1 8600            	   180:          stx  REG     ; save table address
00:8FB3 8401            	   181:          sty  REG+1
                        	   182: 
00:8FB5 20E38F          	   183:          jsr MAKE_UPPER
00:8FB8 AA              	   184:          tax          ; save the token
                        	   185: JMP1     =  *
00:8FB9 A000            	   186:          ldy  #0
00:8FBB B100            	   187:          lda  (REG),Y
00:8FBD D002            	   188:          bne  JMP2
                        	   189: ; failed to find the token
00:8FBF 8A              	   190:          txa          ; retore the token
00:8FC0 60              	   191:          rts
                        	   192: JMP2     =  *
00:8FC1 8A              	   193:          txa          ; get token back
00:8FC2 D100            	   194:          cmp  (REG),Y
00:8FC4 D010            	   195:          bne  JMP3    ; branch if not found
00:8FC6 68              	   196:          pla
00:8FC7 68              	   197:          pla          ; remove return address for TKNJMP call
00:8FC8 C8              	   198:          iny          ; move Y on to routine address
00:8FC9 B100            	   199:          lda  (REG),Y ; get low order byte of routine
00:8FCB 8503            	   200:          sta  REG2
00:8FCD C8              	   201:          iny          ; next byte
00:8FCE B100            	   202:          lda  (REG),Y ; get high order byte
00:8FD0 8504            	   203:          sta  REG2+1
00:8FD2 8A              	   204:          txa          ; get token back
00:8FD3 6C0300          	   205:          jmp  (REG2)  ; go to routine
                        	   206: JMP3     =  *
00:8FD6 A500            	   207:          lda  REG     ; skip this token sequence
00:8FD8 18              	   208:          clc
00:8FD9 6903            	   209:          adc  #3
00:8FDB 8500            	   210:          sta  REG
00:8FDD 90DA            	   211:          bcc  JMP1
00:8FDF E601            	   212:          inc  REG+1
00:8FE1 80D6            	   213:          bra  JMP1    ; try again
                        	   214: 
                        	   215: ;
                        	   216: 
                        	   217: 
                        	   218: ;***********************************************
                        	   219: ;
                        	   220: ; Case conversion
                        	   221: ;
                        	   222: ;***********************************************
                        	   223: 
                        	   224: 
                        	   225: MAKE_UPPER = *
00:8FE3 C97B            	   226:          CMP  #('z'+1)
00:8FE5 B006            	   227:          BCS  MAKE_UPPER_DONE
00:8FE7 C961            	   228:          CMP  #'a'
00:8FE9 9002            	   229:          BCC  MAKE_UPPER_DONE
00:8FEB E920            	   230:          SBC  #$20  ; make upper-case - we want carry set so there is no borrow
                        	   231: MAKE_UPPER_DONE = *
00:8FED 60              	   232:          RTS
                        	   233: 
                        	   234: MAKE_LOWER = *
00:8FEE C941            	   235:          CMP  #'A'
00:8FF0 9006            	   236:          BCC  MAKE_LOWER_DONE
00:8FF2 C95B            	   237:          CMP  #('Z'+1)
00:8FF4 B002            	   238:          BCS  MAKE_LOWER_DONE
00:8FF6 6920            	   239:          ADC  #$20  ; make upper-case - we want carry clear so there is no carry
                        	   240: MAKE_LOWER_DONE = *
00:8FF8 60              	   241:          RTS
                        	   242: 
                        	   243: 
                        	   244: ;
                        	   245: ;  generate the next random number
                        	   246: ;
                        	   247: gen_random:
00:8FF9 0609            	   248:     asl random
00:8FFB 260A            	   249:     rol random+1
00:8FFD 260B            	   250:     rol random+2
00:8FFF 260C            	   251:     rol random+3
00:9001 9018            	   252:     bcc gen_random1
00:9003 A509            	   253:     lda random
00:9005 49B7            	   254:     eor #$B7
00:9007 8509            	   255:     sta random
00:9009 A50A            	   256:     lda random+1
00:900B 491D            	   257:     eor #$1D
00:900D 850A            	   258:     sta random+1
00:900F A50B            	   259:     lda random+2
00:9011 49C1            	   260:     eor #$C1
00:9013 850B            	   261:     sta random+2
00:9015 A50C            	   262:     lda random+3
00:9017 4904            	   263:     eor #$04
00:9019 850C            	   264:     sta random+3
                        	   265: gen_random1:
00:901B 60              	   266:     rts
                        	   267: 
                        	   268: 
                        	   269: 
                        	   270: ;
                        	   271: ;  From: http://www.6502.org/source/integers/crc-more.html
                        	   272: ;
                        	   273: ;   jacksum  -a crc:16,1021,FFFF,false,false,0 -X SOME_FILE
                        	   274: ;
                        	   275: ;   https://jacksum.net/en/index.html
                        	   276: ;
                        	   277: ;   With a starting CRC of $FFFF, the binary string $01 $02 $03 $04 should evaluate to $89C3.
                        	   278: ;
                        	   279: ;   Start at crc_addr, for crc_num bytes
                        	   280: ;
                        	   281: crc16 = *
                        	   282: ;
                        	   283: ;  initialise CRC
                        	   284: ;
00:901C A9FF            	   285:   lda #$FF
00:901E 8506            	   286:   sta crc_val
00:9020 8507            	   287:   sta crc_val+1
00:9022 A503            	   288:   lda crc_num
00:9024 0504            	   289:   ora crc_num+1
00:9026 F01B            	   290:   beq crc_done
                        	   291: 
                        	   292: ;
                        	   293: ;  here for each byte
                        	   294: ;
                        	   295: crc16_loop  = *
00:9028 A000            	   296:   ldy #0
00:902A B100            	   297:   lda (crc_addr),y  ; get next byte
00:902C 204490          	   298:   jsr crc_byte
                        	   299:   ;
                        	   300:   ;  onto next address
                        	   301:   ;
00:902F E600            	   302:   inc crc_addr
00:9031 D002            	   303:   bne crc16_next
00:9033 E601            	   304:   inc crc_addr+1       ; Step to next byte
                        	   305: crc16_next:
                        	   306:   ;
                        	   307:   ; now do a 16-bit decrement
                        	   308:   ;
00:9035 A503            	   309:   LDA crc_num
00:9037 D002            	   310:   BNE crc16_skip    ; decrement the high-order byte if we are about to wrap
00:9039 C604            	   311:   DEC crc_num+1
                        	   312: crc16_skip:
00:903B C603            	   313:   DEC crc_num       ; decrement the low-order byte
00:903D D0E9            	   314:   BNE crc16_loop    ; not zero, keep going
00:903F A504            	   315:   LDA crc_num+1     ; are we zero here too?
00:9041 D0E5            	   316:   BNE crc16_loop    ; not yet
                        	   317: 
                        	   318: crc_done:
00:9043 60              	   319:   rts
                        	   320: 
                        	   321: ;
                        	   322: ;  do a CRC of one byte (in A) updating crc_val
                        	   323: ;
                        	   324: crc_byte = *
00:9044 4507            	   325:   eor crc_val+1     ; A contained the data
00:9046 8507            	   326:   sta crc_val+1     ; XOR it into high byte
00:9048 4A              	   327:   lsr               ; right shift A 4 bits
00:9049 4A              	   328:   lsr               ; to make top of x^12 term
00:904A 4A              	   329:   lsr               ; ($1...)
00:904B 4A              	   330:   lsr
00:904C AA              	   331:   tax               ; save it
00:904D 0A              	   332:   asl               ; then make top of x^5 term
00:904E 4506            	   333:   eor crc_val       ; and XOR that with low byte
00:9050 8506            	   334:   sta crc_val       ; and save
00:9052 8A              	   335:   txa               ; restore partial term
00:9053 4507            	   336:   eor crc_val+1     ; and update high byte
00:9055 8507            	   337:   sta crc_val+1     ; and save
00:9057 0A              	   338:   asl               ; left shift three
00:9058 0A              	   339:   asl               ; the rest of the terms
00:9059 0A              	   340:   asl               ; have feedback from x^12
00:905A AA              	   341:   tax               ; save bottom of x^12
00:905B 0A              	   342:   asl               ; left shift two more
00:905C 0A              	   343:   asl               ; watch the carry flag
00:905D 4507            	   344:   eor crc_val+1     ; bottom of x^5 ($..2.)
00:905F A8              	   345:   tay               ; save high byte
00:9060 8A              	   346:   txa               ; fetch temp value
00:9061 2A              	   347:   rol               ; bottom of x^12, middle of x^5!
00:9062 4506            	   348:   eor crc_val       ; finally update low byte
00:9064 8507            	   349:   sta crc_val+1     ; then swap high and low bytes
00:9066 8406            	   350:   sty crc_val
00:9068 60              	   351:   rts
                        	   352: 
                        	   353: 
                        	   354: crc_helper = *
00:9069 5A              	   355:   phy
00:906A DA              	   356:   phx
00:906B 204490          	   357:   jsr crc_byte
00:906E E603            	   358:   inc crc_num
00:9070 D002            	   359:   bne crc_helper1
00:9072 E604            	   360:   inc crc_num+1
                        	   361: crc_helper1:
00:9074 FA              	   362:   plx
00:9075 7A              	   363:   ply
00:9076 60              	   364:   rts
                        	   365: 
00:9077 536F757263652043	   366: crc_message asciiz "Source CRC       $"               ; source CRC
00:907F 5243202020202020
00:9087 2024
00:9089 00
00:908A 536F75726365206C	   367: source_length_message asciiz "Source length: "    ; source length
00:9092 656E6774683A20
00:9099 00
00:909A 2062797465730A  	   368: bytes_message asciiz " bytes\n"
00:90A1 00
                        	   369: 
                        	   370: crc_source = *
00:90A2 20878C          	   371:   jsr find_source_end
                        	   372: 
                        	   373: ;
                        	   374: ;  move existing source to end of RAM
                        	   375: ;
00:90A5 18              	   376:   clc             ; don't count the final 0x00 byte
00:90A6 A523            	   377:   lda PCODE
00:90A8 E900            	   378:   sbc #<TEXT_START
00:90AA 8503            	   379:   sta crc_num
00:90AC A524            	   380:   lda PCODE+1
00:90AE E903            	   381:   sbc #>TEXT_START
00:90B0 8504            	   382:   sta crc_num+1
                        	   383: ;
                        	   384: ;  Show the length of the source
                        	   385: ;
00:90B2 A98A            	   386:   lda #<source_length_message
00:90B4 A290            	   387:   ldx #>source_length_message
00:90B6 202682          	   388:   jsr print
00:90B9 A503            	   389:   lda crc_num
00:90BB 8500            	   390:   sta REG
00:90BD A504            	   391:   lda crc_num+1
00:90BF 8501            	   392:   sta REG+1
00:90C1 6402            	   393:   stz REGB
00:90C3 207191          	   394:   jsr display_in_decimal
00:90C6 A99A            	   395:   lda #<bytes_message
00:90C8 A290            	   396:   ldx #>bytes_message
00:90CA 202682          	   397:   jsr print
                        	   398: 
                        	   399: ;
                        	   400: ;  now the CRC
                        	   401: ;
00:90CD A900            	   402:   lda #<TEXT_START
00:90CF 8500            	   403:   sta crc_addr
00:90D1 A903            	   404:   lda #>TEXT_START
00:90D3 8501            	   405:   sta crc_addr+1
00:90D5 201C90          	   406:   jsr crc16
00:90D8 A977            	   407:   lda  #<crc_message            ;  source CRC
00:90DA A290            	   408:   ldx  #>crc_message            ;
00:90DC 202682          	   409:   jsr  print
00:90DF A507            	   410:   lda crc_val+1
00:90E1 20BC92          	   411:   jsr PRBYTE
00:90E4 A506            	   412:   lda crc_val
00:90E6 207193          	   413:   jsr PRBYTECR
00:90E9 60              	   414:   rts
                        	   415: 
                        	   416: 
                        	   417: ;
                        	   418: ;  delays for roughly 1 ms - changes no registers
                        	   419: ;
                        	   420: delay_1ms = *
00:90EA DA              	   421:          phx
00:90EB A26C            	   422:          ldx #108
                        	   423: delay_1ms_loop:
00:90ED EA              	   424:          nop
00:90EE EA              	   425:          nop
00:90EF CA              	   426:          dex
00:90F0 D0FB            	   427:          bne delay_1ms_loop
00:90F2 FA              	   428:          plx
00:90F3 60              	   429:          rts
                        	   430: 
                        	   431: ;
                        	   432: ; delay for YYXX ms (Y = high-order byte, X = lo-order byte)
                        	   433: ;  maximum delay 0x7FFF, that is 32767 ms
                        	   434: ;  Changes X and Y
                        	   435: ;
                        	   436: delay = *
00:90F4 20EA90          	   437:   jsr delay_1ms
00:90F7 CA              	   438:   dex
00:90F8 D0FA            	   439:   bne delay
00:90FA 88              	   440:   dey
00:90FB 10F7            	   441:   bpl delay
00:90FD 60              	   442:   rts
                        	   443: 
                        	   444: 
                        	   445: ;--------------------------------------------------------------------------
                        	   446: ;
                        	   447: ;  BINARY TO DECIMAL CONVERSION
                        	   448: ;
                        	   449: ;  This works as follows:
                        	   450: ;
                        	   451: ;  1. First the number is checked if it is negative (sign bit set).
                        	   452: ;  2. If so, a "-" is output and the number subtracted from zero to make it positive.
                        	   453: ;  3. Our next step is to set a BCD (binary coded decimal) output area to all zeroes.
                        	   454: ;      In BCD, the number 1234 is actually stored as 0x1234.
                        	   455: ;      With BCD mode turned on in the processor, doing adds results in an early carry
                        	   456: ;      so that numbers add "the decimal way" rather than the binary way.
                        	   457: ;  4. Then we a loop of 24 iterations (one for each bit) which adds the appropriate number from bcd_table
                        	   458: ;      if that bit was set in the original value.
                        	   459: ;  5. The function bcd_unpack is then called to convert the BCD format into ASCII format. It takes each
                        	   460: ;     nibble and adds 0x30 ('0') to it, and saves that in bcd_result.
                        	   461: ;  6. At this stage bcd_result has a 8-digit ASCII number in it.
                        	   462: ;  7. We then skip leading zeroes in bcd_result.
                        	   463: ;  8. Finally the remaining digits in bcd_result are output.
                        	   464: ;
                        	   465: ;
                        	   466: ;   I'm not sure where the idea for this came from. There was no Internet when this was written in 1979
                        	   467: ;   so it is possibly (probably) my own.
                        	   468: ;   My original implementation, although similar, was more complex than this one, which I found at:
                        	   469: ;              http://www.6502.org/source/integers/hex2dec.htm
                        	   470: ;
                        	   471: ;   Other suggestions for binary to decimal conversion I found recently do not employ this method. One
                        	   472: ;   technique (as described by Ben Eater here: https://www.youtube.com/watch?v=v3-a-zqKfgA ) is to
                        	   473: ;   repeatedly divide by 10 and use the remainder as the digit. This has to be done until the result of
                        	   474: ;   the division is zero. Dividing a 3-byte number by 10 on an 8-bit machine is not particularly fast,
                        	   475: ;   as it involves an inner loop of 24 iterations (one for each bit) and this would have to be done for
                        	   476: ;   each digit, so the number of loops of 24 iterations would increase for each digit. Therefore an
                        	   477: ;   8-digit number (like 80000000) would take 144 iterations in the divide loop. Then the digits have to
                        	   478: ;   be reversed because the remainder gives you the low-order decimal digit first.
                        	   479: ;
                        	   480: ;   Another technique is the "Double dabble" routine.
                        	   481: ;
                        	   482: ;     https://en.wikipedia.org/wiki/Double_dabble
                        	   483: ;
                        	   484: ;   The method below seems fairly efficient, as the inner loop only does anything substantial if a
                        	   485: ;     1-bit is detected. Thus large numbers can be produced quite efficiently, however it would be a
                        	   486: ;     bit slower if the input number had a lot of 1-bits set.
                        	   487: ;
                        	   488: ;   Considering that this is only used when outputting to serial, itself a slow process, speed is not
                        	   489: ;   really the issue here.
                        	   490: ;
                        	   491: ;   - Nick Gammon
                        	   492: ;
                        	   493: ;
                        	   494: ;--------------------------------------------------------------------------
                        	   495: ;
                        	   496: ; Converts BCD to ASCII
                        	   497: ;
                        	   498: bcd_unpack:
00:90FE 48              	   499:   pha  ; save the number for later
                        	   500: ;
                        	   501: ;  shift right 4 bits
                        	   502: ;
00:90FF 4A              	   503:   lsr A
00:9100 4A              	   504:   lsr A
00:9101 4A              	   505:   lsr A
00:9102 4A              	   506:   lsr A
00:9103 0930            	   507:   ora #'0'          ; make printable
00:9105 9560            	   508:   sta bcd_result,X  ; save in bcd_result
00:9107 E8              	   509:   inx
00:9108 68              	   510:   pla               ; get the original character back
00:9109 290F            	   511:   and #$0F          ; take low-order bits and make printable
00:910B 0930            	   512:   ora #'0'
00:910D 9560            	   513:   sta bcd_result,X  ; save in bcd_result
00:910F E8              	   514:   inx
00:9110 60              	   515:   rts               ; done!
                        	   516: 
                        	   517: ;
                        	   518: ;
                        	   519: ; Table for adding into the BCD result.
                        	   520: ;
                        	   521: bcd_table  =  *
00:9111 00              	   522:   dfb $00,$00,$00,$01   ; 0000001
00:9112 00
00:9113 00
00:9114 01
00:9115 00              	   523:   dfb $00,$00,$00,$02   ; 0000002
00:9116 00
00:9117 00
00:9118 02
00:9119 00              	   524:   dfb $00,$00,$00,$04   ; 0000004
00:911A 00
00:911B 00
00:911C 04
00:911D 00              	   525:   dfb $00,$00,$00,$08   ; 0000008
00:911E 00
00:911F 00
00:9120 08
00:9121 00              	   526:   dfb $00,$00,$00,$16   ; 0000016
00:9122 00
00:9123 00
00:9124 16
00:9125 00              	   527:   dfb $00,$00,$00,$32   ; 0000032
00:9126 00
00:9127 00
00:9128 32
00:9129 00              	   528:   dfb $00,$00,$00,$64   ; 0000064
00:912A 00
00:912B 00
00:912C 64
00:912D 00              	   529:   dfb $00,$00,$01,$28   ; 0000128
00:912E 00
00:912F 01
00:9130 28
00:9131 00              	   530:   dfb $00,$00,$02,$56   ; 0000256
00:9132 00
00:9133 02
00:9134 56
00:9135 00              	   531:   dfb $00,$00,$05,$12   ; 0000512
00:9136 00
00:9137 05
00:9138 12
00:9139 00              	   532:   dfb $00,$00,$10,$24   ; 0001024
00:913A 00
00:913B 10
00:913C 24
00:913D 00              	   533:   dfb $00,$00,$20,$48   ; 0002048
00:913E 00
00:913F 20
00:9140 48
00:9141 00              	   534:   dfb $00,$00,$40,$96   ; 0004096
00:9142 00
00:9143 40
00:9144 96
00:9145 00              	   535:   dfb $00,$00,$81,$92   ; 0008192
00:9146 00
00:9147 81
00:9148 92
00:9149 00              	   536:   dfb $00,$01,$63,$84   ; 0016384
00:914A 01
00:914B 63
00:914C 84
00:914D 00              	   537:   dfb $00,$03,$27,$68   ; 0032768
00:914E 03
00:914F 27
00:9150 68
00:9151 00              	   538:   dfb $00,$06,$55,$36   ; 0065536
00:9152 06
00:9153 55
00:9154 36
00:9155 00              	   539:   dfb $00,$13,$10,$72   ; 0131072
00:9156 13
00:9157 10
00:9158 72
00:9159 00              	   540:   dfb $00,$26,$21,$44   ; 0262144
00:915A 26
00:915B 21
00:915C 44
00:915D 00              	   541:   dfb $00,$52,$42,$88   ; 0524288
00:915E 52
00:915F 42
00:9160 88
00:9161 01              	   542:   dfb $01,$04,$85,$76   ; 1048576
00:9162 04
00:9163 85
00:9164 76
00:9165 02              	   543:   dfb $02,$09,$71,$52   ; 2097152
00:9166 09
00:9167 71
00:9168 52
00:9169 04              	   544:   dfb $04,$19,$43,$04   ; 4194304
00:916A 19
00:916B 43
00:916C 04
00:916D 08              	   545:   dfb $08,$38,$86,$08   ; 8388608
00:916E 38
00:916F 86
00:9170 08
                        	   546: 
                        	   547: ;--------------------------------------------------------------------------
                        	   548: ; display_in_decimal - start here - VALUE will be zero after this is executed
                        	   549: ;--------------------------------------------------------------------------
                        	   550: 
                        	   551: display_in_decimal  =  *
00:9171 A502            	   552:   lda  VALUE+2
00:9173 1008            	   553:   bpl  bcd_positive
                        	   554: ;
                        	   555: ;  if the number is negative, output a minus sign and make it positive
                        	   556: ;
00:9175 A92D            	   557:   lda  #'-'
00:9177 20CE93          	   558:   jsr  COUT
00:917A 2025AC          	   559:   jsr  exp_unary_minus
                        	   560: ;
                        	   561: ;  number is now positive
                        	   562: ;
                        	   563: bcd_positive:
                        	   564: 
00:917D 209A91          	   565:   jsr binary_to_decimal   ; do the conversion
                        	   566: 
00:9180 A207            	   567:   ldx  #7         ; zero suppress count (always keep the last zero)
00:9182 A000            	   568:   ldy  #0
                        	   569: ;
                        	   570: ;  this is skipping the leading zeroes
                        	   571: ;
                        	   572: bcd_skip_zeroes:
00:9184 B96000          	   573:   lda  bcd_result,Y
00:9187 C930            	   574:   cmp  #'0'
00:9189 D004            	   575:   bne  bcd_output_digit
00:918B C8              	   576:   iny
00:918C CA              	   577:   dex
00:918D D0F5            	   578:   bne  bcd_skip_zeroes
                        	   579: ;
                        	   580: ;  now we have a non-zero, start outputting them
                        	   581: ;
                        	   582: ;  Y points to how far we are through bcd_result
                        	   583: ;  X is how many digits to go
                        	   584: ;
                        	   585: bcd_output_digit:
00:918F B96000          	   586:   lda  bcd_result,Y
00:9192 20CE93          	   587:   jsr  COUT
00:9195 C8              	   588:   iny
00:9196 CA              	   589:   dex
00:9197 10F6            	   590:   bpl  bcd_output_digit
                        	   591: ;
                        	   592: ;  done!
                        	   593: ;
00:9199 60              	   594:   rts
                        	   595: 
                        	   596: ;--------------------------------------------------------------------------
                        	   597: ;
                        	   598: ;  Binary to decimal routine: Converts VALUE into bcd_result (8 digits)
                        	   599: ;
                        	   600: ;  See: http://www.6502.org/source/integers/hex2dec.htm
                        	   601: ;
                        	   602: ;  - VALUE will be zero after this is executed
                        	   603: ;
                        	   604: ;--------------------------------------------------------------------------
                        	   605: binary_to_decimal:
00:919A F8              	   606:   sed                 ; decimal mode for adds below
00:919B 645C            	   607:   stz  bcd_work       ; zero our result area (4 bytes = 8 digits)
00:919D 645D            	   608:   stz  bcd_work+1
00:919F 645E            	   609:   stz  bcd_work+2
00:91A1 645F            	   610:   stz  bcd_work+3
                        	   611: 
00:91A3 A25C            	   612:   ldx  #(4*23)        ; X points to the start of the highest entry
                        	   613: 
                        	   614: binary_to_decimal_loop:
00:91A5 0600            	   615:   asl VALUE      ;  shift out high-order bit into Carry
00:91A7 2601            	   616:   rol VALUE+1
00:91A9 2602            	   617:   rol VALUE+2
00:91AB 901D            	   618:   bcc binary_to_decimal_next  ; if carry clear, no add needs to be done
                        	   619: ;
                        	   620: ;  that bit was set, so add the appropriate BCD number from the table (eg. 1, 2, 4, 8, 16 and so on)
                        	   621: ;
00:91AD 18              	   622:   clc
00:91AE A55C            	   623:   lda bcd_work
00:91B0 7D1491          	   624:   adc bcd_table+3,X
00:91B3 855C            	   625:   sta bcd_work
00:91B5 A55D            	   626:   lda bcd_work+1
00:91B7 7D1391          	   627:   adc bcd_table+2,X
00:91BA 855D            	   628:   sta bcd_work+1
00:91BC A55E            	   629:   lda bcd_work+2
00:91BE 7D1291          	   630:   adc bcd_table+1,X
00:91C1 855E            	   631:   sta bcd_work+2
00:91C3 A55F            	   632:   lda bcd_work+3
00:91C5 7D1191          	   633:   adc bcd_table,X
00:91C8 855F            	   634:   sta bcd_work+3
                        	   635: 
                        	   636: binary_to_decimal_next:
00:91CA CA              	   637:   dex      ; back to the previous table item
00:91CB CA              	   638:   dex
00:91CC CA              	   639:   dex
00:91CD CA              	   640:   dex
00:91CE 10D5            	   641:   bpl binary_to_decimal_loop
00:91D0 D8              	   642:   cld     ; decimal mode off
                        	   643: 
                        	   644: 
                        	   645: ;
                        	   646: ;  convert BCD to ASCII - note that UNPACK increments x by two each time
                        	   647: ;    - the results are in bcd_result - an 8-character field
                        	   648: ;
                        	   649: ;  We unpack the high-order bytes first, naturally
                        	   650: ;
00:91D1 A200            	   651:   ldx  #0
00:91D3 A55F            	   652:   lda  bcd_work+3
00:91D5 20FE90          	   653:   jsr  bcd_unpack
00:91D8 A55E            	   654:   lda  bcd_work+2
00:91DA 20FE90          	   655:   jsr  bcd_unpack
00:91DD A55D            	   656:   lda  bcd_work+1
00:91DF 20FE90          	   657:   jsr  bcd_unpack
00:91E2 A55C            	   658:   lda  bcd_work
00:91E4 20FE90          	   659:   jsr  bcd_unpack
00:91E7 60              	   660:   rts
                        	   661: 
00:91E8 4E6F20736F757263	   662: NOSCE    asciiz  'No source file.\n'   ; No source file
00:91F0 652066696C652E0A
00:91F8 00
                        	   663: 
                        	   664: ;***********************************************
                        	   665: ;
                        	   666: ; Initialize a compile or assembly
                        	   667: ;
                        	   668: ;***********************************************
                        	   669: 
                        	   670: 
                        	   671: INIT     =  *
                        	   672: ;
                        	   673: ;  set up symbol table pointer
                        	   674: ;
                        	   675: 
00:91F9 A93F            	   676:   lda  #>SYMBOL_TABLE_START
00:91FB 8532            	   677:   sta  ENDSYM+1
00:91FD 8530            	   678:   sta  STARTSYM+1
00:91FF A9FF            	   679:   lda  #<SYMBOL_TABLE_START
00:9201 8531            	   680:   sta  ENDSYM
00:9203 852F            	   681:   sta  STARTSYM
                        	   682: 
                        	   683: INIT_SECOND_PASS:   ; for assembler
                        	   684: 
00:9205 A900            	   685:   lda  #0
00:9207 851D            	   686:   sta  LIST            ; not listing
00:9209 8522            	   687:   sta  LEVEL           ; variable level zero
00:920B 852E            	   688:   sta  DCODE
00:920D 853F            	   689:   sta  RUNNING         ; not running
00:920F 8539            	   690:   sta  PRCITM
00:9211 853A            	   691:   sta  PRCITM+1
00:9213 8502            	   692:   sta  REGB
00:9215 8593            	   693:   sta  token_type
00:9217 64BE            	   694:   stz  system_flags
00:9219 A901            	   695:   lda #1
00:921B 85A2            	   696:   sta  current_line        ; we are currently on line 1
00:921D 64A3            	   697:   stz  current_line+1
                        	   698: 
                        	   699: ;
                        	   700: ;  set up for reading first byte of source
                        	   701: ;
00:921F A900            	   702:   lda  #<TEXT_START
00:9221 858E            	   703:   sta  token_start
00:9223 859C            	   704:   sta  token_line_start
00:9225 A903            	   705:   lda  #>TEXT_START
00:9227 858F            	   706:   sta  token_start+1
00:9229 859D            	   707:   sta  token_line_start+1
00:922B 20878C          	   708:   jsr  find_source_end
00:922E A523            	   709:   lda  PCODE
00:9230 8525            	   710:   sta  ACT_PCDA
00:9232 A524            	   711:   lda  PCODE+1
00:9234 8526            	   712:   sta  ACT_PCDA+1
00:9236 A000            	   713:   ldy  #0
00:9238 B18E            	   714:   lda  (token_start),y
00:923A D00A            	   715:   bne  INIT9
00:923C A9E8            	   716:   lda  #<NOSCE
00:923E A291            	   717:   ldx  #>NOSCE
00:9240 202682          	   718:   jsr  print                      ; No source file
00:9243 4C8282          	   719:   jmp  main_prompt
00:9246 60              	   720: INIT9    rts
                        	   721: 
                        	   722: 
                        	   723: 
                        	   724: 
                        	   725: ;
                        	   726: CROUT    =  *             ; show a newline
00:9247 A90A            	   727:   lda  #NL         ; was a carriage-return in legacy, now is newline
00:9249 4CCE93          	   728:   jmp  COUT
                        	   729: ;
                        	   730: ;***********************************************
                        	   731: ; COMPARE STRING - compare SRCE to DEST, assumes DEST is upper-case
                        	   732: ;                - length in Y (therefore max 255 characters)
                        	   733: ;                - zero flag set if match (therefore do a BEQ to see if strings match)
                        	   734: ;***********************************************
                        	   735: COMSTL   =  *
00:924C 88              	   736:          dey
00:924D 300A            	   737:          bmi  COMS8
00:924F B100            	   738:          lda  (SRCE),Y
00:9251 20E38F          	   739:          jsr MAKE_UPPER
00:9254 D103            	   740:          cmp  (DEST),Y
00:9256 F0F4            	   741:          beq  COMSTL
00:9258 60              	   742: COMS9    rts             ; NOT EQUAL
00:9259 A900            	   743: COMS8    lda  #0
00:925B 60              	   744:          rts             ; EQUAL
                        	   745: 
                        	   746: ;***********************************************
                        	   747: ; DISPLAY A LINE
                        	   748: ;
                        	   749: 
                        	   750: ;
                        	   751: ; DISPLAY IN HEX
                        	   752: ;
00:925C 20BC92          	   753: DISHX    jsr  PRBYTE
00:925F 4CD292          	   754:          jmp  PUTSP
                        	   755: ;
                        	   756: 
                        	   757: ;***********************************************
                        	   758: ; DISPLAY PCODE ADDRESS
                        	   759: ;***********************************************
                        	   760: DISPAD   =  *
00:9262 A52E            	   761:          lda  DCODE
00:9264 F017            	   762:          beq  DISPAD2
                        	   763: DISPAD1  =  *
00:9266 A928            	   764:          lda  #'('
00:9268 20CE93          	   765:          jsr  COUT
00:926B A524            	   766:          lda  PCODE+1
00:926D 20BC92          	   767:          jsr  PRBYTE
00:9270 A523            	   768:          lda  PCODE
00:9272 20BC92          	   769:          jsr  PRBYTE
00:9275 A929            	   770:          lda  #')'
00:9277 20CE93          	   771:          jsr  COUT
00:927A 4CD292          	   772:          jmp  PUTSP
00:927D 60              	   773: DISPAD2  rts
                        	   774: ;
                        	   775: 
                        	   776: ;***********************************************
                        	   777: ; PUSH 'WORK' ONTO STACK
                        	   778: ;***********************************************
                        	   779: PSHWRK   =  *
00:927E 8536            	   780:          sta  BSAVE
00:9280 68              	   781:          pla
00:9281 AA              	   782:          tax
00:9282 68              	   783:          pla
00:9283 A8              	   784:          tay
00:9284 A538            	   785:          lda  WORK+1
00:9286 48              	   786:          pha
00:9287 A537            	   787:          lda  WORK
00:9289 48              	   788:          pha
00:928A 98              	   789:          tya
00:928B 48              	   790:          pha
00:928C 8A              	   791:          txa
00:928D 48              	   792:          pha
00:928E A536            	   793:          lda  BSAVE
00:9290 60              	   794: PSH9     rts
                        	   795: ;
                        	   796: ;***********************************************
                        	   797: ; PULL 'WORK' FROM STACK
                        	   798: ;***********************************************
                        	   799: PULWRK   =  *
00:9291 8536            	   800:          sta  BSAVE
00:9293 68              	   801:          pla
00:9294 AA              	   802:          tax
00:9295 68              	   803:          pla
00:9296 A8              	   804:          tay
00:9297 68              	   805:          pla
00:9298 8537            	   806:          sta  WORK
00:929A 68              	   807:          pla
00:929B 8538            	   808:          sta  WORK+1
00:929D 98              	   809:          tya
00:929E 48              	   810:          pha
00:929F 8A              	   811:          txa
00:92A0 48              	   812:          pha
00:92A1 A536            	   813:          lda  BSAVE
00:92A3 60              	   814:          rts
                        	   815: ;
                        	   816: ;***********************************************
                        	   817: ; PRINTING SUBROUTINES
                        	   818: ; Control characters print with a ^ in front of them, eg. ^A
                        	   819: ;***********************************************
                        	   820: PRCHAR   =  *
00:92A4 48              	   821:   pha
00:92A5 C90A            	   822:   cmp #NL
00:92A7 F00E            	   823:   beq prchar_not_control
00:92A9 C920            	   824:   cmp #$20
00:92AB B00A            	   825:   bcs prchar_not_control
00:92AD 48              	   826:   pha
00:92AE A95E            	   827:   lda #'^'
00:92B0 20CE93          	   828:   jsr COUT
00:92B3 68              	   829:   pla
00:92B4 18              	   830:   clc
00:92B5 6940            	   831:   adc #$40  ; make 0x01 print as ^A
                        	   832: prchar_not_control:
00:92B7 20CE93          	   833:   jsr  COUT
00:92BA 68              	   834:   pla
00:92BB 60              	   835:   rts
                        	   836: ;
                        	   837: ; Prints A in hex
                        	   838: ;
                        	   839: PRBYTE:
00:92BC 48              	   840:   pha
00:92BD 4A              	   841:   lsr
00:92BE 4A              	   842:   lsr
00:92BF 4A              	   843:   lsr
00:92C0 4A              	   844:   lsr
00:92C1 20C792          	   845:   jsr  PRHEXZ    ; first nibble
00:92C4 68              	   846:   pla            ; now do other nibble
                        	   847: PRHEX:
00:92C5 290F            	   848:   and  #$0F
                        	   849: PRHEXZ:
00:92C7 0930            	   850:   ora  #'0'
00:92C9 C93A            	   851:   cmp  #'0' + $0A
00:92CB 9002            	   852:   bcc  PRHEX1
00:92CD 6926            	   853:   adc  #$26  ; (carry is set: adding 7 to make 0x0a become 'a')
                        	   854: PRHEX1:
00:92CF 4CA492          	   855:   jmp  PRCHAR
                        	   856: ;
                        	   857: PUTSP    =  *
00:92D2 A920            	   858:   lda  #' '
00:92D4 80F9            	   859:   bra  PRHEX1
                        	   860: ;
                        	   861: ;
                        	   862: ;  PT - put text
                        	   863: ;   Low-order address in A, high-order address in X, count in Y
                        	   864: ;
                        	   865: ;
                        	   866: PT:
00:92D6 8503            	   867:   sta  REG2
00:92D8 8604            	   868:   stx  REG2+1
00:92DA 98              	   869:   tya    ; count of bytes to print
00:92DB AA              	   870:   tax    ; put that into X
00:92DC A000            	   871:   ldy  #0
                        	   872: PT6:
00:92DE B103            	   873:   lda  (REG2),Y    ; next character
00:92E0 20CE93          	   874:   jsr COUT         ; show it
00:92E3 C8              	   875:   iny
00:92E4 CA              	   876:   dex
00:92E5 D0F7            	   877:   bne  PT6
00:92E7 60              	   878:   rts
                        	   879: ;
                        	   880: ;
                        	   881: ;
                        	   882: ;---- token_address --> WORK
                        	   883: ;
                        	   884: TKNWRK   =  *
00:92E8 48              	   885:          PHA
00:92E9 A590            	   886:          LDA  token_address
00:92EB 8537            	   887:          STA  WORK
00:92ED A591            	   888:          LDA  token_address+1
00:92EF 8538            	   889:          STA  WORK+1
00:92F1 68              	   890:          PLA
00:92F2 60              	   891:          RTS
                        	   892: ;
                        	   893: ;---- WORK --> token_address
                        	   894: ;
                        	   895: WRKTKN   =  *
00:92F3 48              	   896:          PHA
00:92F4 A537            	   897:          LDA  WORK
00:92F6 8590            	   898:          STA  token_address
00:92F8 A538            	   899:          LDA  WORK+1
00:92FA 8591            	   900:          STA  token_address+1
00:92FC 68              	   901:          PLA
00:92FD 60              	   902:          RTS
                        	   903: ;
                        	   904: 
                        	   905: 
                        	   906: ;***********************************************
                        	   907: ; MENU, FILE HANDLING
                        	   908: ;***********************************************
                        	   909: ;
00:92FE 502D636F64657320	   910: pcodes_ended_message        asciiz  "P-codes ended at $"
00:9306 656E646564206174
00:930E 2024
00:9310 00
00:9311 436F6D70696C6520	   911: compile_finished_message    asciiz  "Compile finished: No errors.\n"
00:9319 66696E6973686564
00:9321 3A204E6F20657272
00:9329 6F72732E0A
00:932E 00
00:932F 53796D626F6C2074	   912: symbol_table_ended_message  asciiz "Symbol table ended at $"
00:9337 61626C6520656E64
00:933F 65642061742024
00:9346 00
00:9347 4E6F2076616C6964	   913: no_valid_compile_message    asciiz  'No valid compile or assemble done before\n'
00:934F 20636F6D70696C65
00:9357 206F722061737365
00:935F 6D626C6520646F6E
00:9367 65206265666F7265
00:936F 0A
00:9370 00
                        	   914: ;
                        	   915: PRBYTECR =  *
00:9371 20BC92          	   916:          JSR  PRBYTE
00:9374 4C4792          	   917:          JMP  CROUT
                        	   918: ;
                        	   919: ;
                        	   920: ;
                        	   921: CHK_VAL  =  *
00:9377 A908            	   922:          LDA  #FLAG_VALID_COMPILE
00:9379 0910            	   923:          ORA  #FLAG_VALID_ASSEMBLE
00:937B 25BE            	   924:          and  system_flags
00:937D D00A            	   925:          BNE  CHK_VAL9
00:937F A947            	   926:          LDA  #<no_valid_compile_message    ; No valid Compile or Assemble done before
00:9381 A293            	   927:          LDX  #>no_valid_compile_message
00:9383 202682          	   928:          JSR  print
00:9386 4C8282          	   929:          JMP  main_prompt
                        	   930: CHK_VAL9 =  *
                        	   931: BELL1X   =  *          ; no bell yet
00:9389 60              	   932:          RTS
                        	   933: ;
00:938A 207793          	   934: CHK_RUN  JSR  CHK_VAL
00:938D A910            	   935:          lda  #FLAG_VALID_ASSEMBLE
00:938F 25BE            	   936:          and  system_flags
00:9391 D003            	   937:          bne  run_assembler
00:9393 4C65AE          	   938:          JMP  INTERP
                        	   939: run_assembler:
00:9396 209C93          	   940:          jsr call_assembler
00:9399 4C01AF          	   941:          JMP  EX_FINISHD
                        	   942: ;
                        	   943: ;  let's assume they put a RTS at the end of their code
                        	   944: ;
                        	   945: call_assembler:
00:939C A9F3            	   946:          LDA  #<running_message   ; Running
00:939E A2AD            	   947:          LDX  #>running_message
00:93A0 202682          	   948:          JSR  print
00:93A3 6C2500          	   949:          JMP (ACT_PCDA)
                        	   950: 
                        	   951: ;
                        	   952: 
                        	   953: ;
                        	   954: ; Get a line, read byte by byte until we get a newline, store in INBUF
                        	   955: ;   returns length in Y - handles backspace, ignores carriage-return
                        	   956: ;
                        	   957: GET_LINE =  *
                        	   958: GETLN1   =  *
00:93A6 A000            	   959:   ldy  #0
                        	   960: GET1:
00:93A8 2018C9          	   961:   jsr  CHRIN
00:93AB C90D            	   962:   cmp  #CR       ; carriage-return?
00:93AD F0F9            	   963:   beq  GET1       ; ignore it
00:93AF 990002          	   964:   sta  INBUF,Y    ; SAVE IN BUFFER
00:93B2 C8              	   965:   iny
00:93B3 F016            	   966:   beq  GETLN_OVERFLOW       ; overflow
00:93B5 C90A            	   967:   cmp  #NL        ; END OF LINE?
00:93B7 F00C            	   968:   beq  GET3       ; yes
00:93B9 C908            	   969:   cmp  #BACKSPACE ; backspace?
00:93BB D0EB            	   970:   bne  GET1       ; no - keep adding to buffer
                        	   971: ;
                        	   972: ;  here for backspace
                        	   973: ;
00:93BD 88              	   974:   dey  ; get rid of backspace
00:93BE 88              	   975:   dey  ; get rid of character we backspaced over
00:93BF C0FF            	   976:   cpy  #$FF
00:93C1 F0E3            	   977:   beq  GETLN1   ; if Y underflowed, go back to zero
00:93C3 80E3            	   978:   bra GET1
                        	   979: 
                        	   980: GET3:
00:93C5 A900            	   981:   lda  #0
00:93C7 990002          	   982:   sta  INBUF,Y    ; turn newline into 0x00
00:93CA 60              	   983:   rts             ; RETURN
                        	   984: ;
                        	   985: ;  here on INBUF overflow
                        	   986: ;
                        	   987: GETLN_OVERFLOW:
00:93CB 88              	   988:   dey           ; get back to 255 (last byte)
00:93CC 80F7            	   989:   bra  GET3     ; store a zero there
                        	   990: 
                        	   991: 
                        	   992: ;
                        	   993: ;  output a character - saves all registers
                        	   994: ;
                        	   995: COUT:
00:93CE 48              	   996:   pha
00:93CF DA              	   997:   phx
00:93D0 5A              	   998:   phy
00:93D1 20D893          	   999:   jsr COUT_CALL   ; call the current outputting routine
00:93D4 7A              	  1000:   ply
00:93D5 FA              	  1001:   plx
00:93D6 68              	  1002:   pla
00:93D7 60              	  1003:   rts
                        	  1004: 
                        	  1005: 
                        	  1006: COUT_CALL:
00:93D8 6C1700          	  1007:   jmp (write_function)
                        	  1008: 
                        	  1009: 

Source: "gpascal.asm"
                        	   178:   .include "errors.inc"

Source: "errors.inc"
                        	     1: 
                        	     2: errors_table:
00:93DB 4D656D6F72792066	     3:   asciiz "Memory full"                               ;  1
00:93E3 756C6C
00:93E6 00
00:93E7 436F6E7374616E74	     4:   asciiz "Constant expected"                         ;  2
00:93EF 2065787065637465
00:93F7 64
00:93F8 00
00:93F9 3D20657870656374	     5:   asciiz "= expected"                                ;  3
00:9401 6564
00:9403 00
00:9404 4964656E74696669	     6:   asciiz "Identifier expected"                       ;  4
00:940C 6572206578706563
00:9414 746564
00:9417 00
00:9418 2C206F72203A2065	     7:   asciiz ", or : expected"                           ;  5
00:9420 78706563746564
00:9427 00
00:9428 427567          	     8:   asciiz "Bug"                                       ;  6
00:942B 00
00:942C 2A29206F72207D20	     9:   asciiz "*) or } expected"                          ;  7
00:9434 6578706563746564
00:943C 00
00:943D 496E636F72726563	    10:   asciiz "Incorrect string"                          ;  8
00:9445 7420737472696E67
00:944D 00
00:944E 2E20657870656374	    11:   asciiz ". expected"                                ;  9
00:9456 6564
00:9458 00
00:9459 3B20657870656374	    12:   asciiz "; expected"                                ; 10
00:9461 6564
00:9463 00
00:9464 556E6465636C6172	    13:   asciiz "Undeclared identifier"                     ; 11
00:946C 6564206964656E74
00:9474 6966696572
00:9479 00
00:947A 496C6C6567616C20	    14:   asciiz "Illegal identifier"                        ; 12
00:9482 6964656E74696669
00:948A 6572
00:948C 00
00:948D 3A3D206578706563	    15:   asciiz ":= expected"                               ; 13
00:9495 746564
00:9498 00
00:9499 4C69746572616C20	    16:   asciiz "Literal string of zero length"             ; 14
00:94A1 737472696E67206F
00:94A9 66207A65726F206C
00:94B1 656E677468
00:94B6 00
00:94B7 436F6D70696C6572	    17:   asciiz "Compiler limits exceeded"                  ; 15
00:94BF 206C696D69747320
00:94C7 6578636565646564
00:94CF 00
00:94D0 5448454E20657870	    18:   asciiz "THEN expected"                             ; 16
00:94D8 6563746564
00:94DD 00
00:94DE 3B206F7220454E44	    19:   asciiz "; or END expected"                         ; 17
00:94E6 2065787065637465
00:94EE 64
00:94EF 00
00:94F0 444F206578706563	    20:   asciiz "DO expected"                               ; 18
00:94F8 746564
00:94FB 00
00:94FC 496E636F72726563	    21:   asciiz "Incorrect symbol"                          ; 19
00:9504 742073796D626F6C
00:950C 00
00:950D 427567          	    22:   asciiz "Bug"                                       ; 20
00:9510 00
00:9511 557365206F662070	    23:   asciiz "Use of procedure identifier in expression" ; 21
00:9519 726F636564757265
00:9521 206964656E746966
00:9529 69657220696E2065
00:9531 787072657373696F
00:9539 6E
00:953A 00
00:953B 2920657870656374	    24:   asciiz ") expected"                                ; 22
00:9543 6564
00:9545 00
00:9546 496C6C6567616C20	    25:   asciiz "Illegal factor"                            ; 23
00:954E 666163746F72
00:9554 00
00:9555 54797065206D6973	    26:   asciiz "Type mismatch"                             ; 24
00:955D 6D61746368
00:9562 00
00:9563 424547494E206578	    27:   asciiz "BEGIN expected"                            ; 25
00:956B 706563746564
00:9571 00
00:9572 4F46206578706563	    28:   asciiz "OF expected"                               ; 26
00:957A 746564
00:957D 00
00:957E 537461636B206675	    29:   asciiz "Stack full"                                ; 27
00:9586 6C6C
00:9588 00
00:9589 544F206F7220444F	    30:   asciiz "TO or DOWNTO expected"                     ; 28
00:9591 574E544F20657870
00:9599 6563746564
00:959E 00
00:959F 537472696E67206C	    31:   asciiz "String literal too big"                    ; 29
00:95A7 69746572616C2074
00:95AF 6F6F20626967
00:95B5 00
00:95B6 4E756D626572206F	    32:   asciiz "Number out of range"                       ; 30
00:95BE 7574206F66207261
00:95C6 6E6765
00:95C9 00
00:95CA 2820657870656374	    33:   asciiz "( expected"                                ; 31
00:95D2 6564
00:95D4 00
00:95D5 2C20657870656374	    34:   asciiz ", expected"                                ; 32
00:95DD 6564
00:95DF 00
00:95E0 5B20657870656374	    35:   asciiz "[ expected"                                ; 33
00:95E8 6564
00:95EA 00
00:95EB 5D20657870656374	    36:   asciiz "] expected"                                ; 34
00:95F3 6564
00:95F5 00
00:95F6 506172616D657465	    37:   asciiz "Parameters mismatched"                     ; 35
00:95FE 7273206D69736D61
00:9606 7463686564
00:960B 00
00:960C 4461746120747970	    38:   asciiz "Data type not recognised"                  ; 36
00:9614 65206E6F74207265
00:961C 636F676E69736564
00:9624 00
00:9625 53796D626F6C2074	    39:   asciiz "Symbol table full"                         ; 37
00:962D 61626C652066756C
00:9635 6C
00:9636 00
00:9637 4475706C69636174	    40:   asciiz "Duplicate identifier"                      ; 38
00:963F 65206964656E7469
00:9647 66696572
00:964B 00
00:964C 56616C7565206578	    41:   asciiz "Value expected"                            ; 39
00:9654 706563746564
00:965A 00
00:965B 496C6C6567616C20	    42:   asciiz "Illegal opcode"                            ; 40
00:9663 6F70636F6465
00:9669 00
00:966A 496C6C6567616C20	    43:   asciiz "Illegal addressing mode"                   ; 41
00:9672 6164647265737369
00:967A 6E67206D6F6465
00:9681 00
00:9682 4272616E6368206F	    44:   asciiz "Branch out of range"                       ; 42
00:968A 7574206F66207261
00:9692 6E6765
00:9695 00
00:9696 4E656564207A6572	    45:   asciiz "Need zero page address"                    ; 43
00:969E 6F20706167652061
00:96A6 646472657373
00:96AC 00
00:96AD 4F706572616E6420	    46:   asciiz "Operand too large"                         ; 44
00:96B5 746F6F206C617267
00:96BD 65
00:96BE 00
00:96BF 53796D626F6C2061	    47:   asciiz "Symbol address changed"                    ; 45
00:96C7 6464726573732063
00:96CF 68616E676564
00:96D5 00
00:96D6 4578707265737369	    48:   asciiz "Expression too complex"                    ; 46
00:96DE 6F6E20746F6F2063
00:96E6 6F6D706C6578
00:96EC 00
00:96ED 4469766964652062	    49:   asciiz "Divide by zero"                            ; 47
00:96F5 79207A65726F
00:96FB 00
00:96FC 4C6162656C207265	    50:   asciiz "Label required"                            ; 48
00:9704 717569726564
00:970A 00
00:970B 53796D626F6C2074	    51:   asciiz "Symbol table in use"                       ; 49
00:9713 61626C6520696E20
00:971B 757365
00:971E 00
00:971F 4E6F204C4344    	    52:   asciiz "No LCD"                                    ; 50
00:9725 00
00:9726 436F646520616C72	    53:   asciiz "Code already generated"                    ; 51
00:972E 656164792067656E
00:9736 657261746564
00:973C 00
                        	    54: assertion_failed_message:   ; used by Pascal assert function
00:973D 417373657274696F	    55:   asciiz "Assertion failed"                          ; 52
00:9745 6E206661696C6564
00:974D 00
00:974E 557365206F662066	    56:   asciiz "Use of function identifier in statement"   ; 53
00:9756 756E6374696F6E20
00:975E 6964656E74696669
00:9766 657220696E207374
00:976E 6174656D656E74
00:9775 00
00:9776 00              	    57:   dfb 0
                        	    58: 
                        	    59: ;***********************************************
                        	    60: ; DISPLAY ERROR - this does not return to the caller
                        	    61: ;  but to main_prompt
                        	    62: ;  Error number in X
                        	    63: ;***********************************************
00:9777 2A2A2A204572726F	    64: ERRLIT   asciiz  '*** Error: '
00:977F 723A20
00:9782 00
                        	    65: 
00:9783 8635            	    66: ERROR    stx  ERRNO
00:9785 A53F            	    67:          lda  RUNNING
00:9787 F003            	    68:          beq  ERR7
00:9789 4CC097          	    69:          jmp  ERR6
                        	    70: ERR7     =  *
00:978C A51D            	    71:          lda  LIST
00:978E D006            	    72:          bne  ERR1
00:9790 204792          	    73:          jsr  CROUT
00:9793 201898          	    74:          jsr  show_current_line
                        	    75: ERR1     =  *
00:9796 A590            	    76:          lda  token_address
00:9798 38              	    77:          sec
00:9799 E59C            	    78:          sbc  token_line_start  ; TODO: what about high-order byte?
00:979B 48              	    79:          pha             ; CHARS UP TO ERROR POINT
00:979C A977            	    80:          lda  #<ERRLIT   ; *** Error
00:979E A297            	    81:          ldx  #>ERRLIT
00:97A0 202682          	    82:          jsr  print
00:97A3 68              	    83:          pla
00:97A4 18              	    84:          clc
00:97A5 6901            	    85:          adc   #1
00:97A7 8545            	    86:          sta  TEMP       ; BYTES TO ERROR POINT
00:97A9 AA              	    87:          tax
                        	    88: ERR3     =  *
00:97AA 20D292          	    89:          jsr  PUTSP
00:97AD CA              	    90:          dex
00:97AE D0FA            	    91:          bne  ERR3
00:97B0 A95E            	    92:          lda  #'^'
00:97B2 20CE93          	    93:          jsr  COUT
00:97B5 204792          	    94:          jsr  CROUT
00:97B8 A209            	    95:          ldx  #9
                        	    96: ERR5     =  *
00:97BA 20D292          	    97:          jsr  PUTSP
00:97BD CA              	    98:          dex
00:97BE D0FA            	    99:          bne  ERR5
                        	   100: ERR6     =  *
00:97C0 A9DB            	   101:   lda #<errors_table
00:97C2 8500            	   102:   sta REG
00:97C4 A993            	   103:   lda #>errors_table
00:97C6 8501            	   104:   sta REG+1
00:97C8 A200            	   105:   ldx #0
00:97CA A000            	   106:   ldy #0
                        	   107: error_next:
00:97CC E8              	   108:   inx
                        	   109: error_loop:
00:97CD E435            	   110:   cpx ERRNO
00:97CF F02A            	   111:   beq error_found
                        	   112: error_find_next:
00:97D1 B100            	   113:   lda (REG),Y
00:97D3 48              	   114:   pha
00:97D4 E600            	   115:   inc REG
00:97D6 D002            	   116:   bne error1
00:97D8 E601            	   117:   inc REG+1
                        	   118: error1:
00:97DA 68              	   119:   pla           ; get the previous byte
00:97DB D0F4            	   120:   bne error_find_next
00:97DD B100            	   121:   lda (REG),Y   ; a null after a null?
00:97DF F002            	   122:   beq error_not_found
00:97E1 80E9            	   123:   bra error_next  ; we got a null, so add 1 to our current error number (X)
                        	   124: 
                        	   125: error_not_found:
00:97E3 A908            	   126:   lda #<error_not_found_message
00:97E5 A298            	   127:   ldx #>error_not_found_message
00:97E7 202682          	   128:   jsr print
00:97EA A535            	   129:   lda ERRNO
00:97EC 8500            	   130:   sta REG
00:97EE 6401            	   131:   stz REG+1
00:97F0 6402            	   132:   stz REGB
00:97F2 207191          	   133:   jsr display_in_decimal
00:97F5 204792          	   134:   jsr CROUT
00:97F8 4C8282          	   135:   jmp main_prompt
                        	   136: 
                        	   137: error_found:
00:97FB A500            	   138:   lda REG
00:97FD A601            	   139:   ldx REG+1
00:97FF 202682          	   140:   jsr print
00:9802 204792          	   141:   jsr CROUT
00:9805 4C8282          	   142:   jmp  main_prompt
                        	   143: 
00:9808 556E6B6E6F776E20	   144: error_not_found_message asciiz "Unknown error: "
00:9810 6572726F723A20
00:9817 00
                        	   145: 
                        	   146: show_current_line:
00:9818 A928            	   147:   lda #'('
00:981A 20CE93          	   148:   jsr COUT
00:981D A524            	   149:   lda PCODE+1
00:981F 20BC92          	   150:   jsr PRBYTE
00:9822 A523            	   151:   lda PCODE
00:9824 20BC92          	   152:   jsr PRBYTE
00:9827 A929            	   153:   lda #')'
00:9829 20CE93          	   154:   jsr COUT
00:982C 20D292          	   155:   jsr PUTSP
00:982F 20158C          	   156:   jsr show_current_line_number
00:9832 A59C            	   157:   lda token_line_start
00:9834 85A6            	   158:   sta mem_move_src
00:9836 A59D            	   159:   lda token_line_start+1
00:9838 85A7            	   160:   sta mem_move_src+1
                        	   161: 
                        	   162: show_current_line_loop:
00:983A A000            	   163:   ldy #0
00:983C B1A6            	   164:   lda (mem_move_src),Y
00:983E F01D            	   165:   beq show_current_line_done
00:9840 C90A            	   166:   cmp #NL
00:9842 F019            	   167:   beq show_current_line_done
00:9844 C920            	   168:   cmp #$20
00:9846 B00A            	   169:   bcs show_current_line_loop_print_one_character
00:9848 48              	   170:   pha
00:9849 A95E            	   171:   lda #'^'
00:984B 20CE93          	   172:   jsr COUT
00:984E 68              	   173:   pla
00:984F 18              	   174:   clc
00:9850 6940            	   175:   adc #$40  ; make 0x01 print as ^A
                        	   176: show_current_line_loop_print_one_character:
00:9852 20CE93          	   177:   jsr COUT    ; show that byte
00:9855 E6A6            	   178:   inc mem_move_src
00:9857 D0E1            	   179:   bne show_current_line_loop
00:9859 E6A7            	   180:   inc mem_move_src+1
00:985B 80DD            	   181:   bra show_current_line_loop
                        	   182: 
                        	   183: show_current_line_done:
00:985D 204792          	   184:   jsr CROUT
00:9860 60              	   185:   rts
                        	   186: 

Source: "gpascal.asm"
                        	   179:   .include "assembler.inc"

Source: "assembler.inc"
                        	     1: ;***********************************************
                        	     2: ;
                        	     3: ; Assembler
                        	     4: ;
                        	     5: ;***********************************************
                        	     6: 
                        	     7: ;***********************************************
                        	     8: ; Assembler operand types
                        	     9: ;***********************************************
                        	    10: 
                        	    11: ASS_OPERAND_ABSOLUTE                           =  1      ; a
                        	    12: ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT          =  2      ; (a,x)
                        	    13: ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X            =  3      ; a,x
                        	    14: ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y            =  4      ; a,y
                        	    15: ASS_OPERAND_ABSOLUTE_INDIRECT                  =  5      ; (a)
                        	    16: ASS_OPERAND_ACCUMULATOR_A                      =  6      ; A
                        	    17: ASS_OPERAND_IMMEDIATE                          =  7      ; #
                        	    18: ASS_OPERAND_IMPLIED                            =  8      ; i
                        	    19: ASS_OPERAND_PROGRAM_COUNTER_RELATIVE           =  9      ; r
                        	    20: ASS_OPERAND_STACK                              = 10      ; s
                        	    21: ASS_OPERAND_ZERO_PAGE                          = 11      ; zp
                        	    22: ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT         = 12      ; (zp,x)
                        	    23: ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X           = 13      ; zp,x
                        	    24: ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y           = 14      ; zp,y
                        	    25: ASS_OPERAND_ZERO_PAGE_INDIRECT                 = 15      ; (zp)
                        	    26: ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y  = 16      ; (zp),y
                        	    27: ASS_OPERAND_STRING                             = 17      ; "But does it get goat's blood out?"
                        	    28: ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE             = 18      ; zp,r
                        	    29: 
                        	    30: ;
                        	    31: ;  Entry point for assembler
                        	    32: ;
                        	    33: ASSEMBLE:
                        	    34: 
00:9861 A2FF            	    35:    ldx  #NEW_STK
00:9863 9A              	    36:    txs    ; set stack back to 0xFF
00:9864 6476            	    37:    stz  ASS_PASS  ; first pass
00:9866 20F991          	    38:    jsr  INIT       ; sets up pointers, calls LINE
00:9869 2093AA          	    39:    jsr  add_assembler_library_functions  ; add our inbuilt functions to the symbol table
00:986C 8005            	    40:    bra  ASSEMBLE_PASS
                        	    41: 
                        	    42: ASSEMBLE_SECOND_PASS:
00:986E E676            	    43:    inc  ASS_PASS
00:9870 200592          	    44:    jsr  INIT_SECOND_PASS    ; don't re-initialise the symbol table
                        	    45: ASSEMBLE_PASS:
00:9873 64A2            	    46:    stz  current_line  ; we'll got for zero, not one
                        	    47: 
00:9875 A902            	    48:    lda  #FLAG_ASSEMBLING
00:9877 04BE            	    49:    tsb  system_flags
                        	    50: 
                        	    51: ;
                        	    52: ;  no listing yet
                        	    53: ;
00:9879 642E            	    54:    stz  DCODE
00:987B 641D            	    55:    stz  LIST
00:987D 6442            	    56:    stz  SYNTAX
00:987F 6482            	    57:    stz  show_symbols
                        	    58: ;
                        	    59: ; zero line count
                        	    60: ;
00:9881 6419            	    61:    stz  LINE_CNT
00:9883 641A            	    62:    stz  LINE_CNT+1
                        	    63: 
                        	    64: ;
                        	    65: ;  and emitted bytes count
                        	    66: ;
00:9885 6477            	    67:    stz ass_emit_bytes
00:9887 6478            	    68:    stz ass_emit_bytes+1
                        	    69: 
                        	    70: ;
                        	    71: ; no previous token
                        	    72: ;
00:9889 6493            	    73:    stz  token_type
00:988B 800E            	    74:    bra ass_line
                        	    75: 
                        	    76: ass_finish_line:
00:988D A593            	    77:    lda token_type
00:988F C90A            	    78:    cmp #NL
00:9891 F008            	    79:    beq ass_line
00:9893 A213            	    80:    ldx #19    ; Incorrect Symbol
00:9895 4CC39E          	    81:    jmp ass_error
                        	    82: 
                        	    83: ass_done_jump:
00:9898 4C969B          	    84:    jmp ass_done
                        	    85: ;
                        	    86: ;  here for the start of a line
                        	    87: ;
                        	    88: ass_line:
00:989B A576            	    89:   lda ASS_PASS    ; only showing codes on 2nd pass
00:989D F00B            	    90:   beq ass_line1
00:989F A56F            	    91:   lda ASS_EMIT_COUNT  ; only need a newline if we actually output a code
00:98A1 F007            	    92:   beq ass_line1
00:98A3 A52E            	    93:   lda DCODE           ; is showing codes on?
00:98A5 F003            	    94:   beq ass_line1
00:98A7 204792          	    95:   jsr CROUT
                        	    96: ass_line1:
00:98AA A000            	    97:   ldy #0
00:98AC B18E            	    98:   lda (token_start),y ; quick test so we don't list a non-existent line
00:98AE F0E8            	    99:   beq ass_done_jump
                        	   100: 
00:98B0 A58E            	   101:   lda token_start
00:98B2 859C            	   102:   sta token_line_start
00:98B4 A58F            	   103:   lda token_start+1
00:98B6 859D            	   104:   sta token_line_start+1
00:98B8 2038CA          	   105:   jsr token_line        ; list the next line
                        	   106: 
00:98BB 646B            	   107:   stz ASS_OPERAND   ; no operand yet
00:98BD 646F            	   108:   stz ASS_EMIT_COUNT
00:98BF 6483            	   109:   stz ass_current_label
00:98C1 6484            	   110:   stz ass_current_label+1
                        	   111: 
00:98C3 2098C9          	   112:   jsr get_token
                        	   113: 
00:98C6 C949            	   114:   cmp #TOKEN_IDENTIFIER  ; could be a label if in column 1
00:98C8 F011            	   115:   beq ass_identifier
00:98CA C93D            	   116:   cmp #'='               ; = directive is OK
00:98CC F00D            	   117:   beq ass_identifier
                        	   118: 
00:98CE C90A            	   119:   cmp #NL
00:98D0 F0C9            	   120:   beq ass_line
                        	   121: 
00:98D2 C900            	   122:   cmp #0
00:98D4 F0C2            	   123:   beq ass_done_jump
                        	   124: 
                        	   125: ass_bad_identifier:
00:98D6 A204            	   126:   ldx #4      ; Identifier expected
00:98D8 4CC39E          	   127:   JMP ass_error
                        	   128: 
                        	   129: ass_identifier:
                        	   130: 
                        	   131: ;
                        	   132: ;  if the identifier is at the start of the line, it is a label, not an opcode
                        	   133: ;
00:98DB A590            	   134:   lda token_address
00:98DD C59C            	   135:   cmp token_line_start
00:98DF D063            	   136:   bne ass_opcode
00:98E1 A591            	   137:   lda token_address+1
00:98E3 C59D            	   138:   cmp token_line_start+1
00:98E5 D05D            	   139:   bne ass_opcode
                        	   140: 
00:98E7 A593            	   141:   lda token_type         ; can't have = as an identifier
00:98E9 C93D            	   142:   cmp #'='               ; or "="
00:98EB F0E9            	   143:   beq ass_bad_identifier
                        	   144: 
                        	   145: ;
                        	   146: ;  here for label - on the first pass, add it to the symbol table, on the second pass look it up
                        	   147: ;
00:98ED A576            	   148:   lda ASS_PASS
00:98EF D014            	   149:   bne ass_lookup_existing_label
                        	   150: ;
                        	   151: ;  here for first pass
                        	   152: ;
00:98F1 203FBA          	   153:   jsr CHKDUP
                        	   154: ;
                        	   155: ; not a duplicate - add it
                        	   156: ;
00:98F4 A523            	   157:   lda PCODE
00:98F6 8594            	   158:   sta token_value
00:98F8 A524            	   159:   lda PCODE+1
00:98FA 8595            	   160:   sta token_value+1
00:98FC 6496            	   161:   stz token_value+2
00:98FE A943            	   162:   lda #SYMBOL_CONSTANT
00:9900 2098B9          	   163:   jsr ADDSYM
00:9903 8016            	   164:   bra ass_added_symbol
                        	   165: 
                        	   166: ;
                        	   167: ;  here for second pass
                        	   168: ;
                        	   169: ass_lookup_existing_label:
00:9905 201CB9          	   170:   jsr SEARCH  ; look it up
00:9908 D005            	   171:   bne ass_lookup_save_address  ; it should be!
00:990A A206            	   172:   ldx #6  ; ERROR: bug
00:990C 4CC39E          	   173:   jmp ass_error
                        	   174: 
                        	   175: ass_lookup_save_address:
00:990F A594            	   176:   lda token_value
00:9911 8573            	   177:   sta ASS_VALUE
00:9913 A595            	   178:   lda token_value+1
00:9915 8574            	   179:   sta ASS_VALUE+1
00:9917 A596            	   180:   lda token_value+2
00:9919 8575            	   181:   sta ASS_VALUE+2
                        	   182: 
                        	   183: ;
                        	   184: ;  the symbol has either been added, or looked up to make sure it is still there
                        	   185: ;
                        	   186: ass_added_symbol:
                        	   187: 
                        	   188: ;
                        	   189: ;  remember its address in case we have an EQU directive
                        	   190: ;
00:991B A540            	   191:   lda SYMITM
00:991D 8583            	   192:   sta ass_current_label
00:991F A541            	   193:   lda SYMITM+1
00:9921 8584            	   194:   sta ass_current_label+1
                        	   195: 
                        	   196: ;
                        	   197: ;  get whatever is after the label
                        	   198: ;
00:9923 2098C9          	   199:   jsr get_token
00:9926 C93A            	   200:   cmp #':'
00:9928 D003            	   201:   bne ass_not_colon
00:992A 2098C9          	   202:   jsr get_token  ; skip the colon
                        	   203: ass_not_colon:
00:992D C90A            	   204:   cmp #NL     ; newline means this is just a label line
00:992F D003            	   205:   bne ass_not_colon2
00:9931 4C8D98          	   206:   jmp ass_finish_line
                        	   207: 
                        	   208: ass_not_colon2:
00:9934 C949            	   209:   cmp #TOKEN_IDENTIFIER  ; should be an opcode now
00:9936 F00C            	   210:   beq ass_opcode
00:9938 C93D            	   211:   cmp #'='               ; = directive is OK
00:993A F008            	   212:   beq ass_opcode
                        	   213: 
                        	   214: ass_illegal_opcode:
00:993C 20BC92          	   215:   jsr PRBYTE
00:993F A228            	   216:   ldx #40      ; ERROR: illegal opcode
00:9941 4CC39E          	   217:   JMP ass_error
                        	   218: 
                        	   219: ass_opcode:
                        	   220: 
                        	   221: ;
                        	   222: ;  this will be our assembler mnemonic or directive so save its start point and length
                        	   223: ;
                        	   224: 
00:9944 A690            	   225:   ldx token_address
00:9946 866C            	   226:   stx OPCODE
00:9948 A691            	   227:   ldx token_address+1
00:994A 866D            	   228:   stx OPCODE+1
00:994C A692            	   229:   ldx token_length
00:994E 866E            	   230:   stx OPCODE_LEN
                        	   231: 
                        	   232: ;
                        	   233: ;  if we had a label on the line, check its address hasn't changed (on the second pass)
                        	   234: ;   UNLESS it is an EQU directive in which case it probably did change
                        	   235: ;
00:9950 A576            	   236:   lda ASS_PASS
00:9952 F046            	   237:   beq ass_opcode2
00:9954 A583            	   238:   lda ass_current_label
00:9956 0584            	   239:   ora ass_current_label+1   ; was there a label?
00:9958 F040            	   240:   beq ass_opcode2    ; nope
00:995A A593            	   241:   lda token_type
00:995C C93D            	   242:   cmp #'='
00:995E F03A            	   243:   beq ass_opcode2   ; don't check on "=" directive
00:9960 A592            	   244:   lda token_length
00:9962 C903            	   245:   cmp #3
00:9964 D034            	   246:   bne ass_opcode2   ; can't be EQU
                        	   247: ;
                        	   248: ; this is truly crap, but I am feeling lazy
                        	   249: ;
00:9966 A000            	   250:   ldy #0
00:9968 B190            	   251:   lda (token_address),y
00:996A 20E38F          	   252:   jsr MAKE_UPPER
00:996D C945            	   253:   cmp #'E'
00:996F D014            	   254:   bne ass_check_label_changed
00:9971 C8              	   255:   iny
00:9972 B190            	   256:   lda (token_address),y
00:9974 20E38F          	   257:   jsr MAKE_UPPER
00:9977 C951            	   258:   cmp #'Q'
00:9979 D00A            	   259:   bne ass_check_label_changed
00:997B C8              	   260:   iny
00:997C B190            	   261:   lda (token_address),y
00:997E 20E38F          	   262:   jsr MAKE_UPPER
00:9981 C955            	   263:   cmp #'U'
00:9983 F015            	   264:   beq ass_opcode2
                        	   265: 
                        	   266: ;
                        	   267: ;  we looked up the label earlier, when it was the current token,
                        	   268: ;   and we saved its value in ASS_VALUE
                        	   269: ;
                        	   270: 
                        	   271: ass_check_label_changed:
00:9985 A523            	   272:   lda PCODE
00:9987 C573            	   273:   cmp ASS_VALUE
00:9989 D00A            	   274:   bne ass_symbol_address_changed
00:998B A524            	   275:   lda PCODE+1
00:998D C574            	   276:   cmp ASS_VALUE+1
00:998F D004            	   277:   bne ass_symbol_address_changed
00:9991 A575            	   278:   lda ASS_VALUE+2   ; 3rd byte should be zero
00:9993 F005            	   279:   beq ass_opcode2
                        	   280: 
                        	   281: ass_symbol_address_changed:
00:9995 A22D            	   282:   ldx #45     ; ERROR: Symbol address changed
00:9997 4CC39E          	   283:   jmp ass_error
                        	   284: 
                        	   285: 
                        	   286: 
                        	   287: ass_opcode2:
                        	   288: ;
                        	   289: ;  look up operand
                        	   290: ;
                        	   291: 
00:999A 2098C9          	   292:   jsr get_token
00:999D C90A            	   293:   cmp #NL           ; or end of line?
00:999F D00D            	   294:   bne ass_operand
                        	   295: 
                        	   296: ;
                        	   297: ;  here when the opcode is followed by (spaces) or a newline
                        	   298: ;
00:99A1 A908            	   299:   lda #ASS_OPERAND_IMPLIED
00:99A3 856B            	   300:   sta ASS_OPERAND
00:99A5 20ED9A          	   301:   jsr opcode_lookup
00:99A8 20D99B          	   302:   jsr ass_check_no_more_tokens
                        	   303: ass_finish_lineJ:
00:99AB 4C8D98          	   304:   jmp ass_finish_line
                        	   305: 
                        	   306: ass_operand:
00:99AE C923            	   307:   cmp #'#'  ; immediate?
00:99B0 F01B            	   308:   beq ass_immediate
00:99B2 C928            	   309:   cmp #'('  ; indirect?
00:99B4 F02A            	   310:   beq ass_indirect
00:99B6 C949            	   311:   cmp #TOKEN_IDENTIFIER
00:99B8 F02F            	   312:   beq ass_identifier_operand
00:99BA C922            	   313:   cmp #TOKEN_STRING
00:99BC F002            	   314:   beq ass_string
                        	   315: ;
                        	   316: ;  here for some kind of numeric address
                        	   317: ;
00:99BE 804A            	   318:   bra ass_operand_value
                        	   319: 
                        	   320: ;
                        	   321: ;  Here for a string as an operand, should be a compiler directive, eg.  ASC "Hello, world"
                        	   322: ;
                        	   323: ass_string:
00:99C0 A911            	   324:   lda #ASS_OPERAND_STRING
00:99C2 856B            	   325:   sta ASS_OPERAND
00:99C4 20ED9A          	   326:   jsr opcode_lookup
00:99C7 2098C9          	   327:   jsr get_token  ; NOW get the next token
00:99CA 4C8D98          	   328:   jmp ass_finish_line
                        	   329: 
                        	   330: ;
                        	   331: ;  immediate, that is:  #<expression>
                        	   332: ;
                        	   333: ass_immediate:
00:99CD A907            	   334:   lda #ASS_OPERAND_IMMEDIATE
00:99CF 856B            	   335:   sta ASS_OPERAND
00:99D1 2098C9          	   336:   jsr get_token
00:99D4 20F09C          	   337:   jsr ass_get_value
00:99D7 20D99B          	   338:   jsr ass_check_no_more_tokens
00:99DA 20ED9A          	   339:   jsr opcode_lookup
00:99DD 4C8D98          	   340:   jmp ass_finish_line
                        	   341: 
                        	   342: ;
                        	   343: ;  indirect, that is: (expression) OR (expression,X) OR (expression),Y
                        	   344: ;
                        	   345: ass_indirect:
00:99E0 A905            	   346:   lda #ASS_OPERAND_ABSOLUTE_INDIRECT  ; first guess
00:99E2 856B            	   347:   sta ASS_OPERAND
00:99E4 2098C9          	   348:   jsr get_token    ; skip the bracket
00:99E7 8021            	   349:   bra ass_operand_value
                        	   350: 
                        	   351: ;
                        	   352: ;  some sort of identifier, possibly the start of an expression or maybe just "A"
                        	   353: ;
                        	   354: ass_identifier_operand:
                        	   355: 
                        	   356: ;
                        	   357: ;  see if the operand is just the letter "A"
                        	   358: ;
00:99E9 A592            	   359:   lda token_length
00:99EB C901            	   360:   cmp #1
00:99ED D01B            	   361:   bne ass_operand_value
00:99EF A000            	   362:   ldy #0
00:99F1 B190            	   363:   lda (token_address),Y
00:99F3 20E38F          	   364:   jsr MAKE_UPPER
00:99F6 C941            	   365:   cmp #'A'
00:99F8 D010            	   366:   bne ass_operand_value
00:99FA A906            	   367:   lda #ASS_OPERAND_ACCUMULATOR_A
00:99FC 856B            	   368:   sta ASS_OPERAND
00:99FE 2098C9          	   369:   jsr get_token  ; skip past A
00:9A01 20D99B          	   370:   jsr ass_check_no_more_tokens
00:9A04 20ED9A          	   371:   jsr opcode_lookup
00:9A07 4C8D98          	   372:   jmp ass_finish_line
                        	   373: 
                        	   374: ;
                        	   375: ;  a number or identifier - evaluate as an expression
                        	   376: ;
                        	   377: ass_operand_value:
                        	   378: 
00:9A0A A593            	   379:   lda token_type ; get token back
00:9A0C 20F09C          	   380:   jsr ass_get_value  ; should have some sort of address now in VALUE
                        	   381: ;
                        	   382: ;  we come back with the first non-value token loaded in TOKEN
                        	   383: ;  now see if we originally had a bracket, so this must be one of those indirect things
                        	   384: ;
00:9A0F A56B            	   385:   lda ASS_OPERAND
00:9A11 C905            	   386:   cmp #ASS_OPERAND_ABSOLUTE_INDIRECT
00:9A13 D02D            	   387:   bne ass_value_not_indirectJ
00:9A15 A593            	   388:   lda token_type   ; now we should have a comma or a bracket
00:9A17 C929            	   389:   cmp #')'
00:9A19 F02F            	   390:   beq ass_indirect_with_bracket
                        	   391: ;
                        	   392: ;  We had an opening bracket but not a closing bracket. Must be a comma then
                        	   393: ;
                        	   394: 
00:9A1B A92C            	   395:   lda #','
00:9A1D A220            	   396:   ldx #32  ; ERROR: , expected
00:9A1F 20AACF          	   397:   jsr CHKTKN
                        	   398: ;
                        	   399: ;  now we must have X
                        	   400: ;
00:9A22 20869A          	   401:   jsr ass_check_we_have_x_or_y
00:9A25 901E            	   402:   bcc ass_bad_indirect
00:9A27 C958            	   403:   cmp #'X'
00:9A29 D01A            	   404:   bne ass_bad_indirect
00:9A2B A902            	   405:   lda #ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
00:9A2D 856B            	   406:   sta ASS_OPERAND
00:9A2F A929            	   407:   lda #')'
00:9A31 A216            	   408:   ldx #22  ; ERROR: ) expected
00:9A33 209ACF          	   409:   jsr GETCHK
00:9A36 2098C9          	   410:   jsr get_token
00:9A39 20D99B          	   411:   jsr ass_check_no_more_tokens
00:9A3C 20ED9A          	   412:   jsr opcode_lookup
00:9A3F 4C8D98          	   413:   jmp ass_finish_line
                        	   414: 
00:9A42 4CA49A          	   415: ass_value_not_indirectJ jmp ass_value_not_indirect
                        	   416: 
                        	   417: ass_bad_indirect:
00:9A45 A229            	   418:   ldx #41  ; ERROR: illegal addressing mode
00:9A47 4CC39E          	   419:   jmp ass_error
                        	   420: 
                        	   421: 
                        	   422: ;
                        	   423: ;  we have some sort of indirect expression followed by a bracket, so see if there is ",Y" after it
                        	   424: ;
                        	   425: ass_indirect_with_bracket:
                        	   426: ;
                        	   427: ;  can only be (a), (zp) or (zp),y
                        	   428: ;
00:9A4A 2098C9          	   429:   jsr get_token
00:9A4D C92C            	   430:   cmp #','
00:9A4F F00D            	   431:   beq ass_zp_indirect_indexed
00:9A51 20D99B          	   432:   jsr ass_check_no_more_tokens
00:9A54 A905            	   433:   lda #ASS_OPERAND_ABSOLUTE_INDIRECT
00:9A56 856B            	   434:   sta ASS_OPERAND
00:9A58 20ED9A          	   435:   jsr opcode_lookup
00:9A5B 4C8D98          	   436:   jmp ass_finish_line
                        	   437: 
                        	   438: 
                        	   439: ;
                        	   440: ;  For indirect followed by a comma, we must have Y and nothing else
                        	   441: ;  Also, the operand must be a zero-page address
                        	   442: ;
                        	   443: ass_zp_indirect_indexed:
00:9A5E 20869A          	   444:   jsr ass_check_we_have_x_or_y
00:9A61 90E2            	   445:   bcc ass_bad_indirect
00:9A63 C959            	   446:   cmp #'Y'
00:9A65 D0DE            	   447:   bne ass_bad_indirect
00:9A67 A574            	   448:   lda ASS_VALUE+1
00:9A69 D014            	   449:   bne ass_bad_zp_indirect_indexed
00:9A6B A575            	   450:   lda ASS_VALUE+2
00:9A6D D010            	   451:   bne ass_bad_zp_indirect_indexed
00:9A6F A910            	   452:   lda #ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
00:9A71 856B            	   453:   sta ASS_OPERAND
00:9A73 2098C9          	   454:   jsr get_token  ; skip the Y
00:9A76 20D99B          	   455:   jsr ass_check_no_more_tokens
00:9A79 20ED9A          	   456:   jsr opcode_lookup
00:9A7C 4C8D98          	   457:   jmp ass_finish_line
                        	   458: 
                        	   459: ass_bad_zp_indirect_indexed:
00:9A7F A22B            	   460:   ldx #43
00:9A81 4CC39E          	   461:   jmp ass_error
                        	   462: 
                        	   463: ass_not_x_or_y:
00:9A84 18              	   464:   clc
00:9A85 60              	   465:   rts
                        	   466: 
                        	   467: ;
                        	   468: ;  we had (<expression>),<something> so check that <something> is X or Y
                        	   469: ;   sets carry if it is
                        	   470: ;
                        	   471: ass_check_we_have_x_or_y:
00:9A86 2098C9          	   472:   jsr get_token
00:9A89 C949            	   473:   cmp #TOKEN_IDENTIFIER
00:9A8B D0F7            	   474:   bne ass_not_x_or_y
00:9A8D A592            	   475:   lda token_length
00:9A8F C901            	   476:   cmp #1
00:9A91 D0F1            	   477:   bne ass_not_x_or_y
00:9A93 A000            	   478:   ldy #0
00:9A95 B190            	   479:   lda (token_address),y
00:9A97 20E38F          	   480:   jsr MAKE_UPPER
00:9A9A C959            	   481:   cmp #'Y'
00:9A9C F004            	   482:   beq ass_check_we_have_x_or_y_ok
00:9A9E C958            	   483:   cmp #'X'
00:9AA0 D0E2            	   484:   bne ass_not_x_or_y
                        	   485: ass_check_we_have_x_or_y_ok:
00:9AA2 38              	   486:   sec
00:9AA3 60              	   487:   rts
                        	   488: 
                        	   489: ;
                        	   490: ;  we had a non-indirect expression, so was it followed by a comma?
                        	   491: ;
                        	   492: 
                        	   493: ass_value_not_indirect:
00:9AA4 A593            	   494:   lda token_type
00:9AA6 C92C            	   495:   cmp #','
00:9AA8 F00D            	   496:   beq ass_indexed
00:9AAA A901            	   497:   lda #ASS_OPERAND_ABSOLUTE
00:9AAC 856B            	   498:   sta ASS_OPERAND
                        	   499: ass_value_done:
00:9AAE 20D99B          	   500:   jsr ass_check_no_more_tokens
00:9AB1 20ED9A          	   501:   jsr opcode_lookup
00:9AB4 4C8D98          	   502:   jmp ass_finish_line
                        	   503: 
                        	   504: ;
                        	   505: ;  <expression>,X or <expression>,Y is what we are expecting here
                        	   506: ;
                        	   507: ;  OR: in the case of BBR0 ... BBR7 and BBS0 ... BBS7 : another expression
                        	   508: ;
                        	   509: 
                        	   510: ass_indexed:
                        	   511: ;
                        	   512: ;  save the value in case we find a second one
                        	   513: ;
                        	   514: ;  checking for another one may change VALUE so we do this now
                        	   515: ;
00:9AB7 A500            	   516:   lda VALUE
00:9AB9 8506            	   517:   sta REMAIN
00:9ABB A501            	   518:   lda VALUE+1
00:9ABD 8507            	   519:   sta REMAIN+1
00:9ABF A502            	   520:   lda VALUE+2
00:9AC1 8508            	   521:   sta REMAIN+2
00:9AC3 20869A          	   522:   jsr ass_check_we_have_x_or_y
00:9AC6 9016            	   523:   bcc ass_absolute_another_value
00:9AC8 C958            	   524:   cmp #'X'
00:9ACA F009            	   525:   beq ass_indexed_x
00:9ACC A904            	   526:   lda #ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
00:9ACE 856B            	   527:   sta ASS_OPERAND
00:9AD0 2098C9          	   528:   jsr get_token ; skip the Y
00:9AD3 80D9            	   529:   bra ass_value_done
                        	   530: ass_indexed_x:
00:9AD5 A903            	   531:   lda #ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
00:9AD7 856B            	   532:   sta ASS_OPERAND
00:9AD9 2098C9          	   533:   jsr get_token ; skip the X
00:9ADC 80D0            	   534:   bra ass_value_done
                        	   535: 
                        	   536: ;
                        	   537: ;  this is hopefully something like BBR0 $42,foo
                        	   538: ;   so we need to evaluate foo
                        	   539: ;
                        	   540: ass_absolute_another_value:
00:9ADE A593            	   541:   lda token_type ; get token back
00:9AE0 20F09C          	   542:   jsr ass_get_value  ; should have some sort of address now in VALUE
                        	   543: ;  jsr ass_check_no_more_tokens
00:9AE3 A912            	   544:   lda #ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE
00:9AE5 856B            	   545:   sta ASS_OPERAND
00:9AE7 20ED9A          	   546:   jsr opcode_lookup
00:9AEA 4C8D98          	   547:   jmp ass_finish_line
                        	   548: 
                        	   549: 
                        	   550: ;
                        	   551: ;  look up opcode
                        	   552: ;
                        	   553: opcode_lookup:
                        	   554:   ; the opcode we are looking up
00:9AED A56C            	   555:   lda OPCODE
00:9AEF 8500            	   556:   sta SRCE
00:9AF1 A56D            	   557:   lda OPCODE+1
00:9AF3 8501            	   558:   sta SRCE+1
00:9AF5 6472            	   559:   stz ASS_COUNT   ; count of matches
                        	   560: ;
                        	   561: ;  get the address of our table of tables
                        	   562: ;
00:9AF7 A937            	   563:   lda #<OPCODE_LOOKUP_TABLE
00:9AF9 8570            	   564:   sta ASS_OPCODE_WORK
00:9AFB A99F            	   565:   lda #>OPCODE_LOOKUP_TABLE
00:9AFD 8571            	   566:   sta ASS_OPCODE_WORK+1
                        	   567: opcode_lookup_loop:
00:9AFF A000            	   568:   ldy #OPCODE_LOOKUP_OPCODE_LENGTH
00:9B01 B170            	   569:   lda (ASS_OPCODE_WORK),Y       ; get opcode length
00:9B03 F058            	   570:   beq opcode_lookup_loop_done   ; end of table
00:9B05 C56E            	   571:   cmp OPCODE_LEN                ; right length?
00:9B07 F00F            	   572:   beq opcode_lookup_correct_length ; yes
                        	   573: ;
                        	   574: ; no, try the next table item
                        	   575: ;
                        	   576: opcode_lookup_next_table:
00:9B09 18              	   577:   clc
00:9B0A A570            	   578:   lda ASS_OPCODE_WORK
00:9B0C 6906            	   579:   adc #OPCODE_LOOKUP_TABLE_SIZE  ; onto next item
00:9B0E 8570            	   580:   sta ASS_OPCODE_WORK
00:9B10 A571            	   581:   lda ASS_OPCODE_WORK+1
00:9B12 6900            	   582:   adc #0
00:9B14 8571            	   583:   sta ASS_OPCODE_WORK+1
00:9B16 80E7            	   584:   bra opcode_lookup_loop
                        	   585: opcode_lookup_correct_length:
00:9B18 A002            	   586:   ldy #OPCODE_LOOKUP_OPCODE_TABLE
00:9B1A B170            	   587:   lda (ASS_OPCODE_WORK),Y ; get table address low-order byte
00:9B1C 8503            	   588:   sta DEST
00:9B1E C8              	   589:   iny
00:9B1F B170            	   590:   lda (ASS_OPCODE_WORK),Y ; get table address high-order byte
00:9B21 8504            	   591:   sta DEST+1
00:9B23 20619E          	   592:   jsr ass_lookup_loop
00:9B26 90E1            	   593:   bcc opcode_lookup_next_table  ; not found
00:9B28 AA              	   594:   tax   ; save the machine code byte
00:9B29 E672            	   595:   inc ASS_COUNT
00:9B2B A001            	   596:   ldy #OPCODE_LOOKUP_OPERAND_TYPE
00:9B2D A56B            	   597:   lda ASS_OPERAND         ; get wanted type of operand?
00:9B2F D170            	   598:   cmp (ASS_OPCODE_WORK),Y ; compare to operand type in table
00:9B31 F013            	   599:   beq opcode_lookup_correct_operand  ; yes
00:9B33 C906            	   600:   cmp #ASS_OPERAND_ACCUMULATOR_A  ; see if in range 1 to 5
00:9B35 B0D2            	   601:   bcs opcode_lookup_next_table
                        	   602: ;
                        	   603: ;  so if we have a so-called ASS_OPERAND_ABSOLUTE (with various indexing modes)
                        	   604: ;  see if we can match on ASS_OPERAND_ZERO_PAGE by adding 10 to the operand type
                        	   605: ;  - also applies to all the absolute modes (1 to 5)
                        	   606: ;
00:9B37 18              	   607:   clc
00:9B38 690A            	   608:   adc #10
00:9B3A D170            	   609:   cmp (ASS_OPCODE_WORK),Y
00:9B3C D0CB            	   610:   bne opcode_lookup_next_table
                        	   611: ;
                        	   612: ;  plus, the operand has to be in the zero page
                        	   613: ;
00:9B3E A574            	   614:   lda ASS_VALUE+1
00:9B40 D0C7            	   615:   bne opcode_lookup_next_table
00:9B42 A575            	   616:   lda ASS_VALUE+2
00:9B44 D0C3            	   617:   bne opcode_lookup_next_table
                        	   618: opcode_lookup_correct_operand:
00:9B46 8A              	   619:   txa   ; get the byte to emit back
                        	   620: 
                        	   621: ;
                        	   622: ; we have a match! emit the opcode
                        	   623: ;
00:9B47 20859E          	   624:   jsr ass_emit            ; emit it
00:9B4A A004            	   625:   ldy #OPCODE_LOOKUP_HANDLER  ; offset of handler
00:9B4C B170            	   626:   lda (ASS_OPCODE_WORK),Y ; get opcode handler address low-order byte
00:9B4E AA              	   627:   tax
00:9B4F C8              	   628:   iny
00:9B50 B170            	   629:   lda (ASS_OPCODE_WORK),Y ; get opcode handler address high-order byte
00:9B52 F008            	   630:   beq opcode_lookup_no_handler
00:9B54 8571            	   631:   sta ASS_OPCODE_WORK+1
00:9B56 8A              	   632:   txa
00:9B57 8570            	   633:   sta ASS_OPCODE_WORK
00:9B59 6C7000          	   634:   jmp (ASS_OPCODE_WORK)   ; do handler - it will RTS for us
                        	   635: 
                        	   636: opcode_lookup_no_handler:
                        	   637: ; put nothing here as it won't be done if there is a handler
00:9B5C 60              	   638:   rts    ; done!
                        	   639: 
                        	   640: opcode_lookup_loop_done:
                        	   641: ;
                        	   642: ;  look for assembler directives
                        	   643: ;
00:9B5D A9DA            	   644:   lda #<DIRECTIVES
00:9B5F 8503            	   645:   sta DEST
00:9B61 A99F            	   646:   lda #>DIRECTIVES
00:9B63 8504            	   647:   sta DEST+1
00:9B65 A56E            	   648:   lda OPCODE_LEN
                        	   649: 
                        	   650: ;  pha
                        	   651: ;   lda #'c'
                        	   652: ;   jsr ass_debug_point
                        	   653: ;   pla
                        	   654: 
00:9B67 20298F          	   655:   jsr handlerLookup
00:9B6A 9029            	   656:   bcc opcode_lookup_ok
                        	   657: 
                        	   658: ;   lda #'d'
                        	   659: ;   jsr ass_debug_point
                        	   660: 
                        	   661: ;
                        	   662: ;  here for unknown opcode
                        	   663: ;
00:9B6C A56C            	   664:   lda OPCODE
00:9B6E 8590            	   665:   sta token_address
00:9B70 A56D            	   666:   lda OPCODE+1
00:9B72 8591            	   667:   sta token_address+1
00:9B74 A56E            	   668:   lda OPCODE_LEN
00:9B76 8592            	   669:   sta token_length
                        	   670: 
                        	   671: ;
                        	   672: ;  if we NEVER found a match, this is an illegal opcode
                        	   673: ;
00:9B78 A921            	   674:   lda #'!'
00:9B7A 20CE93          	   675:   jsr COUT
00:9B7D A66E            	   676:   ldx OPCODE_LEN
00:9B7F A000            	   677:   ldy #0
                        	   678: wtf_loop:
00:9B81 B16C            	   679:    lda (OPCODE),Y
00:9B83 20CE93          	   680:    jsr COUT
00:9B86 C8              	   681:    iny
00:9B87 CA              	   682:    dex
00:9B88 D0F7            	   683:    bne wtf_loop
                        	   684: 
                        	   685: 
00:9B8A A228            	   686:   ldx  #40    ; illegal opcode
00:9B8C A572            	   687:   lda ASS_COUNT
00:9B8E F002            	   688:   beq opcode_lookup_loop_unknown
                        	   689: ;
                        	   690: ;  if we found a match, but not for this addressing mode, they used an illegal mode
                        	   691: ;
00:9B90 A229            	   692:   ldx  #41   ; illegal addressing mode
                        	   693: opcode_lookup_loop_unknown:
00:9B92 4CC39E          	   694:   JMP  ass_error
                        	   695: 
                        	   696: opcode_lookup_ok:
                        	   697: 
                        	   698: ;   lda #'e'
                        	   699: ; jsr ass_debug_point
                        	   700: 
00:9B95 60              	   701:   rts
                        	   702: 
                        	   703: ass_done:
00:9B96 204792          	   704:   jsr  CROUT
00:9B99 A576            	   705:   LDA  ASS_PASS
00:9B9B D003            	   706:   bne  ass_done_second_pass
00:9B9D 4C6E98          	   707:   jmp  ASSEMBLE_SECOND_PASS
                        	   708: ass_done_second_pass:
00:9BA0 A9BB            	   709:   LDA  #<ass_done_message  ; Assemble finished: No Errors
00:9BA2 A29B            	   710:   LDX  #>ass_done_message
00:9BA4 202682          	   711:   JSR  print
00:9BA7 A910            	   712:   lda  #FLAG_VALID_ASSEMBLE
00:9BA9 04BE            	   713:   tsb  system_flags
00:9BAB 20C48E          	   714:   jsr  show_symbol_table_end
00:9BAE 20E98E          	   715:   jsr  show_source_end
00:9BB1 A582            	   716:   lda  show_symbols
00:9BB3 F003            	   717:   beq  ass_done1
00:9BB5 207EA5          	   718:   jsr  list_symbols
                        	   719: ass_done1:
00:9BB8 4C8282          	   720:   JMP  main_prompt
                        	   721: 
00:9BBB 417373656D626C65	   722: ass_done_message asciiz "Assemble finished: No errors\n"
00:9BC3 2066696E69736865
00:9BCB 643A204E6F206572
00:9BD3 726F72730A
00:9BD8 00
                        	   723: 
                        	   724: ass_check_no_more_tokens:
00:9BD9 A593            	   725:   lda token_type
00:9BDB C90A            	   726:   cmp #NL           ; or end of line?
00:9BDD F005            	   727:   beq ass_check_no_more_tokens_ok
00:9BDF A213            	   728:   ldx #19    ; ERROR: incorrect symbol
00:9BE1 4CC39E          	   729:   jmp ass_error
                        	   730: 
                        	   731: ass_check_no_more_tokens_ok:
00:9BE4 60              	   732:   rts
                        	   733: 
                        	   734: ;
                        	   735: ;  push a 3-byte value (in VALUE) onto the evaluation stack
                        	   736: ;    changes A and Y
                        	   737: ;
                        	   738: exp_push_value = *
00:9BE5 A57B            	   739:   lda exp_value_stack_count
00:9BE7 C9FF            	   740:   cmp #$FF
00:9BE9 D005            	   741:   bne exp_push_value_ok
                        	   742: exp_push_value_memory_full:
00:9BEB A22E            	   743:   ldx #46   ; ERROR: Expression too complex
00:9BED 4CC39E          	   744:   jmp ass_error
                        	   745: exp_push_value_ok:
00:9BF0 E67B            	   746:   inc exp_value_stack_count
00:9BF2 38              	   747:   sec
00:9BF3 A579            	   748:   lda exp_value_stack
00:9BF5 E903            	   749:   sbc #3
00:9BF7 8579            	   750:   sta exp_value_stack
00:9BF9 A57A            	   751:   lda exp_value_stack+1
00:9BFB E900            	   752:   sbc #0
00:9BFD 857A            	   753:   sta exp_value_stack+1
                        	   754: ;
                        	   755: ;  has our expression value fallen down into our P-codes?
                        	   756: ;
                        	   757: ;  This doesn't work if the output (PCODE) has been relocated to above
                        	   758: ;  the symbol table and I can't think of an easy solution, so let's ignore
                        	   759: ;  it and hope it doesn't happen.
                        	   760: ;
                        	   761: ;
                        	   762: ; lda  PCODE+1               ; see if P-codes full
                        	   763: ; cmp  exp_value_stack+1     ; in other words, have we hit the symbol table?
                        	   764: ; bcc  exp_push_value_not_full      ; less than
                        	   765: ; bne  exp_push_value_memory_full   ; greater than
                        	   766: ; lda  PCODE
                        	   767: ; cmp  exp_value_stack
                        	   768: ; bcs  exp_push_value_memory_full   ; BGE
                        	   769: 
                        	   770: exp_push_value_not_full:
00:9BFF A000            	   771:   ldy #0
00:9C01 A500            	   772:   lda VALUE
00:9C03 9179            	   773:   sta (exp_value_stack),y
00:9C05 C8              	   774:   iny
00:9C06 A501            	   775:   lda VALUE+1
00:9C08 9179            	   776:   sta (exp_value_stack),y
00:9C0A C8              	   777:   iny
00:9C0B A502            	   778:   lda VALUE+2
00:9C0D 9179            	   779:   sta (exp_value_stack),y
00:9C0F 60              	   780:   rts
                        	   781: 
                        	   782: ;
                        	   783: ;  pop a 3-byte value (into VALUE) from the evaluation stack
                        	   784: ;    changes A and Y
                        	   785: ;
                        	   786: exp_pop_value = *
00:9C10 A57B            	   787:   lda exp_value_stack_count
00:9C12 D005            	   788:   bne exp_pop_value_ok
00:9C14 A217            	   789:   ldx #23    ; ERROR: illegal factor
00:9C16 4CC39E          	   790:   jmp ass_error
                        	   791: exp_pop_value_ok:
00:9C19 C67B            	   792:   dec exp_value_stack_count
00:9C1B A000            	   793:   ldy #0
00:9C1D B179            	   794:   lda (exp_value_stack),y
00:9C1F 8500            	   795:   sta VALUE
00:9C21 C8              	   796:   iny
00:9C22 B179            	   797:   lda (exp_value_stack),y
00:9C24 8501            	   798:   sta VALUE+1
00:9C26 C8              	   799:   iny
00:9C27 B179            	   800:   lda (exp_value_stack),y
00:9C29 8502            	   801:   sta VALUE+2
00:9C2B 18              	   802:   clc
00:9C2C A579            	   803:   lda exp_value_stack
00:9C2E 6903            	   804:   adc #3
00:9C30 8579            	   805:   sta exp_value_stack
00:9C32 A57A            	   806:   lda exp_value_stack+1
00:9C34 6900            	   807:   adc #0
00:9C36 857A            	   808:   sta exp_value_stack+1
00:9C38 60              	   809:   rts
                        	   810: 
                        	   811: ;
                        	   812: ;  I needed a work area for operators, and initially used INBUF however that got
                        	   813: ;  repurposed for managing strings (in particular handling \Xnn and double quotes)
                        	   814: ;  so now I am using the memory at the current PCODE address as a work area.
                        	   815: ;  It is only needed during expression evaluation, and should hopefully be available.
                        	   816: ;
                        	   817: ;
                        	   818: ;  push an operator (A) onto the operator stack
                        	   819: ;   changes X and Y
                        	   820: ;
                        	   821: exp_push_operator:
00:9C39 A67C            	   822:   ldx exp_operator_stack_count
00:9C3B E0FA            	   823:   cpx #250  ; make sure we don't overflow our operator stack
00:9C3D 9005            	   824:   bcc exp_push_operator_ok
00:9C3F A22E            	   825:   ldx #46   ; ERROR: Expression too complex
00:9C41 4CC39E          	   826:   jmp ass_error
                        	   827: exp_push_operator_ok:
00:9C44 E67C            	   828:   inc exp_operator_stack_count  ; add, then store
00:9C46 A47C            	   829:   ldy exp_operator_stack_count
00:9C48 9123            	   830:   sta (PCODE),Y
00:9C4A 60              	   831:   rts
                        	   832: 
                        	   833: ;
                        	   834: ;  pop an operator (into A) from the operator stack
                        	   835: ;   changes X and Y
                        	   836: ;
                        	   837: exp_pop_operator:
00:9C4B A67C            	   838:   ldx exp_operator_stack_count
00:9C4D D005            	   839:   bne exp_pop_operator_ok
00:9C4F A217            	   840:   ldx #23   ; ERROR: Illegal factor
00:9C51 4CC39E          	   841:   jmp ass_error
                        	   842: exp_pop_operator_ok:
00:9C54 A47C            	   843:   ldy exp_operator_stack_count  ; retrieve, then decrement
00:9C56 B123            	   844:   lda (PCODE),Y
00:9C58 C67C            	   845:   dec exp_operator_stack_count
00:9C5A 60              	   846:   rts
                        	   847: 
                        	   848: ;
                        	   849: ;  get an operator (into A) from the operator stack (without removing it)
                        	   850: ;   changes X and Y
                        	   851: ;
                        	   852: exp_get_operator:
00:9C5B A67C            	   853:   ldx exp_operator_stack_count
00:9C5D D005            	   854:   bne exp_get_operator_ok
00:9C5F A217            	   855:   ldx #23   ; ERROR: Illegal factor
00:9C61 4CC39E          	   856:   jmp ass_error
                        	   857: exp_get_operator_ok:
00:9C64 A47C            	   858:   ldy exp_operator_stack_count
00:9C66 B123            	   859:   lda (PCODE),Y
00:9C68 60              	   860:   rts
                        	   861: 
                        	   862:  .macro makePrecedenceTable ; table of operators, precedence, handler
                        	   863:    dfb   \1
                        	   864:    dfb   \2
                        	   865:    word  \3
                        	   866:  .endmacro
                        	   867: 
                        	   868: ; cannot have more than 64 entries because we index into this with X
                        	   869: exp_precedence_table:
                        	   870:   makePrecedenceTable '~', 1, exp_negate
00:9C69 7E              	     1M    dfb   '~'
00:9C6A 01              	     2M    dfb   1
00:9C6B 04AC            	     3M    word  exp_negate
                        	   871:   makePrecedenceTable '!', 1, exp_not
00:9C6D 21              	     1M    dfb   '!'
00:9C6E 01              	     2M    dfb   1
00:9C6F 17AC            	     3M    word  exp_not
                        	   872:   makePrecedenceTable TOKEN_UNARY_MINUS, 1, exp_unary_minus
00:9C71 4D              	     1M    dfb   TOKEN_UNARY_MINUS
00:9C72 01              	     2M    dfb   1
00:9C73 25AC            	     3M    word  exp_unary_minus
                        	   873:   makePrecedenceTable TOKEN_LOW_BYTE, 1, exp_low_byte
00:9C75 56              	     1M    dfb   TOKEN_LOW_BYTE
00:9C76 01              	     2M    dfb   1
00:9C77 39AC            	     3M    word  exp_low_byte
                        	   874:   makePrecedenceTable TOKEN_HIGH_BYTE, 1, exp_high_byte
00:9C79 57              	     1M    dfb   TOKEN_HIGH_BYTE
00:9C7A 01              	     2M    dfb   1
00:9C7B 3EAC            	     3M    word  exp_high_byte
                        	   875:   makePrecedenceTable TOKEN_SHIFT_LEFT, 2, exp_shift_left
00:9C7D 4C              	     1M    dfb   TOKEN_SHIFT_LEFT
00:9C7E 02              	     2M    dfb   2
00:9C7F D2AB            	     3M    word  exp_shift_left
                        	   876:   makePrecedenceTable TOKEN_SHIFT_RIGHT, 2, exp_shift_right
00:9C81 52              	     1M    dfb   TOKEN_SHIFT_RIGHT
00:9C82 02              	     2M    dfb   2
00:9C83 EBAB            	     3M    word  exp_shift_right
                        	   877:   makePrecedenceTable '&', 3, exp_bitwise_and
00:9C85 26              	     1M    dfb   '&'
00:9C86 03              	     2M    dfb   3
00:9C87 81AB            	     3M    word  exp_bitwise_and
                        	   878:   makePrecedenceTable '^', 4, exp_bitwise_xor
00:9C89 5E              	     1M    dfb   '^'
00:9C8A 04              	     2M    dfb   4
00:9C8B 96AB            	     3M    word  exp_bitwise_xor
                        	   879:   makePrecedenceTable '|', 5, exp_bitwise_or
00:9C8D 7C              	     1M    dfb   '|'
00:9C8E 05              	     2M    dfb   5
00:9C8F 6CAB            	     3M    word  exp_bitwise_or
                        	   880:   makePrecedenceTable '*', 6, exp_multiply
00:9C91 2A              	     1M    dfb   '*'
00:9C92 06              	     2M    dfb   6
00:9C93 ACAC            	     3M    word  exp_multiply
                        	   881:   makePrecedenceTable '/', 6, exp_divide
00:9C95 2F              	     1M    dfb   '/'
00:9C96 06              	     2M    dfb   6
00:9C97 E5AC            	     3M    word  exp_divide
                        	   882:   makePrecedenceTable '%', 6, exp_modulo
00:9C99 25              	     1M    dfb   '%'
00:9C9A 06              	     2M    dfb   6
00:9C9B 45AD            	     3M    word  exp_modulo
                        	   883:   makePrecedenceTable '+', 7, exp_add
00:9C9D 2B              	     1M    dfb   '+'
00:9C9E 07              	     2M    dfb   7
00:9C9F DEAA            	     3M    word  exp_add
                        	   884:   makePrecedenceTable '-', 7, exp_subtract
00:9CA1 2D              	     1M    dfb   '-'
00:9CA2 07              	     2M    dfb   7
00:9CA3 F2AA            	     3M    word  exp_subtract
                        	   885:   makePrecedenceTable '<', 8, exp_less_than
00:9CA5 3C              	     1M    dfb   '<'
00:9CA6 08              	     2M    dfb   8
00:9CA7 40AB            	     3M    word  exp_less_than
                        	   886:   makePrecedenceTable '>', 8, exp_greater_than
00:9CA9 3E              	     1M    dfb   '>'
00:9CAA 08              	     2M    dfb   8
00:9CAB 47AB            	     3M    word  exp_greater_than
                        	   887:   makePrecedenceTable TOKEN_LEQ, 8, exp_leq
00:9CAD 80              	     1M    dfb   TOKEN_LEQ
00:9CAE 08              	     2M    dfb   8
00:9CAF 56AB            	     3M    word  exp_leq
                        	   888:   makePrecedenceTable TOKEN_GEQ, 8, exp_geq
00:9CB1 81              	     1M    dfb   TOKEN_GEQ
00:9CB2 08              	     2M    dfb   8
00:9CB3 65AB            	     3M    word  exp_geq
                        	   889:   makePrecedenceTable TOKEN_EQUALITY, 9, exp_eql
00:9CB5 45              	     1M    dfb   TOKEN_EQUALITY
00:9CB6 09              	     2M    dfb   9
00:9CB7 18AB            	     3M    word  exp_eql
                        	   890:   makePrecedenceTable TOKEN_NEQ, 9, exp_neq     ; <>
00:9CB9 55              	     1M    dfb   TOKEN_NEQ
00:9CBA 09              	     2M    dfb   9
00:9CBB 2CAB            	     3M    word  exp_neq     
                        	   891:   makePrecedenceTable TOKEN_INEQUALITY, 9, exp_neq  ; !=
00:9CBD 5A              	     1M    dfb   TOKEN_INEQUALITY
00:9CBE 09              	     2M    dfb   9
00:9CBF 2CAB            	     3M    word  exp_neq  
                        	   892:   makePrecedenceTable TOKEN_LOGICAL_AND, 10, exp_logical_and
00:9CC1 58              	     1M    dfb   TOKEN_LOGICAL_AND
00:9CC2 0A              	     2M    dfb   10
00:9CC3 C0AB            	     3M    word  exp_logical_and
                        	   893:   makePrecedenceTable TOKEN_LOGICAL_OR, 11, exp_logical_or
00:9CC5 59              	     1M    dfb   TOKEN_LOGICAL_OR
00:9CC6 0B              	     2M    dfb   11
00:9CC7 B1AB            	     3M    word  exp_logical_or
                        	   894: 
                        	   895: exp_precedence_table_end = *
                        	   896: 
                        	   897: ;
                        	   898: ;  finds precedence of operator in A, returns it in Y (returns 0 if not found)
                        	   899: ;    changes X, A
                        	   900: ;  also stores the operator evaluation function (eg. exp_add) in exp_evaluation_function
                        	   901: ;
                        	   902: exp_get_precedence:
00:9CC9 A200            	   903:   ldx #0
                        	   904: exp_get_precedence_loop:
00:9CCB DD699C          	   905:   cmp exp_precedence_table,x
00:9CCE F00F            	   906:   beq exp_get_precedence_found
00:9CD0 E8              	   907:   inx   ; skip operator
00:9CD1 E8              	   908:   inx   ; skip precedence
00:9CD2 E8              	   909:   inx   ; skip evaluation function
00:9CD3 E8              	   910:   inx   ;  (2 bytes)
00:9CD4 E060            	   911:   cpx #exp_precedence_table_end - exp_precedence_table
00:9CD6 90F3            	   912:   bcc exp_get_precedence_loop
00:9CD8 A000            	   913:   ldy #0
00:9CDA 647F            	   914:   stz exp_evaluation_function
00:9CDC 6480            	   915:   stz exp_evaluation_function+1
00:9CDE 60              	   916:   rts
                        	   917: exp_get_precedence_found:
00:9CDF E8              	   918:   inx
00:9CE0 BC699C          	   919:   ldy exp_precedence_table,x
00:9CE3 E8              	   920:   inx
00:9CE4 BD699C          	   921:   lda exp_precedence_table,x
00:9CE7 857F            	   922:   sta exp_evaluation_function
00:9CE9 E8              	   923:   inx
00:9CEA BD699C          	   924:   lda exp_precedence_table,x
00:9CED 8580            	   925:   sta exp_evaluation_function+1
00:9CEF 60              	   926:   rts
                        	   927: 
                        	   928: ;
                        	   929: ;  Convert an expression into a value
                        	   930: ;
                        	   931: ;   Ideas from https://www.geeksforgeeks.org/expression-evaluation/
                        	   932: ;
                        	   933: ass_get_value:
                        	   934: ;
                        	   935: ;  set up expression evaluation stack
                        	   936: ;
00:9CF0 647B            	   937:   stz exp_value_stack_count
00:9CF2 647C            	   938:   stz exp_operator_stack_count
00:9CF4 A531            	   939:   lda ENDSYM
00:9CF6 8579            	   940:   sta exp_value_stack
00:9CF8 A532            	   941:   lda ENDSYM+1
00:9CFA 857A            	   942:   sta exp_value_stack+1
                        	   943: 
00:9CFC 6473            	   944:   stz ASS_VALUE
00:9CFE 6474            	   945:   stz ASS_VALUE+1
00:9D00 6475            	   946:   stz ASS_VALUE+2
00:9D02 A901            	   947:   lda #1
00:9D04 8581            	   948:   sta exp_unary_ok  ; unary operators can appear at the start of the expression
00:9D06 A593            	   949:   lda token_type
                        	   950: ;  jsr START_TRACE
                        	   951: ;
                        	   952: ;  one token lookahead
                        	   953: ;
00:9D08 8003            	   954:   bra ass_expression_loop_initial
                        	   955: 
                        	   956: ;
                        	   957: ;  1.1 Get the next token
                        	   958: ;
                        	   959: ass_expression_loop:
00:9D0A 2098C9          	   960:   jsr get_token
                        	   961: ass_expression_loop_initial:
                        	   962: 
                        	   963: ;
                        	   964: ;  1.2.1 If it's a number, push onto the value stack
                        	   965: ;
00:9D0D C94E            	   966:   cmp #TOKEN_NUMBER
00:9D0F D013            	   967:   bne ass_expression_loop1a
                        	   968: ass_expression_number:
00:9D11 A594            	   969:   lda token_value
00:9D13 8500            	   970:   sta VALUE
00:9D15 A595            	   971:   lda token_value+1
00:9D17 8501            	   972:   sta VALUE+1
00:9D19 A596            	   973:   lda token_value+2
00:9D1B 8502            	   974:   sta VALUE+2
00:9D1D 20E59B          	   975:   jsr exp_push_value
00:9D20 6481            	   976:   stz exp_unary_ok          ; don't have unary operators after numbers
00:9D22 80E6            	   977:   bra ass_expression_loop
                        	   978: ;
                        	   979: ;  if it's a string and only 1 or 2 bytes, consider as a number
                        	   980: ;
                        	   981: ass_expression_loop1a:
00:9D24 C922            	   982:   cmp #TOKEN_STRING
00:9D26 D013            	   983:   bne ass_expression_loop1
00:9D28 A592            	   984:   lda token_length
00:9D2A C903            	   985:   cmp #3
00:9D2C B008            	   986:   bcs ass_expression_not_small_string  ; too long?
                        	   987: ;
                        	   988: ;  one or two character string - is this an immediate operand?
                        	   989: ;
00:9D2E A56B            	   990:   lda ASS_OPERAND
00:9D30 C907            	   991:   cmp #ASS_OPERAND_IMMEDIATE
00:9D32 D002            	   992:   bne ass_expression_not_small_string
00:9D34 80DB            	   993:   bra ass_expression_number   ; treat as a number (its value should be in VALUE)
                        	   994: 
                        	   995: ass_expression_not_small_string:
00:9D36 A21D            	   996:   ldx #29     ; string literal too big
00:9D38 4CC39E          	   997:   jmp ass_error
                        	   998: 
                        	   999: ;
                        	  1000: ;  1.2.2 If it's an identifier, get its value and push onto the value stack
                        	  1001: ;
                        	  1002: ass_expression_loop1:
00:9D3B C949            	  1003:   cmp #TOKEN_IDENTIFIER
00:9D3D D029            	  1004:   bne ass_expression_loop2
00:9D3F 6481            	  1005:   stz exp_unary_ok          ; don't have unary operators after identifiers
                        	  1006: 
00:9D41 201CB9          	  1007:   jsr SEARCH    ; should be in symbol table as a constant, and the value in VALUE
00:9D44 D011            	  1008:   bne ass_expression_found_value
00:9D46 A576            	  1009:   lda ASS_PASS
00:9D48 F005            	  1010:   beq ass_label_not_found_yet
                        	  1011: 
                        	  1012: ;
                        	  1013: ; it's an error if it isn't there on the second pass
                        	  1014: ;
00:9D4A A20B            	  1015:   ldx #11  ; ERROR: Undeclared Identifier
00:9D4C 4CC39E          	  1016:   jmp ass_error
                        	  1017: 
                        	  1018: ;
                        	  1019: ;  label not found on first pass, make the value 0x6666 for now
                        	  1020: ;   - we don't want a zero-page address assumption because that
                        	  1021: ;     will throw out opcode lengths (it might assume a zero page opcode
                        	  1022: ;     which is shorter and then change it to a longer one)
                        	  1023: ;
                        	  1024: ass_label_not_found_yet:
00:9D4F A966            	  1025:   lda #$66
00:9D51 8500            	  1026:   sta VALUE
00:9D53 8501            	  1027:   sta VALUE+1
00:9D55 6402            	  1028:   stz VALUE+2
                        	  1029: ass_expression_found_value:
00:9D57 A594            	  1030:   lda token_value
00:9D59 8500            	  1031:   sta VALUE
00:9D5B A595            	  1032:   lda token_value+1
00:9D5D 8501            	  1033:   sta VALUE+1
00:9D5F A596            	  1034:   lda token_value+2
00:9D61 8502            	  1035:   sta VALUE+2
00:9D63 20E59B          	  1036:   jsr exp_push_value
00:9D66 80A2            	  1037:   bra ass_expression_loop
                        	  1038: 
                        	  1039: ;
                        	  1040: ; 1.2.3 If it's a left parenthesis: push it onto the operator stack.
                        	  1041: ;
                        	  1042: ass_expression_loop2:
00:9D68 C928            	  1043:   cmp #'('
00:9D6A D00B            	  1044:   bne ass_expression_loop3
00:9D6C 48              	  1045:   pha
00:9D6D A901            	  1046:   lda  #1
00:9D6F 8581            	  1047:   sta exp_unary_ok          ; unary operators can follow left parentheses
00:9D71 68              	  1048:   pla
                        	  1049: 
00:9D72 20399C          	  1050:   jsr exp_push_operator
00:9D75 8093            	  1051:   bra ass_expression_loop
                        	  1052: 
                        	  1053: ;
                        	  1054: ;  1.2.4 A right parenthesis:
                        	  1055: ;       1 While the thing on top of the operator stack is not a
                        	  1056: ;         left parenthesis,
                        	  1057: ;           1 Pop the operator from the operator stack.
                        	  1058: ;           2 Pop the value stack twice, getting two operands.
                        	  1059: ;           3 Apply the operator to the operands, in the correct order.
                        	  1060: ;           4 Push the result onto the value stack.
                        	  1061: ;        2 Pop the left parenthesis from the operator stack, and discard it.
                        	  1062: 
                        	  1063: 
                        	  1064: ass_expression_loop3:
00:9D77 C929            	  1065:   cmp #')'
00:9D79 D016            	  1066:   bne ass_expression_loop4
                        	  1067: ass_expression_loop3b:
                        	  1068: ;
                        	  1069: ;  a RH parenthesis with an empty operator stack is probably the end of the expression, eg. ($1234),x
                        	  1070: ;  where the ")" belongs to the indexed operand stuff and not the expression
                        	  1071: ;
00:9D7B A57C            	  1072:   lda exp_operator_stack_count
00:9D7D F078            	  1073:   beq exp_no_operators_left
00:9D7F 205B9C          	  1074:   jsr exp_get_operator
00:9D82 C928            	  1075:   cmp #'('
00:9D84 F005            	  1076:   beq ass_expression_loop3c
                        	  1077: ;
                        	  1078: ;  not a left parenthesis
                        	  1079: ;
                        	  1080: ass_expression_loop3a:
00:9D86 201D9E          	  1081:   jsr ass_expression_apply_operator ; pop the operator and two values, apply the operator and push the result
00:9D89 80F0            	  1082:   bra ass_expression_loop3b          ; keep going until we don't have a left parenthesis
                        	  1083: 
                        	  1084: ass_expression_loop3c:
00:9D8B 204B9C          	  1085:   jsr exp_pop_operator              ;  2 Pop the left parenthesis from the operator stack, and discard it.
                        	  1086: ass_expression_loopJ:
00:9D8E 4C0A9D          	  1087:   jmp ass_expression_loop
                        	  1088: 
                        	  1089: ;       1.2.5 An operator (call it thisOp):
                        	  1090: ;         1 While the operator stack is not empty, and the top thing on the
                        	  1091: ;           operator stack has the same or greater precedence as thisOp,
                        	  1092: ;           1 Pop the operator from the operator stack.
                        	  1093: ;           2 Pop the value stack twice, getting two operands.
                        	  1094: ;           3 Apply the operator to the operands, in the correct order.
                        	  1095: ;           4 Push the result onto the value stack.
                        	  1096: ;         2 Push thisOp onto the operator stack.
                        	  1097: 
                        	  1098: ass_expression_loop4:
                        	  1099: ;
                        	  1100: ;  look for unary operators
                        	  1101: ;
00:9D91 A681            	  1102:   ldx exp_unary_ok
00:9D93 F034            	  1103:   beq ass_expression_cannot_be_unary
00:9D95 C92D            	  1104:   cmp #'-'
00:9D97 D006            	  1105:   bne ass_not_unary_minus
00:9D99 A94D            	  1106:   lda #TOKEN_UNARY_MINUS
00:9D9B 8593            	  1107:   sta token_type
00:9D9D 802A            	  1108:   bra ass_expression_cannot_be_unary
                        	  1109: ass_not_unary_minus:
00:9D9F C93C            	  1110:   cmp #'<'
00:9DA1 D006            	  1111:   bne ass_not_unary_less_than
00:9DA3 A956            	  1112:   lda #TOKEN_LOW_BYTE
00:9DA5 8593            	  1113:   sta token_type
00:9DA7 8020            	  1114:   bra ass_expression_cannot_be_unary
                        	  1115: ass_not_unary_less_than:
00:9DA9 C93E            	  1116:   cmp #'>'
00:9DAB D006            	  1117:   bne ass_not_unary_greater_than
00:9DAD A957            	  1118:   lda #TOKEN_HIGH_BYTE
00:9DAF 8593            	  1119:   sta token_type
00:9DB1 8000            	  1120:   bra ass_not_unary_greater_than
                        	  1121: ass_not_unary_greater_than:
00:9DB3 C92A            	  1122:   cmp #'*'
00:9DB5 D012            	  1123:   bne ass_expression_cannot_be_unary
                        	  1124: ;
                        	  1125: ;  A '*' where a unary expression is allowed will be the current emit address (eg. foo = *)
                        	  1126: ;
00:9DB7 A523            	  1127:   lda PCODE
00:9DB9 8594            	  1128:   sta token_value
00:9DBB A524            	  1129:   lda PCODE+1
00:9DBD 8595            	  1130:   sta token_value+1
00:9DBF 6496            	  1131:   stz token_value+2
00:9DC1 6481            	  1132:   stz exp_unary_ok          ; don't have unary operators after numbers
00:9DC3 A94E            	  1133:   lda #TOKEN_NUMBER
00:9DC5 8593            	  1134:   sta token_type            ; make get_token think a sign as a token on its own
00:9DC7 808E            	  1135:   bra ass_expression_found_value
                        	  1136: 
                        	  1137: ass_expression_cannot_be_unary:
00:9DC9 48              	  1138:   pha
00:9DCA A901            	  1139:   lda #1
00:9DCC 8581            	  1140:   sta exp_unary_ok          ; can have unary operators after operators
00:9DCE 68              	  1141:   pla
                        	  1142: 
00:9DCF 20C99C          	  1143:   jsr exp_get_precedence
00:9DD2 847E            	  1144:   sty exp_operator_precedence ; thisOp's precedence
00:9DD4 C000            	  1145:   cpy #0
00:9DD6 F01F            	  1146:   beq exp_no_operators_left
                        	  1147: 
                        	  1148: ass_expression_loop7:         ; 1 While the operator stack is not empty
00:9DD8 A57C            	  1149:   lda exp_operator_stack_count
00:9DDA F013            	  1150:   beq ass_expression_loop6    ; stack empty
00:9DDC 205B9C          	  1151:   jsr exp_get_operator    ; find the top thing on the operator stack
00:9DDF C928            	  1152:   cmp #'('                ; if a bracket, consider that low precedence
00:9DE1 F00C            	  1153:   beq ass_expression_loop6
00:9DE3 20C99C          	  1154:   jsr exp_get_precedence  ; and its precedence
00:9DE6 C47E            	  1155:   cpy exp_operator_precedence
00:9DE8 B005            	  1156:   bcs ass_expression_loop6  ; thing on top has less precedence (a higher value) than thisOp
00:9DEA 201D9E          	  1157:   jsr ass_expression_apply_operator  ; pop the operator and two values, apply the operator and push the result
00:9DED 80E9            	  1158:   bra ass_expression_loop7
                        	  1159: 
                        	  1160: ass_expression_loop6:
00:9DEF A593            	  1161:   lda token_type       ; thisOp
00:9DF1 20399C          	  1162:   jsr exp_push_operator
00:9DF4 4C0A9D          	  1163:   jmp ass_expression_loop
                        	  1164: 
                        	  1165: 
                        	  1166: ; 2. While the operator stack is not empty,
                        	  1167: ;     1 Pop the operator from the operator stack.
                        	  1168: ;     2 Pop the value stack twice, getting two operands.
                        	  1169: ;     3 Apply the operator to the operands, in the correct order.
                        	  1170: ;     4 Push the result onto the value stack.
                        	  1171: 
                        	  1172: 
                        	  1173: exp_no_operators_left:
00:9DF7 A57C            	  1174:     lda exp_operator_stack_count
00:9DF9 F005            	  1175:     beq exp_done
00:9DFB 201D9E          	  1176:     jsr ass_expression_apply_operator ; pop the operator and two values, apply the operator and push the result
00:9DFE 80F7            	  1177:     bra exp_no_operators_left
                        	  1178: 
                        	  1179: exp_done:
00:9E00 A57B            	  1180:       lda exp_value_stack_count
00:9E02 C901            	  1181:       cmp #1
00:9E04 F005            	  1182:       beq exp_done_ok
                        	  1183: exp_done_error:
00:9E06 A217            	  1184:       ldx #23       ; ERROR: Illegal factor
00:9E08 4CC39E          	  1185:       jmp ass_error
                        	  1186: 
                        	  1187: exp_done_ok:
00:9E0B A57C            	  1188:       lda exp_operator_stack_count
00:9E0D D0F7            	  1189:       bne exp_done_error
00:9E0F 20109C          	  1190:       jsr exp_pop_value   ; pop the finished value
00:9E12 A500            	  1191:       lda VALUE
00:9E14 8573            	  1192:       sta ASS_VALUE
00:9E16 A501            	  1193:       lda VALUE+1
00:9E18 8574            	  1194:       sta ASS_VALUE+1
00:9E1A 6475            	  1195:       stz ASS_VALUE+2   ; make high-order byte zero just in case
00:9E1C 60              	  1196:       rts
                        	  1197: 
                        	  1198: ;
                        	  1199: ;
                        	  1200: ;     1 Pop the operator from the operator stack.
                        	  1201: ;     2 Pop the value stack twice, getting two operands.
                        	  1202: ;     3 Apply the operator to the operands, in the correct order.
                        	  1203: ;     4 Push the result onto the value stack.
                        	  1204: 
                        	  1205: ;
                        	  1206: ass_expression_apply_operator:
00:9E1D 20109C          	  1207:   jsr exp_pop_value         ; 2 Pop the value stack twice, getting two operands.
00:9E20 205B9C          	  1208:   jsr exp_get_operator
00:9E23 C97E            	  1209:   cmp #'~'
00:9E25 F01F            	  1210:   beq ass_expression_unary
00:9E27 C921            	  1211:   cmp #'!'
00:9E29 F01B            	  1212:   beq ass_expression_unary
00:9E2B C94D            	  1213:   cmp #TOKEN_UNARY_MINUS
00:9E2D F017            	  1214:   beq ass_expression_unary
00:9E2F C956            	  1215:   cmp #TOKEN_LOW_BYTE
00:9E31 F013            	  1216:   beq ass_expression_unary
00:9E33 C957            	  1217:   cmp #TOKEN_HIGH_BYTE
00:9E35 F00F            	  1218:   beq ass_expression_unary
                        	  1219: 
                        	  1220: ;
                        	  1221: ;  if a binary operator get the second value
                        	  1222: ;
00:9E37 A500            	  1223:   lda VALUE                 ; copy top value to VALUE2
00:9E39 8503            	  1224:   sta VALUE2
00:9E3B A501            	  1225:   lda VALUE+1
00:9E3D 8504            	  1226:   sta VALUE2+1
00:9E3F A502            	  1227:   lda VALUE+2
00:9E41 8505            	  1228:   sta VALUE2+2
00:9E43 20109C          	  1229:   jsr exp_pop_value         ; second pop
                        	  1230: ass_expression_unary:
                        	  1231: 
                        	  1232: ;
                        	  1233: ;  now we have the top two values in VALUE (and VALUE2 in the case of binary operators)
                        	  1234: ;
00:9E46 204B9C          	  1235:   jsr exp_pop_operator      ; 1 Pop the operator from the operator stack.
00:9E49 857D            	  1236:   sta exp_operator
00:9E4B 20C99C          	  1237:   jsr exp_get_precedence    ; find the evaluation function
00:9E4E C000            	  1238:   cpy #0
00:9E50 F0CB            	  1239:   beq ass_expression_apply_operator ; should not be here if the operator isn't in the table
00:9E52 205E9E          	  1240:   jsr ass_evaluate_operator ; do the evaluation
00:9E55 20E59B          	  1241:   jsr exp_push_value        ; 4 Push the result onto the value stack.
00:9E58 60              	  1242:   rts
                        	  1243: 
                        	  1244: ass_expression_apply_operator_bug:
00:9E59 A206            	  1245:   ldx #6
00:9E5B 4CC39E          	  1246:   jmp ass_error
                        	  1247: 
                        	  1248: ass_evaluate_operator:
00:9E5E 6C7F00          	  1249:   jmp (exp_evaluation_function)
                        	  1250: 
                        	  1251: 
                        	  1252: ;
                        	  1253: ;  look up opcodes in a table
                        	  1254: ;  returns carry set if found, carry clear if not found
                        	  1255: ;
                        	  1256: ass_lookup_loop:
00:9E61 A46E            	  1257:   ldy OPCODE_LEN
00:9E63 204C92          	  1258:   jsr COMSTL
00:9E66 F017            	  1259:   beq ass_opcode_found
                        	  1260: ;
                        	  1261: ;  add the opcode length, plus 1 to DEST
                        	  1262: ;
00:9E68 18              	  1263:   clc
00:9E69 A46E            	  1264:   ldy OPCODE_LEN
00:9E6B C8              	  1265:   iny
00:9E6C 98              	  1266:   tya
00:9E6D 6503            	  1267:   adc DEST
00:9E6F 8503            	  1268:   sta DEST
00:9E71 A504            	  1269:   lda DEST+1
00:9E73 6900            	  1270:   adc #0
00:9E75 8504            	  1271:   sta DEST+1
                        	  1272: ;
                        	  1273: ;  end of table?
                        	  1274: ;
00:9E77 A000            	  1275:   ldy #0
00:9E79 B103            	  1276:   lda (DEST),Y
00:9E7B D0E4            	  1277:   bne ass_lookup_loop   ; not yet
00:9E7D 18              	  1278:   clc
00:9E7E 60              	  1279:   rts
                        	  1280: 
                        	  1281: 
                        	  1282: ass_opcode_found:
00:9E7F A46E            	  1283:   ldy OPCODE_LEN
00:9E81 B103            	  1284:   lda (DEST),Y
00:9E83 38              	  1285:   sec   ; indicate found
00:9E84 60              	  1286:   rts
                        	  1287: 
                        	  1288: ass_emit:
00:9E85 A476            	  1289:   ldy ASS_PASS
00:9E87 F031            	  1290:   beq ass_emit3  ; only emit codes on 2nd pass
                        	  1291:   ;
                        	  1292:   ;  first time for this line of code, indent by two spaces
                        	  1293:   ;
00:9E89 A46F            	  1294:   ldy ASS_EMIT_COUNT
00:9E8B D00C            	  1295:   bne ass_emit2
00:9E8D A42E            	  1296:   ldy DCODE
00:9E8F F008            	  1297:   beq ass_emit2
00:9E91 48              	  1298:   pha
00:9E92 20D292          	  1299:   jsr PUTSP
00:9E95 20D292          	  1300:   jsr PUTSP
00:9E98 68              	  1301:   pla
                        	  1302: ass_emit2:
                        	  1303: ;
                        	  1304: ;  if this is the *first* byte we emitted, then make that the start address
                        	  1305: ;  for running the code. That is, if you relocate the code, the first byte
                        	  1306: ;  actually emitted will be considered the runtime address.
                        	  1307: ;
                        	  1308: ;  this lets you relocate code (eg. to $4500) and have it run from there if
                        	  1309: ;  you happen to hit Run.
                        	  1310: ;
00:9E99 48              	  1311:   pha
00:9E9A A577            	  1312:   lda ass_emit_bytes
00:9E9C 0578            	  1313:   ora ass_emit_bytes+1
00:9E9E D008            	  1314:   bne ass_already_emitted
00:9EA0 A523            	  1315:   lda PCODE
00:9EA2 8525            	  1316:   sta ACT_PCDA
00:9EA4 A524            	  1317:   lda PCODE+1
00:9EA6 8526            	  1318:   sta ACT_PCDA+1
                        	  1319: ass_already_emitted:
00:9EA8 68              	  1320:   pla
                        	  1321: ;
                        	  1322: ;  write the byte to memory
                        	  1323: ;
00:9EA9 A000            	  1324:   ldy #0
00:9EAB 9123            	  1325:   sta (PCODE),Y
00:9EAD E677            	  1326:   inc ass_emit_bytes
00:9EAF D002            	  1327:   bne ass_emit4
00:9EB1 E678            	  1328:   inc ass_emit_bytes+1
                        	  1329: ass_emit4:
                        	  1330: 
                        	  1331: ;
                        	  1332: ;  if displaying codes, show the emitted byte
                        	  1333: ;
00:9EB3 A42E            	  1334:   ldy DCODE
00:9EB5 F003            	  1335:   beq ass_emit3
00:9EB7 205C92          	  1336:   jsr DISHX
                        	  1337: ;
                        	  1338: ;  increment the PCODE (output) address
                        	  1339: ;
                        	  1340: ass_emit3:
00:9EBA E623            	  1341:   inc PCODE
00:9EBC D002            	  1342:   bne ass_emit1
00:9EBE E624            	  1343:   inc PCODE+1
                        	  1344: ass_emit1:
00:9EC0 E66F            	  1345:   inc ASS_EMIT_COUNT
00:9EC2 60              	  1346:   rts
                        	  1347: 
                        	  1348: ass_error:
00:9EC3 A56F            	  1349:   lda ASS_EMIT_COUNT
00:9EC5 F003            	  1350:   beq ass_error1
00:9EC7 204792          	  1351:   jsr CROUT
                        	  1352: ass_error1:
00:9ECA 4C8397          	  1353:   jmp ERROR
                        	  1354: 
                        	  1355: ass_fixup_bbr_branch:
00:9ECD A507            	  1356:   lda REMAIN+1
00:9ECF D043            	  1357:   bne ass_emit_zero_page_too_high
00:9ED1 A508            	  1358:   lda REMAIN+2
00:9ED3 D03F            	  1359:   bne ass_emit_zero_page_too_high
00:9ED5 A506            	  1360:   lda REMAIN
00:9ED7 20859E          	  1361:   jsr ass_emit  ; output zero page address
                        	  1362: 
                        	  1363: ;
                        	  1364: ;  now fall down and emit the branch
                        	  1365: ;
                        	  1366: 
                        	  1367: ass_fixup_branch:
00:9EDA 18              	  1368:   clc         ; I want to subtract one more, so I CLEAR carry <sigh>
00:9EDB A573            	  1369:   lda ASS_VALUE
00:9EDD E523            	  1370:   sbc PCODE
00:9EDF 8573            	  1371:   sta ASS_VALUE
                        	  1372: 
00:9EE1 A574            	  1373:   lda ASS_VALUE+1
00:9EE3 E524            	  1374:   sbc PCODE+1
00:9EE5 C9FF            	  1375:   cmp #$FF  ; backwards branch
00:9EE7 F00A            	  1376:   beq ass_branch_backwards
00:9EE9 C900            	  1377:   cmp #0
00:9EEB D010            	  1378:   bne ass_branch_out_of_range
00:9EED A573            	  1379:   lda ASS_VALUE ; must be 0x00 to 0x7F
00:9EEF 300C            	  1380:   bmi ass_branch_out_of_range
00:9EF1 8004            	  1381:   bra ass_branch_ok
                        	  1382: 
                        	  1383: ass_branch_backwards:
00:9EF3 A573            	  1384:   lda ASS_VALUE   ; must be 0x80 to 0xFF
00:9EF5 1006            	  1385:   bpl ass_branch_out_of_range
                        	  1386: 
                        	  1387: ass_branch_ok:
00:9EF7 A573            	  1388:   lda ASS_VALUE
00:9EF9 20859E          	  1389:   jsr ass_emit  ; output relative address
00:9EFC 60              	  1390:   rts
                        	  1391: 
                        	  1392: ass_branch_out_of_range:
00:9EFD A576            	  1393:   lda ASS_PASS
00:9EFF F0F6            	  1394:   beq ass_branch_ok   ; out of range is OK on first pass, we don't know how far the branch is
00:9F01 A22A            	  1395:   ldx #42
00:9F03 4CC39E          	  1396:   jmp ass_error  ; branch out of range
                        	  1397: 
                        	  1398: ass_emit_zero_page:
00:9F06 A574            	  1399:   lda ASS_VALUE+1
00:9F08 D00A            	  1400:   bne ass_emit_zero_page_too_high
00:9F0A A575            	  1401:   lda ASS_VALUE+2
00:9F0C D006            	  1402:   bne ass_emit_zero_page_too_high
00:9F0E A573            	  1403:   lda ASS_VALUE
00:9F10 20859E          	  1404:   jsr ass_emit  ; output zero page address
00:9F13 60              	  1405:   rts
                        	  1406: 
                        	  1407: 
                        	  1408: ass_emit_zero_page_too_high:
00:9F14 A22B            	  1409:   ldx #43       ; Need zero page address
00:9F16 4CC39E          	  1410:   jmp ass_error
                        	  1411: 
                        	  1412: ass_emit_immediate:
00:9F19 A574            	  1413:   lda ASS_VALUE+1
00:9F1B D00A            	  1414:   bne ass_emit_immediate_too_high
00:9F1D A575            	  1415:   lda ASS_VALUE+2
00:9F1F D006            	  1416:   bne ass_emit_immediate_too_high
00:9F21 A573            	  1417:   lda ASS_VALUE
00:9F23 20859E          	  1418:   jsr ass_emit  ; output immediate operand
00:9F26 60              	  1419:   rts
                        	  1420: 
                        	  1421: ass_emit_immediate_too_high:
00:9F27 A22C            	  1422:   ldx #44
00:9F29 4CC39E          	  1423:   jmp ass_error
                        	  1424: 
                        	  1425: 
                        	  1426: ass_emit_absolute:
00:9F2C A573            	  1427:   lda ASS_VALUE
00:9F2E 20859E          	  1428:   jsr ass_emit  ; output absolute address - low-order byte
00:9F31 A574            	  1429:   lda ASS_VALUE+1
00:9F33 20859E          	  1430:   jsr ass_emit  ; output absolute address - high-order byte
00:9F36 60              	  1431:   rts
                        	  1432: 
                        	  1433: 
                        	  1434: ;------------------------------------
                        	  1435: ;  Opcode master table
                        	  1436: ;------------------------------------
                        	  1437: 
                        	  1438:    .macro makeOpcodeLookup ; table of opcodes, length of opcode, wanted operand type, special handler
                        	  1439:      dfb   \1
                        	  1440:      dfb   \2
                        	  1441:      word  \3
                        	  1442:      word   \4
                        	  1443:    .endmacro
                        	  1444: 
                        	  1445: ;
                        	  1446: ;  So, for an opcode to match, it has to:
                        	  1447: ;     a) be the right length (usually 3 or 4 characters)
                        	  1448: ;     b) have the right type of operand (eg. ASS_OPERAND_IMMEDIATE)
                        	  1449: ;     c) the opcode must match the name in the list
                        	  1450: ;
                        	  1451: ;   If those conditions are met we output the corresponding opcode,
                        	  1452: ;   return with the operand type in A
                        	  1453: ;
                        	  1454: ;   Otherwise, we return 0 in A
                        	  1455: ;
                        	  1456: 
                        	  1457: OPCODE_LOOKUP_OPCODE_LENGTH = 0
                        	  1458: OPCODE_LOOKUP_OPERAND_TYPE = 1
                        	  1459: OPCODE_LOOKUP_OPCODE_TABLE = 2    ; 2 bytes
                        	  1460: OPCODE_LOOKUP_HANDLER = 4         ; 2 bytes
                        	  1461: OPCODE_LOOKUP_TABLE_SIZE = 6      ; all of the above
                        	  1462: 
                        	  1463: OPCODE_LOOKUP_TABLE = *
                        	  1464: ;
                        	  1465: ;  zero-page opcodes go first as they are preferred if we are accessing a zero-page address
                        	  1466: ;
                        	  1467:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE, OPCODE_ASS_OPERAND_ZERO_PAGE, ass_emit_zero_page ; (11)
00:9F37 03              	     1M      dfb   3
00:9F38 0B              	     2M      dfb   ASS_OPERAND_ZERO_PAGE
00:9F39 C4A2            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE
00:9F3B 069F            	     4M      word   ass_emit_zero_page 
                        	  1468:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE, OPCODE_ASS_OPERAND_ZERO_PAGE_TOKENISED, ass_emit_zero_page ; (11)
00:9F3D 01              	     1M      dfb   1
00:9F3E 0B              	     2M      dfb   ASS_OPERAND_ZERO_PAGE
00:9F3F 25A3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_TOKENISED
00:9F41 069F            	     4M      word   ass_emit_zero_page 
                        	  1469:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT, ass_em
00:9F43 03              	     1M      dfb   3
00:9F44 0C              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
00:9F45 28A3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
00:9F47 069F            	     4M      word   ass_emit_zero_page 
                        	  1470:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT_TOKENIS
00:9F49 01              	     1M      dfb   1
00:9F4A 0C              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
00:9F4B 49A3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT_TOKENISED
00:9F4D 069F            	     4M      word   ass_emit_zero_page 
                        	  1471:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X, ass_emit_z
00:9F4F 03              	     1M      dfb   3
00:9F50 0D              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
00:9F51 4CA3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
00:9F53 069F            	     4M      word   ass_emit_zero_page 
                        	  1472:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X_TOKENISED, 
00:9F55 01              	     1M      dfb   1
00:9F56 0D              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
00:9F57 95A3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X_TOKENISED
00:9F59 069F            	     4M      word   ass_emit_zero_page 
                        	  1473:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y, ass_emit_z
00:9F5B 03              	     1M      dfb   3
00:9F5C 0E              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
00:9F5D 98A3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
00:9F5F 069F            	     4M      word   ass_emit_zero_page 
                        	  1474:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDIRECT, OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT, ass_emit_zero_page ; (
00:9F61 03              	     1M      dfb   3
00:9F62 0F              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDIRECT
00:9F63 A1A3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT
00:9F65 069F            	     4M      word   ass_emit_zero_page 
                        	  1475:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE_INDIRECT, OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_TOKENISED, ass_emit_zer
00:9F67 01              	     1M      dfb   1
00:9F68 0F              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDIRECT
00:9F69 C2A3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_TOKENISED
00:9F6B 069F            	     4M      word   ass_emit_zero_page 
                        	  1476:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_
00:9F6D 03              	     1M      dfb   3
00:9F6E 10              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
00:9F6F C5A3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
00:9F71 069F            	     4M      word   ass_emit_zero_page 
                        	  1477:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_
00:9F73 01              	     1M      dfb   1
00:9F74 10              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
00:9F75 E6A3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y_TOKENISED
00:9F77 069F            	     4M      word   ass_emit_zero_page 
                        	  1478: 
                        	  1479: ;
                        	  1480: ;  non zero-page opcodes
                        	  1481: ;
                        	  1482:     makeOpcodeLookup  4,  ASS_OPERAND_ABSOLUTE, OPCODE_4_CHAR_ZERO_PAGE,  ass_emit_zero_page  ; (11)
00:9F79 04              	     1M      dfb   4
00:9F7A 01              	     2M      dfb   ASS_OPERAND_ABSOLUTE
00:9F7B 40A1            	     3M      word  OPCODE_4_CHAR_ZERO_PAGE
00:9F7D 069F            	     4M      word   ass_emit_zero_page  
                        	  1483:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE, OPCODE_ASS_OPERAND_ABSOLUTE,  ass_emit_absolute  ; (1)
00:9F7F 03              	     1M      dfb   3
00:9F80 01              	     2M      dfb   ASS_OPERAND_ABSOLUTE
00:9F81 91A1            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE
00:9F83 2C9F            	     4M      word   ass_emit_absolute  
                        	  1484:     makeOpcodeLookup  1,  ASS_OPERAND_ABSOLUTE, OPCODE_ASS_OPERAND_ABSOLUTE_TOKENISED,  ass_emit_absolute  ; (1)
00:9F85 01              	     1M      dfb   1
00:9F86 01              	     2M      dfb   ASS_OPERAND_ABSOLUTE
00:9F87 FAA1            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_TOKENISED
00:9F89 2C9F            	     4M      word   ass_emit_absolute  
                        	  1485: 
                        	  1486:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT, ass_emit
00:9F8B 03              	     1M      dfb   3
00:9F8C 02              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
00:9F8D FDA1            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
00:9F8F 2C9F            	     4M      word   ass_emit_absolute 
                        	  1487:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X, ass_emit_abs
00:9F91 03              	     1M      dfb   3
00:9F92 03              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
00:9F93 02A2            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
00:9F95 2C9F            	     4M      word   ass_emit_absolute 
                        	  1488:     makeOpcodeLookup  1,  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X_TOKENISED, as
00:9F97 01              	     1M      dfb   1
00:9F98 03              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
00:9F99 47A2            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X_TOKENISED
00:9F9B 2C9F            	     4M      word   ass_emit_absolute 
                        	  1489:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y, ass_emit_abs
00:9F9D 03              	     1M      dfb   3
00:9F9E 04              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
00:9F9F 4AA2            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
00:9FA1 2C9F            	     4M      word   ass_emit_absolute 
                        	  1490:     makeOpcodeLookup  1,  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y_TOKENISED, as
00:9FA3 01              	     1M      dfb   1
00:9FA4 04              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
00:9FA5 6FA2            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y_TOKENISED
00:9FA7 2C9F            	     4M      word   ass_emit_absolute 
                        	  1491:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDIRECT, OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT, ass_emit_absolute ; (5)
00:9FA9 03              	     1M      dfb   3
00:9FAA 05              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDIRECT
00:9FAB 8BA2            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT
00:9FAD 2C9F            	     4M      word   ass_emit_absolute 
                        	  1492:     makeOpcodeLookup  1,  ASS_OPERAND_ABSOLUTE_INDIRECT, OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED, ass_emit_absolute ; (5
00:9FAF 01              	     1M      dfb   1
00:9FB0 05              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDIRECT
00:9FB1 C1A2            	     3M      word  OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED
00:9FB3 2C9F            	     4M      word   ass_emit_absolute 
                        	  1493:     makeOpcodeLookup  3,  ASS_OPERAND_ACCUMULATOR_A, OPCODE_ASS_OPERAND_ACCUMULATOR_A, 0 ; (6)
00:9FB5 03              	     1M      dfb   3
00:9FB6 06              	     2M      dfb   ASS_OPERAND_ACCUMULATOR_A
00:9FB7 72A2            	     3M      word  OPCODE_ASS_OPERAND_ACCUMULATOR_A
00:9FB9 0000            	     4M      word   0 
                        	  1494:     makeOpcodeLookup  3,  ASS_OPERAND_IMMEDIATE, OPCODE_ASS_OPERAND_IMMEDIATE, ass_emit_immediate ; (7)
00:9FBB 03              	     1M      dfb   3
00:9FBC 07              	     2M      dfb   ASS_OPERAND_IMMEDIATE
00:9FBD 90A2            	     3M      word  OPCODE_ASS_OPERAND_IMMEDIATE
00:9FBF 199F            	     4M      word   ass_emit_immediate 
                        	  1495:     makeOpcodeLookup  1,  ASS_OPERAND_IMMEDIATE, OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED, ass_emit_immediate ; (7)
00:9FC1 01              	     1M      dfb   1
00:9FC2 07              	     2M      dfb   ASS_OPERAND_IMMEDIATE
00:9FC3 C1A2            	     3M      word  OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED
00:9FC5 199F            	     4M      word   ass_emit_immediate 
                        	  1496:     makeOpcodeLookup  3,  ASS_OPERAND_IMPLIED,  OPCODE_3_CHAR_IMPLIED,    0  ; (8) and (10)
00:9FC7 03              	     1M      dfb   3
00:9FC8 08              	     2M      dfb   ASS_OPERAND_IMPLIED
00:9FC9 C3A0            	     3M      word  OPCODE_3_CHAR_IMPLIED
00:9FCB 0000            	     4M      word   0  
                        	  1497:     makeOpcodeLookup  4,  ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE, OPCODE_4_CHAR_BRANCH,     ass_fixup_bbr_branch  ; (9)
00:9FCD 04              	     1M      dfb   4
00:9FCE 12              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE
00:9FCF 4DA0            	     3M      word  OPCODE_4_CHAR_BRANCH
00:9FD1 CD9E            	     4M      word   ass_fixup_bbr_branch  
                        	  1498:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE, OPCODE_3_CHAR_BRANCH,     ass_fixup_branch  ; (9)
00:9FD3 03              	     1M      dfb   3
00:9FD4 01              	     2M      dfb   ASS_OPERAND_ABSOLUTE
00:9FD5 9EA0            	     3M      word  OPCODE_3_CHAR_BRANCH
00:9FD7 DA9E            	     4M      word   ass_fixup_branch  
00:9FD9 00              	  1499:     dfb 0
                        	  1500: 
                        	  1501: 
                        	  1502: ;------------------------------------
                        	  1503: ;  directives
                        	  1504: ;------------------------------------
                        	  1505: 
                        	  1506: 
                        	  1507: DIRECTIVES = *
                        	  1508:   makeHandler "ASSERT",   asm_do_assert
00:9FDA 415353455254    	     1M    asciiz   "ASSERT"
00:9FE0 00
00:9FE1 E9A3            	     2M    word  asm_do_assert
                        	  1509:   makeHandler "LIST",     asm_do_list
00:9FE3 4C495354        	     1M    asciiz   "LIST"
00:9FE7 00
00:9FE8 00A4            	     2M    word  asm_do_list
                        	  1510:   makeHandler "NOLIST",   asm_do_nolist
00:9FEA 4E4F4C495354    	     1M    asciiz   "NOLIST"
00:9FF0 00
00:9FF1 0FA4            	     2M    word  asm_do_nolist
                        	  1511:   makeHandler "ASC",      asm_do_asc
00:9FF3 415343          	     1M    asciiz   "ASC"
00:9FF6 00
00:9FF7 4EA4            	     2M    word  asm_do_asc
                        	  1512:   makeHandler "ASCII",    asm_do_asc
00:9FF9 4153434949      	     1M    asciiz   "ASCII"
00:9FFE 00
00:9FFF 4EA4            	     2M    word  asm_do_asc
                        	  1513:   makeHandler "ASCIIZ",   asm_do_string
00:A001 41534349495A    	     1M    asciiz   "ASCIIZ"
00:A007 00
00:A008 69A4            	     2M    word  asm_do_string
                        	  1514:   makeHandler "STRING",   asm_do_string
00:A00A 535452494E47    	     1M    asciiz   "STRING"
00:A010 00
00:A011 69A4            	     2M    word  asm_do_string
                        	  1515:   makeHandler "EQU",      asm_do_equ
00:A013 455155          	     1M    asciiz   "EQU"
00:A016 00
00:A017 72A4            	     2M    word  asm_do_equ
                        	  1516:   makeHandler "=",        asm_do_equ
00:A019 3D              	     1M    asciiz   "="
00:A01A 00
00:A01B 72A4            	     2M    word  asm_do_equ
                        	  1517:   makeHandler "ORG",      asm_do_org
00:A01D 4F5247          	     1M    asciiz   "ORG"
00:A020 00
00:A021 8FA4            	     2M    word  asm_do_org
                        	  1518:   makeHandler "DFB",      asm_do_dfb
00:A023 444642          	     1M    asciiz   "DFB"
00:A026 00
00:A027 A3A4            	     2M    word  asm_do_dfb
                        	  1519:   makeHandler "DFW",      asm_do_dfw
00:A029 444657          	     1M    asciiz   "DFW"
00:A02C 00
00:A02D E3A4            	     2M    word  asm_do_dfw
                        	  1520:   makeHandler "WORD",     asm_do_dfw
00:A02F 574F5244        	     1M    asciiz   "WORD"
00:A033 00
00:A034 E3A4            	     2M    word  asm_do_dfw
                        	  1521:   makeHandler "BLK",      asm_do_blk
00:A036 424C4B          	     1M    asciiz   "BLK"
00:A039 00
00:A03A 20A5            	     2M    word  asm_do_blk
                        	  1522:   makeHandler "RESERVE",  asm_do_reserve
00:A03C 52455345525645  	     1M    asciiz   "RESERVE"
00:A043 00
00:A044 3EA5            	     2M    word  asm_do_reserve
                        	  1523:   makeHandler "SYM",      asm_do_sym
00:A046 53594D          	     1M    asciiz   "SYM"
00:A049 00
00:A04A 59A5            	     2M    word  asm_do_sym
                        	  1524: 
00:A04C 00              	  1525:   dfb 0
                        	  1526: 
                        	  1527: ;------------------------------------
                        	  1528: ;  4-character branch opcodes
                        	  1529: ;------------------------------------
                        	  1530: 
                        	  1531: 
                        	  1532: OPCODE_4_CHAR_BRANCH = *
00:A04D 42425230        	  1533:   asc "BBR0",$0F
00:A051 0F
00:A052 42425231        	  1534:   asc "BBR1",$1F
00:A056 1F
00:A057 42425232        	  1535:   asc "BBR2",$2F
00:A05B 2F
00:A05C 42425233        	  1536:   asc "BBR3",$3F
00:A060 3F
00:A061 42425234        	  1537:   asc "BBR4",$4F
00:A065 4F
00:A066 42425235        	  1538:   asc "BBR5",$5F
00:A06A 5F
00:A06B 42425236        	  1539:   asc "BBR6",$6F
00:A06F 6F
00:A070 42425237        	  1540:   asc "BBR7",$7F
00:A074 7F
00:A075 42425330        	  1541:   asc "BBS0",$8F
00:A079 8F
00:A07A 42425331        	  1542:   asc "BBS1",$9F
00:A07E 9F
00:A07F 42425332        	  1543:   asc "BBS2",$AF
00:A083 AF
00:A084 42425333        	  1544:   asc "BBS3",$BF
00:A088 BF
00:A089 42425334        	  1545:   asc "BBS4",$CF
00:A08D CF
00:A08E 42425335        	  1546:   asc "BBS5",$DF
00:A092 DF
00:A093 42425336        	  1547:   asc "BBS6",$EF
00:A097 EF
00:A098 42425337        	  1548:   asc "BBS7",$FF
00:A09C FF
00:A09D 00              	  1549:   dfb 0
                        	  1550: 
                        	  1551: ;------------------------------------
                        	  1552: ;  3-character branch opcodes
                        	  1553: ;------------------------------------
                        	  1554: 
                        	  1555: 
                        	  1556: OPCODE_3_CHAR_BRANCH = *
00:A09E 424343          	  1557:   asc "BCC",$90
00:A0A1 90
00:A0A2 424353          	  1558:   asc "BCS",$B0
00:A0A5 B0
00:A0A6 424551          	  1559:   asc "BEQ",$F0
00:A0A9 F0
00:A0AA 424D49          	  1560:   asc "BMI",$30
00:A0AD 30
00:A0AE 424E45          	  1561:   asc "BNE",$D0
00:A0B1 D0
00:A0B2 42504C          	  1562:   asc "BPL",$10
00:A0B5 10
00:A0B6 425241          	  1563:   asc "BRA",$80
00:A0B9 80
00:A0BA 425643          	  1564:   asc "BVC",$50
00:A0BD 50
00:A0BE 425653          	  1565:   asc "BVS",$70
00:A0C1 70
00:A0C2 00              	  1566:   dfb 0
                        	  1567: 
                        	  1568: 
                        	  1569: ;------------------------------------
                        	  1570: ;  3-character implied opcodes (no operand)
                        	  1571: ;------------------------------------
                        	  1572: 
                        	  1573: OPCODE_3_CHAR_IMPLIED = *
00:A0C3 42524B          	  1574:   asc "BRK",$00
00:A0C6 00
00:A0C7 434C43          	  1575:   asc "CLC",$18
00:A0CA 18
00:A0CB 434C44          	  1576:   asc "CLD",$D8
00:A0CE D8
00:A0CF 434C49          	  1577:   asc "CLI",$58
00:A0D2 58
00:A0D3 434C56          	  1578:   asc "CLV",$B8
00:A0D6 B8
00:A0D7 444558          	  1579:   asc "DEX",$CA
00:A0DA CA
00:A0DB 444559          	  1580:   asc "DEY",$88
00:A0DE 88
00:A0DF 494E58          	  1581:   asc "INX",$E8
00:A0E2 E8
00:A0E3 494E59          	  1582:   asc "INY",$C8
00:A0E6 C8
00:A0E7 4E4F50          	  1583:   asc "NOP",$EA
00:A0EA EA
00:A0EB 504841          	  1584:   asc "PHA",$48
00:A0EE 48
00:A0EF 504850          	  1585:   asc "PHP",$08
00:A0F2 08
00:A0F3 504858          	  1586:   asc "PHX",$DA
00:A0F6 DA
00:A0F7 504859          	  1587:   asc "PHY",$5A
00:A0FA 5A
00:A0FB 504C41          	  1588:   asc "PLA",$68
00:A0FE 68
00:A0FF 504C50          	  1589:   asc "PLP",$28
00:A102 28
00:A103 504C58          	  1590:   asc "PLX",$FA
00:A106 FA
00:A107 504C59          	  1591:   asc "PLY",$7A
00:A10A 7A
00:A10B 525449          	  1592:   asc "RTI",$40
00:A10E 40
00:A10F 525453          	  1593:   asc "RTS",$60
00:A112 60
00:A113 534543          	  1594:   asc "SEC",$38
00:A116 38
00:A117 534544          	  1595:   asc "SED",$F8
00:A11A F8
00:A11B 534549          	  1596:   asc "SEI",$78
00:A11E 78
00:A11F 535450          	  1597:   asc "STP",$DB
00:A122 DB
00:A123 544158          	  1598:   asc "TAX",$AA
00:A126 AA
00:A127 544159          	  1599:   asc "TAY",$A8
00:A12A A8
00:A12B 545358          	  1600:   asc "TSX",$BA
00:A12E BA
00:A12F 545841          	  1601:   asc "TXA",$8A
00:A132 8A
00:A133 545853          	  1602:   asc "TXS",$9A
00:A136 9A
00:A137 545941          	  1603:   asc "TYA",$98
00:A13A 98
00:A13B 574149          	  1604:   asc "WAI",$CB
00:A13E CB
00:A13F 00              	  1605:   dfb 0
                        	  1606: 
                        	  1607: ;------------------------------------
                        	  1608: ;  4-character zero page opcodes (operand must be zero-page address)
                        	  1609: ;------------------------------------
                        	  1610: OPCODE_4_CHAR_ZERO_PAGE = *
00:A140 534D4230        	  1611:   asc "SMB0",$87
00:A144 87
00:A145 534D4231        	  1612:   asc "SMB1",$97
00:A149 97
00:A14A 534D4232        	  1613:   asc "SMB2",$A7
00:A14E A7
00:A14F 534D4233        	  1614:   asc "SMB3",$B7
00:A153 B7
00:A154 534D4234        	  1615:   asc "SMB4",$C7
00:A158 C7
00:A159 534D4235        	  1616:   asc "SMB5",$D7
00:A15D D7
00:A15E 534D4236        	  1617:   asc "SMB6",$E7
00:A162 E7
00:A163 534D4237        	  1618:   asc "SMB7",$F7
00:A167 F7
00:A168 524D4230        	  1619:   asc "RMB0",$07
00:A16C 07
00:A16D 524D4231        	  1620:   asc "RMB1",$17
00:A171 17
00:A172 524D4232        	  1621:   asc "RMB2",$27
00:A176 27
00:A177 524D4233        	  1622:   asc "RMB3",$37
00:A17B 37
00:A17C 524D4234        	  1623:   asc "RMB4",$47
00:A180 47
00:A181 524D4235        	  1624:   asc "RMB5",$57
00:A185 57
00:A186 524D4236        	  1625:   asc "RMB6",$67
00:A18A 67
00:A18B 524D4237        	  1626:   asc "RMB7",$77
00:A18F 77
00:A190 00              	  1627:   dfb 0
                        	  1628: 
                        	  1629: ;------------------------------------
                        	  1630: ;  ASS_OPERAND_ABSOLUTE
                        	  1631: ;------------------------------------
                        	  1632: OPCODE_ASS_OPERAND_ABSOLUTE = *
00:A191 414443          	  1633:   asc "ADC",$6D
00:A194 6D
00:A195 414E44          	  1634:   asc "AND",$2D
00:A198 2D
00:A199 41534C          	  1635:   asc "ASL",$0E
00:A19C 0E
00:A19D 424954          	  1636:   asc "BIT",$2C
00:A1A0 2C
00:A1A1 434D50          	  1637:   asc "CMP",$CD
00:A1A4 CD
00:A1A5 435058          	  1638:   asc "CPX",$EC
00:A1A8 EC
00:A1A9 435059          	  1639:   asc "CPY",$CC
00:A1AC CC
00:A1AD 444543          	  1640:   asc "DEC",$CE
00:A1B0 CE
00:A1B1 454F52          	  1641:   asc "EOR",$4D
00:A1B4 4D
00:A1B5 494E43          	  1642:   asc "INC",$EE
00:A1B8 EE
00:A1B9 4A4D50          	  1643:   asc "JMP",$4C
00:A1BC 4C
00:A1BD 4A5352          	  1644:   asc "JSR",$20
00:A1C0 20
00:A1C1 4C4441          	  1645:   asc "LDA",$AD
00:A1C4 AD
00:A1C5 4C4458          	  1646:   asc "LDX",$AE
00:A1C8 AE
00:A1C9 4C4459          	  1647:   asc "LDY",$AC
00:A1CC AC
00:A1CD 4C5352          	  1648:   asc "LSR",$4E
00:A1D0 4E
00:A1D1 4F5241          	  1649:   asc "ORA",$0D
00:A1D4 0D
00:A1D5 524F4C          	  1650:   asc "ROL",$2E
00:A1D8 2E
00:A1D9 524F52          	  1651:   asc "ROR",$6E
00:A1DC 6E
00:A1DD 534243          	  1652:   asc "SBC",$ED
00:A1E0 ED
00:A1E1 535441          	  1653:   asc "STA",$8D
00:A1E4 8D
00:A1E5 535458          	  1654:   asc "STX",$8E
00:A1E8 8E
00:A1E9 535459          	  1655:   asc "STY",$8C
00:A1EC 8C
00:A1ED 53545A          	  1656:   asc "STZ",$9C
00:A1F0 9C
00:A1F1 545242          	  1657:   asc "TRB",$1C
00:A1F4 1C
00:A1F5 545342          	  1658:   asc "TSB",$0C
00:A1F8 0C
00:A1F9 00              	  1659:   dfb 0
                        	  1660: 
                        	  1661: ;------------------------------------
                        	  1662: ;  ASS_OPERAND_ABSOLUTE - for tokenised opcodes like AND
                        	  1663: ;------------------------------------
                        	  1664: OPCODE_ASS_OPERAND_ABSOLUTE_TOKENISED = *
00:A1FA 8D              	  1665:   dfb TOKEN_AND,$2D
00:A1FB 2D
00:A1FC 00              	  1666:   dfb 0
                        	  1667: 
                        	  1668: 
                        	  1669: ;------------------------------------
                        	  1670: ;  ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
                        	  1671: ;------------------------------------
                        	  1672: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT = *
00:A1FD 4A4D50          	  1673:   asc "JMP",$7C
00:A200 7C
00:A201 00              	  1674:   dfb 0
                        	  1675: 
                        	  1676: ;------------------------------------
                        	  1677: ;  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
                        	  1678: ;------------------------------------
                        	  1679: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X = *
00:A202 414443          	  1680:   asc "ADC",$7D
00:A205 7D
00:A206 414E44          	  1681:   asc "AND",$3D
00:A209 3D
00:A20A 41534C          	  1682:   asc "ASL",$1E
00:A20D 1E
00:A20E 424954          	  1683:   asc "BIT",$3C
00:A211 3C
00:A212 434D50          	  1684:   asc "CMP",$DD
00:A215 DD
00:A216 444543          	  1685:   asc "DEC",$DE
00:A219 DE
00:A21A 454F52          	  1686:   asc "EOR",$5D
00:A21D 5D
00:A21E 494E43          	  1687:   asc "INC",$FE
00:A221 FE
00:A222 4C4441          	  1688:   asc "LDA",$BD
00:A225 BD
00:A226 4C4459          	  1689:   asc "LDY",$BC
00:A229 BC
00:A22A 4C5352          	  1690:   asc "LSR",$5E
00:A22D 5E
00:A22E 4F5241          	  1691:   asc "ORA",$1D
00:A231 1D
00:A232 524F4C          	  1692:   asc "ROL",$3E
00:A235 3E
00:A236 524F52          	  1693:   asc "ROR",$7E
00:A239 7E
00:A23A 534243          	  1694:   asc "SBC",$FD
00:A23D FD
00:A23E 535441          	  1695:   asc "STA",$9D
00:A241 9D
00:A242 53545A          	  1696:   asc "STZ",$9E
00:A245 9E
00:A246 00              	  1697:   dfb 0
                        	  1698: 
                        	  1699: ;------------------------------------
                        	  1700: ;  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X - for tokenised opcodes like AND
                        	  1701: ;------------------------------------
                        	  1702: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X_TOKENISED = *
00:A247 8D              	  1703:   dfb TOKEN_AND,$3D
00:A248 3D
00:A249 00              	  1704:   dfb 0
                        	  1705: 
                        	  1706: ;------------------------------------
                        	  1707: ;  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
                        	  1708: ;------------------------------------
                        	  1709: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y = *
00:A24A 414443          	  1710:   asc "ADC",$79
00:A24D 79
00:A24E 414E44          	  1711:   asc "AND",$39
00:A251 39
00:A252 434D50          	  1712:   asc "CMP",$D9
00:A255 D9
00:A256 454F52          	  1713:   asc "EOR",$59
00:A259 59
00:A25A 4C4441          	  1714:   asc "LDA",$B9
00:A25D B9
00:A25E 4C4458          	  1715:   asc "LDX",$BE
00:A261 BE
00:A262 4F5241          	  1716:   asc "ORA",$19
00:A265 19
00:A266 534243          	  1717:   asc "SBC",$F9
00:A269 F9
00:A26A 535441          	  1718:   asc "STA",$99
00:A26D 99
00:A26E 00              	  1719:   dfb 0
                        	  1720: 
                        	  1721: ;------------------------------------
                        	  1722: ;  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y - for tokenised opcodes like AND
                        	  1723: ;------------------------------------
                        	  1724: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y_TOKENISED = *
00:A26F 8D              	  1725:   dfb TOKEN_AND,$39
00:A270 39
00:A271 00              	  1726:   dfb 0
                        	  1727: 
                        	  1728: ;------------------------------------
                        	  1729: ;  ASS_OPERAND_ACCUMULATOR_A
                        	  1730: ;------------------------------------
                        	  1731: OPCODE_ASS_OPERAND_ACCUMULATOR_A = *
00:A272 41534C          	  1732:   asc "ASL",$0A
00:A275 0A
00:A276 444543          	  1733:   asc "DEC",$3A
00:A279 3A
00:A27A 494E43          	  1734:   asc "INC",$1A
00:A27D 1A
00:A27E 4C5352          	  1735:   asc "LSR",$4A
00:A281 4A
00:A282 524F4C          	  1736:   asc "ROL",$2A
00:A285 2A
00:A286 524F52          	  1737:   asc "ROR",$6A
00:A289 6A
00:A28A 00              	  1738:   dfb 0
                        	  1739: 
                        	  1740: ;------------------------------------
                        	  1741: ;  ASS_OPERAND_ABSOLUTE_INDIRECT
                        	  1742: ;------------------------------------
                        	  1743: OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT = *
00:A28B 4A4D50          	  1744:   asc "JMP",$6C
00:A28E 6C
00:A28F 00              	  1745:   dfb 0
                        	  1746: 
                        	  1747: ;------------------------------------
                        	  1748: ;  ASS_OPERAND_IMMEDIATE
                        	  1749: ;------------------------------------
                        	  1750: OPCODE_ASS_OPERAND_IMMEDIATE = *
00:A290 414443          	  1751:   asc "ADC",$69
00:A293 69
00:A294 414E44          	  1752:   asc "AND",$29
00:A297 29
00:A298 424954          	  1753:   asc "BIT",$89
00:A29B 89
00:A29C 434D50          	  1754:   asc "CMP",$C9
00:A29F C9
00:A2A0 435058          	  1755:   asc "CPX",$E0
00:A2A3 E0
00:A2A4 435059          	  1756:   asc "CPY",$C0
00:A2A7 C0
00:A2A8 454F52          	  1757:   asc "EOR",$49
00:A2AB 49
00:A2AC 4C4441          	  1758:   asc "LDA",$A9
00:A2AF A9
00:A2B0 4C4458          	  1759:   asc "LDX",$A2
00:A2B3 A2
00:A2B4 4C4459          	  1760:   asc "LDY",$A0
00:A2B7 A0
00:A2B8 4F5241          	  1761:   asc "ORA",$09
00:A2BB 09
00:A2BC 534243          	  1762:   asc "SBC",$E9
00:A2BF E9
00:A2C0 00              	  1763:   dfb 0
                        	  1764: 
                        	  1765: ;------------------------------------
                        	  1766: ;  ASS_OPERAND_IMMEDIATE - for tokenised opcodes like AND
                        	  1767: ;------------------------------------
                        	  1768: OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED = *
00:A2C1 8D              	  1769:   dfb TOKEN_AND,$29
00:A2C2 29
00:A2C3 00              	  1770:   dfb 0
                        	  1771: 
                        	  1772: ;------------------------------------
                        	  1773: ;  ASS_OPERAND_ZERO_PAGE
                        	  1774: ;------------------------------------
                        	  1775: OPCODE_ASS_OPERAND_ZERO_PAGE = *
00:A2C4 414443          	  1776:   asc "ADC",$65
00:A2C7 65
00:A2C8 414E44          	  1777:   asc "AND",$25
00:A2CB 25
00:A2CC 41534C          	  1778:   asc "ASL",$06
00:A2CF 06
00:A2D0 424954          	  1779:   asc "BIT",$24
00:A2D3 24
00:A2D4 434D50          	  1780:   asc "CMP",$C5
00:A2D7 C5
00:A2D8 435058          	  1781:   asc "CPX",$E4
00:A2DB E4
00:A2DC 435059          	  1782:   asc "CPY",$C4
00:A2DF C4
00:A2E0 444543          	  1783:   asc "DEC",$C6
00:A2E3 C6
00:A2E4 454F52          	  1784:   asc "EOR",$45
00:A2E7 45
00:A2E8 494E43          	  1785:   asc "INC",$E6
00:A2EB E6
00:A2EC 4C4441          	  1786:   asc "LDA",$A5
00:A2EF A5
00:A2F0 4C4458          	  1787:   asc "LDX",$A6
00:A2F3 A6
00:A2F4 4C4459          	  1788:   asc "LDY",$A4
00:A2F7 A4
00:A2F8 4C5352          	  1789:   asc "LSR",$46
00:A2FB 46
00:A2FC 4F5241          	  1790:   asc "ORA",$05
00:A2FF 05
00:A300 524F4C          	  1791:   asc "ROL",$26
00:A303 26
00:A304 524F52          	  1792:   asc "ROR",$66
00:A307 66
00:A308 534243          	  1793:   asc "SBC",$E5
00:A30B E5
00:A30C 535441          	  1794:   asc "STA",$85
00:A30F 85
00:A310 535458          	  1795:   asc "STX",$86
00:A313 86
00:A314 535459          	  1796:   asc "STY",$84
00:A317 84
00:A318 53545A          	  1797:   asc "STZ",$64
00:A31B 64
00:A31C 545242          	  1798:   asc "TRB",$14
00:A31F 14
00:A320 545342          	  1799:   asc "TSB",$04
00:A323 04
00:A324 00              	  1800:   dfb 0
                        	  1801: 
                        	  1802: ;------------------------------------
                        	  1803: ;  ASS_OPERAND_ZERO_PAGE  - for tokenised opcodes like AND
                        	  1804: ;------------------------------------
                        	  1805: OPCODE_ASS_OPERAND_ZERO_PAGE_TOKENISED = *
00:A325 8D              	  1806:   dfb TOKEN_AND,$25
00:A326 25
00:A327 00              	  1807:   dfb 0
                        	  1808: 
                        	  1809: 
                        	  1810: ;------------------------------------
                        	  1811: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
                        	  1812: ;------------------------------------
                        	  1813: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT = *
00:A328 414443          	  1814:   asc "ADC",$61
00:A32B 61
00:A32C 414E44          	  1815:   asc "AND",$21
00:A32F 21
00:A330 434D50          	  1816:   asc "CMP",$C1
00:A333 C1
00:A334 454F52          	  1817:   asc "EOR",$41
00:A337 41
00:A338 4C4441          	  1818:   asc "LDA",$A1
00:A33B A1
00:A33C 4F5241          	  1819:   asc "ORA",$01
00:A33F 01
00:A340 534243          	  1820:   asc "SBC",$E1
00:A343 E1
00:A344 535441          	  1821:   asc "STA",$81
00:A347 81
00:A348 00              	  1822:   dfb 0
                        	  1823: 
                        	  1824: ;------------------------------------
                        	  1825: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT  - for tokenised opcodes like AND
                        	  1826: ;------------------------------------
                        	  1827: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT_TOKENISED  = *
00:A349 8D              	  1828:   dfb TOKEN_AND,$21
00:A34A 21
00:A34B 00              	  1829:   dfb 0
                        	  1830: 
                        	  1831: 
                        	  1832: ;------------------------------------
                        	  1833: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
                        	  1834: ;------------------------------------
                        	  1835: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X = *
00:A34C 414443          	  1836:   asc "ADC",$75
00:A34F 75
00:A350 414E44          	  1837:   asc "AND",$35
00:A353 35
00:A354 41534C          	  1838:   asc "ASL",$16
00:A357 16
00:A358 424954          	  1839:   asc "BIT",$34
00:A35B 34
00:A35C 434D50          	  1840:   asc "CMP",$D5
00:A35F D5
00:A360 444543          	  1841:   asc "DEC",$D6
00:A363 D6
00:A364 454F52          	  1842:   asc "EOR",$55
00:A367 55
00:A368 494E43          	  1843:   asc "INC",$F6
00:A36B F6
00:A36C 4C4441          	  1844:   asc "LDA",$B5
00:A36F B5
00:A370 4C4459          	  1845:   asc "LDY",$B4
00:A373 B4
00:A374 4C5352          	  1846:   asc "LSR",$56
00:A377 56
00:A378 4F5241          	  1847:   asc "ORA",$15
00:A37B 15
00:A37C 524F4C          	  1848:   asc "ROL",$36
00:A37F 36
00:A380 524F52          	  1849:   asc "ROR",$76
00:A383 76
00:A384 534243          	  1850:   asc "SBC",$F5
00:A387 F5
00:A388 535441          	  1851:   asc "STA",$95
00:A38B 95
00:A38C 535459          	  1852:   asc "STY",$94
00:A38F 94
00:A390 53545A          	  1853:   asc "STZ",$74
00:A393 74
00:A394 00              	  1854:   dfb 0
                        	  1855: 
                        	  1856: ;------------------------------------
                        	  1857: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X  - for tokenised opcodes like AND
                        	  1858: ;------------------------------------
                        	  1859: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X_TOKENISED = *
00:A395 8D              	  1860:   dfb TOKEN_AND,$35
00:A396 35
00:A397 00              	  1861:   dfb 0
                        	  1862: 
                        	  1863: ;------------------------------------
                        	  1864: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
                        	  1865: ;------------------------------------
                        	  1866: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y = *
00:A398 4C4458          	  1867:   asc "LDX",$B6
00:A39B B6
00:A39C 535458          	  1868:   asc "STX",$96
00:A39F 96
00:A3A0 00              	  1869:   dfb 0
                        	  1870: 
                        	  1871: ;------------------------------------
                        	  1872: ;  ASS_OPERAND_ZERO_PAGE_INDIRECT
                        	  1873: ;------------------------------------
                        	  1874: OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT = *
00:A3A1 414443          	  1875:   asc "ADC",$72
00:A3A4 72
00:A3A5 414E44          	  1876:   asc "AND",$32
00:A3A8 32
00:A3A9 434D50          	  1877:   asc "CMP",$D2
00:A3AC D2
00:A3AD 454F52          	  1878:   asc "EOR",$52
00:A3B0 52
00:A3B1 4C4441          	  1879:   asc "LDA",$B2
00:A3B4 B2
00:A3B5 4F5241          	  1880:   asc "ORA",$12
00:A3B8 12
00:A3B9 534243          	  1881:   asc "SBC",$F2
00:A3BC F2
00:A3BD 535441          	  1882:   asc "STA",$92
00:A3C0 92
00:A3C1 00              	  1883:   dfb 0
                        	  1884: 
                        	  1885: ;------------------------------------
                        	  1886: ;  ASS_OPERAND_ZERO_PAGE_INDIRECT  - for tokenised opcodes like AND
                        	  1887: ;------------------------------------
                        	  1888: OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_TOKENISED = *
00:A3C2 8D              	  1889:   dfb TOKEN_AND,$32
00:A3C3 32
00:A3C4 00              	  1890:   dfb 0
                        	  1891: 
                        	  1892: ;------------------------------------
                        	  1893: ;  ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
                        	  1894: ;------------------------------------
                        	  1895: OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y = *
00:A3C5 414443          	  1896:   asc "ADC",$71
00:A3C8 71
00:A3C9 414E44          	  1897:   asc "AND",$31
00:A3CC 31
00:A3CD 434D50          	  1898:   asc "CMP",$D1
00:A3D0 D1
00:A3D1 454F52          	  1899:   asc "EOR",$51
00:A3D4 51
00:A3D5 4C4441          	  1900:   asc "LDA",$B1
00:A3D8 B1
00:A3D9 4F5241          	  1901:   asc "ORA",$11
00:A3DC 11
00:A3DD 534243          	  1902:   asc "SBC",$F1
00:A3E0 F1
00:A3E1 535441          	  1903:   asc "STA",$91
00:A3E4 91
00:A3E5 00              	  1904:   dfb 0
                        	  1905: 
                        	  1906: ;------------------------------------
                        	  1907: ;  ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y - for tokenised opcodes like AND
                        	  1908: ;------------------------------------
                        	  1909: OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y_TOKENISED  = *
00:A3E6 8D              	  1910:   dfb TOKEN_AND,$31
00:A3E7 31
00:A3E8 00              	  1911:   dfb 0
                        	  1912: 
                        	  1913: 
                        	  1914: ; ---------------------------
                        	  1915: ; Compiler directives
                        	  1916: ; ---------------------------
                        	  1917: 
                        	  1918: ;
                        	  1919: ;  ASSERT <expression>  - raises an error if <expression> is zero
                        	  1920: ;
                        	  1921: asm_do_assert:
00:A3E9 A56B            	  1922:   lda ASS_OPERAND
00:A3EB C901            	  1923:   cmp #ASS_OPERAND_ABSOLUTE
00:A3ED D00E            	  1924:   bne asm_do_constant_expectedJ
00:A3EF A500            	  1925:   lda VALUE
00:A3F1 0501            	  1926:   ora VALUE+1
00:A3F3 0502            	  1927:   ora VALUE+2
00:A3F5 F001            	  1928:   beq asm_do_assert_failed
00:A3F7 60              	  1929:   rts
                        	  1930: 
                        	  1931: asm_do_assert_failed:
00:A3F8 A234            	  1932:   ldx #52
00:A3FA 4CC39E          	  1933:   jmp ass_error
                        	  1934: 
00:A3FD 4C95A4          	  1935: asm_do_constant_expectedJ jmp asm_do_constant_expected
                        	  1936: 
                        	  1937: ;
                        	  1938: ; LIST (0= none, 1=source, 2=opcodes, 4=symbols, can OR these together)
                        	  1939: ; LIST  is the same as LIST 3
                        	  1940: 
                        	  1941: asm_do_list = *
                        	  1942: 
                        	  1943: ;   lda #'f'
                        	  1944: ;   jsr ass_debug_point
                        	  1945: 
00:A400 A56B            	  1946:   lda ASS_OPERAND
00:A402 C908            	  1947:   cmp #ASS_OPERAND_IMPLIED      ; implied (ie. no operand) will resolve to be the same as LIST 3
00:A404 F01A            	  1948:   beq asm_do_list_no_operand
00:A406 C901            	  1949:   cmp #ASS_OPERAND_ABSOLUTE
00:A408 F01A            	  1950:   beq asm_do_list_ok
00:A40A A202            	  1951:   ldx #2    ; ERROR: constant expected
00:A40C 4CC39E          	  1952:   jmp ass_error
                        	  1953: 
                        	  1954: ;
                        	  1955: ;  NOLIST is the same as LIST 0
                        	  1956: ;
                        	  1957: asm_do_nolist:
00:A40F A56B            	  1958:   lda ASS_OPERAND
00:A411 C908            	  1959:   cmp #ASS_OPERAND_IMPLIED
00:A413 F005            	  1960:   beq asm_do_nolist_ok              ; should have no operand
00:A415 A217            	  1961:   ldx #23   ; ERROR: Illegal factor
00:A417 4CC39E          	  1962:   jmp ass_error
                        	  1963: asm_do_nolist_ok:
00:A41A A900            	  1964:   lda #0
00:A41C 8500            	  1965:   sta VALUE
00:A41E 8004            	  1966:   bra asm_do_list_ok
                        	  1967: 
                        	  1968: asm_do_list_no_operand:
00:A420 A903            	  1969:   lda #3
00:A422 8573            	  1970:   sta ASS_VALUE
                        	  1971: asm_do_list_ok:
00:A424 A576            	  1972:   lda ASS_PASS
00:A426 F025            	  1973:   beq asm_do_list_first_pass  ; ignore on first pass
                        	  1974: 
                        	  1975: ;  lda ASS_VALUE
                        	  1976: ;  clc
                        	  1977: ;  adc #'0'
                        	  1978: ;  jsr ass_debug_point
                        	  1979: 
00:A428 A573            	  1980:   lda ASS_VALUE
00:A42A 2901            	  1981:   and #$01
00:A42C F00C            	  1982:   beq asm_do_list_not    ; no listing wanted
00:A42E A904            	  1983:   lda #FLAG_LIST_SOURCE ; already listing?
00:A430 25BE            	  1984:   and system_flags
00:A432 D00A            	  1985:   bne  asm_do_list1   ; yep
00:A434 A904            	  1986:   lda #FLAG_LIST_SOURCE
00:A436 04BE            	  1987:   tsb system_flags
                        	  1988: ;  jsr token_line        ; list the current line  TODO: don't know, I think it bumps the line number wrongly
00:A438 8004            	  1989:   bra asm_do_list1
                        	  1990: 
                        	  1991: ;
                        	  1992: ;  turn off list flag
                        	  1993: ;
                        	  1994: asm_do_list_not:
00:A43A A904            	  1995:   lda #FLAG_LIST_SOURCE
00:A43C 14BE            	  1996:   trb system_flags
                        	  1997: 
                        	  1998: asm_do_list1:
                        	  1999: 
                        	  2000: 
00:A43E A573            	  2001:   lda ASS_VALUE
00:A440 2902            	  2002:   and #$02
00:A442 852E            	  2003:   sta DCODE
                        	  2004: 
                        	  2005: 
00:A444 A573            	  2006:   lda ASS_VALUE
00:A446 2904            	  2007:   and #$04
00:A448 8582            	  2008:   sta show_symbols
                        	  2009: ;
                        	  2010: ;  output a newline, to get past the asterisks
                        	  2011: ;
00:A44A 204792          	  2012:   jsr CROUT
                        	  2013: asm_do_list_first_pass:
00:A44D 60              	  2014:   rts
                        	  2015: 
                        	  2016: ;
                        	  2017: ;  ASC "String"
                        	  2018: ;
                        	  2019: asm_do_asc = *
00:A44E A56B            	  2020:   lda ASS_OPERAND
00:A450 C911            	  2021:   cmp #ASS_OPERAND_STRING
00:A452 F005            	  2022:   beq asm_do_asc_ok
00:A454 A208            	  2023:   ldx #8    ; ERROR: incorrect string
00:A456 4CC39E          	  2024:   jmp ass_error
                        	  2025: ;
                        	  2026: ;  now emit the string
                        	  2027: ;
                        	  2028: asm_do_asc_ok:
00:A459 A000            	  2029:   ldy  #0
                        	  2030: asm_do_asc_loop:
00:A45B B90002          	  2031:   lda  INBUF,Y
00:A45E C8              	  2032:   iny         ; onto next character in the string
00:A45F 5A              	  2033:   phy
00:A460 20859E          	  2034:   jsr ass_emit
00:A463 7A              	  2035:   ply
                        	  2036: 
                        	  2037: asm_do_asc_next:
00:A464 C692            	  2038:   dec token_length
00:A466 D0F3            	  2039:   bne asm_do_asc_loop
00:A468 60              	  2040:   rts
                        	  2041: 
                        	  2042: 
                        	  2043: ;
                        	  2044: ;  ASCIIZ / STRING - output a string with a null terminator
                        	  2045: ;
                        	  2046: 
                        	  2047: asm_do_string:
00:A469 204EA4          	  2048:   jsr asm_do_asc    ; do the string
00:A46C A900            	  2049:   lda #0            ; and the terminator
00:A46E 20859E          	  2050:   jsr ass_emit
00:A471 60              	  2051:   rts
                        	  2052: 
                        	  2053: 
                        	  2054: ;
                        	  2055: ;  EQU
                        	  2056: ;
                        	  2057: ;  The label, which must be present, takes on the value of the expression
                        	  2058: ;
                        	  2059: 
                        	  2060: asm_do_equ:
00:A472 A56B            	  2061:   lda ASS_OPERAND
00:A474 C901            	  2062:   cmp #ASS_OPERAND_ABSOLUTE
00:A476 D01D            	  2063:   bne asm_do_constant_expected
00:A478 A583            	  2064:   lda ass_current_label
00:A47A 0584            	  2065:   ora ass_current_label+1
00:A47C D005            	  2066:   bne asm_do_equ_have_label
00:A47E A230            	  2067:   ldx #48    ; ERROR: label required
00:A480 4CC39E          	  2068:   jmp ass_error
                        	  2069: 
                        	  2070: asm_do_equ_have_label:
00:A483 A004            	  2071:   ldy #SYMDSP
00:A485 A573            	  2072:   lda ASS_VALUE
00:A487 9183            	  2073:   sta (ass_current_label),y
00:A489 C8              	  2074:   iny
00:A48A A574            	  2075:   lda ASS_VALUE+1
00:A48C 9183            	  2076:   sta (ass_current_label),y
00:A48E 60              	  2077:   rts
                        	  2078: 
                        	  2079: ;
                        	  2080: ;  ORG
                        	  2081: ;
                        	  2082: ;  The program counter becomes the value of the expression
                        	  2083: ;
                        	  2084: 
                        	  2085: asm_do_org:
00:A48F A56B            	  2086:   lda ASS_OPERAND
00:A491 C901            	  2087:   cmp #ASS_OPERAND_ABSOLUTE
00:A493 F005            	  2088:   beq asm_do_org_ok
                        	  2089: asm_do_constant_expected:
00:A495 A202            	  2090:   ldx #2    ; ERROR: constant expected
00:A497 4CC39E          	  2091:   jmp ass_error
                        	  2092: 
                        	  2093: asm_do_org_ok:
00:A49A A573            	  2094:   lda ASS_VALUE
00:A49C 8523            	  2095:   sta PCODE
00:A49E A574            	  2096:   lda ASS_VALUE+1
00:A4A0 8524            	  2097:   sta PCODE+1
00:A4A2 60              	  2098:   rts
                        	  2099: 
                        	  2100: ;
                        	  2101: ;  DFB - define one byte (value being the expression)
                        	  2102: ;
                        	  2103: 
                        	  2104: asm_do_dfb:
00:A4A3 A56B            	  2105:   lda ASS_OPERAND
00:A4A5 C912            	  2106:   cmp #ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE  ; multiple values?
00:A4A7 F008            	  2107:   beq asm_do_dfb_multiple
00:A4A9 C901            	  2108:   cmp #ASS_OPERAND_ABSOLUTE
00:A4AB D0E8            	  2109:   bne asm_do_constant_expected
00:A4AD 20D5A4          	  2110:   jsr asm_emit_one_byte
00:A4B0 60              	  2111:   rts
                        	  2112: 
                        	  2113: ;
                        	  2114: ;  so if we got here we thought we had two values (like a BBR0 $12,foo)
                        	  2115: ;  - the first is in REMAIN and the other in VALUE
                        	  2116: ;
                        	  2117: ;  let's emit REMAIN, then VALUE, then look for other values
                        	  2118: ;
                        	  2119: asm_do_dfb_multiple:
00:A4B1 A507            	  2120:   lda REMAIN+1
00:A4B3 D01B            	  2121:   bne asm_do_dfb_too_big
00:A4B5 A508            	  2122:   lda REMAIN+2
00:A4B7 D017            	  2123:   bne asm_do_dfb_too_big
00:A4B9 A506            	  2124:   lda REMAIN
00:A4BB 20859E          	  2125:   jsr ass_emit  ; emit REMAIN
                        	  2126: asm_do_dfb_multiple_loop:
00:A4BE 20D5A4          	  2127:   jsr asm_emit_one_byte  ; emit VALUE
00:A4C1 A593            	  2128:   lda token_type
00:A4C3 C92C            	  2129:   cmp #','      ; another?
00:A4C5 D008            	  2130:   bne asm_do_dfb_multiple_done
00:A4C7 2098C9          	  2131:   jsr get_token
00:A4CA 20F09C          	  2132:   jsr ass_get_value  ; should have some sort of address now in VALUE
00:A4CD 80EF            	  2133:   bra asm_do_dfb_multiple_loop
                        	  2134: 
                        	  2135: asm_do_dfb_multiple_done:
00:A4CF 60              	  2136:   rts
                        	  2137: 
                        	  2138: 
                        	  2139: asm_do_dfb_too_big:
00:A4D0 A22C            	  2140:   ldx #44
00:A4D2 4CC39E          	  2141:   jmp ass_error
                        	  2142: 
                        	  2143: asm_emit_one_byte:
00:A4D5 A574            	  2144:   lda ASS_VALUE+1
00:A4D7 D0F7            	  2145:   bne asm_do_dfb_too_big
00:A4D9 A575            	  2146:   lda ASS_VALUE+2
00:A4DB D0F3            	  2147:   bne asm_do_dfb_too_big
00:A4DD A573            	  2148:   lda ASS_VALUE
00:A4DF 20859E          	  2149:   jsr ass_emit
00:A4E2 60              	  2150:   rts
                        	  2151: 
                        	  2152: 
                        	  2153: ;
                        	  2154: ;  DFW - define two bytes (value being the expression)
                        	  2155: ;
                        	  2156: 
                        	  2157: asm_do_dfw:
00:A4E3 A56B            	  2158:   lda ASS_OPERAND
00:A4E5 C912            	  2159:   cmp #ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE  ; multiple values?
00:A4E7 F008            	  2160:   beq asm_do_dfw_multiple
00:A4E9 C901            	  2161:   cmp #ASS_OPERAND_ABSOLUTE
00:A4EB D0A8            	  2162:   bne asm_do_constant_expected
00:A4ED 2011A5          	  2163:   jsr asm_emit_two_bytes
00:A4F0 60              	  2164:   rts
                        	  2165: 
                        	  2166: ;
                        	  2167: ;  so if we got here we thought we had two values (like a BBR0 $12,foo)
                        	  2168: ;  - the first is in REMAIN and the other in VALUE
                        	  2169: ;
                        	  2170: ;  let's emit REMAIN, then VALUE, then look for other values
                        	  2171: ;
                        	  2172: asm_do_dfw_multiple:
00:A4F1 A508            	  2173:   lda REMAIN+2
00:A4F3 D0DB            	  2174:   bne asm_do_dfb_too_big
00:A4F5 A506            	  2175:   lda REMAIN
00:A4F7 20859E          	  2176:   jsr ass_emit  ; emit REMAIN
00:A4FA A507            	  2177:   lda REMAIN+1
00:A4FC 20859E          	  2178:   jsr ass_emit  ; emit REMAIN+1
                        	  2179: asm_do_dfw_multiple_loop:
00:A4FF 2011A5          	  2180:   jsr asm_emit_two_bytes  ; emit VALUE
00:A502 A593            	  2181:   lda token_type
00:A504 C92C            	  2182:   cmp #','      ; another?
00:A506 D008            	  2183:   bne asm_do_dfw_multiple_done
00:A508 2098C9          	  2184:   jsr get_token
00:A50B 20F09C          	  2185:   jsr ass_get_value  ; should have some sort of address now in VALUE
00:A50E 80EF            	  2186:   bra asm_do_dfw_multiple_loop
                        	  2187: 
                        	  2188: asm_do_dfw_multiple_done:
00:A510 60              	  2189:   rts
                        	  2190: 
                        	  2191: 
                        	  2192: asm_emit_two_bytes:
00:A511 A575            	  2193:   lda ASS_VALUE+2
00:A513 D0BB            	  2194:   bne asm_do_dfb_too_big
00:A515 A573            	  2195:   lda ASS_VALUE
00:A517 20859E          	  2196:   jsr ass_emit
00:A51A A574            	  2197:   lda ASS_VALUE+1
00:A51C 20859E          	  2198:   jsr ass_emit
00:A51F 60              	  2199:   rts
                        	  2200: 
                        	  2201: 
                        	  2202: 
                        	  2203: ;
                        	  2204: ;  BLK - zero fill <expression> bytes (eg. BLK 5 output 5 zeroes)
                        	  2205: ;
                        	  2206: 
                        	  2207: asm_do_blk:
00:A520 A56B            	  2208:   lda ASS_OPERAND
00:A522 C901            	  2209:   cmp #ASS_OPERAND_ABSOLUTE
00:A524 D030            	  2210:   bne asm_do_constant_expectedJ2
00:A526 A575            	  2211:   lda ASS_VALUE+2
00:A528 D0A6            	  2212:   bne asm_do_dfb_too_big
                        	  2213: ;
                        	  2214: ; handle (obscure) case of them defining zero bytes
                        	  2215: ;
00:A52A A573            	  2216:   lda ASS_VALUE
00:A52C 0574            	  2217:   ora ASS_VALUE+1
00:A52E F00D            	  2218:   beq asm_do_blk_done
                        	  2219: asm_do_blk_loop:
                        	  2220: ;
                        	  2221: ;  emit one zero
                        	  2222: ;
00:A530 A900            	  2223:   lda #0
00:A532 20859E          	  2224:   jsr ass_emit
00:A535 C673            	  2225:   dec ASS_VALUE
00:A537 D0F7            	  2226:   bne asm_do_blk_loop
00:A539 C674            	  2227:   dec ASS_VALUE+1
00:A53B 10F3            	  2228:   bpl asm_do_blk_loop
                        	  2229: asm_do_blk_done:
00:A53D 60              	  2230:   rts
                        	  2231: 
                        	  2232: ;
                        	  2233: ;  RESERVE - reserve <expression> bytes without writing to them
                        	  2234: ;   useful for leaving a gap (eg. for zero-page variables)
                        	  2235: ;
                        	  2236: 
                        	  2237: asm_do_reserve:
00:A53E A56B            	  2238:   lda ASS_OPERAND
00:A540 C901            	  2239:   cmp #ASS_OPERAND_ABSOLUTE
00:A542 D012            	  2240:   bne asm_do_constant_expectedJ2
00:A544 A575            	  2241:   lda ASS_VALUE+2
00:A546 D088            	  2242:   bne asm_do_dfb_too_big
00:A548 18              	  2243:   clc
00:A549 A523            	  2244:   lda PCODE
00:A54B 6573            	  2245:   adc ASS_VALUE
00:A54D 8523            	  2246:   sta PCODE
00:A54F A524            	  2247:   lda PCODE+1
00:A551 6574            	  2248:   adc ASS_VALUE+1
00:A553 8524            	  2249:   sta PCODE+1
00:A555 60              	  2250:   rts
                        	  2251: 
00:A556 4C95A4          	  2252: asm_do_constant_expectedJ2 jmp asm_do_constant_expected
                        	  2253: 
                        	  2254: ;
                        	  2255: ;  SYM <address> symbol table relocation
                        	  2256: ;
                        	  2257: asm_do_sym:
00:A559 A56B            	  2258:   lda ASS_OPERAND
00:A55B C901            	  2259:   cmp #ASS_OPERAND_ABSOLUTE
00:A55D D0F7            	  2260:   bne asm_do_constant_expectedJ2
                        	  2261: ;
                        	  2262: ;  only relocate symbol table on the first pass
                        	  2263: ;
00:A55F A576            	  2264:   lda ASS_PASS
00:A561 D00F            	  2265:   bne asm_do_sym_done
                        	  2266: 
00:A563 A573            	  2267:   lda  ASS_VALUE
00:A565 8531            	  2268:   sta  ENDSYM
00:A567 852F            	  2269:   sta  STARTSYM
00:A569 A574            	  2270:   lda  ASS_VALUE+1
00:A56B 8532            	  2271:   sta  ENDSYM+1        ; store symbol table address
00:A56D 8530            	  2272:   sta  STARTSYM+1
                        	  2273: ;
                        	  2274: ;  put our library functions back into the symbol table
                        	  2275: ;
00:A56F 2093AA          	  2276:   jsr  add_assembler_library_functions  ; add our inbuilt functions to the symbol table
                        	  2277: 
                        	  2278: asm_do_sym_done:
00:A572 60              	  2279:   rts
                        	  2280: ;
                        	  2281: 
                        	  2282: 
00:A573 41646472204E616D	  2283: info_message asciiz "Addr Name\n"
00:A57B 650A
00:A57D 00
                        	  2284: 
                        	  2285: list_symbols  = *
00:A57E A973            	  2286:          lda #<info_message
00:A580 A2A5            	  2287:          ldx #>info_message
00:A582 202682          	  2288:          jsr print
                        	  2289: 
00:A585 A532            	  2290:          lda  ENDSYM+1    ; get the end of the symbol table
00:A587 8541            	  2291:          sta  SYMITM+1    ; make it the current symbol
00:A589 A531            	  2292:          lda  ENDSYM
00:A58B 800B            	  2293:          bra  list_symbols_check
                        	  2294: 
                        	  2295: list_symbols_next =  *
00:A58D A000            	  2296:          ldy  #SYMPRV
00:A58F B140            	  2297:          lda  (SYMITM),Y
00:A591 AA              	  2298:          tax
00:A592 C8              	  2299:          iny
00:A593 B140            	  2300:          lda  (SYMITM),Y
00:A595 8541            	  2301:          sta  SYMITM+1   ; previous link
00:A597 8A              	  2302:          txa
                        	  2303: ;
                        	  2304: ;  go to the previous symbol table item
                        	  2305: ;
                        	  2306: list_symbols_check     =  *
00:A598 8540            	  2307:          sta  SYMITM
00:A59A C52F            	  2308:          cmp  STARTSYM
00:A59C D009            	  2309:          bne  list_symbols_line
00:A59E A541            	  2310:          lda  SYMITM+1
00:A5A0 C530            	  2311:          cmp  STARTSYM+1
00:A5A2 D003            	  2312:          bne  list_symbols_line       ; more to go
00:A5A4 4CD2A5          	  2313:          jmp  list_symbols_done       ; finished if symitm and symitm+1 are both zero
                        	  2314: 
                        	  2315: list_symbols_line = *
00:A5A7 A004            	  2316:          ldy  #SYMDSP
00:A5A9 C8              	  2317:          iny
00:A5AA B140            	  2318:          lda  (SYMITM),Y  ; displacement
00:A5AC 20BC92          	  2319:          jsr  PRBYTE
00:A5AF 88              	  2320:          dey
00:A5B0 B140            	  2321:          lda  (SYMITM),Y  ; displacement
00:A5B2 20BC92          	  2322:          jsr  PRBYTE
00:A5B5 A920            	  2323:          lda  #' '
00:A5B7 20A492          	  2324:          jsr  PRCHAR
00:A5BA A009            	  2325:          ldy  #SYMLEN
00:A5BC B140            	  2326:          lda  (SYMITM),Y  ; length
00:A5BE AA              	  2327:          tax
00:A5BF A00A            	  2328:          ldy  #SYMNAM
                        	  2329: list_symbols_name = *
00:A5C1 B140            	  2330:          lda  (SYMITM),Y  ; name
00:A5C3 5A              	  2331:          phy
00:A5C4 20A492          	  2332:          jsr  PRCHAR
00:A5C7 7A              	  2333:          ply
00:A5C8 C8              	  2334:          iny
00:A5C9 CA              	  2335:          dex
00:A5CA D0F5            	  2336:          bne list_symbols_name
00:A5CC 204792          	  2337:          jsr CROUT
00:A5CF 4C8DA5          	  2338:          jmp list_symbols_next
                        	  2339: 
                        	  2340: list_symbols_done = *
00:A5D2 60              	  2341:          rts
                        	  2342: 
                        	  2343: assembler_library_functions_table:
                        	  2344: ;
                        	  2345: ;  put them in reverse alphabetic order so they come out in alphabetic
                        	  2346: ;  order if you request a symbols list
                        	  2347: ;
                        	  2348:   makeAsmLibraryFunction "write_to_serial",      write_to_serial
00:A5D3 77726974655F746F	     1M      asciiz   "write_to_serial"
00:A5DB 5F73657269616C
00:A5E2 00
00:A5E3 02C9            	     2M      word     write_to_serial
                        	  2349:   makeAsmLibraryFunction "write_to_lcd",         write_to_lcd
00:A5E5 77726974655F746F	     1M      asciiz   "write_to_lcd"
00:A5ED 5F6C6364
00:A5F1 00
00:A5F2 0DC9            	     2M      word     write_to_lcd
                        	  2350:   makeAsmLibraryFunction "write_function",       write_function
00:A5F4 77726974655F6675	     1M      asciiz   "write_function"
00:A5FC 6E6374696F6E
00:A602 00
00:A603 1700            	     2M      word     write_function
                        	  2351:   makeAsmLibraryFunction "write_char",           write_char
00:A605 77726974655F6368	     1M      asciiz   "write_char"
00:A60D 6172
00:A60F 00
00:A610 62C9            	     2M      word     write_char
                        	  2352:   makeAsmLibraryFunction "value",                VALUE
00:A612 76616C7565      	     1M      asciiz   "value"
00:A617 00
00:A618 0000            	     2M      word     VALUE
                        	  2353:   makeAsmLibraryFunction "value2",               VALUE2
00:A61A 76616C756532    	     1M      asciiz   "value2"
00:A620 00
00:A621 0300            	     2M      word     VALUE2
                        	  2354:   makeAsmLibraryFunction "typing_latency",       typing_latency
00:A623 747970696E675F6C	     1M      asciiz   "typing_latency"
00:A62B 6174656E6379
00:A631 00
00:A632 0D00            	     2M      word     typing_latency
                        	  2355:   makeAsmLibraryFunction "tknjmp",               TKNJMP
00:A634 746B6E6A6D70    	     1M      asciiz   "tknjmp"
00:A63A 00
00:A63B B18F            	     2M      word     TKNJMP
                        	  2356:   makeAsmLibraryFunction "reset",                START
00:A63D 7265736574      	     1M      asciiz   "reset"
00:A642 00
00:A643 39DA            	     2M      word     START
                        	  2357:   makeAsmLibraryFunction "srce",                 SRCE
00:A645 73726365        	     1M      asciiz   "srce"
00:A649 00
00:A64A 0000            	     2M      word     SRCE
                        	  2358:   makeAsmLibraryFunction "spi_transfer",         spi_transfer
00:A64C 7370695F7472616E	     1M      asciiz   "spi_transfer"
00:A654 73666572
00:A658 00
00:A659 4BD1            	     2M      word     spi_transfer
                        	  2359:   makeAsmLibraryFunction "spi_ss_low",           spi_ss_low
00:A65B 7370695F73735F6C	     1M      asciiz   "spi_ss_low"
00:A663 6F77
00:A665 00
00:A666 AFD1            	     2M      word     spi_ss_low
                        	  2360:   makeAsmLibraryFunction "spi_ss_high",          spi_ss_high
00:A668 7370695F73735F68	     1M      asciiz   "spi_ss_high"
00:A670 696768
00:A673 00
00:A674 B7D1            	     2M      word     spi_ss_high
                        	  2361:   makeAsmLibraryFunction "spi_send_two_bytes",   spi_send_two_bytes
00:A676 7370695F73656E64	     1M      asciiz   "spi_send_two_bytes"
00:A67E 5F74776F5F627974
00:A686 6573
00:A688 00
00:A689 BFD1            	     2M      word     spi_send_two_bytes
                        	  2362:   makeAsmLibraryFunction "spi_init",             spi_init
00:A68B 7370695F696E6974	     1M      asciiz   "spi_init"
00:A693 00
00:A694 15D1            	     2M      word     spi_init
                        	  2363:   makeAsmLibraryFunction "serial_print_message", serial_print_message
00:A696 73657269616C5F70	     1M      asciiz   "serial_print_message"
00:A69E 72696E745F6D6573
00:A6A6 73616765
00:A6AA 00
00:A6AB 87C9            	     2M      word     serial_print_message
                        	  2364:   makeAsmLibraryFunction "serial_available",     serial_available
00:A6AD 73657269616C5F61	     1M      asciiz   "serial_available"
00:A6B5 7661696C61626C65
00:A6BD 00
00:A6BE 29C9            	     2M      word     serial_available
                        	  2365:   makeAsmLibraryFunction "nmi",                  RESTART
00:A6C0 6E6D69          	     1M      asciiz   "nmi"
00:A6C3 00
00:A6C4 55DA            	     2M      word     RESTART
                        	  2366:   makeAsmLibraryFunction "remain",               REMAIN
00:A6C6 72656D61696E    	     1M      asciiz   "remain"
00:A6CC 00
00:A6CD 0600            	     2M      word     REMAIN
                        	  2367:   makeAsmLibraryFunction "random",               random
00:A6CF 72616E646F6D    	     1M      asciiz   "random"
00:A6D5 00
00:A6D6 0900            	     2M      word     random
                        	  2368:   makeAsmLibraryFunction "putsp",                PUTSP
00:A6D8 7075747370      	     1M      asciiz   "putsp"
00:A6DD 00
00:A6DE D292            	     2M      word     PUTSP
                        	  2369:   makeAsmLibraryFunction "print",                print
00:A6E0 7072696E74      	     1M      asciiz   "print"
00:A6E5 00
00:A6E6 2682            	     2M      word     print
                        	  2370:   makeAsmLibraryFunction "prchar",               PRCHAR
00:A6E8 707263686172    	     1M      asciiz   "prchar"
00:A6EE 00
00:A6EF A492            	     2M      word     PRCHAR
                        	  2371:   makeAsmLibraryFunction "prbyte",               PRBYTE
00:A6F1 707262797465    	     1M      asciiz   "prbyte"
00:A6F7 00
00:A6F8 BC92            	     2M      word     PRBYTE
                        	  2372:   makeAsmLibraryFunction "pinmode",              pinmode
00:A6FA 70696E6D6F6465  	     1M      asciiz   "pinmode"
00:A701 00
00:A702 87C8            	     2M      word     pinmode
                        	  2373:   makeAsmLibraryFunction "lcd_wait",             lcd_wait
00:A704 6C63645F77616974	     1M      asciiz   "lcd_wait"
00:A70C 00
00:A70D 61B8            	     2M      word     lcd_wait
                        	  2374:   makeAsmLibraryFunction "lcd_second_line",      lcd_second_line
00:A70F 6C63645F7365636F	     1M      asciiz   "lcd_second_line"
00:A717 6E645F6C696E65
00:A71E 00
00:A71F F8B8            	     2M      word     lcd_second_line
                        	  2375:   makeAsmLibraryFunction "lcd_print_message",    lcd_print_message
00:A721 6C63645F7072696E	     1M      asciiz   "lcd_print_message"
00:A729 745F6D6573736167
00:A731 65
00:A732 00
00:A733 08B9            	     2M      word     lcd_print_message
                        	  2376:   makeAsmLibraryFunction "lcd_print_char",       lcd_print_char
00:A735 6C63645F7072696E	     1M      asciiz   "lcd_print_char"
00:A73D 745F63686172
00:A743 00
00:A744 BEB8            	     2M      word     lcd_print_char
                        	  2377:   makeAsmLibraryFunction "lcd_instruction",      lcd_instruction
00:A746 6C63645F696E7374	     1M      asciiz   "lcd_instruction"
00:A74E 72756374696F6E
00:A755 00
00:A756 9CB8            	     2M      word     lcd_instruction
                        	  2378:   makeAsmLibraryFunction "lcd_home",             lcd_home
00:A758 6C63645F686F6D65	     1M      asciiz   "lcd_home"
00:A760 00
00:A761 00B9            	     2M      word     lcd_home
                        	  2379:   makeAsmLibraryFunction "lcd_get_address",      lcd_get_address
00:A763 6C63645F6765745F	     1M      asciiz   "lcd_get_address"
00:A76B 61646472657373
00:A772 00
00:A773 7CB8            	     2M      word     lcd_get_address
                        	  2380:   makeAsmLibraryFunction "lcd_clear_display",    lcd_clear_display
00:A775 6C63645F636C6561	     1M      asciiz   "lcd_clear_display"
00:A77D 725F646973706C61
00:A785 79
00:A786 00
00:A787 F0B8            	     2M      word     lcd_clear_display
                        	  2381:   makeAsmLibraryFunction "isxdigit",             isxdigit
00:A789 6973786469676974	     1M      asciiz   "isxdigit"
00:A791 00
00:A792 3E81            	     2M      word     isxdigit
                        	  2382:   makeAsmLibraryFunction "isupper",              isupper
00:A794 69737570706572  	     1M      asciiz   "isupper"
00:A79B 00
00:A79C 0E81            	     2M      word     isupper
                        	  2383:   makeAsmLibraryFunction "isspace",              isspace
00:A79E 69737370616365  	     1M      asciiz   "isspace"
00:A7A5 00
00:A7A6 4A81            	     2M      word     isspace
                        	  2384:   makeAsmLibraryFunction "islower",              islower
00:A7A8 69736C6F776572  	     1M      asciiz   "islower"
00:A7AF 00
00:A7B0 1A81            	     2M      word     islower
                        	  2385:   makeAsmLibraryFunction "isdigit",              isdigit
00:A7B2 69736469676974  	     1M      asciiz   "isdigit"
00:A7B9 00
00:A7BA 3281            	     2M      word     isdigit
                        	  2386:   makeAsmLibraryFunction "iscntrl",              iscntrl
00:A7BC 6973636E74726C  	     1M      asciiz   "iscntrl"
00:A7C3 00
00:A7C4 5681            	     2M      word     iscntrl
                        	  2387:   makeAsmLibraryFunction "isalpha",              isalpha
00:A7C6 6973616C706861  	     1M      asciiz   "isalpha"
00:A7CD 00
00:A7CE 2681            	     2M      word     isalpha
                        	  2388:   makeAsmLibraryFunction "isalnum",              isalnum
00:A7D0 6973616C6E756D  	     1M      asciiz   "isalnum"
00:A7D7 00
00:A7D8 6281            	     2M      word     isalnum
                        	  2389:   makeAsmLibraryFunction "inbuf",                INBUF
00:A7DA 696E627566      	     1M      asciiz   "inbuf"
00:A7DF 00
00:A7E0 0002            	     2M      word     INBUF
                        	  2390:   makeAsmLibraryFunction "i2c_send",             i2c_send
00:A7E2 6932635F73656E64	     1M      asciiz   "i2c_send"
00:A7EA 00
00:A7EB BFD0            	     2M      word     i2c_send
                        	  2391:   makeAsmLibraryFunction "i2c_receive",          i2c_receive
00:A7ED 6932635F72656365	     1M      asciiz   "i2c_receive"
00:A7F5 697665
00:A7F8 00
00:A7F9 E8D0            	     2M      word     i2c_receive
                        	  2392:   makeAsmLibraryFunction "i2c_init",             i2c_init
00:A7FB 6932635F696E6974	     1M      asciiz   "i2c_init"
00:A803 00
00:A804 B9CF            	     2M      word     i2c_init
                        	  2393:   makeAsmLibraryFunction "hardware_init",        hardware_init
00:A806 6861726477617265	     1M      asciiz   "hardware_init"
00:A80E 5F696E6974
00:A813 00
00:A814 2FC9            	     2M      word     hardware_init
                        	  2394:   makeAsmLibraryFunction "getin",                GETIN
00:A816 676574696E      	     1M      asciiz   "getin"
00:A81B 00
00:A81C 18C9            	     2M      word     GETIN
                        	  2395:   makeAsmLibraryFunction "gen_random",           gen_random
00:A81E 67656E5F72616E64	     1M      asciiz   "gen_random"
00:A826 6F6D
00:A828 00
00:A829 F98F            	     2M      word     gen_random
                        	  2396:   makeAsmLibraryFunction "exp_unary_minus",      exp_unary_minus
00:A82B 6578705F756E6172	     1M      asciiz   "exp_unary_minus"
00:A833 795F6D696E7573
00:A83A 00
00:A83B 25AC            	     2M      word     exp_unary_minus
                        	  2397:   makeAsmLibraryFunction "exp_true",             exp_true
00:A83D 6578705F74727565	     1M      asciiz   "exp_true"
00:A845 00
00:A846 08AB            	     2M      word     exp_true
                        	  2398:   makeAsmLibraryFunction "exp_subtract",         exp_subtract
00:A848 6578705F73756274	     1M      asciiz   "exp_subtract"
00:A850 72616374
00:A854 00
00:A855 F2AA            	     2M      word     exp_subtract
                        	  2399:   makeAsmLibraryFunction "exp_shift_right",      exp_shift_right
00:A857 6578705F73686966	     1M      asciiz   "exp_shift_right"
00:A85F 745F7269676874
00:A866 00
00:A867 EBAB            	     2M      word     exp_shift_right
                        	  2400:   makeAsmLibraryFunction "exp_shift_left",       exp_shift_left
00:A869 6578705F73686966	     1M      asciiz   "exp_shift_left"
00:A871 745F6C656674
00:A877 00
00:A878 D2AB            	     2M      word     exp_shift_left
                        	  2401:   makeAsmLibraryFunction "exp_not",              exp_not
00:A87A 6578705F6E6F74  	     1M      asciiz   "exp_not"
00:A881 00
00:A882 17AC            	     2M      word     exp_not
                        	  2402:   makeAsmLibraryFunction "exp_neq",              exp_neq
00:A884 6578705F6E6571  	     1M      asciiz   "exp_neq"
00:A88B 00
00:A88C 2CAB            	     2M      word     exp_neq
                        	  2403:   makeAsmLibraryFunction "exp_negate",           exp_negate
00:A88E 6578705F6E656761	     1M      asciiz   "exp_negate"
00:A896 7465
00:A898 00
00:A899 04AC            	     2M      word     exp_negate
                        	  2404:   makeAsmLibraryFunction "exp_multiply",         exp_multiply
00:A89B 6578705F6D756C74	     1M      asciiz   "exp_multiply"
00:A8A3 69706C79
00:A8A7 00
00:A8A8 ACAC            	     2M      word     exp_multiply
                        	  2405:   makeAsmLibraryFunction "exp_modulo",           exp_modulo
00:A8AA 6578705F6D6F6475	     1M      asciiz   "exp_modulo"
00:A8B2 6C6F
00:A8B4 00
00:A8B5 45AD            	     2M      word     exp_modulo
                        	  2406:   makeAsmLibraryFunction "exp_low_byte",         exp_low_byte
00:A8B7 6578705F6C6F775F	     1M      asciiz   "exp_low_byte"
00:A8BF 62797465
00:A8C3 00
00:A8C4 39AC            	     2M      word     exp_low_byte
                        	  2407:   makeAsmLibraryFunction "exp_logical_or",       exp_logical_or
00:A8C6 6578705F6C6F6769	     1M      asciiz   "exp_logical_or"
00:A8CE 63616C5F6F72
00:A8D4 00
00:A8D5 B1AB            	     2M      word     exp_logical_or
                        	  2408:   makeAsmLibraryFunction "exp_logical_and",      exp_logical_and
00:A8D7 6578705F6C6F6769	     1M      asciiz   "exp_logical_and"
00:A8DF 63616C5F616E64
00:A8E6 00
00:A8E7 C0AB            	     2M      word     exp_logical_and
                        	  2409:   makeAsmLibraryFunction "exp_less_than",        exp_less_than
00:A8E9 6578705F6C657373	     1M      asciiz   "exp_less_than"
00:A8F1 5F7468616E
00:A8F6 00
00:A8F7 40AB            	     2M      word     exp_less_than
                        	  2410:   makeAsmLibraryFunction "exp_leq",              exp_leq
00:A8F9 6578705F6C6571  	     1M      asciiz   "exp_leq"
00:A900 00
00:A901 56AB            	     2M      word     exp_leq
                        	  2411:   makeAsmLibraryFunction "exp_high_byte",        exp_high_byte
00:A903 6578705F68696768	     1M      asciiz   "exp_high_byte"
00:A90B 5F62797465
00:A910 00
00:A911 3EAC            	     2M      word     exp_high_byte
                        	  2412:   makeAsmLibraryFunction "exp_greater_than",     exp_greater_than
00:A913 6578705F67726561	     1M      asciiz   "exp_greater_than"
00:A91B 7465725F7468616E
00:A923 00
00:A924 47AB            	     2M      word     exp_greater_than
                        	  2413:   makeAsmLibraryFunction "exp_geq",              exp_geq
00:A926 6578705F676571  	     1M      asciiz   "exp_geq"
00:A92D 00
00:A92E 65AB            	     2M      word     exp_geq
                        	  2414:   makeAsmLibraryFunction "exp_false",            exp_false
00:A930 6578705F66616C73	     1M      asciiz   "exp_false"
00:A938 65
00:A939 00
00:A93A 11AB            	     2M      word     exp_false
                        	  2415:   makeAsmLibraryFunction "exp_eql",              exp_eql
00:A93C 6578705F65716C  	     1M      asciiz   "exp_eql"
00:A943 00
00:A944 18AB            	     2M      word     exp_eql
                        	  2416:   makeAsmLibraryFunction "exp_divide",           exp_divide
00:A946 6578705F64697669	     1M      asciiz   "exp_divide"
00:A94E 6465
00:A950 00
00:A951 E5AC            	     2M      word     exp_divide
                        	  2417:   makeAsmLibraryFunction "exp_bitwise_xor",      exp_bitwise_xor
00:A953 6578705F62697477	     1M      asciiz   "exp_bitwise_xor"
00:A95B 6973655F786F72
00:A962 00
00:A963 96AB            	     2M      word     exp_bitwise_xor
                        	  2418:   makeAsmLibraryFunction "exp_bitwise_or",       exp_bitwise_or
00:A965 6578705F62697477	     1M      asciiz   "exp_bitwise_or"
00:A96D 6973655F6F72
00:A973 00
00:A974 6CAB            	     2M      word     exp_bitwise_or
                        	  2419:   makeAsmLibraryFunction "exp_bitwise_and",      exp_bitwise_and
00:A976 6578705F62697477	     1M      asciiz   "exp_bitwise_and"
00:A97E 6973655F616E64
00:A985 00
00:A986 81AB            	     2M      word     exp_bitwise_and
                        	  2420:   makeAsmLibraryFunction "exp_add",              exp_add
00:A988 6578705F616464  	     1M      asciiz   "exp_add"
00:A98F 00
00:A990 DEAA            	     2M      word     exp_add
                        	  2421:   makeAsmLibraryFunction "exp_abs_val",          exp_abs_val
00:A992 6578705F6162735F	     1M      asciiz   "exp_abs_val"
00:A99A 76616C
00:A99D 00
00:A99E 47AC            	     2M      word     exp_abs_val
                        	  2422:   makeAsmLibraryFunction "display_in_decimal",   display_in_decimal
00:A9A0 646973706C61795F	     1M      asciiz   "display_in_decimal"
00:A9A8 696E5F646563696D
00:A9B0 616C
00:A9B2 00
00:A9B3 7191            	     2M      word     display_in_decimal
                        	  2423:   makeAsmLibraryFunction "digitalwrite",         digitalwrite
00:A9B5 6469676974616C77	     1M      asciiz   "digitalwrite"
00:A9BD 72697465
00:A9C1 00
00:A9C2 B6C8            	     2M      word     digitalwrite
                        	  2424:   makeAsmLibraryFunction "digitalread",          digitalread
00:A9C4 6469676974616C72	     1M      asciiz   "digitalread"
00:A9CC 656164
00:A9CF 00
00:A9D0 E5C8            	     2M      word     digitalread
                        	  2425:   makeAsmLibraryFunction "dest",                 DEST
00:A9D2 64657374        	     1M      asciiz   "dest"
00:A9D6 00
00:A9D7 0300            	     2M      word     DEST
                        	  2426:   makeAsmLibraryFunction "delay",                delay
00:A9D9 64656C6179      	     1M      asciiz   "delay"
00:A9DE 00
00:A9DF F490            	     2M      word     delay
                        	  2427:   makeAsmLibraryFunction "delay_1ms",            delay_1ms
00:A9E1 64656C61795F316D	     1M      asciiz   "delay_1ms"
00:A9E9 73
00:A9EA 00
00:A9EB EA90            	     2M      word     delay_1ms
                        	  2428:   makeAsmLibraryFunction "crout",                CROUT
00:A9ED 63726F7574      	     1M      asciiz   "crout"
00:A9F2 00
00:A9F3 4792            	     2M      word     CROUT
                        	  2429:   makeAsmLibraryFunction "crc_val",              crc_val
00:A9F5 6372635F76616C  	     1M      asciiz   "crc_val"
00:A9FC 00
00:A9FD 0600            	     2M      word     crc_val
                        	  2430:   makeAsmLibraryFunction "crc_num",              crc_num
00:A9FF 6372635F6E756D  	     1M      asciiz   "crc_num"
00:AA06 00
00:AA07 0300            	     2M      word     crc_num
                        	  2431:   makeAsmLibraryFunction "crc_byte",             crc_byte
00:AA09 6372635F62797465	     1M      asciiz   "crc_byte"
00:AA11 00
00:AA12 4490            	     2M      word     crc_byte
                        	  2432:   makeAsmLibraryFunction "crc_addr",             crc_addr
00:AA14 6372635F61646472	     1M      asciiz   "crc_addr"
00:AA1C 00
00:AA1D 0000            	     2M      word     crc_addr
                        	  2433:   makeAsmLibraryFunction "crc16",                crc16
00:AA1F 6372633136      	     1M      asciiz   "crc16"
00:AA24 00
00:AA25 1C90            	     2M      word     crc16
                        	  2434:   .if USE_CP437_FONT
                        	  2435:   makeAsmLibraryFunction "cp437_font",           cp437_font
00:AA27 63703433375F666F	     1M      asciiz   "cp437_font"
00:AA2F 6E74
00:AA31 00
00:AA32 CFD1            	     2M      word     cp437_font
                        	  2436:   .endif
                        	  2437:   makeAsmLibraryFunction "cout",                 COUT
00:AA34 636F7574        	     1M      asciiz   "cout"
00:AA38 00
00:AA39 CE93            	     2M      word     COUT
                        	  2438:   makeAsmLibraryFunction "comstl",               COMSTL
00:AA3B 636F6D73746C    	     1M      asciiz   "comstl"
00:AA41 00
00:AA42 4C92            	     2M      word     COMSTL
                        	  2439:   makeAsmLibraryFunction "call_y",               call_y
00:AA44 63616C6C5F79    	     1M      asciiz   "call_y"
00:AA4A 00
00:AA4B 1200            	     2M      word     call_y
                        	  2440:   makeAsmLibraryFunction "call_x",               call_x
00:AA4D 63616C6C5F78    	     1M      asciiz   "call_x"
00:AA53 00
00:AA54 1100            	     2M      word     call_x
                        	  2441:   makeAsmLibraryFunction "call_s",               call_s
00:AA56 63616C6C5F73    	     1M      asciiz   "call_s"
00:AA5C 00
00:AA5D 1400            	     2M      word     call_s
                        	  2442:   makeAsmLibraryFunction "call_p",               call_p
00:AA5F 63616C6C5F70    	     1M      asciiz   "call_p"
00:AA65 00
00:AA66 1300            	     2M      word     call_p
                        	  2443:   makeAsmLibraryFunction "call_a",               call_a
00:AA68 63616C6C5F61    	     1M      asciiz   "call_a"
00:AA6E 00
00:AA6F 1000            	     2M      word     call_a
                        	  2444:   makeAsmLibraryFunction "binary_to_decimal",    binary_to_decimal
00:AA71 62696E6172795F74	     1M      asciiz   "binary_to_decimal"
00:AA79 6F5F646563696D61
00:AA81 6C
00:AA82 00
00:AA83 9A91            	     2M      word     binary_to_decimal
                        	  2445:   makeAsmLibraryFunction "bcd_result",           bcd_result
00:AA85 6263645F72657375	     1M      asciiz   "bcd_result"
00:AA8D 6C74
00:AA8F 00
00:AA90 6000            	     2M      word     bcd_result
                        	  2446: 
00:AA92 00              	  2447:   dfb 0   ; end of table
                        	  2448: 
                        	  2449: 
                        	  2450: add_assembler_library_functions:
00:AA93 A9D3            	  2451:   lda #<assembler_library_functions_table
00:AA95 8500            	  2452:   sta REG
00:AA97 A9A5            	  2453:   lda #>assembler_library_functions_table
00:AA99 8501            	  2454:   sta REG+1
                        	  2455: add_assembler_library_functions_loop:
00:AA9B A000            	  2456:   ldy #0
00:AA9D B100            	  2457:   lda (REG),Y
00:AA9F F03C            	  2458:   beq add_assembler_library_functions_done
00:AAA1 A500            	  2459:   lda REG
00:AAA3 8590            	  2460:   sta token_address
00:AAA5 A501            	  2461:   lda REG+1
00:AAA7 8591            	  2462:   sta token_address+1
00:AAA9 6492            	  2463:   stz token_length
                        	  2464: ;
                        	  2465: ;  find name length
                        	  2466: ;
                        	  2467: add_assembler_library_functions_name_loop
00:AAAB C8              	  2468:   iny
00:AAAC E692            	  2469:   inc token_length
00:AAAE B100            	  2470:   lda (REG),Y
00:AAB0 D0F9            	  2471:   bne add_assembler_library_functions_name_loop
00:AAB2 5A              	  2472:   phy
00:AAB3 203FBA          	  2473:   jsr CHKDUP
00:AAB6 A943            	  2474:   lda #SYMBOL_CONSTANT  ; add the symbol as a constant for now
00:AAB8 2098B9          	  2475:   jsr ADDSYM
00:AABB 7A              	  2476:   ply
                        	  2477: 
00:AABC C8              	  2478:   iny             ; get next byte
00:AABD B100            	  2479:   lda (REG),Y     ; get function address low-byte
00:AABF 5A              	  2480:   phy
00:AAC0 A004            	  2481:   ldy #SYMDSP
00:AAC2 9140            	  2482:   sta (SYMITM),Y  ; save function address low-byte
00:AAC4 7A              	  2483:   ply
                        	  2484: 
00:AAC5 C8              	  2485:   iny             ; get next byte
00:AAC6 B100            	  2486:   lda (REG),Y     ; get function address high-byte
00:AAC8 5A              	  2487:   phy
00:AAC9 A005            	  2488:   ldy #SYMDSP+1
00:AACB 9140            	  2489:   sta (SYMITM),Y  ; save function address high-byte
00:AACD 7A              	  2490:   ply
                        	  2491: 
00:AACE C8              	  2492:   iny         ; get past that last byte
00:AACF 98              	  2493:   tya         ; move REG onto next entry
00:AAD0 18              	  2494:   clc
00:AAD1 6500            	  2495:   adc REG
00:AAD3 8500            	  2496:   sta REG
00:AAD5 A900            	  2497:   lda #0
00:AAD7 6501            	  2498:   adc REG+1
00:AAD9 8501            	  2499:   sta REG+1
00:AADB 80BE            	  2500:   bra add_assembler_library_functions_loop
                        	  2501: 
                        	  2502: add_assembler_library_functions_done:
00:AADD 60              	  2503:   rts
                        	  2504: 

Source: "gpascal.asm"
                        	   180:   .include "math.inc"

Source: "math.inc"
                        	     1: ;--------------------------------------------------
                        	     2: ; Maths routines. 3-byte operations on VALUE and VALUE2
                        	     3: ;
                        	     4: ;--------------------------------------------------
                        	     5: exp_add:
00:AADE 18              	     6:   clc
00:AADF A500            	     7:   lda VALUE
00:AAE1 6503            	     8:   adc VALUE2
00:AAE3 8500            	     9:   sta VALUE
00:AAE5 A501            	    10:   lda VALUE+1
00:AAE7 6504            	    11:   adc VALUE2+1
00:AAE9 8501            	    12:   sta VALUE+1
00:AAEB A502            	    13:   lda VALUE+2
00:AAED 6505            	    14:   adc VALUE2+2
00:AAEF 8502            	    15:   sta VALUE+2
00:AAF1 60              	    16:   rts
                        	    17: 
                        	    18: ;
                        	    19: ;  subtract VALUE2 from VALUE, store in VALUE, also set the sign bit
                        	    20: ;   and put the low order two bytes in X and Y
                        	    21: ;
                        	    22: exp_subtract:
00:AAF2 38              	    23:   sec
00:AAF3 A500            	    24:   lda VALUE
00:AAF5 E503            	    25:   sbc VALUE2
00:AAF7 8500            	    26:   sta VALUE
00:AAF9 A8              	    27:   tay
00:AAFA A501            	    28:   lda VALUE+1
00:AAFC E504            	    29:   sbc VALUE2+1
00:AAFE AA              	    30:   tax
00:AAFF 8501            	    31:   sta VALUE+1
00:AB01 A502            	    32:   lda VALUE+2
00:AB03 E505            	    33:   sbc VALUE2+2
00:AB05 8502            	    34:   sta VALUE+2
00:AB07 60              	    35:   rts
                        	    36: 
                        	    37: exp_true:
00:AB08 A901            	    38:   lda #1
00:AB0A 8500            	    39:   sta VALUE
00:AB0C 6401            	    40:   stz VALUE+1
00:AB0E 6402            	    41:   stz VALUE+2
00:AB10 60              	    42:   rts
                        	    43: 
                        	    44: exp_false:
00:AB11 6400            	    45:   stz VALUE
00:AB13 6401            	    46:   stz VALUE+1
00:AB15 6402            	    47:   stz VALUE+2
00:AB17 60              	    48:   rts
                        	    49: 
                        	    50: exp_eql:
00:AB18 A500            	    51:   lda VALUE
00:AB1A C503            	    52:   cmp VALUE2
00:AB1C D0F3            	    53:   bne exp_false
00:AB1E A501            	    54:   lda VALUE+1
00:AB20 C504            	    55:   cmp VALUE2+1
00:AB22 D0ED            	    56:   bne exp_false
00:AB24 A502            	    57:   lda VALUE+2
00:AB26 C505            	    58:   cmp VALUE2+2
00:AB28 D0E7            	    59:   bne exp_false
00:AB2A 80DC            	    60:   bra exp_true
                        	    61: 
                        	    62: exp_neq:
00:AB2C A500            	    63:   lda VALUE
00:AB2E C503            	    64:   cmp VALUE2
00:AB30 D0D6            	    65:   bne exp_true
00:AB32 A501            	    66:   lda VALUE+1
00:AB34 C504            	    67:   cmp VALUE2+1
00:AB36 D0D0            	    68:   bne exp_true
00:AB38 A502            	    69:   lda VALUE+2
00:AB3A C505            	    70:   cmp VALUE2+2
00:AB3C D0CA            	    71:   bne exp_true
00:AB3E 80D1            	    72:   bra exp_false
                        	    73: 
                        	    74: exp_less_than:
00:AB40 20F2AA          	    75:   jsr exp_subtract
00:AB43 30C3            	    76:   bmi exp_true
00:AB45 10CA            	    77:   bpl exp_false
                        	    78: 
                        	    79: exp_greater_than:
00:AB47 20F2AA          	    80:   jsr exp_subtract
00:AB4A 30C5            	    81:   bmi exp_false
00:AB4C D0BA            	    82:   bne exp_true
00:AB4E 98              	    83:   tya
00:AB4F D0B7            	    84:   bne exp_true
00:AB51 8A              	    85:   txa
00:AB52 D0B4            	    86:   bne exp_true
00:AB54 10BB            	    87:   bpl exp_false
                        	    88: 
                        	    89: exp_leq:
00:AB56 20F2AA          	    90:   jsr exp_subtract
00:AB59 30AD            	    91:   bmi exp_true
00:AB5B D0B4            	    92:   bne exp_false
00:AB5D 98              	    93:   tya
00:AB5E D0B1            	    94:   bne exp_false
00:AB60 8A              	    95:   txa
00:AB61 D0AE            	    96:   bne exp_false
00:AB63 10A3            	    97:   bpl exp_true
                        	    98: 
                        	    99: exp_geq:
00:AB65 20F2AA          	   100:   jsr exp_subtract
00:AB68 30A7            	   101:   bmi exp_false
00:AB6A 109C            	   102:   bpl exp_true
                        	   103: 
                        	   104: exp_bitwise_or:
00:AB6C A500            	   105:   lda VALUE
00:AB6E 0503            	   106:   ora VALUE2
00:AB70 8500            	   107:   sta VALUE
00:AB72 A8              	   108:   tay
00:AB73 A501            	   109:   lda VALUE+1
00:AB75 0504            	   110:   ora VALUE2+1
00:AB77 8501            	   111:   sta VALUE+1
00:AB79 AA              	   112:   tax
00:AB7A A502            	   113:   lda VALUE+2
00:AB7C 0505            	   114:   ora VALUE2+2
00:AB7E 8502            	   115:   sta VALUE+2
00:AB80 60              	   116:   rts
                        	   117: 
                        	   118: exp_bitwise_and:
00:AB81 A500            	   119:   lda VALUE
00:AB83 2503            	   120:   and VALUE2
00:AB85 8500            	   121:   sta VALUE
00:AB87 A8              	   122:   tay
00:AB88 A501            	   123:   lda VALUE+1
00:AB8A 2504            	   124:   and VALUE2+1
00:AB8C 8501            	   125:   sta VALUE+1
00:AB8E AA              	   126:   tax
00:AB8F A502            	   127:   lda VALUE+2
00:AB91 2505            	   128:   and VALUE2+2
00:AB93 8502            	   129:   sta VALUE+2
00:AB95 60              	   130:   rts
                        	   131: 
                        	   132: exp_bitwise_xor:
00:AB96 A500            	   133:   lda VALUE
00:AB98 4503            	   134:   eor VALUE2
00:AB9A 8500            	   135:   sta VALUE
00:AB9C A8              	   136:   tay
00:AB9D A501            	   137:   lda VALUE+1
00:AB9F 4504            	   138:   eor VALUE2+1
00:ABA1 8501            	   139:   sta VALUE+1
00:ABA3 AA              	   140:   tax
00:ABA4 A502            	   141:   lda VALUE+2
00:ABA6 4505            	   142:   eor VALUE2+2
00:ABA8 8502            	   143:   sta VALUE+2
00:ABAA 60              	   144:   rts
                        	   145: 
                        	   146: 
00:ABAB 4C08AB          	   147: exp_trueJ jmp exp_true
00:ABAE 4C11AB          	   148: exp_falseJ jmp exp_false
                        	   149: 
                        	   150: exp_logical_or:
00:ABB1 206CAB          	   151:   jsr exp_bitwise_or
00:ABB4 D0F5            	   152:   bne exp_trueJ
00:ABB6 E000            	   153:   cpx #0
00:ABB8 D0F1            	   154:   bne exp_trueJ
00:ABBA C000            	   155:   cpy #0
00:ABBC D0ED            	   156:   bne exp_trueJ
00:ABBE 80EE            	   157:   bra exp_falseJ
                        	   158: 
                        	   159: exp_logical_and:
00:ABC0 A500            	   160:   lda VALUE
00:ABC2 0501            	   161:   ora VALUE+1
00:ABC4 0502            	   162:   ora VALUE+2
00:ABC6 F0E6            	   163:   beq exp_falseJ  ; if VALUE has all bits zero the logical "and" must be false
                        	   164: ;
                        	   165: ;  VALUE is non-zero, how about VALUE2?
                        	   166: ;
00:ABC8 A503            	   167:   lda VALUE2
00:ABCA 0504            	   168:   ora VALUE2+1
00:ABCC 0505            	   169:   ora VALUE2+2
00:ABCE F0DE            	   170:   beq exp_falseJ  ; if VALUE2 has all bits zero the logical "and" must be false
00:ABD0 80D9            	   171:   bra exp_trueJ   ; both are non-zero, therefore the result is true
                        	   172: 
                        	   173: exp_shift_left:
00:ABD2 A504            	   174:   lda VALUE2+1
00:ABD4 0505            	   175:   ora VALUE2+2
00:ABD6 D0D6            	   176:   bne exp_falseJ  ; big shifts will return zero
00:ABD8 A503            	   177:   lda VALUE2
00:ABDA F00E            	   178:   beq exp_shift_left_done ; shift by zero? we are done then
00:ABDC AA              	   179:   tax
00:ABDD 29E0            	   180:   and #$E0        ; maximum of 32 shifts
00:ABDF D0CD            	   181:   bne exp_falseJ
                        	   182: exp_shift_left_loop:
00:ABE1 0600            	   183:   asl VALUE
00:ABE3 2601            	   184:   rol VALUE+1
00:ABE5 2602            	   185:   rol VALUE+2
00:ABE7 CA              	   186:   dex
00:ABE8 D0F7            	   187:   bne exp_shift_left_loop
                        	   188: exp_shift_left_done:
00:ABEA 60              	   189:   rts
                        	   190: 
                        	   191: exp_shift_right:
00:ABEB A504            	   192:   lda VALUE2+1
00:ABED 0505            	   193:   ora VALUE2+2
00:ABEF D0BD            	   194:   bne exp_falseJ  ; big shifts will return zero
00:ABF1 A503            	   195:   lda VALUE2
00:ABF3 F00E            	   196:   beq exp_shift_right_done ; shift by zero? we are done then
00:ABF5 AA              	   197:   tax
00:ABF6 29E0            	   198:   and #$E0        ; maximum of 32 shifts
00:ABF8 D0B4            	   199:   bne exp_falseJ
                        	   200: exp_shift_right_loop:
00:ABFA 4602            	   201:   lsr VALUE+2
00:ABFC 6601            	   202:   ror VALUE+1
00:ABFE 6600            	   203:   ror VALUE
00:AC00 CA              	   204:   dex
00:AC01 D0F7            	   205:   bne exp_shift_right_loop
                        	   206: exp_shift_right_done:
00:AC03 60              	   207:   rts
                        	   208: 
                        	   209: exp_negate:
00:AC04 A500            	   210:   lda VALUE
00:AC06 49FF            	   211:   eor #$FF
00:AC08 8500            	   212:   sta VALUE
00:AC0A A501            	   213:   lda VALUE+1
00:AC0C 49FF            	   214:   eor #$FF
00:AC0E 8501            	   215:   sta VALUE+1
00:AC10 A502            	   216:   lda VALUE+2
00:AC12 49FF            	   217:   eor #$FF
00:AC14 8502            	   218:   sta VALUE+2
00:AC16 60              	   219:   rts
                        	   220: 
                        	   221: exp_not:
00:AC17 A500            	   222:   lda VALUE
00:AC19 D093            	   223:   bne exp_falseJ
00:AC1B A501            	   224:   lda VALUE+1
00:AC1D D08F            	   225:   bne exp_falseJ
00:AC1F A502            	   226:   lda VALUE+2
00:AC21 D08B            	   227:   bne exp_falseJ
00:AC23 8086            	   228:   bra exp_trueJ
                        	   229: 
                        	   230: exp_unary_minus:
00:AC25 38              	   231:   sec
00:AC26 A900            	   232:   lda #0
00:AC28 E500            	   233:   sbc VALUE
00:AC2A 8500            	   234:   sta VALUE
00:AC2C A900            	   235:   lda #0
00:AC2E E501            	   236:   sbc VALUE+1
00:AC30 8501            	   237:   sta VALUE+1
00:AC32 A900            	   238:   lda #0
00:AC34 E502            	   239:   sbc VALUE+2
00:AC36 8502            	   240:   sta VALUE+2
00:AC38 60              	   241:   rts
                        	   242: 
                        	   243: 
                        	   244: exp_low_byte:
00:AC39 6401            	   245:   stz VALUE+1
00:AC3B 6402            	   246:   stz VALUE+2
00:AC3D 60              	   247:   rts
                        	   248: 
                        	   249: exp_high_byte:
00:AC3E A501            	   250:   lda VALUE+1
00:AC40 8500            	   251:   sta VALUE
00:AC42 6401            	   252:   stz VALUE+1
00:AC44 6402            	   253:   stz VALUE+2
00:AC46 60              	   254:   rts
                        	   255: 
                        	   256: ;
                        	   257: ;  make VALUE positive
                        	   258: ;
                        	   259: exp_abs_val:
00:AC47 A502            	   260:   lda  VALUE+2  ; check high-order byte, see if negative
00:AC49 1013            	   261:   bpl  exp_abs_val_done
                        	   262: exp_negate_val:
00:AC4B 38              	   263:   sec
00:AC4C A900            	   264:   lda  #0
00:AC4E E500            	   265:   sbc  VALUE
00:AC50 8500            	   266:   sta  VALUE
00:AC52 A900            	   267:   lda  #0
00:AC54 E501            	   268:   sbc  VALUE+1
00:AC56 8501            	   269:   sta  VALUE+1
00:AC58 A900            	   270:   lda  #0
00:AC5A E502            	   271:   sbc  VALUE+2
00:AC5C 8502            	   272:   sta  VALUE+2
                        	   273: exp_abs_val_done:
00:AC5E 60              	   274:   rts
                        	   275: 
                        	   276: ;
                        	   277: ;  make VALUE2 positive
                        	   278: ;
                        	   279: exp_abs_val2:
00:AC5F A505            	   280:   lda  VALUE2+2  ; check high-order byte, see if negative
00:AC61 1013            	   281:   bpl  exp_abs_val2_done
                        	   282: exp_negate_val2:
00:AC63 38              	   283:   sec
00:AC64 A900            	   284:   lda  #0
00:AC66 E503            	   285:   sbc  VALUE2
00:AC68 8503            	   286:   sta  VALUE2
00:AC6A A900            	   287:   lda  #0
00:AC6C E504            	   288:   sbc  VALUE2+1
00:AC6E 8504            	   289:   sta  VALUE2+1
00:AC70 A900            	   290:   lda  #0
00:AC72 E505            	   291:   sbc  VALUE2+2
00:AC74 8505            	   292:   sta  VALUE2+2
                        	   293: exp_abs_val2_done:
00:AC76 60              	   294:   rts
                        	   295: 
                        	   296: 
                        	   297: ZERRES:
00:AC77 A900            	   298:   lda  #0
00:AC79 8552            	   299:   sta  RES
00:AC7B 8553            	   300:   sta  RES+1
00:AC7D 8554            	   301:   sta  RES+2
00:AC7F 60              	   302:   rts
                        	   303: 
                        	   304: exp_find_sign:
00:AC80 2077AC          	   305:    jsr  ZERRES     ; zero result
00:AC83 A502            	   306:    lda  VALUE+2
00:AC85 2980            	   307:    and  #$80
00:AC87 855B            	   308:    sta  RMNDR
00:AC89 A505            	   309:    lda  VALUE2+2
00:AC8B 2980            	   310:    and  #$80
00:AC8D 455B            	   311:    eor  RMNDR
00:AC8F 855B            	   312:    sta  RMNDR     ; RMNDR is 0x80 if the result needs to be negative
00:AC91 2047AC          	   313:    jsr  exp_abs_val
00:AC94 205FAC          	   314:    jsr  exp_abs_val2
00:AC97 60              	   315:    rts
                        	   316: ;
                        	   317: 
                        	   318: exp_fix_sign:
00:AC98 A55B            	   319:   lda  RMNDR
00:AC9A 100F            	   320:   bpl  exp_fix_sign_done      ; nothing needs to be changed
00:AC9C 38              	   321:   sec                         ; subtract result from zero
00:AC9D A900            	   322:   lda  #0
00:AC9F E552            	   323:   sbc  RES
00:ACA1 AA              	   324:   tax
00:ACA2 A900            	   325:   lda  #0
00:ACA4 E553            	   326:   sbc  RES+1
00:ACA6 A8              	   327:   tay
00:ACA7 A900            	   328:   lda  #0
00:ACA9 E554            	   329:   sbc  RES+2
                        	   330: exp_fix_sign_done:
00:ACAB 60              	   331:   rts
                        	   332: 
                        	   333: 
                        	   334: ;
                        	   335: ;  multiply VALUE1 by VALUE2 and store in VALUE
                        	   336: ;
                        	   337: ;  see: https://llx.com/Neil/a2/mult.html for a discussion
                        	   338: ;
                        	   339: 
                        	   340: exp_multiply:
00:ACAC 2080AC          	   341:   jsr exp_find_sign
00:ACAF A218            	   342:   ldx  #24       ; for all 24 bits
                        	   343: exp_multiply_loop:
00:ACB1 0652            	   344:   asl  RES
00:ACB3 2653            	   345:   rol  RES+1
00:ACB5 2654            	   346:   rol  RES+2                    ; shift RES left one bit
00:ACB7 0600            	   347:   asl  VALUE
00:ACB9 2601            	   348:   rol  VALUE+1
00:ACBB 2602            	   349:   rol  VALUE+2                  ; shift one argument left one bit and get the low-order bit into carry
00:ACBD 9013            	   350:   bcc  exp_multiply_no_add      ; if no low-order bit, don't add anything
00:ACBF 18              	   351:   clc                           ; add the other argument to the result
00:ACC0 A503            	   352:   lda  VALUE2
00:ACC2 6552            	   353:   adc  RES
00:ACC4 8552            	   354:   sta  RES
00:ACC6 A504            	   355:   lda  VALUE2+1
00:ACC8 6553            	   356:   adc  RES+1
00:ACCA 8553            	   357:   sta  RES+1
00:ACCC A505            	   358:   lda  VALUE2+2
00:ACCE 6554            	   359:   adc  RES+2
00:ACD0 8554            	   360:   sta  RES+2
                        	   361: exp_multiply_no_add:
00:ACD2 CA              	   362:   dex                      ; count bits
00:ACD3 D0DC            	   363:   bne  exp_multiply_loop   ; go back if more to go
00:ACD5 2098AC          	   364:   jsr  exp_fix_sign
00:ACD8 A552            	   365:   lda  RES
00:ACDA 8500            	   366:   sta  VALUE
00:ACDC A553            	   367:   lda  RES+1
00:ACDE 8501            	   368:   sta  VALUE+1
00:ACE0 A554            	   369:   lda  RES+2
00:ACE2 8502            	   370:   sta  VALUE+2
00:ACE4 60              	   371:   rts
                        	   372: 
                        	   373: ;
                        	   374: ;  divide VALUE by VALUE2, store result in VALUE
                        	   375: ;
                        	   376: exp_divide:
00:ACE5 2080AC          	   377:   jsr exp_find_sign
                        	   378: 
00:ACE8 A503            	   379:   lda  VALUE2
00:ACEA 0504            	   380:   ora  VALUE2+1
00:ACEC 0505            	   381:   ora  VALUE2+2
00:ACEE D005            	   382:   bne  exp_divide_not_zero  ; check not dividing by zero
00:ACF0 A22F            	   383:   ldx  #47                  ; ERROR: divide by zero
00:ACF2 4CC39E          	   384:   jmp  ass_error
                        	   385:   ;
                        	   386: exp_divide_not_zero:
00:ACF5 2077AC          	   387:   jsr  ZERRES     ; zero result (RES) - leaves zero in A register
00:ACF8 8506            	   388:   sta  REMAIN
00:ACFA 8507            	   389:   sta  REMAIN+1
00:ACFC 8508            	   390:   sta  REMAIN+2
00:ACFE A918            	   391:   lda  #24       ; for all 24 bits of the operands ...
00:AD00 858D            	   392:   sta  maths_work
                        	   393: exp_divide_loop:
00:AD02 0600            	   394:   asl  VALUE
00:AD04 2601            	   395:   rol  VALUE+1
00:AD06 2602            	   396:   rol  VALUE+2    ; shift the dividend left one bit
00:AD08 2606            	   397:   rol  REMAIN    ; the low-order bit of the dividend is shifted into the remainder
00:AD0A 2607            	   398:   rol  REMAIN+1
00:AD0C 2608            	   399:   rol  REMAIN+2
00:AD0E 38              	   400:   sec
00:AD0F A506            	   401:   lda  REMAIN    ; do a trial subtraction of: remainder - divisor
00:AD11 E503            	   402:   sbc  VALUE2
00:AD13 AA              	   403:   tax
00:AD14 A507            	   404:   lda  REMAIN+1
00:AD16 E504            	   405:   sbc  VALUE2+1
00:AD18 A8              	   406:   tay
00:AD19 A508            	   407:   lda  REMAIN+2
00:AD1B E505            	   408:   sbc  VALUE2+2
00:AD1D 300B            	   409:   bmi  exp_divide_subtraction_negative      ; if the subtraction fails (is negative) then discard the result
00:AD1F 8508            	   410:   sta  REMAIN+2  ; if it succeeds then the result of the subtraction is our new remainder
00:AD21 98              	   411:   tya
00:AD22 8507            	   412:   sta  REMAIN+1
00:AD24 8A              	   413:   txa
00:AD25 8506            	   414:   sta  REMAIN
00:AD27 38              	   415:   sec            ; shift a one-bit into the quotient
00:AD28 B001            	   416:   bcs  exp_divide_subtraction_positive
                        	   417: exp_divide_subtraction_negative:
00:AD2A 18              	   418:   clc            ; here if subtraction failed, quotient (RES) gets a 0-bit shifted in
                        	   419: exp_divide_subtraction_positive:
00:AD2B 2652            	   420:   rol  RES       ; the carry bit (from above) is shifted into the quotient
00:AD2D 2653            	   421:   rol  RES+1
00:AD2F 2654            	   422:   rol  RES+2
00:AD31 C68D            	   423:   dec  maths_work      ; one less bit to go
00:AD33 D0CD            	   424:   bne  exp_divide_loop      ; repeat until 24 bits done
00:AD35 2098AC          	   425:   jsr  exp_fix_sign
00:AD38 A552            	   426:   lda  RES
00:AD3A 8500            	   427:   sta  VALUE
00:AD3C A553            	   428:   lda  RES+1
00:AD3E 8501            	   429:   sta  VALUE+1
00:AD40 A554            	   430:   lda  RES+2
00:AD42 8502            	   431:   sta  VALUE+2
00:AD44 60              	   432:   rts
                        	   433: 
                        	   434: exp_modulo:
00:AD45 20E5AC          	   435:   jsr exp_divide
00:AD48 A506            	   436:   lda REMAIN
00:AD4A 8500            	   437:   sta VALUE
00:AD4C A507            	   438:   lda REMAIN+1
00:AD4E 8501            	   439:   sta VALUE+1
00:AD50 A508            	   440:   lda REMAIN+2
00:AD52 8502            	   441:   sta VALUE+2
00:AD54 60              	   442:   rts
                        	   443: 

Source: "gpascal.asm"
                        	   181:   .include "interpreter.inc"

Source: "interpreter.inc"
                        	     1: ;--------------------------------------------------
                        	     2: ; Runtime P-code interpreter
                        	     3: ;
                        	     4: ;--------------------------------------------------
                        	     5: 
                        	     6: 
                        	     7: ;--------------------------------
                        	     8: ; P-codes - these are generated in the compilation phase and looked up
                        	     9: ;           in execution_address_table at runtime
                        	    10: ;
                        	    11: ; Note: some P-codes must appear in sequence, eg. PCODE_STO and PCODE_STOC
                        	    12: ;       That is because one refers to integers (STO) and one refers to characters (STOC)
                        	    13: ;       The code in various places is virtually identical except it adds 1 to the P-code
                        	    14: ;       for characters. These generally are the Load/Store operations.
                        	    15: ;--------------------------------
                        	    16: 
                        	    17: ; Not implemented yet: $05, $13, $15, $39
                        	    18: 
                        	    19: ;                 Code            Description                         Arguments
                        	    20: ;                 ----            -----------------------------       -----------------------
                        	    21: PCODE_LIT     =   $00 ; Dec:  0 - Load constant                     - 3-byte literal (number)
                        	    22: PCODE_STACK   =   $01 ; Dec:  1 - Alter runtime stack to address    - 2-byte stack address
                        	    23: PCODE_NEG     =   $02 ; Dec:  2 - Unary minus 0 - (sp)              - none
                        	    24: PCODE_LIB_CALL =  $03 ; Dec:  3 - Call library function/procedure   - absolute address
                        	    25: PCODE_ADD     =   $04 ; Dec:  4 - Add (sp) to (sp - 1)              - none
                        	    26: PCODE_SUB     =   $06 ; Dec:  6 - Subtract (sp) from (sp - 1)       - none
                        	    27: PCODE_MUL     =   $08 ; Dec:  8 - Multiply (sp) * (sp - 1)          - none
                        	    28: PCODE_DIV     =   $0A ; Dec: 10 - Divide (sp - 1) / (sp)            - none
                        	    29: PCODE_MOD     =   $0B ; Dec: 11 - Modulus (sp - 1) MOD (sp)         - none
                        	    30: PCODE_ADRNN   =   $0C ; Dec: 12 - Address of integer                - level, displ
                        	    31: PCODE_ADRNC   =   $0D ; Dec: 13 - Address of character              - level, displ
                        	    32: PCODE_ADRAN   =   $0E ; Dec: 14 - Address of integer array          - level, displ
                        	    33: PCODE_ADRAC   =   $0F ; Dec: 15 - Address of character array        - level, displ
                        	    34: PCODE_EQL     =   $10 ; Dec: 16 - Test (sp - 1) == (sp)             - none
                        	    35: PCODE_FINISHD =   $11 ; Dec: 17 - Stop run (end program)            - none
                        	    36: PCODE_NEQ     =   $12 ; Dec: 18 - Test (sp - 1) != (sp)             - none
                        	    37: PCODE_LSS     =   $14 ; Dec: 20 - Test (sp - 1) < (sp)              - none
                        	    38: PCODE_GEQ     =   $16 ; Dec: 22 - Test (sp - 1) >= (sp)             - none
                        	    39: PCODE_GTR     =   $18 ; Dec: 24 - Test (sp - 1) > (sp)              - none
                        	    40: PCODE_LEQ     =   $19 ; Dec: 25 - Test (sp - 1) <= (sp)             - none
                        	    41: PCODE_ORR     =   $1A ; Dec: 26 - OR  (sp - 1) | (sp)               - none
                        	    42: PCODE_AND     =   $1B ; Dec: 27 - AND (sp - 1) & (sp)               - none
                        	    43: PCODE_INP     =   $1C ; Dec: 28 - Input number                      - none
                        	    44: PCODE_INPC    =   $1D ; Dec: 29 - Input character                   - none
                        	    45: PCODE_OUT     =   $1E ; Dec: 30 - Output number                     - none
                        	    46: PCODE_OUTC    =   $1F ; Dec: 31 - Output character                  - none
                        	    47: PCODE_EOR     =   $20 ; Dec: 32 - Not (sp) (logical negate)         - none
                        	    48: PCODE_OUH     =   $21 ; Dec: 33 - Output hex number                 - none
                        	    49: PCODE_SHL     =   $22 ; Dec: 34 - Shift left (sp) bits              - none
                        	    50: PCODE_OUS     =   $23 ; Dec: 35 - Output string                     - length, string
                        	    51: PCODE_SHR     =   $24 ; Dec: 36 - Shift right (sp) bits             - none
                        	    52: PCODE_INS     =   $25 ; Dec: 37 - Input string into array           - max, level, displ
                        	    53: PCODE_INC     =   $26 ; Dec: 38 - Increment (sp) by 1               - none
                        	    54: PCODE_CLL     =   $27 ; Dec: 39 - Relative procedure/function call  - level, relative address
                        	    55: PCODE_DEC     =   $28 ; Dec: 40 - Decrement (sp) by 1               - none
                        	    56: PCODE_RTN     =   $29 ; Dec: 41 - Procedure/function return         - none
                        	    57: PCODE_MOV     =   $2A ; Dec: 42 - Copy (sp) to (sp + 1)             - none
                        	    58: PCODE_CLA     =   $2B ; Dec: 43 - Call absolute address             - none
                        	    59: PCODE_LOD     =   $2C ; Dec: 44 - Load integer onto stack           - level, displ
                        	    60: PCODE_LODC    =   $2D ; Dec: 45 - Load character onto stack         - level, displ
                        	    61: PCODE_LDA     =   $2E ; Dec: 46 - Load absolute address integer     - none
                        	    62: PCODE_LDAC    =   $2F ; Dec: 47 - Load absolute address character   - none
                        	    63: PCODE_LDI     =   $30 ; Dec: 48 - Load integer indexed              - level, displ
                        	    64: PCODE_LDIC    =   $31 ; Dec: 49 - Load character indexed            - level, displ
                        	    65: PCODE_STO     =   $32 ; Dec: 50 - Store integer                     - level, displ
                        	    66: PCODE_STOC    =   $33 ; Dec: 51 - Store character                   - level, displ
                        	    67: PCODE_STA     =   $34 ; Dec: 52 - Store integer absolute address    - none
                        	    68: PCODE_STAC    =   $35 ; Dec: 53 - Store character absolute address  - none
                        	    69: PCODE_STI     =   $36 ; Dec: 54 - Store integer indexed             - level, displ
                        	    70: PCODE_STIC    =   $37 ; Dec: 55 - Store character indexed           - level, displ
                        	    71: PCODE_ABSCLL  =   $38 ; Dec: 56 - Absolute procedure/function call  - level, absolute address
                        	    72: PCODE_XOR     =   $3A ; Dec: 58 - XOR (sp - 1) ^ (sp)               - none
                        	    73: PCODE_INT     =   $3B ; Dec: 59 - Increment stack pointer           - increment
                        	    74: PCODE_JMP     =   $3C ; Dec: 60 - Jump unconditionally              - relative address
                        	    75: PCODE_JMZ     =   $3D ; Dec: 61 - Jump if (sp) zero                 - relative address
                        	    76: PCODE_JM1     =   $3E ; Dec: 62 - Jump if (sp) not zero             - relative address
                        	    77: PCODE_OUTCR   =   $40 ; Dec: 64 - Output a carriage-return          - none
                        	    78: PCODE_LCD_WRITE_NUM = $42 ; Dec: 66 - Write number to LCD           - none
                        	    79: PCODE_LCD_WRITE_STR = $43 ; Dec: 67 - Write string to LCD           - none
                        	    80: PCODE_LCD_WRITE_HEX = $44 ; Dec: 68 - Write hex number to LCD       - none
                        	    81: PCODE_LCD_WRITE_CHR = $45 ; Dec: 69 - Write character to LCD        - none
                        	    82: 
                        	    83: PCODE_LAST    =   PCODE_LCD_WRITE_CHR  ; PUT THIS LAST! (error check)                  -
                        	    84: 
                        	    85: ; 0x80 to 0xFF - Load low literal (onto stack), where literal is P-code with 8-bit clear (ie. P-code & 0x7F)
                        	    86: 
                        	    87: 
                        	    88: ;
                        	    89: ;  P-code execution routine lookup.
                        	    90: ;  For symbolic version see list above
                        	    91: ;
                        	    92: ;  Y is zero when starting to execute these routines
                        	    93: ;
                        	    94: execution_address_table  =  *
00:AD55 86B0            	    95:   word  EX_LIT             ; $00 = LIT      Load constant
00:AD57 7AB4            	    96:   word  EX_NEW_STACK       ; $01 =          Change stack to addr
00:AD59 98B0            	    97:   word  EX_NEG             ; $02 = NEG      Unary minus: 0 - (sp)
00:AD5B 06B6            	    98:   word  EX_LIB_CALL        ; $03 = LIB_CALL Library function call
00:AD5D A1B0            	    99:   word  EX_ADD             ; $04 = ADD      Add (sp) to (sp - 1)
00:AD5F B4AF            	   100:   word  EX_INVINS          ; $05 =          NOT IMPLEMENTED
00:AD61 AAB0            	   101:   word  EX_SUB             ; $06 = SUB      Subtract (sp) from (sp - 1)
00:AD63 B4AF            	   102:   word  EX_INVINS          ; $07 =          NOT IMPLEMENTED
00:AD65 B6B0            	   103:   word  EX_MUL             ; $08 = MUL      Multiply (sp) * (sp - 1)
00:AD67 B4AF            	   104:   word  EX_INVINS          ; $09 =          NOT IMPLEMENTED
00:AD69 F1B0            	   105:   word  EX_DIV             ; $0A = DIV      Divide (sp - 1) / (sp)
00:AD6B C6B0            	   106:   word  EX_MOD             ; $0B = MOD      Modulus (sp - 1) MOD (sp)
00:AD6D 65B5            	   107:   word  EX_ADRNN           ; $0C = ADRNN    Address of integer
00:AD6F 55B5            	   108:   word  EX_ADRNC           ; $0D = ADRNC    Address of character
00:AD71 73B5            	   109:   word  EX_ADRAN           ; $0E = ADRAN    Address of integer array
00:AD73 79B5            	   110:   word  EX_ADRAC           ; $0F = ADRAC    Address of character array
00:AD75 0EB1            	   111:   word  EX_EQL             ; $10 = EQL      Test (sp - 1) == (sp)
00:AD77 01AF            	   112:   word  EX_FINISHD         ; $11 = FINISHD  Stop run (end program)
00:AD79 28B1            	   113:   word  EX_NEQ             ; $12 = NEQ      Test (sp - 1) != (sp)
00:AD7B B4AF            	   114:   word  EX_INVINS          ; $13 =          NOT IMPLEMENTED
00:AD7D 31B1            	   115:   word  EX_LSS             ; $14 = LSS      Test (sp - 1) < (sp)
00:AD7F B4AF            	   116:   word  EX_INVINS          ; $15 =          NOT IMPLEMENTED
00:AD81 49B1            	   117:   word  EX_GEQ             ; $16 = GEQ      Test (sp - 1) >= (sp)
00:AD83 B4AF            	   118:   word  EX_INVINS          ; $17 =          NOT IMPLEMENTED
00:AD85 3DB1            	   119:   word  EX_GTR             ; $18 = GTR      Test (sp - 1) > (sp)
00:AD87 55B1            	   120:   word  EX_LEQ             ; $19 = LEQ      Test (sp - 1) <= (sp)
00:AD89 6AB1            	   121:   word  EX_ORR             ; $1A = ORR      OR  (sp - 1) | (sp)
00:AD8B 73B1            	   122:   word  EX_AND             ; $1B = AND      AND (sp - 1) & (sp)
00:AD8D F3B2            	   123:   word  EX_INP             ; $1C = INP      Input number
00:AD8F BBB4            	   124:   word  EX_INPC            ; $1D = INPC     Input character
00:AD91 33B3            	   125:   word  EX_OUT             ; $1E = OUT      Output number
00:AD93 D5B4            	   126:   word  EX_OUTC            ; $1F = OUTC     Output character
00:AD95 7CB1            	   127:   word  EX_EOR             ; $20 = EOR      Not (sp) (logical negate)
00:AD97 47B3            	   128:   word  EX_OUH             ; $21 = OUH      Output hex number
00:AD99 85B1            	   129:   word  EX_SHL             ; $22 = SHL      Shift left (sp) bits
00:AD9B 67B3            	   130:   word  EX_OUS             ; $23 = OUS      Output string
00:AD9D 91B1            	   131:   word  EX_SHR             ; $24 = SHR      Shift right (sp) bits
00:AD9F F7B4            	   132:   word  EX_INS             ; $25 = INS      Input string into array
00:ADA1 9DB1            	   133:   word  EX_INC             ; $26 = INC      Increment (sp) by 1
00:ADA3 A1B3            	   134:   word  EX_CLL             ; $27 = CLL      Relative procedure/function call
00:ADA5 B5B1            	   135:   word  EX_DEC             ; $28 = DEC      Decrement (sp) by 1
00:ADA7 BAB2            	   136:   word  EX_RTN             ; $29 = RTN      Procedure/function return
00:ADA9 CDB1            	   137:   word  EX_MOV             ; $2A = MOV      Copy (sp) to (sp + 1)
00:ADAB 30B4            	   138:   word  EX_CLA             ; $2B = CLA      Call absolute address
00:ADAD F0B1            	   139:   word  EX_LOD             ; $2C = LOD      Load integer onto stack
00:ADAF DEB1            	   140:   word  EX_LODC            ; $2D = LODC     Load character onto stack
00:ADB1 11B2            	   141:   word  EX_LDA             ; $2E = LDA      Load absolute address integer
00:ADB3 06B2            	   142:   word  EX_LDAC            ; $2F = LDAC     Load absolute address character
00:ADB5 4CB2            	   143:   word  EX_LDI             ; $30 = LDI      Load integer indexed
00:ADB7 46B2            	   144:   word  EX_LDIC            ; $31 = LDIC     Load character indexed
00:ADB9 5FB2            	   145:   word  EX_STO             ; $32 = STO      Store integer
00:ADBB 52B2            	   146:   word  EX_STOC            ; $33 = STOC     Store character
00:ADBD 72B2            	   147:   word  EX_STA             ; $34 = STA      Store integer absolute address
00:ADBF 88B2            	   148:   word  EX_STAC            ; $35 = STAC     Store character absolute address
00:ADC1 9FB2            	   149:   word  EX_STI             ; $36 = STI      Store integer indexed
00:ADC3 91B2            	   150:   word  EX_STIC            ; $37 = STIC     Store character indexed
00:ADC5 9AB3            	   151:   word  EX_ABSCLL          ; $38 = ABSCLL   Absolute procedure/function call
00:ADC7 B4AF            	   152:   word  EX_INVINS          ; $39 =          NOT IMPLEMENTED
00:ADC9 61B1            	   153:   word  EX_XOR             ; $3A = XOR      XOR (sp - 1) ^ (sp)
00:ADCB 50B4            	   154:   word  EX_INT             ; $3B = INT      Increment stack pointer
00:ADCD 8CB4            	   155:   word  EX_JMP             ; $3C = JMP      Jump unconditionally
00:ADCF 9FB4            	   156:   word  EX_JMZ             ; $3D = JMZ      Jump if (sp) zero
00:ADD1 B0B4            	   157:   word  EX_JM1             ; $3E = JM1      Jump if (sp) not zero
00:ADD3 B4AF            	   158:   word  EX_INVINS          ; $3F =          NOT IMPLEMENTED
00:ADD5 61AF            	   159:   word  EX_OUTCR           ; $40 = OUTCR    Output a carriage-return
00:ADD7 B4AF            	   160:   word  EX_INVINS          ; $41 =          NOT IMPLEMENTED
00:ADD9 38B3            	   161:   word  EX_LCD_WRITE_NUM   ; $42 = LCD_WRITE_NUM  Write number to LCD
00:ADDB 6CB3            	   162:   word  EX_LCD_WRITE_STR   ; $43 = LCD_WRITE_STR  Write string to LCD
00:ADDD 4CB3            	   163:   word  EX_LCD_WRITE_HEX   ; $44 = LCD_WRITE_HEX  Write hex to LCD
00:ADDF DAB4            	   164:   word  EX_LCD_WRITE_CHR   ; $45 = LCD_WRITE_CHR  Write character to LCD
                        	   165: 
                        	   166: ;--------------------------------------------------------------------------
                        	   167: ;
                        	   168: ;  STACK FRAMES
                        	   169: ;
                        	   170: ;  The compiler can't know where variables are actually going to be stored because
                        	   171: ;  they will be relative to the (interpreter) stack (not the processor stack) which
                        	   172: ;  is an unknown address because procedures/functions can be called directly or from
                        	   173: ;  other procedures/functions.
                        	   174: ;
                        	   175: ;  Hence variables are referenced to BASE which is the base of the current stack frame,
                        	   176: ;  thus a variable will be a certain offset from that. However in the case of nested
                        	   177: ;  calls we need to go back to a previous stack frame. That is what the 6-byte "stack
                        	   178: ;  frame linkage data" is about.
                        	   179: ;
                        	   180: ;  Variables are referred to by a "level difference" and a displacement. For the current
                        	   181: ;  procedure the level difference will be zero, and thus the variable will be BASE +
                        	   182: ;  the offset for this particular variable.
                        	   183: ;
                        	   184: ;  For variables in earlier procedures/functions (ones which called this one) there will
                        	   185: ;  be a level difference, being the depth (lexically) between the called function and the
                        	   186: ;  one with the variable. For example, if foo calls bar, and bar recurses five times, foo
                        	   187: ;  and bar are still only one level apart, from the point of view of accessing foo's
                        	   188: ;  variables.
                        	   189: ;
                        	   190: ;  Thus, to find an address we need to "walk" back through the STATIC stack frame links
                        	   191: ;  (bytes 5 and 6 of the stack frame data) to find the appropriate stack frame, and then
                        	   192: ;  take the offset from that.
                        	   193: ;
                        	   194: ;  However for recursive calls, once a recursed call ends, we need to get back the stack
                        	   195: ;  frame of the caller, which will be different from the static frame. So, to restore the
                        	   196: ;  stack frame after a procedure/function ends, we must take the DYNAMIC stack frame address
                        	   197: ;  (bytes 3 and 4 of the stack frame data) to get back the previous stack frame. In fact,
                        	   198: ;  all procedures/functions do this, it's just that the static and dynamic stack frames will
                        	   199: ;  be the same if the procedure/function does not recurse.
                        	   200: ;
                        	   201: ;  Finally, the return address (in the P-codes) for the procedure/function call is also
                        	   202: ;  stored in the stack frame data (bytes 1 and 2 of the stack frame data) so that, after
                        	   203: ;  doing a return, we can restore the P-code address to the PCODE variable after the call.
                        	   204: ;
                        	   205: ;  When a procedure/function is called these 6 bytes are pushed onto the stack. Then, for
                        	   206: ;  some reason, the code moves the stack pointer back 6 (adds to it). Then as part of the
                        	   207: ;  procedure/function initialisation the stack pointer has 6 or 9 added to it, to allow
                        	   208: ;  for not overwriting this stack frame data, and in the case of functions, the extra 3
                        	   209: ;  bytes are for the returned value.
                        	   210: ;
                        	   211: ;  Note that the stack grows downwards, as it starts at "high memory" (whatever that is
                        	   212: ;  defined as, and grows downwards, taking the gap between the end of the P-codes and the
                        	   213: ;  end of memory.
                        	   214: ;
                        	   215: ;  Then the function will add additional spaces to the stack (ie. by subtracting from the
                        	   216: ;  stack pointer) to make room for variables declared in that procedure/function. Now we
                        	   217: ;  are ready to push data onto the stack as part of normal expression evalution. It follows
                        	   218: ;  from this that variables initially have undefined values, as they will contain whatever
                        	   219: ;  happened to be in the stack when this space was allocated.
                        	   220: ;
                        	   221: ;  The function GETADR resolves these addresses by starting with BASE, the stack frame base
                        	   222: ;  for the current procedure/function, and then using the static stack frame link to load a
                        	   223: ;  (temporary) new base, and repeating that until the level difference is zero. Then it adds
                        	   224: ;  the offset of the wanted variable to the stack base to derive the actual variable address.
                        	   225: ;
                        	   226: ;--------------------------------------------------------------------------
                        	   227: 
                        	   228: 
                        	   229: ;
00:ADE1 20537461636B3A20	   230: DM1               asciiz  ' Stack: '
00:ADE9 00
00:ADEA 20426173653A2020	   231: DM2               asciiz  ' Base:  '
00:ADF2 00
00:ADF3 52756E6E696E670A	   232: running_message   asciiz  'Running\n'
00:ADFB 00
                        	   233: 
                        	   234: ;
                        	   235: DEBUG    =  *
00:ADFC 206292          	   236: DB11     jsr  DISPAD    ; display P-code address
00:ADFF A523            	   237:          lda  PCODE
00:AE01 8537            	   238:          sta  WORK
00:AE03 A524            	   239:          lda  PCODE+1
00:AE05 8538            	   240:          sta  WORK+1
00:AE07 A204            	   241:          ldx  #4
00:AE09 20C5AE          	   242:          jsr  display_x_characters      ; display 4 bytes from WORK (ie. the P-codes)
00:AE0C 204792          	   243:          jsr  CROUT
00:AE0F A649            	   244:          ldx  DBGFLG
00:AE11 3051            	   245:          bmi  DEBUG_DONE        ; trace only
00:AE13 A9E1            	   246:          lda  #<DM1             ; ' Stack: '
00:AE15 A2AD            	   247:          ldx  #>DM1
00:AE17 202682          	   248:          jsr  print
00:AE1A A532            	   249:          lda  T+1
00:AE1C 20BC92          	   250:          jsr  PRBYTE        ; display the stack pointer address
00:AE1F A531            	   251:          lda  T
00:AE21 205C92          	   252:          jsr  DISHX         ; display hex and a space after
00:AE24 A93D            	   253:          lda  #'='
00:AE26 20CE93          	   254:          jsr  COUT
00:AE29 A531            	   255:          lda  T
00:AE2B 8537            	   256:          sta  WORK
00:AE2D A532            	   257:          lda  T+1
00:AE2F 8538            	   258:          sta  WORK+1
00:AE31 A209            	   259:          ldx  #9         ; show 9 bytes on stack, namely 3 variables
00:AE33 20C5AE          	   260:          jsr  display_x_characters
00:AE36 204792          	   261:          jsr  CROUT
00:AE39 A9EA            	   262:          lda  #<DM2       ; ' Base:  '
00:AE3B A2AD            	   263:          ldx  #>DM2
00:AE3D 202682          	   264:          jsr  print
00:AE40 A53C            	   265:          lda  BASE+1
00:AE42 20BC92          	   266:          jsr  PRBYTE      ; display the base pointer address
00:AE45 A53B            	   267:          lda  BASE
00:AE47 205C92          	   268:          jsr  DISHX
00:AE4A A93D            	   269:          lda  #'='
00:AE4C 20CE93          	   270:          jsr  COUT
00:AE4F A53B            	   271:          lda  BASE
00:AE51 38              	   272:          sec
00:AE52 E906            	   273:          sbc  #6    ; the linkage data is 6 bytes below the base
00:AE54 8537            	   274:          sta  WORK
00:AE56 A53C            	   275:          lda  BASE+1
00:AE58 E900            	   276:          sbc  #0
00:AE5A 8538            	   277:          sta  WORK+1
00:AE5C A206            	   278:          ldx  #6    ; show 6 bytes of base linkage data (return, dynamic link, static link)
00:AE5E 20C5AE          	   279:          jsr  display_x_characters
00:AE61 4C4792          	   280:          jmp  CROUT
                        	   281: 
00:AE64 60              	   282: DEBUG_DONE rts
                        	   283: 
                        	   284: 
                        	   285: ;***********************************************
                        	   286: ; Interpreter initialization
                        	   287: ;***********************************************
                        	   288: 
                        	   289: INTERP   =  *
00:AE65 08              	   290:   php
00:AE66 68              	   291:   pla
00:AE67 8513            	   292:   sta  call_p   ; make sure call_p has some reasonable value in it
                        	   293: ;
                        	   294: ;  Move the start of where the P-codes start into PCODE (our first P-code)
                        	   295: ;
00:AE69 A525            	   296:   lda  ACT_PCDA
00:AE6B 8523            	   297:   sta  PCODE
00:AE6D A526            	   298:   lda  ACT_PCDA+1
00:AE6F 8524            	   299:   sta  PCODE+1
                        	   300: ;
                        	   301: ;  Running message
                        	   302: ;
00:AE71 A9F3            	   303:   lda  #<running_message   ; Running
00:AE73 A2AD            	   304:   ldx  #>running_message
00:AE75 202682          	   305:   jsr  print
                        	   306: ;
                        	   307: ;  Running flag
                        	   308: ;
00:AE78 A00C            	   309:   ldy  #$0C
00:AE7A 843F            	   310:   sty  RUNNING
                        	   311: ;
                        	   312: ;  Set up the runtime stack pointer which is also our first stack frame base
                        	   313: ;
00:AE7C A9FF            	   314:   lda  #<HIGHEST_RAM
00:AE7E 8531            	   315:   sta  T
00:AE80 853B            	   316:   sta  BASE
00:AE82 A93F            	   317:   lda  #>HIGHEST_RAM
00:AE84 8532            	   318:   sta  T+1
00:AE86 853C            	   319:   sta  BASE+1
                        	   320: 
00:AE88 4C76AF          	   321:   jmp  MAIN ; start interpreting
                        	   322: ;
                        	   323: ;
                        	   324: ;
                        	   325: 
                        	   326: 
                        	   327: ;***********************************************
                        	   328: ;  INTERPRETER
                        	   329: ;***********************************************
                        	   330: 
                        	   331: ;
                        	   332: ;
00:AE8B 496C6C6567616C20	   333: DM5      asciiz  "Illegal instruction\n"
00:AE93 696E737472756374
00:AE9B 696F6E0A
00:AE9F 00
00:AEA0 427265616B202E2E	   334: DM6      asciiz  'Break ...\n'
00:AEA8 2E0A
00:AEAA 00
00:AEAB 4572726F72206F63	   335: DM7      asciiz  "Error occurred at P-code "
00:AEB3 6375727265642061
00:AEBB 7420502D636F6465
00:AEC3 20
00:AEC4 00
                        	   336: 
                        	   337: ;
                        	   338: ; DISPLAY (X) CHARACTERS FROM (WORK)
                        	   339: ;
                        	   340: display_x_characters:
00:AEC5 8A              	   341:          txa
00:AEC6 48              	   342:          pha
00:AEC7 20D292          	   343:          jsr  PUTSP
00:AECA 68              	   344:          pla
00:AECB AA              	   345:          tax
00:AECC A000            	   346: DIS5     ldy  #0
00:AECE B137            	   347:          lda  (WORK),Y
00:AED0 E637            	   348:          inc  WORK
00:AED2 D002            	   349:          bne  DIS5_A
00:AED4 E638            	   350:          inc  WORK+1
                        	   351: DIS5_A   =  *
00:AED6 A8              	   352:          tay
00:AED7 8A              	   353:          txa
00:AED8 48              	   354:          pha
00:AED9 98              	   355:          tya
00:AEDA 205C92          	   356:          jsr  DISHX
00:AEDD 68              	   357:          pla
00:AEDE AA              	   358:          tax
00:AEDF CA              	   359:          dex
00:AEE0 D0EA            	   360:          bne  DIS5
00:AEE2 60              	   361:          rts
                        	   362: 
                        	   363: ;
                        	   364: ; Ding a bell - however we don't have it on this board
                        	   365: ;
                        	   366: BELL1    =  *
00:AEE3 48              	   367:          pha
00:AEE4 A900            	   368:          lda  #0
00:AEE6 853F            	   369:          sta  RUNNING
00:AEE8 204792          	   370:          jsr  CROUT
00:AEEB 68              	   371:          pla
00:AEEC 60              	   372:          rts
                        	   373: ;
                        	   374: ;
00:AEED 20E3AE          	   375: RUNERR   jsr  BELL1
00:AEF0 A9AB            	   376:          lda  #<DM7  ; Error occurred at P-code
00:AEF2 A2AE            	   377:          ldx  #>DM7
00:AEF4 202682          	   378:          jsr  print
00:AEF7 A54E            	   379:          lda  LASTP+1
00:AEF9 20BC92          	   380:          jsr  PRBYTE
00:AEFC A54D            	   381:          lda  LASTP
00:AEFE 205C92          	   382:          jsr  DISHX
                        	   383: EX_FINISHD  =  *
00:AF01 A900            	   384:          lda  #0
00:AF03 204792          	   385:          jsr  CROUT
00:AF06 A918            	   386:          lda  #<FIN_MSG
00:AF08 A2AF            	   387:          ldx  #>FIN_MSG
00:AF0A 202682          	   388:          jsr  print
00:AF0D 648B            	   389:          stz  serial_in_byte_received  ; get rid of read-ahead
00:AF0F 2018C9          	   390:          jsr  GETIN      ; wait till message seen
00:AF12 204792          	   391:          jsr  CROUT      ; output a newline in case they press space or something
00:AF15 4C55DA          	   392:          jmp  RESTART
                        	   393: ;
00:AF18 52756E2066696E69	   394: FIN_MSG  asciiz  'Run finished - press a key ...'
00:AF20 73686564202D2070
00:AF28 726573732061206B
00:AF30 6579202E2E2E
00:AF36 00
                        	   395: ;
                        	   396: ;
                        	   397: CHK_KBD  =  *
00:AF37 C90E            	   398:          cmp  #KEY_STOP_TRACE       ; Ctrl+N - stop tracing
00:AF39 D008            	   399:          bne  CHK_NOTN
00:AF3B 648B            	   400:          stz  serial_in_byte_received
00:AF3D A900            	   401:          lda  #0
00:AF3F 8549            	   402:          sta  DBGFLG
00:AF41 38              	   403:          sec
00:AF42 60              	   404:          rts
00:AF43 C914            	   405: CHK_NOTN cmp  #KEY_TRACE      ; Ctrl+T - start tracing
00:AF45 D00A            	   406:          bne  CHK_NOTT
00:AF47 648B            	   407:          stz  serial_in_byte_received
00:AF49 A980            	   408:          lda  #$80
00:AF4B 8549            	   409:          sta  DBGFLG
00:AF4D 852E            	   410:          sta  DCODE
00:AF4F 38              	   411:          sec
00:AF50 60              	   412:          rts
00:AF51 C904            	   413: CHK_NOTT cmp  #KEY_DEBUG      ; Ctrl+D - start debugging
00:AF53 D00A            	   414:          bne  CHK_NOTD
00:AF55 648B            	   415:          stz  serial_in_byte_received
00:AF57 A901            	   416:          lda  #1
00:AF59 8549            	   417:          sta  DBGFLG
00:AF5B 852E            	   418:          sta  DCODE
00:AF5D 38              	   419:          sec
00:AF5E 60              	   420:          rts
00:AF5F 18              	   421: CHK_NOTD clc
00:AF60 60              	   422:          rts
                        	   423: ;
                        	   424: EX_OUTCR    =  *
00:AF61 204792          	   425:   jsr  CROUT      ; OUTPUT C/R
00:AF64 4C76AF          	   426:   jmp  MAIN
                        	   427: ;
                        	   428: ;  Here for a "low literal" - a P-code with the 0x80 bit set. Clear that bit and push
                        	   429: ;   the resulting number onto the stack
                        	   430: ;
                        	   431: LOWLIT:
00:AF67 E623            	   432:   inc  PCODE     ; increment P-code past the low literal
00:AF69 D002            	   433:   bne  LOWLIT1
00:AF6B E624            	   434:   inc  PCODE+1
                        	   435: LOWLIT1:
00:AF6D 8401            	   436:   sty  REG+1     ; Y and REGB were cleared below
00:AF6F 297F            	   437:   and  #$7F
00:AF71 8500            	   438:   sta  REG
                        	   439: ;
                        	   440: ;  fall down to push this value
                        	   441: ;
                        	   442: 
                        	   443: 
                        	   444: ;
                        	   445: ; Push previous result (REG) and then drop down to do the next instruction
                        	   446: ;
                        	   447: MAINP:
00:AF73 2053B0          	   448:  jsr  PSHTOP    ; push REG onto stack and go back to MAIN
                        	   449: 
                        	   450: ;
                        	   451: ;  Main interpreter loop - each instruction jumps back here (or to MAINP above if it
                        	   452: ;              needs to push a previous calculation result)
                        	   453: ;
                        	   454: MAIN:
00:AF76 A549            	   455:   lda  DBGFLG   ; debugging?
00:AF78 F003            	   456:   beq  MAIN_2   ; no
00:AF7A 20FCAD          	   457:   jsr  DEBUG    ; yes - show debug info
                        	   458: MAIN_2   =  *
                        	   459: ; check if key pressed here, to abort, or turn on/off tracing or debugging
00:AF7D A58B            	   460:   lda  serial_in_byte_received
00:AF7F F00A            	   461:   beq  MAIN_OK
00:AF81 C903            	   462:   cmp  #KEY_ABORT
00:AF83 D003            	   463:   bne  MAIN_NOT_ABORT
00:AF85 4C01AF          	   464:   jmp  EX_FINISHD
                        	   465: MAIN_NOT_ABORT = *
00:AF88 2037AF          	   466:   jsr  CHK_KBD          ; check for turning on trace, debug, etc.
                        	   467: MAIN_OK  =  *
00:AF8B A523            	   468:   lda  PCODE             ; save P-code address as LASTP (for errors I presume)
00:AF8D 854D            	   469:   sta  LASTP
00:AF8F A524            	   470:   lda  PCODE+1
00:AF91 854E            	   471:   sta  LASTP+1
                        	   472: ;
                        	   473: ;  now grab the P-code
                        	   474: ;
00:AF93 A000            	   475:   ldy  #0
00:AF95 8402            	   476:   sty  REGB
00:AF97 B123            	   477:   lda  (PCODE),Y         ; get the P-code from the P-codes
00:AF99 30CC            	   478:   bmi  LOWLIT            ; low literal - just handle it
00:AF9B C946            	   479:   cmp  #PCODE_LAST+1
00:AF9D B015            	   480:   bcs  EX_INVINS         ; error if off end of table
                        	   481: ;
                        	   482: ;  increment past this P-code
                        	   483: ;
                        	   484: MAIN_5   =  *
00:AF9F E623            	   485:   inc  PCODE
00:AFA1 D002            	   486:   bne  MAIN_1
00:AFA3 E624            	   487:   inc  PCODE+1
                        	   488: ;
                        	   489: ;  grab the execution handler from the execution_address_table
                        	   490: ;
                        	   491: MAIN_1   =  *
00:AFA5 0A              	   492:   asl  A             ; double the P-code because each address takes 2 bytes
00:AFA6 AA              	   493:   tax
00:AFA7 BD55AD          	   494:   lda  execution_address_table,X      ; otherwise get the execution address
00:AFAA 8537            	   495:   sta  WORK
00:AFAC BD56AD          	   496:   lda  execution_address_table+1,X    ; and the high-order byte
00:AFAF 8538            	   497:   sta  WORK+1
00:AFB1 6C3700          	   498:   jmp  (WORK)        ; execute the appropriate P-code implementation routine
                        	   499: 
                        	   500: ;
                        	   501: NOTIMP   =  *
                        	   502: EX_INVINS   =  *
00:AFB4 A98B            	   503:          LDA  #<DM5   ; Illegal Instruction
00:AFB6 A2AE            	   504:          LDX  #>DM5
                        	   505: NOTIM1   =  *
00:AFB8 202682          	   506:          JSR  print
00:AFBB 4CEDAE          	   507:          JMP  RUNERR
                        	   508: ;
                        	   509: BREAK    =  *
00:AFBE A9A0            	   510:          LDA  #<DM6  ; Break ...
00:AFC0 A2AE            	   511:          LDX  #>DM6
00:AFC2 4CB8AF          	   512:          JMP  NOTIM1
                        	   513: 
                        	   514: 
00:AFC5 A000            	   515: GETADR   LDY  #0
00:AFC7 B123            	   516:          LDA  (PCODE),Y     ; level
00:AFC9 854B            	   517:          STA  COUNT1        ; count of levels to work through
00:AFCB A53C            	   518:          LDA  BASE+1        ; start with our stack base address
00:AFCD A63B            	   519:          LDX  BASE
                        	   520: GET2     =  *
00:AFCF 853E            	   521:          STA  DATA+1        ; our data is relative to the stack base
00:AFD1 863D            	   522:          STX  DATA
00:AFD3 A8              	   523:          TAY
00:AFD4 A54B            	   524:          LDA  COUNT1        ; any levels left?
00:AFD6 F018            	   525:          BEQ  GETADR1       ; no, we can continue
00:AFD8 38              	   526:          SEC                ; yes
00:AFD9 8A              	   527:          TXA                ; subtract 2 from the base to get the static link
00:AFDA E902            	   528:          SBC  #2
00:AFDC 8537            	   529:          STA  WORK
00:AFDE 98              	   530:          TYA
00:AFDF E900            	   531:          SBC  #0
00:AFE1 8538            	   532:          STA  WORK+1        ; BASE - 2 -> WORK
00:AFE3 A000            	   533:          LDY  #0
00:AFE5 B137            	   534:          LDA  (WORK),Y      ; grab contents of BASE-2
00:AFE7 C8              	   535:          INY
00:AFE8 AA              	   536:          TAX
00:AFE9 B137            	   537:          LDA  (WORK),Y
00:AFEB C64B            	   538:          DEC  COUNT1        ; one less level
00:AFED 4CCFAF          	   539:          JMP  GET2          ; keep going until we used all levels
                        	   540: 
                        	   541: GETADR1     =  *
00:AFF0 A001            	   542:          LDY  #1            ; now get the offset
00:AFF2 18              	   543:          CLC
00:AFF3 B123            	   544:          LDA  (PCODE),Y     ; offset low-order byte
00:AFF5 653D            	   545:          ADC  DATA          ; add base
00:AFF7 853D            	   546:          STA  DATA
00:AFF9 C8              	   547:          INY
00:AFFA B123            	   548:          LDA  (PCODE),Y     ; offset high-order byte
00:AFFC 653E            	   549:          ADC  DATA+1        ; add base
00:AFFE 853E            	   550:          STA  DATA+1        ; DATA now holds the data address
00:B000 A523            	   551:          LDA  PCODE         ; add 3 to PCODE to skip level and offset
00:B002 18              	   552:          CLC
00:B003 6903            	   553:          ADC  #3
00:B005 8523            	   554:          STA  PCODE
00:B007 9002            	   555:          BCC  GET1_A
00:B009 E624            	   556:          INC  PCODE+1
                        	   557: GET1_A   =  *
00:B00B 60              	   558:          RTS                ; done - we can use DATA to access whatever-it-is
                        	   559: 
                        	   560: ;
                        	   561: ;  Pull the top item on the runtime stack into REG (aka VALUE)
                        	   562: ;
                        	   563: PULTOP   =  *
00:B00C A000            	   564:          LDY  #0
00:B00E B131            	   565:          LDA  (T),Y
00:B010 8500            	   566:          STA  REG
00:B012 C8              	   567:          INY
00:B013 B131            	   568:          LDA  (T),Y
00:B015 8501            	   569:          STA  REG+1
00:B017 C8              	   570:          INY
00:B018 B131            	   571:          LDA  (T),Y
00:B01A 8502            	   572:          STA  REGB
00:B01C A531            	   573:          LDA  T
00:B01E 18              	   574:          CLC      ; add 3 to the stack because we removed one integer from it
00:B01F 6903            	   575:          ADC  #3
00:B021 8531            	   576:          STA  T
00:B023 9002            	   577:          BCC  PUL_END
00:B025 E632            	   578:          INC  T+1
                        	   579: PUL_END  =  *
00:B027 A500            	   580:          LDA  REG
00:B029 A601            	   581:          LDX  REG+1
00:B02B A402            	   582:          LDY  REGB
00:B02D 60              	   583:          RTS
                        	   584: 
00:B02E 200CB0          	   585: PULBOTH  JSR  PULTOP     ; Pulls both of them - do one and then fall through to do the other
                        	   586: 
                        	   587: ;
                        	   588: ;  Pull the top item on the runtime stack into REG2 (aka VALUE2)
                        	   589: ;
                        	   590: PULTOP2  =  *
00:B031 A000            	   591:          LDY  #0
00:B033 B131            	   592:          LDA  (T),Y
00:B035 8503            	   593:          STA  REG2
00:B037 C8              	   594:          INY
00:B038 B131            	   595:          LDA  (T),Y
00:B03A 8504            	   596:          STA  REG2+1
00:B03C C8              	   597:          INY
00:B03D B131            	   598:          LDA  (T),Y
00:B03F 8505            	   599:          STA  REG2B
00:B041 A531            	   600:          LDA  T
00:B043 18              	   601:          CLC         ; add 3 to the stack because we removed one integer from it
00:B044 6903            	   602:          ADC  #3
00:B046 8531            	   603:          STA  T
00:B048 9002            	   604:          BCC  PUL2_END
00:B04A E632            	   605:          INC  T+1
                        	   606: PUL2_END =  *
00:B04C A503            	   607:          LDA  REG2
00:B04E A604            	   608:          LDX  REG2+1
00:B050 A405            	   609:          LDY  REG2B
00:B052 60              	   610:          RTS
                        	   611: 
                        	   612: ;
                        	   613: ;  Push REG (aka VALUE) onto the runtime stack
                        	   614: ;
                        	   615: PSHTOP   =  *
00:B053 38              	   616:          SEC        ;  subtract 3 from the stack because we are about to add one integer to it
00:B054 A531            	   617:          LDA  T
00:B056 E903            	   618:          SBC  #3
00:B058 8531            	   619:          STA  T
00:B05A B002            	   620:          BCS  PSH1
00:B05C C632            	   621:          DEC  T+1
                        	   622: PSH1     =  *
00:B05E A000            	   623:          LDY  #0
00:B060 A500            	   624:          LDA  REG
00:B062 9131            	   625:          STA  (T),Y
00:B064 C8              	   626:          INY
00:B065 A501            	   627:          LDA  REG+1
00:B067 9131            	   628:          STA  (T),Y
00:B069 C8              	   629:          INY
00:B06A A502            	   630:          LDA  REGB
00:B06C 9131            	   631:          STA  (T),Y
00:B06E 60              	   632:          RTS
                        	   633: ;
                        	   634: ;  get a literal (2 bytes) from the P-codes and put it into REG
                        	   635: ;
                        	   636: GETLIT   =  *
00:B06F A000            	   637:   ldy  #0
00:B071 B123            	   638:   lda  (PCODE),Y
00:B073 8500            	   639:   sta  REG
00:B075 C8              	   640:   iny
00:B076 B123            	   641:   lda  (PCODE),Y
00:B078 8501            	   642:   sta  REG+1
00:B07A A523            	   643:   lda  PCODE
00:B07C 18              	   644:   clc         ; P-code address goes up by 2
00:B07D 6902            	   645:   adc  #2
00:B07F 8523            	   646:   sta  PCODE
00:B081 9002            	   647:   bcc  GET_END
00:B083 E624            	   648:   inc  PCODE+1
                        	   649: GET_END:
00:B085 60              	   650:   rts
                        	   651: ;
                        	   652: ; load literal onto the stack (the literal is the next 3 bytes after the P-code)
                        	   653: ;
                        	   654: EX_LIT:
00:B086 206FB0          	   655:   jsr  GETLIT   ; get the first 2 bytes
00:B089 A000            	   656:   ldy  #0
00:B08B B123            	   657:   lda  (PCODE),Y    ; now the third byte
00:B08D 8502            	   658:   sta  REGB
00:B08F E623            	   659:   inc  PCODE
00:B091 D002            	   660:   bne  LIT1
00:B093 E624            	   661:   inc  PCODE+1
                        	   662: LIT1:
00:B095 4C73AF          	   663:   jmp  MAINP    ; now we can push it
                        	   664: ;
                        	   665: ;  Negate (0 - (sp) )
                        	   666: ;
                        	   667: EX_NEG:
00:B098 200CB0          	   668:   jsr PULTOP
00:B09B 2025AC          	   669:   jsr exp_unary_minus
00:B09E 4C73AF          	   670:   jmp MAINP
                        	   671: ;
                        	   672: ;  Add (sp) to (sp -1)
                        	   673: ;
                        	   674: EX_ADD:
00:B0A1 202EB0          	   675:   JSR  PULBOTH
00:B0A4 20DEAA          	   676:   jsr  exp_add
00:B0A7 4C73AF          	   677:   JMP  MAINP
                        	   678: ;
                        	   679: ;
                        	   680: ;  Add (sp) from (sp - 1)
                        	   681: ;
                        	   682: EX_SUB:
00:B0AA 2031B0          	   683:   JSR  PULTOP2
00:B0AD 200CB0          	   684:   jsr  PULTOP
00:B0B0 20F2AA          	   685:   jsr  exp_subtract
00:B0B3 4C73AF          	   686:   JMP  MAINP
                        	   687: ;
                        	   688: ;  Multiply (sp) by (sp - 1)
                        	   689: ;
                        	   690: EX_MUL:
00:B0B6 202EB0          	   691:   jsr PULBOTH
00:B0B9 20ACAC          	   692:   jsr exp_multiply
00:B0BC 4C73AF          	   693:   jmp MAINP
                        	   694: 
                        	   695: ;
                        	   696: ;  we will take the current key (and return to the user)
                        	   697: ;  and zero it out anyway, so that consumes the key
                        	   698: ;
                        	   699: EX_GETKEY   =  *
00:B0BF A58B            	   700:   lda  serial_in_byte_received
00:B0C1 648B            	   701:   stz  serial_in_byte_received
00:B0C3 4C19B1          	   702:   jmp  TRUE2
                        	   703: ;
                        	   704: ;  Modulus (remainder)
                        	   705: ;
                        	   706: EX_MOD:
00:B0C6 2031B0          	   707:   jsr PULTOP2
                        	   708: ;
                        	   709: ;  check for divide by zero because I want a run-time error message
                        	   710: ;
00:B0C9 A503            	   711:   lda VALUE2
00:B0CB 0504            	   712:   ora VALUE2+1
00:B0CD 0505            	   713:   ora VALUE2+2
00:B0CF F009            	   714:   beq EX_DIVIDE_BY_ZERO
00:B0D1 200CB0          	   715:   jsr PULTOP
00:B0D4 2045AD          	   716:   jsr exp_modulo
00:B0D7 4C73AF          	   717:   jmp MAINP
                        	   718: ;
                        	   719: 
                        	   720: EX_DIVIDE_BY_ZERO:
00:B0DA A9E1            	   721:   lda  #<DIVBY0
00:B0DC A2B0            	   722:   ldx  #>DIVBY0
00:B0DE 4CB8AF          	   723:   jmp  NOTIM1
                        	   724: 
00:B0E1 4469766964652062	   725: DIVBY0   asciiz  'Divide by zero\n'
00:B0E9 79207A65726F0A
00:B0F0 00
                        	   726: ;
                        	   727: ;  Divide (sp - 1) by (sp)
                        	   728: ;
                        	   729: EX_DIV:
00:B0F1 2031B0          	   730:   jsr PULTOP2
00:B0F4 A503            	   731:   lda VALUE2
00:B0F6 0504            	   732:   ora VALUE2+1
00:B0F8 0505            	   733:   ora VALUE2+2
00:B0FA F0DE            	   734:   beq EX_DIVIDE_BY_ZERO
00:B0FC 200CB0          	   735:   jsr PULTOP
00:B0FF 20E5AC          	   736:   jsr exp_divide
00:B102 4C73AF          	   737:   jmp MAINP
                        	   738: 
                        	   739: ;
                        	   740: ;  Absolute value of (sp)
                        	   741: ;
                        	   742: EX_ABS:
00:B105 200CB0          	   743:   jsr  PULTOP
00:B108 2047AC          	   744:   jsr exp_abs_val
00:B10B 4C73AF          	   745:   jmp  MAINP
                        	   746: 
                        	   747: ; Equal
                        	   748: ;
                        	   749: EX_EQL:
00:B10E 202EB0          	   750:   jsr PULBOTH
00:B111 2018AB          	   751:   jsr exp_eql
00:B114 4C73AF          	   752:   jmp MAINP
                        	   753: 
                        	   754: ;
                        	   755: ;  Push 1
                        	   756: ;
                        	   757: TRUE:
00:B117 A901            	   758:   lda  #1
                        	   759: ;
                        	   760: ;  Push A into low-order byte, zero other two bytes
                        	   761: ;
                        	   762: TRUE2:
00:B119 8500            	   763:   sta  REG
00:B11B A900            	   764:   lda  #0
00:B11D 8501            	   765:   sta  REG+1
00:B11F 8502            	   766:   sta  REGB
00:B121 4C73AF          	   767:   jmp  MAINP
                        	   768: 
                        	   769: ;
                        	   770: ;  Push 0
                        	   771: ;
                        	   772: FALSE:
00:B124 A900            	   773:   lda  #0
00:B126 80F1            	   774:   bra TRUE2
                        	   775: ;
                        	   776: ;  Not equal
                        	   777: ;
                        	   778: EX_NEQ:
00:B128 202EB0          	   779:     jsr PULBOTH
00:B12B 202CAB          	   780:     jsr exp_neq
00:B12E 4C73AF          	   781:     jmp MAINP
                        	   782: 
                        	   783: ;
                        	   784: ;  Less than
                        	   785: ;
                        	   786: EX_LSS:
00:B131 2031B0          	   787:   jsr PULTOP2
00:B134 200CB0          	   788:   jsr PULTOP
00:B137 2040AB          	   789:   jsr exp_less_than
00:B13A 4C73AF          	   790:   jmp MAINP
                        	   791: 
                        	   792: ;
                        	   793: ;  Greater than
                        	   794: ;
                        	   795: EX_GTR:
00:B13D 2031B0          	   796:   jsr PULTOP2
00:B140 200CB0          	   797:   jsr PULTOP
00:B143 2047AB          	   798:   jsr exp_greater_than
00:B146 4C73AF          	   799:   jmp MAINP
                        	   800: 
                        	   801: ;
                        	   802: ;  Greater than or equal
                        	   803: ;
                        	   804: EX_GEQ:
00:B149 2031B0          	   805:   jsr PULTOP2
00:B14C 200CB0          	   806:   jsr PULTOP
00:B14F 2065AB          	   807:   jsr exp_geq
00:B152 4C73AF          	   808:   jmp MAINP
                        	   809: 
                        	   810: ;
                        	   811: ;  Less than or equal
                        	   812: ;
                        	   813: EX_LEQ:
00:B155 2031B0          	   814:   jsr PULTOP2
00:B158 200CB0          	   815:   jsr PULTOP
00:B15B 2056AB          	   816:   jsr exp_leq
00:B15E 4C73AF          	   817:   jmp MAINP
                        	   818: 
                        	   819: ;
                        	   820: ;  Exclusive OR
                        	   821: ;
                        	   822: EX_XOR:
00:B161 202EB0          	   823:   jsr PULBOTH
00:B164 2096AB          	   824:   jsr exp_bitwise_xor
00:B167 4C73AF          	   825:   jmp MAINP
                        	   826: ;
                        	   827: ;  Or
                        	   828: ;
                        	   829: EX_ORR:
00:B16A 202EB0          	   830:   jsr PULBOTH
00:B16D 206CAB          	   831:   jsr exp_bitwise_or
00:B170 4C73AF          	   832:   jmp MAINP
                        	   833: 
                        	   834: ;
                        	   835: ;  And
                        	   836: ;
                        	   837: EX_AND:
00:B173 202EB0          	   838:   jsr  PULBOTH
00:B176 2081AB          	   839:   jsr exp_bitwise_and
00:B179 4C73AF          	   840:   jmp MAINP
                        	   841: 
                        	   842: ;
                        	   843: ;  Not
                        	   844: ;
                        	   845: EX_EOR:
00:B17C 200CB0          	   846:   jsr PULTOP
00:B17F 2017AC          	   847:   jsr exp_not
00:B182 4C73AF          	   848:   jmp MAINP
                        	   849: ;
                        	   850: ; Shift left
                        	   851: ;
                        	   852: EX_SHL:
00:B185 2031B0          	   853:   jsr PULTOP2
00:B188 200CB0          	   854:   jsr PULTOP
00:B18B 20D2AB          	   855:   jsr exp_shift_left
00:B18E 4C73AF          	   856:   jmp MAINP
                        	   857: 
                        	   858: ;
                        	   859: ;  Shift right
                        	   860: ;
                        	   861: EX_SHR:
00:B191 2031B0          	   862:   jsr PULTOP2
00:B194 200CB0          	   863:   jsr PULTOP
00:B197 20EBAB          	   864:   jsr exp_shift_right
00:B19A 4C73AF          	   865:   jmp MAINP
                        	   866: 
                        	   867: ;
                        	   868: ;  increment number on top of stack by one
                        	   869: ;
                        	   870: EX_INC:
00:B19D 18              	   871:   clc
00:B19E B131            	   872:   lda  (T),Y
00:B1A0 6901            	   873:   adc  #1
00:B1A2 9131            	   874:   sta  (T),Y
00:B1A4 C8              	   875:   iny
00:B1A5 B131            	   876:   lda  (T),Y
00:B1A7 6900            	   877:   adc  #0
00:B1A9 9131            	   878:   sta  (T),Y
00:B1AB C8              	   879:   iny
00:B1AC B131            	   880:   lda  (T),Y
00:B1AE 6900            	   881:   adc  #0
00:B1B0 9131            	   882:   sta  (T),Y
00:B1B2 4C76AF          	   883:   jmp  MAIN
                        	   884: ;
                        	   885: ;  decrement number on top of stack by one
                        	   886: ;
                        	   887: 
                        	   888: EX_DEC:
00:B1B5 38              	   889:   sec
00:B1B6 B131            	   890:   lda  (T),Y
00:B1B8 E901            	   891:   sbc  #1
00:B1BA 9131            	   892:   sta  (T),Y
00:B1BC C8              	   893:   iny
00:B1BD B131            	   894:   lda  (T),Y
00:B1BF E900            	   895:   sbc  #0
00:B1C1 9131            	   896:   sta  (T),Y
00:B1C3 C8              	   897:   iny
00:B1C4 B131            	   898:   lda  (T),Y
00:B1C6 E900            	   899:   sbc  #0
00:B1C8 9131            	   900:   sta  (T),Y
00:B1CA 4C76AF          	   901:   jmp  MAIN
                        	   902: 
                        	   903: ;
                        	   904: ;  Copy (sp) to (sp + 1)
                        	   905: ;
                        	   906: EX_MOV:
00:B1CD B131            	   907:   lda  (T),Y  ; get item at top of stack
00:B1CF 8500            	   908:   sta REG
00:B1D1 C8              	   909:   iny
00:B1D2 B131            	   910:   lda  (T),Y
00:B1D4 8501            	   911:   sta REG+1
00:B1D6 C8              	   912:   iny
00:B1D7 B131            	   913:   lda  (T),Y
00:B1D9 8502            	   914:   sta REGB
00:B1DB 4C73AF          	   915:   jmp MAINP   ; push it
                        	   916: 
                        	   917: ;
                        	   918: ;  Load a single-character value (variable) onto the stack
                        	   919: ;
                        	   920: 
                        	   921: EX_LODC:
00:B1DE 20C5AF          	   922:   jsr  GETADR
                        	   923: EX_LOD3:
00:B1E1 A002            	   924:   ldy  #2
                        	   925: EX_LOD3_A:
00:B1E3 A900            	   926:   lda  #0      ; since this is a character zero out the high-order bytes
00:B1E5 8501            	   927:   sta  REG+1
00:B1E7 8502            	   928:   sta  REGB
00:B1E9 B13D            	   929:   lda  (DATA),Y  ; (DATA) contains the lower-order byte
00:B1EB 8500            	   930:   sta  REG       ; REG will be pushed
00:B1ED 4C73AF          	   931:   jmp  MAINP     ; push REG and go to MAIN
                        	   932: ;
                        	   933: ;  Load a 3-byte value (variable) onto the stack
                        	   934: ;
                        	   935: EX_LOD:
00:B1F0 20C5AF          	   936:   jsr  GETADR
                        	   937: EX_LOD2:
00:B1F3 A000            	   938:   ldy  #0
00:B1F5 B13D            	   939:   lda  (DATA),Y    ; (DATA) contains the variable value
00:B1F7 8500            	   940:   sta  REG
00:B1F9 C8              	   941:   iny
00:B1FA B13D            	   942:   lda  (DATA),Y
00:B1FC 8501            	   943:   sta  REG+1
00:B1FE C8              	   944:   iny
00:B1FF B13D            	   945:   lda  (DATA),Y
00:B201 8502            	   946:   sta REGB
00:B203 4C73AF          	   947:   jmp MAINP   ; push it
                        	   948: 
                        	   949: ;
                        	   950: ;  Load absolute address character
                        	   951: ;
                        	   952: EX_LDAC:
00:B206 200CB0          	   953:   jsr  PULTOP
00:B209 853D            	   954:   sta  DATA
00:B20B 863E            	   955:   stx  DATA+1
00:B20D A000            	   956:   ldy  #0
00:B20F F0D2            	   957:   beq  EX_LOD3_A
                        	   958: ;
                        	   959: ;  Load absolute address integer
                        	   960: ;
                        	   961: EX_LDA:
00:B211 200CB0          	   962:   jsr  PULTOP
00:B214 853D            	   963:   sta  DATA
00:B216 863E            	   964:   stx  DATA+1
00:B218 4CF3B1          	   965:   jmp  EX_LOD2
                        	   966: ;
                        	   967: ;  Get address of indexed character
                        	   968: ;
                        	   969: GETIDC:
00:B21B 2031B0          	   970:   jsr  PULTOP2    ; pull index into REG2
00:B21E 20C5AF          	   971:   jsr  GETADR
00:B221 4C38B2          	   972:   jmp  GETID2
                        	   973: ;
                        	   974: ;  Get address of indexed integer
                        	   975: ;
                        	   976: GETIDX   =  *
00:B224 2031B0          	   977:   jsr  PULTOP2  ; pull index into REG2
00:B227 0603            	   978:   asl  REG2     ; now multiply by 3
00:B229 2604            	   979:   rol  REG2+1
00:B22B 18              	   980:   clc
00:B22C 6503            	   981:   adc  REG2
00:B22E 8503            	   982:   sta  REG2
00:B230 8A              	   983:   txa
00:B231 6504            	   984:   adc  REG2+1
00:B233 8504            	   985:   sta  REG2+1     ; TIMES 3
00:B235 20C5AF          	   986:   jsr  GETADR
                        	   987: ;
                        	   988: ;  Get address of indexed integer/character
                        	   989: ;
                        	   990: ;  It looks like arrays expand downwards
                        	   991: ;
                        	   992: GETID2:
00:B238 A53D            	   993:   lda  DATA     ; initial address
00:B23A 38              	   994:   sec           ; subtract subscript
00:B23B E503            	   995:   sbc  REG2
00:B23D 853D            	   996:   sta  DATA
00:B23F A53E            	   997:   lda  DATA+1
00:B241 E504            	   998:   sbc  REG2+1
00:B243 853E            	   999:   sta  DATA+1
00:B245 60              	  1000:   rts
                        	  1001: ;
                        	  1002: ;  Load indexed character
                        	  1003: ;
                        	  1004: EX_LDIC:
00:B246 201BB2          	  1005:   jsr  GETIDC
00:B249 4CE1B1          	  1006:   jmp  EX_LOD3
                        	  1007: ;
                        	  1008: ;  Load indexed integer
                        	  1009: ;
                        	  1010: EX_LDI:
00:B24C 2024B2          	  1011:   jsr  GETIDX
00:B24F 4CF3B1          	  1012:   jmp  EX_LOD2
                        	  1013: ;
                        	  1014: ;  Store character
                        	  1015: ;
                        	  1016: EX_STOC:
00:B252 20C5AF          	  1017:   jsr  GETADR
00:B255 200CB0          	  1018:   jsr  PULTOP
00:B258 A002            	  1019:   ldy  #2   ; why?
                        	  1020: EX_STO5:
00:B25A 913D            	  1021:   sta  (DATA),Y
00:B25C 4C76AF          	  1022:   jmp  MAIN
                        	  1023: ;
                        	  1024: ;  Store integer
                        	  1025: ;
                        	  1026: EX_STO:
00:B25F 20C5AF          	  1027:   jsr  GETADR   ; get its address
00:B262 200CB0          	  1028:   jsr  PULTOP   ; get the value to store
                        	  1029: EX_STO2:
00:B265 A000            	  1030:   ldy  #0
00:B267 913D            	  1031:   sta  (DATA),Y
00:B269 C8              	  1032:   iny
00:B26A 8A              	  1033:   txa
00:B26B 913D            	  1034:   sta  (DATA),Y
00:B26D A502            	  1035:   lda  REGB
00:B26F C8              	  1036:   iny
00:B270 D0E8            	  1037:   bne  EX_STO5
                        	  1038: ;
                        	  1039: ;  Store integer at absolute address
                        	  1040: ;
                        	  1041: EX_STA:
00:B272 202EB0          	  1042:   jsr  PULBOTH  ; get address into REG2 and value into REG
00:B275 A000            	  1043:   ldy  #0
00:B277 A500            	  1044:   lda  REG
00:B279 9103            	  1045:   sta  (REG2),Y
00:B27B C8              	  1046:   iny
00:B27C A501            	  1047:   lda  REG+1
00:B27E 9103            	  1048:   sta  (REG2),Y
00:B280 C8              	  1049:   iny
00:B281 A502            	  1050:   lda  REGB
                        	  1051: EX_STA5:
00:B283 9103            	  1052:   sta  (REG2),Y
00:B285 4C76AF          	  1053:   jmp  MAIN
                        	  1054: ;
                        	  1055: ;  Store character at absolute address
                        	  1056: ;
                        	  1057: EX_STAC:
00:B288 202EB0          	  1058:   jsr  PULBOTH  ; get address into REG2 and value into REG
00:B28B A500            	  1059:   lda  REG
00:B28D A000            	  1060:   ldy  #0
00:B28F F0F2            	  1061:   beq  EX_STA5
                        	  1062: ;
                        	  1063: ;     Store character indexed
                        	  1064: ;
                        	  1065: EX_STIC:
00:B291 200CB0          	  1066:   jsr  PULTOP
00:B294 8545            	  1067:   sta  TEMP
00:B296 201BB2          	  1068:   jsr  GETIDC
00:B299 A545            	  1069:   lda  TEMP
00:B29B A002            	  1070:   ldy  #2
00:B29D D0BB            	  1071:   bne  EX_STO5
                        	  1072: ;
                        	  1073: ;     Store integer indexed
                        	  1074: ;
                        	  1075: EX_STI :
00:B29F 200CB0          	  1076:   jsr  PULTOP
00:B2A2 8545            	  1077:   sta  TEMP
00:B2A4 8646            	  1078:   stx  TEMP+1
00:B2A6 98              	  1079:   tya
00:B2A7 48              	  1080:   pha
00:B2A8 2024B2          	  1081:   jsr  GETIDX
00:B2AB A000            	  1082:   ldy  #0
00:B2AD A545            	  1083:   lda  TEMP
00:B2AF 913D            	  1084:   sta  (DATA),Y
00:B2B1 A546            	  1085:   lda  TEMP+1
00:B2B3 C8              	  1086:   iny
00:B2B4 913D            	  1087:   sta  (DATA),Y
00:B2B6 68              	  1088:   pla
00:B2B7 C8              	  1089:   iny
00:B2B8 D0A0            	  1090:   bne  EX_STO5
                        	  1091: ;
                        	  1092: ;  Procedure/function return
                        	  1093: ;
                        	  1094: ;  Stack frame linkage data:
                        	  1095: ;
                        	  1096: ;    (from low to high address)
                        	  1097: ;
                        	  1098: ;    Return address <-- P-code to return to when function/procedure exits
                        	  1099: ;    Dynamic link   <-- The previous stack frame from the earlier function call
                        	  1100: ;    Static link    <-- The stack frame of the previous static function
                        	  1101: ;
                        	  1102: ;  Static and dynamic links will be the same except for recursive calls.
                        	  1103: ;
                        	  1104: ;  To unwind the stack we have to go back to the previous dynamic link (on a return)
                        	  1105: ;
                        	  1106: ;  However to find variables in previous lexical declarations we have to use the static link.
                        	  1107: ;
                        	  1108: ;
                        	  1109: EX_RTN:
                        	  1110: ;
                        	  1111: ;  Subtract 6 from the base address, put result into WORK
                        	  1112: ;
00:B2BA 38              	  1113:   sec
00:B2BB A53B            	  1114:   lda  BASE
00:B2BD E906            	  1115:   sbc  #6
00:B2BF 8537            	  1116:   sta  WORK
00:B2C1 A53C            	  1117:   lda  BASE+1
00:B2C3 E900            	  1118:   sbc  #0
00:B2C5 8538            	  1119:   sta  WORK+1
                        	  1120: ;
                        	  1121: ;  The return address was at the bottom of BASE, so put that into PCODE
                        	  1122: ;
00:B2C7 A000            	  1123:   ldy  #0
00:B2C9 B137            	  1124:   lda  (WORK),Y
00:B2CB 8523            	  1125:   sta  PCODE
00:B2CD C8              	  1126:   iny
00:B2CE B137            	  1127:   lda  (WORK),Y
00:B2D0 8524            	  1128:   sta  PCODE+1
                        	  1129: 
                        	  1130: ;
                        	  1131: ;  The base address becomes our new top of runtime stack
                        	  1132: ;
00:B2D2 A53C            	  1133:   lda  BASE+1
00:B2D4 8532            	  1134:   sta  T+1
00:B2D6 A53B            	  1135:   lda  BASE
00:B2D8 8531            	  1136:   sta  T
                        	  1137: ;
                        	  1138: ;  The dynamic stack frame address is 4 bytes down from the BASE - put that into WORK
                        	  1139: ;
00:B2DA 38              	  1140:   sec
00:B2DB E904            	  1141:   sbc  #4
00:B2DD 8537            	  1142:   sta  WORK
00:B2DF A53C            	  1143:   lda  BASE+1
00:B2E1 E900            	  1144:   sbc  #0
00:B2E3 8538            	  1145:   sta  WORK+1
                        	  1146: ;
                        	  1147: ;  Get the previous dynamic stack frame address and put it into BASE (in case of
                        	  1148: ;   recursive function calls)
                        	  1149: ;
00:B2E5 A000            	  1150:   ldy  #0
00:B2E7 B137            	  1151:   lda  (WORK),Y
00:B2E9 853B            	  1152:   sta  BASE
00:B2EB C8              	  1153:   iny
00:B2EC B137            	  1154:   lda  (WORK),Y
00:B2EE 853C            	  1155:   sta  BASE+1
                        	  1156: ;
                        	  1157: ;  Stack, base and Pcode all changed, ready for next instruction
                        	  1158: ;
00:B2F0 4C76AF          	  1159:   jmp  MAIN
                        	  1160: 
                        	  1161: ;
                        	  1162: ; Input a number into a variable
                        	  1163: ;
                        	  1164: EX_INP      =  *
00:B2F3 A980            	  1165:   lda #$80
00:B2F5 853F            	  1166:   sta  RUNNING
00:B2F7 20A693          	  1167:   JSR  GET_LINE
00:B2FA AD0002          	  1168:   lda  INBUF
00:B2FD C903            	  1169:   cmp  #KEY_ABORT   ; check for aborting with Ctrl+C
00:B2FF D003            	  1170:   bne  EX_INP_OK
00:B301 4C4EB5          	  1171:   jmp  ex_input_aborted
                        	  1172: 
                        	  1173: EX_INP_OK:
00:B304 A900            	  1174:   lda #<INBUF
00:B306 858E            	  1175:   sta token_start
00:B308 A902            	  1176:   lda #>INBUF
00:B30A 858F            	  1177:   sta token_start+1
00:B30C 6493            	  1178:   stz token_type
00:B30E 2098C9          	  1179:   jsr get_token
00:B311 C94E            	  1180:   cmp #TOKEN_NUMBER
00:B313 D016            	  1181:   bne BAD_INP
00:B315 A694            	  1182:   LDX  token_value
00:B317 A495            	  1183:   LDY  token_value+1
00:B319 A596            	  1184:   LDA  token_value+2
                        	  1185: INP3:
00:B31B 8401            	  1186:   sty  REG+1
00:B31D 8600            	  1187:   stx  REG
00:B31F 8502            	  1188:   sta  REGB
00:B321 2053B0          	  1189:   jsr  PSHTOP
00:B324 A20C            	  1190:   ldx  #12
00:B326 863F            	  1191:   stx  RUNNING
00:B328 4C76AF          	  1192:   jmp  MAIN
                        	  1193: ;
                        	  1194: ;  bad number: set it to $800000
                        	  1195: ;
                        	  1196: BAD_INP:
00:B32B A980            	  1197:   lda #$80
00:B32D A200            	  1198:   ldx #0
00:B32F A000            	  1199:   ldy #0
00:B331 F0E8            	  1200:   beq INP3
                        	  1201: ;
                        	  1202: ; write a number to output
                        	  1203: ;
                        	  1204: EX_OUT:
00:B333 2002C9          	  1205:   jsr write_to_serial
00:B336 8003            	  1206:   bra OUT_COMMON
                        	  1207: 
                        	  1208: EX_LCD_WRITE_NUM:
00:B338 200DC9          	  1209:   jsr write_to_lcd
                        	  1210: 
                        	  1211: OUT_COMMON:
00:B33B 200CB0          	  1212:   jsr  PULTOP
00:B33E 207191          	  1213:   jsr  display_in_decimal
00:B341 2002C9          	  1214:   jsr  write_to_serial
00:B344 4C76AF          	  1215:   jmp  MAIN
                        	  1216: ;
                        	  1217: ;
                        	  1218: ; Output 6 hex characters (3 bytes)
                        	  1219: ;
                        	  1220: EX_OUH:
00:B347 2002C9          	  1221:   jsr write_to_serial
00:B34A 8003            	  1222:   bra EX_OUH_COMMON
                        	  1223: 
                        	  1224: EX_LCD_WRITE_HEX:
00:B34C 200DC9          	  1225:   jsr write_to_lcd
                        	  1226: 
                        	  1227: EX_OUH_COMMON:
00:B34F 200CB0          	  1228:   jsr  PULTOP
00:B352 A502            	  1229:   lda  REGB
00:B354 20BC92          	  1230:   jsr  PRBYTE
00:B357 A501            	  1231:   lda  REG+1
00:B359 20BC92          	  1232:   jsr  PRBYTE
00:B35C A500            	  1233:   lda  REG
00:B35E 20BC92          	  1234:   jsr  PRBYTE
00:B361 2002C9          	  1235:   jsr  write_to_serial
00:B364 4C76AF          	  1236:   jmp  MAIN
                        	  1237: ;
                        	  1238: ;  write a string to output
                        	  1239: ;
                        	  1240: EX_OUS      =  *
00:B367 2002C9          	  1241:   jsr write_to_serial
00:B36A 8003            	  1242:   bra EX_OUS_COMMON
                        	  1243: 
                        	  1244: EX_LCD_WRITE_STR:
00:B36C 200DC9          	  1245:   jsr write_to_lcd
                        	  1246: 
                        	  1247: EX_OUS_COMMON:
00:B36F A523            	  1248:   lda  PCODE
00:B371 18              	  1249:   clc
00:B372 6901            	  1250:   adc  #1
00:B374 8537            	  1251:   sta  WORK
00:B376 A524            	  1252:   lda  PCODE+1
00:B378 6900            	  1253:   adc  #0
00:B37A 8538            	  1254:   sta  WORK+1
00:B37C B123            	  1255:   lda  (PCODE),Y
00:B37E 854B            	  1256:   sta  COUNT1     ; NO. OF CHARS
00:B380 18              	  1257:   clc
00:B381 6901            	  1258:   adc  #1
00:B383 6523            	  1259:   adc  PCODE
00:B385 8523            	  1260:   sta  PCODE
00:B387 9002            	  1261:   bcc  EX_OUS1
00:B389 E624            	  1262:   inc  PCODE+1
                        	  1263: EX_OUS1:
00:B38B A537            	  1264:   lda  WORK
00:B38D A638            	  1265:   ldx  WORK+1
00:B38F A44B            	  1266:   ldy  COUNT1
00:B391 20D692          	  1267:   jsr  PT
00:B394 2002C9          	  1268:   jsr write_to_serial
00:B397 4C76AF          	  1269:   jmp  MAIN
                        	  1270: 
                        	  1271: 
                        	  1272: 
                        	  1273: ;
                        	  1274: ;  Stack frame linkage data:
                        	  1275: ;
                        	  1276: ;    (from low to high address)
                        	  1277: ;
                        	  1278: ;    Return address <-- P-code to return to when function/procedure exits
                        	  1279: ;    Dynamic link   <-- The previous stack frame from the earlier function call
                        	  1280: ;    Static link    <-- The stack frame of the previous static function
                        	  1281: ;
                        	  1282: ;  Static and dynamic links will be the same except for recursive calls.
                        	  1283: ;
                        	  1284: ;  To unwind the stack we have to go back to the previous dynamic link (on a return)
                        	  1285: ;
                        	  1286: ;  However to find variables in previous lexical declarations we have to use the static link.
                        	  1287: ;
                        	  1288: ;
                        	  1289: ; Call absolute procedure - I don't think this is used in this version TBH
                        	  1290: ;
                        	  1291: ; Note: Y is zero when entering
                        	  1292: ;
                        	  1293: EX_ABSCLL   =  *
00:B39A 8447            	  1294:   sty  CALL      ; zero out address to be called
00:B39C 8448            	  1295:   sty  CALL+1    ; (offset therefore becomes absolute address)
00:B39E 4CA9B3          	  1296:   jmp  EX_CLL_A
                        	  1297: ;
                        	  1298: ; Call relative procedure
                        	  1299: ;
                        	  1300: ; Note: Y is zero when entering
                        	  1301: ;
                        	  1302: EX_CLL      =  *
00:B3A1 A54D            	  1303:   lda  LASTP
00:B3A3 8547            	  1304:   sta  CALL
00:B3A5 A54E            	  1305:   lda  LASTP+1
00:B3A7 8548            	  1306:   sta  CALL+1
                        	  1307: EX_CLL_A    =  *
00:B3A9 B123            	  1308:   lda  (PCODE),Y     ; level
00:B3AB 854B            	  1309:   sta  COUNT1
00:B3AD C8              	  1310:   iny
00:B3AE 18              	  1311:   clc
00:B3AF B123            	  1312:   lda  (PCODE),Y     ; relative address
00:B3B1 6547            	  1313:   adc  CALL          ; add to current P-code address
00:B3B3 8547            	  1314:   sta  CALL
00:B3B5 C8              	  1315:   iny
00:B3B6 B123            	  1316:   lda  (PCODE),Y
00:B3B8 6548            	  1317:   adc  CALL+1
00:B3BA 8548            	  1318:   sta  CALL+1
00:B3BC A523            	  1319:   lda  PCODE         ; add 3 to P-code to bypass level / address
00:B3BE 18              	  1320:   clc                ; this will become our return address
00:B3BF 6903            	  1321:   adc  #3
00:B3C1 8523            	  1322:   sta  PCODE
00:B3C3 9002            	  1323:   bcc  EX_CLL4
00:B3C5 E624            	  1324:   inc  PCODE+1
                        	  1325: EX_CLL4     =  *
00:B3C7 A53C            	  1326:   lda  BASE+1
00:B3C9 A63B            	  1327:   ldx  BASE
                        	  1328: EX_CLL2     =  *
00:B3CB 853E            	  1329:   sta  DATA+1      ; this was BASE
00:B3CD 863D            	  1330:   stx  DATA
00:B3CF A8              	  1331:   tay
00:B3D0 A54B            	  1332:   lda  COUNT1      ; this was the level
00:B3D2 F018            	  1333:   beq  EX_CLL3
00:B3D4 38              	  1334:   sec
00:B3D5 8A              	  1335:   txa
00:B3D6 E902            	  1336:   sbc  #2          ; subtract 2 from BASE, store in WORK
00:B3D8 8537            	  1337:   sta  WORK
00:B3DA 98              	  1338:   tya
00:B3DB E900            	  1339:   sbc  #0
00:B3DD 8538            	  1340:   sta  WORK+1
00:B3DF A000            	  1341:   ldy  #0
00:B3E1 B137            	  1342:   lda  (WORK),Y
00:B3E3 C8              	  1343:   iny
00:B3E4 AA              	  1344:   tax
00:B3E5 B137            	  1345:   lda  (WORK),Y
00:B3E7 C64B            	  1346:   dec  COUNT1
00:B3E9 4CCBB3          	  1347:   jmp  EX_CLL2
                        	  1348: EX_CLL3     =  *
00:B3EC A531            	  1349:   lda  T         ; our stack pointer
00:B3EE 8545            	  1350:   sta  TEMP      ; save it
00:B3F0 A532            	  1351:   lda  T+1
00:B3F2 8546            	  1352:   sta  TEMP+1
                        	  1353: ;
                        	  1354: ; this is as confusing as all-get-out but it looks like we
                        	  1355: ; are pushing onto the stack: DATA / BASE / PCODE (return address)
                        	  1356: ;  (which is why we saved T into TEMP so it didn't change during the pushes)
                        	  1357: ;
                        	  1358: 
00:B3F4 A53D            	  1359:   lda  DATA      ; put DATA into REG
00:B3F6 8501            	  1360:   sta  REG+1
00:B3F8 A53E            	  1361:   lda  DATA+1
00:B3FA 8502            	  1362:   sta  REGB
00:B3FC A53C            	  1363:   lda  BASE+1
00:B3FE 8500            	  1364:   sta  REG
00:B400 2053B0          	  1365:   jsr  PSHTOP      ; push REG (DATA + BASE[1])
00:B403 A53B            	  1366:   lda  BASE
00:B405 8502            	  1367:   sta  REGB
00:B407 A545            	  1368:   lda  TEMP        ; old stack pointer
00:B409 853B            	  1369:   sta  BASE        ; becomes BASE
00:B40B A546            	  1370:   lda  TEMP+1      ; ditto for other byte
00:B40D 853C            	  1371:   sta  BASE+1
00:B40F A523            	  1372:   lda  PCODE       ; get ready to push current P-Code
00:B411 8500            	  1373:   sta  REG
00:B413 A524            	  1374:   lda  PCODE+1
00:B415 8501            	  1375:   sta  REG+1
00:B417 2053B0          	  1376:   jsr  PSHTOP     ; push REG (BASE[0] + PCODE)
00:B41A A547            	  1377:   lda  CALL       ; now get the address of the place we want to call
00:B41C 8523            	  1378:   sta  PCODE      ; and put it into PCODE
00:B41E A548            	  1379:   lda  CALL+1
00:B420 8524            	  1380:   sta  PCODE+1
00:B422 18              	  1381:   clc             ; add 6 to the stack pointer because we later emit the code to INT 6 (leave room for base stuff)
00:B423 A531            	  1382:   lda  T
00:B425 6906            	  1383:   adc  #6
00:B427 8531            	  1384:   sta  T
00:B429 9002            	  1385:   bcc  EX_CLL5
00:B42B E632            	  1386:   inc  T+1
                        	  1387: EX_CLL5     =  *
00:B42D 4C76AF          	  1388:   jmp  MAIN        ; we are done, MAIN will now go to the called subroutine
                        	  1389: ;
                        	  1390: ;  Here for calling machine code from Pascal
                        	  1391: ;
                        	  1392: EX_CLA:
00:B430 200CB0          	  1393:   jsr  PULTOP      ; pull the address to be called from the stack
00:B433 A513            	  1394:   lda  call_p      ; status register
00:B435 48              	  1395:   pha
00:B436 A510            	  1396:   lda  call_a      ; A register
00:B438 A611            	  1397:   ldx  call_x      ; X register
00:B43A A412            	  1398:   ldy  call_y      ; Y register
00:B43C 28              	  1399:   plp              ; get status register back
00:B43D 204DB4          	  1400:   jsr  EX_CLL_JMP  ; call the subroutine
00:B440 08              	  1401:   php              ; save the status register
00:B441 8510            	  1402:   sta  call_a      ; store the A/X/Y register
00:B443 8611            	  1403:   stx  call_x
00:B445 8412            	  1404:   sty  call_y
00:B447 68              	  1405:   pla              ; get status register back
00:B448 8513            	  1406:   sta  call_p      ; save it
00:B44A 4C76AF          	  1407:   jmp  MAIN        ; done!
                        	  1408: 
00:B44D 6C0000          	  1409: EX_CLL_JMP  jmp  (REG)
                        	  1410: ;
                        	  1411: ;
                        	  1412: ; increment stack pointer (that is, subtract the literal from it, as it grows downwards)
                        	  1413: ;
                        	  1414: EX_INT:
00:B450 206FB0          	  1415:   jsr  GETLIT
00:B453 38              	  1416:   sec
00:B454 A531            	  1417:   lda  T
00:B456 E500            	  1418:   sbc  REG
00:B458 8531            	  1419:   sta  T
00:B45A A532            	  1420:   lda  T+1
00:B45C E501            	  1421:   sbc  REG+1
00:B45E 8532            	  1422:   sta  T+1
00:B460 C544            	  1423:   cmp  END_PCD+1
00:B462 9003            	  1424:   bcc  INT_ERR
00:B464 4C76AF          	  1425:   jmp  MAIN
                        	  1426: ;
                        	  1427: INT_ERR  =  *
00:B467 A96E            	  1428:   lda  #<INT_ERRM    ; stack full
00:B469 A2B4            	  1429:   ldx  #>INT_ERRM
00:B46B 4CB8AF          	  1430:   jmp  NOTIM1
                        	  1431: ;
00:B46E 537461636B206675	  1432: INT_ERRM asciiz "Stack full\n"    ; stack full
00:B476 6C6C0A
00:B479 00
                        	  1433: ;
                        	  1434: 
                        	  1435: ;
                        	  1436: ;  Change the runtime stack to the address given (assuming stack is empty)
                        	  1437: ;   Done by the {%S nnnn} compiler directive.
                        	  1438: ;
                        	  1439: EX_NEW_STACK:
00:B47A 206FB0          	  1440:   jsr GETLIT
00:B47D A500            	  1441:   lda REG
00:B47F 8531            	  1442:   sta T
00:B481 853B            	  1443:   sta BASE
00:B483 A501            	  1444:   lda REG+1
00:B485 8532            	  1445:   sta T+1
00:B487 853C            	  1446:   sta BASE+1
00:B489 4C76AF          	  1447:   jmp MAIN
                        	  1448: 
                        	  1449: ;
                        	  1450: ;  Jump to the address following the P-code
                        	  1451: ;
                        	  1452: EX_JMP:
00:B48C 206FB0          	  1453:   jsr  GETLIT   ; get the address
00:B48F 18              	  1454:   clc
00:B490 A500            	  1455:   lda  REG
00:B492 654D            	  1456:   adc  LASTP
00:B494 8523            	  1457:   sta  PCODE
00:B496 A501            	  1458:   lda  REG+1
00:B498 654E            	  1459:   adc  LASTP+1
00:B49A 8524            	  1460:   sta  PCODE+1
00:B49C 4C76AF          	  1461:   jmp  MAIN
                        	  1462: ;
                        	  1463: ;  Jump if the top of the stack is zero
                        	  1464: ;
                        	  1465: EX_JMZ:
00:B49F 200CB0          	  1466:   jsr  PULTOP   ; puts REG into A
00:B4A2 0501            	  1467:   ora  REG+1
00:B4A4 0502            	  1468:   ora  REGB
00:B4A6 D002            	  1469:   bne  EX_NOJUMP
00:B4A8 F0E2            	  1470:   beq  EX_JMP
                        	  1471: ;
                        	  1472: ;  Don't jump, just move past the address (TODO: just add 2?)
                        	  1473: ;
                        	  1474: EX_NOJUMP:
00:B4AA 206FB0          	  1475:   jsr  GETLIT
00:B4AD 4C76AF          	  1476:   jmp  MAIN
                        	  1477: ;
                        	  1478: ;  Jump if the top of the stack is non-zero
                        	  1479: ;
                        	  1480: EX_JM1:
00:B4B0 200CB0          	  1481:   jsr  PULTOP    ; puts REG into A
00:B4B3 0501            	  1482:   ora  REG+1
00:B4B5 0502            	  1483:   ora  REGB
00:B4B7 D0D3            	  1484:   bne  EX_JMP
00:B4B9 F0EF            	  1485:   beq  EX_NOJUMP
                        	  1486: ;
                        	  1487: ;
                        	  1488: EX_INPC:
00:B4BB 2018C9          	  1489:   jsr GETIN
00:B4BE C903            	  1490:   cmp  #KEY_ABORT   ; check for aborting with Ctrl+C
00:B4C0 D003            	  1491:   bne  EX_INPC_OK
00:B4C2 4C4EB5          	  1492:   jmp  ex_input_aborted
                        	  1493: 
                        	  1494: EX_INPC_OK:
00:B4C5 2037AF          	  1495:   jsr CHK_KBD
00:B4C8 B0F1            	  1496:   bcs EX_INPC
00:B4CA 8500            	  1497:   sta REG
00:B4CC A900            	  1498:   lda #0
00:B4CE 8501            	  1499:   sta REG+1
00:B4D0 8502            	  1500:   sta REGB
00:B4D2 4C73AF          	  1501:   jmp  MAINP
                        	  1502: ;
                        	  1503: EX_OUTC:
00:B4D5 2002C9          	  1504:   jsr write_to_serial
00:B4D8 8003            	  1505:   bra EX_OUTC_COMMON
                        	  1506: 
                        	  1507: EX_LCD_WRITE_CHR:
00:B4DA 200DC9          	  1508:   jsr write_to_lcd
                        	  1509: 
                        	  1510: EX_OUTC_COMMON:
00:B4DD 200CB0          	  1511:   jsr  PULTOP
00:B4E0 A500            	  1512:   lda  REG
00:B4E2 20CE93          	  1513:   jsr  COUT
00:B4E5 2002C9          	  1514:   jsr write_to_serial
00:B4E8 4C76AF          	  1515:   jmp  MAIN
                        	  1516:   ;
                        	  1517: 
                        	  1518: EX_LCDHOME:
00:B4EB 2000B9          	  1519:   jsr lcd_home
00:B4EE 4C76AF          	  1520:   JMP MAIN
                        	  1521: 
                        	  1522: 
                        	  1523: EX_LCDCLEAR:
00:B4F1 20F0B8          	  1524:   jsr lcd_clear_display
00:B4F4 4C76AF          	  1525:   JMP MAIN
                        	  1526: 
                        	  1527: EX_INS      =  *
00:B4F7 B123            	  1528:   lda  (PCODE),Y   ; wanted length
00:B4F9 8545            	  1529:   sta  TEMP
00:B4FB E623            	  1530:   inc  PCODE
00:B4FD D002            	  1531:   bne  EX_INS3
00:B4FF E624            	  1532:   inc  PCODE+1
                        	  1533: EX_INS3     =  *
00:B501 20A693          	  1534:   jsr  GET_LINE
00:B504 AD0002          	  1535:   lda  INBUF
00:B507 C903            	  1536:   cmp  #KEY_ABORT     ; check for them aborting the run on input
00:B509 F043            	  1537:   beq  ex_input_aborted
00:B50B 2037AF          	  1538:   jsr  CHK_KBD
00:B50E B0F1            	  1539:   bcs  EX_INS3      ; we turned on/off tracing etc, ignore this line
00:B510 98              	  1540:   tya               ; length of line
00:B511 18              	  1541:   clc
00:B512 6901            	  1542:   adc  #1        ; why?
00:B514 C545            	  1543:   cmp  TEMP
00:B516 9002            	  1544:   bcc  EX_INS1
00:B518 A545            	  1545:   lda  TEMP      ; use max allowed length rather than received length
                        	  1546: EX_INS1     =  *
00:B51A 8546            	  1547:   sta  TEMP+1    ; this is the length we are copying
00:B51C 20C5AF          	  1548:   jsr  GETADR    ; get address to put the line
00:B51F A003            	  1549:   ldy  #3        ; why?
00:B521 A200            	  1550:   ldx  #0
                        	  1551: ;
                        	  1552: ;  copying loop - arrays are stored downwards, so we subtract from DATA each time
                        	  1553: ;
                        	  1554: EX_INS2     =  *
00:B523 C63D            	  1555:   dec  DATA
00:B525 A53D            	  1556:   lda  DATA
00:B527 C9FF            	  1557:   cmp  #$FF
00:B529 D002            	  1558:   bne  EX_INS4
00:B52B C63E            	  1559:   dec  DATA+1
                        	  1560: EX_INS4     =  *
00:B52D BD0002          	  1561:   lda  INBUF,X
00:B530 913D            	  1562:   sta  (DATA),Y
00:B532 E8              	  1563:   inx
00:B533 C646            	  1564:   dec  TEMP+1      ; count of bytes to copy
00:B535 D0EC            	  1565:   bne  EX_INS2
00:B537 4C76AF          	  1566:   jmp  MAIN        ; stop now
                        	  1567:   ;
                        	  1568: 
00:B53A 0A45786563757469	  1569: execution_aborted_message asciiz "\nExecution aborted\n"
00:B542 6F6E2061626F7274
00:B54A 65640A
00:B54D 00
                        	  1570: 
                        	  1571: ex_input_aborted:
00:B54E A93A            	  1572:   lda #<execution_aborted_message
00:B550 A2B5            	  1573:   ldx #>execution_aborted_message
00:B552 4CB8AF          	  1574:   jmp NOTIM1
                        	  1575: ;
                        	  1576: ;
                        	  1577: EX_ADRNC    =  *
00:B555 20C5AF          	  1578:   jsr  GETADR
                        	  1579: EX_ADRNC2   =  *
00:B558 A53D            	  1580:   lda  DATA
00:B55A 18              	  1581:   clc
00:B55B 6902            	  1582:   adc  #2
00:B55D 853D            	  1583:   sta  DATA
00:B55F 9007            	  1584:   bcc  EX_ADRN2
00:B561 E63E            	  1585:   inc  DATA+1
00:B563 B003            	  1586:   bcs  EX_ADRN2
                        	  1587: EX_ADRNN    =  *
00:B565 20C5AF          	  1588:   jsr  GETADR
                        	  1589: EX_ADRN2    =  *
00:B568 A53D            	  1590:   lda  DATA
00:B56A 8500            	  1591:   sta  REG
00:B56C A53E            	  1592:   lda  DATA+1
00:B56E 8501            	  1593:   sta  REG+1
00:B570 4C73AF          	  1594:   jmp  MAINP
                        	  1595: ;
                        	  1596: EX_ADRAN    =  *
00:B573 2024B2          	  1597:   jsr  GETIDX
00:B576 4C68B5          	  1598:   jmp  EX_ADRN2
                        	  1599: ;
                        	  1600: EX_ADRAC    =  *
00:B579 201BB2          	  1601:    jsr  GETIDC
00:B57C 4C58B5          	  1602:    jmp  EX_ADRNC2
                        	  1603: ;
                        	  1604: ;
                        	  1605: ;
                        	  1606: 
                        	  1607: 
                        	  1608: ;
                        	  1609: ;  DIGITALREAD (pin) pin:0 to 15; pushes 0 or 1
                        	  1610: ;
                        	  1611: EX_DIGITALREAD = *
00:B57F 200CB0          	  1612:   jsr PULTOP  ; which pin
00:B582 20E5C8          	  1613:   jsr digitalread
00:B585 D003            	  1614:   bne EX_DIGITALREAD_ONE
00:B587 4C24B1          	  1615:   jmp FALSE
                        	  1616: EX_DIGITALREAD_ONE:
00:B58A 4C17B1          	  1617:   jmp TRUE    ; done
                        	  1618: 
                        	  1619: ;
                        	  1620: ;  LCDPOS (line, column)
                        	  1621: ;
                        	  1622: 
                        	  1623: EX_LCDPOS = *
00:B58D 200CB0          	  1624:   jsr PULTOP   ; x
00:B590 290F            	  1625:   and #$0F     ; max 15
00:B592 858C            	  1626:   sta hardware_work  ; save it
00:B594 200CB0          	  1627:   jsr PULTOP   ; y
00:B597 2901            	  1628:   and #1       ; can be 0 or 1
00:B599 F002            	  1629:   beq EX_LCDPOS_1
00:B59B A940            	  1630:   lda #$40
                        	  1631: EX_LCDPOS_1:
00:B59D 058C            	  1632:   ora hardware_work  ; or in the column
00:B59F 0980            	  1633:   ora #$80     ; command to set the address
00:B5A1 209CB8          	  1634:   jsr lcd_instruction
00:B5A4 4C76AF          	  1635:   jmp MAIN
                        	  1636: 
                        	  1637: ;
                        	  1638: ;  RANDOM
                        	  1639: ;
                        	  1640: EX_RANDOM:
00:B5A7 20F98F          	  1641:   jsr gen_random
00:B5AA A509            	  1642:   lda random
00:B5AC 8500            	  1643:   sta REG
00:B5AE A50A            	  1644:   lda random+1
00:B5B0 8501            	  1645:   sta REG+1
00:B5B2 A50B            	  1646:   lda random+2
00:B5B4 8502            	  1647:   sta REGB
00:B5B6 4C73AF          	  1648:   jmp MAINP
                        	  1649: 
                        	  1650: 
                        	  1651: ;
                        	  1652: ;  LATENCY
                        	  1653: ;
                        	  1654: EX_LATENCY:
00:B5B9 A50D            	  1655:   lda typing_latency
00:B5BB 8500            	  1656:   sta REG
00:B5BD A50E            	  1657:   lda typing_latency+1
00:B5BF 8501            	  1658:   sta REG+1
00:B5C1 A50F            	  1659:   lda typing_latency+2
00:B5C3 8502            	  1660:   sta REGB
00:B5C5 4C73AF          	  1661:   jmp MAINP
                        	  1662: 
                        	  1663: ; PULTOP puts stuff here thus:
                        	  1664: ;
                        	  1665: ;        LDA  REG
                        	  1666: ;        LDX  REG+1
                        	  1667: ;        LDY  REGB
                        	  1668: 
                        	  1669: EX_DELAY = *
00:B5C8 200CB0          	  1670:   JSR  PULTOP  ; get the time interval in ms
                        	  1671:   ; (Y = high-order byte, X = lo-order byte)
00:B5CB A600            	  1672:   ldx REG
00:B5CD A501            	  1673:   lda REG+1
00:B5CF 297F            	  1674:   and #$7F
00:B5D1 A8              	  1675:   tay
00:B5D2 20F490          	  1676:   jsr delay
00:B5D5 4C76AF          	  1677:   jmp MAIN
                        	  1678: 
                        	  1679: ;
                        	  1680: ;  RANDOMSEED
                        	  1681: ;
                        	  1682: EX_RANDOMSEED = *
00:B5D8 200CB0          	  1683:   JSR  PULTOP  ; get the seed
00:B5DB 850A            	  1684:   sta random+1
00:B5DD 860B            	  1685:   stx random+2
00:B5DF 840C            	  1686:   sty random+3
00:B5E1 A9FF            	  1687:   lda #$FF     ; ensure seed has some 1 bits
00:B5E3 8509            	  1688:   sta random
00:B5E5 4C76AF          	  1689:   jmp MAIN
                        	  1690: 
                        	  1691: ;
                        	  1692: ;  PINMODE (pin, mode) pin:0 to 15; mode: 0=read, 1=write
                        	  1693: ;
                        	  1694: EX_PINMODE = *
00:B5E8 200CB0          	  1695:   jsr PULTOP  ; the mode
00:B5EB AA              	  1696:   tax         ; input or output?
00:B5EC DA              	  1697:   phx         ; save the mode
00:B5ED 200CB0          	  1698:   jsr PULTOP  ; which pin
00:B5F0 FA              	  1699:   plx         ; get mode back
00:B5F1 2087C8          	  1700:   jsr pinmode ; pin in A, mode in X
00:B5F4 4C76AF          	  1701:   jmp MAIN    ; done
                        	  1702: 
                        	  1703: ;
                        	  1704: ;  DIGITALWRITE (pin, value) pin:0 to 15; value: 0 or 1
                        	  1705: ;
                        	  1706: EX_DIGITALWRITE = *
00:B5F7 200CB0          	  1707:   jsr PULTOP  ; the value
00:B5FA AA              	  1708:   tax         ;
00:B5FB DA              	  1709:   phx         ; save the value
00:B5FC 200CB0          	  1710:   jsr PULTOP  ; which pin
00:B5FF FA              	  1711:   plx         ; get mode back
00:B600 20B6C8          	  1712:   jsr digitalwrite ; pin in A, value in X
00:B603 4C76AF          	  1713:   jmp MAIN    ; done
                        	  1714: 
                        	  1715: EX_LIB_CALL:
00:B606 206FB0          	  1716:   JSR  GETLIT
00:B609 6C0000          	  1717:   jmp  (REG)
                        	  1718: 
                        	  1719: ;
                        	  1720: ;  Assert (expression)
                        	  1721: ;
                        	  1722: 
                        	  1723: EX_ASSERT:
00:B60C 200CB0          	  1724:   jsr PULTOP  ; the value
00:B60F A500            	  1725:   lda REG
00:B611 0501            	  1726:   ora REG+1
00:B613 0502            	  1727:   ora REGB
00:B615 D00A            	  1728:   bne EX_ASSERT_OK
00:B617 A93D            	  1729:   lda #<assertion_failed_message  ; "Assertion failed"
00:B619 A297            	  1730:   ldx #>assertion_failed_message
00:B61B 202682          	  1731:   jsr print
00:B61E 4CEDAE          	  1732:   jmp RUNERR
                        	  1733: 
                        	  1734: EX_ASSERT_OK:
00:B621 4C76AF          	  1735:   jmp MAIN
                        	  1736: 

Source: "gpascal.asm"
                        	   182:   .include "interrupts.inc"

Source: "interrupts.inc"
                        	     1: 
00:B624 0A42524B20657865	     2: break_message     asciiz "\nBRK executed at address $"
00:B62C 6375746564206174
00:B634 2061646472657373
00:B63C 2024
00:B63E 00
00:B63F 2C2041203D2024  	     3: a_equals_message  asciiz ", A = $"
00:B646 00
00:B647 2C2058203D2024  	     4: x_equals_message  asciiz ", X = $"
00:B64E 00
00:B64F 2C2059203D2024  	     5: y_equals_message  asciiz ", Y = $"
00:B656 00
00:B657 2C2050203D2024  	     6: p_equals_message  asciiz ", P = $"
00:B65E 00
00:B65F 2C2053203D2024  	     7: s_equals_message  asciiz ", S = $"
00:B666 00
00:B667 2C206964203D2024	     8: id_equals_message asciiz ", id = $"
00:B66F 00
                        	     9: 
                        	    10: ;--------------------------------------------------
                        	    11: ;  IRQ - here on BRK interrupt
                        	    12: ;--------------------------------------------------
                        	    13: brk_executed:
00:B670 8412            	    14:   sty call_y    ; save Y - we didn't touch that
00:B672 8614            	    15:   stx call_s    ; X still has the stack pointer in it
00:B674 FA              	    16:   plx           ; get X back
00:B675 8611            	    17:   stx call_x
00:B677 68              	    18:   pla           ; get A back
00:B678 8510            	    19:   sta call_a    ; save A
00:B67A 68              	    20:   pla           ; get the processor flags from the stack
00:B67B 8513            	    21:   sta call_p
00:B67D 68              	    22:   pla           ; low-order address of BRK
00:B67E 8515            	    23:   sta brk_address
00:B680 68              	    24:   pla           ; high order address of BRK
00:B681 8516            	    25:   sta brk_address+1
00:B683 58              	    26:   cli           ; allow interrupts now so we can print
                        	    27: 
                        	    28: ;
                        	    29: ;  display BRK info for the user
                        	    30: ;
                        	    31:   ;
                        	    32:   ;  subtract 2 from brk_address to get where it actually was
                        	    33:   ;
00:B684 38              	    34:   sec
00:B685 A515            	    35:   lda brk_address
00:B687 E902            	    36:   sbc #2
00:B689 8515            	    37:   sta brk_address
00:B68B A516            	    38:   lda brk_address+1
00:B68D E900            	    39:   sbc #0
00:B68F 8516            	    40:   sta brk_address+1
00:B691 A924            	    41:   lda #<break_message
00:B693 A2B6            	    42:   ldx #>break_message
00:B695 202682          	    43:   jsr print
00:B698 A516            	    44:   lda brk_address+1
00:B69A 20BC92          	    45:   jsr PRBYTE
00:B69D A515            	    46:   lda brk_address
00:B69F 20BC92          	    47:   jsr PRBYTE
                        	    48: ;
                        	    49: ;  show A, X, Y, P, S
                        	    50: ;
00:B6A2 A93F            	    51:   lda #<a_equals_message
00:B6A4 A2B6            	    52:   ldx #>a_equals_message
00:B6A6 202682          	    53:   jsr print
00:B6A9 A510            	    54:   lda call_a
00:B6AB 20BC92          	    55:   jsr PRBYTE
00:B6AE A947            	    56:   lda #<x_equals_message
00:B6B0 A2B6            	    57:   ldx #>x_equals_message
00:B6B2 202682          	    58:   jsr print
00:B6B5 A511            	    59:   lda call_x
00:B6B7 20BC92          	    60:   jsr PRBYTE
00:B6BA A94F            	    61:   lda #<y_equals_message
00:B6BC A2B6            	    62:   ldx #>y_equals_message
00:B6BE 202682          	    63:   jsr print
00:B6C1 A512            	    64:   lda call_y
00:B6C3 20BC92          	    65:   jsr PRBYTE
00:B6C6 A957            	    66:   lda #<p_equals_message
00:B6C8 A2B6            	    67:   ldx #>p_equals_message
00:B6CA 202682          	    68:   jsr print
00:B6CD A513            	    69:   lda call_p
00:B6CF 20BC92          	    70:   jsr PRBYTE
00:B6D2 A95F            	    71:   lda #<s_equals_message
00:B6D4 A2B6            	    72:   ldx #>s_equals_message
00:B6D6 202682          	    73:   jsr print
00:B6D9 A514            	    74:   lda call_s
00:B6DB 20BC92          	    75:   jsr PRBYTE
00:B6DE A967            	    76:   lda #<id_equals_message
00:B6E0 A2B6            	    77:   ldx #>id_equals_message
00:B6E2 202682          	    78:   jsr print
                        	    79: ;
                        	    80: ;  advance one byte to get the break ID (byte after the BRK)
                        	    81: ;
00:B6E5 E615            	    82:   inc brk_address
00:B6E7 D002            	    83:   bne brk_executed1
00:B6E9 E616            	    84:   inc brk_address+1
                        	    85: brk_executed1:
00:B6EB A000            	    86:   ldy #0
00:B6ED B115            	    87:   lda (brk_address),Y
00:B6EF 20BC92          	    88:   jsr PRBYTE
                        	    89: ;
                        	    90: ;  put brk_address back to where we should resume from
                        	    91: ;
00:B6F2 E615            	    92:   inc brk_address
00:B6F4 D002            	    93:   bne brk_executed2
00:B6F6 E616            	    94:   inc brk_address+1
                        	    95: brk_executed2:
                        	    96: 
00:B6F8 204792          	    97:   jsr CROUT
                        	    98: ;
                        	    99: ;  display stack
                        	   100: ;
00:B6FB A91C            	   101:   lda #<stack_message
00:B6FD A2B7            	   102:   ldx #>stack_message
00:B6FF 202682          	   103:   jsr print
00:B702 A514            	   104:   lda call_s
00:B704 18              	   105:   clc
00:B705 6906            	   106:   adc #6  ; the interrupt pushed 3 we pushed 2, plus the stack points to the first UNUSED spot
00:B707 AA              	   107:   tax
                        	   108: brk_executed3:
00:B708 BD0001          	   109:   lda $100,x
00:B70B DA              	   110:   phx
00:B70C 20BC92          	   111:   jsr PRBYTE
00:B70F 20D292          	   112:   jsr PUTSP
00:B712 FA              	   113:   plx
00:B713 E8              	   114:   inx
00:B714 D0F2            	   115:   bne brk_executed3
                        	   116: 
                        	   117: ;
                        	   118: ;  we are done now
                        	   119: ;
00:B716 204792          	   120:   jsr CROUT
00:B719 4C8282          	   121:   jmp main_prompt
                        	   122: 
00:B71C 537461636B3A20  	   123: stack_message asciiz "Stack: "
00:B723 00
                        	   124: 
00:B724 4C70B6          	   125: brk_executedJ jmp brk_executed
                        	   126: 
                        	   127: ;--------------------------------------------------
                        	   128: ;  IRQ - here on maskable interrupt
                        	   129: ;--------------------------------------------------
                        	   130: 
                        	   131: irq:
00:B727 48              	   132:   pha       ; save A and X
00:B728 DA              	   133:   phx
00:B729 BA              	   134:   tsx       ; get stack pointer
00:B72A E0FB            	   135:   cpx #$FB  ; should be lesss than $FB (since the interrupt pushed 3 and we pushed 2)
00:B72C 9006            	   136:   bcc irq1
00:B72E A21B            	   137:   ldx #27   ; ERROR: stack full
00:B730 58              	   138:   cli       ; allow interrupts or error won't print
00:B731 4C8397          	   139:   jmp ERROR
                        	   140: 
                        	   141: irq1:
00:B734 BD0301          	   142:   lda $103,X    ; this will be the processor flags on the stack (3 up from where we are now)
00:B737 2910            	   143:   and #$10      ; check BRK flag
00:B739 D0E9            	   144:   bne brk_executedJ
                        	   145: ;
                        	   146: ;  here for a hardware IRQ
                        	   147: ;
00:B73B ADFD7F          	   148:   lda VIA_IFR
00:B73E 2908            	   149:   and #VIA_FLAG_CB2        ; CB2 active edge
00:B740 D00A            	   150:   bne cb2_interrupt
                        	   151: 
00:B742 ADFD7F          	   152:   lda VIA_IFR
00:B745 2940            	   153:   and #VIA_FLAG_TIMER1     ; Time out of T1
00:B747 D034            	   154:   bne timer1_interrupt
                        	   155: 
                        	   156: 
                        	   157: ;
                        	   158: ;  we shouldn't get here, and if we do we will probably just loop servicing the interrupt
                        	   159: ;
                        	   160:   .if SERIAL_DEBUGGING
                        	   161: 
                        	   162:     lda #SERIAL_SPARE2_MASK
                        	   163:     tsb VIA_PORTA
                        	   164:     trb VIA_PORTA
                        	   165: 
                        	   166:   .endif  ; SERIAL_DEBUGGING
                        	   167: 
00:B749 4CACB7          	   168:   jmp irq_done
                        	   169: 
                        	   170: ;
                        	   171: ;  here for incoming start bit
                        	   172: ;
                        	   173: cb2_interrupt:
                        	   174: 
00:B74C 8DFE7F          	   175:   sta VIA_IER           ; turn off that interrupt
00:B74F 8DFD7F          	   176:   sta VIA_IFR           ; indicate we noticed it
                        	   177: 
00:B752 DA              	   178:   phx
00:B753 5A              	   179:   phy
                        	   180: 
00:B754 A208            	   181:   ldx #8              ; count of bits
00:B756 A030            	   182:   ldy #SERIAL_DELAY1  ; delay interval for first bit (allow for code above) TODO - probably needs to be less now
                        	   183: serial_in_loop:
                        	   184: ;
                        	   185: ; wait for bit time to be up
                        	   186: ;
00:B758 88              	   187:   dey
00:B759 D0FD            	   188:   bne serial_in_loop
                        	   189: 
                        	   190:   .if SERIAL_DEBUGGING
                        	   191:     lda #SERIAL_DEBUG1_MASK     ; toggle debug flag (2 cycles)
                        	   192:     tsb VIA_PORTA               ; (6 cycles)
                        	   193:     trb VIA_PORTA               ; (6 cycles)
                        	   194:   .else
00:B75B EA              	   195:     NOP    ; take the same time so the timing isn't thrown out
00:B75C EA              	   196:     NOP    ; 2 cycles each
00:B75D EA              	   197:     NOP
00:B75E EA              	   198:     NOP
00:B75F EA              	   199:     NOP
00:B760 EA              	   200:     NOP
00:B761 EA              	   201:     NOP    ; total of 14 cycles
                        	   202:   .endif  ; SERIAL_DEBUGGING
                        	   203: 
00:B762 ADF17F          	   204:   lda VIA_PORTA
00:B765 6A              	   205:   ror A                 ; put incoming bit into carry
00:B766 668A            	   206:   ror serial_in_byte    ; shift one bit in
00:B768 A023            	   207:   ldy #SERIAL_DELAY2    ; delay interval for remaining bits
00:B76A CA              	   208:   dex
00:B76B D0EB            	   209:   bne serial_in_loop
                        	   210: 
00:B76D 7A              	   211:   ply
00:B76E FA              	   212:   plx
                        	   213: ;
                        	   214: ;  re-enable interrupts on the falling edge
                        	   215: ;
00:B76F A988            	   216:   lda #VIA_FLAG_ENABLE | VIA_FLAG_CB2
00:B771 8DFE7F          	   217:   sta VIA_IER
00:B774 8DFD7F          	   218:   sta VIA_IFR   ; indicate we know about previous falling edges
                        	   219: 
                        	   220: ;
                        	   221: ;  move to place that we know it will be noticed
                        	   222: ;
00:B777 A58A            	   223:   lda serial_in_byte
00:B779 858B            	   224:   sta serial_in_byte_received
                        	   225: 
00:B77B 802F            	   226:   bra irq_done
                        	   227: 
                        	   228: ;
                        	   229: ;  here for time to send another outgoing bit
                        	   230: ;
                        	   231: timer1_interrupt :
                        	   232: 
00:B77D 8DFD7F          	   233:   sta VIA_IFR           ; indicate we noticed it
00:B780 A589            	   234:   lda serial_out_bit    ; are we in fact sending a byte?
00:B782 F028            	   235:   beq irq_done          ; no, just exit
                        	   236: 
                        	   237:   .if SERIAL_DEBUGGING
                        	   238: 
                        	   239:   lda #SERIAL_DEBUG2_MASK     ; toggle debug flag (2 cycles)
                        	   240:   tsb VIA_PORTA               ; wash on   (6 cycles)
                        	   241:   trb VIA_PORTA               ; wash off  (6 cycles)
                        	   242:                               ; now, sand the floor
                        	   243:  .else
00:B784 EA              	   244:      NOP    ; take the same time so the timing isn't thrown out
00:B785 EA              	   245:      NOP    ; 2 cycles each
00:B786 EA              	   246:      NOP
00:B787 EA              	   247:      NOP
00:B788 EA              	   248:      NOP
00:B789 EA              	   249:      NOP
00:B78A EA              	   250:      NOP    ; total of 14 cycles
                        	   251:   .endif  ; SERIAL_DEBUGGING
                        	   252: 
00:B78B 6688            	   253:   ror serial_out_byte+1  ; we don't care about the high-order bit
00:B78D 6687            	   254:   ror serial_out_byte    ; get the low-order bit into Carry
00:B78F 9007            	   255:   bcc write_zero
00:B791 A902            	   256:   lda #SERIAL_OUT_MASK   ; (send a 1 bit)
00:B793 0DF17F          	   257:   ora VIA_PORTA
00:B796 8005            	   258:   bra serial_send_count_bits
                        	   259: 
                        	   260: write_zero:
00:B798 A9FD            	   261:   lda #~SERIAL_OUT_MASK  ; (send a 0 bit)
00:B79A 2DF17F          	   262:   and VIA_PORTA
                        	   263: 
                        	   264: serial_send_count_bits:
00:B79D 8DF17F          	   265:   sta VIA_PORTA          ; output this bit
00:B7A0 C689            	   266:   dec serial_out_bit     ; remember bit count for later
00:B7A2 D008            	   267:   bne irq_done
                        	   268: 
                        	   269: ; here when all bits have been sent
                        	   270: ; disable the timer as we don't need it any more
                        	   271: ; and this will be a flag that we can send another byte
                        	   272: 
00:B7A4 A940            	   273:   lda #VIA_FLAG_DISABLE | VIA_FLAG_TIMER1  ; cancel interrupt on T1 timeout
00:B7A6 8DFE7F          	   274:   sta VIA_IER
00:B7A9 ADF47F          	   275:   lda VIA_T1C_L     ; clear interrupt flag
                        	   276: 
                        	   277: irq_done:
00:B7AC FA              	   278:   plx   ; restore X
00:B7AD 68              	   279:   pla   ; restore A
00:B7AE 40              	   280:   rti
                        	   281: 

Source: "gpascal.asm"
                        	   183:   .include "lcd.inc"

Source: "lcd.inc"
                        	     1:   .if !EMULATOR
                        	     2:   .if LCD_SUPPORT
                        	     3: 
                        	     4: ;
                        	     5: ;  LCD stuff
                        	     6: ;
                        	     7: 
                        	     8: lcd_initialise:
                        	     9: ;
                        	    10: ;  LCD initialise
                        	    11: ;
                        	    12: 
00:B7AF ADF37F          	    13:   lda VIA_DDRA
00:B7B2 09E0            	    14:   ora #(LCD_RW|LCD_RS|LCD_E)    ; set appropriate pins on Port A to output
00:B7B4 8DF37F          	    15:   sta VIA_DDRA
                        	    16: 
                        	    17:   ; see HD44780U documentation: "Initializing by Instruction" (page 46)
00:B7B7 2030B8          	    18:   jsr lcd_prepare_to_write_instruction
00:B7BA A930            	    19:   lda #$30
00:B7BC 2090B8          	    20:   jsr lcd_write_instruction_nibble
                        	    21:   ; wait > 4.1 ms
00:B7BF A214            	    22:   ldx #20
00:B7C1 A000            	    23:   ldy #0
00:B7C3 20F490          	    24:   jsr delay      ; 20 ms delay (in case of faster board clock speeds)
00:B7C6 2090B8          	    25:   jsr lcd_write_instruction_nibble
00:B7C9 20EA90          	    26:   jsr delay_1ms  ; do it 4 times in case of faster board clock speeds
00:B7CC 20EA90          	    27:   jsr delay_1ms
00:B7CF 20EA90          	    28:   jsr delay_1ms
00:B7D2 20EA90          	    29:   jsr delay_1ms
00:B7D5 2090B8          	    30:   jsr lcd_write_instruction_nibble
00:B7D8 20EA90          	    31:   jsr delay_1ms  ; do it 4 times in case of faster board clock speeds
00:B7DB 20EA90          	    32:   jsr delay_1ms
00:B7DE 20EA90          	    33:   jsr delay_1ms
00:B7E1 20EA90          	    34:   jsr delay_1ms
00:B7E4 A920            	    35:   lda #$20    ; switch to 4-bit mode
00:B7E6 2090B8          	    36:   jsr lcd_write_instruction_nibble
00:B7E9 20EA90          	    37:   jsr delay_1ms  ; do it 4 times in case of faster board clock speeds
00:B7EC 20EA90          	    38:   jsr delay_1ms
00:B7EF 20EA90          	    39:   jsr delay_1ms
00:B7F2 20EA90          	    40:   jsr delay_1ms
                        	    41: ;
                        	    42: ;  now we can switch to sending 8-bits in two nibbles
                        	    43: ;
00:B7F5 A928            	    44:   lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
00:B7F7 209CB8          	    45:   jsr lcd_instruction
00:B7FA A90C            	    46:   lda #%00001100 ; DCB: Display on; cursor off; blink off
00:B7FC 209CB8          	    47:   jsr lcd_instruction
00:B7FF A906            	    48:   lda #%00000110 ; Increment and shift cursor; don't shift display
00:B801 209CB8          	    49:   jsr lcd_instruction
00:B804 20F0B8          	    50:   jsr lcd_clear_display
00:B807 60              	    51:   rts
                        	    52: 
                        	    53: lcd_prepare_to_read_register:
00:B808 ADF17F          	    54:   lda VIA_PORTA
00:B80B 0940            	    55:   ora #LCD_RW             ; set RW bit  (ie. enable reading)
00:B80D 295F            	    56:   and #<(~(LCD_RS|LCD_E)) ; Clear RS/E bits
00:B80F 8DF17F          	    57:   sta VIA_PORTA
00:B812 ADF27F          	    58:   lda VIA_DDRB
00:B815 290F            	    59:   and #$0F
00:B817 8DF27F          	    60:   sta VIA_DDRB            ; we are reading from DDRB
00:B81A 60              	    61:   rts
                        	    62: 
                        	    63: lcd_prepare_to_write_data:
00:B81B 48              	    64:   pha
00:B81C ADF17F          	    65:   lda VIA_PORTA
00:B81F 293F            	    66:   and #<(~(LCD_RW|LCD_E))  ; clear RW and E (enable writing)
00:B821 0920            	    67:   ora #LCD_RS              ; setting this means we write a character
00:B823 8DF17F          	    68:   sta VIA_PORTA
00:B826 ADF27F          	    69:   lda VIA_DDRB
00:B829 09F0            	    70:   ora #$F0      ; Set high-order pins on port B to output
00:B82B 8DF27F          	    71:   sta VIA_DDRB
00:B82E 68              	    72:   pla
00:B82F 60              	    73:   rts
                        	    74: 
                        	    75: lcd_prepare_to_write_instruction:
00:B830 48              	    76:   pha
00:B831 ADF17F          	    77:   lda VIA_PORTA
00:B834 291F            	    78:   and #<(~(LCD_RW|LCD_RS|LCD_E))  ; clear RW, RS and E (enable writing)
00:B836 8DF17F          	    79:   sta VIA_PORTA
00:B839 ADF27F          	    80:   lda VIA_DDRB
00:B83C 09F0            	    81:   ora #$F0      ; Set high-order pins on port B to output
00:B83E 8DF27F          	    82:   sta VIA_DDRB
00:B841 68              	    83:   pla
00:B842 60              	    84:   rts
                        	    85: 
                        	    86: lcd_set_enable:
00:B843 ADF17F          	    87:   lda VIA_PORTA
00:B846 0980            	    88:   ora #LCD_E
00:B848 8DF17F          	    89:   sta VIA_PORTA   ; Set enable (E)
00:B84B 60              	    90:   rts
                        	    91: 
                        	    92: lcd_clear_enable:
00:B84C ADF17F          	    93:   lda VIA_PORTA
00:B84F 297F            	    94:   and #<(~LCD_E)  ; Clear enable (E)
00:B851 8DF17F          	    95:   sta VIA_PORTA
00:B854 60              	    96:   rts
                        	    97: 
                        	    98: lcd_read_instruction_nibble:
00:B855 2043B8          	    99:   jsr lcd_set_enable
00:B858 ADF07F          	   100:   lda VIA_PORTB   ; read the data on port B
00:B85B 48              	   101:   pha             ; save the data
00:B85C 204CB8          	   102:   jsr lcd_clear_enable
00:B85F 68              	   103:   pla             ; get the data back
00:B860 60              	   104:   rts
                        	   105: 
                        	   106: ;
                        	   107: ; wait until LCD is not busy
                        	   108: ;
                        	   109: lcd_wait:
00:B861 DA              	   110:   phx
00:B862 5A              	   111:   phy
00:B863 48              	   112:   pha
00:B864 2008B8          	   113:   jsr lcd_prepare_to_read_register
00:B867 A200            	   114:   ldx #0
                        	   115: lcdbusy:
                        	   116: ;
                        	   117: ;  timeout after 256 iterations of this loop so we don't hang
                        	   118: ;  if there is no LCD or it doesn't respond
                        	   119: ;
00:B869 CA              	   120:   dex
00:B86A F00C            	   121:   beq lcd_wait_timeout
00:B86C 2055B8          	   122:   jsr lcd_read_instruction_nibble
00:B86F 2980            	   123:   and #$80        ; get busy flag
00:B871 A8              	   124:   tay             ; save busy status
00:B872 2055B8          	   125:   jsr lcd_read_instruction_nibble   ; do second nibble
00:B875 98              	   126:   tya             ; get busy status back
00:B876 D0F1            	   127:   bne lcdbusy     ; if busy go back
                        	   128: ;
                        	   129: ;  here when not busy any more
                        	   130: ;
                        	   131: lcd_wait_timeout:
00:B878 68              	   132:   pla
00:B879 7A              	   133:   ply
00:B87A FA              	   134:   plx
00:B87B 60              	   135:   rts
                        	   136: 
                        	   137: ;
                        	   138: ;  Find the current LCD (cursor) address - useful for knowing
                        	   139: ;  if we exceed the limit of line 1
                        	   140: ;
                        	   141: lcd_get_address:
00:B87C 2008B8          	   142:   jsr lcd_prepare_to_read_register
00:B87F 2055B8          	   143:   jsr lcd_read_instruction_nibble
00:B882 2970            	   144:   and #$70        ; ignore busy bit, mask out other junk
00:B884 8586            	   145:   sta lcd_work
00:B886 2055B8          	   146:   jsr lcd_read_instruction_nibble
00:B889 4A              	   147:   lsr A   ; shift this lot into low-order bits
00:B88A 4A              	   148:   lsr A
00:B88B 4A              	   149:   lsr A
00:B88C 4A              	   150:   lsr A
00:B88D 0586            	   151:   ora lcd_work    ; get the high-order bits back
00:B88F 60              	   152:   rts
                        	   153: 
                        	   154: lcd_write_instruction_nibble:
00:B890 48              	   155:   pha
00:B891 8DF07F          	   156:   sta VIA_PORTB         ; set up the data
00:B894 2043B8          	   157:   jsr lcd_set_enable    ; toggle enable
00:B897 204CB8          	   158:   jsr lcd_clear_enable
00:B89A 68              	   159:   pla
00:B89B 60              	   160:   rts
                        	   161: 
                        	   162: ;
                        	   163: ;  send an instruction to the LCD
                        	   164: ;
                        	   165: lcd_instruction:
00:B89C 2061B8          	   166:   jsr lcd_wait
00:B89F 2030B8          	   167:   jsr lcd_prepare_to_write_instruction
00:B8A2 2090B8          	   168:   jsr lcd_write_instruction_nibble
00:B8A5 48              	   169:   pha
00:B8A6 0A              	   170:   asl a   ; move the low-order bits into the high-order bits
00:B8A7 0A              	   171:   asl a   ; because the high-order 4 bits are the active ones
00:B8A8 0A              	   172:   asl a
00:B8A9 0A              	   173:   asl a
00:B8AA 2090B8          	   174:   jsr lcd_write_instruction_nibble
00:B8AD 68              	   175:   pla
00:B8AE 60              	   176:   rts
                        	   177: 
                        	   178: lcd_data_nibble:
00:B8AF 48              	   179:   pha
00:B8B0 201BB8          	   180:   jsr lcd_prepare_to_write_data
00:B8B3 8DF07F          	   181:   sta VIA_PORTB
00:B8B6 2043B8          	   182:   jsr lcd_set_enable
00:B8B9 204CB8          	   183:   jsr lcd_clear_enable
00:B8BC 68              	   184:   pla
00:B8BD 60              	   185:   rts
                        	   186: 
                        	   187: ;
                        	   188: ;  print a character to the LCD
                        	   189: ;
                        	   190: lcd_print_char:
00:B8BE 2061B8          	   191:   jsr lcd_wait  ; wait for previous write to finish
00:B8C1 C90A            	   192:   cmp #NL
00:B8C3 D004            	   193:   bne lcd_print_not_newline ; newline jumps to 2nd line
00:B8C5 20F8B8          	   194:   jsr lcd_second_line       ; go to second line
00:B8C8 60              	   195:   rts                       ; and don't print the newline :)
                        	   196: 
                        	   197: lcd_print_not_newline:
00:B8C9 48              	   198:   pha                   ; save the character we want to print
00:B8CA 207CB8          	   199:   jsr lcd_get_address
00:B8CD C910            	   200:   cmp #16         ; 16 characters on the first line
00:B8CF 900E            	   201:   bcc lcd_print_char_ok ; not there yet
00:B8D1 D005            	   202:   bne lcd_print_char_on_2nd_line  ; not < 16 and not == 16, must be > 16
                        	   203:   ; we have exactly 16, so drop down to address 64
00:B8D3 20F8B8          	   204:   jsr lcd_second_line  ; at char 16 go to 2nd line (address 64)
00:B8D6 8007            	   205:   bra lcd_print_char_ok
                        	   206: 
                        	   207: lcd_print_char_on_2nd_line:
00:B8D8 C950            	   208:   cmp #80                  ; more than 16 characters on in 2nd line? (64 + 16)
00:B8DA 9003            	   209:   bcc lcd_print_char_ok    ; nah
00:B8DC 20F0B8          	   210:   jsr lcd_clear_display    ; yes, clear display then and start again
                        	   211: lcd_print_char_ok:
                        	   212: lcd_print_char_newline:
00:B8DF 201BB8          	   213:   jsr lcd_prepare_to_write_data
00:B8E2 68              	   214:   pla                      ; get the character back
00:B8E3 20AFB8          	   215:   jsr lcd_data_nibble
00:B8E6 48              	   216:   pha
00:B8E7 0A              	   217:   asl a     ; now send the low-order bits
00:B8E8 0A              	   218:   asl a
00:B8E9 0A              	   219:   asl a
00:B8EA 0A              	   220:   asl a
00:B8EB 20AFB8          	   221:   jsr lcd_data_nibble
00:B8EE 68              	   222:   pla
00:B8EF 60              	   223:   rts
                        	   224: 
                        	   225: lcd_clear_display:
00:B8F0 48              	   226:   pha
00:B8F1 A901            	   227:   lda #%00000001 ; Clear display
00:B8F3 209CB8          	   228:   jsr lcd_instruction
00:B8F6 68              	   229:   pla
00:B8F7 60              	   230:   rts
                        	   231: 
                        	   232: lcd_second_line:
00:B8F8 48              	   233:   pha
00:B8F9 A9C0            	   234:   lda #$C0 ; set output address to 0x40 (set DDRAM address)
00:B8FB 209CB8          	   235:   jsr lcd_instruction
00:B8FE 68              	   236:   pla
00:B8FF 60              	   237:   rts
                        	   238: 
                        	   239: lcd_home:
00:B900 48              	   240:   pha
00:B901 A980            	   241:   lda #$80 ; set output address to 0 (set DDRAM address)
00:B903 209CB8          	   242:   jsr lcd_instruction
00:B906 68              	   243:   pla
00:B907 60              	   244:   rts
                        	   245: 
                        	   246: 
                        	   247: ;
                        	   248: ;  print null-terminated message on LCD, message in A (lo) and X (hi)
                        	   249: ;  returns the length of the message in Y
                        	   250: ;
                        	   251: lcd_print_message:
00:B908 8503            	   252:   sta REG2
00:B90A 8604            	   253:   stx REG2+1
00:B90C A000            	   254:   ldy #0
00:B90E 20F0B8          	   255:   jsr lcd_clear_display
                        	   256: lcd_print:
00:B911 B103            	   257:   lda (REG2),y
00:B913 F006            	   258:   beq lcd_print_done
00:B915 20BEB8          	   259:   jsr lcd_print_char
00:B918 C8              	   260:   iny
00:B919 80F6            	   261:   bra lcd_print
                        	   262: 
00:B91B 60              	   263: lcd_print_done rts
                        	   264: 
                        	   265:   .else ; LCD_SUPPORT
                        	   266: 
                        	   267: lcd_print_char :
                        	   268: lcd_clear_display :
                        	   269: lcd_second_line:
                        	   270: lcd_print_message:
                        	   271: lcd_instruction:
                        	   272: lcd_get_address:
                        	   273: lcd_home:
                        	   274: lcd_wait:
                        	   275:     ldx #50     ; No LCD
                        	   276:     jmp ERROR
                        	   277: 
                        	   278: 
                        	   279:   .endif  ; (no) LCD_SUPPORT
                        	   280: 
                        	   281:   .endif  ; not emulator
                        	   282: 

Source: "gpascal.asm"
                        	   184:   .include "symbols.inc"

Source: "symbols.inc"
                        	     1: ;***********************************************
                        	     2: ; SYMBOL TABLE STUFF: Offsets from the start of a particular symbol
                        	     3: ; Stored as a linked list, where you search backwards so the more local one is found first
                        	     4: ;***********************************************
                        	     5: 
                        	     6: SYMPRV   =  0         ; address of previous symbol (for working backwards through symbols)
                        	     7: SYMLVL   =  2         ; nested level (eg. entering a procedure/function increments the level,
                        	     8:                       ;                   and leaving it decrements the level)
                        	     9:                       ; - used to detect duplicate symbols at the same level
                        	    10: SYMTYP   =  3         ; Symbol type: C = constant, V = variable, Y = function return value
                        	    11:                       ;              P = procedure, F = function, A = array
                        	    12:                       ;              p = library procedure, f = library function
                        	    13:                       ;  See defines below.
                        	    14: SYMDSP   =  4         ; if the symbol is a constant, what the value is (3 bytes)
                        	    15:                       ; if the symbol is a variable, array or function return then this is the offset (2 bytes)
                        	    16: SYMARG   =  6         ; if the symbol is a procedure/function, count of arguments (can be zero)
                        	    17: SYMSUB   =  6         ; MAX SUBSCRIPT+1 - for arrays, so this is the actual array length
                        	    18: SYMDAT   =  8         ; data type: 0 = integer, 1 = char
                        	    19: SYMLEN   =  9         ; length of the name, der
                        	    20: SYMNAM   =  10        ; name of symbol for SYMLEN characters, stored in upper-case
                        	    21: 
                        	    22: ;
                        	    23: ; Symbol types
                        	    24: ;
                        	    25: 
                        	    26: SYMBOL_CONSTANT          = 'C'
                        	    27: SYMBOL_VARIABLE          = 'V'
                        	    28: SYMBOL_FUNCTION_RETURN   = 'Y'
                        	    29: SYMBOL_PROCEDURE         = 'P'
                        	    30: SYMBOL_FUNCTION          = 'F'
                        	    31: SYMBOL_LIBRARY_PROCEDURE = 'Q'  ; library procedures and functions are implemented in assembler
                        	    32: SYMBOL_LIBRARY_FUNCTION  = 'R'
                        	    33: SYMBOL_ARRAY             = 'A'
                        	    34: 
                        	    35: 
                        	    36: 
                        	    37: ;
                        	    38: ;***********************************************
                        	    39: ;SEARCH SYMBOL TABLE - returns Z if not found (BEQ <not found>)
                        	    40: ;***********************************************
                        	    41: SEARCH   =  *
00:B91C A532            	    42:          lda  ENDSYM+1    ; get the end of the symbol table
00:B91E 8541            	    43:          sta  SYMITM+1    ; make it the current symbol
00:B920 A531            	    44:          lda  ENDSYM
00:B922 800B            	    45:          bra  SEA1
                        	    46: 
                        	    47: SEA_NEXT =  *
00:B924 A000            	    48:          ldy  #SYMPRV
00:B926 B140            	    49:          lda  (SYMITM),Y
00:B928 AA              	    50:          tax
00:B929 C8              	    51:          iny
00:B92A B140            	    52:          lda  (SYMITM),Y
00:B92C 8541            	    53:          sta  SYMITM+1   ; previous link
00:B92E 8A              	    54:          txa
                        	    55: ;
                        	    56: ;  go to the previous symbol table item
                        	    57: ;
                        	    58: SEA1     =  *
00:B92F 8540            	    59:          sta  SYMITM
00:B931 C52F            	    60:          cmp  STARTSYM
00:B933 D007            	    61:          bne  SEA2
00:B935 A541            	    62:          lda  SYMITM+1
00:B937 C530            	    63:          cmp  STARTSYM+1
00:B939 D001            	    64:          bne  SEA2       ; more to go
00:B93B 60              	    65:          rts             ; finished if we are back at the start of the symbol table
                        	    66: 
                        	    67: SEA2     =  *
00:B93C A009            	    68:          ldy  #SYMLEN
00:B93E B140            	    69:          lda  (SYMITM),Y  ; get this item's length
00:B940 C592            	    70:          cmp  token_length      ; compare to the token legnth we got
00:B942 D0E0            	    71:          bne  SEA_NEXT    ; wrong length - try another
00:B944 A540            	    72:          lda  SYMITM      ; back to this symbol's start address
00:B946 18              	    73:          clc
00:B947 690A            	    74:          adc  #SYMNAM     ; add the offset of the name to it
00:B949 8503            	    75:          sta  DEST
00:B94B A541            	    76:          lda  SYMITM+1
00:B94D 6900            	    77:          adc  #0
00:B94F 8504            	    78:          sta  DEST+1      ; the memory location of the symbol name is in DEST
00:B951 A590            	    79:          lda  token_address      ; now put the token's address into SRCE
00:B953 8500            	    80:          sta  SRCE
00:B955 A591            	    81:          lda  token_address+1
00:B957 8501            	    82:          sta  SRCE+1
00:B959 A492            	    83:          ldy  token_length
00:B95B 204C92          	    84:          jsr  COMSTL      ; compare SRCE to DEST
00:B95E D0C4            	    85:          bne  SEA_NEXT    ; not that one - try another
00:B960 20D8BA          	    86:          jsr  GET_DAT     ; get the symbol's data type into DATTYP
00:B963 A002            	    87:          ldy  #SYMLVL     ; and level - why isn't this a function, huh?
00:B965 B140            	    88:          lda  (SYMITM),Y
00:B967 AA              	    89:          tax              ; level into X
00:B968 A003            	    90:          ldy  #SYMTYP
00:B96A B140            	    91:          lda  (SYMITM),Y  ; get type of symbol
00:B96C 8536            	    92:          sta  BSAVE       ; symbol type -> BSAVE
00:B96E C943            	    93:          cmp  #SYMBOL_CONSTANT       ; constant?
00:B970 D013            	    94:          bne  SEA4        ; nah
                        	    95: ;
                        	    96: ;  symbol is a constant
                        	    97: ;
00:B972 A004            	    98:          ldy  #SYMDSP     ; if a constant, this is the value
00:B974 B140            	    99:          lda  (SYMITM),Y
00:B976 8594            	   100:          sta  token_value
00:B978 C8              	   101:          iny
00:B979 B140            	   102:          lda  (SYMITM),Y
00:B97B 8595            	   103:          sta  token_value+1
00:B97D C8              	   104:          iny
00:B97E B140            	   105:          lda  (SYMITM),Y
00:B980 8596            	   106:          sta  token_value+2     ; token_value (3 bytes) now has the value in it
00:B982 4C90B9          	   107:          jmp  SEA3
                        	   108: ;
                        	   109: ;  symbol is not a constant
                        	   110: ;
                        	   111: SEA4     =  *                           ; not constant
00:B985 C956            	   112:          cmp  #SYMBOL_VARIABLE          ; variable?
00:B987 F004            	   113:          beq  SEA5                      ; yes
00:B989 C959            	   114:          cmp  #SYMBOL_FUNCTION_RETURN   ; argument?
00:B98B D003            	   115:          bne  SEA3                      ; no - must be SYMBOL_ARRAY, SYMBOL_PROCEDURE or SYMBOL_FUNCTION
                        	   116: ;
                        	   117: ;  here for variables and function return values
                        	   118: ;
                        	   119: SEA5     =  *
00:B98D 2033BB          	   120:          jsr  GET_OFF    ; get the variable's offset
                        	   121: SEA3     =  *
00:B990 A536            	   122:          lda  BSAVE      ; A now has the symbol type in it
                        	   123: 
                        	   124: ; Types are: SYMBOL_CONSTANT, SYMBOL_VARIABLE, SYMBOL_FUNCTION_RETURN,
                        	   125: ;            SYMBOL_PROCEDURE, SYMBOL_FUNCTION, SYMBOL_ARRAY
                        	   126: 
00:B992 60              	   127:          rts             ; SHOULD SET 'NEQ' FLAG
                        	   128: 
                        	   129: 
00:B993 A225            	   130: SYM_FULL ldx  #37     ; ERROR: Symbol table full
00:B995 4C8397          	   131:          jmp  ERROR
                        	   132: 
                        	   133: ;***********************************************
                        	   134: ; ADD SYMBOL TO SYMBOL TABLE - going downwards until we hit the P-codes
                        	   135: ;  A = the symbol type
                        	   136: ;***********************************************
                        	   137: ADDSYM   =  *
00:B998 48              	   138:          pha            ; save the symbol type
                        	   139: 
00:B999 A631            	   140:          ldx  ENDSYM    ; get the end of the symbol table
00:B99B 8640            	   141:          stx  SYMITM    ; make it the current symbol
00:B99D A632            	   142:          ldx  ENDSYM+1
00:B99F 8641            	   143:          stx  SYMITM+1
                        	   144: ;
                        	   145: ;  since we are going downwards, we need to subtract the fixed size of a symbol table item,
                        	   146: ;  plus the symbol length, from SYMITM
                        	   147: ;
00:B9A1 38              	   148:          sec            ; first subtract the token length
00:B9A2 A540            	   149:          lda  SYMITM
00:B9A4 E592            	   150:          sbc  token_length
00:B9A6 8540            	   151:          sta  SYMITM
00:B9A8 8503            	   152:          sta  DEST      ; put this spot into DEST for copying the name
00:B9AA A541            	   153:          lda  SYMITM+1
00:B9AC E900            	   154:          sbc  #0
00:B9AE 8541            	   155:          sta  SYMITM+1
00:B9B0 8504            	   156:          sta  DEST+1
00:B9B2 38              	   157:          sec            ; and now the fixed size
00:B9B3 A540            	   158:          lda  SYMITM
00:B9B5 E90A            	   159:          sbc  #SYMNAM
00:B9B7 8540            	   160:          sta  SYMITM
00:B9B9 A541            	   161:          lda  SYMITM+1
00:B9BB E900            	   162:          sbc  #0
00:B9BD 8541            	   163:          sta  SYMITM+1
                        	   164: ;
                        	   165: ;  check we haven't hit the P-codes
                        	   166: ;
00:B9BF A902            	   167:          lda  #FLAG_ASSEMBLING
00:B9C1 25BE            	   168:          and  system_flags
00:B9C3 D008            	   169:          bne  ADDSYM_NOT_FULL
00:B9C5 A524            	   170:          lda  PCODE+1
00:B9C7 C541            	   171:          cmp  SYMITM+1
00:B9C9 9002            	   172:          bcc  ADDSYM_NOT_FULL   ; less than - ok
00:B9CB 80C6            	   173:          bra  SYM_FULL          ; greater than or equal (high-order byte) - uh oh
                        	   174: ;
                        	   175: ;  ah, for assembling it is a pain to know whether the symbol table has overflowed, so I'm going
                        	   176: ;  to ignore that as a problem for now. Checking against PCODE will not work if the assembler output
                        	   177: ;  has been relocated to above the symbol table, and the only other thing we can compare against is
                        	   178: ;  the end of the source which we don't necessarily know.
                        	   179: ;
                        	   180: ;
                        	   181: ;  now put the previous start in as the link for the previous one for this item
                        	   182: ;
                        	   183: ADDSYM_NOT_FULL:
00:B9CD A000            	   184:          ldy  #SYMPRV
00:B9CF A531            	   185:          lda  ENDSYM
00:B9D1 9140            	   186:          sta  (SYMITM),Y
00:B9D3 A532            	   187:          lda  ENDSYM+1
00:B9D5 C8              	   188:          iny
00:B9D6 9140            	   189:          sta  (SYMITM),Y
                        	   190: ;
                        	   191: ;  SYMITM now becomes the start of the symbol table
                        	   192: ;
00:B9D8 A540            	   193:          lda  SYMITM
00:B9DA 8531            	   194:          sta  ENDSYM
00:B9DC A541            	   195:          lda  SYMITM+1
00:B9DE 8532            	   196:          sta  ENDSYM+1
                        	   197: ;
                        	   198: ;  OK, we should be done linking it in.
                        	   199: ;  SYMITM now points to this (as yet unfilled-in) item and the first two bytes now point to
                        	   200: ;   where the symbols previously ended
                        	   201: ;
00:B9E0 68              	   202:          pla                ; get symbol type back
00:B9E1 A003            	   203:          ldy  #SYMTYP
00:B9E3 9140            	   204:          sta  (SYMITM),Y    ; store the type which was in A
00:B9E5 A002            	   205:          ldy  #SYMLVL
00:B9E7 48              	   206:          pha                ; save symbol type again
00:B9E8 A522            	   207:          lda  LEVEL
00:B9EA 9140            	   208:          sta  (SYMITM),Y    ; store the level
00:B9EC A009            	   209:          ldy  #SYMLEN
00:B9EE A592            	   210:          lda  token_length
00:B9F0 9140            	   211:          sta  (SYMITM),Y    ; store the token length
00:B9F2 A8              	   212:          tay
00:B9F3 88              	   213:          dey                ; make zero-relative
                        	   214: ADD1     =  *               ; copy the name across, in upper case
00:B9F4 B190            	   215:          lda  (token_address),Y
00:B9F6 20E38F          	   216:          jsr  MAKE_UPPER
00:B9F9 9103            	   217:          sta  (DEST),Y
00:B9FB 88              	   218:          dey
00:B9FC 10F6            	   219:          bpl  ADD1      ; keep copying
                        	   220: 
                        	   221: ;
                        	   222: ;  we have added name to the table, now do the rest
                        	   223: ;
00:B9FE 68              	   224:          pla                     ; get symbol type back again
00:B9FF AA              	   225:          tax                     ; symbol type
00:BA00 C943            	   226:          cmp  #SYMBOL_CONSTANT   ; CONSTANT??
00:BA02 D013            	   227:          bne  ADD4
                        	   228: ;
                        	   229: ;  constant
                        	   230: ;
00:BA04 A004            	   231:          ldy  #SYMDSP            ; put this token's value into SYMDSP offset from SYMITM (for 3 bytes)
00:BA06 A594            	   232:          lda  token_value
00:BA08 9140            	   233:          sta  (SYMITM),Y
00:BA0A C8              	   234:          iny
00:BA0B A595            	   235:          lda  token_value+1
00:BA0D 9140            	   236:          sta  (SYMITM),Y
00:BA0F C8              	   237:          iny
00:BA10 A596            	   238:          lda  token_value+2
00:BA12 9140            	   239:          sta  (SYMITM),Y
00:BA14 4C33BA          	   240:          jmp  ADD9
                        	   241: ;
                        	   242: ;  not a constant
                        	   243: ;
                        	   244: ADD4     =  *
00:BA17 A008            	   245:          ldy  #SYMDAT
00:BA19 A901            	   246:          lda  #1            ; char type (?)
00:BA1B 9140            	   247:          sta  (SYMITM),Y
00:BA1D 8A              	   248:          txa                ; get symbol type back
00:BA1E C956            	   249:          cmp  #SYMBOL_VARIABLE
00:BA20 D011            	   250:          bne  ADD9
                        	   251: ;
                        	   252: ;  variable type
                        	   253: ;
00:BA22 A005            	   254:          ldy  #SYMDSP+1
00:BA24 A521            	   255:          lda  FRAME+1       ; save frame
00:BA26 9140            	   256:          sta  (SYMITM),Y
00:BA28 88              	   257:          dey
00:BA29 A520            	   258:          lda  FRAME
00:BA2B 9140            	   259:          sta  (SYMITM),Y
00:BA2D E620            	   260:          inc  FRAME         ; add 1 to frame number
00:BA2F D002            	   261:          bne  ADD9
00:BA31 E621            	   262:          inc  FRAME+1
                        	   263: ADD9     =  *
00:BA33 60              	   264:          rts
                        	   265: ;
                        	   266: 
                        	   267: ;
                        	   268: LOOKUP   =  *
00:BA34 201CB9          	   269:          JSR  SEARCH
00:BA37 D005            	   270:          BNE  LOOK1
00:BA39 A20B            	   271:          LDX  #11     ; ERROR: Undeclared Identifier
00:BA3B 4C8397          	   272:          jmp  ERROR
00:BA3E 60              	   273: LOOK1    RTS
                        	   274: ;
00:BA3F 201CB9          	   275: CHKDUP   JSR  SEARCH
00:BA42 F00A            	   276:          BEQ  DUP9
00:BA44 8A              	   277:          TXA
00:BA45 C522            	   278:          CMP  LEVEL
00:BA47 D005            	   279:          BNE  DUP9
00:BA49 A226            	   280:          LDX  #38   ; ERROR: Duplicate Identifier
00:BA4B 4C8397          	   281:          jmp  ERROR
00:BA4E 60              	   282: DUP9     RTS
                        	   283: 

Source: "gpascal.asm"
                        	   185:   .include "compiler.inc"

Source: "compiler.inc"
                        	     1: 
                        	     2: ;***********************************************
                        	     3: ; COMPILER
                        	     4: ;***********************************************
                        	     5: 
                        	     6: 
                        	     7: ;
                        	     8: ;
                        	     9: ;  Compiler directives:
                        	    10: ;
                        	    11: ;    {%L} - list during compile (source code and current P-code address)
                        	    12: ;    {%P} - show generated P-codes during compile - only works during compile (not syntax check)
                        	    13: ;    {%N} - stop listing during compile (cancels %L and %P)
                        	    14: ;    {%S <address>} - relocate symbol table to <address> - must be done before defining symbols
                        	    15: ;                     also generates an opcode to relocate the runtime stack
                        	    16: ;
                        	    17: ;   The % must directly follow the start of the comment.
                        	    18: ;
                        	    19: ;
                        	    20: ;  Comments:  (* some comment *) or { some comment }
                        	    21: ;             "(*" / "{", and "*)" / "}" are treated interchangeably so (* some comment } would work
                        	    22: ;  Comments cannot be nested.
                        	    23: ;
                        	    24: ;  Tips:
                        	    25: ;
                        	    26: ;   Procedures and functions must be declared at the START of a block, not in the middle.
                        	    27: ;   The order is important. CONST first, then VAR, then procedure/function declarations, then BEGIN
                        	    28: 
                        	    29: ;    eg.
                        	    30: ;
                        	    31: ;    const limit = 10;   { <-- this is the start of a block: CONST before VAR }
                        	    32: ;    var k: integer;     { we declare variables and constants here - BEFORE "begin" }
                        	    33: ;    line : array [100] of char;  { array }
                        	    34: ;    function foo;       { and functions and procedures - this is the start of another block}
                        	    35: ;    begin
                        	    36: ;      foo := 42         { assign to function return value }
                        	    37: ;    end;                { end of the function block - note semicolon }
                        	    38: ;    begin               { end of declarations - now we have the block statements }
                        	    39: ;     for k := 1 to limit do
                        	    40: ;       writeln ("square of ", k, " is ", k * k);
                        	    41: ;     write (foo)        { call function }
                        	    42: ;    end.
                        	    43: ;
                        	    44: ;    ARGUMENTS: If the procedure or function does not take arguments OMIT THE BRACKETS.
                        	    45: ;               Likewise, omit the brackets if you call the procedure or function (unlike C)
                        	    46: ;
                        	    47: ;    Semicolons SEPARATE statements, they don't terminate them.
                        	    48: ;
                        	    49: ; Warnings: * Functions which do not assign to the function return value give undefined results.
                        	    50: ;           * Multiplication discards high-order bits if result is too large.
                        	    51: ;           * Divide remainder is always positive (ie. MOD always gives a positive result, regardless of operand signs)
                        	    52: ;           * Function arguments are always integers and always return an integer.
                        	    53: ;           * One to three-byte strings can be used as integer constants
                        	    54: ;               eg. a := "abc"; write (a);   --> Result: 6513249 (ie. 0x636261 or "abc")
                        	    55: ;               The first character is the low-order byte in the number, explaining the above results.
                        	    56: ;           * Strings can start with single or double quotes, whatever starts the string must terminate it.
                        	    57: ;           * String literals can have the same character that started the string embedded, to do that put it twice.
                        	    58: ;             eg. 'Nick''s cat'
                        	    59: ;           * Array access it not range-checked.
                        	    60: ;           * Arrays start at zero. The array size declared is the maximum index (unlike C) so foo: array [10] of integ
                        	    61: ;               would declare an array of 11 elements, numbered from foo [0] to foo [10]
                        	    62: ;           * Maximum arguments to a procedure/function is 85 (255 / 3) due to internal coding
                        	    63: ;
                        	    64: 
                        	    65: 
                        	    66: ;
00:BA4F A2FF            	    67: COMPIL   LDX  #NEW_STK
00:BA51 9A              	    68:   txs    ; set stack back to 0xFF
                        	    69: 
00:BA52 20F991          	    70:   jsr  INIT
00:BA55 A901            	    71:   lda  #FLAG_COMPILING
00:BA57 04BE            	    72:   tsb  system_flags
00:BA59 20C0C6          	    73:   jsr  add_pascal_library_functions
00:BA5C 2046CF          	    74:   jsr  pas_get_token
00:BA5F 2043C3          	    75:   jsr  BLOCK
00:BA62 A92E            	    76:   lda  #'.'
00:BA64 A209            	    77:   ldx  #9        ; ERROR: . expected
00:BA66 20AACF          	    78:   jsr  CHKTKN
00:BA69 A900            	    79:   lda  #0
00:BA6B A213            	    80:   ldx  #19       ; ERROR: Incorrect Symbol
00:BA6D 209ACF          	    81:   jsr  GETCHK
00:BA70 204792          	    82:   jsr  CROUT
00:BA73 A9FE            	    83:   lda  #<pcodes_ended_message  ; P-codes ended at
00:BA75 A292            	    84:   ldx  #>pcodes_ended_message
00:BA77 202682          	    85:   jsr  print
00:BA7A A524            	    86:   lda  PCODE+1
00:BA7C 8544            	    87:   sta  END_PCD+1
00:BA7E 20BC92          	    88:   jsr  PRBYTE
00:BA81 A523            	    89:   lda  PCODE
00:BA83 8543            	    90:   sta  END_PCD
00:BA85 207193          	    91:   jsr  PRBYTECR
00:BA88 20C48E          	    92:   jsr  show_symbol_table_end
00:BA8B 20E98E          	    93:   jsr  show_source_end
                        	    94: 
00:BA8E A911            	    95:   lda  #<compile_finished_message  ; <C>ompile finished: No Errors
00:BA90 A293            	    96:   ldx  #>compile_finished_message
00:BA92 202682          	    97:   jsr  print
00:BA95 A642            	    98:   ldx  SYNTAX
00:BA97 D004            	    99:   bne  END_CMP
00:BA99 A908            	   100:   lda  #FLAG_VALID_COMPILE
00:BA9B 04BE            	   101:   tsb  system_flags
                        	   102: END_CMP  =  *
00:BA9D 4C8282          	   103:   jmp  main_prompt
                        	   104: ;
                        	   105: 
                        	   106: ;
                        	   107: CHKLHP   =  *
00:BAA0 A928            	   108:          LDA  #'('
00:BAA2 A21F            	   109:          LDX  #31     ; ERROR: ( expected
00:BAA4 4C9ACF          	   110:          JMP  GETCHK
                        	   111: ;
                        	   112: CHKRHP   =  *
00:BAA7 A929            	   113:          LDA  #')'
00:BAA9 A216            	   114:          LDX  #22     ; ERROR: ) expected
00:BAAB 20AACF          	   115:          JSR  CHKTKN
00:BAAE 4C46CF          	   116:          JMP  pas_get_token
                        	   117: ;
                        	   118: GETSUB   =  *
00:BAB1 20BABA          	   119:          JSR  CHKLHB
00:BAB4 20CBBD          	   120:          JSR  EXPRES
00:BAB7 4CC4BA          	   121:          JMP  CHKRHB
                        	   122: ;
                        	   123: CHKLHB   =  *
00:BABA A95B            	   124:          LDA  #'['
00:BABC A221            	   125:          LDX  #33     ; ERROR: [ expected
00:BABE 209ACF          	   126:          JSR  GETCHK
00:BAC1 4C46CF          	   127:          JMP  pas_get_token
                        	   128: ;
                        	   129: CHKRHB   =  *
00:BAC4 A95D            	   130:          LDA  #']'
00:BAC6 A222            	   131:          LDX  #34     ; ERROR: ] expected
00:BAC8 20AACF          	   132:          JSR  CHKTKN
00:BACB 4C46CF          	   133:          JMP  pas_get_token
                        	   134: ;
                        	   135: GET_LEV  =  *
00:BACE A522            	   136:          LDA  LEVEL
00:BAD0 A002            	   137:          LDY  #SYMLVL
00:BAD2 38              	   138:          SEC
00:BAD3 F140            	   139:          SBC  (SYMITM),Y
00:BAD5 8527            	   140:          STA  DISPL
00:BAD7 60              	   141:          RTS
                        	   142: ;
                        	   143: GET_DAT  =  *
00:BAD8 A008            	   144:          LDY  #SYMDAT
00:BADA B140            	   145:          LDA  (SYMITM),Y
00:BADC 854A            	   146:          STA  DATTYP
00:BADE 60              	   147:          RTS
                        	   148: ;
                        	   149: 
                        	   150: 
                        	   151: 
                        	   152: ; CONSTANT DEC
                        	   153: ;
                        	   154: CONDEC   =  *
00:BADF A949            	   155:          LDA  #TOKEN_IDENTIFIER
00:BAE1 A204            	   156:          LDX  #4        ; ERROR: Identifier expected
00:BAE3 20AACF          	   157:          JSR  CHKTKN
00:BAE6 20E892          	   158:          JSR  TKNWRK
00:BAE9 A592            	   159:          LDA  token_length
00:BAEB 48              	   160:          PHA
00:BAEC A93D            	   161:          LDA  #'='
00:BAEE A203            	   162:          LDX  #3        ; ERROR: = expected
00:BAF0 209ACF          	   163:          JSR  GETCHK
00:BAF3 2046CF          	   164:          JSR  pas_get_token
00:BAF6 20D2BB          	   165:          JSR  CONST
00:BAF9 20F392          	   166:          JSR  WRKTKN
00:BAFC 68              	   167:          PLA
00:BAFD 8592            	   168:          STA  token_length
00:BAFF 203FBA          	   169:          JSR  CHKDUP
00:BB02 A943            	   170:          LDA  #SYMBOL_CONSTANT
00:BB04 2098B9          	   171:          JSR  ADDSYM
00:BB07 4C46CF          	   172:          JMP  pas_get_token
                        	   173: ;
                        	   174: ;
                        	   175: ;--- SYMITM --> WORK
                        	   176: ;
                        	   177: SYMWRK   =  *
00:BB0A 48              	   178:          PHA
00:BB0B A540            	   179:          LDA  SYMITM
00:BB0D 8537            	   180:          STA  WORK
00:BB0F A541            	   181:          LDA  SYMITM+1
00:BB11 8538            	   182:          STA  WORK+1
00:BB13 68              	   183:          PLA
00:BB14 60              	   184:          RTS
                        	   185: ;
                        	   186: ;--- WORK --> SYMITM
                        	   187: ;
                        	   188: WRKSYM   =  *
00:BB15 48              	   189:          PHA
00:BB16 A537            	   190:          LDA  WORK
00:BB18 8540            	   191:          STA  SYMITM
00:BB1A A538            	   192:          LDA  WORK+1
00:BB1C 8541            	   193:          STA  SYMITM+1
00:BB1E 68              	   194:          PLA
00:BB1F 60              	   195:          RTS
                        	   196: ;
                        	   197: ; PUSH PCODE ONTO STACK
                        	   198: ;
                        	   199: PSHPCODE =  *
00:BB20 8536            	   200:          STA  BSAVE
00:BB22 68              	   201:          PLA
00:BB23 AA              	   202:          TAX
00:BB24 68              	   203:          PLA
00:BB25 A8              	   204:          TAY
00:BB26 A524            	   205:          LDA  PCODE+1
00:BB28 48              	   206:          PHA
00:BB29 A523            	   207:          LDA  PCODE
00:BB2B 48              	   208:          PHA
00:BB2C 98              	   209:          TYA
00:BB2D 48              	   210:          PHA
00:BB2E 8A              	   211:          TXA
00:BB2F 48              	   212:          PHA
00:BB30 A536            	   213:          LDA  BSAVE
00:BB32 60              	   214:          RTS
                        	   215: ;
                        	   216: ;  Get the offset of this current symbol into OFFSET
                        	   217: ;
                        	   218: GET_OFF  =  *
00:BB33 48              	   219:          PHA
00:BB34 A004            	   220:          LDY  #SYMDSP
00:BB36 B140            	   221:          LDA  (SYMITM),Y
00:BB38 8529            	   222:          STA  OFFSET
00:BB3A C8              	   223:          INY
00:BB3B B140            	   224:          LDA  (SYMITM),Y
00:BB3D 852A            	   225:          STA  OFFSET+1
00:BB3F A003            	   226:          LDY  #SYMTYP
00:BB41 B140            	   227:          LDA  (SYMITM),Y
00:BB43 C956            	   228:          CMP  #SYMBOL_VARIABLE
00:BB45 F008            	   229:          BEQ  GETO_1
00:BB47 C941            	   230:          CMP  #SYMBOL_ARRAY
00:BB49 F004            	   231:          BEQ  GETO_1
00:BB4B C959            	   232:          CMP  #SYMBOL_FUNCTION_RETURN
00:BB4D D00D            	   233:          BNE  GETO_2
                        	   234: ;
                        	   235: ;  here if the symbol is a variable, array or function return value
                        	   236: ;   subtract the offset from -3
                        	   237: ;
                        	   238: GETO_1   =  *
00:BB4F 38              	   239:          SEC
00:BB50 A9FD            	   240:          LDA  #$FD
00:BB52 E529            	   241:          SBC  OFFSET
00:BB54 8529            	   242:          STA  OFFSET
00:BB56 A9FF            	   243:          LDA  #$FF
00:BB58 E52A            	   244:          SBC  OFFSET+1
00:BB5A 852A            	   245:          STA  OFFSET+1
                        	   246: GETO_2   =  *
00:BB5C 68              	   247:          PLA
00:BB5D 60              	   248:          RTS
                        	   249: ;
                        	   250: GETEXPR  =  *
00:BB5E 2046CF          	   251:          JSR  pas_get_token
00:BB61 4CCBBD          	   252:          JMP  EXPRES
                        	   253: ;
                        	   254: ;
                        	   255: PCD_WRKD =  *
00:BB64 48              	   256:          PHA
00:BB65 A523            	   257:          LDA  PCODE
00:BB67 8533            	   258:          STA  WORKD
00:BB69 A524            	   259:          LDA  PCODE+1
00:BB6B 8534            	   260:          STA  WORKD+1
00:BB6D 68              	   261:          PLA
00:BB6E 60              	   262:          RTS
                        	   263: ;
                        	   264: WRK_OPND =  *
00:BB6F 48              	   265:          PHA
00:BB70 A537            	   266:          LDA  WORK
00:BB72 852B            	   267:          STA  OPND
00:BB74 A538            	   268:          LDA  WORK+1
00:BB76 852C            	   269:          STA  OPND+1
00:BB78 68              	   270:          PLA
00:BB79 60              	   271:          RTS
                        	   272: ;
                        	   273: WRKD_WRK =  *
00:BB7A 48              	   274:          PHA
00:BB7B A533            	   275:          LDA  WORKD
00:BB7D 8537            	   276:          STA  WORK
00:BB7F A534            	   277:          LDA  WORKD+1
00:BB81 8538            	   278:          STA  WORK+1
00:BB83 68              	   279:          PLA
00:BB84 60              	   280:          RTS
                        	   281: ;
                        	   282: WRK_WRKD =  *
00:BB85 48              	   283:          PHA
00:BB86 A537            	   284:          LDA  WORK
00:BB88 8533            	   285:          STA  WORKD
00:BB8A A538            	   286:          LDA  WORK+1
00:BB8C 8534            	   287:          STA  WORKD+1
00:BB8E 68              	   288:          PLA
00:BB8F 60              	   289:          RTS
                        	   290: ;
                        	   291: GET_COMM =  *
00:BB90 A92C            	   292:          LDA  #','
00:BB92 A220            	   293:          LDX  #32     ; ERROR: , expected
00:BB94 4CAACF          	   294:          JMP  CHKTKN
                        	   295: ;
                        	   296: GET_ITEM =  *
00:BB97 2090BB          	   297:          JSR  GET_COMM   ; check for comma
00:BB9A 4C5EBB          	   298:          JMP  GETEXPR
                        	   299: ;
                        	   300: ;  Load (push) a constant (ie. a literal number)
                        	   301: ;
                        	   302: ;  Numbers in the range 0 to 0x7F are turned into a "low literal" which is a P-code
                        	   303: ;  with the 0x80 bit set. These then become a single-byte P-code which simply pushes
                        	   304: ;  that number onto the stack, thus saving having to have a 4-byte P-code being PCODE_LIT
                        	   305: ;  followed by a 3-byte number, 2 bytes of which would be zero.
                        	   306: ;
                        	   307: VAL_MOVE =  *
00:BB9D 48              	   308:          PHA
00:BB9E 18              	   309:          CLC
00:BB9F A594            	   310:          LDA  token_value
00:BBA1 8527            	   311:          STA  DISPL   ; why?
00:BBA3 1001            	   312:          BPL  VAL_1   ; is it 0x00 to 0x7F?
00:BBA5 38              	   313:          SEC          ; no, set carry bit
                        	   314: VAL_1    =  *
00:BBA6 A595            	   315:          LDA  token_value+1
00:BBA8 F001            	   316:          BEQ  VAL_2   ; is second byte 0x00?
00:BBAA 38              	   317:          SEC          ; no, set carry bit
                        	   318: VAL_2    =  *
00:BBAB 8529            	   319:          STA  OFFSET
00:BBAD A596            	   320:          LDA  token_value+2
00:BBAF 852A            	   321:          STA  OFFSET+1
00:BBB1 F001            	   322:          BEQ  VAL_3   ; is third byte 0x00?
00:BBB3 38              	   323:          SEC          ; no, set carry bit
                        	   324: VAL_3    =  *
00:BBB4 9007            	   325:          BCC  VAL_5   ; did we ever set the carry bit?
00:BBB6 A900            	   326:          LDA  #PCODE_LIT  ; yes, so just generate a "load literal"
00:BBB8 2083C7          	   327:          JSR  GENADR
00:BBBB 68              	   328:          PLA
00:BBBC 60              	   329:          RTS
                        	   330: VAL_5    =  *
00:BBBD A594            	   331:          LDA  token_value   ; get the low-order byte back
00:BBBF 0980            	   332:          ORA  #$80    ; set the 0x80 bit as a flag
00:BBC1 206AC7          	   333:          JSR  GENNOP  ; output one P-code
00:BBC4 68              	   334:          PLA
00:BBC5 60              	   335:          RTS
                        	   336: ;
                        	   337: ;
                        	   338: CHK_STAK =  *
00:BBC6 BA              	   339:          TSX
00:BBC7 8A              	   340:          TXA
00:BBC8 C920            	   341:          CMP  #MAX_STK
00:BBCA 9001            	   342:          BCC  STK_FULL
00:BBCC 60              	   343:          RTS
                        	   344: STK_FULL =  *
00:BBCD A21B            	   345: STK_ERR  LDX  #27     ; ERROR: Stack full
00:BBCF 4C8397          	   346:          jmp  ERROR      ; FULL
                        	   347: ;
                        	   348: ;
                        	   349: ; CONST get the value into token_value
                        	   350: ;
                        	   351: CONST    =  *
00:BBD2 A593            	   352:          LDA  token_type
00:BBD4 C94E            	   353:          CMP  #TOKEN_NUMBER
00:BBD6 F01F            	   354:          BEQ  CONST9
00:BBD8 C949            	   355:          CMP  #TOKEN_IDENTIFIER
00:BBDA F00D            	   356:          BEQ  CONST1
00:BBDC C922            	   357:          CMP  #TOKEN_STRING
00:BBDE D00E            	   358:          BNE  CONST3
00:BBE0 A692            	   359:          LDX  token_length
00:BBE2 E004            	   360:          CPX  #4
00:BBE4 9011            	   361:          BCC  CONST9
00:BBE6 4C7ABD          	   362:          JMP  FACERR1    ; STRING TOO BIG
00:BBE9 201CB9          	   363: CONST1   JSR  SEARCH
00:BBEC D005            	   364:          BNE  CONST2
                        	   365: CONST3   =  *
00:BBEE A202            	   366:          LDX  #2        ; ERROR: Constant expected
00:BBF0 4C8397          	   367:          jmp  ERROR
00:BBF3 C943            	   368: CONST2   CMP  #SYMBOL_CONSTANT
00:BBF5 D0F7            	   369:          BNE  CONST3
00:BBF7 60              	   370: CONST9   RTS
                        	   371: ;
                        	   372: ; VARIABLE DEC
                        	   373: ;
00:BBF8 A949            	   374: VARDEC   LDA  #TOKEN_IDENTIFIER
00:BBFA A204            	   375:          LDX  #4      ; ERROR: Identifier expected
00:BBFC 20AACF          	   376:          JSR  CHKTKN
00:BBFF 203FBA          	   377:          JSR  CHKDUP
00:BC02 A956            	   378:          LDA  #SYMBOL_VARIABLE
00:BC04 2098B9          	   379:          JSR  ADDSYM
00:BC07 4C46CF          	   380:          JMP  pas_get_token
                        	   381: ;
                        	   382: ; SIMPLE EXPRESSION
                        	   383: ;
                        	   384: SIMEXP   =  *
00:BC0A A593            	   385:          LDA  token_type
00:BC0C C92B            	   386:          CMP  #'+'
00:BC0E F004            	   387:          BEQ  SIM1
00:BC10 C92D            	   388:          CMP  #'-'
00:BC12 D048            	   389:          BNE  SIM2
00:BC14 48              	   390: SIM1     PHA
00:BC15 2046CF          	   391:          JSR  pas_get_token
00:BC18 207CBC          	   392:          JSR  TERM
00:BC1B 68              	   393:          PLA
00:BC1C C92D            	   394:          CMP  #'-'
00:BC1E D005            	   395:          BNE  SIM3
00:BC20 A902            	   396:          LDA  #PCODE_NEG      ; NEG       Negate (sp)
00:BC22 206AC7          	   397:          JSR  GENNOP     ; NEGATE
00:BC25 A593            	   398: SIM3     LDA  token_type
00:BC27 C92B            	   399:          CMP  #'+'
00:BC29 F00D            	   400:          BEQ  SIM4
00:BC2B C92D            	   401:          CMP  #'-'
00:BC2D F009            	   402:          BEQ  SIM4
00:BC2F C98A            	   403:          CMP  #TOKEN_OR       ; OR
00:BC31 F005            	   404:          BEQ  SIM4
00:BC33 C9A4            	   405:          CMP  #TOKEN_XOR      ; XOR
00:BC35 F001            	   406:          BEQ  SIM4
00:BC37 60              	   407:          RTS
00:BC38 48              	   408: SIM4     PHA
00:BC39 2046CF          	   409:          JSR  pas_get_token
00:BC3C 207CBC          	   410:          JSR  TERM
00:BC3F 68              	   411:          PLA
00:BC40 C92D            	   412:          CMP  #'-'
00:BC42 F010            	   413:          BEQ  SIM5
00:BC44 C92B            	   414:          CMP  #'+'
00:BC46 F010            	   415:          BEQ  SIM6
00:BC48 C9A4            	   416:          CMP  #TOKEN_XOR          ; XOR
00:BC4A F016            	   417:          BEQ  SIM8
00:BC4C A91A            	   418:          LDA  #PCODE_ORR          ; ORR       OR  (sp - 1) | (sp)
00:BC4E 206AC7          	   419: SIM7     JSR  GENNOP
00:BC51 4C25BC          	   420:          JMP  SIM3
00:BC54 A906            	   421: SIM5     LDA  #PCODE_SUB          ; MINUS
00:BC56 D0F6            	   422:          BNE  SIM7
00:BC58 A904            	   423: SIM6     LDA  #PCODE_ADD          ; PLUS
00:BC5A D0F2            	   424:          BNE  SIM7
00:BC5C 207CBC          	   425: SIM2     JSR  TERM
00:BC5F 4C25BC          	   426:          JMP  SIM3
00:BC62 A93A            	   427: SIM8     LDA  #PCODE_XOR         ; XOR
00:BC64 D0E8            	   428:          BNE  SIM7
                        	   429: ;
                        	   430: ; TERM
                        	   431: ;
00:BC66 2A              	   432: TERMT1   ASC    '*'
00:BC67 89BC            	   433:          word   TERM1
00:BC69 8B              	   434:          DFB    TOKEN_DIV    ; div
00:BC6A 89BC            	   435:          word   TERM1
00:BC6C 2F              	   436:          ASC    '/'
00:BC6D 89BC            	   437:          word   TERM1
00:BC6F 8D              	   438:          DFB    TOKEN_AND    ; and
00:BC70 89BC            	   439:          word   TERM1
00:BC72 8C              	   440:          DFB    TOKEN_MOD    ; mod
00:BC73 89BC            	   441:          word   TERM1
00:BC75 8E              	   442:          DFB    TOKEN_SHL    ; shl
00:BC76 89BC            	   443:          word   TERM1
00:BC78 8F              	   444:          DFB    TOKEN_SHR    ; shr
00:BC79 89BC            	   445:          word   TERM1
00:BC7B 00              	   446:          DFB    0
                        	   447: ;
00:BC7C 20CABC          	   448: TERM     JSR  FACTOR
00:BC7F A266            	   449: TERM2    LDX  #<TERMT1
00:BC81 A0BC            	   450:          LDY  #>TERMT1
00:BC83 A593            	   451:          LDA  token_type
00:BC85 20B18F          	   452:          JSR  TKNJMP
00:BC88 60              	   453:          RTS
                        	   454: ;
00:BC89 48              	   455: TERM1    PHA
00:BC8A 2046CF          	   456:          JSR  pas_get_token
00:BC8D 20CABC          	   457:          JSR  FACTOR
00:BC90 68              	   458:          PLA
00:BC91 A2B4            	   459:          LDX  #<TERMT3
00:BC93 A0BC            	   460:          LDY  #>TERMT3
00:BC95 20B18F          	   461:          JSR  TKNJMP
                        	   462: ;
00:BC98 A90A            	   463: TERM4    LDA  #PCODE_DIV       ; Divide (sp - 1) / (sp)
00:BC9A 206AC7          	   464: TERM3    JSR  GENNOP
00:BC9D 4C7FBC          	   465:          JMP  TERM2
00:BCA0 A91B            	   466: TERM5    LDA  #PCODE_AND        ; AND
00:BCA2 D0F6            	   467:          BNE  TERM3
00:BCA4 A90B            	   468: TERM6    LDA  #PCODE_MOD        ; MOD
00:BCA6 D0F2            	   469:          BNE  TERM3
00:BCA8 A922            	   470: TERM7    LDA  #PCODE_SHL       ; Shift left (sp) bits
00:BCAA D0EE            	   471:          BNE  TERM3
00:BCAC A924            	   472: TERM8    LDA  #PCODE_SHR       ; Shift right (sp) bits
00:BCAE D0EA            	   473:          BNE  TERM3
00:BCB0 A908            	   474: TERM9    LDA  #PCODE_MUL        ; Multiply (sp) * (sp - 1)
00:BCB2 D0E6            	   475:          BNE  TERM3
                        	   476: ;
00:BCB4 8B              	   477: TERMT3   DFB    TOKEN_DIV     ; div
00:BCB5 98BC            	   478:          word   TERM4
00:BCB7 2F              	   479:          ASC    '/'
00:BCB8 98BC            	   480:          word   TERM4
00:BCBA 8D              	   481:          DFB    TOKEN_AND     ; and
00:BCBB A0BC            	   482:          word   TERM5
00:BCBD 8C              	   483:          DFB    TOKEN_MOD     ; mod
00:BCBE A4BC            	   484:          word   TERM6
00:BCC0 8E              	   485:          DFB    TOKEN_SHL     ; shl
00:BCC1 A8BC            	   486:          word   TERM7
00:BCC3 8F              	   487:          DFB    TOKEN_SHR     ; shr
00:BCC4 ACBC            	   488:          word   TERM8
00:BCC6 2A              	   489:          ASC    '*'
00:BCC7 B0BC            	   490:          word   TERM9
00:BCC9 00              	   491:          DFB  0
                        	   492: ;
                        	   493: ; FACTOR
                        	   494: ;
00:BCCA 20C6BB          	   495: FACTOR   JSR  CHK_STAK
00:BCCD A593            	   496:          LDA  token_type
00:BCCF A2B2            	   497:          LDX  #<FACTB1
00:BCD1 A0BD            	   498:          LDY  #>FACTB1
00:BCD3 20B18F          	   499:          JSR  TKNJMP
00:BCD6 A217            	   500:          LDX  #23     ; ERROR: Illegal factor
00:BCD8 4C8397          	   501:          jmp  ERROR
                        	   502: ;
00:BCDB 2034BA          	   503: IDENT    JSR  LOOKUP
00:BCDE C950            	   504: IDENT1   CMP  #SYMBOL_PROCEDURE
00:BCE0 F004            	   505:          beq  IDENT1A
00:BCE2 C951            	   506:          CMP  #SYMBOL_LIBRARY_PROCEDURE
00:BCE4 D005            	   507:          BNE  IDENT2
                        	   508: IDENT1A:
00:BCE6 A215            	   509:          LDX  #21     ; ERROR: Use of procedure Identifier in expression
00:BCE8 4C8397          	   510:          jmp  ERROR
00:BCEB C959            	   511: IDENT2   CMP  #SYMBOL_FUNCTION_RETURN
00:BCED D015            	   512:          BNE  IDENT2A
00:BCEF A000            	   513:          LDY  #SYMPRV      ; this symbol is actually the function return value symbol
00:BCF1 B140            	   514:          LDA  (SYMITM),Y   ; so go to the previous symbol which will be the function
00:BCF3 AA              	   515:          TAX               ; declaration symbol with the address of the function to be called
00:BCF4 C8              	   516:          INY
00:BCF5 B140            	   517:          LDA  (SYMITM),Y
00:BCF7 8541            	   518:          STA  SYMITM+1
00:BCF9 8A              	   519:          TXA
00:BCFA 8540            	   520:          STA  SYMITM
00:BCFC A980            	   521:          lda  #$80       ; push 0 onto the stack which will be the default function return value
00:BCFE 206AC7          	   522:          jsr  GENNOP     ; when the function returns this will be left on the top of the stack
00:BD01 4C4BC0          	   523:          JMP  FNCPRC     ; with the function's assigned value in it (or zero if nothing assigned);
                        	   524: 
00:BD04 C952            	   525: IDENT2A  CMP #SYMBOL_LIBRARY_FUNCTION
00:BD06 D003            	   526:          bne IDENT3
00:BD08 4C1AC7          	   527:          jmp  library_function_call
                        	   528: 
00:BD0B C941            	   529: IDENT3   CMP  #SYMBOL_ARRAY
00:BD0D F030            	   530:          BEQ  IDENT4
00:BD0F C943            	   531:          CMP  #SYMBOL_CONSTANT
00:BD11 D00E            	   532:          BNE  IDENT5
00:BD13 209DBB          	   533:          JSR  VAL_MOVE
00:BD16 4C34BD          	   534:          JMP  IDENT7
                        	   535: ;
                        	   536: ;   Here for address of integer variable
                        	   537: ;
00:BD19 A90C            	   538: FACAD1   LDA  #PCODE_ADRNN
00:BD1B 2023BD          	   539:          JSR  IDENT5_A
00:BD1E 4CA7BA          	   540:          JMP  CHKRHP
                        	   541: ;
00:BD21 A92C            	   542: IDENT5   LDA  #PCODE_LOD   ; load integer onto stack
00:BD23 48              	   543: IDENT5_A PHA
                        	   544: ;
00:BD24 8636            	   545:          STX  BSAVE
00:BD26 A522            	   546:          LDA  LEVEL
00:BD28 38              	   547:          SEC
00:BD29 E536            	   548:          SBC  BSAVE
00:BD2B 8527            	   549:          STA  DISPL
00:BD2D 68              	   550:          PLA
00:BD2E 18              	   551: IDENT6   CLC
00:BD2F 654A            	   552:          ADC  DATTYP
00:BD31 2083C7          	   553:          JSR  GENADR
00:BD34 4C46CF          	   554: IDENT7   JMP  pas_get_token
                        	   555: ;
00:BD37 A90E            	   556: FACAD2   LDA  #PCODE_ADRAN  ; address of integer array
00:BD39 2041BD          	   557:          JSR  IDENT4_A
00:BD3C 4CA7BA          	   558:          JMP  CHKRHP
                        	   559: ;
                        	   560: ;    Here for load indexed integer
                        	   561: ;
00:BD3F A930            	   562: IDENT4   LDA  #PCODE_LDI         ; Load integer indexed
00:BD41 48              	   563: IDENT4_A PHA
                        	   564: ;
00:BD42 200ABB          	   565:          JSR  SYMWRK
00:BD45 207E92          	   566:          JSR  PSHWRK
00:BD48 20B1BA          	   567:          JSR  GETSUB
00:BD4B 209192          	   568:          JSR  PULWRK
00:BD4E 2015BB          	   569:          JSR  WRKSYM
00:BD51 20D8BA          	   570:          JSR  GET_DAT
00:BD54 20CEBA          	   571:          JSR  GET_LEV
00:BD57 2033BB          	   572:          JSR  GET_OFF
00:BD5A 68              	   573:          PLA
00:BD5B 18              	   574:          CLC
00:BD5C 654A            	   575:          ADC  DATTYP
00:BD5E 4C83C7          	   576:          JMP  GENADR
                        	   577: ;
                        	   578: ; ADDRESS (IDENTIFIER)
                        	   579: ;
                        	   580: ;
                        	   581: FACADR   =  *
00:BD61 20A0BA          	   582:          JSR  CHKLHP
00:BD64 20AFCF          	   583:          JSR  GET_LOOK
00:BD67 C956            	   584:          CMP  #SYMBOL_VARIABLE
00:BD69 F0AE            	   585:          BEQ  FACAD1
00:BD6B C941            	   586:          CMP  #SYMBOL_ARRAY
00:BD6D F0C8            	   587:          BEQ  FACAD2
00:BD6F A217            	   588:          LDX  #23     ; ERROR: Illegal factor
00:BD71 4C8397          	   589:          jmp  ERROR
                        	   590: ;
                        	   591: ;
00:BD74 A592            	   592: FACSTR   LDA  token_length
00:BD76 C904            	   593:          CMP  #4
00:BD78 9005            	   594:          BCC  FACNUM    ; BLT
00:BD7A A21D            	   595: FACERR1  LDX  #29        ; ERROR: string literal too big
00:BD7C 4C8397          	   596:          jmp  ERROR
                        	   597: FACNUM   =  *
00:BD7F 209DBB          	   598:          JSR  VAL_MOVE
00:BD82 4C34BD          	   599:          JMP  IDENT7
                        	   600: ;
00:BD85 205EBB          	   601: PAREN    JSR  GETEXPR
00:BD88 4CA7BA          	   602:          JMP  CHKRHP
                        	   603: ;
00:BD8B A900            	   604: FACMEM   LDA  #0          ; add zero below to get PCODE_LDA
00:BD8D 854A            	   605:          STA  DATTYP
00:BD8F F004            	   606:          BEQ  FACM2
00:BD91 A901            	   607: FACMMC   LDA  #1          ; add one below to get PCODE_LDAC
00:BD93 854A            	   608:          STA  DATTYP
00:BD95 A54A            	   609: FACM2    LDA  DATTYP
00:BD97 48              	   610:          PHA
00:BD98 20B1BA          	   611:          JSR  GETSUB
00:BD9B 68              	   612:          PLA
00:BD9C 18              	   613:          CLC
00:BD9D 692E            	   614:          ADC  #PCODE_LDA    ; Load absolute address integer or PCODE_LDAC if we added 1
00:BD9F D008            	   615:          BNE  GENNOP1
                        	   616: ;
00:BDA1 2046CF          	   617: FACNOT   JSR  pas_get_token
00:BDA4 20CABC          	   618:          JSR  FACTOR
00:BDA7 A920            	   619:          LDA  #PCODE_EOR     ; Not (sp) (logical negate)
00:BDA9 4C6AC7          	   620: GENNOP1  JMP  GENNOP
                        	   621: ;
00:BDAC 206AC7          	   622: FACRND1  JSR  GENNOP
00:BDAF 4C46CF          	   623:          JMP  pas_get_token
                        	   624: ;
                        	   625: ;
                        	   626: ;
00:BDB2 49              	   627: FACTB1   DFB    TOKEN_IDENTIFIER
00:BDB3 DBBC            	   628:          word   IDENT
00:BDB5 4E              	   629:          ASC    TOKEN_NUMBER
00:BDB6 7FBD            	   630:          word   FACNUM
00:BDB8 22              	   631: FACTQT1  DFB    TOKEN_STRING        ; QUOTE SYMBOL
00:BDB9 74BD            	   632:          word   FACSTR
00:BDBB 28              	   633:          ASC    '('
00:BDBC 85BD            	   634:          word   PAREN
00:BDBE 91              	   635:          DFB    TOKEN_MEM
00:BDBF 8BBD            	   636:          word   FACMEM     ; MEM
00:BDC1 90              	   637:          DFB    TOKEN_NOT
00:BDC2 A1BD            	   638:          word   FACNOT
00:BDC4 A2              	   639:          DFB    TOKEN_MEMC
00:BDC5 91BD            	   640:          word   FACMMC     ; MEMC
00:BDC7 A9              	   641:          DFB    TOKEN_ADDRESS
00:BDC8 61BD            	   642:          word   FACADR
00:BDCA 00              	   643:          DFB  0
                        	   644: ;
                        	   645: ; EXPRESSION
                        	   646: ;
00:BDCB 20C6BB          	   647: EXPRES   JSR  CHK_STAK
00:BDCE 200ABC          	   648:          JSR  SIMEXP
00:BDD1 A593            	   649:          LDA  token_type
00:BDD3 A2DB            	   650:          LDX  #<EXPTB1
00:BDD5 A0BD            	   651:          LDY  #>EXPTB1
00:BDD7 20B18F          	   652:          JSR  TKNJMP
00:BDDA 60              	   653:          RTS
                        	   654: ;
00:BDDB 3D              	   655: EXPTB1   ASC    '='
00:BDDC EEBD            	   656:          word   EXPR1
00:BDDE 55              	   657:          DFB    TOKEN_NEQ
00:BDDF EEBD            	   658:          word   EXPR1
00:BDE1 3C              	   659:          ASC    '<'
00:BDE2 EEBD            	   660:          word   EXPR1
00:BDE4 80              	   661:          DFB    TOKEN_LEQ
00:BDE5 EEBD            	   662:          word   EXPR1
00:BDE7 81              	   663:          DFB    TOKEN_GEQ
00:BDE8 EEBD            	   664:          word   EXPR1
00:BDEA 3E              	   665:          ASC    '>'
00:BDEB EEBD            	   666:          word   EXPR1
00:BDED 00              	   667:          DFB  0
                        	   668: ;
00:BDEE 48              	   669: EXPR1    PHA
00:BDEF 2046CF          	   670:          JSR  pas_get_token
00:BDF2 200ABC          	   671:          JSR  SIMEXP
00:BDF5 68              	   672:          PLA
00:BDF6 A2FD            	   673:          LDX  #<EXPTB3
00:BDF8 A0BD            	   674:          LDY  #>EXPTB3
00:BDFA 20B18F          	   675:          JSR  TKNJMP
                        	   676: ;
00:BDFD 3D              	   677: EXPTB3   ASC    '='
00:BDFE 10BE            	   678:          word   EXPR2
00:BE00 55              	   679:          ASC    TOKEN_NEQ
00:BE01 16BE            	   680:          word   EXPR3
00:BE03 3C              	   681:          ASC    '<'
00:BE04 1ABE            	   682:          word   EXPR4
00:BE06 81              	   683:          DFB    TOKEN_GEQ
00:BE07 1EBE            	   684:          word   EXPR5
00:BE09 3E              	   685:          ASC    '>'
00:BE0A 22BE            	   686:          word   EXPR6
00:BE0C 80              	   687:          DFB    TOKEN_LEQ
00:BE0D 26BE            	   688:          word   EXPR7
00:BE0F 00              	   689:          DFB  0
                        	   690: ;
00:BE10 A910            	   691: EXPR2    LDA  #PCODE_EQL       ; EQL      Test (sp - 1) == (sp)
00:BE12 206AC7          	   692: EXPR8    JSR  GENNOP
00:BE15 60              	   693:          RTS
00:BE16 A912            	   694: EXPR3    LDA  #PCODE_NEQ       ; NEQ      Test (sp - 1) != (sp)
00:BE18 D0F8            	   695:          BNE  EXPR8
00:BE1A A914            	   696: EXPR4    LDA  #PCODE_LSS       ; LSS      Test (sp - 1) < (sp)
00:BE1C D0F4            	   697:          BNE  EXPR8
00:BE1E A916            	   698: EXPR5    LDA  #PCODE_GEQ       ; GEQ      Test (sp - 1) >= (sp)
00:BE20 D0F0            	   699:          BNE  EXPR8
00:BE22 A918            	   700: EXPR6    LDA  #PCODE_GTR       ; GTR      Test (sp - 1) > (sp)
00:BE24 D0EC            	   701:          BNE  EXPR8
00:BE26 A919            	   702: EXPR7    LDA  #PCODE_LEQ       ; LEQ      Test (sp - 1) <= (sp)
00:BE28 D0E8            	   703:          BNE  EXPR8
                        	   704: ;
                        	   705: ; STATEMENT
                        	   706: ;
00:BE2A 20C6BB          	   707: STMNT    JSR  CHK_STAK
00:BE2D A593            	   708:          LDA  token_type
00:BE2F A237            	   709:          LDX  #<STMNT1
00:BE31 A0BE            	   710:          LDY  #>STMNT1
00:BE33 20B18F          	   711:          JSR  TKNJMP
00:BE36 60              	   712:          RTS
                        	   713: ;
00:BE37 49              	   714: STMNT1   DFB    TOKEN_IDENTIFIER
00:BE38 62BE            	   715:          word   ASSIGN
00:BE3A 92              	   716:          DFB    TOKEN_IF
00:BE3B D2C0            	   717:          word   IF
00:BE3D 9A              	   718:          DFB    TOKEN_FOR
00:BE3E 39C2            	   719:          word   FOR
00:BE40 96              	   720:          DFB    TOKEN_WHILE
00:BE41 4CC1            	   721:          word   WHILE
00:BE43 95              	   722:          DFB    TOKEN_CASE
00:BE44 7EC1            	   723:          word   CASE
00:BE46 98              	   724:          DFB    TOKEN_REPEAT
00:BE47 28C1            	   725:          word   REPEAT
00:BE49 88              	   726:          DFB    TOKEN_BEGIN
00:BE4A 12C1            	   727:          word   BEG
00:BE4C 9E              	   728:          DFB    TOKEN_READ
00:BE4D 7ABF            	   729:          word   READ
00:BE4F 9D              	   730:          DFB    TOKEN_WRITE
00:BE50 D8BE            	   731:          word   WRITE
00:BE52 91              	   732:          DFB    TOKEN_MEM
00:BE53 23C0            	   733:          word   MEM
00:BE55 9F              	   734:          DFB    TOKEN_CALL
00:BE56 3EC0            	   735:          word   CALLSB
00:BE58 A2              	   736:          DFB    TOKEN_MEMC
00:BE59 28C0            	   737:          word   MEMC
00:BE5B FF              	   738:          DFB    TOKEN_WRITELN
00:BE5C C9BE            	   739:          word   WRITELN
00:BE5E F1              	   740:          DB     TOKEN_LCDWRITE
00:BE5F 29BF            	   741:          word   STMNT_WRITE_LCD
00:BE61 00              	   742:          DFB  0
                        	   743: ;
                        	   744: ; ASSIGNMENT - this is where we store an integer/char into a variable or array index
                        	   745: ;
00:BE62 2034BA          	   746: ASSIGN   JSR  LOOKUP
00:BE65 A271            	   747: ASS1     LDX  #<ASSTB1
00:BE67 A0BE            	   748:          LDY  #>ASSTB1
00:BE69 20B18F          	   749:          JSR  TKNJMP
00:BE6C A218            	   750:          LDX  #24     ; ERROR: Type mismatch
00:BE6E 4C8397          	   751:          jmp  ERROR
                        	   752: ;
00:BE71 41              	   753: ASSTB1   DFB   SYMBOL_ARRAY
00:BE72 8CBE            	   754:          word  ASSARR
00:BE74 56              	   755:          DFB   SYMBOL_VARIABLE
00:BE75 9EBE            	   756:          word  ASSVAR
00:BE77 59              	   757:          DFB   SYMBOL_FUNCTION_RETURN
00:BE78 9EBE            	   758:          word  ASSVAR
00:BE7A 50              	   759:          DFB   SYMBOL_PROCEDURE
00:BE7B 4BC0            	   760:          word  FNCPRC
00:BE7D 51              	   761:          DFB   SYMBOL_LIBRARY_PROCEDURE
00:BE7E 1AC7            	   762:          word  library_function_call
00:BE80 46              	   763:          DFB   SYMBOL_FUNCTION
00:BE81 87BE            	   764:          word  assign_bad_identifier
00:BE83 52              	   765:          DFB   SYMBOL_LIBRARY_FUNCTION
00:BE84 87BE            	   766:          word  assign_bad_identifier
00:BE86 00              	   767:          DFB  0
                        	   768: 
                        	   769: assign_bad_identifier:
00:BE87 A235            	   770:           ldx #53   ; ERROR: Use of function identifier in statement
00:BE89 4C8397          	   771:           jmp ERROR
                        	   772: ;
00:BE8C 200ABB          	   773: ASSARR   JSR  SYMWRK
00:BE8F 207E92          	   774:          JSR  PSHWRK
00:BE92 A936            	   775:          LDA  #PCODE_STI    ; Store integer indexed
00:BE94 18              	   776:          CLC
00:BE95 654A            	   777:          ADC  DATTYP        ; A becomes PCODE_STIC (Store character indexed) if DATTYP == 1
00:BE97 48              	   778:          PHA
00:BE98 20B1BA          	   779:          JSR  GETSUB
00:BE9B 4CADBE          	   780:          JMP  ASS2
                        	   781: ;
00:BE9E 200ABB          	   782: ASSVAR   JSR  SYMWRK
00:BEA1 207E92          	   783:          JSR  PSHWRK
00:BEA4 A932            	   784:          LDA  #PCODE_STO    ;  Store integer
00:BEA6 18              	   785:          CLC
00:BEA7 654A            	   786:          ADC  DATTYP        ; A becomes PCODE_STOC (Store character indexed) if DATTYP == 1
00:BEA9 48              	   787:          PHA
00:BEAA 2046CF          	   788:          JSR  pas_get_token
00:BEAD A941            	   789: ASS2     LDA  #TOKEN_ASSIGN
00:BEAF A20D            	   790:          LDX  #13       ; ERROR: := expected
00:BEB1 20AACF          	   791:          JSR  CHKTKN
00:BEB4 205EBB          	   792:          JSR  GETEXPR
00:BEB7 68              	   793:          PLA
00:BEB8 209192          	   794:          JSR  PULWRK
00:BEBB 2015BB          	   795:          JSR  WRKSYM
00:BEBE 48              	   796:          PHA
00:BEBF 20CEBA          	   797:          JSR  GET_LEV
00:BEC2 2033BB          	   798:          JSR  GET_OFF
00:BEC5 68              	   799:          PLA
00:BEC6 4C83C7          	   800:          JMP  GENADR
                        	   801: ;
                        	   802: 
                        	   803: ;
                        	   804: ;
                        	   805: ; WRITELN
                        	   806: ;
00:BEC9 2046CF          	   807: WRITELN  JSR  pas_get_token     ; SEE IF ( PRESENT
00:BECC C928            	   808:          CMP  #'('
00:BECE D003            	   809:          BNE  WRITELN9   ; NOPE
00:BED0 20DBBE          	   810:          JSR  WRIT9
                        	   811: WRITELN9 =  *
00:BED3 A940            	   812:          LDA  #PCODE_OUTCR   ; OUTPUT C/R
00:BED5 4C6AC7          	   813:          JMP  GENNOP
                        	   814: ;
                        	   815: ;
                        	   816: ; WRITE
                        	   817: ;
00:BED8 20A0BA          	   818: WRITE    JSR  CHKLHP
00:BEDB 2046CF          	   819: WRIT9    JSR  pas_get_token
00:BEDE C922            	   820:          CMP  #TOKEN_STRING
00:BEE0 D022            	   821:          BNE  WRIT1
00:BEE2 A923            	   822:          LDA  #PCODE_OUS    ; Output string
00:BEE4 20EABE          	   823:          JSR  W_STRING
00:BEE7 4C14BF          	   824:          JMP  WRIT5
                        	   825: ;
                        	   826: W_STRING =  *
00:BEEA 206AC7          	   827:          JSR  GENNOP
00:BEED A592            	   828:          LDA  token_length
00:BEEF 206AC7          	   829:          JSR  GENNOP
00:BEF2 A000            	   830:          LDY  #0
00:BEF4 B90002          	   831: WRIT2    LDA  INBUF,Y
00:BEF7 C8              	   832: WRIT10   INY
00:BEF8 5A              	   833:          phy
00:BEF9 206AC7          	   834:          JSR  GENNOP
00:BEFC 7A              	   835:          ply
00:BEFD C692            	   836:          DEC  token_length
00:BEFF D0F3            	   837:          BNE  WRIT2
00:BF01 4C46CF          	   838:          JMP  pas_get_token
                        	   839: ;
                        	   840: WRIT1    =  *          ; here if not string
00:BF04 C9AB            	   841:          CMP  #TOKEN_CHR       ; CHR?
00:BF06 F015            	   842:          BEQ  W_CHR      ; yes
00:BF08 C9AC            	   843:          CMP  #TOKEN_HEX       ; HEX?
00:BF0A F019            	   844:          BEQ  W_HEX      ; yes
00:BF0C 20CBBD          	   845:          JSR  EXPRES     ; just ordinary number - get it
00:BF0F A91E            	   846:          LDA  #PCODE_OUT        ; OUT       Output number
00:BF11 206AC7          	   847:          JSR  GENNOP
00:BF14 A593            	   848: WRIT5    LDA  token_type
00:BF16 C92C            	   849:          CMP  #','
00:BF18 F0C1            	   850:          BEQ  WRIT9
00:BF1A 4CA7BA          	   851:          JMP  CHKRHP
                        	   852: ;
                        	   853: ; here for write (chr(x))
                        	   854: ;
                        	   855: W_CHR    =  *
00:BF1D A91F            	   856:          LDA  #PCODE_OUTC   ; OUTC      Output character
                        	   857: W_CHR1   =  *
00:BF1F 2019C0          	   858:          JSR  WAIT_1     ; process expression in parentheses
00:BF22 4C14BF          	   859:          JMP  WRIT5      ; back for next item
                        	   860: ;
                        	   861: ; here for write (hex(x))
                        	   862: ;
                        	   863: W_HEX    =  *
00:BF25 A921            	   864:          LDA  #PCODE_OUH        ; OUH       Output hex number
00:BF27 D0F6            	   865:          BNE  W_CHR1
                        	   866: 
                        	   867: ;
                        	   868: ;
                        	   869: ; WRITELCD: can write number, string, hex or chr
                        	   870: ;
00:BF29 20A0BA          	   871: STMNT_WRITE_LCD    JSR  CHKLHP
00:BF2C 2046CF          	   872: WRITE_LCD9    JSR  pas_get_token
00:BF2F C922            	   873:          CMP  #TOKEN_STRING
00:BF31 D022            	   874:          BNE  WRITE_LCD1
00:BF33 A943            	   875:          LDA  #PCODE_LCD_WRITE_STR    ; Output string
00:BF35 203BBF          	   876:          JSR  WRITE_LCD_STRING
00:BF38 4C65BF          	   877:          JMP  WRITE_LCD5
                        	   878: ;
                        	   879: WRITE_LCD_STRING =  *
00:BF3B 206AC7          	   880:          JSR  GENNOP
00:BF3E A592            	   881:          LDA  token_length
00:BF40 206AC7          	   882:          JSR  GENNOP
00:BF43 A000            	   883:          LDY  #0
00:BF45 B90002          	   884: WRITE_LCD2    LDA  INBUF,Y    ; strings are placed in INBUF during parsing
00:BF48 C8              	   885:          INY
00:BF49 5A              	   886:          phy
00:BF4A 206AC7          	   887:          JSR  GENNOP
00:BF4D 7A              	   888:          ply
00:BF4E C692            	   889:          DEC  token_length
00:BF50 D0F3            	   890:          BNE  WRITE_LCD2
00:BF52 4C46CF          	   891:          JMP  pas_get_token
                        	   892: ;
                        	   893: WRITE_LCD1    =  *            ; here if not string
00:BF55 C9AB            	   894:          CMP  #TOKEN_CHR      ; CHR?
00:BF57 F015            	   895:          BEQ  WRITE_LDC_CHR   ; yes
00:BF59 C9AC            	   896:          CMP  #TOKEN_HEX      ; HEX?
00:BF5B F019            	   897:          BEQ  WRITE_LDC_HEX   ; yes
00:BF5D 20CBBD          	   898:          JSR  EXPRES          ; just ordinary number - get it
00:BF60 A942            	   899:          LDA  #PCODE_LCD_WRITE_NUM        ; OUT       Output number
00:BF62 206AC7          	   900:          JSR  GENNOP
00:BF65 A593            	   901: WRITE_LCD5    LDA  token_type
00:BF67 C92C            	   902:          CMP  #','
00:BF69 F0C1            	   903:          BEQ  WRITE_LCD9
00:BF6B 4CA7BA          	   904:          JMP  CHKRHP
                        	   905: ;
                        	   906: ; here for lcdwrite (chr(x))
                        	   907: ;
                        	   908: WRITE_LDC_CHR    =  *
00:BF6E A945            	   909:          LDA  #PCODE_LCD_WRITE_CHR   ; OUTC     Output character
                        	   910: WRITE_LDC_CHR1   =  *
00:BF70 2019C0          	   911:          JSR  WAIT_1          ; process expression in parentheses
00:BF73 4C65BF          	   912:          JMP  WRITE_LCD5      ; back for next item
                        	   913: ;
                        	   914: ; here for lcdwrite (hex(x))
                        	   915: ;
                        	   916: WRITE_LDC_HEX    =  *
00:BF76 A944            	   917:          LDA  #PCODE_LCD_WRITE_HEX        ; OUH       Output hex number
00:BF78 D0F6            	   918:          BNE  WRITE_LDC_CHR1
                        	   919: 
                        	   920: ;
                        	   921: ;
                        	   922: ; READ
                        	   923: ;
00:BF7A 20A0BA          	   924: READ     jsr  CHKLHP    ; check for "("
00:BF7D 20AFCF          	   925: READ8    jsr  GET_LOOK
00:BF80 200ABB          	   926: READ2    jsr  SYMWRK      ; SYMITM --> WORK
00:BF83 207E92          	   927:          jsr  PSHWRK
00:BF86 A200            	   928:          ldx  #0
00:BF88 864B            	   929:          stx  COUNT1      ; this will have 1 in it if we are reading into an array element
00:BF8A C941            	   930:          cmp  #SYMBOL_ARRAY
00:BF8C F03B            	   931:          beq  READ3
00:BF8E C956            	   932:          cmp  #SYMBOL_VARIABLE
00:BF90 F005            	   933:          beq  READ9
00:BF92 A20C            	   934:          ldx  #12     ; ERROR: Illegal Identifier
00:BF94 4C8397          	   935:          jmp  ERROR
                        	   936: 
00:BF97 2098C9          	   937: READ9    jsr get_token
00:BF9A A91C            	   938: READ11   lda  #PCODE_INP  ; Input number
00:BF9C 18              	   939:          clc
00:BF9D 654A            	   940:          adc  DATTYP      ; becomes PCODE_INPC (input character) if DATTYP == 1
00:BF9F 206AC7          	   941:          jsr  GENNOP
00:BFA2 209192          	   942:          jsr  PULWRK
00:BFA5 2015BB          	   943:          jsr  WRKSYM      ; WORK --> SYMITM
00:BFA8 20D8BA          	   944:          jsr  GET_DAT
00:BFAB 20CEBA          	   945:          jsr  GET_LEV
00:BFAE 2033BB          	   946:          jsr  GET_OFF
00:BFB1 A932            	   947:          lda  #PCODE_STO    ; Store integer
00:BFB3 A64B            	   948:          ldx  COUNT1
00:BFB5 F002            	   949:          beq  READ7
00:BFB7 A936            	   950:          lda  #PCODE_STI    ; Store integer indexed
00:BFB9 18              	   951: READ7    clc
00:BFBA 654A            	   952:          adc  DATTYP        ; add 1 if a char to become PCODE_STOC / PCODE_STIC
00:BFBC 2083C7          	   953:          jsr  GENADR
00:BFBF A593            	   954: READ7_A  lda  token_type
00:BFC1 C92C            	   955:          cmp  #','
00:BFC3 F0B8            	   956:          beq  READ8         ; get another variable to read into
                        	   957: ;
                        	   958: ;  done with READ statement
                        	   959: ;
00:BFC5 20A7BA          	   960:          jsr  CHKRHP        ; check for ")"
00:BFC8 60              	   961:          rts
                        	   962: ;
                        	   963: ;  here for reading into an array
                        	   964: ;
00:BFC9 A54A            	   965: READ3    lda  DATTYP
00:BFCB 48              	   966:          pha              ; push data type of array
00:BFCC 2046CF          	   967:          jsr  pas_get_token
00:BFCF C95B            	   968:          cmp  #'['
00:BFD1 F025            	   969:          beq  READ3_A
00:BFD3 68              	   970:          pla            ; get back data type of array
00:BFD4 854A            	   971:          sta  DATTYP    ; 0 = integer, 1 = char
00:BFD6 D005            	   972:          bne  READ3_B
00:BFD8 A218            	   973:          ldx  #24       ; ERROR: Type mismatch (cannot read into array of integer)
00:BFDA 4C8397          	   974:          jmp  ERROR
00:BFDD 209192          	   975: READ3_B  jsr  PULWRK
00:BFE0 2015BB          	   976:          jsr  WRKSYM     ; WORK --> SYMITM
00:BFE3 A925            	   977:          lda  #PCODE_INS        ; READ STRING - Input string into array
00:BFE5 206AC7          	   978:          jsr  GENNOP
00:BFE8 20CEBA          	   979:          jsr  GET_LEV
00:BFEB 2033BB          	   980:          jsr  GET_OFF
00:BFEE A006            	   981:          ldy  #SYMSUB
00:BFF0 B140            	   982:          lda  (SYMITM),Y  ; maximum array size
00:BFF2 2083C7          	   983:          jsr  GENADR     ; A = length, not the P-code which we just output above
00:BFF5 4CBFBF          	   984:          jmp  READ7_A
                        	   985: ;
                        	   986: ;  read into subscripted item
                        	   987: ;
00:BFF8 205EBB          	   988: READ3_A  jsr  GETEXPR   ; subscript
00:BFFB 20C4BA          	   989:          jsr  CHKRHB    ; check for "]"
00:BFFE E64B            	   990:          inc  COUNT1    ; flag for reading into array element
00:C000 68              	   991:          pla            ; get back data type of array
00:C001 854A            	   992:          sta  DATTYP    ; save
00:C003 4C9ABF          	   993:          jmp  READ11
                        	   994: ;
                        	   995: 
                        	   996: ;
                        	   997: ;
00:C006 20A0BA          	   998: TWO_OP   JSR  CHKLHP
00:C009 205EBB          	   999:          JSR  GETEXPR
00:C00C 2097BB          	  1000: ONE_OP2  JSR  GET_ITEM
00:C00F 20A7BA          	  1001: ONE_OP   JSR  CHKRHP
00:C012 68              	  1002:          PLA
00:C013 4C6AC7          	  1003:          JMP  GENNOP
                        	  1004: 
                        	  1005: 
                        	  1006: 
00:C016 4C6AC7          	  1007: GENNOP2  JMP  GENNOP
                        	  1008: ;
                        	  1009: 
00:C019 48              	  1010: WAIT_1   PHA
00:C01A 20A0BA          	  1011:          JSR  CHKLHP
00:C01D 205EBB          	  1012:          JSR  GETEXPR
00:C020 4C0FC0          	  1013:          JMP  ONE_OP
                        	  1014: ;
                        	  1015: ; MEM
                        	  1016: ;
00:C023 A900            	  1017: MEM      LDA  #0        ; integer
00:C025 48              	  1018:          PHA
00:C026 F003            	  1019:          BEQ  MEM2
00:C028 A901            	  1020: MEMC     LDA  #1        ; character
00:C02A 48              	  1021:          PHA
00:C02B 20B1BA          	  1022: MEM2     JSR  GETSUB
00:C02E A941            	  1023:          LDA  #TOKEN_ASSIGN
00:C030 A20D            	  1024:          LDX  #13     ; ERROR: := expected
00:C032 20AACF          	  1025:          JSR  CHKTKN
00:C035 205EBB          	  1026:          JSR  GETEXPR
00:C038 68              	  1027:          PLA
00:C039 18              	  1028:          CLC
00:C03A 6934            	  1029:          ADC  #PCODE_STA     ; Store integer absolute address (or PCODE_STAC if A == 1)
00:C03C D0D8            	  1030:          BNE  GENNOP2
                        	  1031: ;
                        	  1032: ; CALL ABSOLUTE ADDRESS
                        	  1033: ;
00:C03E 20A0BA          	  1034: CALLSB   JSR  CHKLHP
00:C041 205EBB          	  1035:          JSR  GETEXPR
00:C044 20A7BA          	  1036:          JSR  CHKRHP
00:C047 A92B            	  1037:          LDA  #PCODE_CLA    ; Call absolute address
00:C049 D0CB            	  1038:          BNE  GENNOP2
                        	  1039: ;
                        	  1040: ; FUNCTION OR PROCEDURE CALL
                        	  1041: ;
00:C04B A900            	  1042: FNCPRC   LDA  #0
00:C04D 854B            	  1043:          STA  COUNT1      ; number of arguments
00:C04F A006            	  1044:          LDY  #SYMARG
00:C051 B140            	  1045:          LDA  (SYMITM),Y
00:C053 F033            	  1046:          BEQ  FNC1
00:C055 20A0BA          	  1047:          JSR  CHKLHP
00:C058 A54B            	  1048: FNC2     LDA  COUNT1    ; save on stack in case the expression calls functions
00:C05A 48              	  1049:          PHA
00:C05B 200ABB          	  1050:          JSR  SYMWRK
00:C05E 207E92          	  1051:          JSR  PSHWRK
00:C061 205EBB          	  1052:          JSR  GETEXPR
00:C064 209192          	  1053:          JSR  PULWRK
00:C067 2015BB          	  1054:          JSR  WRKSYM
00:C06A 68              	  1055:          PLA            ; get number of arguments back
00:C06B 854B            	  1056:          STA  COUNT1
00:C06D E64B            	  1057:          INC  COUNT1    ; add 1 for the one we just processed
00:C06F A593            	  1058:          LDA  token_type
00:C071 C92C            	  1059:          CMP  #','
00:C073 F0E3            	  1060:          BEQ  FNC2
00:C075 A54B            	  1061:          LDA  COUNT1
00:C077 A006            	  1062:          LDY  #SYMARG
00:C079 D140            	  1063:          CMP  (SYMITM),Y   ; check we got the right number of arguments
00:C07B F005            	  1064:          BEQ  FNC3
00:C07D A223            	  1065:          LDX  #35     ; ERROR: Parameters mismatched
00:C07F 4C8397          	  1066:          jmp  ERROR
00:C082 20A7BA          	  1067: FNC3     JSR  CHKRHP
00:C085 4C8BC0          	  1068:          JMP  FNC5
00:C088 2046CF          	  1069: FNC1     JSR  pas_get_token
00:C08B 20CEBA          	  1070: FNC5     JSR  GET_LEV
00:C08E 2033BB          	  1071:          JSR  GET_OFF
00:C091 A008            	  1072:          LDY  #SYMDAT
00:C093 B140            	  1073:          LDA  (SYMITM),Y
00:C095 D011            	  1074:          BNE  FNC5A
00:C097 A529            	  1075:          LDA  OFFSET
00:C099 38              	  1076:          SEC
00:C09A E523            	  1077:          SBC  PCODE         ; calculate relative procedure address
00:C09C 8529            	  1078:          STA  OFFSET
00:C09E A52A            	  1079:          LDA  OFFSET+1
00:C0A0 E524            	  1080:          SBC  PCODE+1
00:C0A2 852A            	  1081:          STA  OFFSET+1
00:C0A4 A927            	  1082:          LDA  #PCODE_CLL         ; Relative procedure/function call
00:C0A6 D002            	  1083:          BNE  FNC5B
00:C0A8 A938            	  1084: FNC5A    LDA  #PCODE_ABSCLL      ; Absolute procedure/function call
00:C0AA 2083C7          	  1085: FNC5B    JSR  GENADR
00:C0AD A54B            	  1086:          LDA  COUNT1    ; number of arguments
00:C0AF F01B            	  1087:          BEQ  FNC4
00:C0B1 A54B            	  1088:          LDA  COUNT1     ; TIMES 3
00:C0B3 0A              	  1089:          ASL             ; multiply by two then add one more COUNT1
00:C0B4 B017            	  1090:          BCS  FNC6
00:C0B6 654B            	  1091:          ADC  COUNT1
00:C0B8 854B            	  1092:          STA  COUNT1
00:C0BA B011            	  1093:          BCS  FNC6
00:C0BC A900            	  1094:          LDA  #0
00:C0BE 38              	  1095:          SEC
00:C0BF E54B            	  1096:          SBC  COUNT1
00:C0C1 852B            	  1097:          STA  OPND
00:C0C3 A9FF            	  1098:          LDA  #$FF
00:C0C5 852C            	  1099:          STA  OPND+1      ;  calculate: 0 - (number_of_arguments * 3)
00:C0C7 A93B            	  1100:          LDA  #PCODE_INT     ; Increment stack pointer (allow for arguments)
00:C0C9 20F3C7          	  1101:          JSR  GENJMP
00:C0CC 60              	  1102: FNC4     RTS
00:C0CD A20F            	  1103: FNC6     LDX  #15       ; ERROR: compiler limits exceeded
00:C0CF 4C8397          	  1104:          jmp  ERROR
                        	  1105: ;
                        	  1106: ;
                        	  1107: ; IF
                        	  1108: ;
00:C0D2 205EBB          	  1109: IF       JSR  GETEXPR
00:C0D5 A993            	  1110:          LDA  #TOKEN_THEN
00:C0D7 A210            	  1111:          LDX  #16     ; ERROR: THEN expected
00:C0D9 20AACF          	  1112:          JSR  CHKTKN
00:C0DC 2046CF          	  1113:          JSR  pas_get_token
00:C0DF 2020BB          	  1114:          JSR  PSHPCODE
00:C0E2 A93D            	  1115:          LDA  #PCODE_JMZ     ; JMZ      Jump if (sp) zero
00:C0E4 20EDC7          	  1116:          JSR  GENNJM
00:C0E7 202ABE          	  1117:          JSR  STMNT
00:C0EA A593            	  1118:          LDA  token_type
00:C0EC C994            	  1119:          CMP  #TOKEN_ELSE       ; ELSE
00:C0EE F007            	  1120:          BEQ  IF1
00:C0F0 209192          	  1121: IF2      JSR  PULWRK
00:C0F3 2021C8          	  1122:          JSR  FIXAD
00:C0F6 60              	  1123:          RTS
00:C0F7 209192          	  1124: IF1      JSR  PULWRK     ; HERE FOR ELSE
00:C0FA 2085BB          	  1125:          JSR  WRK_WRKD
00:C0FD 2020BB          	  1126:          JSR  PSHPCODE
00:C100 20EBC7          	  1127:          JSR  GENNJP
00:C103 207ABB          	  1128:          JSR  WRKD_WRK
00:C106 2021C8          	  1129:          JSR  FIXAD
00:C109 2046CF          	  1130:          JSR  pas_get_token
00:C10C 202ABE          	  1131:          JSR  STMNT
00:C10F 4CF0C0          	  1132:          JMP  IF2
                        	  1133: ;
                        	  1134: ; BEGIN
                        	  1135: ;
00:C112 2046CF          	  1136: BEG      JSR  pas_get_token
00:C115 202ABE          	  1137:          JSR  STMNT
00:C118 A593            	  1138:          LDA  token_type
00:C11A C93B            	  1139:          CMP  #';'
00:C11C F0F4            	  1140:          BEQ  BEG
00:C11E A989            	  1141:          LDA  #TOKEN_END       ; END
00:C120 A211            	  1142:          LDX  #17         ; ERROR: ; or END expected
00:C122 20AACF          	  1143:          JSR  CHKTKN
00:C125 4C46CF          	  1144:          JMP  pas_get_token
                        	  1145: ;
                        	  1146: ; REPEAT
                        	  1147: ;
00:C128 2020BB          	  1148: REPEAT   JSR  PSHPCODE
00:C12B 2046CF          	  1149: REP1     JSR  pas_get_token
00:C12E 202ABE          	  1150:          JSR  STMNT
00:C131 A593            	  1151:          LDA  token_type
00:C133 C93B            	  1152:          CMP  #';'
00:C135 F0F4            	  1153:          BEQ  REP1
00:C137 A999            	  1154:          LDA  #TOKEN_UNTIL
00:C139 A20A            	  1155:          LDX  #10           ; ERROR: ; expected
00:C13B 20AACF          	  1156:          JSR  CHKTKN
00:C13E 205EBB          	  1157:          JSR  GETEXPR
00:C141 209192          	  1158:          JSR  PULWRK
00:C144 206FBB          	  1159:          JSR  WRK_OPND
00:C147 A93D            	  1160:          LDA  #PCODE_JMZ         ; JMZ      Jump if (sp) zero
00:C149 4CD9C7          	  1161:          JMP  GENRJMP
                        	  1162: ;
                        	  1163: ; WHILE
                        	  1164: ;
00:C14C 2020BB          	  1165: WHILE    JSR  PSHPCODE
00:C14F 205EBB          	  1166:          JSR  GETEXPR
00:C152 2020BB          	  1167:          JSR  PSHPCODE
00:C155 A93D            	  1168:          LDA  #PCODE_JMZ       ; JMZ      Jump if (sp) zero
00:C157 20EDC7          	  1169:          JSR  GENNJM
00:C15A A997            	  1170:          LDA  #TOKEN_DO
00:C15C A212            	  1171:          LDX  #18             ; ERROR: DO expected
00:C15E 20AACF          	  1172:          JSR  CHKTKN
00:C161 2046CF          	  1173:          JSR  pas_get_token
00:C164 202ABE          	  1174:          JSR  STMNT
00:C167 209192          	  1175:          JSR  PULWRK
00:C16A 2085BB          	  1176:          JSR  WRK_WRKD
00:C16D 209192          	  1177:          JSR  PULWRK
00:C170 206FBB          	  1178:          JSR  WRK_OPND
00:C173 A93C            	  1179:          LDA  #PCODE_JMP     ; JMP      Jump unconditionally
00:C175 20D9C7          	  1180:          JSR  GENRJMP
00:C178 207ABB          	  1181:          JSR  WRKD_WRK
00:C17B 4C21C8          	  1182:          JMP  FIXAD
                        	  1183: ;
                        	  1184: ; CASE
                        	  1185: ;
00:C17E 205EBB          	  1186: CASE     JSR  GETEXPR
00:C181 A985            	  1187:          LDA  #TOKEN_OF       ; OF
00:C183 A21A            	  1188:          LDX  #26         ; ERROR: "of " expected
00:C185 20AACF          	  1189:          JSR  CHKTKN
00:C188 A901            	  1190:          LDA  #1
00:C18A 854B            	  1191:          STA  COUNT1
00:C18C A900            	  1192: CASE7    LDA  #0
00:C18E 854C            	  1193:          STA  COUNT2
                        	  1194: CASE2    =  *
00:C190 A92A            	  1195:          LDA  #PCODE_MOV  ; make copy of selector:  MOV       Copy (sp) to (sp + 1)
00:C192 206AC7          	  1196:          JSR  GENNOP
00:C195 205EBB          	  1197:          JSR  GETEXPR    ; next expression to compare
00:C198 A910            	  1198:          LDA  #PCODE_EQL       ;  EQL       Test (sp - 1) == (sp)
00:C19A 206AC7          	  1199:          JSR  GENNOP
00:C19D A593            	  1200:          LDA  token_type
00:C19F C93A            	  1201:          CMP  #':'
00:C1A1 F014            	  1202:          BEQ  CASE1
00:C1A3 A92C            	  1203:          LDA  #','
00:C1A5 A205            	  1204:          LDX  #5      ; ERROR: , or : expected
00:C1A7 20AACF          	  1205:          JSR  CHKTKN
00:C1AA 2020BB          	  1206:          JSR  PSHPCODE
00:C1AD A93E            	  1207:          LDA  #PCODE_JM1     ; JM1      Jump if (sp) not zero
00:C1AF 20EDC7          	  1208:          JSR  GENNJM
00:C1B2 E64C            	  1209:          INC  COUNT2
00:C1B4 4C90C1          	  1210:          JMP  CASE2
00:C1B7 2064BB          	  1211: CASE1    JSR  PCD_WRKD
00:C1BA A93D            	  1212:          LDA  #PCODE_JMZ     ; JMZ      Jump if (sp) zero
00:C1BC 20EDC7          	  1213:          JSR  GENNJM
00:C1BF A54C            	  1214:          LDA  COUNT2
00:C1C1 F00A            	  1215:          BEQ  CASE3
00:C1C3 209192          	  1216: CASE4    JSR  PULWRK
00:C1C6 2021C8          	  1217:          JSR  FIXAD
00:C1C9 C64C            	  1218:          DEC  COUNT2
00:C1CB D0F6            	  1219:          BNE  CASE4
00:C1CD 207ABB          	  1220: CASE3    JSR  WRKD_WRK
00:C1D0 207E92          	  1221:          JSR  PSHWRK
00:C1D3 2046CF          	  1222:          JSR  pas_get_token
00:C1D6 A54B            	  1223:          LDA  COUNT1
00:C1D8 48              	  1224:          PHA
00:C1D9 202ABE          	  1225:          JSR  STMNT
00:C1DC 68              	  1226:          PLA
00:C1DD 854B            	  1227:          STA  COUNT1
00:C1DF A593            	  1228:          LDA  token_type
00:C1E1 C994            	  1229:          CMP  #TOKEN_ELSE       ; ELSE
00:C1E3 F01B            	  1230:          BEQ  CASE5
00:C1E5 C93B            	  1231:          CMP  #';'
00:C1E7 D035            	  1232:          BNE  CASE6
00:C1E9 2064BB          	  1233:          JSR  PCD_WRKD
00:C1EC 20EBC7          	  1234:          JSR  GENNJP
00:C1EF 209192          	  1235:          JSR  PULWRK
00:C1F2 2021C8          	  1236:          JSR  FIXAD
00:C1F5 207ABB          	  1237:          JSR  WRKD_WRK
00:C1F8 207E92          	  1238:          JSR  PSHWRK
00:C1FB E64B            	  1239:          INC  COUNT1
00:C1FD 4C8CC1          	  1240:          JMP  CASE7
00:C200 2064BB          	  1241: CASE5    JSR  PCD_WRKD
00:C203 20EBC7          	  1242:          JSR  GENNJP
00:C206 209192          	  1243:          JSR  PULWRK
00:C209 2021C8          	  1244:          JSR  FIXAD
00:C20C 207ABB          	  1245:          JSR  WRKD_WRK
00:C20F 207E92          	  1246:          JSR  PSHWRK
00:C212 2046CF          	  1247:          JSR  pas_get_token
00:C215 A54B            	  1248:          LDA  COUNT1
00:C217 48              	  1249:          PHA
00:C218 202ABE          	  1250:          JSR  STMNT
00:C21B 68              	  1251:          PLA
00:C21C 854B            	  1252:          STA  COUNT1
00:C21E A989            	  1253: CASE6    LDA  #TOKEN_END       ; END
00:C220 A211            	  1254:          LDX  #17         ; ERROR: ; or END expected
00:C222 20AACF          	  1255:          JSR  CHKTKN
00:C225 A54B            	  1256:          LDA  COUNT1
00:C227 F00A            	  1257:          BEQ  CASE8
00:C229 209192          	  1258: CASE9    JSR  PULWRK
00:C22C 2021C8          	  1259:          JSR  FIXAD
00:C22F C64B            	  1260:          DEC  COUNT1
00:C231 D0F6            	  1261:          BNE  CASE9
00:C233 20FFC2          	  1262: CASE8    JSR  FOR6
00:C236 4C46CF          	  1263:          JMP  pas_get_token
                        	  1264: ;
                        	  1265: ; FOR
                        	  1266: ;
00:C239 A949            	  1267: FOR      LDA  #TOKEN_IDENTIFIER
00:C23B A204            	  1268:          LDX  #4      ; ERROR:  Identifier expected
00:C23D 209ACF          	  1269:          JSR  GETCHK
00:C240 2034BA          	  1270:          JSR  LOOKUP
00:C243 C956            	  1271: FOR1     CMP  #SYMBOL_VARIABLE
00:C245 F009            	  1272:          BEQ  FOR2
00:C247 C959            	  1273:          CMP  #SYMBOL_FUNCTION_RETURN
00:C249 F005            	  1274:          BEQ  FOR2
00:C24B A20C            	  1275:          LDX  #12   ; ERROR: Illegal Identifier
00:C24D 4C8397          	  1276:          jmp  ERROR
00:C250 209EBE          	  1277: FOR2     JSR  ASSVAR
00:C253 200ABB          	  1278:          JSR  SYMWRK
00:C256 A900            	  1279:          LDA  #0
00:C258 854B            	  1280:          STA  COUNT1
00:C25A A593            	  1281:          LDA  token_type
00:C25C C99B            	  1282:          CMP  #TOKEN_TO       ; TO
00:C25E F009            	  1283:          BEQ  FOR3
00:C260 A99C            	  1284:          LDA  #TOKEN_DOWNTO       ; DOWNTO
00:C262 A21C            	  1285:          LDX  #28       ; ERROR: TO or DOWNTO expected
00:C264 20AACF          	  1286:          JSR  CHKTKN
00:C267 C64B            	  1287:          DEC  COUNT1
00:C269 A54B            	  1288: FOR3     LDA  COUNT1
00:C26B 48              	  1289:          PHA
00:C26C 207E92          	  1290:          JSR  PSHWRK
00:C26F 205EBB          	  1291:          JSR  GETEXPR
00:C272 209192          	  1292:          JSR  PULWRK
00:C275 2015BB          	  1293:          JSR  WRKSYM
00:C278 68              	  1294:          PLA
00:C279 854B            	  1295:          STA  COUNT1
00:C27B 2020BB          	  1296:          JSR  PSHPCODE
00:C27E A92A            	  1297:          LDA  #PCODE_MOV     ; MOV      Copy (sp) to (sp + 1)
00:C280 206AC7          	  1298:          JSR  GENNOP
00:C283 20CEBA          	  1299:          JSR  GET_LEV
00:C286 2033BB          	  1300:          JSR  GET_OFF
00:C289 20D8BA          	  1301:          JSR  GET_DAT
00:C28C 18              	  1302:          CLC
00:C28D 692C            	  1303:          ADC  #PCODE_LOD  ; Load integer onto stack or PCODE_LODC if a char
00:C28F 2083C7          	  1304:          JSR  GENADR
00:C292 A916            	  1305:          LDA  #PCODE_GEQ        ; UP (GEQ): GEQ       Test (sp - 1) >= (sp)
00:C294 A64B            	  1306:          LDX  COUNT1
00:C296 F002            	  1307:          BEQ  FOR4
00:C298 A919            	  1308:          LDA  #PCODE_LEQ        ; DOWN (LEQ): LEQ       Test (sp - 1) <= (sp)
00:C29A 206AC7          	  1309: FOR4     JSR  GENNOP
00:C29D 2020BB          	  1310:          JSR  PSHPCODE
00:C2A0 A93D            	  1311:          LDA  #PCODE_JMZ       ;  JMZ       Jump if (sp) zero
00:C2A2 20EDC7          	  1312:          JSR  GENNJM
00:C2A5 A54B            	  1313:          LDA  COUNT1
00:C2A7 48              	  1314:          PHA
00:C2A8 200ABB          	  1315:          JSR  SYMWRK
00:C2AB 207E92          	  1316:          JSR  PSHWRK
00:C2AE A997            	  1317:          LDA  #TOKEN_DO
00:C2B0 A212            	  1318:          LDX  #18       ; ERROR: DO expected
00:C2B2 20AACF          	  1319:          JSR  CHKTKN
00:C2B5 2046CF          	  1320:          JSR  pas_get_token
00:C2B8 202ABE          	  1321:          JSR  STMNT
00:C2BB 209192          	  1322:          JSR  PULWRK
00:C2BE 2015BB          	  1323:          JSR  WRKSYM
00:C2C1 20CEBA          	  1324:          JSR  GET_LEV
00:C2C4 20D8BA          	  1325:          JSR  GET_DAT
00:C2C7 2033BB          	  1326:          JSR  GET_OFF
00:C2CA A54A            	  1327:          LDA  DATTYP
00:C2CC 18              	  1328:          CLC
00:C2CD 692C            	  1329:          ADC  #PCODE_LOD       ; LOD      Load integer onto stack
00:C2CF 2083C7          	  1330:          JSR  GENADR
00:C2D2 68              	  1331:          PLA
00:C2D3 854B            	  1332:          STA  COUNT1
00:C2D5 A926            	  1333:          LDA  #PCODE_INC     ; INC      Increment (sp) by 1
00:C2D7 A64B            	  1334:          LDX  COUNT1
00:C2D9 F002            	  1335:          BEQ  FOR5
00:C2DB A928            	  1336:          LDA  #PCODE_DEC        ; DEC       Decrement (sp) by 1
00:C2DD 206AC7          	  1337: FOR5     JSR  GENNOP
00:C2E0 A932            	  1338:          LDA  #PCODE_STO       ; STO      Store integer
00:C2E2 18              	  1339:          CLC
00:C2E3 654A            	  1340:          ADC  DATTYP          ; may become PCODE_STOC if a char
00:C2E5 2083C7          	  1341:          JSR  GENADR
00:C2E8 209192          	  1342:          JSR  PULWRK
00:C2EB 2085BB          	  1343:          JSR  WRK_WRKD
00:C2EE 209192          	  1344:          JSR  PULWRK
00:C2F1 206FBB          	  1345:          JSR  WRK_OPND
00:C2F4 A93C            	  1346:          LDA  #PCODE_JMP       ; JMP      Jump unconditionally
00:C2F6 20D9C7          	  1347:          JSR  GENRJMP
00:C2F9 207ABB          	  1348:          JSR  WRKD_WRK
00:C2FC 2021C8          	  1349:          JSR  FIXAD
00:C2FF A9FF            	  1350: FOR6     LDA  #$FF
00:C301 852C            	  1351:          STA  OPND+1
00:C303 A9FD            	  1352:          LDA  #$FD
00:C305 852B            	  1353:          STA  OPND
00:C307 A93B            	  1354:          LDA  #PCODE_INT       ;  INT       Increment stack pointer
00:C309 4CF3C7          	  1355:          JMP  GENJMP
                        	  1356: 
                        	  1357: 
                        	  1358: ;***********************************************
                        	  1359: ; MORE OF THE COMPILER (PROCESSING A 'BLOCK')
                        	  1360: ;***********************************************
                        	  1361: 
                        	  1362: CHKGET   =  *
00:C30C 20AACF          	  1363:          JSR  CHKTKN
00:C30F 4C46CF          	  1364:          JMP  pas_get_token
                        	  1365: ;
                        	  1366: ;  copy WORK to token_value
                        	  1367: ;
                        	  1368: WRK_VAL  =  *
00:C312 48              	  1369:          PHA
00:C313 A537            	  1370:          LDA  WORK
00:C315 8594            	  1371:          STA  token_value
00:C317 A538            	  1372:          LDA  WORK+1
00:C319 8595            	  1373:          STA  token_value+1
00:C31B 68              	  1374:          PLA
00:C31C 60              	  1375:          RTS
                        	  1376: ;
                        	  1377: ;  copy VALUE to WORK
                        	  1378: ;
                        	  1379: VAL_WRK  =  *
00:C31D 48              	  1380:          PHA
00:C31E A594            	  1381:          LDA  token_value
00:C320 8537            	  1382:          STA  WORK
00:C322 A595            	  1383:          LDA  token_value+1
00:C324 8538            	  1384:          STA  WORK+1
00:C326 68              	  1385:          PLA
00:C327 60              	  1386:          RTS
                        	  1387: ;
                        	  1388: ;  copy ENDSYM to WORK
                        	  1389: ;
                        	  1390: END_WRK  =  *
00:C328 48              	  1391:          PHA
00:C329 A531            	  1392:          LDA  ENDSYM
00:C32B 8537            	  1393:          STA  WORK
00:C32D A532            	  1394:          LDA  ENDSYM+1
00:C32F 8538            	  1395:          STA  WORK+1
00:C331 68              	  1396:          PLA
00:C332 60              	  1397:          RTS
                        	  1398: ;
                        	  1399: ;***********************************************
                        	  1400: ;
                        	  1401: ;
                        	  1402: ; BLOCK
                        	  1403: ;
00:C333 82              	  1404: BLCKT1   DFB  TOKEN_CONST
00:C334 8AC3            	  1405:          word BLKCNS
00:C336 83              	  1406: BLCKT2   DFB  TOKEN_VAR
00:C337 A1C3            	  1407:          word BLKVAR
00:C339 86              	  1408: BLCKT3   DFB  TOKEN_PROCEDURE
00:C33A DEC4            	  1409:          word BLKPRC
00:C33C 87              	  1410:          DFB  TOKEN_FUNCTION
00:C33D FEC4            	  1411:          word BLKFNC
00:C33F 88              	  1412:          DFB  TOKEN_BEGIN
00:C340 C6C5            	  1413:          word BLKBEG
00:C342 00              	  1414:          DFB  0
                        	  1415: ;
                        	  1416: ;
00:C343 20C6BB          	  1417: BLOCK    JSR  CHK_STAK
00:C346 A900            	  1418:          LDA  #0
00:C348 8521            	  1419:          STA  FRAME+1
00:C34A A906            	  1420:          LDA  #6
00:C34C 8520            	  1421:          STA  FRAME
00:C34E A539            	  1422:          LDA  PRCITM
00:C350 8537            	  1423:          STA  WORK
00:C352 A63A            	  1424:          LDX  PRCITM+1
00:C354 8638            	  1425:          STX  WORK+1
00:C356 053A            	  1426:          ORA  PRCITM+1
00:C358 F014            	  1427:          BEQ  BLK1
                        	  1428: 
                        	  1429: ;
00:C35A A004            	  1430: BLK1A    LDY  #SYMDSP
00:C35C A523            	  1431:          LDA  PCODE
00:C35E 9137            	  1432:          STA  (WORK),Y
00:C360 C8              	  1433:          INY
00:C361 A524            	  1434:          LDA  PCODE+1
00:C363 9137            	  1435:          STA  (WORK),Y
00:C365 A900            	  1436:          LDA  #0
00:C367 A008            	  1437:          LDY  #SYMDAT
00:C369 9137            	  1438:          STA  (WORK),Y   ; FLAG RELATIVE PROCEDURE
00:C36B 4C76C3          	  1439:          JMP  BLK2
00:C36E A523            	  1440: BLK1     LDA  PCODE
00:C370 8537            	  1441:          STA  WORK
00:C372 A524            	  1442:          LDA  PCODE+1
00:C374 8538            	  1443:          STA  WORK+1
00:C376 207E92          	  1444: BLK2     JSR  PSHWRK
00:C379 20EBC7          	  1445:          JSR  GENNJP
00:C37C A233            	  1446:          LDX  #<BLCKT1
00:C37E A0C3            	  1447:          LDY  #>BLCKT1
00:C380 A593            	  1448: BLK4     LDA  token_type
00:C382 20B18F          	  1449:          JSR  TKNJMP
00:C385 A219            	  1450:          LDX  #25       ; ERROR: BEGIN expected
00:C387 4C8397          	  1451:          jmp  ERROR
                        	  1452: ;
                        	  1453: ;
                        	  1454: ; CONSTANT
                        	  1455: ;
00:C38A 2046CF          	  1456: BLKCNS   JSR  pas_get_token
00:C38D 20DFBA          	  1457: BLKCN1   JSR  CONDEC
00:C390 A93B            	  1458:          LDA  #';'
00:C392 A20A            	  1459:          LDX  #10       ; ERROR: ; expected
00:C394 200CC3          	  1460:          JSR  CHKGET
00:C397 A236            	  1461:          LDX  #<BLCKT2
00:C399 A0C3            	  1462:          LDY  #>BLCKT2
00:C39B 20B18F          	  1463:          JSR  TKNJMP
00:C39E 4C8DC3          	  1464:          JMP  BLKCN1
                        	  1465: ;
                        	  1466: ; VARIABLE
                        	  1467: ;
00:C3A1 A900            	  1468: BLKVAR   LDA  #0
00:C3A3 854B            	  1469:          STA  COUNT1
00:C3A5 2046CF          	  1470: BLKVR1   JSR  pas_get_token
00:C3A8 20F8BB          	  1471: BLKVR6   JSR  VARDEC    ; check we have an identifier, add it to the symbol table, get another token
00:C3AB E64B            	  1472:          INC  COUNT1    ; how many variables in this declaration
00:C3AD 1003            	  1473:          BPL  BLKVR7
00:C3AF 4C1FC4          	  1474:          JMP  BLKV13     ; ERROR  - compiler limits exceeded (more than 127 variables?)
00:C3B2 A593            	  1475: BLKVR7   LDA  token_type
00:C3B4 C92C            	  1476:          CMP  #','
00:C3B6 F0ED            	  1477:          BEQ  BLKVR1    ; back for another
00:C3B8 A93A            	  1478:          LDA  #':'
00:C3BA A205            	  1479:          LDX  #5        ; ERROR: , or : expected
00:C3BC 200CC3          	  1480:          JSR  CHKGET
00:C3BF C984            	  1481:          CMP  #TOKEN_ARRAY   ; ARRAY
00:C3C1 F043            	  1482:          BEQ  BLKVR2
00:C3C3 C9FE            	  1483:          CMP  #TOKEN_INTEGER ; INTEGER
00:C3C5 F00A            	  1484:          BEQ  BLKVR8
00:C3C7 A9A1            	  1485:          LDA  #TOKEN_CHAR    ; CHAR
00:C3C9 A224            	  1486:          LDX  #36            ; ERROR: Data Type not recognised
00:C3CB 20AACF          	  1487:          JSR  CHKTKN
00:C3CE 4CC6C4          	  1488:          JMP  BLKVR3
                        	  1489: 
                        	  1490: ;
                        	  1491: ;  integer variable
                        	  1492: ;
00:C3D1 206BC4          	  1493: BLKVR8   JSR  BLKVR9  ; subtract COUNT1 from FRAME, put WORK into VALUE, put ENDSYM into WORK
                        	  1494: BLKV10   = *
00:C3D4 A008            	  1495:          LDY  #SYMDAT
00:C3D6 A900            	  1496:          LDA  #0         ; INTEGER TYPE
00:C3D8 9137            	  1497:          STA  (WORK),Y
00:C3DA A520            	  1498:          LDA  FRAME
00:C3DC A004            	  1499:          LDY  #SYMDSP
00:C3DE 9137            	  1500:          STA  (WORK),Y
00:C3E0 C8              	  1501:          INY
00:C3E1 A521            	  1502:          LDA  FRAME+1
00:C3E3 9137            	  1503:          STA  (WORK),Y
00:C3E5 18              	  1504:          CLC
00:C3E6 A520            	  1505:          LDA  FRAME
00:C3E8 6903            	  1506:          ADC  #3
00:C3EA 8520            	  1507:          STA  FRAME
00:C3EC 9002            	  1508:          BCC  BLKV10_A
00:C3EE E621            	  1509:          INC  FRAME+1
                        	  1510: BLKV10_A =  *
00:C3F0 C64B            	  1511:          DEC  COUNT1
00:C3F2 D003            	  1512:          BNE  BLKV10_B
00:C3F4 4CC6C4          	  1513:          JMP  BLKVR3
                        	  1514: 
                        	  1515: BLKV10_B = *
                        	  1516: ;
                        	  1517: ;  more in the list, go to the previous symbol
                        	  1518: ;
00:C3F7 A000            	  1519:          LDY  #SYMPRV
00:C3F9 B137            	  1520:          LDA  (WORK),Y
00:C3FB AA              	  1521:          TAX
00:C3FC C8              	  1522:          INY
00:C3FD B137            	  1523:          LDA  (WORK),Y
00:C3FF 8538            	  1524:          STA  WORK+1
00:C401 8A              	  1525:          TXA
00:C402 8537            	  1526:          STA  WORK       ; PREVIOUS ITEM
00:C404 80CE            	  1527:          BRA  BLKV10
                        	  1528: 
                        	  1529: ;
                        	  1530: ; ARRAY [ N ] OF ...
                        	  1531: ;
00:C406 20BABA          	  1532: BLKVR2   JSR  CHKLHB
00:C409 20D2BB          	  1533:          JSR  CONST     ; get how many are in the array
00:C40C A596            	  1534:          LDA  token_value+2   ; can't be more than 65536
00:C40E D00F            	  1535:          BNE  BLKV13
00:C410 A594            	  1536:          LDA  token_value     ; add 1 to the count since array [3] of char means 4 elements
00:C412 18              	  1537:          CLC
00:C413 6901            	  1538:          ADC  #1
00:C415 8594            	  1539:          STA  token_value
00:C417 A595            	  1540:          LDA  token_value+1
00:C419 3004            	  1541:          BMI  BLKV13
00:C41B 6900            	  1542:          ADC  #0
00:C41D 1005            	  1543:          BPL  BLKVR4
00:C41F A20F            	  1544: BLKV13   LDX  #15       ; ERROR: compiler limits exceeded
00:C421 4C8397          	  1545:          jmp  ERROR
00:C424 8595            	  1546: BLKVR4   STA  token_value+1
00:C426 201DC3          	  1547:          JSR  VAL_WRK   ; put the value (array count) in WORK
00:C429 2046CF          	  1548:          JSR  pas_get_token
00:C42C 20C4BA          	  1549:          JSR  CHKRHB
00:C42F A901            	  1550:          LDA  #1        ; char
00:C431 854A            	  1551:          STA  DATTYP
00:C433 A985            	  1552:          LDA  #TOKEN_OF  ; OF
00:C435 A21A            	  1553:          LDX  #26        ; ERROR: "of " expected
00:C437 200CC3          	  1554:          JSR  CHKGET
00:C43A C9FE            	  1555:          CMP  #TOKEN_INTEGER  ; INTEGER
00:C43C D020            	  1556:          BNE  BLKV11
00:C43E C64A            	  1557:          DEC  DATTYP    ; DATTYP of 0 is integer, and 1 is char
00:C440 2012C3          	  1558:          JSR  WRK_VAL   ; get the array count back into token_value
                        	  1559: ;
                        	  1560: ; MULTIPLY token_value BY 3
                        	  1561: ;
00:C443 A594            	  1562:          LDA  token_value
00:C445 A695            	  1563:          LDX  token_value+1
00:C447 0694            	  1564:          ASL  token_value
00:C449 2695            	  1565:          ROL  token_value+1
00:C44B B0D2            	  1566:          BCS  BLKV13
00:C44D 6594            	  1567:          ADC  token_value
00:C44F 8594            	  1568:          STA  token_value
00:C451 8A              	  1569:          TXA
00:C452 6595            	  1570:          ADC  token_value+1
00:C454 B0C9            	  1571:          BCS  BLKV13
00:C456 8595            	  1572:          STA  token_value+1
00:C458 201DC3          	  1573:          JSR  VAL_WRK     ; put the array count (times 3) back into WORK
00:C45B 4C65C4          	  1574:          JMP  BLKV12
                        	  1575:  ;
                        	  1576:  ;  here for array of char
                        	  1577:  ;
00:C45E A9A1            	  1578: BLKV11   LDA  #TOKEN_CHAR       ; CHAR
00:C460 A224            	  1579:          LDX  #36           ; ERROR: Data Type not recognised
00:C462 20AACF          	  1580:          JSR  CHKTKN
00:C465 206BC4          	  1581: BLKV12   JSR  BLKVR9        ; we are COUNT1 frames back
00:C468 4C84C4          	  1582:          JMP  BLKVR5
                        	  1583: 
                        	  1584: BLKVR9   =  *
00:C46B A520            	  1585:          LDA  FRAME         ; subtract COUNT1 (the variable position) from the frame number
00:C46D 38              	  1586:          SEC
00:C46E E54B            	  1587:          SBC  COUNT1
00:C470 8520            	  1588:          STA  FRAME
00:C472 A521            	  1589:          LDA  FRAME+1
00:C474 E900            	  1590:          SBC  #0
00:C476 8521            	  1591:          STA  FRAME+1
00:C478 2012C3          	  1592:          JSR  WRK_VAL     ; copy WORK to VALUE (array count, possibly multiplied by 3)
00:C47B A531            	  1593:          LDA  ENDSYM      ; end of symbol table into WORK
00:C47D 8537            	  1594:          STA  WORK
00:C47F A532            	  1595:          LDA  ENDSYM+1
00:C481 8538            	  1596:          STA  WORK+1
00:C483 60              	  1597:          RTS
                        	  1598: 
                        	  1599: ;
                        	  1600: ;  we should be here with ENDSYM in WORK (for walking back through the symbol table for all the variables we just decla
                        	  1601: ;  COUNT1 will be the number of symbols we have to fix up
                        	  1602: ;
                        	  1603: BLKVR5   = *
00:C484 A003            	  1604:          ldy  #SYMTYP
00:C486 A941            	  1605:          lda  #SYMBOL_ARRAY
00:C488 9137            	  1606:          sta  (WORK),Y    ; make symbol type array
00:C48A A004            	  1607:          ldy  #SYMDSP
00:C48C A520            	  1608:          lda  FRAME       ; FRAME is the displacement
00:C48E 9137            	  1609:          sta  (WORK),Y
00:C490 C8              	  1610:          iny
00:C491 A521            	  1611:          lda  FRAME+1
00:C493 9137            	  1612:          sta  (WORK),Y
00:C495 A594            	  1613:          lda  token_value       ; array count (multiplied by 3 in the case of integers)
00:C497 18              	  1614:          clc
00:C498 6520            	  1615:          adc  FRAME       ; add to the stack frame address
00:C49A 8520            	  1616:          sta  FRAME
00:C49C A595            	  1617:          lda  token_value+1
00:C49E 6521            	  1618:          adc  FRAME+1
00:C4A0 8521            	  1619:          sta  FRAME+1
00:C4A2 A008            	  1620:          ldy  #SYMDAT
00:C4A4 A54A            	  1621:          lda  DATTYP       ; save the data type in the symbol
00:C4A6 9137            	  1622:          sta  (WORK),Y
00:C4A8 A006            	  1623:          ldy  #SYMSUB
00:C4AA A594            	  1624:          lda  token_value        ; max subscript + 1
00:C4AC 9137            	  1625:          sta  (WORK),Y
00:C4AE A595            	  1626:          lda  token_value+1
00:C4B0 C8              	  1627:          iny
00:C4B1 9137            	  1628:          sta  (WORK),Y
00:C4B3 C64B            	  1629:          dec  COUNT1
00:C4B5 F00F            	  1630:          beq  BLKVR3
                        	  1631: ;
                        	  1632: ;  onto the previous symbol
                        	  1633: ;
00:C4B7 A000            	  1634:          ldy  #SYMPRV
00:C4B9 B137            	  1635:          lda  (WORK),Y
00:C4BB AA              	  1636:          tax
00:C4BC C8              	  1637:          iny
00:C4BD B137            	  1638:          lda  (WORK),Y
00:C4BF 8538            	  1639:          sta  WORK+1
00:C4C1 8A              	  1640:          txa
00:C4C2 8537            	  1641:          sta  WORK       ; PREVIOUS ITEM
00:C4C4 80BE            	  1642:          bra  BLKVR5
                        	  1643: ;
                        	  1644: ;  here at end of variable declaration (after INTEGER / CHAR)
                        	  1645: ;
00:C4C6 A93B            	  1646: BLKVR3   LDA  #';'
00:C4C8 A20A            	  1647:          LDX  #10       ; ERROR: ; expected
00:C4CA 209ACF          	  1648:          JSR  GETCHK
00:C4CD 2046CF          	  1649:          JSR  pas_get_token
00:C4D0 A239            	  1650:          LDX  #<BLCKT3  ; now look for procedure / function / begin
00:C4D2 A0C3            	  1651:          LDY  #>BLCKT3
00:C4D4 20B18F          	  1652:          JSR  TKNJMP    ; if not there, look for another variable declaration
00:C4D7 A900            	  1653:          LDA  #0        ; zero variables in this list so far
00:C4D9 854B            	  1654:          STA  COUNT1
00:C4DB 4CA8C3          	  1655:          JMP  BLKVR6
                        	  1656: ;
                        	  1657: ; PROCEDURE DECLARATION
                        	  1658: ;
00:C4DE A949            	  1659: BLKPRC   LDA  #'I'
00:C4E0 A204            	  1660:          LDX  #4         ; ERROR: Identifier expected
00:C4E2 209ACF          	  1661:          JSR  GETCHK
00:C4E5 A900            	  1662:          LDA  #0
00:C4E7 854B            	  1663:          STA  COUNT1    ; no function return value
00:C4E9 203FBA          	  1664:          JSR  CHKDUP
00:C4EC A950            	  1665:          LDA  #SYMBOL_PROCEDURE
00:C4EE 2098B9          	  1666:          JSR  ADDSYM
00:C4F1 E622            	  1667:          INC  LEVEL
00:C4F3 A540            	  1668:          LDA  SYMITM
00:C4F5 8539            	  1669:          STA  PRCITM    ; PRCITM is the symbol of the procedure/function
00:C4F7 A541            	  1670:          LDA  SYMITM+1
00:C4F9 853A            	  1671:          STA  PRCITM+1
00:C4FB 4C20C5          	  1672:          JMP  BLKPR1
                        	  1673: ;
                        	  1674: ; FUNCTION DECLARATION
                        	  1675: ;
00:C4FE A949            	  1676: BLKFNC   LDA  #TOKEN_IDENTIFIER
00:C500 A204            	  1677:          LDX  #4      ; ERROR: Identifier expected
00:C502 209ACF          	  1678:          JSR  GETCHK
00:C505 203FBA          	  1679:          JSR  CHKDUP
00:C508 A946            	  1680:          LDA  #SYMBOL_FUNCTION
00:C50A 2098B9          	  1681:          JSR  ADDSYM
00:C50D E622            	  1682:          INC  LEVEL
00:C50F A901            	  1683:          LDA  #1
00:C511 854B            	  1684:          STA  COUNT1    ; we have the function return as a symbol
00:C513 A540            	  1685:          LDA  SYMITM
00:C515 8539            	  1686:          STA  PRCITM   ; PRCITM is the symbol of the procedure/function
00:C517 A541            	  1687:          LDA  SYMITM+1
00:C519 853A            	  1688:          STA  PRCITM+1
00:C51B A959            	  1689:          LDA  #SYMBOL_FUNCTION_RETURN ; for assigning the results to
00:C51D 2098B9          	  1690:          JSR  ADDSYM
                        	  1691: ;
                        	  1692: ; PROCEDURE AND FUNCTION COMMON CODE
                        	  1693: ;
00:C520 A54B            	  1694: BLKPR1   LDA  COUNT1
00:C522 854C            	  1695:          STA  COUNT2    ; remember if we had 0 or 1 extra symbols (function return)
00:C524 2028C3          	  1696:          JSR  END_WRK
00:C527 207E92          	  1697:          JSR  PSHWRK
00:C52A A520            	  1698:          LDA  FRAME
00:C52C 8537            	  1699:          STA  WORK
00:C52E A521            	  1700:          LDA  FRAME+1
00:C530 8538            	  1701:          STA  WORK+1
00:C532 207E92          	  1702:          JSR  PSHWRK
00:C535 2046CF          	  1703:          JSR  pas_get_token
00:C538 C928            	  1704:          CMP  #'('      ; opening bracket after procedure/function name?
00:C53A D016            	  1705:          BNE  BLKPR2
00:C53C 2046CF          	  1706: BLKPR3   JSR  pas_get_token
00:C53F 20F8BB          	  1707:          JSR  VARDEC
00:C542 E64B            	  1708:          INC  COUNT1    ; count arguments
00:C544 1003            	  1709:          BPL  BLKPR6
00:C546 4C1FC4          	  1710:          JMP  BLKV13
00:C549 A593            	  1711: BLKPR6   LDA  token_type
00:C54B C92C            	  1712:          CMP  #','
00:C54D F0ED            	  1713:          BEQ  BLKPR3
00:C54F 20A7BA          	  1714:          JSR  CHKRHP
00:C552 A539            	  1715: BLKPR2   LDA  PRCITM      ; here after argument list, if any
00:C554 8537            	  1716:          STA  WORK
00:C556 A53A            	  1717:          LDA  PRCITM+1
00:C558 8538            	  1718:          STA  WORK+1
00:C55A A006            	  1719:          LDY  #SYMARG
00:C55C A54B            	  1720:          LDA  COUNT1
00:C55E 38              	  1721:          SEC
00:C55F E54C            	  1722:          SBC  COUNT2      ; subtract 0 or 1 depending on if this is a function or not
00:C561 9137            	  1723:          STA  (WORK),Y    ; store the number of arguments to this procedure/function
00:C563 A93B            	  1724:          LDA  #';'
00:C565 A20A            	  1725:          LDX  #10         ; ERROR: ; expected
00:C567 20AACF          	  1726:          JSR  CHKTKN
00:C56A A54B            	  1727:          LDA  COUNT1
00:C56C F02C            	  1728:          BEQ  BLKPR4
00:C56E 2028C3          	  1729:          JSR  END_WRK     ; ENDSYM -> WORK
00:C571 A2FD            	  1730:          LDX  #$FD        ; X = -3
                        	  1731: ; WORK starts off pointing to the procedure/function symbol
                        	  1732: BLKPR5   = *
00:C573 A008            	  1733:          LDY  #SYMDAT
00:C575 A900            	  1734:          LDA  #0
00:C577 9137            	  1735:          STA  (WORK),Y    ; data type = integer
00:C579 A004            	  1736:          LDY  #SYMDSP
00:C57B 8A              	  1737:          TXA
00:C57C 9137            	  1738:          STA  (WORK),Y
00:C57E 38              	  1739:          SEC
00:C57F E903            	  1740:          SBC  #3
00:C581 AA              	  1741:          TAX
00:C582 A9FF            	  1742:          LDA  #$FF
00:C584 C8              	  1743:          INY
00:C585 9137            	  1744:          STA  (WORK),Y
00:C587 C64B            	  1745:          DEC  COUNT1
00:C589 F00F            	  1746:          beq  BLKPR4
                        	  1747: ;
                        	  1748: ;  back to previous symbol
                        	  1749: ;
00:C58B A000            	  1750:          LDY  #SYMPRV
00:C58D B137            	  1751:          LDA  (WORK),Y
00:C58F 48              	  1752:          PHA
00:C590 C8              	  1753:          INY
00:C591 B137            	  1754:          LDA  (WORK),Y
00:C593 8538            	  1755:          STA  WORK+1
00:C595 68              	  1756:          PLA
00:C596 8537            	  1757:          STA  WORK
00:C598 80D9            	  1758:          bra  BLKPR5
00:C59A 2046CF          	  1759: BLKPR4   JSR  pas_get_token
00:C59D 2043C3          	  1760:          JSR  BLOCK
00:C5A0 C622            	  1761:          DEC  LEVEL
00:C5A2 209192          	  1762:          JSR  PULWRK
00:C5A5 A537            	  1763:          LDA  WORK
00:C5A7 8520            	  1764:          STA  FRAME
00:C5A9 A538            	  1765:          LDA  WORK+1
00:C5AB 8521            	  1766:          STA  FRAME+1
00:C5AD 209192          	  1767:          JSR  PULWRK
00:C5B0 A537            	  1768:          LDA  WORK
00:C5B2 8531            	  1769:          STA  ENDSYM
00:C5B4 A538            	  1770:          LDA  WORK+1
00:C5B6 8532            	  1771:          STA  ENDSYM+1
00:C5B8 A93B            	  1772:          LDA  #';'
00:C5BA A20A            	  1773:          LDX  #10       ; ERROR: ; expected
00:C5BC 200CC3          	  1774:          JSR  CHKGET
00:C5BF A239            	  1775:          LDX  #<BLCKT3
00:C5C1 A0C3            	  1776:          LDY  #>BLCKT3
00:C5C3 4C80C3          	  1777:          JMP  BLK4
                        	  1778: ;
                        	  1779: ; BEGIN (COMPOUND STATEMENT)
                        	  1780: ;
00:C5C6 2046CF          	  1781: BLKBEG   JSR  pas_get_token
00:C5C9 209192          	  1782:          JSR  PULWRK
00:C5CC A522            	  1783:          LDA  LEVEL
00:C5CE D006            	  1784:          BNE  BLKB1
00:C5D0 2021C8          	  1785: BLKB3    JSR  FIXAD
00:C5D3 4CF2C5          	  1786:          JMP  BLKB2
00:C5D6 2015BB          	  1787: BLKB1    JSR  WRKSYM
00:C5D9 A004            	  1788:          LDY  #SYMDSP
00:C5DB B140            	  1789:          LDA  (SYMITM),Y
00:C5DD 8537            	  1790:          STA  WORK
00:C5DF C8              	  1791:          INY
00:C5E0 B140            	  1792:          LDA  (SYMITM),Y
00:C5E2 8538            	  1793:          STA  WORK+1
00:C5E4 A004            	  1794:          LDY  #SYMDSP
00:C5E6 A523            	  1795:          LDA  PCODE
00:C5E8 9140            	  1796:          STA  (SYMITM),Y
00:C5EA A524            	  1797:          LDA  PCODE+1
00:C5EC C8              	  1798:          INY
00:C5ED 9140            	  1799:          STA  (SYMITM),Y
00:C5EF 4CD0C5          	  1800:          JMP  BLKB3
00:C5F2 A520            	  1801: BLKB2    LDA  FRAME
00:C5F4 852B            	  1802:          STA  OPND
00:C5F6 A521            	  1803:          LDA  FRAME+1
00:C5F8 852C            	  1804:          STA  OPND+1
00:C5FA A93B            	  1805:          LDA  #PCODE_INT         ; INT      Increment stack pointer
00:C5FC 20F3C7          	  1806:          JSR  GENJMP
00:C5FF 202ABE          	  1807: BLKB5    JSR  STMNT
00:C602 A593            	  1808:          LDA  token_type
00:C604 C93B            	  1809:          CMP  #';'
00:C606 D006            	  1810:          BNE  BLKB4
00:C608 2046CF          	  1811:          JSR  pas_get_token
00:C60B 4CFFC5          	  1812:          JMP  BLKB5
00:C60E A989            	  1813: BLKB4    LDA  #TOKEN_END       ; END
00:C610 A211            	  1814:          LDX  #17         ; ERROR: ; or END expected
00:C612 200CC3          	  1815:          JSR  CHKGET
00:C615 A929            	  1816:          LDA  #PCODE_RTN  ; OK - we are at the end of a block - this is a procedure/function return
00:C617 A622            	  1817:          LDX  LEVEL       ; OR - if we are at level 0, then that is the end of the program
00:C619 D002            	  1818:          BNE  BLKB6
00:C61B A911            	  1819:          LDA  #PCODE_FINISHD        ; Opcode: FINISHED  Stop run (end program)
                        	  1820: TEST1    =  *
00:C61D 4C6AC7          	  1821: BLKB6    JMP  GENNOP
                        	  1822: ;
                        	  1823: 
                        	  1824: 
                        	  1825: ;
                        	  1826: ;  Writing library functions is quite easy:
                        	  1827: ;
                        	  1828: ;   1. For each of the n arguments that they have (could be zero) do a PULTOP to get
                        	  1829: ;      that value from the runtime stack into REG. Or, PULTOP2 to get the value into REG2.
                        	  1830: ;      For two arguments you can do PULBOTH to get them into REG and REG2.
                        	  1831: ;   2. Do whatever the function/procedure is supposed to do with those arguments
                        	  1832: ;   3. If a procedure, you are finished: JMP MAIN
                        	  1833: ;      For a function, put the result into REG, and then JMP MAINP
                        	  1834: ;      - or - (equivalently): JSR PSHTOP, JMP MAIN
                        	  1835: ;
                        	  1836: ;  Note: PULTOP puts the value into REG and also: A, X and Y registers where A is the low-order
                        	  1837: ;        byte, X the middle byte, and Y the high-order byte.
                        	  1838: ;
                        	  1839: 
                        	  1840: ;                         Name           function or procedure   Args Execution address
                        	  1841: pascal_library_functions_table:
                        	  1842: ;
                        	  1843: ;    functions
                        	  1844: ;
                        	  1845:   makePasLibraryFunction "ABS",          SYMBOL_LIBRARY_FUNCTION,  1, EX_ABS
00:C620 414253          	     1M      asciiz   "ABS"
00:C623 00
00:C624 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:C625 01              	     3M      dfb      1
00:C626 05B1            	     4M      word     EX_ABS
                        	  1846:   makePasLibraryFunction "DIGITALREAD",  SYMBOL_LIBRARY_FUNCTION,  1, EX_DIGITALREAD
00:C628 4449474954414C52	     1M      asciiz   "DIGITALREAD"
00:C630 454144
00:C633 00
00:C634 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:C635 01              	     3M      dfb      1
00:C636 7FB5            	     4M      word     EX_DIGITALREAD
                        	  1847:   makePasLibraryFunction "GETKEY",       SYMBOL_LIBRARY_FUNCTION,  0, EX_GETKEY
00:C638 4745544B4559    	     1M      asciiz   "GETKEY"
00:C63E 00
00:C63F 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:C640 00              	     3M      dfb      0
00:C641 BFB0            	     4M      word     EX_GETKEY
                        	  1848:   makePasLibraryFunction "RANDOM",       SYMBOL_LIBRARY_FUNCTION,  0, EX_RANDOM
00:C643 52414E444F4D    	     1M      asciiz   "RANDOM"
00:C649 00
00:C64A 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:C64B 00              	     3M      dfb      0
00:C64C A7B5            	     4M      word     EX_RANDOM
                        	  1849:   makePasLibraryFunction "LATENCY",      SYMBOL_LIBRARY_FUNCTION,  0, EX_LATENCY
00:C64E 4C4154454E4359  	     1M      asciiz   "LATENCY"
00:C655 00
00:C656 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:C657 00              	     3M      dfb      0
00:C658 B9B5            	     4M      word     EX_LATENCY
                        	  1850: ;
                        	  1851: ;      procedures
                        	  1852: ;
                        	  1853:   makePasLibraryFunction "ASSERT",       SYMBOL_LIBRARY_PROCEDURE, 1, EX_ASSERT
00:C65A 415353455254    	     1M      asciiz   "ASSERT"
00:C660 00
00:C661 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C662 01              	     3M      dfb      1
00:C663 0CB6            	     4M      word     EX_ASSERT
                        	  1854:   makePasLibraryFunction "DELAY",        SYMBOL_LIBRARY_PROCEDURE, 1, EX_DELAY
00:C665 44454C4159      	     1M      asciiz   "DELAY"
00:C66A 00
00:C66B 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C66C 01              	     3M      dfb      1
00:C66D C8B5            	     4M      word     EX_DELAY
                        	  1855:   makePasLibraryFunction "DIGITALWRITE", SYMBOL_LIBRARY_PROCEDURE, 2, EX_DIGITALWRITE
00:C66F 4449474954414C57	     1M      asciiz   "DIGITALWRITE"
00:C677 52495445
00:C67B 00
00:C67C 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C67D 02              	     3M      dfb      2
00:C67E F7B5            	     4M      word     EX_DIGITALWRITE
                        	  1856:   makePasLibraryFunction "LCDCLEAR",     SYMBOL_LIBRARY_PROCEDURE, 0, EX_LCDCLEAR
00:C680 4C4344434C454152	     1M      asciiz   "LCDCLEAR"
00:C688 00
00:C689 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C68A 00              	     3M      dfb      0
00:C68B F1B4            	     4M      word     EX_LCDCLEAR
                        	  1857:   makePasLibraryFunction "LCDHOME",      SYMBOL_LIBRARY_PROCEDURE, 0, EX_LCDHOME
00:C68D 4C4344484F4D45  	     1M      asciiz   "LCDHOME"
00:C694 00
00:C695 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C696 00              	     3M      dfb      0
00:C697 EBB4            	     4M      word     EX_LCDHOME
                        	  1858:   makePasLibraryFunction "LCDPOS",       SYMBOL_LIBRARY_PROCEDURE, 2, EX_LCDPOS
00:C699 4C4344504F53    	     1M      asciiz   "LCDPOS"
00:C69F 00
00:C6A0 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C6A1 02              	     3M      dfb      2
00:C6A2 8DB5            	     4M      word     EX_LCDPOS
                        	  1859:   makePasLibraryFunction "PINMODE",      SYMBOL_LIBRARY_PROCEDURE, 2, EX_PINMODE
00:C6A4 50494E4D4F4445  	     1M      asciiz   "PINMODE"
00:C6AB 00
00:C6AC 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C6AD 02              	     3M      dfb      2
00:C6AE E8B5            	     4M      word     EX_PINMODE
                        	  1860:   makePasLibraryFunction "RANDOMSEED",   SYMBOL_LIBRARY_PROCEDURE, 1, EX_RANDOMSEED
00:C6B0 52414E444F4D5345	     1M      asciiz   "RANDOMSEED"
00:C6B8 4544
00:C6BA 00
00:C6BB 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C6BC 01              	     3M      dfb      1
00:C6BD D8B5            	     4M      word     EX_RANDOMSEED
00:C6BF 00              	  1861:   dfb 0   ; end of table
                        	  1862: 
                        	  1863: add_pascal_library_functions:
00:C6C0 A920            	  1864:   lda #<pascal_library_functions_table
00:C6C2 8500            	  1865:   sta REG
00:C6C4 A9C6            	  1866:   lda #>pascal_library_functions_table
00:C6C6 8501            	  1867:   sta REG+1
                        	  1868: add_pascal_library_functions_loop:
00:C6C8 A000            	  1869:   ldy #0
00:C6CA B100            	  1870:   lda (REG),Y
00:C6CC F04B            	  1871:   beq add_pascal_library_functions_done
00:C6CE A500            	  1872:   lda REG
00:C6D0 8590            	  1873:   sta token_address
00:C6D2 A501            	  1874:   lda REG+1
00:C6D4 8591            	  1875:   sta token_address+1
00:C6D6 6492            	  1876:   stz token_length
                        	  1877: ;
                        	  1878: ;  find name length
                        	  1879: ;
                        	  1880: add_pascal_library_functions_name_loop
00:C6D8 C8              	  1881:   iny
00:C6D9 E692            	  1882:   inc token_length
00:C6DB B100            	  1883:   lda (REG),Y
00:C6DD D0F9            	  1884:   bne add_pascal_library_functions_name_loop
00:C6DF 5A              	  1885:   phy
00:C6E0 A943            	  1886:   lda #SYMBOL_CONSTANT  ; add the symbol as a constant for now
00:C6E2 2098B9          	  1887:   jsr ADDSYM
00:C6E5 7A              	  1888:   ply
                        	  1889: 
00:C6E6 C8              	  1890:   iny             ; get past the 0x00
00:C6E7 B100            	  1891:   lda (REG),Y     ; get symbol type
00:C6E9 5A              	  1892:   phy
00:C6EA A003            	  1893:   ldy #SYMTYP
00:C6EC 9140            	  1894:   sta (SYMITM),Y  ; change symbol type to be correct
00:C6EE 7A              	  1895:   ply
                        	  1896: 
00:C6EF C8              	  1897:   iny             ; get next byte
00:C6F0 B100            	  1898:   lda (REG),Y     ; get number of arguments
00:C6F2 5A              	  1899:   phy
00:C6F3 A006            	  1900:   ldy #SYMARG
00:C6F5 9140            	  1901:   sta (SYMITM),Y  ; save number of arguments
00:C6F7 7A              	  1902:   ply
                        	  1903: 
00:C6F8 C8              	  1904:   iny             ; get next byte
00:C6F9 B100            	  1905:   lda (REG),Y     ; get function address low-byte
00:C6FB 5A              	  1906:   phy
00:C6FC A004            	  1907:   ldy #SYMDSP
00:C6FE 9140            	  1908:   sta (SYMITM),Y  ; save function address low-byte
00:C700 7A              	  1909:   ply
                        	  1910: 
00:C701 C8              	  1911:   iny             ; get next byte
00:C702 B100            	  1912:   lda (REG),Y     ; get function address high-byte
00:C704 5A              	  1913:   phy
00:C705 A005            	  1914:   ldy #SYMDSP+1
00:C707 9140            	  1915:   sta (SYMITM),Y  ; save function address high-byte
00:C709 7A              	  1916:   ply
                        	  1917: 
00:C70A C8              	  1918:   iny         ; get past that last byte
00:C70B 98              	  1919:   tya         ; move REG onto next entry
00:C70C 18              	  1920:   clc
00:C70D 6500            	  1921:   adc REG
00:C70F 8500            	  1922:   sta REG
00:C711 A900            	  1923:   lda #0
00:C713 6501            	  1924:   adc REG+1
00:C715 8501            	  1925:   sta REG+1
00:C717 80AF            	  1926:   bra add_pascal_library_functions_loop
                        	  1927: 
                        	  1928: add_pascal_library_functions_done:
00:C719 60              	  1929:   rts
                        	  1930: 
                        	  1931: 
                        	  1932: library_function_call:
                        	  1933: 
00:C71A A900            	  1934:   lda  #0
00:C71C 854B            	  1935:   sta  COUNT1      ; number of arguments
00:C71E A006            	  1936:   ldy  #SYMARG
00:C720 B140            	  1937:   lda  (SYMITM),Y
00:C722 F032            	  1938:   beq  library_function_call_1
                        	  1939: 
                        	  1940: ;
                        	  1941: ;  here if it has arguments - push them on the stack
                        	  1942: ;
                        	  1943: 
00:C724 20A0BA          	  1944:   jsr  CHKLHP
                        	  1945: library_function_call_2
00:C727 A54B            	  1946:   lda  COUNT1    ; save on stack in case the expression calls functions
00:C729 48              	  1947:   pha
00:C72A 200ABB          	  1948:   jsr  SYMWRK
00:C72D 207E92          	  1949:   jsr  PSHWRK
00:C730 205EBB          	  1950:   jsr  GETEXPR
00:C733 209192          	  1951:   jsr  PULWRK
00:C736 2015BB          	  1952:   jsr  WRKSYM
00:C739 68              	  1953:   pla            ; get number of arguments back
00:C73A 854B            	  1954:   sta  COUNT1
00:C73C E64B            	  1955:   inc  COUNT1    ; add 1 for the one we just processed
00:C73E A593            	  1956:   lda  token_type
00:C740 C92C            	  1957:   cmp  #','
00:C742 F0E3            	  1958:   beq  library_function_call_2
                        	  1959: 
00:C744 A54B            	  1960:   lda  COUNT1
00:C746 A006            	  1961:   ldy  #SYMARG
00:C748 D140            	  1962:   cmp  (SYMITM),Y   ; check we got the right number of arguments
00:C74A F005            	  1963:   beq  library_function_call_3
                        	  1964: 
00:C74C A223            	  1965:   ldx  #35     ; ERROR: Parameters mismatched
00:C74E 4C8397          	  1966:   jmp  ERROR
                        	  1967: library_function_call_3:
00:C751 20A7BA          	  1968:   jsr  CHKRHP
00:C754 8003            	  1969:   bra  library_function_call_5
                        	  1970: 
                        	  1971: ;
                        	  1972: ;  here for no arguments
                        	  1973: ;
                        	  1974: 
                        	  1975: library_function_call_1:
00:C756 2046CF          	  1976:   jsr  pas_get_token      ; one token look-ahead
                        	  1977: 
                        	  1978: library_function_call_5:
00:C759 A004            	  1979:   ldy  #SYMDSP
00:C75B B140            	  1980:   lda  (SYMITM),Y
00:C75D 852B            	  1981:   sta  OPND
00:C75F C8              	  1982:   iny
00:C760 B140            	  1983:   lda  (SYMITM),Y
00:C762 852C            	  1984:   sta  OPND+1
00:C764 A903            	  1985:   lda  #PCODE_LIB_CALL
00:C766 20F3C7          	  1986:   jsr  GENJMP
00:C769 60              	  1987:   rts
                        	  1988: 
                        	  1989: 
                        	  1990: ;***********************************************
                        	  1991: ; GENERATE P-CODES - NO OPERANDS
                        	  1992: ;***********************************************
                        	  1993: GENNOP   =  *
00:C76A A442            	  1994:          LDY  SYNTAX
00:C76C D011            	  1995:          BNE  GEN1      ; no storing/displaying if syntax-only compile
00:C76E 9123            	  1996:          STA  (PCODE),Y
00:C770 48              	  1997:          PHA
00:C771 206292          	  1998:          JSR  DISPAD
00:C774 68              	  1999:          PLA
00:C775 A62E            	  2000:          LDX  DCODE
00:C777 F006            	  2001:          BEQ  GEN1
00:C779 205C92          	  2002:          JSR  DISHX
00:C77C 204792          	  2003:          JSR  CROUT
                        	  2004: GEN1     =  *
00:C77F A901            	  2005:          LDA  #1      ; 1-byte P-code
00:C781 D035            	  2006:          BNE  GEN2_B
                        	  2007: ;***********************************************
                        	  2008: ; GENERATE P-CODES - WITH ADDRESS (3-bytes stored in DISPL (1)/OFFSET(2))
                        	  2009: ;***********************************************
                        	  2010: GENADR   =  *
00:C783 A442            	  2011:          LDY  SYNTAX
00:C785 D02F            	  2012:          BNE  GEN2    ; no storing/displaying if syntax-only compile
00:C787 9123            	  2013:          STA  (PCODE),Y
00:C789 48              	  2014:          PHA
00:C78A A527            	  2015:          LDA  DISPL
00:C78C C8              	  2016:          INY
00:C78D 9123            	  2017:          STA  (PCODE),Y
00:C78F A529            	  2018:          LDA  OFFSET
00:C791 C8              	  2019:          INY
00:C792 9123            	  2020:          STA  (PCODE),Y
00:C794 A52A            	  2021:          LDA  OFFSET+1
00:C796 C8              	  2022:          INY
00:C797 9123            	  2023:          STA  (PCODE),Y
00:C799 206292          	  2024:          JSR  DISPAD
00:C79C 68              	  2025:          PLA
00:C79D A62E            	  2026:          LDX  DCODE
00:C79F F015            	  2027:          BEQ  GEN2
00:C7A1 205C92          	  2028:          JSR  DISHX
00:C7A4 A527            	  2029:          LDA  DISPL
00:C7A6 205C92          	  2030:          JSR  DISHX
00:C7A9 A529            	  2031:          LDA  OFFSET
00:C7AB 205C92          	  2032:          JSR  DISHX
00:C7AE A52A            	  2033:          LDA  OFFSET+1
00:C7B0 205C92          	  2034:          JSR  DISHX
00:C7B3 204792          	  2035:          JSR  CROUT
                        	  2036: GEN2     =  *
00:C7B6 A904            	  2037:          LDA  #4      ; 4-byte P-code
                        	  2038: GEN2_B   =  *
00:C7B8 18              	  2039:          CLC
00:C7B9 6523            	  2040:          ADC  PCODE
00:C7BB 8523            	  2041:          STA  PCODE
00:C7BD 9002            	  2042:          BCC  GEN2_A
00:C7BF E624            	  2043:          INC  PCODE+1
                        	  2044: GEN2_A   =  *
00:C7C1 A542            	  2045:          LDA  SYNTAX
00:C7C3 D013            	  2046:          BNE  GEN2_C      ; no storing/displaying if syntax-only compile
00:C7C5 A524            	  2047:          LDA  PCODE+1     ; see if P-codes full
00:C7C7 C532            	  2048:          CMP  ENDSYM+1   ; in other words, have we hit the symbol table?
00:C7C9 900D            	  2049:          BCC  GEN2_C      ; less than
00:C7CB D006            	  2050:          BNE  GEN_FULL
00:C7CD A523            	  2051:          LDA  PCODE
00:C7CF C531            	  2052:          CMP  ENDSYM   ; TODO - what?
00:C7D1 9005            	  2053:          BCC  GEN2_C
00:C7D3 A201            	  2054: GEN_FULL LDX  #1         ; MEM FULL
00:C7D5 4C8397          	  2055:          jmp  ERROR
                        	  2056: GEN2_C   =  *
00:C7D8 60              	  2057: DISP9    RTS
                        	  2058: ;***********************************************
                        	  2059: ; GENERATE P-CODES - JUMP ADDRESS (relative to current P-code address in OPND)
                        	  2060: ;***********************************************
                        	  2061: GENRJMP  =  *
00:C7D9 48              	  2062:          PHA
00:C7DA A52B            	  2063:          LDA  OPND
00:C7DC 38              	  2064:          SEC
00:C7DD E523            	  2065:          SBC  PCODE
00:C7DF 852B            	  2066:          STA  OPND      ; subtract P-code address to find difference
00:C7E1 A52C            	  2067:          LDA  OPND+1
00:C7E3 E524            	  2068:          SBC  PCODE+1
00:C7E5 852C            	  2069:          STA  OPND+1
00:C7E7 68              	  2070:          PLA
00:C7E8 4CF3C7          	  2071:          JMP  GENJMP
                        	  2072: ;
                        	  2073: GENNJP   =  *
00:C7EB A93C            	  2074:          LDA  #PCODE_JMP       ; JMP
                        	  2075: 
                        	  2076: ; Generate jump, P-code is in "A" register (eg. PCODE_JMZ, PCODE_JM1)
                        	  2077: ;
                        	  2078: ;  Note: the destination here is 0000, however FIXAD will be called later to fix up
                        	  2079: ;        the jump, once we know what the destination will be (ie. further down the code)
                        	  2080: ;
00:C7ED A200            	  2081: GENNJM   LDX  #0
00:C7EF 862B            	  2082:          STX  OPND
00:C7F1 862C            	  2083:          STX  OPND+1
                        	  2084: ;
                        	  2085: ;***********************************************
                        	  2086: ; GENERATE P-CODES - JUMP ADDRESS (absolute address in OPND)
                        	  2087: ;   also used in other places, like increment stack address
                        	  2088: ;***********************************************
                        	  2089: GENJMP   =  *
00:C7F3 A442            	  2090:          LDY  SYNTAX
00:C7F5 D025            	  2091:          BNE  GEN3     ; no storing/displaying if syntax-only compile
00:C7F7 9123            	  2092:          STA  (PCODE),Y
00:C7F9 48              	  2093:          PHA
00:C7FA A52B            	  2094:          LDA  OPND
00:C7FC C8              	  2095:          INY
00:C7FD 9123            	  2096:          STA  (PCODE),Y
00:C7FF A52C            	  2097:          LDA  OPND+1
00:C801 C8              	  2098:          INY
00:C802 9123            	  2099:          STA  (PCODE),Y
00:C804 206292          	  2100:          JSR  DISPAD
00:C807 68              	  2101:          PLA
00:C808 A62E            	  2102:          LDX  DCODE
00:C80A F010            	  2103:          BEQ  GEN3
00:C80C 205C92          	  2104:          JSR  DISHX
00:C80F A52B            	  2105:          LDA  OPND
00:C811 205C92          	  2106:          JSR  DISHX
00:C814 A52C            	  2107:          LDA  OPND+1
00:C816 205C92          	  2108:          JSR  DISHX
00:C819 204792          	  2109:          JSR  CROUT
                        	  2110: GEN3     =  *
00:C81C A903            	  2111:          LDA  #3        ; 3-byte P-code
00:C81E 4CB8C7          	  2112:          JMP  GEN2_B
                        	  2113: 
                        	  2114: ;***********************************************
                        	  2115: ; FIXUP ADDRESSES
                        	  2116: ;***********************************************
                        	  2117: FIXAD    =  *
00:C821 A442            	  2118:          LDY  SYNTAX
00:C823 D039            	  2119:          BNE  FIXAD1
00:C825 A001            	  2120:          LDY  #1
00:C827 A523            	  2121:          LDA  PCODE
00:C829 38              	  2122:          SEC
00:C82A E537            	  2123:          SBC  WORK
00:C82C 9137            	  2124:          STA  (WORK),Y
00:C82E C8              	  2125:          INY
00:C82F A524            	  2126:          LDA  PCODE+1
00:C831 E538            	  2127:          SBC  WORK+1
00:C833 9137            	  2128:          STA  (WORK),Y
00:C835 A52E            	  2129:          LDA  DCODE
00:C837 F025            	  2130:          BEQ  FIXAD1
00:C839 A95F            	  2131:          LDA  #<FIXM1
00:C83B A2C8            	  2132:          LDX  #>FIXM1
00:C83D 202682          	  2133:          JSR  print
00:C840 A538            	  2134:          LDA  WORK+1
00:C842 20BC92          	  2135:          JSR  PRBYTE
00:C845 A537            	  2136:          LDA  WORK
00:C847 205C92          	  2137:          JSR  DISHX
00:C84A A968            	  2138:          LDA  #<FIXM2
00:C84C A2C8            	  2139:          LDX  #>FIXM2
00:C84E 202682          	  2140:          JSR  print
00:C851 A524            	  2141:          LDA  PCODE+1
00:C853 20BC92          	  2142:          JSR  PRBYTE
00:C856 A523            	  2143:          LDA  PCODE
00:C858 205C92          	  2144:          JSR  DISHX
00:C85B 4C4792          	  2145:          JMP  CROUT
00:C85E 60              	  2146: FIXAD1    rts
                        	  2147: 
00:C85F 4A756D7020617420	  2148: FIXM1    asciiz  'Jump at '
00:C867 00
00:C868 6368616E67656420	  2149: FIXM2    asciiz  'changed to '   ; changed to
00:C870 746F20
00:C873 00
                        	  2150: 
                        	  2151: 

Source: "gpascal.asm"
                        	   186:   .include "hardware.inc"

Source: "hardware.inc"
                        	     1: 
                        	     2: ; VIA - Versatile Interface Adapter (W65C22) hardware
                        	     3: 
                        	     4: VIA_PORTB   = $7FF0   ; input/output register "B"
                        	     5: VIA_PORTA   = $7FF1   ; input/output register "A"
                        	     6: VIA_DDRB    = $7FF2   ; data direction register "B"
                        	     7: VIA_DDRA    = $7FF3   ; data direction register "A"
                        	     8: VIA_T1C_L   = $7FF4   ; T1 write: latch (L), read: counter (L)
                        	     9: VIA_T1C_H   = $7FF5   ; T1 high_order counter
                        	    10: VIA_T1L_L   = $7FF6   ; T1 low_order latches
                        	    11: VIA_T1L_H   = $7FF7   ; T1 high_order latches
                        	    12: VIA_T2C_L   = $7FF8   ; T2 write: latch (L), read: counter (L)
                        	    13: VIA_T2C_H   = $7FF9   ; T2 high_order counter
                        	    14: VIA_SR      = $7FFA   ; shift register
                        	    15: VIA_ACR     = $7FFB   ; auxilliary control register
                        	    16: VIA_PCR     = $7FFC   ; peripheral control register
                        	    17: VIA_IFR     = $7FFD   ; interrupt flag register
                        	    18: VIA_IER     = $7FFE   ; interrupt enable register
                        	    19: 
                        	    20: VIA_FLAG_ENABLE   = %10000000 ; high-order bit set enables the flag
                        	    21: VIA_FLAG_DISABLE  = %00000000 ; high-order bit clear disables the flag
                        	    22: VIA_FLAG_TIMER1   = %01000000
                        	    23: VIA_FLAG_TIMER2   = %00100000
                        	    24: VIA_FLAG_CB1      = %00010000
                        	    25: VIA_FLAG_CB2      = %00001000
                        	    26: VIA_FLAG_SHIFT    = %00000100
                        	    27: VIA_FLAG_CA1      = %00000010
                        	    28: VIA_FLAG_CA2      = %00000001
                        	    29: 
                        	    30: ;
                        	    31: ; VIA Port A pin masks
                        	    32: ;
                        	    33: 
                        	    34: SERIAL_IN_MASK     = %00000001   ; serial in on PA0 (also connect to CB2) (to FTDI TxD pin - pin 4)
                        	    35: SERIAL_OUT_MASK    = %00000010   ; serial out on PA1 (to FTDI RxD pin - pin 5)
                        	    36: SERIAL_DEBUG1_MASK = %00000100   ; serial debugging on PA2
                        	    37: SERIAL_DEBUG2_MASK = %00001000   ; serial debugging on PA3
                        	    38: SERIAL_SPARE2_MASK = %00010000   ; spare VIA pins (PA4)
                        	    39: 
                        	    40: 
                        	    41: ;***********************************************
                        	    42: ;  Functions added for Ben's Board
                        	    43: ;***********************************************
                        	    44: 
                        	    45: ;
                        	    46: ;  Converts a pin number in the range 0 to 15 to a mask
                        	    47: ;  eg. 00000001, 00000010, 00000100 and so on
                        	    48: ;
                        	    49: ;  Returns mask in Y
                        	    50: ;
                        	    51: ;  Returns with Z set if the range was 0 to 7 an
                        	    52: ;  and Z clear if the range was 8 to 15
                        	    53: ;
                        	    54: pin_number_to_mask = *
00:C874 48              	    55:   pha         ; save for a moment
00:C875 2907            	    56:   and #$7     ; make in range 0 to 7
00:C877 A8              	    57:   tay
00:C878 A901            	    58:   lda #1      ; initial mask
                        	    59: pin_number_to_mask_loop:
00:C87A C000            	    60:   cpy #0
00:C87C F004            	    61:   beq pin_number_to_mask_done
00:C87E 0A              	    62:   asl A
00:C87F 88              	    63:   dey
00:C880 80F8            	    64:   bra pin_number_to_mask_loop
                        	    65: pin_number_to_mask_done:
00:C882 A8              	    66:   tay         ; save mask in Y
00:C883 68              	    67:   pla
00:C884 2908            	    68:   and #$8     ; DDRA or DDRB ?
00:C886 60              	    69:   rts
                        	    70: 
                        	    71: ;
                        	    72: ;  pin in A, mode in X
                        	    73: ;
                        	    74: pinmode:
00:C887 868C            	    75:   stx hardware_work ; input or output
00:C889 2074C8          	    76:   jsr pin_number_to_mask  ; convert to appropriate mask bit
00:C88C D00A            	    77:   bne pinmode_B        ; Z is clear if it is DDRB
00:C88E A9F3            	    78:   lda #<VIA_DDRA
00:C890 8500            	    79:   sta REG
00:C892 A97F            	    80:   lda #>VIA_DDRA
00:C894 8501            	    81:   sta REG+1
00:C896 8008            	    82:   bra pinmode_C
                        	    83: pinmode_B:
00:C898 A9F2            	    84:   lda #<VIA_DDRB
00:C89A 8500            	    85:   sta REG
00:C89C A97F            	    86:   lda #>VIA_DDRB
00:C89E 8501            	    87:   sta REG+1
                        	    88: ;
                        	    89: ;  The DDR register is now in REG
                        	    90: ;
                        	    91: pinmode_C:
00:C8A0 A58C            	    92:   lda hardware_work     ; input or output?
00:C8A2 D00A            	    93:   bne pinmode_OUTPUT
                        	    94: ;
                        	    95: ;  here to set input mode
                        	    96: ;
00:C8A4 98              	    97:   tya       ; get the mask back
00:C8A5 A000            	    98:   ldy #0
00:C8A7 49FF            	    99:   eor #$FF  ; negate the mask
00:C8A9 3100            	   100:   and (REG),y
00:C8AB 9100            	   101:   sta (REG),y
00:C8AD 60              	   102:   rts       ; done
                        	   103: ;
                        	   104: ;  here to set output mode
                        	   105: ;
                        	   106: pinmode_OUTPUT:
00:C8AE 98              	   107:   tya          ; get the mask back
00:C8AF A000            	   108:   ldy #0
00:C8B1 1100            	   109:   ora (REG),y  ; or in with the existing DDR register
00:C8B3 9100            	   110:   sta (REG),y  ; and write it back
00:C8B5 60              	   111:   rts          ; done
                        	   112: 
                        	   113: 
                        	   114: ;
                        	   115: ;  DIGITALWRITE (pin, value) pin:0 to 15; value: 0 or 1 : pin in A, mode in X
                        	   116: ;
                        	   117: digitalwrite = *
00:C8B6 868C            	   118:   stx hardware_work ; save what to write (0 or 1)
00:C8B8 2074C8          	   119:   jsr pin_number_to_mask  ; convert to appropriate mask bit
00:C8BB D00A            	   120:   bne digitalwrite_B        ; Z is clear if it is PORTB
00:C8BD A9F1            	   121:   lda #<VIA_PORTA
00:C8BF 8500            	   122:   sta REG
00:C8C1 A97F            	   123:   lda #>VIA_PORTA
00:C8C3 8501            	   124:   sta REG+1
00:C8C5 8008            	   125:   bra digitalwrite_C
                        	   126: digitalwrite_B:
00:C8C7 A9F0            	   127:   lda #<VIA_PORTB
00:C8C9 8500            	   128:   sta REG
00:C8CB A97F            	   129:   lda #>VIA_PORTB
00:C8CD 8501            	   130:   sta REG+1
                        	   131: ;
                        	   132: ;  The PORT register is now in REG
                        	   133: ;
                        	   134: digitalwrite_C:
00:C8CF A58C            	   135:   lda hardware_work
00:C8D1 D00A            	   136:   bne digitalwrite_ONE  ; any non-zero value is writing a 1
                        	   137: ;
                        	   138: ;  here to write a zero
                        	   139: ;
00:C8D3 98              	   140:   tya
00:C8D4 A000            	   141:   ldy #0
00:C8D6 49FF            	   142:   eor #$FF  ; negate the mask
00:C8D8 3100            	   143:   and (REG),y
00:C8DA 9100            	   144:   sta (REG),y
00:C8DC 60              	   145:   rts       ; done
                        	   146: 
                        	   147: ;
                        	   148: ;  here to write a one
                        	   149: ;
                        	   150: digitalwrite_ONE:
00:C8DD 98              	   151:   tya          ; get the mask back
00:C8DE A000            	   152:   ldy #0
00:C8E0 1100            	   153:   ora (REG),y  ; or in with the existing DDR register
00:C8E2 9100            	   154:   sta (REG),y  ; and write it back
00:C8E4 60              	   155:   rts          ; done
                        	   156: 
                        	   157: 
                        	   158: ;
                        	   159: ;  DIGITALREAD (pin) pin:0 to 15; Pin to read is in in A. returns or non-zero in A.
                        	   160: ;
                        	   161: digitalread = *
00:C8E5 2074C8          	   162:   jsr pin_number_to_mask  ; convert to appropriate mask bit
00:C8E8 D00A            	   163:   bne digitalread_B        ; Z is clear if it is PORTB
00:C8EA A9F1            	   164:   lda #<VIA_PORTA
00:C8EC 8500            	   165:   sta REG
00:C8EE A97F            	   166:   lda #>VIA_PORTA
00:C8F0 8501            	   167:   sta REG+1
00:C8F2 8008            	   168:   bra digitalread_C
                        	   169: digitalread_B:
00:C8F4 A9F0            	   170:   lda #<VIA_PORTB
00:C8F6 8500            	   171:   sta REG
00:C8F8 A97F            	   172:   lda #>VIA_PORTB
00:C8FA 8501            	   173:   sta REG+1
                        	   174: ;
                        	   175: ;  The PORT register is now in REG
                        	   176: ;
                        	   177: digitalread_C:
00:C8FC 98              	   178:   tya         ; get the mask back
00:C8FD A000            	   179:   ldy #0
00:C8FF 3100            	   180:   and (REG),y ; get that bit
00:C901 60              	   181:   rts
                        	   182: 
                        	   183: 
                        	   184: 
                        	   185: ;
                        	   186: ;  Functions to change where writing is done
                        	   187: ;
                        	   188: write_to_serial:
00:C902 48              	   189:   pha
00:C903 A962            	   190:   lda  #<write_char
00:C905 8517            	   191:   sta  write_function
00:C907 A9C9            	   192:   lda  #>write_char
00:C909 8518            	   193:   sta  write_function+1
00:C90B 68              	   194:   pla
00:C90C 60              	   195:   rts
                        	   196: 
                        	   197: write_to_lcd:
00:C90D 48              	   198:   pha
00:C90E A9BE            	   199:   lda  #<lcd_print_char
00:C910 8517            	   200:   sta  write_function
00:C912 A9B8            	   201:   lda  #>lcd_print_char
00:C914 8518            	   202:   sta  write_function+1
00:C916 68              	   203:   pla
00:C917 60              	   204:   rts
                        	   205: 
                        	   206: 
                        	   207: 
                        	   208: ; ---------------------------
                        	   209: ; Simulate kernel interfaces
                        	   210: ; ---------------------------
                        	   211: ; We interface by reading/writing to special
                        	   212: ; RAM that is implemented in the emulator
                        	   213: 
                        	   214: 
                        	   215: 
                        	   216:     .if EMULATOR
                        	   217: 
                        	   218: ;
                        	   219: ;  Emulator testing
                        	   220: ;
                        	   221: CHRIN    =  *
                        	   222:          lda  $7F22
                        	   223:          rts
                        	   224: 
                        	   225: write_char   =  *
                        	   226:          sta  $7F23
                        	   227:          rts
                        	   228: 
                        	   229: 
                        	   230: GETIN    =  *
                        	   231:          lda  $7F29
                        	   232:          rts
                        	   233: 
                        	   234: hardware_init rts
                        	   235: 
                        	   236: ;
                        	   237: ;  put debug number in A
                        	   238: ;
                        	   239: EMULATOR_DEBUG = *
                        	   240:          sta $7F46
                        	   241:          rts
                        	   242: 
                        	   243: START_TRACE = *
                        	   244:          sta $7F47
                        	   245:          rts
                        	   246: 
                        	   247: STOP_TRACE = *
                        	   248:          sta $7F48
                        	   249:          rts
                        	   250: ;
                        	   251: ;  not applicable in emulator
                        	   252: ;
                        	   253: lcd_print_message   rts
                        	   254: lcd_clear_display   rts
                        	   255: lcd_print_char      rts
                        	   256: lcd_second_line     rts
                        	   257: lcd_instruction     rts
                        	   258: lcd_get_address     rts
                        	   259: lcd_wait            rts
                        	   260: lcd_home            rts
                        	   261: lcd_initialise      rts
                        	   262: serial_available    rts
                        	   263: serial_print_message rts
                        	   264: 
                        	   265:   .else
                        	   266: 
                        	   267: ;
                        	   268: ;  Ben's Board
                        	   269: ;
                        	   270: 
                        	   271: ;
                        	   272: ;  typing_latency could be used as a seed for the random number generator
                        	   273: ;    - the exact time between keypresses would be somewhat unpredictable
                        	   274: ;
                        	   275: CHRIN  = *
                        	   276: GETIN    =  *
00:C918 E60D            	   277:          inc typing_latency
00:C91A D006            	   278:          bne GETIN1
00:C91C E60E            	   279:          inc typing_latency+1
00:C91E D002            	   280:          bne GETIN1
00:C920 E60F            	   281:          inc typing_latency+2
                        	   282: GETIN1:
00:C922 A58B            	   283:          lda serial_in_byte_received
00:C924 F0F2            	   284:          beq GETIN    ; nothing yet
00:C926 648B            	   285:          stz serial_in_byte_received
00:C928 60              	   286:          rts
                        	   287: 
                        	   288: serial_available = *
00:C929 A58B            	   289:          lda serial_in_byte_received
00:C92B 60              	   290:          rts
                        	   291: 
                        	   292: 
00:C92C 60              	   293: EMULATOR_DEBUG rts
00:C92D 60              	   294: START_TRACE rts
00:C92E 60              	   295: STOP_TRACE rts
                        	   296: 
                        	   297: 
                        	   298: ;
                        	   299: ;  set up serial hardware
                        	   300: ;
                        	   301: 
                        	   302: hardware_init:
                        	   303: 
00:C92F A902            	   304:   lda #SERIAL_OUT_MASK  ; set 1 bit (idle serial comms), and others to zero
00:C931 8DF17F          	   305:   sta VIA_PORTA
                        	   306: 
                        	   307:   ; set output enable bits
00:C934 A91E            	   308:   lda #(SERIAL_OUT_MASK | SERIAL_DEBUG1_MASK | SERIAL_DEBUG2_MASK | SERIAL_SPARE2_MASK)
00:C936 8DF37F          	   309:   sta VIA_DDRA
                        	   310: 
00:C939 A940            	   311:   lda #%01000000      ; continuous interrupts on T1
00:C93B 8DFB7F          	   312:   sta VIA_ACR
                        	   313: 
00:C93E A900            	   314:   lda #0              ; Input-negative active edge
00:C940 8DFC7F          	   315:   sta VIA_PCR
                        	   316: 
00:C943 A9D0            	   317:   lda #<BIT_INTERVAL  ; ie. baud rate interval
00:C945 8DF47F          	   318:   sta VIA_T1C_L       ; for sending bits
00:C948 A900            	   319:   lda #>BIT_INTERVAL
00:C94A 8DF57F          	   320:   sta VIA_T1C_H       ; this starts the counter
                        	   321: 
                        	   322:   ; set up for serial input
                        	   323: 
00:C94D A988            	   324:   lda #VIA_FLAG_ENABLE | VIA_FLAG_CB2  ; interrupt on CB2 falling edge
00:C94F 8DFE7F          	   325:   sta VIA_IER
                        	   326: 
00:C952 A9FF            	   327:   lda #$FF         ; clear all interrupt flags
00:C954 8DFD7F          	   328:   sta VIA_IFR
                        	   329: 
                        	   330:   .if LCD_SUPPORT
00:C957 20AFB7          	   331:   jsr lcd_initialise
                        	   332:   .endif
                        	   333: 
00:C95A 648A            	   334:   stz serial_in_byte    ; non-zero means an interrupt put in incoming byte there
00:C95C 6489            	   335:   stz serial_out_bit
00:C95E 6468            	   336:   stz spi_mode          ; default to SPI mode zero
                        	   337: 
00:C960 58              	   338:   cli         ; enable interrupts
00:C961 60              	   339:   rts
                        	   340: 
                        	   341: 
                        	   342: ;
                        	   343: ;  Write a character (in A) to the serial port.
                        	   344: ;   Interrupts MUST be enabled for this to work!
                        	   345: ;
                        	   346: write_char:
00:C962 48              	   347:   pha                   ; save original character
00:C963 0A              	   348:   asl a                 ; shift in a zero which will be the start bit
00:C964 8587            	   349:   sta serial_out_byte
00:C966 A9FF            	   350:   lda #0xff             ; will become the stop bit(s)
00:C968 2A              	   351:   rol a                 ; rotate in the high-order bit from the data byte
00:C969 8588            	   352:   sta serial_out_byte+1
00:C96B A90B            	   353:   lda #11               ; 8 data bits, one start bit, two stop bits
00:C96D 8589            	   354:   sta serial_out_bit    ; number of bits to shift out
00:C96F A9D0            	   355:   lda #<BIT_INTERVAL    ; ie. baud rate interval
00:C971 8DF47F          	   356:   sta VIA_T1C_L         ; for sending bits
00:C974 A900            	   357:   lda #>BIT_INTERVAL
00:C976 8DF57F          	   358:   sta VIA_T1C_H         ; this starts the counter
00:C979 A9C0            	   359:   lda #VIA_FLAG_ENABLE | VIA_FLAG_TIMER1  ; interrupt on T1 timeout
00:C97B 8DFE7F          	   360:   sta VIA_IER
                        	   361: 
                        	   362: ;
                        	   363: ; wait for this byte to finish - otherwise it might interfere with many things
                        	   364: ;
                        	   365: 
                        	   366: write_char_loop:
00:C97E ADFE7F          	   367:   lda VIA_IER
00:C981 2940            	   368:   and #VIA_FLAG_TIMER1  ; are T1 interrupts enabled?
00:C983 D0F9            	   369:   bne write_char_loop   ; loop until this character sent
00:C985 68              	   370:   pla                   ; get character back
00:C986 60              	   371:   rts
                        	   372: 
                        	   373: 
                        	   374: ;
                        	   375: ;  sends null-terminated message to serial port, message in A (lo) and X (hi)
                        	   376: ;  returns the length of the message in Y
                        	   377: ;
                        	   378: serial_print_message:
00:C987 8503            	   379:   sta REG2
00:C989 8604            	   380:   stx REG2+1
00:C98B A000            	   381:   ldy #0
                        	   382: serial_print:
00:C98D B103            	   383:   lda (REG2),y
00:C98F F006            	   384:   beq serial_print_done
00:C991 2062C9          	   385:   jsr write_char
00:C994 C8              	   386:   iny
00:C995 80F6            	   387:   bra serial_print
                        	   388: 
00:C997 60              	   389: serial_print_done rts
                        	   390: 
                        	   391:   .endif  ; not EMULATOR
                        	   392: 
                        	   393: 

Source: "gpascal.asm"
                        	   187:   .include "gtoken.inc"

Source: "gtoken.inc"
                        	     1: ;
                        	     2: ;  get_token
                        	     3: ;
                        	     4: ;  Gets a lexical token from the specified address.
                        	     5: ;
                        	     6: ;  - Start parsing at token_start (this should be the first character of the token)
                        	     7: ;  - The first found character (after spaces, comments, newlines) is in token_address
                        	     8: ;      - this is mainly used for knowing what the identifier is so we can put it in the symbol table
                        	     9: ;      - strings are put into INBUF after processing, so token_address is not as useful in that case
                        	    10: ;  - The length is in token_length (in the case of strings, this is the processed length)
                        	    11: ;  - The type is in token_type - zero would mean end of file
                        	    12: ;
                        	    13: ;  The types are one of the token codes below
                        	    14: ;
                        	    15: ;  Tokens which start with a letter and are possibly followed by letters, numbers, and
                        	    16: ;    the underscore character become TOKEN_IDENTIFIER.
                        	    17: ;
                        	    18: ;  Tokens starting with a number (TOKEN_NUMBER) are parsed for the value which is placed into token_value.
                        	    19: ;
                        	    20: ;  Tokens starting with a single or double quote are parsed for the internal string (TOKEN_STRING)
                        	    21: ;  which is placed in INBUF. The internal string has internal double-quotes turned
                        	    22: ;  into single quotes, and sequences like \n or \x42 turned into their appropriate characters.
                        	    23: ;
                        	    24: ;  String tokens which are up to 3 bytes long also have the 3 bytes placed into token_value.
                        	    25: ;
                        	    26: ;  Hex and binary tokens are parsed for their value which is placed into token_value.
                        	    27: ;
                        	    28: ;  Various 2-character tokens are given their own code (eg. <> == != := << >> and so on).
                        	    29: ;
                        	    30: ;  Spaces and comments are skipped, however Pascal directives inside comments are processed
                        	    31: ;
                        	    32: ;  Newlines are skipped in Pascal but returned as a token in assembler (ASSEMBLING == true)
                        	    33: ;  If newlines are skipped then token_line is called to handle listing the line (the line
                        	    34: ;   we are about to process, not the previous line)
                        	    35: ;
                        	    36: ; Rewritten in February 2022 to be easier to read and have well-defined work variables (zero-page variables)
                        	    37: 
                        	    38: ; multi-byte token codes (single byte tokens are themselves)
                        	    39: 
                        	    40: TOKEN_ASSIGN     = 'A'   ; :=
                        	    41: TOKEN_IDENTIFIER = 'I'   ; alpha-numeric identifiers
                        	    42: TOKEN_NUMBER     = 'N'   ; numbers
                        	    43: TOKEN_STRING     = '"'   ; string literal
                        	    44: TOKEN_LEQ        = $80   ; <=
                        	    45: TOKEN_GEQ        = $81   ; >=
                        	    46: TOKEN_NEQ        = 'U'   ; <>
                        	    47: 
                        	    48: ;
                        	    49: ;  the ones below are used in the assembler
                        	    50: ;
                        	    51: TOKEN_EQUALITY    = 'E'     ; ==
                        	    52: TOKEN_SHIFT_LEFT  = 'L'     ; <<
                        	    53: TOKEN_SHIFT_RIGHT = 'R'     ; >>
                        	    54: TOKEN_UNARY_MINUS = 'M'     ; -
                        	    55: TOKEN_LOW_BYTE    = 'V'     ; eg. lda #<foo
                        	    56: TOKEN_HIGH_BYTE   = 'W'     ; eg. lda #>foo
                        	    57: TOKEN_LOGICAL_AND = 'X'     ; &&
                        	    58: TOKEN_LOGICAL_OR  = 'Y'     ; ||
                        	    59: TOKEN_INEQUALITY  = 'Z'     ; !=
                        	    60: 
                        	    61: 
                        	    62: get_token:
00:C998 A593            	    63:   lda token_type      ; remember previous token for checking if + or - stand on their own
00:C99A 8598            	    64:   sta token_work
                        	    65: get_token_loop:
00:C99C A000            	    66:   ldy #0              ; offset into the token address
00:C99E 8497            	    67:   sty token_sign      ; Y is zero at this point
00:C9A0 8494            	    68:   sty token_value     ; no value yet
00:C9A2 8495            	    69:   sty token_value+1
00:C9A4 8496            	    70:   sty token_value+2
                        	    71: 
                        	    72: gc_skip_spaces:
00:C9A6 B18E            	    73:   lda (token_start),y
00:C9A8 F034            	    74:   beq gc_done         ; 0x00 means end, so return it WITHOUT incrementing the pointer
00:C9AA C90A            	    75:   cmp #NL             ; newline need special handling
00:C9AC F00D            	    76:   beq gc_newline
00:C9AE 204A81          	    77:   jsr isspace
00:C9B1 9043            	    78:   bcc gc_not_space
00:C9B3 E68E            	    79:   inc token_start     ; increment pointer because spaces can be any length
00:C9B5 D0EF            	    80:   bne gc_skip_spaces
00:C9B7 E68F            	    81:   inc token_start+1
00:C9B9 80EB            	    82:   bra gc_skip_spaces
                        	    83: 
                        	    84: ;
                        	    85: ;  got a newline - if assembling, return that so we know where lines end
                        	    86: ;  otherwise just call token_line to display the next line and press on looking
                        	    87: ;  for tokens.
                        	    88: ;
                        	    89: gc_newline:
00:C9BB A902            	    90:   lda #FLAG_ASSEMBLING
00:C9BD 25BE            	    91:   and system_flags
00:C9BF D014            	    92:   bne gc_newline_assembling    ; return the newline as a token
00:C9C1 C8              	    93:   iny              ; length in Y (ie. one)
00:C9C2 E68E            	    94:   inc token_start
00:C9C4 D002            	    95:   bne gc_newline1
00:C9C6 E68F            	    96:   inc token_start+1
                        	    97: gc_newline1:
00:C9C8 A58E            	    98:   lda token_start
00:C9CA 859C            	    99:   sta token_line_start
00:C9CC A58F            	   100:   lda token_start+1
00:C9CE 859D            	   101:   sta token_line_start+1
00:C9D0 2038CA          	   102:   jsr token_line        ; list the next line
00:C9D3 80C7            	   103:   bra get_token_loop    ; look for another token
                        	   104: 
                        	   105: gc_newline_assembling:
00:C9D5 A90A            	   106:   lda #NL       ; get the newline back
00:C9D7 4CDCC9          	   107:   jmp gc_single_byte_token
                        	   108: 
                        	   109: ;
                        	   110: ;  wrap up getting a token:
                        	   111: ;
                        	   112: ;   - save the type
                        	   113: ;   - save the current address as token_address
                        	   114: ;   - add the length to token_start ready for next time
                        	   115: ;
                        	   116: gc_single_byte_already_known:
00:C9DA A593            	   117:   lda token_type        ; get back saved token type
                        	   118: gc_single_byte_token:
00:C9DC A001            	   119:   ldy #1
                        	   120: gc_done:
00:C9DE 8492            	   121:   sty token_length      ; Y has our length
00:C9E0 8593            	   122:   sta token_type        ; A has our type
00:C9E2 18              	   123:   clc
00:C9E3 A58E            	   124:   lda token_start
00:C9E5 8590            	   125:   sta token_address     ; save the starting address of the token
00:C9E7 6592            	   126:   adc token_length      ; now add its length
00:C9E9 858E            	   127:   sta token_start       ; that gives the ending address
                        	   128: 
00:C9EB A58F            	   129:   lda token_start+1     ; repeat for high-order byte
00:C9ED 8591            	   130:   sta token_address+1
00:C9EF 6900            	   131:   adc #0
00:C9F1 858F            	   132:   sta token_start+1
                        	   133: 
00:C9F3 A593            	   134:   lda token_type        ; get token type back into A
00:C9F5 60              	   135:   rts
                        	   136: 
                        	   137: ;
                        	   138: ;  not a space (or newline) so this must be the actual start of it
                        	   139: ;
                        	   140: 
                        	   141: gc_not_space:
                        	   142: 
                        	   143: ;
                        	   144: ;  first look for classes of characters (ie. alpha, numeric)
                        	   145: ;
00:C9F6 202681          	   146:   jsr isalpha
00:C9F9 9026            	   147:   bcc gc_not_alpha
                        	   148: 
                        	   149: ;
                        	   150: ;  find end of identifier
                        	   151: ;
                        	   152: gc_alpha_loop:
00:C9FB C8              	   153:   iny
00:C9FC D005            	   154:   bne gc_alpha_ok   ; if it becomes zero now, we have 256+ long identifier
00:C9FE A20C            	   155:   ldx #12       ; ERROR: Illegal Identifier (too long)
00:CA00 4C8397          	   156:   jmp ERROR
                        	   157: 
                        	   158: gc_alpha_ok:
00:CA03 A940            	   159:   lda #FLAG_ONLY_ALPHA
00:CA05 24BE            	   160:   bit system_flags
00:CA07 D00F            	   161:   bne gc_alpha_alpha_only
00:CA09 B18E            	   162:   lda (token_start),y
00:CA0B 206281          	   163:   jsr isalnum
00:CA0E B0EB            	   164:   bcs gc_alpha_loop
00:CA10 C95F            	   165:   cmp #'_'
00:CA12 F0E7            	   166:   beq gc_alpha_loop
                        	   167: 
                        	   168: ;
                        	   169: ; end of identifier
                        	   170: ;
                        	   171: gc_alpha_done:
00:CA14 A949            	   172:   lda #TOKEN_IDENTIFIER
00:CA16 80C6            	   173:   bra gc_done
                        	   174: 
                        	   175: 
                        	   176: gc_alpha_alpha_only:
00:CA18 B18E            	   177:   lda (token_start),y
00:CA1A 202681          	   178:   jsr isalpha
00:CA1D B0DC            	   179:   bcs gc_alpha_loop
00:CA1F 80F3            	   180:   bra gc_alpha_done
                        	   181: 
                        	   182: ;
                        	   183: ; now see if it is a digit
                        	   184: ;
                        	   185: gc_not_alpha:
00:CA21 203281          	   186:   jsr isdigit
00:CA24 9007            	   187:   bcc gc_not_digit
                        	   188: 
00:CA26 2087CA          	   189:   jsr atoi
00:CA29 A94E            	   190:   lda  #TOKEN_NUMBER
00:CA2B 80B1            	   191:   bra  gc_done
                        	   192: 
                        	   193: ;
                        	   194: ;  not alpha and not digit - so let's consider:
                        	   195: ;   * prefixes: $ for hex and % for binary
                        	   196: ;   *  + or - in front of numbers or on their own
                        	   197: ;   * single character tokens, eg. =, (, ) and so on
                        	   198: ;   * double-character tokens, eg. ==, >= << and so on
                        	   199: ;   * strings, eg. "foo"
                        	   200: ;
                        	   201: ;  we'll do a jump on the first character
                        	   202: ;
                        	   203: gc_not_digit:
00:CA2D 8593            	   204:   sta token_type            ; remember it in case of possible two-byte sequences
00:CA2F A215            	   205:   ldx #<gtoken_table
00:CA31 A0CB            	   206:   ldy #>gtoken_table
00:CA33 20B18F          	   207:   jsr TKNJMP
00:CA36 80A2            	   208:   bra gc_single_byte_already_known  ; it is what it is
                        	   209: 
                        	   210: ;
                        	   211: ;  here when get_token discovers a newline - print the next line if wanted
                        	   212: ;
                        	   213: 
                        	   214: token_line:
                        	   215: ;
                        	   216: ;  count lines
                        	   217: ;
00:CA38 E6A2            	   218:   inc current_line
00:CA3A D002            	   219:   bne token_line1
00:CA3C E6A3            	   220:   inc current_line+1
                        	   221: token_line1:
                        	   222: ;
                        	   223: ;  compiling or assembling?
                        	   224: ;
00:CA3E A901            	   225:   lda #FLAG_COMPILING
00:CA40 0902            	   226:   ora #FLAG_ASSEMBLING
00:CA42 25BE            	   227:   and system_flags
00:CA44 F040            	   228:   beq token_line_done ; no - no listing
                        	   229: ;
                        	   230: ;  listing wanted?
                        	   231: ;
00:CA46 A904            	   232:   lda #FLAG_LIST_SOURCE
00:CA48 25BE            	   233:   and system_flags
00:CA4A D00D            	   234:   bne token_line_listing ; yes
                        	   235: 
                        	   236: ;
                        	   237: ;  no listing - show an asterisk every 15 lines
                        	   238: ;
00:CA4C A5A2            	   239:   lda current_line
00:CA4E 290F            	   240:   and #$0F
00:CA50 D034            	   241:   bne token_line_done
00:CA52 A92A            	   242:   lda #'*'
00:CA54 20CE93          	   243:   jsr COUT
00:CA57 802D            	   244:   bra token_line_done
                        	   245: 
                        	   246: token_line_listing:
00:CA59 A52E            	   247:   lda DCODE
00:CA5B 48              	   248:   pha
00:CA5C A901            	   249:   lda #1
00:CA5E 852E            	   250:   sta DCODE
00:CA60 206292          	   251:   jsr DISPAD
00:CA63 68              	   252:   pla
00:CA64 852E            	   253:   sta DCODE
00:CA66 20158C          	   254:   jsr show_current_line_number
                        	   255: 
00:CA69 A59C            	   256:   lda token_line_start
00:CA6B 8598            	   257:   sta token_work
00:CA6D A59D            	   258:   lda token_line_start+1
00:CA6F 8599            	   259:   sta token_work+1
                        	   260: 
                        	   261: token_line_loop:
00:CA71 A000            	   262:   ldy #0
00:CA73 B198            	   263:   lda (token_work),Y
00:CA75 F00F            	   264:   beq token_line_done
00:CA77 48              	   265:   pha
00:CA78 20CE93          	   266:   jsr COUT
00:CA7B E698            	   267:   inc token_work
00:CA7D D002            	   268:   bne token_line_loop1
00:CA7F E699            	   269:   inc token_work+1
                        	   270: token_line_loop1:
00:CA81 68              	   271:   pla
00:CA82 C90A            	   272:   cmp #NL
00:CA84 D0EB            	   273:   bne token_line_loop
                        	   274: 
                        	   275: token_line_done:
00:CA86 60              	   276:   rts
                        	   277: 
                        	   278: 
                        	   279: ;
                        	   280: ;  atoi
                        	   281: ;
                        	   282: ; get a decimal number - returns carry flag set if bad number and running
                        	   283: ;   (if compiling and a bad number gives an error)
                        	   284: ;
                        	   285: ;  token_start : the start address of the number
                        	   286: ;  Y : offset into token_start
                        	   287: ;  token_sign : non-zero if negative
                        	   288: ;
                        	   289: ;  returns: token_value  and carry clear (if no error)
                        	   290: ;           carry set if error (for use at runtime)
                        	   291: ;           Y at offset of first non-numeric character
                        	   292: 
                        	   293: atoi:
00:CA87 38              	   294:   sec
00:CA88 E930            	   295:   sbc  #'0'   ;  ; subtract out ASCII stuff, save first digit
00:CA8A 8594            	   296:   sta  token_value
00:CA8C 6495            	   297:   stz  token_value+1
00:CA8E 6496            	   298:   stz  token_value+2
                        	   299: atoi_loop    =  *
00:CA90 C8              	   300:   iny
00:CA91 B18E            	   301:   lda  (token_start),y
00:CA93 203281          	   302:   jsr  isdigit
00:CA96 B009            	   303:   bcs  atoi_more      ; more digits
                        	   304: ;
                        	   305: ; end of number - make negative if we got a sign earlier
                        	   306: ;
00:CA98 A597            	   307:   lda  token_sign
00:CA9A F003            	   308:   beq  atoi_positive    ; not signed
                        	   309: ;
                        	   310: ;  make negative
                        	   311: ;
00:CA9C 2001CB          	   312:   jsr negate_token_value
                        	   313: ;
                        	   314: ;  done! clear carry and return
                        	   315: ;
                        	   316: atoi_positive:
00:CA9F 18              	   317:   clc                   ; indicate no error for numeric conversion
00:CAA0 60              	   318:   rts
                        	   319: ;
                        	   320: ;  Multiply previous value by 10, add in new digit
                        	   321: ;
                        	   322: atoi_more    =  *
00:CAA1 38              	   323:   sec
00:CAA2 E930            	   324:   sbc  #'0'
00:CAA4 859B            	   325:   sta  token_digit
00:CAA6 0694            	   326:   asl  token_value         ; multiply token_value by 2
00:CAA8 2695            	   327:   rol  token_value+1
00:CAAA 2696            	   328:   rol  token_value+2
00:CAAC 3048            	   329:   bmi  atoi_error
                        	   330: 
00:CAAE A594            	   331:   lda  token_value         ; save token_value*2 in token_work
00:CAB0 8598            	   332:   sta  token_work
00:CAB2 A595            	   333:   lda  token_value+1
00:CAB4 8599            	   334:   sta  token_work+1
00:CAB6 A596            	   335:   lda  token_value+2
00:CAB8 859A            	   336:   sta  token_work+2
                        	   337: 
00:CABA 0694            	   338:   asl  token_value         ; now token_value is multiplied by 4
00:CABC 2695            	   339:   rol  token_value+1
00:CABE 2696            	   340:   rol  token_value+2
00:CAC0 3034            	   341:   bmi  atoi_error
                        	   342: 
00:CAC2 0694            	   343:   asl  token_value         ; now token_value is multiplied by 8
00:CAC4 2695            	   344:   rol  token_value+1
00:CAC6 2696            	   345:   rol  token_value+2
00:CAC8 302C            	   346:   bmi  atoi_error
                        	   347: 
00:CACA A598            	   348:   lda  token_work          ; now add back in token_value*2 (giving token_value*10)
00:CACC 6594            	   349:   adc  token_value
00:CACE 8594            	   350:   sta  token_value
00:CAD0 A599            	   351:   lda  token_work+1
00:CAD2 6595            	   352:   adc  token_value+1
00:CAD4 8595            	   353:   sta  token_value+1
00:CAD6 A59A            	   354:   lda  token_work+2
00:CAD8 6596            	   355:   adc  token_value+2
00:CADA 8596            	   356:   sta  token_value+2
00:CADC 3018            	   357:   bmi  atoi_error      ; if negative, the number was too big
00:CADE 18              	   358:   clc
00:CADF A594            	   359:   lda  token_value     ; now take the value and add in our new digit
00:CAE1 659B            	   360:   adc  token_digit
00:CAE3 8594            	   361:   sta  token_value
00:CAE5 A900            	   362:   lda #0
00:CAE7 6595            	   363:   adc  token_value+1   ; increment next byte if necessary
00:CAE9 8595            	   364:   sta  token_value+1
00:CAEB A900            	   365:   lda #0
00:CAED 6596            	   366:   adc  token_value+2
00:CAEF 8596            	   367:   sta  token_value+2
00:CAF1 3003            	   368:   bmi  atoi_error
00:CAF3 4C90CA          	   369:   jmp  atoi_loop     ; onwards for next digit
                        	   370: 
                        	   371: atoi_error    =  *
00:CAF6 A53F            	   372:   lda  RUNNING
00:CAF8 1002            	   373:   bpl  atoi_not_running
00:CAFA 38              	   374:   sec             ; otherwise set carry and return
00:CAFB 60              	   375:   rts
                        	   376: atoi_not_running  =  *
00:CAFC A21E            	   377:   ldx  #30       ; ERROR: Number out of Range
00:CAFE 4C8397          	   378:   jmp  ERROR
                        	   379: 
                        	   380: ;
                        	   381: ;  for negative numbers, subtract token_value from zero
                        	   382: ;
                        	   383: negate_token_value:
00:CB01 38              	   384:   sec
00:CB02 A900            	   385:   lda  #0
00:CB04 E594            	   386:   sbc  token_value
00:CB06 8594            	   387:   sta  token_value
00:CB08 A900            	   388:   lda  #0
00:CB0A E595            	   389:   sbc  token_value+1
00:CB0C 8595            	   390:   sta  token_value+1
00:CB0E A900            	   391:   lda  #0
00:CB10 E596            	   392:   sbc  token_value+2
00:CB12 8596            	   393:   sta  token_value+2
00:CB14 60              	   394:   rts
                        	   395: 
                        	   396: 
                        	   397: gtoken_table:
                        	   398:   tknjmpItem '(',gc_lh_paren
00:CB15 28              	     1M    dfb   '('
00:CB16 5DCB            	     2M    word  gc_lh_paren
                        	   399:   tknjmpItem '{',gc_lh_brace
00:CB18 7B              	     1M    dfb   '{'
00:CB19 59CB            	     2M    word  gc_lh_brace
                        	   400:   tknjmpItem '"',gc_quote
00:CB1B 22              	     1M    dfb   '"'
00:CB1C 4CCC            	     2M    word  gc_quote
                        	   401:   tknjmpItem SINGLE_QUOTE,gc_quote
00:CB1E 27              	     1M    dfb   SINGLE_QUOTE
00:CB1F 4CCC            	     2M    word  gc_quote
                        	   402:   tknjmpItem '$',gc_dollar
00:CB21 24              	     1M    dfb   '$'
00:CB22 1ACD            	     2M    word  gc_dollar
                        	   403:   tknjmpItem '%',gc_percent
00:CB24 25              	     1M    dfb   '%'
00:CB25 74CD            	     2M    word  gc_percent
                        	   404:   tknjmpItem ':',gc_colon
00:CB27 3A              	     1M    dfb   ':'
00:CB28 9ECD            	     2M    word  gc_colon
                        	   405:   tknjmpItem '<',gc_less_than
00:CB2A 3C              	     1M    dfb   '<'
00:CB2B AFCD            	     2M    word  gc_less_than
                        	   406:   tknjmpItem '>',gc_greater_than
00:CB2D 3E              	     1M    dfb   '>'
00:CB2E D2CD            	     2M    word  gc_greater_than
                        	   407:   tknjmpItem '-',gc_minus
00:CB30 2D              	     1M    dfb   '-'
00:CB31 ECCD            	     2M    word  gc_minus
                        	   408:   tknjmpItem '+',gc_plus
00:CB33 2B              	     1M    dfb   '+'
00:CB34 EECD            	     2M    word  gc_plus
                        	   409:   tknjmpItem '&',gc_ampersand
00:CB36 26              	     1M    dfb   '&'
00:CB37 0DCE            	     2M    word  gc_ampersand
                        	   410:   tknjmpItem '|',gc_bar
00:CB39 7C              	     1M    dfb   '|'
00:CB3A 1ECE            	     2M    word  gc_bar
                        	   411:   tknjmpItem '=',gc_equals
00:CB3C 3D              	     1M    dfb   '='
00:CB3D 2FCE            	     2M    word  gc_equals
                        	   412:   tknjmpItem '!',gc_bang
00:CB3F 21              	     1M    dfb   '!'
00:CB40 40CE            	     2M    word  gc_bang
                        	   413:   tknjmpItem ';',gc_semicolon
00:CB42 3B              	     1M    dfb   ';'
00:CB43 13CC            	     2M    word  gc_semicolon
00:CB45 00              	   414:   dfb        0   ; end of table
                        	   415: 
                        	   416: gtoken_directive_table:
                        	   417:   tknjmpItem 'S',gc_directive_symbols
00:CB46 53              	     1M    dfb   'S'
00:CB47 C5CB            	     2M    word  gc_directive_symbols
                        	   418:   tknjmpItem 'L',gc_directive_list
00:CB49 4C              	     1M    dfb   'L'
00:CB4A FDCB            	     2M    word  gc_directive_list
                        	   419:   tknjmpItem 'P',gc_directive_pcodes
00:CB4C 50              	     1M    dfb   'P'
00:CB4D 04CC            	     2M    word  gc_directive_pcodes
                        	   420:   tknjmpItem 'N',gc_directive_nolist
00:CB4F 4E              	     1M    dfb   'N'
00:CB50 0ACC            	     2M    word  gc_directive_nolist
00:CB52 00              	   421:   dfb        0
                        	   422: 
                        	   423: ; single byte token, in A
00:CB53 4CDCC9          	   424: gc_single_byte_tokenJ jmp gc_single_byte_token
                        	   425: ; single byte token in token_type
00:CB56 4CDAC9          	   426: gc_single_byte_already_knownJ jmp gc_single_byte_already_known
                        	   427: 
                        	   428: gc_lh_brace:
00:CB59 A000            	   429:   ldy #0
00:CB5B 800E            	   430:   bra gc_pascal_comment
                        	   431: gc_lh_paren:
00:CB5D A902            	   432:   lda #FLAG_ASSEMBLING
00:CB5F 25BE            	   433:   and system_flags
00:CB61 D0F3            	   434:   bne gc_single_byte_already_knownJ
00:CB63 A001            	   435:   ldy #1
00:CB65 B18E            	   436:   lda (token_start),Y
00:CB67 C92A            	   437:   cmp #'*'      ; was it: (* ?
00:CB69 D0EB            	   438:   bne gc_single_byte_already_knownJ  ; nope
                        	   439: 
                        	   440: ;
                        	   441: ;  Y will be 0 or 1 depending on the sort of starting comment
                        	   442: ;  first look for % which indicates a compiler directive
                        	   443: ;
                        	   444: gc_pascal_comment:
00:CB6B C8              	   445:   iny
00:CB6C B18E            	   446:   lda (token_start),Y
00:CB6E C925            	   447:   cmp #'%'   ; directive?
00:CB70 D018            	   448:   bne gc_pascal_comment_find_end
00:CB72 C8              	   449:   iny
00:CB73 B18E            	   450:   lda (token_start),Y ; get the directive: S, L, P or N
00:CB75 48              	   451:   pha   ; save the directive for now
00:CB76 98              	   452:   tya
                        	   453: ;
                        	   454: ;  make token_start point to where we are up to, so we can skip the comment, even if it is long
                        	   455: ;
00:CB77 38              	   456:   sec               ; I actually want to be one past where the directive letter is
00:CB78 658E            	   457:   adc token_start
00:CB7A 858E            	   458:   sta token_start
00:CB7C A900            	   459:   lda #0
00:CB7E 658F            	   460:   adc token_start+1
00:CB80 858F            	   461:   sta token_start+1
00:CB82 68              	   462:   pla   ; get the directive back
00:CB83 A246            	   463:   ldx #<gtoken_directive_table
00:CB85 A0CB            	   464:   ldy #>gtoken_directive_table
00:CB87 20B18F          	   465:   jsr TKNJMP  ; do the directive handler
                        	   466: ;
                        	   467: ;  fall through if not found and just find the end of the comment
                        	   468: ;
                        	   469: 
                        	   470: gc_pascal_comment_find_end:
00:CB8A A000            	   471:   ldy #0    ; we normalised token_start to be where we want to start
00:CB8C B18E            	   472:   lda (token_start),Y
00:CB8E D005            	   473:   bne gc_comment_not_eof
00:CB90 A207            	   474:   ldx  #7           ; NO } FOUND
00:CB92 4C8397          	   475:   jmp  ERROR
                        	   476: gc_comment_not_eof:
00:CB95 C90A            	   477:   cmp #NL
00:CB97 D005            	   478:   bne gc_comment_not_newline
00:CB99 2038CA          	   479:   jsr token_line    ; handle the newline (we can't be assembling or we wouldn't be here)
00:CB9C 800F            	   480:   bra gc_comment_keep_looking
                        	   481: gc_comment_not_newline:
00:CB9E C97D            	   482:   cmp #'}'
00:CBA0 F013            	   483:   beq gc_comment_found_end
00:CBA2 C92A            	   484:   cmp #'*'
00:CBA4 D007            	   485:   bne gc_comment_keep_looking
00:CBA6 C8              	   486:   iny
00:CBA7 B18E            	   487:   lda (token_start),Y
00:CBA9 C929            	   488:   cmp #')'
00:CBAB F008            	   489:   beq gc_comment_found_end
                        	   490: 
                        	   491: ;
                        	   492: ;  skip this byte and keep looking for the end of comment
                        	   493: ;
                        	   494: gc_comment_keep_looking:
00:CBAD E68E            	   495:   inc token_start
00:CBAF D0D9            	   496:   bne gc_pascal_comment_find_end
00:CBB1 E68F            	   497:   inc token_start+1
00:CBB3 80D5            	   498:   bra gc_pascal_comment_find_end
                        	   499: 
                        	   500: ;
                        	   501: ;  found end of comment, so move token_start to this character
                        	   502: ;   (the one past the end of the comment) and try again for a token
                        	   503: ;
                        	   504: gc_comment_found_end:
00:CBB5 C8              	   505:   iny   ; get past end of comment
00:CBB6 98              	   506:   tya
00:CBB7 18              	   507:   clc
00:CBB8 658E            	   508:   adc token_start
00:CBBA 858E            	   509:   sta token_start
00:CBBC A900            	   510:   lda #0
00:CBBE 658F            	   511:   adc token_start+1
00:CBC0 858F            	   512:   sta token_start+1
00:CBC2 4C9CC9          	   513:   jmp get_token_loop
                        	   514: 
                        	   515: ;
                        	   516: ;  {%S $nnnn}
                        	   517: ;  symbol table relocation
                        	   518: ;
                        	   519: gc_directive_symbols:
00:CBC5 209CC9          	   520:    jsr  get_token_loop     ; re-call get_token to find the address
00:CBC8 C94E            	   521:    cmp  #TOKEN_NUMBER ; number?
00:CBCA F005            	   522:    beq  gc_directive_symbols_ok      ; yes
00:CBCC A202            	   523:    ldx  #2
00:CBCE 4C8397          	   524:    jmp  ERROR      ; 'Constant expected'
                        	   525: 
                        	   526: gc_directive_symbols_ok:
                        	   527:   ;
                        	   528:   ;  check we haven't generated any code
                        	   529:   ;
00:CBD1 A523            	   530:   lda PCODE
00:CBD3 C525            	   531:   cmp ACT_PCDA
00:CBD5 D021            	   532:   bne gc_directive_symbols_too_late
00:CBD7 A524            	   533:   lda PCODE+1
00:CBD9 C526            	   534:   cmp ACT_PCDA+1
00:CBDB D01B            	   535:   bne gc_directive_symbols_too_late
                        	   536: 
00:CBDD A594            	   537:   lda  token_value
00:CBDF 8531            	   538:   sta  ENDSYM
00:CBE1 852F            	   539:   sta  STARTSYM
00:CBE3 852B            	   540:   sta  OPND
00:CBE5 A595            	   541:   lda  token_value+1
00:CBE7 8532            	   542:   sta  ENDSYM+1        ; store symbol table address
00:CBE9 8530            	   543:   sta  STARTSYM+1
00:CBEB 852C            	   544:   sta  OPND+1
00:CBED A901            	   545:   lda  #PCODE_STACK    ; change runtime stack
00:CBEF 20F3C7          	   546:   jsr  GENJMP
                        	   547: ;
                        	   548: ;  put the library functions back
                        	   549: ;
00:CBF2 20C0C6          	   550:   jsr  add_pascal_library_functions
                        	   551: 
00:CBF5 4C8ACB          	   552:   jmp  gc_pascal_comment_find_end     ; go back and find the end of the comment
                        	   553: ;
                        	   554: 
                        	   555: gc_directive_symbols_too_late:
00:CBF8 A233            	   556:   ldx #51        ; code already generated
00:CBFA 4C8397          	   557:   JMP  ERROR
                        	   558: 
                        	   559: 
                        	   560: ;
                        	   561: ;  {%L} - list source
                        	   562: ;
                        	   563: gc_directive_list:
00:CBFD A904            	   564:   lda #FLAG_LIST_SOURCE
00:CBFF 04BE            	   565:   tsb system_flags
00:CC01 4C8ACB          	   566:   jmp gc_pascal_comment_find_end
                        	   567: 
                        	   568: ;
                        	   569: ;  {%P} - list source and P-codes
                        	   570: ;
                        	   571: gc_directive_pcodes:
00:CC04 A901            	   572:   lda #1
00:CC06 852E            	   573:   sta DCODE
00:CC08 80F3            	   574:   bra gc_directive_list   ; also list source
                        	   575: ;
                        	   576: ;  {%N} - do not list source or P-codes
                        	   577: ;
                        	   578: gc_directive_nolist:
00:CC0A A904            	   579:   lda #FLAG_LIST_SOURCE
00:CC0C 14BE            	   580:   trb system_flags    ; clear both of the above flags
00:CC0E 642E            	   581:   stz DCODE
00:CC10 4C8ACB          	   582:   jmp gc_pascal_comment_find_end
                        	   583: 
                        	   584: ;
                        	   585: ;  semicolons start comments in the assembler
                        	   586: ;
                        	   587: gc_semicolon:
00:CC13 A902            	   588:   lda #FLAG_ASSEMBLING
00:CC15 25BE            	   589:   and system_flags
00:CC17 D003            	   590:   bne gc_assembler_comment_find_end
00:CC19 4CDAC9          	   591:   jmp gc_single_byte_already_known
                        	   592: 
                        	   593: gc_assembler_comment_find_end:
00:CC1C A000            	   594:   ldy #0
00:CC1E B18E            	   595:   lda (token_start),Y
00:CC20 D005            	   596:   bne gc_assembler_comment_not_eof
00:CC22 A90A            	   597:   lda #NL
00:CC24 8593            	   598:   sta token_type
00:CC26 60              	   599:   rts     ; exit without incrementing token_start
                        	   600: 
                        	   601: gc_assembler_comment_not_eof:
00:CC27 C90A            	   602:   cmp #NL
00:CC29 D003            	   603:   bne gc_assembler_comment_keep_looking
00:CC2B 4CDCC9          	   604:   jmp gc_single_byte_token
                        	   605: ;
                        	   606: ;  skip this byte and keep looking for the newline at the end of comment
                        	   607: ;
                        	   608: gc_assembler_comment_keep_looking:
00:CC2E E68E            	   609:   inc token_start
00:CC30 D0EA            	   610:   bne gc_assembler_comment_find_end
00:CC32 E68F            	   611:   inc token_start+1
00:CC34 80E6            	   612:   bra gc_assembler_comment_find_end
                        	   613: 
                        	   614: 
                        	   615: gc_backslash_tokens:
00:CC36 41              	   616:          DFB  'A',$07  ; bell ($07)
00:CC37 07
00:CC38 42              	   617:          DFB  'B',$08  ; backspace ($08)
00:CC39 08
00:CC3A 45              	   618:          DFB  'E',$1B  ; escape  (0x1B)
00:CC3B 1B
00:CC3C 46              	   619:          DFB  'F',$0C  ; formfeed ($0C)
00:CC3D 0C
00:CC3E 4E              	   620:          DFB  'N',$0A  ; newline  (0x0A)
00:CC3F 0A
00:CC40 52              	   621:          DFB  'R',$0D  ; carriage return (0x0D)
00:CC41 0D
00:CC42 54              	   622:          DFB  'T',$09  ; horizontal tab (0x09)
00:CC43 09
00:CC44 56              	   623:          DFB  'V',$0B  ; vertical tab (0x0B)
00:CC45 0B
00:CC46 5C              	   624:          DFB  $5C,$5C  ; backslash
00:CC47 5C
00:CC48 22              	   625:          DFB  '"','"'  ; double quote
00:CC49 22
00:CC4A 27              	   626:          DFB  SINGLE_QUOTE,SINGLE_QUOTE  ; single quote
00:CC4B 27
                        	   627: gc_backslash_tokens_end = *
                        	   628: gc_backslash_tokens_length = gc_backslash_tokens_end - gc_backslash_tokens
                        	   629: 
                        	   630: ;
                        	   631: ;  quoted string
                        	   632: ;
                        	   633: ;  resolve double quotes and backslash sequences and store it in INBUF
                        	   634: ;
                        	   635: ;
                        	   636: gc_quote:
00:CC4C 8598            	   637:   sta token_work    ; remember which sort
00:CC4E A000            	   638:   ldy #0            ; back to the start
00:CC50 6492            	   639:   stz token_length  ; zero-length string so far
00:CC52 A58E            	   640:   lda token_start
00:CC54 8590            	   641:   sta token_address   ; save the starting address of the token (not that it matters too much)
00:CC56 A58F            	   642:   lda token_start+1   ; repeat for high-order byte
00:CC58 8591            	   643:   sta token_address+1
                        	   644: 
                        	   645: gc_quote_loop:
00:CC5A C8              	   646:   iny                 ; onto next character
00:CC5B B18E            	   647:   lda (token_start),Y ; get the next character in the string
00:CC5D F004            	   648:   beq gc_quote_bad
00:CC5F C90A            	   649:   cmp  #NL
00:CC61 D005            	   650:   bne  gc_quote_loop_not_end_of_line
                        	   651: 
                        	   652: gc_quote_bad:
00:CC63 A208            	   653:   ldx  #8         ; MISSING QUOTE: Incorrect string
00:CC65 4C8397          	   654:   jmp  ERROR
                        	   655: 
                        	   656: gc_quote_loop_not_end_of_line:
00:CC68 C598            	   657:   cmp  token_work  ; same as start quote?
00:CC6A D037            	   658:   bne  gc_quote_not_finished       ; no
00:CC6C C8              	   659:   iny
00:CC6D B18E            	   660:   lda (token_start),Y ; see if another quote follows
00:CC6F C598            	   661:   cmp  token_work
00:CC71 F05A            	   662:   beq  gc_quote_not_backslash      ; embedded quote (ie. two quotes in a row)? Store a single quote symbol
                        	   663:   ;
                        	   664:   ;  here at end of quoted string
                        	   665:   ;
00:CC73 8498            	   666:   sty  token_work  ; remember how far through our input we are
00:CC75 A003            	   667:   ldy  #3          ; OK, we have the final quote, so is the string <= 3 characters long?
00:CC77 C492            	   668:   cpy  token_length
00:CC79 9002            	   669:   bcc  gc_quote_long_string   ; BLT - no
00:CC7B A492            	   670:   ldy  token_length           ; yes - load its actual length into Y (ie. 0, 1, 2, 3)
                        	   671: gc_quote_long_string:
00:CC7D 88              	   672:   dey      ; zero-relative
00:CC7E 3008            	   673:   bmi  gc_quote_copied_value   ; keep going into the length done
00:CC80 B90002          	   674:   lda  INBUF,Y   ; store the (up to) 3 bytes into VALUE as the token value
00:CC83 999400          	   675:   sta  token_value,Y
00:CC86 D0F5            	   676:   bne  gc_quote_long_string   ; keep going until we hit the 0x00 at the end
                        	   677: 
                        	   678: gc_quote_copied_value:
00:CC88 A592            	   679:   lda  token_length    ; now see how long it is?
00:CC8A D005            	   680:   bne  gc_quote_done     ; don't allow zero length strings
00:CC8C A20E            	   681:   ldx  #14        ; BAD STRING: literal string of zero length
00:CC8E 4C8397          	   682:   jmp  ERROR
                        	   683: 
                        	   684: gc_quote_done:
00:CC91 18              	   685:   clc
00:CC92 A58E            	   686:   lda token_start       ; bump up our token_start address to past the quoted string
00:CC94 6598            	   687:   adc token_work        ; now add its (actual) length, not the length afer mucking around
00:CC96 858E            	   688:   sta token_start       ; that gives the ending address
00:CC98 A58F            	   689:   lda token_start+1   ; repeat for high-order byte
00:CC9A 6900            	   690:   adc #0
00:CC9C 858F            	   691:   sta token_start+1
00:CC9E A922            	   692:   lda  #TOKEN_STRING   ; it's a string token
00:CCA0 8593            	   693:   sta  token_type
00:CCA2 60              	   694:   rts
                        	   695: 
                        	   696: 
                        	   697: gc_quote_not_finished:
00:CCA3 C95C            	   698:   cmp #$5C    ; backslash?
00:CCA5 D026            	   699:   bne  gc_quote_not_backslash
                        	   700: ;
                        	   701: ;  backslash - see what follows
                        	   702: ;
00:CCA7 C8              	   703:   iny
00:CCA8 B18E            	   704:   lda (token_start),Y ; the character after the backslash
00:CCAA F0B7            	   705:   beq gc_quote_bad    ; nothing? bad
00:CCAC 20E38F          	   706:   jsr MAKE_UPPER
00:CCAF C958            	   707:   cmp #'X'
00:CCB1 F038            	   708:   beq gc_quote_hex_character
00:CCB3 A200            	   709:   ldx #0
                        	   710: gc_quote_backslash_loop:
00:CCB5 DD36CC          	   711:   cmp gc_backslash_tokens,X
00:CCB8 F00F            	   712:   beq gc_quote_found_backslash_character   ; good match
00:CCBA E8              	   713:   inx
00:CCBB E8              	   714:   inx
00:CCBC E016            	   715:   cpx #gc_backslash_tokens_length
00:CCBE 90F5            	   716:   bcc gc_quote_backslash_loop
                        	   717: gc_quote_bad_string:
00:CCC0 A208            	   718:   ldx #8
00:CCC2 4C8397          	   719:   jmp ERROR   ; ERROR: Incorrect string
                        	   720: 
                        	   721: gc_quote_hex_character_done:
00:CCC5 A594            	   722:   lda token_value
00:CCC7 8004            	   723:   bra gc_quote_not_backslash
                        	   724: 
                        	   725: gc_quote_found_backslash_character:
00:CCC9 E8              	   726:   inx
00:CCCA BD36CC          	   727:   lda gc_backslash_tokens,X  ; get its replacement
                        	   728: 
                        	   729: gc_quote_not_backslash:
00:CCCD A692            	   730:   ldx  token_length
00:CCCF 9D0002          	   731:   sta  INBUF,x           ; store it in INBUF
00:CCD2 E692            	   732:   inc  token_length
00:CCD4 F003            	   733:   beq  gc_quote_too_long
00:CCD6 4C5ACC          	   734:   jmp  gc_quote_loop     ; keep adding to string
                        	   735: 
                        	   736: 
                        	   737: gc_quote_too_long:
                        	   738:   ;            string over 255 characters long - error!
00:CCD9 A21D            	   739:   ldx   #29  ; ERROR: string literal too big
00:CCDB 4C8397          	   740:   jmp  ERROR
                        	   741: 
                        	   742: ;
                        	   743: ;  "fix" a hex digit by making it upper-case, then subtracting 7 if it is A-F
                        	   744: ;   then subtracting '0' so we get a number in the range 0x00 to 0x0F in A
                        	   745: ;
                        	   746: gc_fix_hex:
00:CCDE 20E38F          	   747:   jsr  MAKE_UPPER
00:CCE1 C941            	   748:   cmp  #'A'
00:CCE3 9002            	   749:   bcc  gc_fix_hex_not_a_to_f
00:CCE5 E907            	   750:   sbc  #7
                        	   751: gc_fix_hex_not_a_to_f:
00:CCE7 38              	   752:   sec
00:CCE8 E930            	   753:   sbc  #'0'
00:CCEA 60              	   754:   rts
                        	   755: 
                        	   756: gc_quote_hex_character:
00:CCEB C8              	   757:   iny
00:CCEC F0EB            	   758:   beq  gc_quote_too_long
00:CCEE B18E            	   759:   lda  (token_start),Y ; the character after the backslash
00:CCF0 203E81          	   760:   jsr  isxdigit
00:CCF3 90CB            	   761:   bcc  gc_quote_bad_string  ; what? should be hex
00:CCF5 20DECC          	   762:   jsr  gc_fix_hex
00:CCF8 8594            	   763:   sta  token_value  ; first nibble
00:CCFA C8              	   764:   iny
00:CCFB F0DC            	   765:   beq  gc_quote_too_long
00:CCFD B18E            	   766:   lda  (token_start),Y ; a second hex character?
00:CCFF F0BF            	   767:   beq  gc_quote_bad_string
00:CD01 203E81          	   768:   jsr  isxdigit
00:CD04 9011            	   769:   bcc  gc_quote_hex_character_one_only
00:CD06 20DECC          	   770:   jsr  gc_fix_hex
00:CD09 0694            	   771:   asl  token_value    ; shift existing value 4 bits left
00:CD0B 0694            	   772:   asl  token_value
00:CD0D 0694            	   773:   asl  token_value
00:CD0F 0694            	   774:   asl  token_value
00:CD11 0594            	   775:   ora  token_value
00:CD13 8594            	   776:   sta  token_value
00:CD15 80AE            	   777:   bra  gc_quote_hex_character_done
                        	   778: 
                        	   779: gc_quote_hex_character_one_only:
00:CD17 88              	   780:   dey         ; undo add since we didn't find another hex character
00:CD18 80AB            	   781:   bra gc_quote_hex_character_done
                        	   782: 
                        	   783: ;
                        	   784: ;  $nnnnnn where nnnnnn is one or more hex digits
                        	   785: ;    if no hex digits, then it is the token '$'
                        	   786: ;
                        	   787: gc_dollar:
00:CD1A A001            	   788:   ldy  #1    ; start with the character after the dollar
00:CD1C B18E            	   789:   lda  (token_start),Y ; followed by a hex character?
00:CD1E 203E81          	   790:   jsr  isxdigit
00:CD21 B003            	   791:   bcs  gc_hex_literal
00:CD23 4CDAC9          	   792:   jmp  gc_single_byte_already_known
                        	   793: 
                        	   794: gc_hex_literal:
00:CD26 20DECC          	   795:   jsr gc_fix_hex
00:CD29 8594            	   796:   sta token_value       ; store the first digit
00:CD2B 6495            	   797:   stz token_value+1
00:CD2D 6496            	   798:   stz token_value+2
                        	   799: gc_hex_loop:
00:CD2F C8              	   800:   iny
00:CD30 B18E            	   801:   lda (token_start),Y ; followed by another hex character?
00:CD32 203E81          	   802:   jsr isxdigit
00:CD35 9033            	   803:   bcc gc_hex_done
00:CD37 20DECC          	   804:   jsr gc_fix_hex
                        	   805: ;
                        	   806: ;  shift the existing value left 4 bits to make room for the new nibble
                        	   807: ;
00:CD3A 0694            	   808:   asl  token_value        ; token_value shifted left 1 bit
00:CD3C 2695            	   809:   rol  token_value+1
00:CD3E 2696            	   810:   rol  token_value+2
00:CD40 B02D            	   811:   bcs  gc_hex_too_big
00:CD42 0694            	   812:   asl  token_value        ; token_value shifted left 2 bits
00:CD44 2695            	   813:   rol  token_value+1
00:CD46 2696            	   814:   rol  token_value+2
00:CD48 B025            	   815:   bcs  gc_hex_too_big
00:CD4A 0694            	   816:   asl  token_value        ; token_value shifted left 3 bits
00:CD4C 2695            	   817:   rol  token_value+1
00:CD4E 2696            	   818:   rol  token_value+2
00:CD50 B01D            	   819:   bcs  gc_hex_too_big
00:CD52 0694            	   820:   asl  token_value        ; token_value shifted left 4 bits
00:CD54 2695            	   821:   rol  token_value+1
00:CD56 2696            	   822:   rol  token_value+2
00:CD58 B015            	   823:   bcs  gc_hex_too_big
00:CD5A 6594            	   824:   adc  token_value        ; now add in this last digit (carry will be clear)
00:CD5C 8594            	   825:   sta  token_value        ; store the new result
00:CD5E 90CF            	   826:   bcc  gc_hex_loop
00:CD60 E695            	   827:   inc  token_value+1
00:CD62 90CB            	   828:   bcc  gc_hex_loop
00:CD64 E695            	   829:   inc  token_value+1
00:CD66 B007            	   830:   bcs  gc_hex_too_big
00:CD68 80C5            	   831:   bra  gc_hex_loop
                        	   832: 
                        	   833: gc_hex_done:
00:CD6A A94E            	   834:   lda #TOKEN_NUMBER
00:CD6C 4CDEC9          	   835:   jmp gc_done
                        	   836: 
                        	   837: gc_hex_too_big:
00:CD6F A21E            	   838:   ldx  #30       ; ERROR: Number out of Range
00:CD71 4C8397          	   839:   jmp  ERROR
                        	   840: 
                        	   841: ;
                        	   842: ;  %nnnnnn where nnnnnn is one or more binary digits
                        	   843: ;    if no binary digits, then it is the token '%'
                        	   844: ;
                        	   845: 
                        	   846: gc_percent:
00:CD74 A001            	   847:   ldy  #1    ; start with the character after the %
00:CD76 B18E            	   848:   lda  (token_start),Y ; followed by a binary character?
00:CD78 206E81          	   849:   jsr  isbinary
00:CD7B B003            	   850:   bcs  gc_binary_literal
00:CD7D 4CDAC9          	   851:   jmp  gc_single_byte_already_known
                        	   852: 
                        	   853: gc_binary_literal:
00:CD80 E930            	   854:   sbc #'0'              ; we know carry is set
00:CD82 8594            	   855:   sta token_value       ; store the first digit
00:CD84 6495            	   856:   stz token_value+1
00:CD86 6496            	   857:   stz token_value+2
                        	   858: gc_binary_loop:
00:CD88 C8              	   859:   iny
00:CD89 B18E            	   860:   lda (token_start),Y ; followed by another binary character?
00:CD8B 206E81          	   861:   jsr isbinary
00:CD8E 90DA            	   862:   bcc gc_hex_done
00:CD90 E930            	   863:   sbc #'0'              ; we know carry is set
                        	   864: 
00:CD92 6A              	   865:   ror A   ; get the new bit into Carry
00:CD93 2694            	   866:   rol token_value
00:CD95 2695            	   867:   rol token_value+1
00:CD97 2696            	   868:   rol token_value+2
00:CD99 90ED            	   869:   bcc gc_binary_loop
00:CD9B 4C6FCD          	   870:   jmp gc_hex_too_big   ; number too large
                        	   871: 
                        	   872: ;
                        	   873: ;  token : might be :=
                        	   874: ;
                        	   875: gc_colon:
00:CD9E A001            	   876:   ldy  #1               ; get the next character
00:CDA0 B18E            	   877:   lda  (token_start),Y  ; followed by = ?
00:CDA2 C93D            	   878:   cmp  #'='
00:CDA4 F003            	   879:   beq  gc_assign
00:CDA6 4CDAC9          	   880:   jmp  gc_single_byte_already_known
                        	   881: 
                        	   882: gc_assign:
00:CDA9 A941            	   883:   lda #TOKEN_ASSIGN
00:CDAB C8              	   884:   iny
00:CDAC 4CDEC9          	   885:   jmp gc_done
                        	   886: 
                        	   887: ;
                        	   888: ;  token: < might be <=, <>, <<
                        	   889: ;
                        	   890: gc_less_than:
00:CDAF A001            	   891:   ldy  #1               ; get the next character
00:CDB1 B18E            	   892:   lda  (token_start),Y  ; followed by = ?
00:CDB3 C8              	   893:   iny                   ; make it a 2-byte token
00:CDB4 C93D            	   894:   cmp  #'='
00:CDB6 F00B            	   895:   beq  gc_leq
00:CDB8 C93E            	   896:   cmp  #'>'
00:CDBA F00C            	   897:   beq  gc_neq
00:CDBC C93C            	   898:   cmp  #'<'
00:CDBE F00D            	   899:   beq  gc_shift_left
00:CDC0 4CDAC9          	   900:   jmp  gc_single_byte_already_known
                        	   901: 
                        	   902: gc_leq:
00:CDC3 A980            	   903:   lda #TOKEN_LEQ
00:CDC5 4CDEC9          	   904:   jmp gc_done
                        	   905: 
                        	   906: gc_neq:
00:CDC8 A955            	   907:   lda #TOKEN_NEQ
00:CDCA 4CDEC9          	   908:   jmp gc_done
                        	   909: 
                        	   910: gc_shift_left:
00:CDCD A94C            	   911:   lda #TOKEN_SHIFT_LEFT
00:CDCF 4CDEC9          	   912:   jmp gc_done
                        	   913: 
                        	   914: ;
                        	   915: ;  token: > might be <>=, >>
                        	   916: ;
                        	   917: gc_greater_than:
00:CDD2 A001            	   918:   ldy  #1               ; get the next character
00:CDD4 B18E            	   919:   lda  (token_start),Y  ; followed by = ?
00:CDD6 C8              	   920:   iny                   ; make it a 2-byte token
00:CDD7 C93D            	   921:   cmp  #'='
00:CDD9 F007            	   922:   beq  gc_geq
00:CDDB C93E            	   923:   cmp  #'>'
00:CDDD F008            	   924:   beq  gc_shift_right
                        	   925: 
                        	   926: gc_single_byte_already_knownJ2:
00:CDDF 4CDAC9          	   927:   jmp  gc_single_byte_already_known
                        	   928: 
                        	   929: gc_geq:
00:CDE2 A981            	   930:   lda #TOKEN_GEQ
00:CDE4 4CDEC9          	   931:   jmp gc_done
                        	   932: 
                        	   933: gc_shift_right:
00:CDE7 A952            	   934:   lda #TOKEN_SHIFT_RIGHT
00:CDE9 4CDEC9          	   935:   jmp gc_done
                        	   936: 
                        	   937: 
                        	   938: ;
                        	   939: ;  minus and plus sign
                        	   940: ;
                        	   941: 
                        	   942: gc_minus:
00:CDEC 8597            	   943:   sta token_sign
                        	   944: gc_plus:
                        	   945: 
                        	   946: ;
                        	   947: ;  new stuff - treat a sign as a token on its own if the previous token was one of:
                        	   948: ;    a) a number
                        	   949: ;    b) an identifier
                        	   950: ;    c) a RH bracket
                        	   951: ;
                        	   952: ;  So, for example: 2+3 is three tokens, but 2+-5 is also three, as the -5 becomes one token
                        	   953: ;
00:CDEE A598            	   954:   lda  token_work            ; saved previous token on entry to get_token
00:CDF0 C94E            	   955:   cmp  #TOKEN_NUMBER
00:CDF2 F0EB            	   956:   beq  gc_single_byte_already_knownJ2
00:CDF4 C949            	   957:   cmp  #TOKEN_IDENTIFIER
00:CDF6 F0E7            	   958:   beq  gc_single_byte_already_knownJ2
00:CDF8 C929            	   959:   cmp  #')'
00:CDFA F0E3            	   960:   beq  gc_single_byte_already_knownJ2
                        	   961: ;
                        	   962: ;  if not, see if this is a signed number (ie. it is directly followed by a digit)
                        	   963: ;
00:CDFC A001            	   964:   ldy  #1               ; get the next character
00:CDFE B18E            	   965:   lda  (token_start),Y  ; followed by a digit?
00:CE00 203281          	   966:   jsr  isdigit
00:CE03 90DA            	   967:   bcc  gc_single_byte_already_knownJ2
00:CE05 2087CA          	   968:   jsr atoi
00:CE08 A94E            	   969:   lda  #TOKEN_NUMBER
00:CE0A 4CDEC9          	   970:   jmp  gc_done
                        	   971: 
                        	   972: 
                        	   973: ;
                        	   974: ;  token: & might be &&
                        	   975: ;
                        	   976: gc_ampersand:
00:CE0D A001            	   977:   ldy  #1               ; get the next character
00:CE0F B18E            	   978:   lda  (token_start),Y  ; followed by & ?
00:CE11 C926            	   979:   cmp  #'&'
00:CE13 F003            	   980:   beq  gc_logical_and
00:CE15 4CDAC9          	   981:   jmp  gc_single_byte_already_known
                        	   982: 
                        	   983: gc_logical_and:
00:CE18 A958            	   984:   lda #TOKEN_LOGICAL_AND
00:CE1A C8              	   985:   iny
00:CE1B 4CDEC9          	   986:   jmp gc_done
                        	   987: 
                        	   988: ;
                        	   989: ;  token: | might be ||
                        	   990: ;
                        	   991: gc_bar:
00:CE1E A001            	   992:   ldy  #1               ; get the next character
00:CE20 B18E            	   993:   lda  (token_start),Y  ; followed by | ?
00:CE22 C97C            	   994:   cmp  #'|'
00:CE24 F003            	   995:   beq  gc_logical_or
00:CE26 4CDAC9          	   996:   jmp  gc_single_byte_already_known
                        	   997: 
                        	   998: gc_logical_or:
00:CE29 A959            	   999:   lda #TOKEN_LOGICAL_OR
00:CE2B C8              	  1000:   iny
00:CE2C 4CDEC9          	  1001:   jmp gc_done
                        	  1002: 
                        	  1003: ;
                        	  1004: ;  token: = might be ==
                        	  1005: ;
                        	  1006: gc_equals:
00:CE2F A001            	  1007:   ldy  #1               ; get the next character
00:CE31 B18E            	  1008:   lda  (token_start),Y  ; followed by = ?
00:CE33 C93D            	  1009:   cmp  #'='
00:CE35 F003            	  1010:   beq  gc_equality
00:CE37 4CDAC9          	  1011:   jmp  gc_single_byte_already_known
                        	  1012: 
                        	  1013: gc_equality:
00:CE3A A945            	  1014:   lda #TOKEN_EQUALITY
00:CE3C C8              	  1015:   iny
00:CE3D 4CDEC9          	  1016:   jmp gc_done
                        	  1017: 
                        	  1018: ;
                        	  1019: ;  token: ! might be !=
                        	  1020: ;
                        	  1021: gc_bang:
00:CE40 A001            	  1022:   ldy  #1               ; get the next character
00:CE42 B18E            	  1023:   lda  (token_start),Y  ; followed by = ?
00:CE44 C93D            	  1024:   cmp  #'='
00:CE46 F003            	  1025:   beq  gc_inequality
00:CE48 4CDAC9          	  1026:   jmp  gc_single_byte_already_known
                        	  1027: 
                        	  1028: gc_inequality:
00:CE4B A95A            	  1029:   lda #TOKEN_INEQUALITY
00:CE4D C8              	  1030:   iny
00:CE4E 4CDEC9          	  1031:   jmp gc_done
                        	  1032: 
                        	  1033: 
                        	  1034: 
                        	  1035: ; Pascal tokens
                        	  1036: 
                        	  1037: TOKEN_CONST     = $82
                        	  1038: TOKEN_VAR       = $83
                        	  1039: TOKEN_ARRAY     = $84
                        	  1040: TOKEN_OF        = $85
                        	  1041: TOKEN_PROCEDURE = $86
                        	  1042: TOKEN_FUNCTION  = $87
                        	  1043: TOKEN_BEGIN     = $88
                        	  1044: TOKEN_END       = $89
                        	  1045: TOKEN_OR        = $8A
                        	  1046: TOKEN_DIV       = $8B
                        	  1047: TOKEN_MOD       = $8C
                        	  1048: TOKEN_AND       = $8D
                        	  1049: TOKEN_SHL       = $8E
                        	  1050: TOKEN_SHR       = $8F
                        	  1051: TOKEN_NOT       = $90
                        	  1052: TOKEN_MEM       = $91
                        	  1053: TOKEN_IF        = $92
                        	  1054: TOKEN_THEN      = $93
                        	  1055: TOKEN_ELSE      = $94
                        	  1056: TOKEN_CASE      = $95
                        	  1057: TOKEN_WHILE     = $96
                        	  1058: TOKEN_DO        = $97
                        	  1059: TOKEN_REPEAT    = $98
                        	  1060: TOKEN_UNTIL     = $99
                        	  1061: TOKEN_FOR       = $9A
                        	  1062: TOKEN_TO        = $9B
                        	  1063: TOKEN_DOWNTO    = $9C
                        	  1064: TOKEN_WRITE     = $9D
                        	  1065: TOKEN_READ      = $9E
                        	  1066: TOKEN_CALL      = $9F
                        	  1067: TOKEN_CHAR      = $A1
                        	  1068: TOKEN_MEMC      = $A2
                        	  1069: TOKEN_XOR       = $A4
                        	  1070: TOKEN_ADDRESS   = $A9
                        	  1071: TOKEN_CHR       = $AB
                        	  1072: TOKEN_HEX       = $AC
                        	  1073: ; $B0 to $DE used by message tokens
                        	  1074: TOKEN_LCDWRITE  = $F1
                        	  1075: TOKEN_INTEGER   = $FE
                        	  1076: TOKEN_WRITELN   = $FF
                        	  1077: 
                        	  1078: 
                        	  1079: 
                        	  1080: ; RESERVED WORD TABLE
                        	  1081: ;
                        	  1082: ;***********************************************
                        	  1083:          .macro makeToken  ; MACRO DEFINITION FOR TOKENS: Length, token number, token name
                        	  1084:          DFB  \1
                        	  1085:          DFB  \2
                        	  1086:          text  \3
                        	  1087:          .endmacro           ; END OF MACRO
                        	  1088: 
                        	  1089: ;
                        	  1090: ; Reserved words are identified internally by their code (eg. $86 for PROCEDURE)
                        	  1091: ;
                        	  1092: ;  They are also stored "tokenised" and expanded out when you list the source
                        	  1093: ;
                        	  1094: ; Other tokens are:
                        	  1095: ;  * Punctuation (eg. "<", ">", "=", ".", "(", ")", "$", "+", "-"
                        	  1096: ;  * Identifiers: "I"        (eg. MY_VARIABLE)
                        	  1097: ;  * Constant numbers: "N"   (eg. -1234 and $1234)
                        	  1098: ;  * Literal strings:  '"' (quote symbol)  (eg. "Nick")
                        	  1099: ;  * Double-character punctuation:
                        	  1100: ;       <= : $80
                        	  1101: ;       >= : $81
                        	  1102: ;       Unequal (<>) : "U"
                        	  1103: ;       Assignment (:=) : "A"
                        	  1104: ;
                        	  1105: ; Comments are skipped: (* some comment *)
                        	  1106: ;
                        	  1107: ;
                        	  1108: ; However comments can have compiler directives embedded, eg. (*%A $4000) - put P-codes at $4000
                        	  1109: ;    (*%L*) - list during compile
                        	  1110: ;    (*%N*) - stop listing during compile (cancels %L and %P)
                        	  1111: ;    (*%P*) - show P-codes during compile
                        	  1112: ;    (*%A  $nnnn *) - put P-codes at address $nnnn - must be at START of program
                        	  1113: ;
                        	  1114: ;
                        	  1115: 
                        	  1116: ;              Length   Code             Name
                        	  1117: ;                  --   --------------- ---------------
                        	  1118: RSVWRD   =  *
                        	  1119:    makeToken   5, TOKEN_CONST     ,"CONST"
00:CE51 05              	     1M          DFB  5
00:CE52 82              	     2M          DFB  TOKEN_CONST     
00:CE53 434F4E5354      	     3M          text  "CONST"
                        	  1120:    makeToken   3, TOKEN_VAR       ,"VAR"
00:CE58 03              	     1M          DFB  3
00:CE59 83              	     2M          DFB  TOKEN_VAR       
00:CE5A 564152          	     3M          text  "VAR"
                        	  1121:    makeToken   5, TOKEN_ARRAY     ,"ARRAY"
00:CE5D 05              	     1M          DFB  5
00:CE5E 84              	     2M          DFB  TOKEN_ARRAY     
00:CE5F 4152524159      	     3M          text  "ARRAY"
                        	  1122:    makeToken   2, TOKEN_OF        ,"OF"
00:CE64 02              	     1M          DFB  2
00:CE65 85              	     2M          DFB  TOKEN_OF        
00:CE66 4F46            	     3M          text  "OF"
                        	  1123:    makeToken   9, TOKEN_PROCEDURE ,"PROCEDURE"
00:CE68 09              	     1M          DFB  9
00:CE69 86              	     2M          DFB  TOKEN_PROCEDURE 
00:CE6A 50524F4345445552	     3M          text  "PROCEDURE"
00:CE72 45
                        	  1124:    makeToken   8, TOKEN_FUNCTION  ,"FUNCTION"
00:CE73 08              	     1M          DFB  8
00:CE74 87              	     2M          DFB  TOKEN_FUNCTION  
00:CE75 46554E4354494F4E	     3M          text  "FUNCTION"
                        	  1125:    makeToken   5, TOKEN_BEGIN     ,"BEGIN"
00:CE7D 05              	     1M          DFB  5
00:CE7E 88              	     2M          DFB  TOKEN_BEGIN     
00:CE7F 424547494E      	     3M          text  "BEGIN"
                        	  1126:    makeToken   3, TOKEN_END       ,"END"
00:CE84 03              	     1M          DFB  3
00:CE85 89              	     2M          DFB  TOKEN_END       
00:CE86 454E44          	     3M          text  "END"
                        	  1127:    makeToken   2, TOKEN_OR        ,"OR"
00:CE89 02              	     1M          DFB  2
00:CE8A 8A              	     2M          DFB  TOKEN_OR        
00:CE8B 4F52            	     3M          text  "OR"
                        	  1128:    makeToken   3, TOKEN_DIV       ,"DIV"
00:CE8D 03              	     1M          DFB  3
00:CE8E 8B              	     2M          DFB  TOKEN_DIV       
00:CE8F 444956          	     3M          text  "DIV"
                        	  1129:    makeToken   3, TOKEN_MOD       ,"MOD"
00:CE92 03              	     1M          DFB  3
00:CE93 8C              	     2M          DFB  TOKEN_MOD       
00:CE94 4D4F44          	     3M          text  "MOD"
                        	  1130:    makeToken   3, TOKEN_AND       ,"AND"
00:CE97 03              	     1M          DFB  3
00:CE98 8D              	     2M          DFB  TOKEN_AND       
00:CE99 414E44          	     3M          text  "AND"
                        	  1131:    makeToken   3, TOKEN_SHL       ,"SHL"
00:CE9C 03              	     1M          DFB  3
00:CE9D 8E              	     2M          DFB  TOKEN_SHL       
00:CE9E 53484C          	     3M          text  "SHL"
                        	  1132:    makeToken   3, TOKEN_SHR       ,"SHR"
00:CEA1 03              	     1M          DFB  3
00:CEA2 8F              	     2M          DFB  TOKEN_SHR       
00:CEA3 534852          	     3M          text  "SHR"
                        	  1133:    makeToken   3, TOKEN_NOT       ,"NOT"
00:CEA6 03              	     1M          DFB  3
00:CEA7 90              	     2M          DFB  TOKEN_NOT       
00:CEA8 4E4F54          	     3M          text  "NOT"
                        	  1134:    makeToken   3, TOKEN_MEM       ,"MEM"
00:CEAB 03              	     1M          DFB  3
00:CEAC 91              	     2M          DFB  TOKEN_MEM       
00:CEAD 4D454D          	     3M          text  "MEM"
                        	  1135:    makeToken   2, TOKEN_IF        ,"IF"
00:CEB0 02              	     1M          DFB  2
00:CEB1 92              	     2M          DFB  TOKEN_IF        
00:CEB2 4946            	     3M          text  "IF"
                        	  1136:    makeToken   4, TOKEN_THEN      ,"THEN"
00:CEB4 04              	     1M          DFB  4
00:CEB5 93              	     2M          DFB  TOKEN_THEN      
00:CEB6 5448454E        	     3M          text  "THEN"
                        	  1137:    makeToken   4, TOKEN_ELSE      ,"ELSE"
00:CEBA 04              	     1M          DFB  4
00:CEBB 94              	     2M          DFB  TOKEN_ELSE      
00:CEBC 454C5345        	     3M          text  "ELSE"
                        	  1138:    makeToken   4, TOKEN_CASE      ,"CASE"
00:CEC0 04              	     1M          DFB  4
00:CEC1 95              	     2M          DFB  TOKEN_CASE      
00:CEC2 43415345        	     3M          text  "CASE"
                        	  1139:    makeToken   5, TOKEN_WHILE     ,"WHILE"
00:CEC6 05              	     1M          DFB  5
00:CEC7 96              	     2M          DFB  TOKEN_WHILE     
00:CEC8 5748494C45      	     3M          text  "WHILE"
                        	  1140:    makeToken   2, TOKEN_DO        ,"DO"
00:CECD 02              	     1M          DFB  2
00:CECE 97              	     2M          DFB  TOKEN_DO        
00:CECF 444F            	     3M          text  "DO"
                        	  1141:    makeToken   6, TOKEN_REPEAT    ,"REPEAT"
00:CED1 06              	     1M          DFB  6
00:CED2 98              	     2M          DFB  TOKEN_REPEAT    
00:CED3 524550454154    	     3M          text  "REPEAT"
                        	  1142:    makeToken   5, TOKEN_UNTIL     ,"UNTIL"
00:CED9 05              	     1M          DFB  5
00:CEDA 99              	     2M          DFB  TOKEN_UNTIL     
00:CEDB 554E54494C      	     3M          text  "UNTIL"
                        	  1143:    makeToken   3, TOKEN_FOR       ,"FOR"
00:CEE0 03              	     1M          DFB  3
00:CEE1 9A              	     2M          DFB  TOKEN_FOR       
00:CEE2 464F52          	     3M          text  "FOR"
                        	  1144:    makeToken   2, TOKEN_TO        ,"TO"
00:CEE5 02              	     1M          DFB  2
00:CEE6 9B              	     2M          DFB  TOKEN_TO        
00:CEE7 544F            	     3M          text  "TO"
                        	  1145:    makeToken   6, TOKEN_DOWNTO    ,"DOWNTO"
00:CEE9 06              	     1M          DFB  6
00:CEEA 9C              	     2M          DFB  TOKEN_DOWNTO    
00:CEEB 444F574E544F    	     3M          text  "DOWNTO"
                        	  1146:    makeToken   5, TOKEN_WRITE     ,"WRITE"
00:CEF1 05              	     1M          DFB  5
00:CEF2 9D              	     2M          DFB  TOKEN_WRITE     
00:CEF3 5752495445      	     3M          text  "WRITE"
                        	  1147:    makeToken   4, TOKEN_READ      ,"READ"
00:CEF8 04              	     1M          DFB  4
00:CEF9 9E              	     2M          DFB  TOKEN_READ      
00:CEFA 52454144        	     3M          text  "READ"
                        	  1148:    makeToken   4, TOKEN_CALL      ,"CALL"
00:CEFE 04              	     1M          DFB  4
00:CEFF 9F              	     2M          DFB  TOKEN_CALL      
00:CF00 43414C4C        	     3M          text  "CALL"
                        	  1149:    makeToken   4, TOKEN_CHAR      ,"CHAR"
00:CF04 04              	     1M          DFB  4
00:CF05 A1              	     2M          DFB  TOKEN_CHAR      
00:CF06 43484152        	     3M          text  "CHAR"
                        	  1150:    makeToken   4, TOKEN_MEMC      ,"MEMC"
00:CF0A 04              	     1M          DFB  4
00:CF0B A2              	     2M          DFB  TOKEN_MEMC      
00:CF0C 4D454D43        	     3M          text  "MEMC"
                        	  1151:    makeToken   3, TOKEN_XOR       ,"XOR"
00:CF10 03              	     1M          DFB  3
00:CF11 A4              	     2M          DFB  TOKEN_XOR       
00:CF12 584F52          	     3M          text  "XOR"
                        	  1152:    makeToken   7, TOKEN_ADDRESS   ,"ADDRESS"
00:CF15 07              	     1M          DFB  7
00:CF16 A9              	     2M          DFB  TOKEN_ADDRESS   
00:CF17 41444452455353  	     3M          text  "ADDRESS"
                        	  1153:    makeToken   3, TOKEN_CHR       ,"CHR"
00:CF1E 03              	     1M          DFB  3
00:CF1F AB              	     2M          DFB  TOKEN_CHR       
00:CF20 434852          	     3M          text  "CHR"
                        	  1154:    makeToken   3, TOKEN_HEX       ,"HEX"
00:CF23 03              	     1M          DFB  3
00:CF24 AC              	     2M          DFB  TOKEN_HEX       
00:CF25 484558          	     3M          text  "HEX"
                        	  1155:    makeToken   7, TOKEN_INTEGER   ,"INTEGER"
00:CF28 07              	     1M          DFB  7
00:CF29 FE              	     2M          DFB  TOKEN_INTEGER   
00:CF2A 494E5445474552  	     3M          text  "INTEGER"
                        	  1156:    makeToken   7, TOKEN_WRITELN   ,"WRITELN"
00:CF31 07              	     1M          DFB  7
00:CF32 FF              	     2M          DFB  TOKEN_WRITELN   
00:CF33 57524954454C4E  	     3M          text  "WRITELN"
                        	  1157:    makeToken   8, TOKEN_LCDWRITE  ,"LCDWRITE"
00:CF3A 08              	     1M          DFB  8
00:CF3B F1              	     2M          DFB  TOKEN_LCDWRITE  
00:CF3C 4C43445752495445	     3M          text  "LCDWRITE"
                        	  1158: 
                        	  1159: 
00:CF44 00              	  1160: RSVEND   DFB  0,0        ; END OF TABLE
00:CF45 00
                        	  1161: ;
                        	  1162: 
                        	  1163: ;
                        	  1164: ;  Pascal get_token
                        	  1165: ;
                        	  1166: ;  Used in the Pascal section. Does a get_token, and then if an identifier is found tries to look
                        	  1167: ;  it up.
                        	  1168: ;
                        	  1169: pas_get_token:
00:CF46 2098C9          	  1170:   jsr get_token
00:CF49 F004            	  1171:   beq pas_get_token_eof   ; branch to make sure Z flag stays set
00:CF4B C949            	  1172:   cmp #TOKEN_IDENTIFIER
00:CF4D F001            	  1173:   beq pas_gc_identifier
                        	  1174: pas_get_token_eof:
00:CF4F 60              	  1175:   rts
                        	  1176: ;
                        	  1177: ;  here if get_token got an identifier
                        	  1178: ;
                        	  1179: pas_gc_identifier:
00:CF50 A951            	  1180:   lda  #<RSVWRD
00:CF52 8598            	  1181:   sta  token_work
00:CF54 A9CE            	  1182:   lda  #>RSVWRD
00:CF56 8599            	  1183:   sta  token_work+1
                        	  1184: pas_gc_loop:
00:CF58 A000            	  1185:   ldy  #0
00:CF5A B198            	  1186:   lda  (token_work),Y
00:CF5C D003            	  1187:   bne  pas_gc_more        ; MORE TO GO
00:CF5E A949            	  1188:   lda  #TOKEN_IDENTIFIER
00:CF60 60              	  1189:   rts
                        	  1190: ;
                        	  1191: ; SEARCH for RESERVED WORD
                        	  1192: ;
                        	  1193: pas_gc_more:
00:CF61 B198            	  1194:   lda  (token_work),Y     ; length of word in table
00:CF63 C592            	  1195:   cmp  token_length       ; same?
00:CF65 D022            	  1196:   bne  pas_gc_no_match    ; no - can't be it then
00:CF67 A8              	  1197:   tay                     ; length
00:CF68 A590            	  1198:   lda  token_address      ; put token start address into SRCE
00:CF6A 8500            	  1199:   sta  SRCE
00:CF6C A591            	  1200:   lda  token_address+1
00:CF6E 8501            	  1201:   sta  SRCE+1
00:CF70 A598            	  1202:   lda  token_work         ; put current token_work+2 into DEST
00:CF72 18              	  1203:   clc
00:CF73 6902            	  1204:   adc  #2
00:CF75 8503            	  1205:   sta  DEST
00:CF77 A599            	  1206:   lda  token_work+1
00:CF79 6900            	  1207:   adc  #0
00:CF7B 8504            	  1208:   sta  DEST+1
00:CF7D 200182          	  1209:   jsr  str_ic_compare
00:CF80 D007            	  1210:   bne  pas_gc_no_match      ; NOT FOUND
00:CF82 A001            	  1211:   ldy  #1
00:CF84 B198            	  1212:   lda  (token_work),Y
00:CF86 8593            	  1213:   sta  token_type
00:CF88 60              	  1214:   rts
                        	  1215: pas_gc_no_match    =  *
00:CF89 A000            	  1216:   ldy  #0
00:CF8B B198            	  1217:   lda  (token_work),Y     ; token_work points to reserved word entry
00:CF8D 18              	  1218:   clc
00:CF8E 6902            	  1219:   adc  #2         ; add 2 to bypass length and code
00:CF90 6598            	  1220:   adc  token_work
00:CF92 8598            	  1221:   sta  token_work         ; put it back
00:CF94 90C2            	  1222:   bcc  pas_gc_loop
00:CF96 E699            	  1223:   inc  token_work+1       ; handle overflow
00:CF98 80BE            	  1224:   bra  pas_gc_loop     ; try for another
                        	  1225: 
                        	  1226: 
                        	  1227: 
                        	  1228: ;***********************************************
                        	  1229: ; GET A TOKEN - CHECK THAT IT
                        	  1230: ; IS THE SAME AS IN "A", IF NOT
                        	  1231: ; CALL ERROR "X"
                        	  1232: ;***********************************************
                        	  1233: GETCHK:
00:CF9A DA              	  1234:   phx   ; save error number
00:CF9B 48              	  1235:   pha   ; save wanted token type
00:CF9C 2046CF          	  1236:   jsr pas_get_token
00:CF9F 68              	  1237:   pla   ; get it back
00:CFA0 C593            	  1238:   cmp token_type
00:CFA2 F004            	  1239:   beq CHKOK
00:CFA4 FA              	  1240:   plx   ; get error number back
                        	  1241: CHKNOK   =  *
00:CFA5 4C8397          	  1242:   jmp ERROR
                        	  1243: CHKOK    =  *
00:CFA8 FA              	  1244:   plx   ; get error number back
00:CFA9 60              	  1245:   rts
                        	  1246: 
                        	  1247: ;***********************************************
                        	  1248: ; CHECK TOKEN AGREES WITH "A",
                        	  1249: ; IF NOT, GIVE ERROR "X"
                        	  1250: ;***********************************************
                        	  1251: CHKTKN:
00:CFAA C593            	  1252:   cmp  token_type
00:CFAC D0F7            	  1253:   bne  CHKNOK
00:CFAE 60              	  1254:   rts
                        	  1255: 
                        	  1256: ;***********************************************
                        	  1257: ;
                        	  1258: ; GET NEXT TOKEN - MUST BE IDENTIFIER
                        	  1259: ; THEN LOOK IT UP IN SYMBOL TABLE
                        	  1260: ;***********************************************
                        	  1261: 
                        	  1262: GET_LOOK:
00:CFAF A949            	  1263:   lda  #TOKEN_IDENTIFIER
00:CFB1 A204            	  1264:   ldx  #4      ; ERROR: Identifier expected
00:CFB3 209ACF          	  1265:   jsr  GETCHK
00:CFB6 4C34BA          	  1266:   jmp  LOOKUP
                        	  1267: 

Source: "gpascal.asm"
                        	   188:   .include "i2c.inc"

Source: "i2c.inc"
                        	     1: ;
                        	     2: ;  I2C interface routines
                        	     3: ;
                        	     4: ; Author: Nick Gammon
                        	     5: ; Date: 2 March 2022
                        	     6: 
                        	     7: ; PROTOCOL
                        	     8: ;
                        	     9: ;  BUS NOT BUSY: Both data and clock lines remain HIGH.
                        	    10: ;
                        	    11: ;  START DATA TRANSFER: A change in the state of the data line, from HIGH to LOW, while the clock is
                        	    12: ;  HIGH, defines a START condition.
                        	    13: ;
                        	    14: ;  STOP DATA TRANSFER: A change in the state of the data line, from LOW to HIGH, while the clock line
                        	    15: ;  is HIGH, defines the STOP condition.
                        	    16: ;
                        	    17: ;  DATA VALID: The state of the data line represents valid data when, after a START condition, the data
                        	    18: ;  line is stable for the duration of the HIGH period of the clock signal. The data on the line must be
                        	    19: ;  changed during the LOW period of the clock signal. There is one clock pulse per bit of data.
                        	    20: ;  Each data transfer is initiated with a START co ndition and terminated with a STOP condition. The
                        	    21: ;  number of data bytes transferred between START and STOP conditions is not limited, and is
                        	    22: ;  determined by the master device. The information is transferred byte-wise and each receiver
                        	    23: ;  acknowledges with a ninth bit.
                        	    24: ;
                        	    25: ;  CLOCK STRETCHING
                        	    26: ;
                        	    27: ;  If a slave wants us to wait, or another master is attempting to take over the bus, SCL will not go
                        	    28: ;  high immediately after we set it to input (high impedance) so we therefore wait until SCL is in
                        	    29: ;  fact high before proceeding.
                        	    30: ;
                        	    31: ;  ARBITRATION
                        	    32: ;
                        	    33: ;  If two masters are attempting to write to the bus we can detect that as soon as one of them writes
                        	    34: ;  a one, but reads back a zero. This indicates that another master wrote the zero. The master that
                        	    35: ;  read back the one then abandons its attempt to write (to try again later).
                        	    36: ;
                        	    37: ;  Since, up to this point, both have read back what they wrote, the bus is not corrupted.
                        	    38: ;
                        	    39: 
                        	    40: 
                        	    41: ; Configuration of which VIA ports are used by SCL and SDA
                        	    42: 
                        	    43: I2C_SCL     = %00000100   ; SCL (serial clock) - PA2
                        	    44: I2C_SDA     = %00001000   ; SDA (serial data)  - PA3
                        	    45: 
                        	    46: I2C_PORT    = VIA_PORTA   ; PORT A
                        	    47: I2C_DDR     = VIA_DDRA    ; DDR  A
                        	    48: 
                        	    49: ;
                        	    50: ;  Initialise hardware for I2C comms.
                        	    51: ;
                        	    52: ;  Set SCL and SDA to high, however make the ports input for now
                        	    53: ;
                        	    54: i2c_init:
                        	    55: 
                        	    56: ;
                        	    57: ;  Set ports to low
                        	    58: ;
00:CFB9 A90C            	    59:   lda #I2C_SCL | I2C_SDA
00:CFBB 1CF17F          	    60:   trb I2C_PORT
                        	    61: 
                        	    62: ;
                        	    63: ;  Set ports to input
                        	    64: ;
                        	    65: 
00:CFBE A90C            	    66:   lda #I2C_SCL | I2C_SDA
00:CFC0 1CF37F          	    67:   trb I2C_DDR
                        	    68: 
                        	    69: 
00:CFC3 60              	    70:   rts
                        	    71: 
                        	    72: ;---------------------------------------------
                        	    73: ;  delay between clock bits - could make shorter if using a 1 MHz clock
                        	    74: ;---------------------------------------------
                        	    75: i2c_delay:
00:CFC4 EA              	    76:     nop
00:CFC5 EA              	    77:     nop
00:CFC6 EA              	    78:     nop
00:CFC7 60              	    79:     rts
                        	    80: 
                        	    81: ;---------------------------------------------
                        	    82: ;  toggle the SCL line from low to high and back again
                        	    83: ;---------------------------------------------
                        	    84: i2c_toggle_clock:
00:CFC8 A904            	    85:   lda #I2C_SCL
00:CFCA 1CF37F          	    86:   trb I2C_DDR      ; SCL high
00:CFCD 20C4CF          	    87:   jsr i2c_delay
                        	    88: ;
                        	    89: ;  check if the slave wants us to wait by pulling the clock low
                        	    90: ;
                        	    91: i2c_toggle_clock_wait:
00:CFD0 ADF17F          	    92:   lda I2C_PORT
00:CFD3 2904            	    93:   and #I2C_SCL
00:CFD5 F0F9            	    94:   beq i2c_toggle_clock_wait   ; should be high, but is low
                        	    95: ;
                        	    96: ;  we let the clock go high, and it actually IS high, so we can proceed
                        	    97: ;
00:CFD7 0CF37F          	    98:   tsb I2C_DDR       ; SCL low
00:CFDA A908            	    99:   lda #I2C_SDA      ; immediately set SDA to low
00:CFDC 1CF37F          	   100:   trb I2C_DDR
00:CFDF 20C4CF          	   101:   jsr i2c_delay
00:CFE2 60              	   102:   rts
                        	   103: 
                        	   104: ;---------------------------------------------
                        	   105: ;
                        	   106: ;  Begin transmission: send a start condition
                        	   107: ;
                        	   108: ;  Slave address in A, read/write bit in low-order bit
                        	   109: ;    0 = write, 1 = read
                        	   110: ;
                        	   111: ;  Sets carry if OK
                        	   112: ;
                        	   113: ;  START CONDITION:
                        	   114: ;
                        	   115: ;  A change in the state of the data line, from HIGH to LOW, while the clock is HIGH
                        	   116: ;---------------------------------------------
                        	   117: 
                        	   118: i2c_begin_transmission:
                        	   119: 
00:CFE3 48              	   120:   pha             ; save address
                        	   121: 
00:CFE4 20B9CF          	   122:   jsr i2c_init    ; set ports to low, and ports to input
                        	   123: 
                        	   124: ;
                        	   125: ;  Check if SDA or SCL are in use (low) - if so, wait until they are not
                        	   126: ;
                        	   127: i2c_begin_transmission_loop:
00:CFE7 A908            	   128:   lda #I2C_SDA
00:CFE9 2DF17F          	   129:   and I2C_PORT
00:CFEC F0F9            	   130:   beq i2c_begin_transmission_loop
00:CFEE A904            	   131:   lda #I2C_SCL
00:CFF0 2DF17F          	   132:   and I2C_PORT
00:CFF3 F0F2            	   133:   beq i2c_begin_transmission_loop
                        	   134: 
                        	   135: ;
                        	   136: ;  The start condition pulls SDA low but SCL stays high
                        	   137: ;
                        	   138: 
00:CFF5 A908            	   139:   lda #I2C_SDA
00:CFF7 0CF37F          	   140:   tsb I2C_DDR
00:CFFA 20C4CF          	   141:   jsr i2c_delay
                        	   142: 
                        	   143: ;
                        	   144: ;  But now we pull SCL low ready for clocking out bits
                        	   145: ;
                        	   146: 
00:CFFD A904            	   147:   lda #I2C_SCL
00:CFFF 0CF37F          	   148:   tsb I2C_DDR
00:D002 20C4CF          	   149:   jsr i2c_delay
                        	   150: 
00:D005 68              	   151:   pla   ; get address back
                        	   152: 
00:D006 200AD0          	   153:   jsr i2c_write
                        	   154: 
00:D009 60              	   155:   rts
                        	   156: 
                        	   157: ;---------------------------------------------
                        	   158: ;
                        	   159: ;  I2C write: send 8 data bits, wait for acknowledge
                        	   160: ;
                        	   161: ;---------------------------------------------
                        	   162: 
                        	   163: i2c_write:
00:D00A A208            	   164:   ldx #8  ; count of bits
00:D00C A8              	   165:   tay
                        	   166: 
                        	   167: i2c_write_loop:
00:D00D 98              	   168:   tya
00:D00E 2A              	   169:   rol a   ; get bit to write into carry
00:D00F A8              	   170:   tay
                        	   171: 
00:D010 B007            	   172:   bcs i2c_write_one
                        	   173: ;
                        	   174: ;  write a zero by setting SDA to output
                        	   175: ;
00:D012 A908            	   176:   lda #I2C_SDA
00:D014 0CF37F          	   177:   tsb I2C_DDR
00:D017 800B            	   178:   bra i2c_write_clock
                        	   179: ;
                        	   180: ;  write a one by setting SDA to input
                        	   181: ;
                        	   182: i2c_write_one:
00:D019 A908            	   183:   lda #I2C_SDA
00:D01B 1CF37F          	   184:   trb I2C_DDR
                        	   185: ;
                        	   186: ;  if SDA is not high, another master has taken control of the bus, abandon this write
                        	   187: ;
00:D01E EA              	   188:   nop
00:D01F 2DF17F          	   189:   and I2C_PORT
00:D022 F028            	   190:   beq i2c_write_lost_arbitration   ; error return, give up
                        	   191: 
                        	   192: ;---------------------------------------------
                        	   193: ;
                        	   194: ;  toggle clock
                        	   195: ;
                        	   196: ;---------------------------------------------
                        	   197: i2c_write_clock:
00:D024 20C8CF          	   198:   jsr i2c_toggle_clock
                        	   199: ;
                        	   200: ;  back for another bit?
                        	   201: ;
00:D027 CA              	   202:   dex
00:D028 D0E3            	   203:   bne i2c_write_loop
                        	   204: 
                        	   205:   ;---------------------------------------------
                        	   206:   ;  wait for acknowledge bit
                        	   207:   ;---------------------------------------------
                        	   208: 
                        	   209:   ;
                        	   210:   ;  make SDA input and see if it is pulled low
                        	   211:   ;
                        	   212: 
00:D02A A908            	   213:   lda #I2C_SDA
00:D02C 1CF37F          	   214:   trb I2C_DDR         ; SDA to input
                        	   215: 
00:D02F A904            	   216:   lda #I2C_SCL        ; clock high
00:D031 1CF37F          	   217:   trb I2C_DDR
                        	   218: 
                        	   219: ;
                        	   220: ;  check if the slave wants us to wait by pulling the clock low
                        	   221: ;
                        	   222: i2c_write_clock_wait:
00:D034 ADF17F          	   223:   lda I2C_PORT
00:D037 2904            	   224:   and #I2C_SCL
00:D039 F0F9            	   225:   beq i2c_write_clock_wait   ; should be high, but is low
                        	   226: 
00:D03B 20C4CF          	   227:   jsr i2c_delay       ; give it time to respond
                        	   228: 
00:D03E A908            	   229:   lda #I2C_SDA
00:D040 2DF17F          	   230:   and I2C_PORT        ; read SDA
                        	   231: 
00:D043 AA              	   232:   tax                 ; save result for a moment
00:D044 A904            	   233:   lda #I2C_SCL        ; clock low
00:D046 0CF37F          	   234:   tsb I2C_DDR
                        	   235: 
00:D049 8A              	   236:   txa             ; get ack/nak bit back
                        	   237: 
00:D04A F002            	   238:   beq i2c_write_got_ack
                        	   239: 
                        	   240: i2c_write_lost_arbitration:
00:D04C 18              	   241:   clc   ; error return
00:D04D 60              	   242:   rts
                        	   243: 
                        	   244: i2c_write_got_ack:
00:D04E 38              	   245:   sec   ; carry means OK
00:D04F 60              	   246:   rts
                        	   247: 
                        	   248: 
                        	   249: ;---------------------------------------------
                        	   250: ;
                        	   251: ;  I2C read: receive 8 data bits, then acknowledge unless hardware_work is zero
                        	   252: ;    hardware_work will be the count of outstanding bytes to be sent
                        	   253: ;    on the last bit we NAK it to tell the sender not to send any more
                        	   254: ;
                        	   255: ;---------------------------------------------
                        	   256: 
                        	   257: i2c_read:
00:D050 A208            	   258:   ldx #8  ; count of bits
00:D052 A000            	   259:   ldy #0  ; current result
                        	   260: 
00:D054 A908            	   261:   lda #I2C_SDA
00:D056 1CF37F          	   262:   trb I2C_DDR         ; SDA to input
                        	   263: 
                        	   264: i2c_read_loop:
                        	   265: 
00:D059 A904            	   266:   lda #I2C_SCL        ; clock high
00:D05B 1CF37F          	   267:   trb I2C_DDR
00:D05E 20C4CF          	   268:   jsr i2c_delay       ; give it time to respond
                        	   269: 
00:D061 A908            	   270:   lda #I2C_SDA
00:D063 2DF17F          	   271:   and I2C_PORT        ; read SDA
00:D066 F006            	   272:   beq i2c_read_zero
                        	   273: ;
                        	   274: ;  read a 1
                        	   275: ;
00:D068 98              	   276:   tya       ; get previous result
00:D069 38              	   277:   sec
00:D06A 2A              	   278:   rol a     ; rotate in a one-bit
00:D06B A8              	   279:   tay       ; keep for later
00:D06C 8004            	   280:   bra i2c_read_next
                        	   281: 
                        	   282: ;
                        	   283: ;  read a 0
                        	   284: ;
                        	   285: i2c_read_zero:
00:D06E 98              	   286:   tya       ; get previous result
00:D06F 18              	   287:   clc
00:D070 2A              	   288:   rol a     ; rotate in a zero-bit
00:D071 A8              	   289:   tay       ; keep for later
                        	   290: 
                        	   291: i2c_read_next:
                        	   292: 
00:D072 A904            	   293:   lda #I2C_SCL        ; clock low
00:D074 0CF37F          	   294:   tsb I2C_DDR
00:D077 20C4CF          	   295:   jsr i2c_delay       ; give it time to respond
                        	   296: 
                        	   297: ;
                        	   298: ;  back for another bit?
                        	   299: ;
00:D07A CA              	   300:   dex
00:D07B D0DC            	   301:   bne i2c_read_loop
                        	   302: 
00:D07D A58C            	   303:   lda hardware_work   ; NAK on last read so they stop sending
00:D07F F007            	   304:   beq i2c_read_nak
                        	   305: 
00:D081 A908            	   306:   lda #I2C_SDA
00:D083 0CF37F          	   307:   tsb I2C_DDR         ; pull SDA low to ACK the byte
00:D086 8005            	   308:   bra i2c_read_ack_or_nak
                        	   309: 
                        	   310: i2c_read_nak:
00:D088 A908            	   311:   lda #I2C_SDA
00:D08A 1CF37F          	   312:   trb I2C_DDR         ; pull SDA high to NAK the final byte
                        	   313: 
                        	   314: i2c_read_ack_or_nak:
                        	   315: 
00:D08D A904            	   316:   lda #I2C_SCL        ; clock high
00:D08F 1CF37F          	   317:   trb I2C_DDR
                        	   318: 
                        	   319: ;
                        	   320: ;  check if the slave wants us to wait by pulling the clock low
                        	   321: ;   (clock stretching)
                        	   322: ;
                        	   323: 
                        	   324: i2c_read_ack_or_nak_wait:
00:D092 ADF17F          	   325:   lda I2C_PORT
00:D095 2904            	   326:   and #I2C_SCL
00:D097 F0F9            	   327:   beq i2c_read_ack_or_nak_wait   ; should be high, but is low
                        	   328: 
00:D099 20C4CF          	   329:   jsr i2c_delay       ; give it time to respond
                        	   330: 
00:D09C A904            	   331:   lda #I2C_SCL        ; clock low
00:D09E 0CF37F          	   332:   tsb I2C_DDR
00:D0A1 20C4CF          	   333:   jsr i2c_delay
                        	   334: 
                        	   335: i2c_read_done:
                        	   336: 
00:D0A4 98              	   337:   tya                 ; result in A
00:D0A5 60              	   338:   rts
                        	   339: 
                        	   340: 
                        	   341: ;---------------------------------------------
                        	   342: ;  end transmission - send stop condition
                        	   343: ;
                        	   344: ;  STOP CONDITION:
                        	   345: ;
                        	   346: ;  A change in the state of the data line, from LOW to HIGH, while the clock is HIGH
                        	   347: ;---------------------------------------------
                        	   348: 
                        	   349: i2c_end_transmission:
                        	   350: 
                        	   351: ;
                        	   352: ;  make sure SDA is low, otherwise it can't transition low to high
                        	   353: ;
00:D0A6 A908            	   354:   lda #I2C_SDA
00:D0A8 0CF37F          	   355:   tsb I2C_DDR
                        	   356: 
00:D0AB 20C4CF          	   357:   jsr i2c_delay
                        	   358: 
                        	   359: ;
                        	   360: ;  Set SCL to input so it floats high
                        	   361: ;
00:D0AE A904            	   362:   lda #I2C_SCL
00:D0B0 1CF37F          	   363:   trb I2C_DDR
                        	   364: 
00:D0B3 20C4CF          	   365:   jsr i2c_delay
                        	   366: 
                        	   367: ;
                        	   368: ;  Now with SCL high, set SDA to input so it also floats high
                        	   369: ;
00:D0B6 A908            	   370:   lda #I2C_SDA
00:D0B8 1CF37F          	   371:   trb I2C_DDR
                        	   372: 
00:D0BB 20C4CF          	   373:   jsr i2c_delay
                        	   374: 
                        	   375: ;
                        	   376: ;  Both SDA and SCL are now high (by the pull-up resistors) so we are done
                        	   377: ;
00:D0BE 60              	   378:   rts
                        	   379: 
                        	   380: ;---------------------------------------------
                        	   381: ;
                        	   382: ;  Send a message, address in A (excluding write bit)
                        	   383: ;  Message in (VALUE)
                        	   384: ;  Length in Y
                        	   385: ;  Returns carry set on success, carry clear on failure
                        	   386: ;
                        	   387: ;---------------------------------------------
                        	   388: i2c_send:
00:D0BF 848C            	   389:   sty hardware_work
00:D0C1 0A              	   390:   asl A     ; move zero into write bit
00:D0C2 20E3CF          	   391:   jsr i2c_begin_transmission
00:D0C5 901C            	   392:   bcc i2c_send_fail
                        	   393: 
                        	   394: ;
                        	   395: ;  send each byte
                        	   396: ;
                        	   397: i2c_send_loop:
00:D0C7 A58C            	   398:   lda hardware_work           ; number of bytes to go
00:D0C9 F013            	   399:   beq i2c_send_done
00:D0CB C68C            	   400:   dec hardware_work
00:D0CD A000            	   401:   ldy #0
00:D0CF B100            	   402:   lda (VALUE),Y
00:D0D1 200AD0          	   403:   jsr i2c_write
00:D0D4 900D            	   404:   bcc i2c_send_fail
00:D0D6 E600            	   405:   inc VALUE
00:D0D8 D0ED            	   406:   bne i2c_send_loop
00:D0DA E601            	   407:   inc VALUE+1
00:D0DC 80E9            	   408:   bra i2c_send_loop
                        	   409: ;
                        	   410: ;  sending done
                        	   411: ;
                        	   412: i2c_send_done:
00:D0DE 20A6D0          	   413:   jsr i2c_end_transmission
00:D0E1 38              	   414:   sec
00:D0E2 60              	   415:   rts
                        	   416: ;
                        	   417: ;  sending failure
                        	   418: ;
                        	   419: i2c_send_fail:
00:D0E3 20A6D0          	   420:   jsr i2c_end_transmission
00:D0E6 18              	   421:   clc
00:D0E7 60              	   422:   rts
                        	   423: 
                        	   424: ;---------------------------------------------
                        	   425: ;
                        	   426: ;  Receive messave, slave address in A (excluding write bit)
                        	   427: ;  Message in (VALUE)
                        	   428: ;  Length in Y
                        	   429: ;---------------------------------------------
                        	   430: 
                        	   431: i2c_receive:
00:D0E8 848C            	   432:   sty hardware_work
00:D0EA 38              	   433:   sec
00:D0EB 2A              	   434:   rol A   ; move one into write bit (so it is read mode)
00:D0EC 20E3CF          	   435:   jsr i2c_begin_transmission
00:D0EF 901F            	   436:   bcc i2c_receive_fail
                        	   437: 
                        	   438: ;
                        	   439: ;  put serial data (SDA) into input mode so we can read from it
                        	   440: ;
00:D0F1 A908            	   441:   lda #I2C_SDA
00:D0F3 1CF37F          	   442:   trb I2C_DDR
                        	   443: 
                        	   444: ;
                        	   445: ;  receive each byte
                        	   446: ;
                        	   447: i2c_receive_loop:
00:D0F6 A58C            	   448:   lda hardware_work           ; number of bytes to go
00:D0F8 F011            	   449:   beq i2c_receive_done
00:D0FA C68C            	   450:   dec hardware_work
00:D0FC 2050D0          	   451:   jsr i2c_read
00:D0FF A000            	   452:   ldy #0
00:D101 9100            	   453:   sta (VALUE),Y
00:D103 E600            	   454:   inc VALUE
00:D105 D0EF            	   455:   bne i2c_receive_loop
00:D107 E601            	   456:   inc VALUE+1
00:D109 80EB            	   457:   bra i2c_receive_loop
                        	   458: ;
                        	   459: ;  receiving done
                        	   460: ;
                        	   461: i2c_receive_done:
00:D10B 20A6D0          	   462:   jsr i2c_end_transmission
00:D10E 38              	   463:   sec
00:D10F 60              	   464:   rts
                        	   465: ;
                        	   466: ;  receiving failure
                        	   467: ;
                        	   468: i2c_receive_fail:
00:D110 20A6D0          	   469:   jsr i2c_end_transmission
00:D113 18              	   470:   clc
00:D114 60              	   471:   rts
                        	   472: 
                        	   473: 

Source: "gpascal.asm"
                        	   189:   .include "spi.inc"

Source: "spi.inc"
                        	     1: ;
                        	     2: ;  SPI interface routines
                        	     3: ;
                        	     4: ; Author: Nick Gammon
                        	     5: ; Date: 6 March 2022
                        	     6: ;
                        	     7: 
                        	     8: ; Configuration of which VIA ports are used by SS, MOSI, MISO, SCK
                        	     9: 
                        	    10: SPI_SS    = %00000001   ; SS   (slave select) - PB0
                        	    11: SPI_MOSI  = %00000010   ; MOSI (master out, slave in) - PB1
                        	    12: SPI_MISO  = %00000100   ; MISO (master in, slave out) - PB2
                        	    13: SPI_SCK   = %00001000   ; SCK  (serial clock) - PB3
                        	    14: 
                        	    15: SPI_PORT    = VIA_PORTB   ; PORT B
                        	    16: SPI_DDR     = VIA_DDRB    ; DDR  B
                        	    17: 
                        	    18: ;---------------------------------------------
                        	    19: ;  Initialise hardware for SPI comms.
                        	    20: ;
                        	    21: ;  SPI mode in A, as follows:
                        	    22: 
                        	    23: ;   Mode 0 - clock is normally low,  the data is sampled on the transition from low to high (leading edge)
                        	    24: ;   Mode 1 - clock is normally low,  the data is sampled on the transition from high to low (trailing edge)
                        	    25: ;   Mode 2 - clock is normally high, the data is sampled on the transition from high to low (leading edge)
                        	    26: ;   Mode 3 - clock is normally high, the data is sampled on the transition from low to high (trailing edge)
                        	    27: ;
                        	    28: ;  Set SS, MOSI and SCK to outputs. Set MISO to input.
                        	    29: ;---------------------------------------------
                        	    30: spi_init:
                        	    31: 
00:D115 8568            	    32:   sta spi_mode
                        	    33: 
                        	    34: ;
                        	    35: ;  Set MISO to input
                        	    36: ;
                        	    37: 
00:D117 A904            	    38:   lda #SPI_MISO
00:D119 1CF27F          	    39:   trb SPI_DDR
                        	    40: 
                        	    41: ;
                        	    42: ;  Set SS to high (it is active low)
                        	    43: ;
00:D11C A901            	    44:   lda #SPI_SS
00:D11E 0CF07F          	    45:   tsb SPI_PORT
                        	    46: 
                        	    47: ;
                        	    48: ; In modes 0 and 1, the clock is normally low
                        	    49: ;
00:D121 A568            	    50:   lda spi_mode
00:D123 2902            	    51:   and #2
00:D125 D007            	    52:   bne spi_init_clock_high
                        	    53: 
00:D127 A908            	    54:   lda #SPI_SCK
00:D129 1CF07F          	    55:   trb SPI_PORT
00:D12C 8005            	    56:   bra spi_init2
                        	    57: 
                        	    58: ;
                        	    59: ; In modes 2 and 3, the clock is normally high
                        	    60: ;
                        	    61: spi_init_clock_high:
00:D12E A908            	    62:   lda #SPI_SCK
00:D130 0CF07F          	    63:   tsb SPI_PORT
                        	    64: ;
                        	    65: ;  Now set up MOSI
                        	    66: ;
                        	    67: 
                        	    68: spi_init2:
                        	    69: 
00:D133 A568            	    70:   lda spi_mode
00:D135 2901            	    71:   and #1
00:D137 D007            	    72:   bne spi_init_mosi_low
                        	    73: 
                        	    74: ;
                        	    75: ;  In modes 0 and 2, MOSI idles high
                        	    76: ;
00:D139 A902            	    77:   lda #SPI_MOSI
00:D13B 0CF07F          	    78:   tsb SPI_PORT
00:D13E 8005            	    79:   bra spi_init3
                        	    80: 
                        	    81: ;
                        	    82: ;  In modes 1 and 3, MOSI idles low
                        	    83: ;
                        	    84: 
                        	    85: spi_init_mosi_low:
00:D140 A902            	    86:   lda #SPI_MOSI
00:D142 1CF07F          	    87:   trb SPI_PORT
                        	    88: 
                        	    89: ;
                        	    90: ;   Set SS, MOSI and SCK to outputs
                        	    91: ;
                        	    92: 
                        	    93: spi_init3:
00:D145 A90B            	    94:   lda #SPI_SS | SPI_MOSI | SPI_SCK
00:D147 0CF27F          	    95:   tsb SPI_DDR
                        	    96: 
00:D14A 60              	    97:   rts
                        	    98: 
                        	    99: ;---------------------------------------------
                        	   100: ;  Transfer one byte.
                        	   101: ;    Byte to be sent in A.
                        	   102: ;    Returns received byte in A.
                        	   103: ;    Preserves X and Y
                        	   104: ;
                        	   105: ;   Mode 0 - clock is normally low,  the data is sampled on the transition from low to high (leading edge)
                        	   106: ;   Mode 1 - clock is normally low,  the data is sampled on the transition from high to low (trailing edge)
                        	   107: ;   Mode 2 - clock is normally high, the data is sampled on the transition from high to low (leading edge)
                        	   108: ;   Mode 3 - clock is normally high, the data is sampled on the transition from low to high (trailing edge)
                        	   109: ;---------------------------------------------
                        	   110: 
                        	   111: spi_transfer:
00:D14B DA              	   112:   phx
00:D14C 5A              	   113:   phy
00:D14D A208            	   114:   ldx  #8               ; count of bits
00:D14F A8              	   115:   tay                   ; save the byte we are sending
                        	   116: spi_transfer_loop:
00:D150 98              	   117:   tya                   ; get the byte we are sending back
                        	   118: ;
                        	   119: ;  set up MOSI, ready to be sampled on the clock transition
                        	   120: ;
00:D151 2A              	   121:   rol A                 ; get MSB into carry
00:D152 A8              	   122:   tay                   ; save the byte which we shifted left
00:D153 9007            	   123:   bcc spi_send_zero     ; if no carry, we are sending a zero
                        	   124: 
                        	   125: ;
                        	   126: ; here to send a one bit
                        	   127: ;
00:D155 A902            	   128:   lda #SPI_MOSI
00:D157 0CF07F          	   129:   tsb SPI_PORT    ; set MOSI to high
00:D15A 8005            	   130:   bra spi_send_clock_pulse_1
                        	   131: 
                        	   132: ;
                        	   133: ; here to send a zero bit
                        	   134: ;
                        	   135: spi_send_zero:
00:D15C A902            	   136:   lda #SPI_MOSI
00:D15E 1CF07F          	   137:   trb SPI_PORT    ; set MOSI to low
                        	   138: 
                        	   139: ;
                        	   140: ; transition clock
                        	   141: ;
                        	   142: spi_send_clock_pulse_1:
                        	   143: 
                        	   144: ;
                        	   145: ; In modes 0 and 1, the clock is normally low, so we need to make it high
                        	   146: ;
00:D161 A568            	   147:   lda spi_mode
00:D163 2902            	   148:   and #2
00:D165 D007            	   149:   bne spi_send_clock_high_low
                        	   150: 
                        	   151: ;
                        	   152: ; Make SCK high
                        	   153: ;
00:D167 A908            	   154:   lda #SPI_SCK
00:D169 0CF07F          	   155:   tsb SPI_PORT
00:D16C 8005            	   156:   bra spi_send2
                        	   157: 
                        	   158: ;
                        	   159: ; Otherwise we need to make it low
                        	   160: ;
                        	   161: spi_send_clock_high_low:
                        	   162: ;
                        	   163: ;  Make SCK low
                        	   164: ;
00:D16E A908            	   165:   lda #SPI_SCK
00:D170 1CF07F          	   166:   trb SPI_PORT
                        	   167: 
                        	   168: ;
                        	   169: ;  We have done the leading edge of SCK
                        	   170: ;
                        	   171: spi_send2:
                        	   172: 
                        	   173: ;
                        	   174: ;  In modes 1 and 3 we sample on the trailing edge, so do nothing here
                        	   175: ;
00:D173 A568            	   176:   lda spi_mode
00:D175 2901            	   177:   and #1
00:D177 D00B            	   178:   bne spi_send3
                        	   179: 
                        	   180: ;
                        	   181: ;  sample incoming data on leading edge
                        	   182: ;
00:D179 18              	   183:   clc
00:D17A A904            	   184:   lda #SPI_MISO
00:D17C 2DF07F          	   185:   and SPI_PORT
00:D17F F001            	   186:   beq spi_read_02_done
00:D181 38              	   187:   sec
                        	   188: spi_read_02_done:
00:D182 268C            	   189:   rol hardware_work   ; rotate in zero or one from carry
                        	   190: 
                        	   191: spi_send3:
                        	   192: 
                        	   193: ;
                        	   194: ;  transition clock again to give the trailing edge
                        	   195: ;
                        	   196: 
                        	   197: ;
                        	   198: ; In modes 0 and 1, the clock is normally low, so we need to make it low again
                        	   199: ;
00:D184 A568            	   200:   lda spi_mode
00:D186 2902            	   201:   and #2
00:D188 D007            	   202:   bne spi_send_clock_low_high
                        	   203: 
00:D18A A908            	   204:   lda #SPI_SCK
00:D18C 1CF07F          	   205:   trb SPI_PORT
00:D18F 8005            	   206:   bra spi_send4
                        	   207: 
                        	   208: spi_send_clock_low_high:
00:D191 A908            	   209:   lda #SPI_SCK
00:D193 0CF07F          	   210:   tsb SPI_PORT
                        	   211: 
                        	   212: spi_send4:
                        	   213: 
                        	   214: ;
                        	   215: ;  In modes 1 and 3 we sample on the trailing edge
                        	   216: ;
00:D196 A568            	   217:   lda spi_mode
00:D198 2901            	   218:   and #1
00:D19A F00B            	   219:   beq spi_send_bit_done
                        	   220: 
                        	   221: ;
                        	   222: ;  sample incoming data on trailing edge
                        	   223: ;
00:D19C 18              	   224:   clc
00:D19D A904            	   225:   lda #SPI_MISO
00:D19F 2DF07F          	   226:   and SPI_PORT
00:D1A2 F001            	   227:   beq spi_read_13_done
00:D1A4 38              	   228:   sec
                        	   229: spi_read_13_done:
00:D1A5 268C            	   230:   rol hardware_work   ; rotate in zero or one from carry
                        	   231: 
                        	   232: spi_send_bit_done:
00:D1A7 CA              	   233:   dex
00:D1A8 D0A6            	   234:   bne spi_transfer_loop
                        	   235: 
                        	   236: ;
                        	   237: ;  get incoming byte back into A
                        	   238: ;
00:D1AA 7A              	   239:   ply
00:D1AB FA              	   240:   plx
00:D1AC A58C            	   241:   lda hardware_work
00:D1AE 60              	   242:   rts
                        	   243: 
                        	   244: 
                        	   245: ;---------------------------------------------
                        	   246: ; Select the slave (send SS low) - preserves all registers
                        	   247: ;---------------------------------------------
                        	   248: spi_ss_low:
00:D1AF 48              	   249:   pha
00:D1B0 A901            	   250:   lda #SPI_SS
00:D1B2 1CF07F          	   251:   trb SPI_PORT
00:D1B5 68              	   252:   pla
00:D1B6 60              	   253:   rts
                        	   254: 
                        	   255: ;---------------------------------------------
                        	   256: ; Deselect the slave (send SS high) - preserves all registers
                        	   257: ;---------------------------------------------
                        	   258: spi_ss_high:
00:D1B7 48              	   259:   pha
00:D1B8 A901            	   260:   lda #SPI_SS
00:D1BA 0CF07F          	   261:   tsb SPI_PORT
00:D1BD 68              	   262:   pla
00:D1BE 60              	   263:   rts
                        	   264: 
                        	   265: ;---------------------------------------------
                        	   266: ;  send two bytes: first in A, second in X
                        	   267: ;   preserves all registers
                        	   268: ;---------------------------------------------
                        	   269: spi_send_two_bytes:
00:D1BF 48              	   270:   pha
00:D1C0 20AFD1          	   271:   jsr spi_ss_low    ; SS low
00:D1C3 204BD1          	   272:   jsr spi_transfer  ; send first byte
00:D1C6 8A              	   273:   txa               ; get second byte
00:D1C7 204BD1          	   274:   jsr spi_transfer  ; send second byte
00:D1CA 20B7D1          	   275:   jsr spi_ss_high   ; SS high again
00:D1CD 68              	   276:   pla
00:D1CE 60              	   277:   rts
                        	   278: 
                        	   279: 

Source: "gpascal.asm"
                        	   190: 
                        	   191:   .if USE_CP437_FONT
                        	   192:     .include "cp437_font.inc"

Source: "cp437_font.inc"
                        	     1: ; bit patterns for the CP437 font
                        	     2: 
                        	     3: cp437_font:
                        	     4: 
00:D1CF 00              	     5:   dfb $00,$00,$00,$00,$00,$00,$00,$00 ; $00
00:D1D0 00
00:D1D1 00
00:D1D2 00
00:D1D3 00
00:D1D4 00
00:D1D5 00
00:D1D6 00
00:D1D7 7E              	     6:   dfb $7E,$81,$A5,$81,$BD,$99,$81,$7E ; $01
00:D1D8 81
00:D1D9 A5
00:D1DA 81
00:D1DB BD
00:D1DC 99
00:D1DD 81
00:D1DE 7E
00:D1DF 7E              	     7:   dfb $7E,$FF,$DB,$FF,$C3,$E7,$FF,$7E ; $02
00:D1E0 FF
00:D1E1 DB
00:D1E2 FF
00:D1E3 C3
00:D1E4 E7
00:D1E5 FF
00:D1E6 7E
00:D1E7 6C              	     8:   dfb $6C,$FE,$FE,$FE,$7C,$38,$10,$00 ; $03
00:D1E8 FE
00:D1E9 FE
00:D1EA FE
00:D1EB 7C
00:D1EC 38
00:D1ED 10
00:D1EE 00
00:D1EF 10              	     9:   dfb $10,$38,$7C,$FE,$7C,$38,$10,$00 ; $04
00:D1F0 38
00:D1F1 7C
00:D1F2 FE
00:D1F3 7C
00:D1F4 38
00:D1F5 10
00:D1F6 00
00:D1F7 38              	    10:   dfb $38,$7C,$38,$FE,$FE,$7C,$38,$7C ; $05
00:D1F8 7C
00:D1F9 38
00:D1FA FE
00:D1FB FE
00:D1FC 7C
00:D1FD 38
00:D1FE 7C
00:D1FF 10              	    11:   dfb $10,$10,$38,$7C,$FE,$7C,$38,$7C ; $06
00:D200 10
00:D201 38
00:D202 7C
00:D203 FE
00:D204 7C
00:D205 38
00:D206 7C
00:D207 00              	    12:   dfb $00,$00,$18,$3C,$3C,$18,$00,$00 ; $07
00:D208 00
00:D209 18
00:D20A 3C
00:D20B 3C
00:D20C 18
00:D20D 00
00:D20E 00
00:D20F FF              	    13:   dfb $FF,$FF,$E7,$C3,$C3,$E7,$FF,$FF ; $08
00:D210 FF
00:D211 E7
00:D212 C3
00:D213 C3
00:D214 E7
00:D215 FF
00:D216 FF
00:D217 00              	    14:   dfb $00,$3C,$66,$42,$42,$66,$3C,$00 ; $09
00:D218 3C
00:D219 66
00:D21A 42
00:D21B 42
00:D21C 66
00:D21D 3C
00:D21E 00
00:D21F FF              	    15:   dfb $FF,$C3,$99,$BD,$BD,$99,$C3,$FF ; $0A
00:D220 C3
00:D221 99
00:D222 BD
00:D223 BD
00:D224 99
00:D225 C3
00:D226 FF
00:D227 0F              	    16:   dfb $0F,$07,$0F,$7D,$CC,$CC,$CC,$78 ; $0B
00:D228 07
00:D229 0F
00:D22A 7D
00:D22B CC
00:D22C CC
00:D22D CC
00:D22E 78
00:D22F 3C              	    17:   dfb $3C,$66,$66,$66,$3C,$18,$7E,$18 ; $0C
00:D230 66
00:D231 66
00:D232 66
00:D233 3C
00:D234 18
00:D235 7E
00:D236 18
00:D237 3F              	    18:   dfb $3F,$33,$3F,$30,$30,$70,$F0,$E0 ; $0D
00:D238 33
00:D239 3F
00:D23A 30
00:D23B 30
00:D23C 70
00:D23D F0
00:D23E E0
00:D23F 7F              	    19:   dfb $7F,$63,$7F,$63,$63,$67,$E6,$C0 ; $0E
00:D240 63
00:D241 7F
00:D242 63
00:D243 63
00:D244 67
00:D245 E6
00:D246 C0
00:D247 99              	    20:   dfb $99,$5A,$3C,$E7,$E7,$3C,$5A,$99 ; $0F
00:D248 5A
00:D249 3C
00:D24A E7
00:D24B E7
00:D24C 3C
00:D24D 5A
00:D24E 99
00:D24F 80              	    21:   dfb $80,$E0,$F8,$FE,$F8,$E0,$80,$00 ; $10
00:D250 E0
00:D251 F8
00:D252 FE
00:D253 F8
00:D254 E0
00:D255 80
00:D256 00
00:D257 02              	    22:   dfb $02,$0E,$3E,$FE,$3E,$0E,$02,$00 ; $11
00:D258 0E
00:D259 3E
00:D25A FE
00:D25B 3E
00:D25C 0E
00:D25D 02
00:D25E 00
00:D25F 18              	    23:   dfb $18,$3C,$7E,$18,$18,$7E,$3C,$18 ; $12
00:D260 3C
00:D261 7E
00:D262 18
00:D263 18
00:D264 7E
00:D265 3C
00:D266 18
00:D267 66              	    24:   dfb $66,$66,$66,$66,$66,$00,$66,$00 ; $13
00:D268 66
00:D269 66
00:D26A 66
00:D26B 66
00:D26C 00
00:D26D 66
00:D26E 00
00:D26F 7F              	    25:   dfb $7F,$DB,$DB,$7B,$1B,$1B,$1B,$00 ; $14
00:D270 DB
00:D271 DB
00:D272 7B
00:D273 1B
00:D274 1B
00:D275 1B
00:D276 00
00:D277 3E              	    26:   dfb $3E,$63,$38,$6C,$6C,$38,$CC,$78 ; $15
00:D278 63
00:D279 38
00:D27A 6C
00:D27B 6C
00:D27C 38
00:D27D CC
00:D27E 78
00:D27F 00              	    27:   dfb $00,$00,$00,$00,$7E,$7E,$7E,$00 ; $16
00:D280 00
00:D281 00
00:D282 00
00:D283 7E
00:D284 7E
00:D285 7E
00:D286 00
00:D287 18              	    28:   dfb $18,$3C,$7E,$18,$7E,$3C,$18,$FF ; $17
00:D288 3C
00:D289 7E
00:D28A 18
00:D28B 7E
00:D28C 3C
00:D28D 18
00:D28E FF
00:D28F 18              	    29:   dfb $18,$3C,$7E,$18,$18,$18,$18,$00 ; $18
00:D290 3C
00:D291 7E
00:D292 18
00:D293 18
00:D294 18
00:D295 18
00:D296 00
00:D297 18              	    30:   dfb $18,$18,$18,$18,$7E,$3C,$18,$00 ; $19
00:D298 18
00:D299 18
00:D29A 18
00:D29B 7E
00:D29C 3C
00:D29D 18
00:D29E 00
00:D29F 00              	    31:   dfb $00,$18,$0C,$FE,$0C,$18,$00,$00 ; $1A
00:D2A0 18
00:D2A1 0C
00:D2A2 FE
00:D2A3 0C
00:D2A4 18
00:D2A5 00
00:D2A6 00
00:D2A7 00              	    32:   dfb $00,$30,$60,$FE,$60,$30,$00,$00 ; $1B
00:D2A8 30
00:D2A9 60
00:D2AA FE
00:D2AB 60
00:D2AC 30
00:D2AD 00
00:D2AE 00
00:D2AF 00              	    33:   dfb $00,$00,$C0,$C0,$C0,$FE,$00,$00 ; $1C
00:D2B0 00
00:D2B1 C0
00:D2B2 C0
00:D2B3 C0
00:D2B4 FE
00:D2B5 00
00:D2B6 00
00:D2B7 00              	    34:   dfb $00,$24,$66,$FF,$66,$24,$00,$00 ; $1D
00:D2B8 24
00:D2B9 66
00:D2BA FF
00:D2BB 66
00:D2BC 24
00:D2BD 00
00:D2BE 00
00:D2BF 00              	    35:   dfb $00,$18,$3C,$7E,$FF,$FF,$00,$00 ; $1E
00:D2C0 18
00:D2C1 3C
00:D2C2 7E
00:D2C3 FF
00:D2C4 FF
00:D2C5 00
00:D2C6 00
00:D2C7 00              	    36:   dfb $00,$FF,$FF,$7E,$3C,$18,$00,$00 ; $1F
00:D2C8 FF
00:D2C9 FF
00:D2CA 7E
00:D2CB 3C
00:D2CC 18
00:D2CD 00
00:D2CE 00
00:D2CF 00              	    37:   dfb $00,$00,$00,$00,$00,$00,$00,$00 ; ' '
00:D2D0 00
00:D2D1 00
00:D2D2 00
00:D2D3 00
00:D2D4 00
00:D2D5 00
00:D2D6 00
00:D2D7 30              	    38:   dfb $30,$78,$78,$30,$30,$00,$30,$00 ; '!'
00:D2D8 78
00:D2D9 78
00:D2DA 30
00:D2DB 30
00:D2DC 00
00:D2DD 30
00:D2DE 00
00:D2DF 6C              	    39:   dfb $6C,$6C,$6C,$00,$00,$00,$00,$00 ; '"'
00:D2E0 6C
00:D2E1 6C
00:D2E2 00
00:D2E3 00
00:D2E4 00
00:D2E5 00
00:D2E6 00
00:D2E7 6C              	    40:   dfb $6C,$6C,$FE,$6C,$FE,$6C,$6C,$00 ; '#'
00:D2E8 6C
00:D2E9 FE
00:D2EA 6C
00:D2EB FE
00:D2EC 6C
00:D2ED 6C
00:D2EE 00
00:D2EF 30              	    41:   dfb $30,$7C,$C0,$78,$0C,$F8,$30,$00 ; '$'
00:D2F0 7C
00:D2F1 C0
00:D2F2 78
00:D2F3 0C
00:D2F4 F8
00:D2F5 30
00:D2F6 00
00:D2F7 00              	    42:   dfb $00,$C6,$CC,$18,$30,$66,$C6,$00 ; '%'
00:D2F8 C6
00:D2F9 CC
00:D2FA 18
00:D2FB 30
00:D2FC 66
00:D2FD C6
00:D2FE 00
00:D2FF 38              	    43:   dfb $38,$6C,$38,$76,$DC,$CC,$76,$00 ; '&'
00:D300 6C
00:D301 38
00:D302 76
00:D303 DC
00:D304 CC
00:D305 76
00:D306 00
00:D307 60              	    44:   dfb $60,$60,$C0,$00,$00,$00,$00,$00 ; '''
00:D308 60
00:D309 C0
00:D30A 00
00:D30B 00
00:D30C 00
00:D30D 00
00:D30E 00
00:D30F 18              	    45:   dfb $18,$30,$60,$60,$60,$30,$18,$00 ; '('
00:D310 30
00:D311 60
00:D312 60
00:D313 60
00:D314 30
00:D315 18
00:D316 00
00:D317 60              	    46:   dfb $60,$30,$18,$18,$18,$30,$60,$00 ; ')'
00:D318 30
00:D319 18
00:D31A 18
00:D31B 18
00:D31C 30
00:D31D 60
00:D31E 00
00:D31F 00              	    47:   dfb $00,$66,$3C,$FF,$3C,$66,$00,$00 ; '*'
00:D320 66
00:D321 3C
00:D322 FF
00:D323 3C
00:D324 66
00:D325 00
00:D326 00
00:D327 00              	    48:   dfb $00,$30,$30,$FC,$30,$30,$00,$00 ; '+'
00:D328 30
00:D329 30
00:D32A FC
00:D32B 30
00:D32C 30
00:D32D 00
00:D32E 00
00:D32F 00              	    49:   dfb $00,$00,$00,$00,$00,$30,$30,$60 ; ','
00:D330 00
00:D331 00
00:D332 00
00:D333 00
00:D334 30
00:D335 30
00:D336 60
00:D337 00              	    50:   dfb $00,$00,$00,$FC,$00,$00,$00,$00 ; '-'
00:D338 00
00:D339 00
00:D33A FC
00:D33B 00
00:D33C 00
00:D33D 00
00:D33E 00
00:D33F 00              	    51:   dfb $00,$00,$00,$00,$00,$30,$30,$00 ; '.'
00:D340 00
00:D341 00
00:D342 00
00:D343 00
00:D344 30
00:D345 30
00:D346 00
00:D347 06              	    52:   dfb $06,$0C,$18,$30,$60,$C0,$80,$00 ; '/'
00:D348 0C
00:D349 18
00:D34A 30
00:D34B 60
00:D34C C0
00:D34D 80
00:D34E 00
00:D34F 7C              	    53:   dfb $7C,$C6,$CE,$DE,$F6,$E6,$7C,$00 ; '0'
00:D350 C6
00:D351 CE
00:D352 DE
00:D353 F6
00:D354 E6
00:D355 7C
00:D356 00
00:D357 30              	    54:   dfb $30,$70,$30,$30,$30,$30,$FC,$00 ; '1'
00:D358 70
00:D359 30
00:D35A 30
00:D35B 30
00:D35C 30
00:D35D FC
00:D35E 00
00:D35F 78              	    55:   dfb $78,$CC,$0C,$38,$60,$CC,$FC,$00 ; '2'
00:D360 CC
00:D361 0C
00:D362 38
00:D363 60
00:D364 CC
00:D365 FC
00:D366 00
00:D367 78              	    56:   dfb $78,$CC,$0C,$38,$0C,$CC,$78,$00 ; '3'
00:D368 CC
00:D369 0C
00:D36A 38
00:D36B 0C
00:D36C CC
00:D36D 78
00:D36E 00
00:D36F 1C              	    57:   dfb $1C,$3C,$6C,$CC,$FE,$0C,$1E,$00 ; '4'
00:D370 3C
00:D371 6C
00:D372 CC
00:D373 FE
00:D374 0C
00:D375 1E
00:D376 00
00:D377 FC              	    58:   dfb $FC,$C0,$F8,$0C,$0C,$CC,$78,$00 ; '5'
00:D378 C0
00:D379 F8
00:D37A 0C
00:D37B 0C
00:D37C CC
00:D37D 78
00:D37E 00
00:D37F 38              	    59:   dfb $38,$60,$C0,$F8,$CC,$CC,$78,$00 ; '6'
00:D380 60
00:D381 C0
00:D382 F8
00:D383 CC
00:D384 CC
00:D385 78
00:D386 00
00:D387 FC              	    60:   dfb $FC,$CC,$0C,$18,$30,$30,$30,$00 ; '7'
00:D388 CC
00:D389 0C
00:D38A 18
00:D38B 30
00:D38C 30
00:D38D 30
00:D38E 00
00:D38F 78              	    61:   dfb $78,$CC,$CC,$78,$CC,$CC,$78,$00 ; '8'
00:D390 CC
00:D391 CC
00:D392 78
00:D393 CC
00:D394 CC
00:D395 78
00:D396 00
00:D397 78              	    62:   dfb $78,$CC,$CC,$7C,$0C,$18,$70,$00 ; '9'
00:D398 CC
00:D399 CC
00:D39A 7C
00:D39B 0C
00:D39C 18
00:D39D 70
00:D39E 00
00:D39F 00              	    63:   dfb $00,$30,$30,$00,$00,$30,$30,$00 ; ':'
00:D3A0 30
00:D3A1 30
00:D3A2 00
00:D3A3 00
00:D3A4 30
00:D3A5 30
00:D3A6 00
00:D3A7 00              	    64:   dfb $00,$30,$30,$00,$00,$30,$30,$60 ; ';'
00:D3A8 30
00:D3A9 30
00:D3AA 00
00:D3AB 00
00:D3AC 30
00:D3AD 30
00:D3AE 60
00:D3AF 18              	    65:   dfb $18,$30,$60,$C0,$60,$30,$18,$00 ; '<'
00:D3B0 30
00:D3B1 60
00:D3B2 C0
00:D3B3 60
00:D3B4 30
00:D3B5 18
00:D3B6 00
00:D3B7 00              	    66:   dfb $00,$00,$FC,$00,$00,$FC,$00,$00 ; '='
00:D3B8 00
00:D3B9 FC
00:D3BA 00
00:D3BB 00
00:D3BC FC
00:D3BD 00
00:D3BE 00
00:D3BF 60              	    67:   dfb $60,$30,$18,$0C,$18,$30,$60,$00 ; '>'
00:D3C0 30
00:D3C1 18
00:D3C2 0C
00:D3C3 18
00:D3C4 30
00:D3C5 60
00:D3C6 00
00:D3C7 78              	    68:   dfb $78,$CC,$0C,$18,$30,$00,$30,$00 ; '?'
00:D3C8 CC
00:D3C9 0C
00:D3CA 18
00:D3CB 30
00:D3CC 00
00:D3CD 30
00:D3CE 00
00:D3CF 7C              	    69:   dfb $7C,$C6,$DE,$DE,$DE,$C0,$78,$00 ; '@'
00:D3D0 C6
00:D3D1 DE
00:D3D2 DE
00:D3D3 DE
00:D3D4 C0
00:D3D5 78
00:D3D6 00
00:D3D7 30              	    70:   dfb $30,$78,$CC,$CC,$FC,$CC,$CC,$00 ; 'A'
00:D3D8 78
00:D3D9 CC
00:D3DA CC
00:D3DB FC
00:D3DC CC
00:D3DD CC
00:D3DE 00
00:D3DF FC              	    71:   dfb $FC,$66,$66,$7C,$66,$66,$FC,$00 ; 'B'
00:D3E0 66
00:D3E1 66
00:D3E2 7C
00:D3E3 66
00:D3E4 66
00:D3E5 FC
00:D3E6 00
00:D3E7 3C              	    72:   dfb $3C,$66,$C0,$C0,$C0,$66,$3C,$00 ; 'C'
00:D3E8 66
00:D3E9 C0
00:D3EA C0
00:D3EB C0
00:D3EC 66
00:D3ED 3C
00:D3EE 00
00:D3EF F8              	    73:   dfb $F8,$6C,$66,$66,$66,$6C,$F8,$00 ; 'D'
00:D3F0 6C
00:D3F1 66
00:D3F2 66
00:D3F3 66
00:D3F4 6C
00:D3F5 F8
00:D3F6 00
00:D3F7 FE              	    74:   dfb $FE,$62,$68,$78,$68,$62,$FE,$00 ; 'E'
00:D3F8 62
00:D3F9 68
00:D3FA 78
00:D3FB 68
00:D3FC 62
00:D3FD FE
00:D3FE 00
00:D3FF FE              	    75:   dfb $FE,$62,$68,$78,$68,$60,$F0,$00 ; 'F'
00:D400 62
00:D401 68
00:D402 78
00:D403 68
00:D404 60
00:D405 F0
00:D406 00
00:D407 3C              	    76:   dfb $3C,$66,$C0,$C0,$CE,$66,$3E,$00 ; 'G'
00:D408 66
00:D409 C0
00:D40A C0
00:D40B CE
00:D40C 66
00:D40D 3E
00:D40E 00
00:D40F CC              	    77:   dfb $CC,$CC,$CC,$FC,$CC,$CC,$CC,$00 ; 'H'
00:D410 CC
00:D411 CC
00:D412 FC
00:D413 CC
00:D414 CC
00:D415 CC
00:D416 00
00:D417 78              	    78:   dfb $78,$30,$30,$30,$30,$30,$78,$00 ; 'I'
00:D418 30
00:D419 30
00:D41A 30
00:D41B 30
00:D41C 30
00:D41D 78
00:D41E 00
00:D41F 1E              	    79:   dfb $1E,$0C,$0C,$0C,$CC,$CC,$78,$00 ; 'J'
00:D420 0C
00:D421 0C
00:D422 0C
00:D423 CC
00:D424 CC
00:D425 78
00:D426 00
00:D427 E6              	    80:   dfb $E6,$66,$6C,$78,$6C,$66,$E6,$00 ; 'K'
00:D428 66
00:D429 6C
00:D42A 78
00:D42B 6C
00:D42C 66
00:D42D E6
00:D42E 00
00:D42F F0              	    81:   dfb $F0,$60,$60,$60,$62,$66,$FE,$00 ; 'L'
00:D430 60
00:D431 60
00:D432 60
00:D433 62
00:D434 66
00:D435 FE
00:D436 00
00:D437 C6              	    82:   dfb $C6,$EE,$FE,$FE,$D6,$C6,$C6,$00 ; 'M'
00:D438 EE
00:D439 FE
00:D43A FE
00:D43B D6
00:D43C C6
00:D43D C6
00:D43E 00
00:D43F C6              	    83:   dfb $C6,$E6,$F6,$DE,$CE,$C6,$C6,$00 ; 'N'
00:D440 E6
00:D441 F6
00:D442 DE
00:D443 CE
00:D444 C6
00:D445 C6
00:D446 00
00:D447 38              	    84:   dfb $38,$6C,$C6,$C6,$C6,$6C,$38,$00 ; 'O'
00:D448 6C
00:D449 C6
00:D44A C6
00:D44B C6
00:D44C 6C
00:D44D 38
00:D44E 00
00:D44F FC              	    85:   dfb $FC,$66,$66,$7C,$60,$60,$F0,$00 ; 'P'
00:D450 66
00:D451 66
00:D452 7C
00:D453 60
00:D454 60
00:D455 F0
00:D456 00
00:D457 78              	    86:   dfb $78,$CC,$CC,$CC,$DC,$78,$1C,$00 ; 'Q'
00:D458 CC
00:D459 CC
00:D45A CC
00:D45B DC
00:D45C 78
00:D45D 1C
00:D45E 00
00:D45F FC              	    87:   dfb $FC,$66,$66,$7C,$6C,$66,$E6,$00 ; 'R'
00:D460 66
00:D461 66
00:D462 7C
00:D463 6C
00:D464 66
00:D465 E6
00:D466 00
00:D467 78              	    88:   dfb $78,$CC,$E0,$70,$1C,$CC,$78,$00 ; 'S'
00:D468 CC
00:D469 E0
00:D46A 70
00:D46B 1C
00:D46C CC
00:D46D 78
00:D46E 00
00:D46F FC              	    89:   dfb $FC,$B4,$30,$30,$30,$30,$78,$00 ; 'T'
00:D470 B4
00:D471 30
00:D472 30
00:D473 30
00:D474 30
00:D475 78
00:D476 00
00:D477 CC              	    90:   dfb $CC,$CC,$CC,$CC,$CC,$CC,$FC,$00 ; 'U'
00:D478 CC
00:D479 CC
00:D47A CC
00:D47B CC
00:D47C CC
00:D47D FC
00:D47E 00
00:D47F CC              	    91:   dfb $CC,$CC,$CC,$CC,$CC,$78,$30,$00 ; 'V'
00:D480 CC
00:D481 CC
00:D482 CC
00:D483 CC
00:D484 78
00:D485 30
00:D486 00
00:D487 C6              	    92:   dfb $C6,$C6,$C6,$D6,$FE,$EE,$C6,$00 ; 'W'
00:D488 C6
00:D489 C6
00:D48A D6
00:D48B FE
00:D48C EE
00:D48D C6
00:D48E 00
00:D48F C6              	    93:   dfb $C6,$C6,$6C,$38,$38,$6C,$C6,$00 ; 'X'
00:D490 C6
00:D491 6C
00:D492 38
00:D493 38
00:D494 6C
00:D495 C6
00:D496 00
00:D497 CC              	    94:   dfb $CC,$CC,$CC,$78,$30,$30,$78,$00 ; 'Y'
00:D498 CC
00:D499 CC
00:D49A 78
00:D49B 30
00:D49C 30
00:D49D 78
00:D49E 00
00:D49F FE              	    95:   dfb $FE,$C6,$8C,$18,$32,$66,$FE,$00 ; 'Z'
00:D4A0 C6
00:D4A1 8C
00:D4A2 18
00:D4A3 32
00:D4A4 66
00:D4A5 FE
00:D4A6 00
00:D4A7 78              	    96:   dfb $78,$60,$60,$60,$60,$60,$78,$00 ; '['
00:D4A8 60
00:D4A9 60
00:D4AA 60
00:D4AB 60
00:D4AC 60
00:D4AD 78
00:D4AE 00
00:D4AF C0              	    97:   dfb $C0,$60,$30,$18,$0C,$06,$02,$00 ; back
00:D4B0 60
00:D4B1 30
00:D4B2 18
00:D4B3 0C
00:D4B4 06
00:D4B5 02
00:D4B6 00
00:D4B7 78              	    98:   dfb $78,$18,$18,$18,$18,$18,$78,$00 ; ']'
00:D4B8 18
00:D4B9 18
00:D4BA 18
00:D4BB 18
00:D4BC 18
00:D4BD 78
00:D4BE 00
00:D4BF 10              	    99:   dfb $10,$38,$6C,$C6,$00,$00,$00,$00 ; '^'
00:D4C0 38
00:D4C1 6C
00:D4C2 C6
00:D4C3 00
00:D4C4 00
00:D4C5 00
00:D4C6 00
00:D4C7 00              	   100:   dfb $00,$00,$00,$00,$00,$00,$00,$FF ; '_'
00:D4C8 00
00:D4C9 00
00:D4CA 00
00:D4CB 00
00:D4CC 00
00:D4CD 00
00:D4CE FF
00:D4CF 30              	   101:   dfb $30,$30,$18,$00,$00,$00,$00,$00 ; '`'
00:D4D0 30
00:D4D1 18
00:D4D2 00
00:D4D3 00
00:D4D4 00
00:D4D5 00
00:D4D6 00
00:D4D7 00              	   102:   dfb $00,$00,$78,$0C,$7C,$CC,$76,$00 ; 'a'
00:D4D8 00
00:D4D9 78
00:D4DA 0C
00:D4DB 7C
00:D4DC CC
00:D4DD 76
00:D4DE 00
00:D4DF E0              	   103:   dfb $E0,$60,$60,$7C,$66,$66,$DC,$00 ; 'b'
00:D4E0 60
00:D4E1 60
00:D4E2 7C
00:D4E3 66
00:D4E4 66
00:D4E5 DC
00:D4E6 00
00:D4E7 00              	   104:   dfb $00,$00,$78,$CC,$C0,$CC,$78,$00 ; 'c'
00:D4E8 00
00:D4E9 78
00:D4EA CC
00:D4EB C0
00:D4EC CC
00:D4ED 78
00:D4EE 00
00:D4EF 1C              	   105:   dfb $1C,$0C,$0C,$7C,$CC,$CC,$76,$00 ; 'd'
00:D4F0 0C
00:D4F1 0C
00:D4F2 7C
00:D4F3 CC
00:D4F4 CC
00:D4F5 76
00:D4F6 00
00:D4F7 00              	   106:   dfb $00,$00,$78,$CC,$FC,$C0,$78,$00 ; 'e'
00:D4F8 00
00:D4F9 78
00:D4FA CC
00:D4FB FC
00:D4FC C0
00:D4FD 78
00:D4FE 00
00:D4FF 38              	   107:   dfb $38,$6C,$60,$F0,$60,$60,$F0,$00 ; 'f'
00:D500 6C
00:D501 60
00:D502 F0
00:D503 60
00:D504 60
00:D505 F0
00:D506 00
00:D507 00              	   108:   dfb $00,$00,$76,$CC,$CC,$7C,$0C,$F8 ; 'g'
00:D508 00
00:D509 76
00:D50A CC
00:D50B CC
00:D50C 7C
00:D50D 0C
00:D50E F8
00:D50F E0              	   109:   dfb $E0,$60,$6C,$76,$66,$66,$E6,$00 ; 'h'
00:D510 60
00:D511 6C
00:D512 76
00:D513 66
00:D514 66
00:D515 E6
00:D516 00
00:D517 30              	   110:   dfb $30,$00,$70,$30,$30,$30,$78,$00 ; 'i'
00:D518 00
00:D519 70
00:D51A 30
00:D51B 30
00:D51C 30
00:D51D 78
00:D51E 00
00:D51F 0C              	   111:   dfb $0C,$00,$0C,$0C,$0C,$CC,$CC,$78 ; 'j'
00:D520 00
00:D521 0C
00:D522 0C
00:D523 0C
00:D524 CC
00:D525 CC
00:D526 78
00:D527 E0              	   112:   dfb $E0,$60,$66,$6C,$78,$6C,$E6,$00 ; 'k'
00:D528 60
00:D529 66
00:D52A 6C
00:D52B 78
00:D52C 6C
00:D52D E6
00:D52E 00
00:D52F 70              	   113:   dfb $70,$30,$30,$30,$30,$30,$78,$00 ; 'l'
00:D530 30
00:D531 30
00:D532 30
00:D533 30
00:D534 30
00:D535 78
00:D536 00
00:D537 00              	   114:   dfb $00,$00,$CC,$FE,$FE,$D6,$C6,$00 ; 'm'
00:D538 00
00:D539 CC
00:D53A FE
00:D53B FE
00:D53C D6
00:D53D C6
00:D53E 00
00:D53F 00              	   115:   dfb $00,$00,$F8,$CC,$CC,$CC,$CC,$00 ; 'n'
00:D540 00
00:D541 F8
00:D542 CC
00:D543 CC
00:D544 CC
00:D545 CC
00:D546 00
00:D547 00              	   116:   dfb $00,$00,$78,$CC,$CC,$CC,$78,$00 ; 'o'
00:D548 00
00:D549 78
00:D54A CC
00:D54B CC
00:D54C CC
00:D54D 78
00:D54E 00
00:D54F 00              	   117:   dfb $00,$00,$DC,$66,$66,$7C,$60,$F0 ; 'p'
00:D550 00
00:D551 DC
00:D552 66
00:D553 66
00:D554 7C
00:D555 60
00:D556 F0
00:D557 00              	   118:   dfb $00,$00,$76,$CC,$CC,$7C,$0C,$1E ; 'q'
00:D558 00
00:D559 76
00:D55A CC
00:D55B CC
00:D55C 7C
00:D55D 0C
00:D55E 1E
00:D55F 00              	   119:   dfb $00,$00,$DC,$76,$66,$60,$F0,$00 ; 'r'
00:D560 00
00:D561 DC
00:D562 76
00:D563 66
00:D564 60
00:D565 F0
00:D566 00
00:D567 00              	   120:   dfb $00,$00,$7C,$C0,$78,$0C,$F8,$00 ; 's'
00:D568 00
00:D569 7C
00:D56A C0
00:D56B 78
00:D56C 0C
00:D56D F8
00:D56E 00
00:D56F 10              	   121:   dfb $10,$30,$7C,$30,$30,$34,$18,$00 ; 't'
00:D570 30
00:D571 7C
00:D572 30
00:D573 30
00:D574 34
00:D575 18
00:D576 00
00:D577 00              	   122:   dfb $00,$00,$CC,$CC,$CC,$CC,$76,$00 ; 'u'
00:D578 00
00:D579 CC
00:D57A CC
00:D57B CC
00:D57C CC
00:D57D 76
00:D57E 00
00:D57F 00              	   123:   dfb $00,$00,$CC,$CC,$CC,$78,$30,$00 ; 'v'
00:D580 00
00:D581 CC
00:D582 CC
00:D583 CC
00:D584 78
00:D585 30
00:D586 00
00:D587 00              	   124:   dfb $00,$00,$C6,$D6,$FE,$FE,$6C,$00 ; 'w'
00:D588 00
00:D589 C6
00:D58A D6
00:D58B FE
00:D58C FE
00:D58D 6C
00:D58E 00
00:D58F 00              	   125:   dfb $00,$00,$C6,$6C,$38,$6C,$C6,$00 ; 'x'
00:D590 00
00:D591 C6
00:D592 6C
00:D593 38
00:D594 6C
00:D595 C6
00:D596 00
00:D597 00              	   126:   dfb $00,$00,$CC,$CC,$CC,$7C,$0C,$F8 ; 'y'
00:D598 00
00:D599 CC
00:D59A CC
00:D59B CC
00:D59C 7C
00:D59D 0C
00:D59E F8
00:D59F 00              	   127:   dfb $00,$00,$FC,$98,$30,$64,$FC,$00 ; 'z'
00:D5A0 00
00:D5A1 FC
00:D5A2 98
00:D5A3 30
00:D5A4 64
00:D5A5 FC
00:D5A6 00
00:D5A7 1C              	   128:   dfb $1C,$30,$30,$E0,$30,$30,$1C,$00 ; '{'
00:D5A8 30
00:D5A9 30
00:D5AA E0
00:D5AB 30
00:D5AC 30
00:D5AD 1C
00:D5AE 00
00:D5AF 18              	   129:   dfb $18,$18,$18,$00,$18,$18,$18,$00 ; '|'
00:D5B0 18
00:D5B1 18
00:D5B2 00
00:D5B3 18
00:D5B4 18
00:D5B5 18
00:D5B6 00
00:D5B7 E0              	   130:   dfb $E0,$30,$30,$1C,$30,$30,$E0,$00 ; '}'
00:D5B8 30
00:D5B9 30
00:D5BA 1C
00:D5BB 30
00:D5BC 30
00:D5BD E0
00:D5BE 00
00:D5BF 76              	   131:   dfb $76,$DC,$00,$00,$00,$00,$00,$00 ; '~'
00:D5C0 DC
00:D5C1 00
00:D5C2 00
00:D5C3 00
00:D5C4 00
00:D5C5 00
00:D5C6 00
00:D5C7 00              	   132:   dfb $00,$10,$38,$6C,$C6,$C6,$FE,$00 ; $7F
00:D5C8 10
00:D5C9 38
00:D5CA 6C
00:D5CB C6
00:D5CC C6
00:D5CD FE
00:D5CE 00
00:D5CF 78              	   133:   dfb $78,$CC,$C0,$CC,$78,$18,$0C,$78 ; $80
00:D5D0 CC
00:D5D1 C0
00:D5D2 CC
00:D5D3 78
00:D5D4 18
00:D5D5 0C
00:D5D6 78
00:D5D7 00              	   134:   dfb $00,$CC,$00,$CC,$CC,$CC,$7E,$00 ; $81
00:D5D8 CC
00:D5D9 00
00:D5DA CC
00:D5DB CC
00:D5DC CC
00:D5DD 7E
00:D5DE 00
00:D5DF 1C              	   135:   dfb $1C,$00,$78,$CC,$FC,$C0,$78,$00 ; $82
00:D5E0 00
00:D5E1 78
00:D5E2 CC
00:D5E3 FC
00:D5E4 C0
00:D5E5 78
00:D5E6 00
00:D5E7 7E              	   136:   dfb $7E,$C3,$3C,$06,$3E,$66,$3F,$00 ; $83
00:D5E8 C3
00:D5E9 3C
00:D5EA 06
00:D5EB 3E
00:D5EC 66
00:D5ED 3F
00:D5EE 00
00:D5EF CC              	   137:   dfb $CC,$00,$78,$0C,$7C,$CC,$7E,$00 ; $84
00:D5F0 00
00:D5F1 78
00:D5F2 0C
00:D5F3 7C
00:D5F4 CC
00:D5F5 7E
00:D5F6 00
00:D5F7 E0              	   138:   dfb $E0,$00,$78,$0C,$7C,$CC,$7E,$00 ; $85
00:D5F8 00
00:D5F9 78
00:D5FA 0C
00:D5FB 7C
00:D5FC CC
00:D5FD 7E
00:D5FE 00
00:D5FF 30              	   139:   dfb $30,$30,$78,$0C,$7C,$CC,$7E,$00 ; $86
00:D600 30
00:D601 78
00:D602 0C
00:D603 7C
00:D604 CC
00:D605 7E
00:D606 00
00:D607 00              	   140:   dfb $00,$00,$78,$C0,$C0,$78,$0C,$38 ; $87
00:D608 00
00:D609 78
00:D60A C0
00:D60B C0
00:D60C 78
00:D60D 0C
00:D60E 38
00:D60F 7E              	   141:   dfb $7E,$C3,$3C,$66,$7E,$60,$3C,$00 ; $88
00:D610 C3
00:D611 3C
00:D612 66
00:D613 7E
00:D614 60
00:D615 3C
00:D616 00
00:D617 CC              	   142:   dfb $CC,$00,$78,$CC,$FC,$C0,$78,$00 ; $89
00:D618 00
00:D619 78
00:D61A CC
00:D61B FC
00:D61C C0
00:D61D 78
00:D61E 00
00:D61F E0              	   143:   dfb $E0,$00,$78,$CC,$FC,$C0,$78,$00 ; $8A
00:D620 00
00:D621 78
00:D622 CC
00:D623 FC
00:D624 C0
00:D625 78
00:D626 00
00:D627 CC              	   144:   dfb $CC,$00,$70,$30,$30,$30,$78,$00 ; $8B
00:D628 00
00:D629 70
00:D62A 30
00:D62B 30
00:D62C 30
00:D62D 78
00:D62E 00
00:D62F 7C              	   145:   dfb $7C,$C6,$38,$18,$18,$18,$3C,$00 ; $8C
00:D630 C6
00:D631 38
00:D632 18
00:D633 18
00:D634 18
00:D635 3C
00:D636 00
00:D637 E0              	   146:   dfb $E0,$00,$70,$30,$30,$30,$78,$00 ; $8D
00:D638 00
00:D639 70
00:D63A 30
00:D63B 30
00:D63C 30
00:D63D 78
00:D63E 00
00:D63F C6              	   147:   dfb $C6,$38,$6C,$C6,$FE,$C6,$C6,$00 ; $8E
00:D640 38
00:D641 6C
00:D642 C6
00:D643 FE
00:D644 C6
00:D645 C6
00:D646 00
00:D647 30              	   148:   dfb $30,$30,$00,$78,$CC,$FC,$CC,$00 ; $8F
00:D648 30
00:D649 00
00:D64A 78
00:D64B CC
00:D64C FC
00:D64D CC
00:D64E 00
00:D64F 1C              	   149:   dfb $1C,$00,$FC,$60,$78,$60,$FC,$00 ; $90
00:D650 00
00:D651 FC
00:D652 60
00:D653 78
00:D654 60
00:D655 FC
00:D656 00
00:D657 00              	   150:   dfb $00,$00,$7F,$0C,$7F,$CC,$7F,$00 ; $91
00:D658 00
00:D659 7F
00:D65A 0C
00:D65B 7F
00:D65C CC
00:D65D 7F
00:D65E 00
00:D65F 3E              	   151:   dfb $3E,$6C,$CC,$FE,$CC,$CC,$CE,$00 ; $92
00:D660 6C
00:D661 CC
00:D662 FE
00:D663 CC
00:D664 CC
00:D665 CE
00:D666 00
00:D667 78              	   152:   dfb $78,$CC,$00,$78,$CC,$CC,$78,$00 ; $93
00:D668 CC
00:D669 00
00:D66A 78
00:D66B CC
00:D66C CC
00:D66D 78
00:D66E 00
00:D66F 00              	   153:   dfb $00,$CC,$00,$78,$CC,$CC,$78,$00 ; $94
00:D670 CC
00:D671 00
00:D672 78
00:D673 CC
00:D674 CC
00:D675 78
00:D676 00
00:D677 00              	   154:   dfb $00,$E0,$00,$78,$CC,$CC,$78,$00 ; $95
00:D678 E0
00:D679 00
00:D67A 78
00:D67B CC
00:D67C CC
00:D67D 78
00:D67E 00
00:D67F 78              	   155:   dfb $78,$CC,$00,$CC,$CC,$CC,$7E,$00 ; $96
00:D680 CC
00:D681 00
00:D682 CC
00:D683 CC
00:D684 CC
00:D685 7E
00:D686 00
00:D687 00              	   156:   dfb $00,$E0,$00,$CC,$CC,$CC,$7E,$00 ; $97
00:D688 E0
00:D689 00
00:D68A CC
00:D68B CC
00:D68C CC
00:D68D 7E
00:D68E 00
00:D68F 00              	   157:   dfb $00,$CC,$00,$CC,$CC,$7C,$0C,$F8 ; $98
00:D690 CC
00:D691 00
00:D692 CC
00:D693 CC
00:D694 7C
00:D695 0C
00:D696 F8
00:D697 C3              	   158:   dfb $C3,$18,$3C,$66,$66,$3C,$18,$00 ; $99
00:D698 18
00:D699 3C
00:D69A 66
00:D69B 66
00:D69C 3C
00:D69D 18
00:D69E 00
00:D69F CC              	   159:   dfb $CC,$00,$CC,$CC,$CC,$CC,$78,$00 ; $9A
00:D6A0 00
00:D6A1 CC
00:D6A2 CC
00:D6A3 CC
00:D6A4 CC
00:D6A5 78
00:D6A6 00
00:D6A7 18              	   160:   dfb $18,$18,$7E,$C0,$C0,$7E,$18,$18 ; $9B
00:D6A8 18
00:D6A9 7E
00:D6AA C0
00:D6AB C0
00:D6AC 7E
00:D6AD 18
00:D6AE 18
00:D6AF 38              	   161:   dfb $38,$6C,$64,$F0,$60,$E6,$FC,$00 ; $9C
00:D6B0 6C
00:D6B1 64
00:D6B2 F0
00:D6B3 60
00:D6B4 E6
00:D6B5 FC
00:D6B6 00
00:D6B7 CC              	   162:   dfb $CC,$CC,$78,$FC,$30,$FC,$30,$30 ; $9D
00:D6B8 CC
00:D6B9 78
00:D6BA FC
00:D6BB 30
00:D6BC FC
00:D6BD 30
00:D6BE 30
00:D6BF F8              	   163:   dfb $F8,$CC,$CC,$FA,$C6,$CF,$C6,$C7 ; $9E
00:D6C0 CC
00:D6C1 CC
00:D6C2 FA
00:D6C3 C6
00:D6C4 CF
00:D6C5 C6
00:D6C6 C7
00:D6C7 0E              	   164:   dfb $0E,$1B,$18,$3C,$18,$18,$D8,$70 ; $9F
00:D6C8 1B
00:D6C9 18
00:D6CA 3C
00:D6CB 18
00:D6CC 18
00:D6CD D8
00:D6CE 70
00:D6CF 1C              	   165:   dfb $1C,$00,$78,$0C,$7C,$CC,$7E,$00 ; $A0
00:D6D0 00
00:D6D1 78
00:D6D2 0C
00:D6D3 7C
00:D6D4 CC
00:D6D5 7E
00:D6D6 00
00:D6D7 38              	   166:   dfb $38,$00,$70,$30,$30,$30,$78,$00 ; $A1
00:D6D8 00
00:D6D9 70
00:D6DA 30
00:D6DB 30
00:D6DC 30
00:D6DD 78
00:D6DE 00
00:D6DF 00              	   167:   dfb $00,$1C,$00,$78,$CC,$CC,$78,$00 ; $A2
00:D6E0 1C
00:D6E1 00
00:D6E2 78
00:D6E3 CC
00:D6E4 CC
00:D6E5 78
00:D6E6 00
00:D6E7 00              	   168:   dfb $00,$1C,$00,$CC,$CC,$CC,$7E,$00 ; $A3
00:D6E8 1C
00:D6E9 00
00:D6EA CC
00:D6EB CC
00:D6EC CC
00:D6ED 7E
00:D6EE 00
00:D6EF 00              	   169:   dfb $00,$F8,$00,$F8,$CC,$CC,$CC,$00 ; $A4
00:D6F0 F8
00:D6F1 00
00:D6F2 F8
00:D6F3 CC
00:D6F4 CC
00:D6F5 CC
00:D6F6 00
00:D6F7 FC              	   170:   dfb $FC,$00,$CC,$EC,$FC,$DC,$CC,$00 ; $A5
00:D6F8 00
00:D6F9 CC
00:D6FA EC
00:D6FB FC
00:D6FC DC
00:D6FD CC
00:D6FE 00
00:D6FF 3C              	   171:   dfb $3C,$6C,$6C,$3E,$00,$7E,$00,$00 ; $A6
00:D700 6C
00:D701 6C
00:D702 3E
00:D703 00
00:D704 7E
00:D705 00
00:D706 00
00:D707 38              	   172:   dfb $38,$6C,$6C,$38,$00,$7C,$00,$00 ; $A7
00:D708 6C
00:D709 6C
00:D70A 38
00:D70B 00
00:D70C 7C
00:D70D 00
00:D70E 00
00:D70F 30              	   173:   dfb $30,$00,$30,$60,$C0,$CC,$78,$00 ; $A8
00:D710 00
00:D711 30
00:D712 60
00:D713 C0
00:D714 CC
00:D715 78
00:D716 00
00:D717 00              	   174:   dfb $00,$00,$00,$FC,$C0,$C0,$00,$00 ; $A9
00:D718 00
00:D719 00
00:D71A FC
00:D71B C0
00:D71C C0
00:D71D 00
00:D71E 00
00:D71F 00              	   175:   dfb $00,$00,$00,$FC,$0C,$0C,$00,$00 ; $AA
00:D720 00
00:D721 00
00:D722 FC
00:D723 0C
00:D724 0C
00:D725 00
00:D726 00
00:D727 C3              	   176:   dfb $C3,$C6,$CC,$DE,$33,$66,$CC,$0F ; $AB
00:D728 C6
00:D729 CC
00:D72A DE
00:D72B 33
00:D72C 66
00:D72D CC
00:D72E 0F
00:D72F C3              	   177:   dfb $C3,$C6,$CC,$DB,$37,$6F,$CF,$03 ; $AC
00:D730 C6
00:D731 CC
00:D732 DB
00:D733 37
00:D734 6F
00:D735 CF
00:D736 03
00:D737 18              	   178:   dfb $18,$18,$00,$18,$18,$18,$18,$00 ; $AD
00:D738 18
00:D739 00
00:D73A 18
00:D73B 18
00:D73C 18
00:D73D 18
00:D73E 00
00:D73F 00              	   179:   dfb $00,$33,$66,$CC,$66,$33,$00,$00 ; $AE
00:D740 33
00:D741 66
00:D742 CC
00:D743 66
00:D744 33
00:D745 00
00:D746 00
00:D747 00              	   180:   dfb $00,$CC,$66,$33,$66,$CC,$00,$00 ; $AF
00:D748 CC
00:D749 66
00:D74A 33
00:D74B 66
00:D74C CC
00:D74D 00
00:D74E 00
00:D74F 22              	   181:   dfb $22,$88,$22,$88,$22,$88,$22,$88 ; $B0
00:D750 88
00:D751 22
00:D752 88
00:D753 22
00:D754 88
00:D755 22
00:D756 88
00:D757 55              	   182:   dfb $55,$AA,$55,$AA,$55,$AA,$55,$AA ; $B1
00:D758 AA
00:D759 55
00:D75A AA
00:D75B 55
00:D75C AA
00:D75D 55
00:D75E AA
00:D75F DB              	   183:   dfb $DB,$77,$DB,$EE,$DB,$77,$DB,$EE ; $B2
00:D760 77
00:D761 DB
00:D762 EE
00:D763 DB
00:D764 77
00:D765 DB
00:D766 EE
00:D767 18              	   184:   dfb $18,$18,$18,$18,$18,$18,$18,$18 ; $B3
00:D768 18
00:D769 18
00:D76A 18
00:D76B 18
00:D76C 18
00:D76D 18
00:D76E 18
00:D76F 18              	   185:   dfb $18,$18,$18,$18,$F8,$18,$18,$18 ; $B4
00:D770 18
00:D771 18
00:D772 18
00:D773 F8
00:D774 18
00:D775 18
00:D776 18
00:D777 18              	   186:   dfb $18,$18,$F8,$18,$F8,$18,$18,$18 ; $B5
00:D778 18
00:D779 F8
00:D77A 18
00:D77B F8
00:D77C 18
00:D77D 18
00:D77E 18
00:D77F 36              	   187:   dfb $36,$36,$36,$36,$F6,$36,$36,$36 ; $B6
00:D780 36
00:D781 36
00:D782 36
00:D783 F6
00:D784 36
00:D785 36
00:D786 36
00:D787 00              	   188:   dfb $00,$00,$00,$00,$FE,$36,$36,$36 ; $B7
00:D788 00
00:D789 00
00:D78A 00
00:D78B FE
00:D78C 36
00:D78D 36
00:D78E 36
00:D78F 00              	   189:   dfb $00,$00,$F8,$18,$F8,$18,$18,$18 ; $B8
00:D790 00
00:D791 F8
00:D792 18
00:D793 F8
00:D794 18
00:D795 18
00:D796 18
00:D797 36              	   190:   dfb $36,$36,$F6,$06,$F6,$36,$36,$36 ; $B9
00:D798 36
00:D799 F6
00:D79A 06
00:D79B F6
00:D79C 36
00:D79D 36
00:D79E 36
00:D79F 36              	   191:   dfb $36,$36,$36,$36,$36,$36,$36,$36 ; $BA
00:D7A0 36
00:D7A1 36
00:D7A2 36
00:D7A3 36
00:D7A4 36
00:D7A5 36
00:D7A6 36
00:D7A7 00              	   192:   dfb $00,$00,$FE,$06,$F6,$36,$36,$36 ; $BB
00:D7A8 00
00:D7A9 FE
00:D7AA 06
00:D7AB F6
00:D7AC 36
00:D7AD 36
00:D7AE 36
00:D7AF 36              	   193:   dfb $36,$36,$F6,$06,$FE,$00,$00,$00 ; $BC
00:D7B0 36
00:D7B1 F6
00:D7B2 06
00:D7B3 FE
00:D7B4 00
00:D7B5 00
00:D7B6 00
00:D7B7 36              	   194:   dfb $36,$36,$36,$36,$FE,$00,$00,$00 ; $BD
00:D7B8 36
00:D7B9 36
00:D7BA 36
00:D7BB FE
00:D7BC 00
00:D7BD 00
00:D7BE 00
00:D7BF 18              	   195:   dfb $18,$18,$F8,$18,$F8,$00,$00,$00 ; $BE
00:D7C0 18
00:D7C1 F8
00:D7C2 18
00:D7C3 F8
00:D7C4 00
00:D7C5 00
00:D7C6 00
00:D7C7 00              	   196:   dfb $00,$00,$00,$00,$F8,$18,$18,$18 ; $BF
00:D7C8 00
00:D7C9 00
00:D7CA 00
00:D7CB F8
00:D7CC 18
00:D7CD 18
00:D7CE 18
00:D7CF 18              	   197:   dfb $18,$18,$18,$18,$1F,$00,$00,$00 ; $C0
00:D7D0 18
00:D7D1 18
00:D7D2 18
00:D7D3 1F
00:D7D4 00
00:D7D5 00
00:D7D6 00
00:D7D7 18              	   198:   dfb $18,$18,$18,$18,$FF,$00,$00,$00 ; $C1
00:D7D8 18
00:D7D9 18
00:D7DA 18
00:D7DB FF
00:D7DC 00
00:D7DD 00
00:D7DE 00
00:D7DF 00              	   199:   dfb $00,$00,$00,$00,$FF,$18,$18,$18 ; $C2
00:D7E0 00
00:D7E1 00
00:D7E2 00
00:D7E3 FF
00:D7E4 18
00:D7E5 18
00:D7E6 18
00:D7E7 18              	   200:   dfb $18,$18,$18,$18,$1F,$18,$18,$18 ; $C3
00:D7E8 18
00:D7E9 18
00:D7EA 18
00:D7EB 1F
00:D7EC 18
00:D7ED 18
00:D7EE 18
00:D7EF 00              	   201:   dfb $00,$00,$00,$00,$FF,$00,$00,$00 ; $C4
00:D7F0 00
00:D7F1 00
00:D7F2 00
00:D7F3 FF
00:D7F4 00
00:D7F5 00
00:D7F6 00
00:D7F7 18              	   202:   dfb $18,$18,$18,$18,$FF,$18,$18,$18 ; $C5
00:D7F8 18
00:D7F9 18
00:D7FA 18
00:D7FB FF
00:D7FC 18
00:D7FD 18
00:D7FE 18
00:D7FF 18              	   203:   dfb $18,$18,$1F,$18,$1F,$18,$18,$18 ; $C6
00:D800 18
00:D801 1F
00:D802 18
00:D803 1F
00:D804 18
00:D805 18
00:D806 18
00:D807 36              	   204:   dfb $36,$36,$36,$36,$37,$36,$36,$36 ; $C7
00:D808 36
00:D809 36
00:D80A 36
00:D80B 37
00:D80C 36
00:D80D 36
00:D80E 36
00:D80F 36              	   205:   dfb $36,$36,$37,$30,$3F,$00,$00,$00 ; $C8
00:D810 36
00:D811 37
00:D812 30
00:D813 3F
00:D814 00
00:D815 00
00:D816 00
00:D817 00              	   206:   dfb $00,$00,$3F,$30,$37,$36,$36,$36 ; $C9
00:D818 00
00:D819 3F
00:D81A 30
00:D81B 37
00:D81C 36
00:D81D 36
00:D81E 36
00:D81F 36              	   207:   dfb $36,$36,$F7,$00,$FF,$00,$00,$00 ; $CA
00:D820 36
00:D821 F7
00:D822 00
00:D823 FF
00:D824 00
00:D825 00
00:D826 00
00:D827 00              	   208:   dfb $00,$00,$FF,$00,$F7,$36,$36,$36 ; $CB
00:D828 00
00:D829 FF
00:D82A 00
00:D82B F7
00:D82C 36
00:D82D 36
00:D82E 36
00:D82F 36              	   209:   dfb $36,$36,$37,$30,$37,$36,$36,$36 ; $CC
00:D830 36
00:D831 37
00:D832 30
00:D833 37
00:D834 36
00:D835 36
00:D836 36
00:D837 00              	   210:   dfb $00,$00,$FF,$00,$FF,$00,$00,$00 ; $CD
00:D838 00
00:D839 FF
00:D83A 00
00:D83B FF
00:D83C 00
00:D83D 00
00:D83E 00
00:D83F 36              	   211:   dfb $36,$36,$F7,$00,$F7,$36,$36,$36 ; $CE
00:D840 36
00:D841 F7
00:D842 00
00:D843 F7
00:D844 36
00:D845 36
00:D846 36
00:D847 18              	   212:   dfb $18,$18,$FF,$00,$FF,$00,$00,$00 ; $CF
00:D848 18
00:D849 FF
00:D84A 00
00:D84B FF
00:D84C 00
00:D84D 00
00:D84E 00
00:D84F 36              	   213:   dfb $36,$36,$36,$36,$FF,$00,$00,$00 ; $D0
00:D850 36
00:D851 36
00:D852 36
00:D853 FF
00:D854 00
00:D855 00
00:D856 00
00:D857 00              	   214:   dfb $00,$00,$FF,$00,$FF,$18,$18,$18 ; $D1
00:D858 00
00:D859 FF
00:D85A 00
00:D85B FF
00:D85C 18
00:D85D 18
00:D85E 18
00:D85F 00              	   215:   dfb $00,$00,$00,$00,$FF,$36,$36,$36 ; $D2
00:D860 00
00:D861 00
00:D862 00
00:D863 FF
00:D864 36
00:D865 36
00:D866 36
00:D867 36              	   216:   dfb $36,$36,$36,$36,$3F,$00,$00,$00 ; $D3
00:D868 36
00:D869 36
00:D86A 36
00:D86B 3F
00:D86C 00
00:D86D 00
00:D86E 00
00:D86F 18              	   217:   dfb $18,$18,$1F,$18,$1F,$00,$00,$00 ; $D4
00:D870 18
00:D871 1F
00:D872 18
00:D873 1F
00:D874 00
00:D875 00
00:D876 00
00:D877 00              	   218:   dfb $00,$00,$1F,$18,$1F,$18,$18,$18 ; $D5
00:D878 00
00:D879 1F
00:D87A 18
00:D87B 1F
00:D87C 18
00:D87D 18
00:D87E 18
00:D87F 00              	   219:   dfb $00,$00,$00,$00,$3F,$36,$36,$36 ; $D6
00:D880 00
00:D881 00
00:D882 00
00:D883 3F
00:D884 36
00:D885 36
00:D886 36
00:D887 36              	   220:   dfb $36,$36,$36,$36,$FF,$36,$36,$36 ; $D7
00:D888 36
00:D889 36
00:D88A 36
00:D88B FF
00:D88C 36
00:D88D 36
00:D88E 36
00:D88F 18              	   221:   dfb $18,$18,$FF,$18,$FF,$18,$18,$18 ; $D8
00:D890 18
00:D891 FF
00:D892 18
00:D893 FF
00:D894 18
00:D895 18
00:D896 18
00:D897 18              	   222:   dfb $18,$18,$18,$18,$F8,$00,$00,$00 ; $D9
00:D898 18
00:D899 18
00:D89A 18
00:D89B F8
00:D89C 00
00:D89D 00
00:D89E 00
00:D89F 00              	   223:   dfb $00,$00,$00,$00,$1F,$18,$18,$18 ; $DA
00:D8A0 00
00:D8A1 00
00:D8A2 00
00:D8A3 1F
00:D8A4 18
00:D8A5 18
00:D8A6 18
00:D8A7 FF              	   224:   dfb $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF ; $DB
00:D8A8 FF
00:D8A9 FF
00:D8AA FF
00:D8AB FF
00:D8AC FF
00:D8AD FF
00:D8AE FF
00:D8AF 00              	   225:   dfb $00,$00,$00,$00,$FF,$FF,$FF,$FF ; $DC
00:D8B0 00
00:D8B1 00
00:D8B2 00
00:D8B3 FF
00:D8B4 FF
00:D8B5 FF
00:D8B6 FF
00:D8B7 F0              	   226:   dfb $F0,$F0,$F0,$F0,$F0,$F0,$F0,$F0 ; $DD
00:D8B8 F0
00:D8B9 F0
00:D8BA F0
00:D8BB F0
00:D8BC F0
00:D8BD F0
00:D8BE F0
00:D8BF 0F              	   227:   dfb $0F,$0F,$0F,$0F,$0F,$0F,$0F,$0F ; $DE
00:D8C0 0F
00:D8C1 0F
00:D8C2 0F
00:D8C3 0F
00:D8C4 0F
00:D8C5 0F
00:D8C6 0F
00:D8C7 FF              	   228:   dfb $FF,$FF,$FF,$FF,$00,$00,$00,$00 ; $DF
00:D8C8 FF
00:D8C9 FF
00:D8CA FF
00:D8CB 00
00:D8CC 00
00:D8CD 00
00:D8CE 00
00:D8CF 00              	   229:   dfb $00,$00,$76,$DC,$C8,$DC,$76,$00 ; $E0
00:D8D0 00
00:D8D1 76
00:D8D2 DC
00:D8D3 C8
00:D8D4 DC
00:D8D5 76
00:D8D6 00
00:D8D7 00              	   230:   dfb $00,$78,$CC,$F8,$CC,$F8,$C0,$C0 ; $E1
00:D8D8 78
00:D8D9 CC
00:D8DA F8
00:D8DB CC
00:D8DC F8
00:D8DD C0
00:D8DE C0
00:D8DF 00              	   231:   dfb $00,$FC,$CC,$C0,$C0,$C0,$C0,$00 ; $E2
00:D8E0 FC
00:D8E1 CC
00:D8E2 C0
00:D8E3 C0
00:D8E4 C0
00:D8E5 C0
00:D8E6 00
00:D8E7 00              	   232:   dfb $00,$FE,$6C,$6C,$6C,$6C,$6C,$00 ; $E3
00:D8E8 FE
00:D8E9 6C
00:D8EA 6C
00:D8EB 6C
00:D8EC 6C
00:D8ED 6C
00:D8EE 00
00:D8EF FC              	   233:   dfb $FC,$CC,$60,$30,$60,$CC,$FC,$00 ; $E4
00:D8F0 CC
00:D8F1 60
00:D8F2 30
00:D8F3 60
00:D8F4 CC
00:D8F5 FC
00:D8F6 00
00:D8F7 00              	   234:   dfb $00,$00,$7E,$D8,$D8,$D8,$70,$00 ; $E5
00:D8F8 00
00:D8F9 7E
00:D8FA D8
00:D8FB D8
00:D8FC D8
00:D8FD 70
00:D8FE 00
00:D8FF 00              	   235:   dfb $00,$66,$66,$66,$66,$7C,$60,$C0 ; $E6
00:D900 66
00:D901 66
00:D902 66
00:D903 66
00:D904 7C
00:D905 60
00:D906 C0
00:D907 00              	   236:   dfb $00,$76,$DC,$18,$18,$18,$18,$00 ; $E7
00:D908 76
00:D909 DC
00:D90A 18
00:D90B 18
00:D90C 18
00:D90D 18
00:D90E 00
00:D90F FC              	   237:   dfb $FC,$30,$78,$CC,$CC,$78,$30,$FC ; $E8
00:D910 30
00:D911 78
00:D912 CC
00:D913 CC
00:D914 78
00:D915 30
00:D916 FC
00:D917 38              	   238:   dfb $38,$6C,$C6,$FE,$C6,$6C,$38,$00 ; $E9
00:D918 6C
00:D919 C6
00:D91A FE
00:D91B C6
00:D91C 6C
00:D91D 38
00:D91E 00
00:D91F 38              	   239:   dfb $38,$6C,$C6,$C6,$6C,$6C,$EE,$00 ; $EA
00:D920 6C
00:D921 C6
00:D922 C6
00:D923 6C
00:D924 6C
00:D925 EE
00:D926 00
00:D927 1C              	   240:   dfb $1C,$30,$18,$7C,$CC,$CC,$78,$00 ; $EB
00:D928 30
00:D929 18
00:D92A 7C
00:D92B CC
00:D92C CC
00:D92D 78
00:D92E 00
00:D92F 00              	   241:   dfb $00,$00,$7E,$DB,$DB,$7E,$00,$00 ; $EC
00:D930 00
00:D931 7E
00:D932 DB
00:D933 DB
00:D934 7E
00:D935 00
00:D936 00
00:D937 06              	   242:   dfb $06,$0C,$7E,$DB,$DB,$7E,$60,$C0 ; $ED
00:D938 0C
00:D939 7E
00:D93A DB
00:D93B DB
00:D93C 7E
00:D93D 60
00:D93E C0
00:D93F 38              	   243:   dfb $38,$60,$C0,$F8,$C0,$60,$38,$00 ; $EE
00:D940 60
00:D941 C0
00:D942 F8
00:D943 C0
00:D944 60
00:D945 38
00:D946 00
00:D947 78              	   244:   dfb $78,$CC,$CC,$CC,$CC,$CC,$CC,$00 ; $EF
00:D948 CC
00:D949 CC
00:D94A CC
00:D94B CC
00:D94C CC
00:D94D CC
00:D94E 00
00:D94F 00              	   245:   dfb $00,$FC,$00,$FC,$00,$FC,$00,$00 ; $F0
00:D950 FC
00:D951 00
00:D952 FC
00:D953 00
00:D954 FC
00:D955 00
00:D956 00
00:D957 30              	   246:   dfb $30,$30,$FC,$30,$30,$00,$FC,$00 ; $F1
00:D958 30
00:D959 FC
00:D95A 30
00:D95B 30
00:D95C 00
00:D95D FC
00:D95E 00
00:D95F 60              	   247:   dfb $60,$30,$18,$30,$60,$00,$FC,$00 ; $F2
00:D960 30
00:D961 18
00:D962 30
00:D963 60
00:D964 00
00:D965 FC
00:D966 00
00:D967 18              	   248:   dfb $18,$30,$60,$30,$18,$00,$FC,$00 ; $F3
00:D968 30
00:D969 60
00:D96A 30
00:D96B 18
00:D96C 00
00:D96D FC
00:D96E 00
00:D96F 0E              	   249:   dfb $0E,$1B,$1B,$18,$18,$18,$18,$18 ; $F4
00:D970 1B
00:D971 1B
00:D972 18
00:D973 18
00:D974 18
00:D975 18
00:D976 18
00:D977 18              	   250:   dfb $18,$18,$18,$18,$18,$D8,$D8,$70 ; $F5
00:D978 18
00:D979 18
00:D97A 18
00:D97B 18
00:D97C D8
00:D97D D8
00:D97E 70
00:D97F 30              	   251:   dfb $30,$30,$00,$FC,$00,$30,$30,$00 ; $F6
00:D980 30
00:D981 00
00:D982 FC
00:D983 00
00:D984 30
00:D985 30
00:D986 00
00:D987 00              	   252:   dfb $00,$76,$DC,$00,$76,$DC,$00,$00 ; $F7
00:D988 76
00:D989 DC
00:D98A 00
00:D98B 76
00:D98C DC
00:D98D 00
00:D98E 00
00:D98F 38              	   253:   dfb $38,$6C,$6C,$38,$00,$00,$00,$00 ; $F8
00:D990 6C
00:D991 6C
00:D992 38
00:D993 00
00:D994 00
00:D995 00
00:D996 00
00:D997 00              	   254:   dfb $00,$00,$00,$18,$18,$00,$00,$00 ; $F9
00:D998 00
00:D999 00
00:D99A 18
00:D99B 18
00:D99C 00
00:D99D 00
00:D99E 00
00:D99F 00              	   255:   dfb $00,$00,$00,$00,$18,$00,$00,$00 ; $FA
00:D9A0 00
00:D9A1 00
00:D9A2 00
00:D9A3 18
00:D9A4 00
00:D9A5 00
00:D9A6 00
00:D9A7 0F              	   256:   dfb $0F,$0C,$0C,$0C,$EC,$6C,$3C,$1C ; $FB
00:D9A8 0C
00:D9A9 0C
00:D9AA 0C
00:D9AB EC
00:D9AC 6C
00:D9AD 3C
00:D9AE 1C
00:D9AF 78              	   257:   dfb $78,$6C,$6C,$6C,$6C,$00,$00,$00 ; $FC
00:D9B0 6C
00:D9B1 6C
00:D9B2 6C
00:D9B3 6C
00:D9B4 00
00:D9B5 00
00:D9B6 00
00:D9B7 70              	   258:   dfb $70,$18,$30,$60,$78,$00,$00,$00 ; $FD
00:D9B8 18
00:D9B9 30
00:D9BA 60
00:D9BB 78
00:D9BC 00
00:D9BD 00
00:D9BE 00
00:D9BF 00              	   259:   dfb $00,$00,$3C,$3C,$3C,$3C,$00,$00 ; $FE
00:D9C0 00
00:D9C1 3C
00:D9C2 3C
00:D9C3 3C
00:D9C4 3C
00:D9C5 00
00:D9C6 00
00:D9C7 00              	   260:   dfb $00,$00,$00,$00,$00,$00,$00,$00 ; $FF
00:D9C8 00
00:D9C9 00
00:D9CA 00
00:D9CB 00
00:D9CC 00
00:D9CD 00
00:D9CE 00
                        	   261: 

Source: "gpascal.asm"
                        	   193:   .endif
                        	   194: 
00:D9CF 472D50617363616C	   195: introduction asc    "G-Pascal compiler, version 4.02.\n"
00:D9D7 20636F6D70696C65
00:D9DF 722C207665727369
00:D9E7 6F6E20342E30322E
00:D9EF 0A
00:D9F0 5772697474656E20	   196:              asciiz "Written by Nick Gammon.\nType H for help.\n"
00:D9F8 6279204E69636B20
00:DA00 47616D6D6F6E2E0A
00:DA08 5479706520482066
00:DA10 6F722068656C702E
00:DA18 0A
00:DA19 00
                        	   197: 
                        	   198:   .if LCD_SUPPORT
00:DA1A 4E69636B27732047	   199: LCD_welcome asciiz "Nick's G-Pascal\nCompiler v4.02"
00:DA22 2D50617363616C0A
00:DA2A 436F6D70696C6572
00:DA32 2076342E3032
00:DA38 00
                        	   200:   .endif
                        	   201: 
                        	   202: ;
                        	   203: ; here for cold start - clear text file to null etc. etc.
                        	   204: ;
                        	   205: START    =  *
00:DA39 D8              	   206:   cld             ; cancel decimal mode
00:DA3A 78              	   207:   sei             ; no interrupts yet
00:DA3B A9FF            	   208:   lda #$FF
00:DA3D 8509            	   209:   sta random      ; initialise random numbers
00:DA3F 850A            	   210:   sta random+1
00:DA41 850B            	   211:   sta random+2
00:DA43 850C            	   212:   sta random+3
                        	   213: ;
                        	   214: ;  Put 0x00 at start of source
                        	   215: ;
00:DA45 A900            	   216:   lda  #<TEXT_START
00:DA47 8500            	   217:   sta  REG
00:DA49 A903            	   218:   lda  #>TEXT_START
00:DA4B 8501            	   219:   sta  REG+1
00:DA4D A900            	   220:   lda  #0
00:DA4F A8              	   221:   tay
00:DA50 9100            	   222:   sta  (REG),Y     ; null edit file
00:DA52 84BE            	   223:   sty  system_flags
00:DA54 AA              	   224:   tax
                        	   225: ;
                        	   226: ;  now do rest of initialization
                        	   227: ;
                        	   228: RESTART  =  *
00:DA55 A2FF            	   229:   ldx  #NEW_STK
00:DA57 9A              	   230:   txs             ; reset stack
00:DA58 58              	   231:   cli             ; allow interrupts after a NMI
00:DA59 D8              	   232:   cld             ; cancel decimal mode
00:DA5A 202FC9          	   233:   jsr hardware_init
                        	   234: 
                        	   235: ;
                        	   236: REST1    =  *
                        	   237:   .if LCD_SUPPORT
                        	   238:     ;
                        	   239:     ;  put message on the LCD screen to prove it is working
                        	   240:     ;
00:DA5D A91A            	   241:     lda  #<LCD_welcome  ; G-pascal compiler
00:DA5F A2DA            	   242:     ldx  #>LCD_welcome
00:DA61 2008B9          	   243:     jsr lcd_print_message
                        	   244:   .endif
                        	   245: 
                        	   246: ;
                        	   247: ;  now direct output to the serial port
                        	   248: ;
00:DA64 2002C9          	   249:   jsr  write_to_serial   ; set up outputting function
00:DA67 A900            	   250:   lda  #0
00:DA69 853F            	   251:   sta  RUNNING
00:DA6B 4C7B82          	   252:   jmp  main_start    ; go to "shell"
                        	   253: 
                        	   254: 
                        	   255: ;
                        	   256: ;  processor hardware vectors
                        	   257: ;
                        	   258:   .org $FFFA
01:FFFA 55DA            	   259:   .word RESTART   ; non-maskable interrupt (NMI)
01:FFFC 39DA            	   260:   .word START     ; reset vector
01:FFFE 27B7            	   261:   .word irq       ; maskable interrupt (IRQ)
                        	   262: 


Symbols by name:
ACT_PCDA                         S:0025
ADD1                             E:B9F4
ADD4                             E:BA17
ADD9                             E:BA33
ADDSYM                           E:B998
ADDSYM_NOT_FULL                  A:B9CD
ASS1                             A:BE65
ASS2                             A:BEAD
ASSARR                           A:BE8C
ASSEMBLE                         A:9861
ASSEMBLE_PASS                    A:9873
ASSEMBLE_SECOND_PASS             A:986E
ASSIGN                           A:BE62
ASSTB1                           A:BE71
ASSVAR                           A:BE9E
ASS_COUNT                        S:0072
ASS_EMIT_COUNT                   S:006F
ASS_OPCODE_WORK                  S:0070
ASS_OPERAND                      S:006B
ASS_OPERAND_ABSOLUTE             E:0001
ASS_OPERAND_ABSOLUTE_INDEXED_IN  E:0002
ASS_OPERAND_ABSOLUTE_INDEXED_WI  E:0003
ASS_OPERAND_ABSOLUTE_INDEXED_WI  E:0004
ASS_OPERAND_ABSOLUTE_INDIRECT    E:0005
ASS_OPERAND_ACCUMULATOR_A        E:0006
ASS_OPERAND_IMMEDIATE            E:0007
ASS_OPERAND_IMPLIED              E:0008
ASS_OPERAND_STRING               E:0011
ASS_OPERAND_ZERO_PAGE            E:000B
ASS_OPERAND_ZERO_PAGE_AND_ABSOL  E:0012
ASS_OPERAND_ZERO_PAGE_INDEXED_I  E:000C
ASS_OPERAND_ZERO_PAGE_INDEXED_W  E:000D
ASS_OPERAND_ZERO_PAGE_INDEXED_W  E:000E
ASS_OPERAND_ZERO_PAGE_INDIRECT   E:000F
ASS_OPERAND_ZERO_PAGE_INDIRECT_  E:0010
ASS_PASS                         S:0076
ASS_VALUE                        S:0073
BACKSPACE                        E:0008
BAD_INP                          A:B32B
BASE                             S:003B
BAUD_RATE                        E:12C0
BEG                              A:C112
BELL1                            E:AEE3
BIT_INTERVAL                     E:00D0
BLCKT1                           A:C333
BLCKT2                           A:C336
BLCKT3                           A:C339
BLK1                             A:C36E
BLK1A                            A:C35A
BLK2                             A:C376
BLK4                             A:C380
BLKB1                            A:C5D6
BLKB2                            A:C5F2
BLKB3                            A:C5D0
BLKB4                            A:C60E
BLKB5                            A:C5FF
BLKB6                            A:C61D
BLKBEG                           A:C5C6
BLKCN1                           A:C38D
BLKCNS                           A:C38A
BLKFNC                           A:C4FE
BLKPR1                           A:C520
BLKPR2                           A:C552
BLKPR3                           A:C53C
BLKPR4                           A:C59A
BLKPR5                           E:C573
BLKPR6                           A:C549
BLKPRC                           A:C4DE
BLKV10                           E:C3D4
BLKV10_A                         E:C3F0
BLKV10_B                         E:C3F7
BLKV11                           A:C45E
BLKV12                           A:C465
BLKV13                           A:C41F
BLKVAR                           A:C3A1
BLKVR1                           A:C3A5
BLKVR2                           A:C406
BLKVR3                           A:C4C6
BLKVR4                           A:C424
BLKVR5                           E:C484
BLKVR6                           A:C3A8
BLKVR7                           A:C3B2
BLKVR8                           A:C3D1
BLKVR9                           E:C46B
BLOCK                            A:C343
BSAVE                            S:0036
CALL                             S:0047
CALLSB                           A:C03E
CASE                             A:C17E
CASE1                            A:C1B7
CASE2                            E:C190
CASE3                            A:C1CD
CASE4                            A:C1C3
CASE5                            A:C200
CASE6                            A:C21E
CASE7                            A:C18C
CASE8                            A:C233
CASE9                            A:C229
CHKDUP                           A:BA3F
CHKGET                           E:C30C
CHKLHB                           E:BABA
CHKLHP                           E:BAA0
CHKNOK                           E:CFA5
CHKOK                            E:CFA8
CHKRHB                           E:BAC4
CHKRHP                           E:BAA7
CHKTKN                           A:CFAA
CHK_KBD                          E:AF37
CHK_NOTD                         A:AF5F
CHK_NOTN                         A:AF43
CHK_NOTT                         A:AF51
CHK_RUN                          A:938A
CHK_STAK                         E:BBC6
CHK_VAL                          E:9377
CHK_VAL9                         E:9389
CHRIN                            E:C918
CLOCK_RATE                       E:4240
COMPIL                           A:BA4F
COMS8                            A:9259
COMS9                            A:9258
COMSTL                           E:924C
CONDEC                           E:BADF
CONST                            E:BBD2
CONST1                           A:BBE9
CONST2                           A:BBF3
CONST3                           E:BBEE
CONST9                           A:BBF7
COUNT1                           S:004B
COUNT2                           S:004C
COUT                             A:93CE
COUT_CALL                        A:93D8
CR                               E:000D
CROUT                            E:9247
DATA                             S:003D
DATTYP                           S:004A
DB11                             A:ADFC
DBGFLG                           S:0049
DCODE                            S:002E
DEBUG                            E:ADFC
DEBUG_DONE                       A:AE64
DEST                             E:0003
DIRECTIVES                       E:9FDA
DIS5                             A:AECC
DIS5_A                           E:AED6
DISHX                            A:925C
DISP9                            A:C7D8
DISPAD                           E:9262
DISPAD2                          A:927D
DISPL                            S:0027
DIVBY0                           A:B0E1
DM1                              A:ADE1
DM2                              A:ADEA
DM5                              A:AE8B
DM6                              A:AEA0
DM7                              A:AEAB
DUP9                             A:BA4E
EFLAG_ALLOW_ZERO_FROM            E:0002
EFLAG_FIND                       E:0010
EFLAG_LOAD                       E:0004
EFLAG_NO_LINE_NUMBERS            E:0080
EFLAG_REPLACE                    E:0020
EFLAG_SAVE                       E:0008
EFLAG_SHOW_LINE                  E:0001
EFLAG_SUPPRESS_NEWLINE           E:0040
EMULATOR                         E:0000
EMULATOR_DEBUG                   A:C92C
ENDSYM                           S:0031
END_CMP                          E:BA9D
END_EDITOR_INPUT                 E:001B
END_PCD                          S:0043
END_WRK                          E:C328
ERR1                             E:9796
ERR3                             E:97AA
ERR5                             E:97BA
ERR6                             E:97C0
ERR7                             E:978C
ERRLIT                           A:9777
ERRNO                            S:0035
ERROR                            A:9783
EXPR1                            A:BDEE
EXPR2                            A:BE10
EXPR3                            A:BE16
EXPR4                            A:BE1A
EXPR5                            A:BE1E
EXPR6                            A:BE22
EXPR7                            A:BE26
EXPR8                            A:BE12
EXPRES                           A:BDCB
EXPTB1                           A:BDDB
EXPTB3                           A:BDFD
EX_ABS                           A:B105
EX_ABSCLL                        E:B39A
EX_ADD                           A:B0A1
EX_ADRAC                         E:B579
EX_ADRAN                         E:B573
EX_ADRN2                         E:B568
EX_ADRNC                         E:B555
EX_ADRNC2                        E:B558
EX_ADRNN                         E:B565
EX_AND                           A:B173
EX_ASSERT                        A:B60C
EX_ASSERT_OK                     A:B621
EX_CLA                           A:B430
EX_CLL                           E:B3A1
EX_CLL2                          E:B3CB
EX_CLL3                          E:B3EC
EX_CLL4                          E:B3C7
EX_CLL5                          E:B42D
EX_CLL_A                         E:B3A9
EX_CLL_JMP                       A:B44D
EX_DEC                           A:B1B5
EX_DELAY                         E:B5C8
EX_DIGITALREAD                   E:B57F
EX_DIGITALREAD_ONE               A:B58A
EX_DIGITALWRITE                  E:B5F7
EX_DIV                           A:B0F1
EX_DIVIDE_BY_ZERO                A:B0DA
EX_EOR                           A:B17C
EX_EQL                           A:B10E
EX_FINISHD                       E:AF01
EX_GEQ                           A:B149
EX_GETKEY                        E:B0BF
EX_GTR                           A:B13D
EX_INC                           A:B19D
EX_INP                           E:B2F3
EX_INPC                          A:B4BB
EX_INPC_OK                       A:B4C5
EX_INP_OK                        A:B304
EX_INS                           E:B4F7
EX_INS1                          E:B51A
EX_INS2                          E:B523
EX_INS3                          E:B501
EX_INS4                          E:B52D
EX_INT                           A:B450
EX_INVINS                        E:AFB4
EX_JM1                           A:B4B0
EX_JMP                           A:B48C
EX_JMZ                           A:B49F
EX_LATENCY                       A:B5B9
EX_LCDCLEAR                      A:B4F1
EX_LCDHOME                       A:B4EB
EX_LCDPOS                        E:B58D
EX_LCDPOS_1                      A:B59D
EX_LCD_WRITE_CHR                 A:B4DA
EX_LCD_WRITE_HEX                 A:B34C
EX_LCD_WRITE_NUM                 A:B338
EX_LCD_WRITE_STR                 A:B36C
EX_LDA                           A:B211
EX_LDAC                          A:B206
EX_LDI                           A:B24C
EX_LDIC                          A:B246
EX_LEQ                           A:B155
EX_LIB_CALL                      A:B606
EX_LIT                           A:B086
EX_LOD                           A:B1F0
EX_LOD2                          A:B1F3
EX_LOD3                          A:B1E1
EX_LOD3_A                        A:B1E3
EX_LODC                          A:B1DE
EX_LSS                           A:B131
EX_MOD                           A:B0C6
EX_MOV                           A:B1CD
EX_MUL                           A:B0B6
EX_NEG                           A:B098
EX_NEQ                           A:B128
EX_NEW_STACK                     A:B47A
EX_NOJUMP                        A:B4AA
EX_ORR                           A:B16A
EX_OUH                           A:B347
EX_OUH_COMMON                    A:B34F
EX_OUS                           E:B367
EX_OUS1                          A:B38B
EX_OUS_COMMON                    A:B36F
EX_OUT                           A:B333
EX_OUTC                          A:B4D5
EX_OUTCR                         E:AF61
EX_OUTC_COMMON                   A:B4DD
EX_PINMODE                       E:B5E8
EX_RANDOM                        A:B5A7
EX_RANDOMSEED                    E:B5D8
EX_RTN                           A:B2BA
EX_SHL                           A:B185
EX_SHR                           A:B191
EX_STA                           A:B272
EX_STA5                          A:B283
EX_STAC                          A:B288
EX_STI                           A:B29F
EX_STIC                          A:B291
EX_STO                           A:B25F
EX_STO2                          A:B265
EX_STO5                          A:B25A
EX_STOC                          A:B252
EX_SUB                           A:B0AA
EX_XOR                           A:B161
FACAD1                           A:BD19
FACAD2                           A:BD37
FACADR                           E:BD61
FACERR1                          A:BD7A
FACM2                            A:BD95
FACMEM                           A:BD8B
FACMMC                           A:BD91
FACNOT                           A:BDA1
FACNUM                           E:BD7F
FACRND1                          A:BDAC
FACSTR                           A:BD74
FACTB1                           A:BDB2
FACTOR                           A:BCCA
FACTQT1                          A:BDB8
FALSE                            A:B124
FFLAG_GLOBAL                     E:0002
FFLAG_IGNORE_CASE                E:0001
FFLAG_QUIET                      E:0004
FIN_MSG                          A:AF18
FIXAD                            E:C821
FIXAD1                           A:C85E
FIXM1                            A:C85F
FIXM2                            A:C868
FLAG_ABORTED                     E:0080
FLAG_ASSEMBLING                  E:0002
FLAG_COMPILING                   E:0001
FLAG_LIST_SOURCE                 E:0004
FLAG_ONLY_ALPHA                  E:0040
FLAG_VALID_ASSEMBLE              E:0010
FLAG_VALID_COMPILE               E:0008
FNC1                             A:C088
FNC2                             A:C058
FNC3                             A:C082
FNC4                             A:C0CC
FNC5                             A:C08B
FNC5A                            A:C0A8
FNC5B                            A:C0AA
FNC6                             A:C0CD
FNCPRC                           A:C04B
FOR                              A:C239
FOR1                             A:C243
FOR2                             A:C250
FOR3                             A:C269
FOR4                             A:C29A
FOR5                             A:C2DD
FOR6                             A:C2FF
FRAME                            S:0020
FROM                             E:0040
GEN1                             E:C77F
GEN2                             E:C7B6
GEN2_A                           E:C7C1
GEN2_B                           E:C7B8
GEN2_C                           E:C7D8
GEN3                             E:C81C
GENADR                           E:C783
GENJMP                           E:C7F3
GENNJM                           A:C7ED
GENNJP                           E:C7EB
GENNOP                           E:C76A
GENNOP1                          A:BDA9
GENNOP2                          A:C016
GENRJMP                          E:C7D9
GEN_FULL                         A:C7D3
GET1                             A:93A8
GET1_A                           E:B00B
GET2                             E:AFCF
GET3                             A:93C5
GETADR                           A:AFC5
GETADR1                          E:AFF0
GETCHK                           A:CF9A
GETEXPR                          E:BB5E
GETID2                           A:B238
GETIDC                           A:B21B
GETIDX                           E:B224
GETIN                            E:C918
GETIN1                           A:C922
GETLIT                           E:B06F
GETLN1                           E:93A6
GETLN_OVERFLOW                   A:93CB
GETO_1                           E:BB4F
GETO_2                           E:BB5C
GETSUB                           E:BAB1
GET_COMM                         E:BB90
GET_DAT                          E:BAD8
GET_END                          A:B085
GET_ITEM                         E:BB97
GET_LEV                          E:BACE
GET_LINE                         E:93A6
GET_LOOK                         A:CFAF
GET_OFF                          E:BB33
HIGHEST_RAM                      E:3FFF
I2C_DDR                          E:7FF3
I2C_PORT                         E:7FF1
I2C_SCL                          E:0004
I2C_SDA                          E:0008
IDENT                            A:BCDB
IDENT1                           A:BCDE
IDENT1A                          A:BCE6
IDENT2                           A:BCEB
IDENT2A                          A:BD04
IDENT3                           A:BD0B
IDENT4                           A:BD3F
IDENT4_A                         A:BD41
IDENT5                           A:BD21
IDENT5_A                         A:BD23
IDENT6                           A:BD2E
IDENT7                           A:BD34
IF                               A:C0D2
IF1                              A:C0F7
IF2                              A:C0F0
INBUF                            S:0200
INBUF_SIZE                       E:0100
INIT                             E:91F9
INIT9                            A:9246
INIT_SECOND_PASS                 A:9205
INP3                             A:B31B
INTERP                           E:AE65
INT_ERR                          E:B467
INT_ERRM                         A:B46E
JMP1                             E:8FB9
JMP2                             E:8FC1
JMP3                             E:8FD6
KEY_ABORT                        E:0003
KEY_DEBUG                        E:0004
KEY_STOP_TRACE                   E:000E
KEY_TRACE                        E:0014
LASTP                            S:004D
LCD_E                            E:0080
LCD_RS                           E:0020
LCD_RW                           E:0040
LCD_SUPPORT                      E:0001
LCD_welcome                      A:DA1A
LEVEL                            S:0022
LINE_CNT                         S:0019
LIST                             S:001D
LIT1                             A:B095
LOOK1                            A:BA3E
LOOKUP                           E:BA34
LOWLIT                           A:AF67
LOWLIT1                          A:AF6D
MAIN                             A:AF76
MAINP                            A:AF73
MAIN_1                           E:AFA5
MAIN_2                           E:AF7D
MAIN_NOT_ABORT                   E:AF88
MAIN_OK                          E:AF8B
MAKE_LOWER_DONE                  E:8FF8
MAKE_UPPER                       E:8FE3
MAKE_UPPER_DONE                  E:8FED
MAX_STK                          E:0020
MEM                              A:C023
MEM2                             A:C02B
MEMC                             A:C028
NEW_STK                          E:00FF
NL                               E:000A
NOSCE                            A:91E8
NOTIM1                           E:AFB8
OFFSET                           S:0029
ONE_OP                           A:C00F
ONE_OP2                          A:C00C
OPCODE                           S:006C
OPCODE_3_CHAR_BRANCH             E:A09E
OPCODE_3_CHAR_IMPLIED            E:A0C3
OPCODE_4_CHAR_BRANCH             E:A04D
OPCODE_4_CHAR_ZERO_PAGE          E:A140
OPCODE_ASS_OPERAND_ABSOLUTE      E:A191
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A1FD
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A202
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A247
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A24A
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A26F
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A28B
OPCODE_ASS_OPERAND_ABSOLUTE_TOK  E:A1FA
OPCODE_ASS_OPERAND_ACCUMULATOR_  E:A272
OPCODE_ASS_OPERAND_IMMEDIATE     E:A290
OPCODE_ASS_OPERAND_IMMEDIATE_TO  E:A2C1
OPCODE_ASS_OPERAND_ZERO_PAGE     E:A2C4
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A328
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A349
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A34C
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A395
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A398
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A3A1
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A3C5
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A3E6
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A3C2
OPCODE_ASS_OPERAND_ZERO_PAGE_TO  E:A325
OPCODE_LEN                       S:006E
OPCODE_LOOKUP_HANDLER            E:0004
OPCODE_LOOKUP_OPCODE_LENGTH      E:0000
OPCODE_LOOKUP_OPCODE_TABLE       E:0002
OPCODE_LOOKUP_OPERAND_TYPE       E:0001
OPCODE_LOOKUP_TABLE              E:9F37
OPCODE_LOOKUP_TABLE_SIZE         E:0006
OPND                             S:002B
OUT_COMMON                       A:B33B
PAREN                            A:BD85
PCD_WRKD                         E:BB64
PCODE                            S:0023
PCODE_ABSCLL                     E:0038
PCODE_ADD                        E:0004
PCODE_ADRAN                      E:000E
PCODE_ADRNN                      E:000C
PCODE_AND                        E:001B
PCODE_CLA                        E:002B
PCODE_CLL                        E:0027
PCODE_DEC                        E:0028
PCODE_DIV                        E:000A
PCODE_EOR                        E:0020
PCODE_EQL                        E:0010
PCODE_FINISHD                    E:0011
PCODE_GEQ                        E:0016
PCODE_GTR                        E:0018
PCODE_INC                        E:0026
PCODE_INP                        E:001C
PCODE_INS                        E:0025
PCODE_INT                        E:003B
PCODE_JM1                        E:003E
PCODE_JMP                        E:003C
PCODE_JMZ                        E:003D
PCODE_LAST                       E:0045
PCODE_LCD_WRITE_CHR              E:0045
PCODE_LCD_WRITE_HEX              E:0044
PCODE_LCD_WRITE_NUM              E:0042
PCODE_LCD_WRITE_STR              E:0043
PCODE_LDA                        E:002E
PCODE_LDI                        E:0030
PCODE_LEQ                        E:0019
PCODE_LIB_CALL                   E:0003
PCODE_LIT                        E:0000
PCODE_LOD                        E:002C
PCODE_LSS                        E:0014
PCODE_MOD                        E:000B
PCODE_MOV                        E:002A
PCODE_MUL                        E:0008
PCODE_NEG                        E:0002
PCODE_NEQ                        E:0012
PCODE_ORR                        E:001A
PCODE_OUH                        E:0021
PCODE_OUS                        E:0023
PCODE_OUT                        E:001E
PCODE_OUTC                       E:001F
PCODE_OUTCR                      E:0040
PCODE_RTN                        E:0029
PCODE_SHL                        E:0022
PCODE_SHR                        E:0024
PCODE_STA                        E:0034
PCODE_STACK                      E:0001
PCODE_STI                        E:0036
PCODE_STO                        E:0032
PCODE_SUB                        E:0006
PCODE_XOR                        E:003A
PRBYTE                           A:92BC
PRBYTECR                         E:9371
PRCHAR                           E:92A4
PRCITM                           S:0039
PRHEX                            A:92C5
PRHEX1                           A:92CF
PRHEXZ                           A:92C7
PSH1                             E:B05E
PSH9                             A:9290
PSHPCODE                         E:BB20
PSHTOP                           E:B053
PSHWRK                           E:927E
PT                               A:92D6
PT6                              A:92DE
PUL2_END                         E:B04C
PULBOTH                          A:B02E
PULTOP                           E:B00C
PULTOP2                          E:B031
PULWRK                           E:9291
PUL_END                          E:B027
PUTSP                            E:92D2
READ                             A:BF7A
READ11                           A:BF9A
READ2                            A:BF80
READ3                            A:BFC9
READ3_A                          A:BFF8
READ3_B                          A:BFDD
READ7                            A:BFB9
READ7_A                          A:BFBF
READ8                            A:BF7D
READ9                            A:BF97
REG                              E:0000
REG2                             E:0003
REG2B                            E:0005
REGB                             E:0002
REMAIN                           S:0006
REP1                             A:C12B
REPEAT                           A:C128
RES                              S:0052
RESTART                          E:DA55
RMNDR                            S:005B
RSVEND                           A:CF44
RSVWRD                           E:CE51
RUNERR                           A:AEED
RUNNING                          S:003F
SEA1                             E:B92F
SEA2                             E:B93C
SEA3                             E:B990
SEA4                             E:B985
SEA5                             E:B98D
SEARCH                           E:B91C
SEA_NEXT                         E:B924
SERIAL_DEBUG1_MASK               E:0004
SERIAL_DEBUG2_MASK               E:0008
SERIAL_DEBUGGING                 E:0000
SERIAL_DELAY1                    E:0030
SERIAL_DELAY2                    E:0023
SERIAL_OUT_MASK                  E:0002
SERIAL_SPARE2_MASK               E:0010
SIM1                             A:BC14
SIM2                             A:BC5C
SIM3                             A:BC25
SIM4                             A:BC38
SIM5                             A:BC54
SIM6                             A:BC58
SIM7                             A:BC4E
SIM8                             A:BC62
SIMEXP                           E:BC0A
SINGLE_QUOTE                     E:0027
SPI_DDR                          E:7FF2
SPI_MISO                         E:0004
SPI_MOSI                         E:0002
SPI_PORT                         E:7FF0
SPI_SCK                          E:0008
SPI_SS                           E:0001
SRCE                             E:0000
START                            E:DA39
STARTSYM                         S:002F
START_OF_ROM                     E:8000
START_TRACE                      A:C92D
STK_ERR                          A:BBCD
STK_FULL                         E:BBCD
STMNT                            A:BE2A
STMNT1                           A:BE37
STMNT_WRITE_LCD                  A:BF29
STOP_TRACE                       A:C92E
ST_SYMTBL_LIST_CHECK             E:8DAA
ST_SYMTBL_LIST_DONE              E:8E3F
ST_SYMTBL_LIST_LINE              E:8DB9
ST_SYMTBL_LIST_NAME              E:8E2E
ST_SYMTBL_LIST_NEXT              E:8D9F
SYMARG                           E:0006
SYMBOL_ARRAY                     E:0041
SYMBOL_CONSTANT                  E:0043
SYMBOL_FUNCTION                  E:0046
SYMBOL_FUNCTION_RETURN           E:0059
SYMBOL_LIBRARY_FUNCTION          E:0052
SYMBOL_LIBRARY_PROCEDURE         E:0051
SYMBOL_PROCEDURE                 E:0050
SYMBOL_TABLE_START               E:3FFF
SYMBOL_VARIABLE                  E:0056
SYMDAT                           E:0008
SYMDSP                           E:0004
SYMITM                           S:0040
SYMLEN                           E:0009
SYMLVL                           E:0002
SYMNAM                           E:000A
SYMPRV                           E:0000
SYMSUB                           E:0006
SYMTYP                           E:0003
SYMWRK                           E:BB0A
SYM_FULL                         A:B993
SYNTAX                           S:0042
T                                E:0031
TEMP                             S:0045
TERM                             A:BC7C
TERM1                            A:BC89
TERM2                            A:BC7F
TERM3                            A:BC9A
TERM4                            A:BC98
TERM5                            A:BCA0
TERM6                            A:BCA4
TERM7                            A:BCA8
TERM8                            A:BCAC
TERM9                            A:BCB0
TERMT1                           A:BC66
TERMT3                           A:BCB4
TEXT_START                       E:0300
TKNJMP                           E:8FB1
TKNWRK                           E:92E8
TOKEN_ADDRESS                    E:00A9
TOKEN_AND                        E:008D
TOKEN_ARRAY                      E:0084
TOKEN_ASSIGN                     E:0041
TOKEN_BEGIN                      E:0088
TOKEN_CALL                       E:009F
TOKEN_CASE                       E:0095
TOKEN_CHAR                       E:00A1
TOKEN_CHR                        E:00AB
TOKEN_CONST                      E:0082
TOKEN_DIV                        E:008B
TOKEN_DO                         E:0097
TOKEN_DOWNTO                     E:009C
TOKEN_ELSE                       E:0094
TOKEN_END                        E:0089
TOKEN_EQUALITY                   E:0045
TOKEN_FOR                        E:009A
TOKEN_FUNCTION                   E:0087
TOKEN_GEQ                        E:0081
TOKEN_HEX                        E:00AC
TOKEN_HIGH_BYTE                  E:0057
TOKEN_IDENTIFIER                 E:0049
TOKEN_IF                         E:0092
TOKEN_INEQUALITY                 E:005A
TOKEN_INTEGER                    E:00FE
TOKEN_LCDWRITE                   E:00F1
TOKEN_LEQ                        E:0080
TOKEN_LOGICAL_AND                E:0058
TOKEN_LOGICAL_OR                 E:0059
TOKEN_LOW_BYTE                   E:0056
TOKEN_MEM                        E:0091
TOKEN_MEMC                       E:00A2
TOKEN_MOD                        E:008C
TOKEN_NEQ                        E:0055
TOKEN_NOT                        E:0090
TOKEN_NUMBER                     E:004E
TOKEN_OF                         E:0085
TOKEN_OR                         E:008A
TOKEN_PROCEDURE                  E:0086
TOKEN_READ                       E:009E
TOKEN_REPEAT                     E:0098
TOKEN_SHIFT_LEFT                 E:004C
TOKEN_SHIFT_RIGHT                E:0052
TOKEN_SHL                        E:008E
TOKEN_SHR                        E:008F
TOKEN_STRING                     E:0022
TOKEN_THEN                       E:0093
TOKEN_TO                         E:009B
TOKEN_UNARY_MINUS                E:004D
TOKEN_UNTIL                      E:0099
TOKEN_VAR                        E:0083
TOKEN_WHILE                      E:0096
TOKEN_WRITE                      E:009D
TOKEN_WRITELN                    E:00FF
TOKEN_XOR                        E:00A4
TRUE                             A:B117
TRUE2                            A:B119
TWO_OP                           A:C006
USE_CP437_FONT                   E:0001
VALUE                            S:0000
VALUE2                           S:0003
VAL_1                            E:BBA6
VAL_2                            E:BBAB
VAL_3                            E:BBB4
VAL_5                            E:BBBD
VAL_MOVE                         E:BB9D
VAL_WRK                          E:C31D
VARDEC                           A:BBF8
VIA_ACR                          E:7FFB
VIA_DDRA                         E:7FF3
VIA_DDRB                         E:7FF2
VIA_FLAG_CB2                     E:0008
VIA_FLAG_DISABLE                 E:0000
VIA_FLAG_ENABLE                  E:0080
VIA_FLAG_TIMER1                  E:0040
VIA_IER                          E:7FFE
VIA_IFR                          E:7FFD
VIA_PCR                          E:7FFC
VIA_PORTA                        E:7FF1
VIA_PORTB                        E:7FF0
VIA_T1C_H                        E:7FF5
VIA_T1C_L                        E:7FF4
WAIT_1                           A:C019
WHILE                            A:C14C
WORK                             S:0037
WORKD                            S:0033
WRIT1                            E:BF04
WRIT10                           A:BEF7
WRIT2                            A:BEF4
WRIT5                            A:BF14
WRIT9                            A:BEDB
WRITE                            A:BED8
WRITELN                          A:BEC9
WRITELN9                         E:BED3
WRITE_LCD1                       E:BF55
WRITE_LCD2                       A:BF45
WRITE_LCD5                       A:BF65
WRITE_LCD9                       A:BF2C
WRITE_LCD_STRING                 E:BF3B
WRITE_LDC_CHR                    E:BF6E
WRITE_LDC_CHR1                   E:BF70
WRITE_LDC_HEX                    E:BF76
WRKD_WRK                         E:BB7A
WRKSYM                           E:BB15
WRKTKN                           E:92F3
WRK_OPND                         E:BB6F
WRK_VAL                          E:C312
WRK_WRKD                         E:BB85
W_CHR                            E:BF1D
W_CHR1                           E:BF1F
W_HEX                            E:BF25
W_STRING                         E:BEEA
ZERRES                           A:AC77
a_equals_message                 A:B63F
add_assembler_library_functions  A:AA93
add_assembler_library_functions  A:AADD
add_assembler_library_functions  A:AA9B
add_assembler_library_functions  A:AAAB
add_pascal_library_functions     A:C6C0
add_pascal_library_functions_do  A:C719
add_pascal_library_functions_lo  A:C6C8
add_pascal_library_functions_na  A:C6D8
asm_do_asc                       E:A44E
asm_do_asc_loop                  A:A45B
asm_do_asc_next                  A:A464
asm_do_asc_ok                    A:A459
asm_do_assert                    A:A3E9
asm_do_assert_failed             A:A3F8
asm_do_blk                       A:A520
asm_do_blk_done                  A:A53D
asm_do_blk_loop                  A:A530
asm_do_constant_expected         A:A495
asm_do_constant_expectedJ        A:A3FD
asm_do_constant_expectedJ2       A:A556
asm_do_dfb                       A:A4A3
asm_do_dfb_multiple              A:A4B1
asm_do_dfb_multiple_done         A:A4CF
asm_do_dfb_multiple_loop         A:A4BE
asm_do_dfb_too_big               A:A4D0
asm_do_dfw                       A:A4E3
asm_do_dfw_multiple              A:A4F1
asm_do_dfw_multiple_done         A:A510
asm_do_dfw_multiple_loop         A:A4FF
asm_do_equ                       A:A472
asm_do_equ_have_label            A:A483
asm_do_list                      E:A400
asm_do_list1                     A:A43E
asm_do_list_first_pass           A:A44D
asm_do_list_no_operand           A:A420
asm_do_list_not                  A:A43A
asm_do_list_ok                   A:A424
asm_do_nolist                    A:A40F
asm_do_nolist_ok                 A:A41A
asm_do_org                       A:A48F
asm_do_org_ok                    A:A49A
asm_do_reserve                   A:A53E
asm_do_string                    A:A469
asm_do_sym                       A:A559
asm_do_sym_done                  A:A572
asm_emit_one_byte                A:A4D5
asm_emit_two_bytes               A:A511
ass_absolute_another_value       A:9ADE
ass_added_symbol                 A:991B
ass_already_emitted              A:9EA8
ass_bad_identifier               A:98D6
ass_bad_indirect                 A:9A45
ass_bad_zp_indirect_indexed      A:9A7F
ass_branch_backwards             A:9EF3
ass_branch_ok                    A:9EF7
ass_branch_out_of_range          A:9EFD
ass_check_label_changed          A:9985
ass_check_no_more_tokens         A:9BD9
ass_check_no_more_tokens_ok      A:9BE4
ass_check_we_have_x_or_y         A:9A86
ass_check_we_have_x_or_y_ok      A:9AA2
ass_current_label                S:0083
ass_done                         A:9B96
ass_done1                        A:9BB8
ass_done_jump                    A:9898
ass_done_message                 A:9BBB
ass_done_second_pass             A:9BA0
ass_emit                         A:9E85
ass_emit1                        A:9EC0
ass_emit2                        A:9E99
ass_emit3                        A:9EBA
ass_emit4                        A:9EB3
ass_emit_absolute                A:9F2C
ass_emit_bytes                   S:0077
ass_emit_immediate               A:9F19
ass_emit_immediate_too_high      A:9F27
ass_emit_zero_page               A:9F06
ass_emit_zero_page_too_high      A:9F14
ass_error                        A:9EC3
ass_error1                       A:9ECA
ass_evaluate_operator            A:9E5E
ass_expression_apply_operator    A:9E1D
ass_expression_apply_operator_b  A:9E59
ass_expression_cannot_be_unary   A:9DC9
ass_expression_found_value       A:9D57
ass_expression_loop              A:9D0A
ass_expression_loop1             A:9D3B
ass_expression_loop1a            A:9D24
ass_expression_loop2             A:9D68
ass_expression_loop3             A:9D77
ass_expression_loop3a            A:9D86
ass_expression_loop3b            A:9D7B
ass_expression_loop3c            A:9D8B
ass_expression_loop4             A:9D91
ass_expression_loop6             A:9DEF
ass_expression_loop7             A:9DD8
ass_expression_loopJ             A:9D8E
ass_expression_loop_initial      A:9D0D
ass_expression_not_small_string  A:9D36
ass_expression_number            A:9D11
ass_expression_unary             A:9E46
ass_finish_line                  A:988D
ass_finish_lineJ                 A:99AB
ass_fixup_bbr_branch             A:9ECD
ass_fixup_branch                 A:9EDA
ass_get_value                    A:9CF0
ass_identifier                   A:98DB
ass_identifier_operand           A:99E9
ass_illegal_opcode               A:993C
ass_immediate                    A:99CD
ass_indexed                      A:9AB7
ass_indexed_x                    A:9AD5
ass_indirect                     A:99E0
ass_indirect_with_bracket        A:9A4A
ass_label_not_found_yet          A:9D4F
ass_line                         A:989B
ass_line1                        A:98AA
ass_lookup_existing_label        A:9905
ass_lookup_loop                  A:9E61
ass_lookup_save_address          A:990F
ass_not_colon                    A:992D
ass_not_colon2                   A:9934
ass_not_unary_greater_than       A:9DB3
ass_not_unary_less_than          A:9DA9
ass_not_unary_minus              A:9D9F
ass_not_x_or_y                   A:9A84
ass_opcode                       A:9944
ass_opcode2                      A:999A
ass_opcode_found                 A:9E7F
ass_operand                      A:99AE
ass_operand_value                A:9A0A
ass_string                       A:99C0
ass_symbol_address_changed       A:9995
ass_value_done                   A:9AAE
ass_value_not_indirect           A:9AA4
ass_value_not_indirectJ          A:9A42
ass_zp_indirect_indexed          A:9A5E
assembler_library_functions_tab  A:A5D3
assertion_failed_message         A:973D
assign_bad_identifier            A:BE87
atoi                             A:CA87
atoi_error                       E:CAF6
atoi_loop                        E:CA90
atoi_more                        E:CAA1
atoi_not_running                 E:CAFC
atoi_positive                    A:CA9F
bad_command                      A:8258
bad_delimiter_message            A:8691
bad_flag_message                 A:87FB
bcd_output_digit                 A:918F
bcd_positive                     A:917D
bcd_result                       S:0060
bcd_skip_zeroes                  A:9184
bcd_table                        E:9111
bcd_unpack                       A:90FE
bcd_work                         S:005C
binary_to_decimal                A:919A
binary_to_decimal_loop           A:91A5
binary_to_decimal_next           A:91CA
break_message                    A:B624
brk_address                      S:0015
brk_executed                     A:B670
brk_executed1                    A:B6EB
brk_executed2                    A:B6F8
brk_executed3                    A:B708
brk_executedJ                    A:B724
brk_resumed                      A:8CA4
bytes_message                    A:909A
call_a                           S:0010
call_assembler                   A:939C
call_handler                     A:8F69
call_p                           S:0013
call_s                           S:0014
call_x                           S:0011
call_y                           S:0012
cb2_interrupt                    A:B74C
character_types_table            E:8006
compile_finished_message         A:9311
cp437_font                       A:D1CF
crc16                            E:901C
crc16_loop                       E:9028
crc16_next                       A:9035
crc16_skip                       A:903B
crc_addr                         E:0000
crc_byte                         E:9044
crc_done                         A:9043
crc_helper1                      A:9074
crc_message                      A:9077
crc_num                          E:0003
crc_source                       E:90A2
crc_val                          E:0006
current_line                     S:00A2
delay                            E:90F4
delay_1ms                        E:90EA
delay_1ms_loop                   A:90ED
digitalread                      E:C8E5
digitalread_B                    A:C8F4
digitalread_C                    A:C8FC
digitalwrite                     E:C8B6
digitalwrite_B                   A:C8C7
digitalwrite_C                   A:C8CF
digitalwrite_ONE                 A:C8DD
display_in_decimal               E:9171
display_x_characters             A:AEC5
editor_argument_check            A:8B55
editor_argument_check_failed     A:8B67
editor_argument_check_got_argum  A:8B71
editor_argument_check_loop       A:8B57
editor_assemble                  A:8F23
editor_bad_delimiter             A:86A0
editor_bad_number                A:8526
editor_bad_range                 A:85E1
editor_bad_rangeJ                A:867A
editor_check_no_more             A:860E
editor_check_no_more_failed      A:8620
editor_check_no_more_loop        A:8610
editor_check_no_more_ok          A:862A
editor_compile                   A:8EA4
editor_debug                     A:8E7D
editor_default_range             A:8508
editor_delete                    A:8B72
editor_delete_line_count_done    A:8BE0
editor_delete_line_count_loop    A:8BC0
editor_delete_line_count_not_do  A:8BCC
editor_delete_line_count_not_ne  A:8BD8
editor_do_replace                A:8970
editor_do_replace_copy_done      A:89B5
editor_do_replace_smaller        A:89B2
editor_do_the_replace            A:88D6
editor_easy_replace              A:88E3
editor_easy_replace_done         A:88F4
editor_easy_replace_loop         A:88E7
editor_find                      A:8725
editor_find_bug                  A:8763
editor_find_case_sensitive       A:8894
editor_find_found_it             A:88B8
editor_find_found_it1            A:88BE
editor_find_get_flags            A:87BD
editor_find_inner_loop           A:887D
editor_find_loop                 A:8879
editor_find_no_match             A:88A2
editor_find_or_replacing         A:8875
editor_find_problem              A:86A4
editor_find_second_delimiter_lo  A:8770
editor_find_skip_this            A:889E
editor_find_test_character       A:8895
editor_find_third_delimiter_loo  A:8797
editor_flags                     S:00BC
editor_flags1                    A:87DD
editor_flags2                    A:87E7
editor_flags3                    A:87F1
editor_flags_loop                A:87BF
editor_get_delimiter             A:86CE
editor_get_number                A:8530
editor_get_number_done           A:8598
editor_get_number_end            A:859C
editor_get_number_none           A:859A
editor_get_number_not_identifie  A:8572
editor_get_number_ok             A:8588
editor_get_range                 A:862B
editor_get_range_done            A:8679
editor_get_range_hyphen          A:8661
editor_get_range_number          A:8666
editor_handlers                  A:82E6
editor_help                      A:84E9
editor_help_done                 A:8505
editor_help_info                 A:8374
editor_help_loop                 A:84F4
editor_info                      E:8E95
editor_insert                    A:89E4
editor_insert_at_start           A:89FE
editor_insert_backspace          A:8A98
editor_insert_backspace_not_at_  A:8AA4
editor_insert_common             A:8A0C
editor_insert_done               A:8ABA
editor_insert_done_with_newline  A:8ACB
editor_insert_loop               A:8A4F
editor_insert_loop1              A:8A88
editor_insert_no_line_number     A:8A60
editor_insert_not_newline        A:8A7F
editor_line_number_too_big       A:85C8
editor_list                      A:8731
editor_list_aborted              A:8868
editor_list_check_to_line        A:8924
editor_list_check_to_line_ok     A:8934
editor_list_completely_done      A:896D
editor_list_doing_find           A:8757
editor_list_done                 A:8950
editor_list_doneJ                A:883B
editor_list_fix_target_string    A:8809
editor_list_fixup_loop           A:8811
editor_list_get_on_with_it       A:8824
editor_list_got_from_point       A:876E
editor_list_have_source          A:8835
editor_list_loop                 A:8841
editor_list_loopJ                A:894D
editor_list_no_line_number       A:8912
editor_list_no_line_numberJ      A:883E
editor_list_not_find             A:8821
editor_list_not_finding          A:8905
editor_list_not_newline          A:893C
editor_list_skip_newline         A:8947
editor_load                      A:89E0
editor_memory                    A:8CCA
editor_memory_aborted            A:8D40
editor_memory_ascii              A:8D48
editor_memory_done               A:8D3D
editor_memory_loop               A:8CE4
editor_memory_loop1              A:8D05
editor_memory_loop2              A:8D17
editor_memory_loop3              A:8D2D
editor_memory_not_control        A:8D50
editor_memory_not_high           A:8D56
editor_memory_show_ascii         A:8D46
editor_memory_show_dot           A:8D54
editor_newline_processing        A:891A
editor_no_closing_delimiter      A:86FC
editor_no_closing_delimiterJ     A:876B
editor_no_closing_delimiter_mes  A:86E6
editor_no_find_string            A:8717
editor_no_lines                  A:8AFE
editor_recover                   A:8E54
editor_recover_not_needed        A:8E73
editor_replace                   A:871D
editor_replacement_loop          A:8877
editor_run                       A:8EB8
editor_save                      A:872B
editor_syntax                    A:8EAE
editor_test                      A:8CB8
editor_too_full                  A:8AE6
editor_too_full_loop             A:8AED
editor_trace                     A:8E89
error1                           A:97DA
error_find_next                  A:97D1
error_found                      A:97FB
error_loop                       A:97CD
error_next                       A:97CC
error_not_found                  A:97E3
error_not_found_message          A:9808
errors_table                     A:93DB
ex_input_aborted                 A:B54E
execution_aborted_message        A:B53A
execution_address_table          E:AD55
exp_abs_val                      A:AC47
exp_abs_val2                     A:AC5F
exp_abs_val2_done                A:AC76
exp_abs_val_done                 A:AC5E
exp_add                          A:AADE
exp_bitwise_and                  A:AB81
exp_bitwise_or                   A:AB6C
exp_bitwise_xor                  A:AB96
exp_divide                       A:ACE5
exp_divide_loop                  A:AD02
exp_divide_not_zero              A:ACF5
exp_divide_subtraction_negative  A:AD2A
exp_divide_subtraction_positive  A:AD2B
exp_done                         A:9E00
exp_done_error                   A:9E06
exp_done_ok                      A:9E0B
exp_eql                          A:AB18
exp_evaluation_function          S:007F
exp_false                        A:AB11
exp_falseJ                       A:ABAE
exp_find_sign                    A:AC80
exp_fix_sign                     A:AC98
exp_fix_sign_done                A:ACAB
exp_geq                          A:AB65
exp_get_operator                 A:9C5B
exp_get_operator_ok              A:9C64
exp_get_precedence               A:9CC9
exp_get_precedence_found         A:9CDF
exp_get_precedence_loop          A:9CCB
exp_greater_than                 A:AB47
exp_high_byte                    A:AC3E
exp_leq                          A:AB56
exp_less_than                    A:AB40
exp_logical_and                  A:ABC0
exp_logical_or                   A:ABB1
exp_low_byte                     A:AC39
exp_modulo                       A:AD45
exp_multiply                     A:ACAC
exp_multiply_loop                A:ACB1
exp_multiply_no_add              A:ACD2
exp_negate                       A:AC04
exp_negate_val                   A:AC4B
exp_negate_val2                  A:AC63
exp_neq                          A:AB2C
exp_no_operators_left            A:9DF7
exp_not                          A:AC17
exp_operator                     S:007D
exp_operator_precedence          S:007E
exp_operator_stack_count         S:007C
exp_pop_operator                 A:9C4B
exp_pop_operator_ok              A:9C54
exp_pop_value                    E:9C10
exp_pop_value_ok                 A:9C19
exp_precedence_table             A:9C69
exp_precedence_table_end         E:9CC9
exp_push_operator                A:9C39
exp_push_operator_ok             A:9C44
exp_push_value                   E:9BE5
exp_push_value_memory_full       A:9BEB
exp_push_value_not_full          A:9BFF
exp_push_value_ok                A:9BF0
exp_shift_left                   A:ABD2
exp_shift_left_done              A:ABEA
exp_shift_left_loop              A:ABE1
exp_shift_right                  A:ABEB
exp_shift_right_done             A:AC03
exp_shift_right_loop             A:ABFA
exp_subtract                     A:AAF2
exp_true                         A:AB08
exp_trueJ                        A:ABAB
exp_unary_minus                  A:AC25
exp_unary_ok                     S:0081
exp_value_stack                  S:0079
exp_value_stack_count            S:007B
find_count                       S:00B9
find_delimiter                   S:00B4
find_flags                       S:00BD
find_from                        S:00B0
find_len                         S:00B3
find_line                        A:8C53
find_line_eof                    A:8C86
find_line_loop                   A:8C61
find_line_next                   A:8C70
find_line_same_line              A:8C7E
find_pos                         S:00B2
find_source_end                  A:8C87
find_source_end_done             E:8CA3
find_source_end_loop             E:8C8F
find_source_end_wrap             E:8C9D
find_string_too_long             A:86C8
find_string_too_longJ            A:8768
find_string_too_long_message     A:86AA
find_to                          S:00B1
found_message                    A:867D
found_this_line                  S:00BB
from_line                        S:009E
from_msg                         A:8685
gc_alpha_alpha_only              A:CA18
gc_alpha_done                    A:CA14
gc_alpha_loop                    A:C9FB
gc_alpha_ok                      A:CA03
gc_ampersand                     A:CE0D
gc_assembler_comment_find_end    A:CC1C
gc_assembler_comment_keep_looki  A:CC2E
gc_assembler_comment_not_eof     A:CC27
gc_assign                        A:CDA9
gc_backslash_tokens              A:CC36
gc_backslash_tokens_end          E:CC4C
gc_backslash_tokens_length       E:0016
gc_bang                          A:CE40
gc_bar                           A:CE1E
gc_binary_literal                A:CD80
gc_binary_loop                   A:CD88
gc_colon                         A:CD9E
gc_comment_found_end             A:CBB5
gc_comment_keep_looking          A:CBAD
gc_comment_not_eof               A:CB95
gc_comment_not_newline           A:CB9E
gc_directive_list                A:CBFD
gc_directive_nolist              A:CC0A
gc_directive_pcodes              A:CC04
gc_directive_symbols             A:CBC5
gc_directive_symbols_ok          A:CBD1
gc_directive_symbols_too_late    A:CBF8
gc_dollar                        A:CD1A
gc_done                          A:C9DE
gc_equality                      A:CE3A
gc_equals                        A:CE2F
gc_fix_hex                       A:CCDE
gc_fix_hex_not_a_to_f            A:CCE7
gc_geq                           A:CDE2
gc_greater_than                  A:CDD2
gc_hex_done                      A:CD6A
gc_hex_literal                   A:CD26
gc_hex_loop                      A:CD2F
gc_hex_too_big                   A:CD6F
gc_inequality                    A:CE4B
gc_leq                           A:CDC3
gc_less_than                     A:CDAF
gc_lh_brace                      A:CB59
gc_lh_paren                      A:CB5D
gc_logical_and                   A:CE18
gc_logical_or                    A:CE29
gc_minus                         A:CDEC
gc_neq                           A:CDC8
gc_newline                       A:C9BB
gc_newline1                      A:C9C8
gc_newline_assembling            A:C9D5
gc_not_alpha                     A:CA21
gc_not_digit                     A:CA2D
gc_not_space                     A:C9F6
gc_pascal_comment                A:CB6B
gc_pascal_comment_find_end       A:CB8A
gc_percent                       A:CD74
gc_plus                          A:CDEE
gc_quote                         A:CC4C
gc_quote_backslash_loop          A:CCB5
gc_quote_bad                     A:CC63
gc_quote_bad_string              A:CCC0
gc_quote_copied_value            A:CC88
gc_quote_done                    A:CC91
gc_quote_found_backslash_charac  A:CCC9
gc_quote_hex_character           A:CCEB
gc_quote_hex_character_done      A:CCC5
gc_quote_hex_character_one_only  A:CD17
gc_quote_long_string             A:CC7D
gc_quote_loop                    A:CC5A
gc_quote_loop_not_end_of_line    A:CC68
gc_quote_not_backslash           A:CCCD
gc_quote_not_finished            A:CCA3
gc_quote_too_long                A:CCD9
gc_semicolon                     A:CC13
gc_shift_left                    A:CDCD
gc_shift_right                   A:CDE7
gc_single_byte_already_known     A:C9DA
gc_single_byte_already_knownJ    A:CB56
gc_single_byte_already_knownJ2   A:CDDF
gc_single_byte_token             A:C9DC
gc_single_byte_tokenJ            A:CB53
gc_skip_spaces                   A:C9A6
gen_random                       A:8FF9
gen_random1                      A:901B
get_token                        A:C998
get_token_loop                   A:C99C
gtoken_directive_table           A:CB46
gtoken_table                     A:CB15
handlerLookup                    A:8F29
handler_find_length              A:8F31
handler_found_directive          A:8F57
handler_found_length             A:8F3A
handler_loop                     A:8F2B
handler_next                     A:8F3E
handler_same_length              A:8F4E
handlers_done                    A:8F67
hardware_init                    A:C92F
hardware_work                    S:008C
i2c_begin_transmission           A:CFE3
i2c_begin_transmission_loop      A:CFE7
i2c_delay                        A:CFC4
i2c_end_transmission             A:D0A6
i2c_init                         A:CFB9
i2c_read                         A:D050
i2c_read_ack_or_nak              A:D08D
i2c_read_ack_or_nak_wait         A:D092
i2c_read_done                    A:D0A4
i2c_read_loop                    A:D059
i2c_read_nak                     A:D088
i2c_read_next                    A:D072
i2c_read_zero                    A:D06E
i2c_receive                      A:D0E8
i2c_receive_done                 A:D10B
i2c_receive_fail                 A:D110
i2c_receive_loop                 A:D0F6
i2c_send                         A:D0BF
i2c_send_done                    A:D0DE
i2c_send_fail                    A:D0E3
i2c_send_loop                    A:D0C7
i2c_toggle_clock                 A:CFC8
i2c_toggle_clock_wait            A:CFD0
i2c_write                        A:D00A
i2c_write_clock                  A:D024
i2c_write_clock_wait             A:D034
i2c_write_got_ack                A:D04E
i2c_write_loop                   A:D00D
i2c_write_lost_arbitration       A:D04C
i2c_write_one                    A:D019
id_equals_message                A:B667
info_message                     A:A573
insert_limit                     S:00A4
introduction                     A:D9CF
irq                              A:B727
irq1                             A:B734
irq_done                         A:B7AC
is_xxx_fail                      A:8106
is_xxx_pass                      A:810A
isalnum                          E:8162
isalpha                          E:8126
isbin                            A:8176
isbinary                         E:816E
iscntrl                          E:8156
isdigit                          E:8132
islower                          E:811A
isspace                          E:814A
isupper                          E:810E
isxdigit                         E:813E
lcd_clear_display                A:B8F0
lcd_clear_enable                 A:B84C
lcd_data_nibble                  A:B8AF
lcd_get_address                  A:B87C
lcd_home                         A:B900
lcd_initialise                   A:B7AF
lcd_instruction                  A:B89C
lcd_prepare_to_read_register     A:B808
lcd_prepare_to_write_data        A:B81B
lcd_prepare_to_write_instructio  A:B830
lcd_print                        A:B911
lcd_print_char                   A:B8BE
lcd_print_char_newline           A:B8DF
lcd_print_char_ok                A:B8DF
lcd_print_char_on_2nd_line       A:B8D8
lcd_print_done                   A:B91B
lcd_print_message                A:B908
lcd_print_not_newline            A:B8C9
lcd_read_instruction_nibble      A:B855
lcd_second_line                  A:B8F8
lcd_set_enable                   A:B843
lcd_wait                         A:B861
lcd_wait_timeout                 A:B878
lcd_work                         S:0086
lcd_write_instruction_nibble     A:B890
lcdbusy                          A:B869
library_function_call            A:C71A
library_function_call_1          A:C756
library_function_call_2          A:C727
library_function_call_3          A:C751
library_function_call_5          A:C759
line_number_lt_1000              A:8C2E
line_number_output_spaces        A:8C3D
lines_deleted_message            A:8C0A
list_symbols                     E:A57E
list_symbols_check               E:A598
list_symbols_done                E:A5D2
list_symbols_line                E:A5A7
list_symbols_name                E:A5C1
list_symbols_next                E:A58D
load_message                     A:89BE
m_alnum                          E:0080
m_alpha                          E:0004
m_cntrl                          E:0040
m_digit                          E:0008
m_lower                          E:0002
m_space                          E:0020
m_upper                          E:0001
m_xdigit                         E:0010
main_loop                        A:829C
main_loop_not_run                A:82C8
main_prompt                      A:8282
main_start                       A:827B
maths_work                       S:008D
mem_move_dest                    S:00A8
mem_move_len                     S:00AA
mem_move_src                     S:00A6
memory_filled_up                 A:8B2C
memory_full                      A:8B11
movedown                         A:817A
movedown1                        A:819D
movedown2                        A:8190
movedown_done                    A:819C
movedown_loop                    A:8186
moveup                           A:81A6
moveup3                          A:81D8
moveup_done                      A:81E4
moveup_loop                      A:81CE
moveup_next                      E:81E5
negate_token_value               A:CB01
no_find_message                  A:8702
no_valid_compile_message         A:9347
notbin                           A:8178
number_bad_range_message         A:85D2
number_expected_message          A:8515
number_too_large_message         A:85A9
opcode_lookup                    A:9AED
opcode_lookup_correct_length     A:9B18
opcode_lookup_correct_operand    A:9B46
opcode_lookup_loop               A:9AFF
opcode_lookup_loop_done          A:9B5D
opcode_lookup_loop_unknown       A:9B92
opcode_lookup_next_table         A:9B09
opcode_lookup_no_handler         A:9B5C
opcode_lookup_ok                 A:9B95
p_equals_message                 A:B657
partial_handler_Lookup           A:8F6C
partial_handler_done             A:8FB0
partial_handler_found_directive  A:8F9C
partial_handler_next             A:8F85
partial_handler_next_found_item  A:8F8C
partial_handler_next_item        A:8F6E
partial_handler_next_loop        A:8F76
partial_handler_skipped_string   A:8FA3
pas_gc_identifier                A:CF50
pas_gc_loop                      A:CF58
pas_gc_more                      A:CF61
pas_gc_no_match                  E:CF89
pas_get_token                    A:CF46
pas_get_token_eof                A:CF4F
pascal_library_functions_table   A:C620
pcodes_ended_message             A:92FE
pin_number_to_mask               E:C874
pin_number_to_mask_done          A:C882
pin_number_to_mask_loop          A:C87A
pinmode                          A:C887
pinmode_B                        A:C898
pinmode_C                        A:C8A0
pinmode_OUTPUT                   A:C8AE
prchar_not_control               A:92B7
print                            A:8226
print_done                       A:824C
print_loop                       A:8234
print_not_abort                  A:8242
prompt                           A:8255
random                           S:0009
recover_done                     A:8E42
recover_not_needed               A:8E48
rep_diff                         S:00B7
rep_from                         S:00B5
rep_to                           S:00B6
run_assembler                    A:9396
running_message                  A:ADF3
s_equals_message                 A:B65F
serial_available                 E:C929
serial_in_byte                   S:008A
serial_in_byte_received          S:008B
serial_in_loop                   A:B758
serial_out_bit                   S:0089
serial_out_byte                  S:0087
serial_print                     A:C98D
serial_print_done                A:C997
serial_print_message             A:C987
serial_send_count_bits           A:B79D
show_current_line                A:9818
show_current_line_done           A:985D
show_current_line_loop           A:983A
show_current_line_loop_print_on  A:9852
show_current_line_number         A:8C15
show_current_line_number_done    A:8C49
show_source_end                  A:8EE9
show_source_start                A:8F11
show_symbol_table_end            A:8EC4
show_symbols                     S:0082
source_ended_message             A:8ED6
source_length_message            A:908A
source_starts_message            A:8EFE
spi_init                         A:D115
spi_init2                        A:D133
spi_init3                        A:D145
spi_init_clock_high              A:D12E
spi_init_mosi_low                A:D140
spi_mode                         S:0068
spi_read_02_done                 A:D182
spi_read_13_done                 A:D1A5
spi_send2                        A:D173
spi_send3                        A:D184
spi_send4                        A:D196
spi_send_bit_done                A:D1A7
spi_send_clock_high_low          A:D16E
spi_send_clock_low_high          A:D191
spi_send_clock_pulse_1           A:D161
spi_send_two_bytes               A:D1BF
spi_send_zero                    A:D15C
spi_ss_high                      A:D1B7
spi_ss_low                       A:D1AF
spi_transfer                     A:D14B
spi_transfer_loop                A:D150
stack_message                    A:B71C
str_compare                      A:81F0
str_compare_done                 A:81FE
str_ic_compare                   A:8201
str_ic_compare_done              A:8223
str_ic_compare_fixed_dest        A:821E
str_ic_compare_fixed_srce        A:8210
str_work                         S:0085
symbol_table_ended_message       A:932F
symbol_table_message             A:8D6D
system_flags                     S:00BE
this_line                        S:00AC
this_line_addr                   S:00AE
timer1_interrupt                 A:B77D
to_line                          S:00A0
to_msg                           A:868C
token_address                    S:0090
token_digit                      S:009B
token_length                     S:0092
token_line                       A:CA38
token_line1                      A:CA3E
token_line_done                  A:CA86
token_line_listing               A:CA59
token_line_loop                  A:CA71
token_line_loop1                 A:CA81
token_line_start                 S:009C
token_sign                       S:0097
token_start                      S:008E
token_type                       S:0093
token_value                      S:0094
token_work                       S:0098
too_much_on_line                 A:85EB
typing_latency                   S:000D
write_char                       A:C962
write_char_loop                  A:C97E
write_function                   S:0017
write_to_lcd                     A:C90D
write_to_serial                  A:C902
write_zero                       A:B798
wtf_loop                         A:9B81
x_equals_message                 A:B647
y_equals_message                 A:B64F

Symbols by value:
0000 EMULATOR
0000 OPCODE_LOOKUP_OPCODE_LENGTH
0000 PCODE_LIT
0000 REG
0000 SERIAL_DEBUGGING
0000 SRCE
0000 SYMPRV
0000 VALUE
0000 VIA_FLAG_DISABLE
0000 crc_addr
0001 ASS_OPERAND_ABSOLUTE
0001 EFLAG_SHOW_LINE
0001 FFLAG_IGNORE_CASE
0001 FLAG_COMPILING
0001 LCD_SUPPORT
0001 OPCODE_LOOKUP_OPERAND_TYPE
0001 PCODE_STACK
0001 SPI_SS
0001 USE_CP437_FONT
0001 m_upper
0002 ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
0002 EFLAG_ALLOW_ZERO_FROM
0002 FFLAG_GLOBAL
0002 FLAG_ASSEMBLING
0002 OPCODE_LOOKUP_OPCODE_TABLE
0002 PCODE_NEG
0002 REGB
0002 SERIAL_OUT_MASK
0002 SPI_MOSI
0002 SYMLVL
0002 m_lower
0003 ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
0003 DEST
0003 KEY_ABORT
0003 PCODE_LIB_CALL
0003 REG2
0003 SYMTYP
0003 VALUE2
0003 crc_num
0004 ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
0004 EFLAG_LOAD
0004 FFLAG_QUIET
0004 FLAG_LIST_SOURCE
0004 I2C_SCL
0004 KEY_DEBUG
0004 OPCODE_LOOKUP_HANDLER
0004 PCODE_ADD
0004 SERIAL_DEBUG1_MASK
0004 SPI_MISO
0004 SYMDSP
0004 m_alpha
0005 ASS_OPERAND_ABSOLUTE_INDIRECT
0005 REG2B
0006 ASS_OPERAND_ACCUMULATOR_A
0006 OPCODE_LOOKUP_TABLE_SIZE
0006 PCODE_SUB
0006 REMAIN
0006 SYMARG
0006 SYMSUB
0006 crc_val
0007 ASS_OPERAND_IMMEDIATE
0008 ASS_OPERAND_IMPLIED
0008 BACKSPACE
0008 EFLAG_SAVE
0008 FLAG_VALID_COMPILE
0008 I2C_SDA
0008 PCODE_MUL
0008 SERIAL_DEBUG2_MASK
0008 SPI_SCK
0008 SYMDAT
0008 VIA_FLAG_CB2
0008 m_digit
0009 SYMLEN
0009 random
000A NL
000A PCODE_DIV
000A SYMNAM
000B ASS_OPERAND_ZERO_PAGE
000B PCODE_MOD
000C ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
000C PCODE_ADRNN
000D ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
000D CR
000D typing_latency
000E ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
000E KEY_STOP_TRACE
000E PCODE_ADRAN
000F ASS_OPERAND_ZERO_PAGE_INDIRECT
0010 ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
0010 EFLAG_FIND
0010 FLAG_VALID_ASSEMBLE
0010 PCODE_EQL
0010 SERIAL_SPARE2_MASK
0010 call_a
0010 m_xdigit
0011 ASS_OPERAND_STRING
0011 PCODE_FINISHD
0011 call_x
0012 ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE
0012 PCODE_NEQ
0012 call_y
0013 call_p
0014 KEY_TRACE
0014 PCODE_LSS
0014 call_s
0015 brk_address
0016 PCODE_GEQ
0016 gc_backslash_tokens_length
0017 write_function
0018 PCODE_GTR
0019 LINE_CNT
0019 PCODE_LEQ
001A PCODE_ORR
001B END_EDITOR_INPUT
001B PCODE_AND
001C PCODE_INP
001D LIST
001E PCODE_OUT
001F PCODE_OUTC
0020 EFLAG_REPLACE
0020 FRAME
0020 LCD_RS
0020 MAX_STK
0020 PCODE_EOR
0020 m_space
0021 PCODE_OUH
0022 LEVEL
0022 PCODE_SHL
0022 TOKEN_STRING
0023 PCODE
0023 PCODE_OUS
0023 SERIAL_DELAY2
0024 PCODE_SHR
0025 ACT_PCDA
0025 PCODE_INS
0026 PCODE_INC
0027 DISPL
0027 PCODE_CLL
0027 SINGLE_QUOTE
0028 PCODE_DEC
0029 OFFSET
0029 PCODE_RTN
002A PCODE_MOV
002B OPND
002B PCODE_CLA
002C PCODE_LOD
002E DCODE
002E PCODE_LDA
002F STARTSYM
0030 PCODE_LDI
0030 SERIAL_DELAY1
0031 ENDSYM
0031 T
0032 PCODE_STO
0033 WORKD
0034 PCODE_STA
0035 ERRNO
0036 BSAVE
0036 PCODE_STI
0037 WORK
0038 PCODE_ABSCLL
0039 PRCITM
003A PCODE_XOR
003B BASE
003B PCODE_INT
003C PCODE_JMP
003D DATA
003D PCODE_JMZ
003E PCODE_JM1
003F RUNNING
0040 EFLAG_SUPPRESS_NEWLINE
0040 FLAG_ONLY_ALPHA
0040 FROM
0040 LCD_RW
0040 PCODE_OUTCR
0040 SYMITM
0040 VIA_FLAG_TIMER1
0040 m_cntrl
0041 SYMBOL_ARRAY
0041 TOKEN_ASSIGN
0042 PCODE_LCD_WRITE_NUM
0042 SYNTAX
0043 END_PCD
0043 PCODE_LCD_WRITE_STR
0043 SYMBOL_CONSTANT
0044 PCODE_LCD_WRITE_HEX
0045 PCODE_LAST
0045 PCODE_LCD_WRITE_CHR
0045 TEMP
0045 TOKEN_EQUALITY
0046 SYMBOL_FUNCTION
0047 CALL
0049 DBGFLG
0049 TOKEN_IDENTIFIER
004A DATTYP
004B COUNT1
004C COUNT2
004C TOKEN_SHIFT_LEFT
004D LASTP
004D TOKEN_UNARY_MINUS
004E TOKEN_NUMBER
0050 SYMBOL_PROCEDURE
0051 SYMBOL_LIBRARY_PROCEDURE
0052 RES
0052 SYMBOL_LIBRARY_FUNCTION
0052 TOKEN_SHIFT_RIGHT
0055 TOKEN_NEQ
0056 SYMBOL_VARIABLE
0056 TOKEN_LOW_BYTE
0057 TOKEN_HIGH_BYTE
0058 TOKEN_LOGICAL_AND
0059 SYMBOL_FUNCTION_RETURN
0059 TOKEN_LOGICAL_OR
005A TOKEN_INEQUALITY
005B RMNDR
005C bcd_work
0060 bcd_result
0068 spi_mode
006B ASS_OPERAND
006C OPCODE
006E OPCODE_LEN
006F ASS_EMIT_COUNT
0070 ASS_OPCODE_WORK
0072 ASS_COUNT
0073 ASS_VALUE
0076 ASS_PASS
0077 ass_emit_bytes
0079 exp_value_stack
007B exp_value_stack_count
007C exp_operator_stack_count
007D exp_operator
007E exp_operator_precedence
007F exp_evaluation_function
0080 EFLAG_NO_LINE_NUMBERS
0080 FLAG_ABORTED
0080 LCD_E
0080 TOKEN_LEQ
0080 VIA_FLAG_ENABLE
0080 m_alnum
0081 TOKEN_GEQ
0081 exp_unary_ok
0082 TOKEN_CONST
0082 show_symbols
0083 TOKEN_VAR
0083 ass_current_label
0084 TOKEN_ARRAY
0085 TOKEN_OF
0085 str_work
0086 TOKEN_PROCEDURE
0086 lcd_work
0087 TOKEN_FUNCTION
0087 serial_out_byte
0088 TOKEN_BEGIN
0089 TOKEN_END
0089 serial_out_bit
008A TOKEN_OR
008A serial_in_byte
008B TOKEN_DIV
008B serial_in_byte_received
008C TOKEN_MOD
008C hardware_work
008D TOKEN_AND
008D maths_work
008E TOKEN_SHL
008E token_start
008F TOKEN_SHR
0090 TOKEN_NOT
0090 token_address
0091 TOKEN_MEM
0092 TOKEN_IF
0092 token_length
0093 TOKEN_THEN
0093 token_type
0094 TOKEN_ELSE
0094 token_value
0095 TOKEN_CASE
0096 TOKEN_WHILE
0097 TOKEN_DO
0097 token_sign
0098 TOKEN_REPEAT
0098 token_work
0099 TOKEN_UNTIL
009A TOKEN_FOR
009B TOKEN_TO
009B token_digit
009C TOKEN_DOWNTO
009C token_line_start
009D TOKEN_WRITE
009E TOKEN_READ
009E from_line
009F TOKEN_CALL
00A0 to_line
00A1 TOKEN_CHAR
00A2 TOKEN_MEMC
00A2 current_line
00A4 TOKEN_XOR
00A4 insert_limit
00A6 mem_move_src
00A8 mem_move_dest
00A9 TOKEN_ADDRESS
00AA mem_move_len
00AB TOKEN_CHR
00AC TOKEN_HEX
00AC this_line
00AE this_line_addr
00B0 find_from
00B1 find_to
00B2 find_pos
00B3 find_len
00B4 find_delimiter
00B5 rep_from
00B6 rep_to
00B7 rep_diff
00B9 find_count
00BB found_this_line
00BC editor_flags
00BD find_flags
00BE system_flags
00D0 BIT_INTERVAL
00F1 TOKEN_LCDWRITE
00FE TOKEN_INTEGER
00FF NEW_STK
00FF TOKEN_WRITELN
0100 INBUF_SIZE
0200 INBUF
0300 TEXT_START
12C0 BAUD_RATE
3FFF HIGHEST_RAM
3FFF SYMBOL_TABLE_START
7FF0 SPI_PORT
7FF0 VIA_PORTB
7FF1 I2C_PORT
7FF1 VIA_PORTA
7FF2 SPI_DDR
7FF2 VIA_DDRB
7FF3 I2C_DDR
7FF3 VIA_DDRA
7FF4 VIA_T1C_L
7FF5 VIA_T1C_H
7FFB VIA_ACR
7FFC VIA_PCR
7FFD VIA_IFR
7FFE VIA_IER
8000 START_OF_ROM
8006 character_types_table
8106 is_xxx_fail
810A is_xxx_pass
810E isupper
811A islower
8126 isalpha
8132 isdigit
813E isxdigit
814A isspace
8156 iscntrl
8162 isalnum
816E isbinary
8176 isbin
8178 notbin
817A movedown
8186 movedown_loop
8190 movedown2
819C movedown_done
819D movedown1
81A6 moveup
81CE moveup_loop
81D8 moveup3
81E4 moveup_done
81E5 moveup_next
81F0 str_compare
81FE str_compare_done
8201 str_ic_compare
8210 str_ic_compare_fixed_srce
821E str_ic_compare_fixed_dest
8223 str_ic_compare_done
8226 print
8234 print_loop
8242 print_not_abort
824C print_done
8255 prompt
8258 bad_command
827B main_start
8282 main_prompt
829C main_loop
82C8 main_loop_not_run
82E6 editor_handlers
8374 editor_help_info
84E9 editor_help
84F4 editor_help_loop
8505 editor_help_done
8508 editor_default_range
8515 number_expected_message
8526 editor_bad_number
8530 editor_get_number
8572 editor_get_number_not_identifier
8588 editor_get_number_ok
8598 editor_get_number_done
859A editor_get_number_none
859C editor_get_number_end
85A9 number_too_large_message
85C8 editor_line_number_too_big
85D2 number_bad_range_message
85E1 editor_bad_range
85EB too_much_on_line
860E editor_check_no_more
8610 editor_check_no_more_loop
8620 editor_check_no_more_failed
862A editor_check_no_more_ok
862B editor_get_range
8661 editor_get_range_hyphen
8666 editor_get_range_number
8679 editor_get_range_done
867A editor_bad_rangeJ
867D found_message
8685 from_msg
868C to_msg
8691 bad_delimiter_message
86A0 editor_bad_delimiter
86A4 editor_find_problem
86AA find_string_too_long_message
86C8 find_string_too_long
86CE editor_get_delimiter
86E6 editor_no_closing_delimiter_message
86FC editor_no_closing_delimiter
8702 no_find_message
8717 editor_no_find_string
871D editor_replace
8725 editor_find
872B editor_save
8731 editor_list
8757 editor_list_doing_find
8763 editor_find_bug
8768 find_string_too_longJ
876B editor_no_closing_delimiterJ
876E editor_list_got_from_point
8770 editor_find_second_delimiter_loop
8797 editor_find_third_delimiter_loop
87BD editor_find_get_flags
87BF editor_flags_loop
87DD editor_flags1
87E7 editor_flags2
87F1 editor_flags3
87FB bad_flag_message
8809 editor_list_fix_target_string
8811 editor_list_fixup_loop
8821 editor_list_not_find
8824 editor_list_get_on_with_it
8835 editor_list_have_source
883B editor_list_doneJ
883E editor_list_no_line_numberJ
8841 editor_list_loop
8868 editor_list_aborted
8875 editor_find_or_replacing
8877 editor_replacement_loop
8879 editor_find_loop
887D editor_find_inner_loop
8894 editor_find_case_sensitive
8895 editor_find_test_character
889E editor_find_skip_this
88A2 editor_find_no_match
88B8 editor_find_found_it
88BE editor_find_found_it1
88D6 editor_do_the_replace
88E3 editor_easy_replace
88E7 editor_easy_replace_loop
88F4 editor_easy_replace_done
8905 editor_list_not_finding
8912 editor_list_no_line_number
891A editor_newline_processing
8924 editor_list_check_to_line
8934 editor_list_check_to_line_ok
893C editor_list_not_newline
8947 editor_list_skip_newline
894D editor_list_loopJ
8950 editor_list_done
896D editor_list_completely_done
8970 editor_do_replace
89B2 editor_do_replace_smaller
89B5 editor_do_replace_copy_done
89BE load_message
89E0 editor_load
89E4 editor_insert
89FE editor_insert_at_start
8A0C editor_insert_common
8A4F editor_insert_loop
8A60 editor_insert_no_line_number
8A7F editor_insert_not_newline
8A88 editor_insert_loop1
8A98 editor_insert_backspace
8AA4 editor_insert_backspace_not_at_start
8ABA editor_insert_done
8ACB editor_insert_done_with_newline
8AE6 editor_too_full
8AED editor_too_full_loop
8AFE editor_no_lines
8B11 memory_full
8B2C memory_filled_up
8B55 editor_argument_check
8B57 editor_argument_check_loop
8B67 editor_argument_check_failed
8B71 editor_argument_check_got_argument
8B72 editor_delete
8BC0 editor_delete_line_count_loop
8BCC editor_delete_line_count_not_done
8BD8 editor_delete_line_count_not_newline
8BE0 editor_delete_line_count_done
8C0A lines_deleted_message
8C15 show_current_line_number
8C2E line_number_lt_1000
8C3D line_number_output_spaces
8C49 show_current_line_number_done
8C53 find_line
8C61 find_line_loop
8C70 find_line_next
8C7E find_line_same_line
8C86 find_line_eof
8C87 find_source_end
8C8F find_source_end_loop
8C9D find_source_end_wrap
8CA3 find_source_end_done
8CA4 brk_resumed
8CB8 editor_test
8CCA editor_memory
8CE4 editor_memory_loop
8D05 editor_memory_loop1
8D17 editor_memory_loop2
8D2D editor_memory_loop3
8D3D editor_memory_done
8D40 editor_memory_aborted
8D46 editor_memory_show_ascii
8D48 editor_memory_ascii
8D50 editor_memory_not_control
8D54 editor_memory_show_dot
8D56 editor_memory_not_high
8D6D symbol_table_message
8D9F ST_SYMTBL_LIST_NEXT
8DAA ST_SYMTBL_LIST_CHECK
8DB9 ST_SYMTBL_LIST_LINE
8E2E ST_SYMTBL_LIST_NAME
8E3F ST_SYMTBL_LIST_DONE
8E42 recover_done
8E48 recover_not_needed
8E54 editor_recover
8E73 editor_recover_not_needed
8E7D editor_debug
8E89 editor_trace
8E95 editor_info
8EA4 editor_compile
8EAE editor_syntax
8EB8 editor_run
8EC4 show_symbol_table_end
8ED6 source_ended_message
8EE9 show_source_end
8EFE source_starts_message
8F11 show_source_start
8F23 editor_assemble
8F29 handlerLookup
8F2B handler_loop
8F31 handler_find_length
8F3A handler_found_length
8F3E handler_next
8F4E handler_same_length
8F57 handler_found_directive
8F67 handlers_done
8F69 call_handler
8F6C partial_handler_Lookup
8F6E partial_handler_next_item
8F76 partial_handler_next_loop
8F85 partial_handler_next
8F8C partial_handler_next_found_item_length
8F9C partial_handler_found_directive
8FA3 partial_handler_skipped_string
8FB0 partial_handler_done
8FB1 TKNJMP
8FB9 JMP1
8FC1 JMP2
8FD6 JMP3
8FE3 MAKE_UPPER
8FED MAKE_UPPER_DONE
8FF8 MAKE_LOWER_DONE
8FF9 gen_random
901B gen_random1
901C crc16
9028 crc16_loop
9035 crc16_next
903B crc16_skip
9043 crc_done
9044 crc_byte
9074 crc_helper1
9077 crc_message
908A source_length_message
909A bytes_message
90A2 crc_source
90EA delay_1ms
90ED delay_1ms_loop
90F4 delay
90FE bcd_unpack
9111 bcd_table
9171 display_in_decimal
917D bcd_positive
9184 bcd_skip_zeroes
918F bcd_output_digit
919A binary_to_decimal
91A5 binary_to_decimal_loop
91CA binary_to_decimal_next
91E8 NOSCE
91F9 INIT
9205 INIT_SECOND_PASS
9246 INIT9
9247 CROUT
924C COMSTL
9258 COMS9
9259 COMS8
925C DISHX
9262 DISPAD
927D DISPAD2
927E PSHWRK
9290 PSH9
9291 PULWRK
92A4 PRCHAR
92B7 prchar_not_control
92BC PRBYTE
92C5 PRHEX
92C7 PRHEXZ
92CF PRHEX1
92D2 PUTSP
92D6 PT
92DE PT6
92E8 TKNWRK
92F3 WRKTKN
92FE pcodes_ended_message
9311 compile_finished_message
932F symbol_table_ended_message
9347 no_valid_compile_message
9371 PRBYTECR
9377 CHK_VAL
9389 CHK_VAL9
938A CHK_RUN
9396 run_assembler
939C call_assembler
93A6 GETLN1
93A6 GET_LINE
93A8 GET1
93C5 GET3
93CB GETLN_OVERFLOW
93CE COUT
93D8 COUT_CALL
93DB errors_table
973D assertion_failed_message
9777 ERRLIT
9783 ERROR
978C ERR7
9796 ERR1
97AA ERR3
97BA ERR5
97C0 ERR6
97CC error_next
97CD error_loop
97D1 error_find_next
97DA error1
97E3 error_not_found
97FB error_found
9808 error_not_found_message
9818 show_current_line
983A show_current_line_loop
9852 show_current_line_loop_print_one_character
985D show_current_line_done
9861 ASSEMBLE
986E ASSEMBLE_SECOND_PASS
9873 ASSEMBLE_PASS
988D ass_finish_line
9898 ass_done_jump
989B ass_line
98AA ass_line1
98D6 ass_bad_identifier
98DB ass_identifier
9905 ass_lookup_existing_label
990F ass_lookup_save_address
991B ass_added_symbol
992D ass_not_colon
9934 ass_not_colon2
993C ass_illegal_opcode
9944 ass_opcode
9985 ass_check_label_changed
9995 ass_symbol_address_changed
999A ass_opcode2
99AB ass_finish_lineJ
99AE ass_operand
99C0 ass_string
99CD ass_immediate
99E0 ass_indirect
99E9 ass_identifier_operand
9A0A ass_operand_value
9A42 ass_value_not_indirectJ
9A45 ass_bad_indirect
9A4A ass_indirect_with_bracket
9A5E ass_zp_indirect_indexed
9A7F ass_bad_zp_indirect_indexed
9A84 ass_not_x_or_y
9A86 ass_check_we_have_x_or_y
9AA2 ass_check_we_have_x_or_y_ok
9AA4 ass_value_not_indirect
9AAE ass_value_done
9AB7 ass_indexed
9AD5 ass_indexed_x
9ADE ass_absolute_another_value
9AED opcode_lookup
9AFF opcode_lookup_loop
9B09 opcode_lookup_next_table
9B18 opcode_lookup_correct_length
9B46 opcode_lookup_correct_operand
9B5C opcode_lookup_no_handler
9B5D opcode_lookup_loop_done
9B81 wtf_loop
9B92 opcode_lookup_loop_unknown
9B95 opcode_lookup_ok
9B96 ass_done
9BA0 ass_done_second_pass
9BB8 ass_done1
9BBB ass_done_message
9BD9 ass_check_no_more_tokens
9BE4 ass_check_no_more_tokens_ok
9BE5 exp_push_value
9BEB exp_push_value_memory_full
9BF0 exp_push_value_ok
9BFF exp_push_value_not_full
9C10 exp_pop_value
9C19 exp_pop_value_ok
9C39 exp_push_operator
9C44 exp_push_operator_ok
9C4B exp_pop_operator
9C54 exp_pop_operator_ok
9C5B exp_get_operator
9C64 exp_get_operator_ok
9C69 exp_precedence_table
9CC9 exp_get_precedence
9CC9 exp_precedence_table_end
9CCB exp_get_precedence_loop
9CDF exp_get_precedence_found
9CF0 ass_get_value
9D0A ass_expression_loop
9D0D ass_expression_loop_initial
9D11 ass_expression_number
9D24 ass_expression_loop1a
9D36 ass_expression_not_small_string
9D3B ass_expression_loop1
9D4F ass_label_not_found_yet
9D57 ass_expression_found_value
9D68 ass_expression_loop2
9D77 ass_expression_loop3
9D7B ass_expression_loop3b
9D86 ass_expression_loop3a
9D8B ass_expression_loop3c
9D8E ass_expression_loopJ
9D91 ass_expression_loop4
9D9F ass_not_unary_minus
9DA9 ass_not_unary_less_than
9DB3 ass_not_unary_greater_than
9DC9 ass_expression_cannot_be_unary
9DD8 ass_expression_loop7
9DEF ass_expression_loop6
9DF7 exp_no_operators_left
9E00 exp_done
9E06 exp_done_error
9E0B exp_done_ok
9E1D ass_expression_apply_operator
9E46 ass_expression_unary
9E59 ass_expression_apply_operator_bug
9E5E ass_evaluate_operator
9E61 ass_lookup_loop
9E7F ass_opcode_found
9E85 ass_emit
9E99 ass_emit2
9EA8 ass_already_emitted
9EB3 ass_emit4
9EBA ass_emit3
9EC0 ass_emit1
9EC3 ass_error
9ECA ass_error1
9ECD ass_fixup_bbr_branch
9EDA ass_fixup_branch
9EF3 ass_branch_backwards
9EF7 ass_branch_ok
9EFD ass_branch_out_of_range
9F06 ass_emit_zero_page
9F14 ass_emit_zero_page_too_high
9F19 ass_emit_immediate
9F27 ass_emit_immediate_too_high
9F2C ass_emit_absolute
9F37 OPCODE_LOOKUP_TABLE
9FDA DIRECTIVES
A04D OPCODE_4_CHAR_BRANCH
A09E OPCODE_3_CHAR_BRANCH
A0C3 OPCODE_3_CHAR_IMPLIED
A140 OPCODE_4_CHAR_ZERO_PAGE
A191 OPCODE_ASS_OPERAND_ABSOLUTE
A1FA OPCODE_ASS_OPERAND_ABSOLUTE_TOKENISED
A1FD OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
A202 OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
A247 OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X_TOKENISED
A24A OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
A26F OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y_TOKENISED
A272 OPCODE_ASS_OPERAND_ACCUMULATOR_A
A28B OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT
A290 OPCODE_ASS_OPERAND_IMMEDIATE
A2C1 OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED
A2C4 OPCODE_ASS_OPERAND_ZERO_PAGE
A325 OPCODE_ASS_OPERAND_ZERO_PAGE_TOKENISED
A328 OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
A349 OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT_TOKENISED
A34C OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
A395 OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X_TOKENISED
A398 OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
A3A1 OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT
A3C2 OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_TOKENISED
A3C5 OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
A3E6 OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y_TOKENISED
A3E9 asm_do_assert
A3F8 asm_do_assert_failed
A3FD asm_do_constant_expectedJ
A400 asm_do_list
A40F asm_do_nolist
A41A asm_do_nolist_ok
A420 asm_do_list_no_operand
A424 asm_do_list_ok
A43A asm_do_list_not
A43E asm_do_list1
A44D asm_do_list_first_pass
A44E asm_do_asc
A459 asm_do_asc_ok
A45B asm_do_asc_loop
A464 asm_do_asc_next
A469 asm_do_string
A472 asm_do_equ
A483 asm_do_equ_have_label
A48F asm_do_org
A495 asm_do_constant_expected
A49A asm_do_org_ok
A4A3 asm_do_dfb
A4B1 asm_do_dfb_multiple
A4BE asm_do_dfb_multiple_loop
A4CF asm_do_dfb_multiple_done
A4D0 asm_do_dfb_too_big
A4D5 asm_emit_one_byte
A4E3 asm_do_dfw
A4F1 asm_do_dfw_multiple
A4FF asm_do_dfw_multiple_loop
A510 asm_do_dfw_multiple_done
A511 asm_emit_two_bytes
A520 asm_do_blk
A530 asm_do_blk_loop
A53D asm_do_blk_done
A53E asm_do_reserve
A556 asm_do_constant_expectedJ2
A559 asm_do_sym
A572 asm_do_sym_done
A573 info_message
A57E list_symbols
A58D list_symbols_next
A598 list_symbols_check
A5A7 list_symbols_line
A5C1 list_symbols_name
A5D2 list_symbols_done
A5D3 assembler_library_functions_table
AA93 add_assembler_library_functions
AA9B add_assembler_library_functions_loop
AAAB add_assembler_library_functions_name_loop
AADD add_assembler_library_functions_done
AADE exp_add
AAF2 exp_subtract
AB08 exp_true
AB11 exp_false
AB18 exp_eql
AB2C exp_neq
AB40 exp_less_than
AB47 exp_greater_than
AB56 exp_leq
AB65 exp_geq
AB6C exp_bitwise_or
AB81 exp_bitwise_and
AB96 exp_bitwise_xor
ABAB exp_trueJ
ABAE exp_falseJ
ABB1 exp_logical_or
ABC0 exp_logical_and
ABD2 exp_shift_left
ABE1 exp_shift_left_loop
ABEA exp_shift_left_done
ABEB exp_shift_right
ABFA exp_shift_right_loop
AC03 exp_shift_right_done
AC04 exp_negate
AC17 exp_not
AC25 exp_unary_minus
AC39 exp_low_byte
AC3E exp_high_byte
AC47 exp_abs_val
AC4B exp_negate_val
AC5E exp_abs_val_done
AC5F exp_abs_val2
AC63 exp_negate_val2
AC76 exp_abs_val2_done
AC77 ZERRES
AC80 exp_find_sign
AC98 exp_fix_sign
ACAB exp_fix_sign_done
ACAC exp_multiply
ACB1 exp_multiply_loop
ACD2 exp_multiply_no_add
ACE5 exp_divide
ACF5 exp_divide_not_zero
AD02 exp_divide_loop
AD2A exp_divide_subtraction_negative
AD2B exp_divide_subtraction_positive
AD45 exp_modulo
AD55 execution_address_table
ADE1 DM1
ADEA DM2
ADF3 running_message
ADFC DB11
ADFC DEBUG
AE64 DEBUG_DONE
AE65 INTERP
AE8B DM5
AEA0 DM6
AEAB DM7
AEC5 display_x_characters
AECC DIS5
AED6 DIS5_A
AEE3 BELL1
AEED RUNERR
AF01 EX_FINISHD
AF18 FIN_MSG
AF37 CHK_KBD
AF43 CHK_NOTN
AF51 CHK_NOTT
AF5F CHK_NOTD
AF61 EX_OUTCR
AF67 LOWLIT
AF6D LOWLIT1
AF73 MAINP
AF76 MAIN
AF7D MAIN_2
AF88 MAIN_NOT_ABORT
AF8B MAIN_OK
AFA5 MAIN_1
AFB4 EX_INVINS
AFB8 NOTIM1
AFC5 GETADR
AFCF GET2
AFF0 GETADR1
B00B GET1_A
B00C PULTOP
B027 PUL_END
B02E PULBOTH
B031 PULTOP2
B04C PUL2_END
B053 PSHTOP
B05E PSH1
B06F GETLIT
B085 GET_END
B086 EX_LIT
B095 LIT1
B098 EX_NEG
B0A1 EX_ADD
B0AA EX_SUB
B0B6 EX_MUL
B0BF EX_GETKEY
B0C6 EX_MOD
B0DA EX_DIVIDE_BY_ZERO
B0E1 DIVBY0
B0F1 EX_DIV
B105 EX_ABS
B10E EX_EQL
B117 TRUE
B119 TRUE2
B124 FALSE
B128 EX_NEQ
B131 EX_LSS
B13D EX_GTR
B149 EX_GEQ
B155 EX_LEQ
B161 EX_XOR
B16A EX_ORR
B173 EX_AND
B17C EX_EOR
B185 EX_SHL
B191 EX_SHR
B19D EX_INC
B1B5 EX_DEC
B1CD EX_MOV
B1DE EX_LODC
B1E1 EX_LOD3
B1E3 EX_LOD3_A
B1F0 EX_LOD
B1F3 EX_LOD2
B206 EX_LDAC
B211 EX_LDA
B21B GETIDC
B224 GETIDX
B238 GETID2
B246 EX_LDIC
B24C EX_LDI
B252 EX_STOC
B25A EX_STO5
B25F EX_STO
B265 EX_STO2
B272 EX_STA
B283 EX_STA5
B288 EX_STAC
B291 EX_STIC
B29F EX_STI
B2BA EX_RTN
B2F3 EX_INP
B304 EX_INP_OK
B31B INP3
B32B BAD_INP
B333 EX_OUT
B338 EX_LCD_WRITE_NUM
B33B OUT_COMMON
B347 EX_OUH
B34C EX_LCD_WRITE_HEX
B34F EX_OUH_COMMON
B367 EX_OUS
B36C EX_LCD_WRITE_STR
B36F EX_OUS_COMMON
B38B EX_OUS1
B39A EX_ABSCLL
B3A1 EX_CLL
B3A9 EX_CLL_A
B3C7 EX_CLL4
B3CB EX_CLL2
B3EC EX_CLL3
B42D EX_CLL5
B430 EX_CLA
B44D EX_CLL_JMP
B450 EX_INT
B467 INT_ERR
B46E INT_ERRM
B47A EX_NEW_STACK
B48C EX_JMP
B49F EX_JMZ
B4AA EX_NOJUMP
B4B0 EX_JM1
B4BB EX_INPC
B4C5 EX_INPC_OK
B4D5 EX_OUTC
B4DA EX_LCD_WRITE_CHR
B4DD EX_OUTC_COMMON
B4EB EX_LCDHOME
B4F1 EX_LCDCLEAR
B4F7 EX_INS
B501 EX_INS3
B51A EX_INS1
B523 EX_INS2
B52D EX_INS4
B53A execution_aborted_message
B54E ex_input_aborted
B555 EX_ADRNC
B558 EX_ADRNC2
B565 EX_ADRNN
B568 EX_ADRN2
B573 EX_ADRAN
B579 EX_ADRAC
B57F EX_DIGITALREAD
B58A EX_DIGITALREAD_ONE
B58D EX_LCDPOS
B59D EX_LCDPOS_1
B5A7 EX_RANDOM
B5B9 EX_LATENCY
B5C8 EX_DELAY
B5D8 EX_RANDOMSEED
B5E8 EX_PINMODE
B5F7 EX_DIGITALWRITE
B606 EX_LIB_CALL
B60C EX_ASSERT
B621 EX_ASSERT_OK
B624 break_message
B63F a_equals_message
B647 x_equals_message
B64F y_equals_message
B657 p_equals_message
B65F s_equals_message
B667 id_equals_message
B670 brk_executed
B6EB brk_executed1
B6F8 brk_executed2
B708 brk_executed3
B71C stack_message
B724 brk_executedJ
B727 irq
B734 irq1
B74C cb2_interrupt
B758 serial_in_loop
B77D timer1_interrupt
B798 write_zero
B79D serial_send_count_bits
B7AC irq_done
B7AF lcd_initialise
B808 lcd_prepare_to_read_register
B81B lcd_prepare_to_write_data
B830 lcd_prepare_to_write_instruction
B843 lcd_set_enable
B84C lcd_clear_enable
B855 lcd_read_instruction_nibble
B861 lcd_wait
B869 lcdbusy
B878 lcd_wait_timeout
B87C lcd_get_address
B890 lcd_write_instruction_nibble
B89C lcd_instruction
B8AF lcd_data_nibble
B8BE lcd_print_char
B8C9 lcd_print_not_newline
B8D8 lcd_print_char_on_2nd_line
B8DF lcd_print_char_newline
B8DF lcd_print_char_ok
B8F0 lcd_clear_display
B8F8 lcd_second_line
B900 lcd_home
B908 lcd_print_message
B911 lcd_print
B91B lcd_print_done
B91C SEARCH
B924 SEA_NEXT
B92F SEA1
B93C SEA2
B985 SEA4
B98D SEA5
B990 SEA3
B993 SYM_FULL
B998 ADDSYM
B9CD ADDSYM_NOT_FULL
B9F4 ADD1
BA17 ADD4
BA33 ADD9
BA34 LOOKUP
BA3E LOOK1
BA3F CHKDUP
BA4E DUP9
BA4F COMPIL
BA9D END_CMP
BAA0 CHKLHP
BAA7 CHKRHP
BAB1 GETSUB
BABA CHKLHB
BAC4 CHKRHB
BACE GET_LEV
BAD8 GET_DAT
BADF CONDEC
BB0A SYMWRK
BB15 WRKSYM
BB20 PSHPCODE
BB33 GET_OFF
BB4F GETO_1
BB5C GETO_2
BB5E GETEXPR
BB64 PCD_WRKD
BB6F WRK_OPND
BB7A WRKD_WRK
BB85 WRK_WRKD
BB90 GET_COMM
BB97 GET_ITEM
BB9D VAL_MOVE
BBA6 VAL_1
BBAB VAL_2
BBB4 VAL_3
BBBD VAL_5
BBC6 CHK_STAK
BBCD STK_ERR
BBCD STK_FULL
BBD2 CONST
BBE9 CONST1
BBEE CONST3
BBF3 CONST2
BBF7 CONST9
BBF8 VARDEC
BC0A SIMEXP
BC14 SIM1
BC25 SIM3
BC38 SIM4
BC4E SIM7
BC54 SIM5
BC58 SIM6
BC5C SIM2
BC62 SIM8
BC66 TERMT1
BC7C TERM
BC7F TERM2
BC89 TERM1
BC98 TERM4
BC9A TERM3
BCA0 TERM5
BCA4 TERM6
BCA8 TERM7
BCAC TERM8
BCB0 TERM9
BCB4 TERMT3
BCCA FACTOR
BCDB IDENT
BCDE IDENT1
BCE6 IDENT1A
BCEB IDENT2
BD04 IDENT2A
BD0B IDENT3
BD19 FACAD1
BD21 IDENT5
BD23 IDENT5_A
BD2E IDENT6
BD34 IDENT7
BD37 FACAD2
BD3F IDENT4
BD41 IDENT4_A
BD61 FACADR
BD74 FACSTR
BD7A FACERR1
BD7F FACNUM
BD85 PAREN
BD8B FACMEM
BD91 FACMMC
BD95 FACM2
BDA1 FACNOT
BDA9 GENNOP1
BDAC FACRND1
BDB2 FACTB1
BDB8 FACTQT1
BDCB EXPRES
BDDB EXPTB1
BDEE EXPR1
BDFD EXPTB3
BE10 EXPR2
BE12 EXPR8
BE16 EXPR3
BE1A EXPR4
BE1E EXPR5
BE22 EXPR6
BE26 EXPR7
BE2A STMNT
BE37 STMNT1
BE62 ASSIGN
BE65 ASS1
BE71 ASSTB1
BE87 assign_bad_identifier
BE8C ASSARR
BE9E ASSVAR
BEAD ASS2
BEC9 WRITELN
BED3 WRITELN9
BED8 WRITE
BEDB WRIT9
BEEA W_STRING
BEF4 WRIT2
BEF7 WRIT10
BF04 WRIT1
BF14 WRIT5
BF1D W_CHR
BF1F W_CHR1
BF25 W_HEX
BF29 STMNT_WRITE_LCD
BF2C WRITE_LCD9
BF3B WRITE_LCD_STRING
BF45 WRITE_LCD2
BF55 WRITE_LCD1
BF65 WRITE_LCD5
BF6E WRITE_LDC_CHR
BF70 WRITE_LDC_CHR1
BF76 WRITE_LDC_HEX
BF7A READ
BF7D READ8
BF80 READ2
BF97 READ9
BF9A READ11
BFB9 READ7
BFBF READ7_A
BFC9 READ3
BFDD READ3_B
BFF8 READ3_A
C006 TWO_OP
C00C ONE_OP2
C00F ONE_OP
C016 GENNOP2
C019 WAIT_1
C023 MEM
C028 MEMC
C02B MEM2
C03E CALLSB
C04B FNCPRC
C058 FNC2
C082 FNC3
C088 FNC1
C08B FNC5
C0A8 FNC5A
C0AA FNC5B
C0CC FNC4
C0CD FNC6
C0D2 IF
C0F0 IF2
C0F7 IF1
C112 BEG
C128 REPEAT
C12B REP1
C14C WHILE
C17E CASE
C18C CASE7
C190 CASE2
C1B7 CASE1
C1C3 CASE4
C1CD CASE3
C200 CASE5
C21E CASE6
C229 CASE9
C233 CASE8
C239 FOR
C243 FOR1
C250 FOR2
C269 FOR3
C29A FOR4
C2DD FOR5
C2FF FOR6
C30C CHKGET
C312 WRK_VAL
C31D VAL_WRK
C328 END_WRK
C333 BLCKT1
C336 BLCKT2
C339 BLCKT3
C343 BLOCK
C35A BLK1A
C36E BLK1
C376 BLK2
C380 BLK4
C38A BLKCNS
C38D BLKCN1
C3A1 BLKVAR
C3A5 BLKVR1
C3A8 BLKVR6
C3B2 BLKVR7
C3D1 BLKVR8
C3D4 BLKV10
C3F0 BLKV10_A
C3F7 BLKV10_B
C406 BLKVR2
C41F BLKV13
C424 BLKVR4
C45E BLKV11
C465 BLKV12
C46B BLKVR9
C484 BLKVR5
C4C6 BLKVR3
C4DE BLKPRC
C4FE BLKFNC
C520 BLKPR1
C53C BLKPR3
C549 BLKPR6
C552 BLKPR2
C573 BLKPR5
C59A BLKPR4
C5C6 BLKBEG
C5D0 BLKB3
C5D6 BLKB1
C5F2 BLKB2
C5FF BLKB5
C60E BLKB4
C61D BLKB6
C620 pascal_library_functions_table
C6C0 add_pascal_library_functions
C6C8 add_pascal_library_functions_loop
C6D8 add_pascal_library_functions_name_loop
C719 add_pascal_library_functions_done
C71A library_function_call
C727 library_function_call_2
C751 library_function_call_3
C756 library_function_call_1
C759 library_function_call_5
C76A GENNOP
C77F GEN1
C783 GENADR
C7B6 GEN2
C7B8 GEN2_B
C7C1 GEN2_A
C7D3 GEN_FULL
C7D8 DISP9
C7D8 GEN2_C
C7D9 GENRJMP
C7EB GENNJP
C7ED GENNJM
C7F3 GENJMP
C81C GEN3
C821 FIXAD
C85E FIXAD1
C85F FIXM1
C868 FIXM2
C874 pin_number_to_mask
C87A pin_number_to_mask_loop
C882 pin_number_to_mask_done
C887 pinmode
C898 pinmode_B
C8A0 pinmode_C
C8AE pinmode_OUTPUT
C8B6 digitalwrite
C8C7 digitalwrite_B
C8CF digitalwrite_C
C8DD digitalwrite_ONE
C8E5 digitalread
C8F4 digitalread_B
C8FC digitalread_C
C902 write_to_serial
C90D write_to_lcd
C918 CHRIN
C918 GETIN
C922 GETIN1
C929 serial_available
C92C EMULATOR_DEBUG
C92D START_TRACE
C92E STOP_TRACE
C92F hardware_init
C962 write_char
C97E write_char_loop
C987 serial_print_message
C98D serial_print
C997 serial_print_done
C998 get_token
C99C get_token_loop
C9A6 gc_skip_spaces
C9BB gc_newline
C9C8 gc_newline1
C9D5 gc_newline_assembling
C9DA gc_single_byte_already_known
C9DC gc_single_byte_token
C9DE gc_done
C9F6 gc_not_space
C9FB gc_alpha_loop
CA03 gc_alpha_ok
CA14 gc_alpha_done
CA18 gc_alpha_alpha_only
CA21 gc_not_alpha
CA2D gc_not_digit
CA38 token_line
CA3E token_line1
CA59 token_line_listing
CA71 token_line_loop
CA81 token_line_loop1
CA86 token_line_done
CA87 atoi
CA90 atoi_loop
CA9F atoi_positive
CAA1 atoi_more
CAF6 atoi_error
CAFC atoi_not_running
CB01 negate_token_value
CB15 gtoken_table
CB46 gtoken_directive_table
CB53 gc_single_byte_tokenJ
CB56 gc_single_byte_already_knownJ
CB59 gc_lh_brace
CB5D gc_lh_paren
CB6B gc_pascal_comment
CB8A gc_pascal_comment_find_end
CB95 gc_comment_not_eof
CB9E gc_comment_not_newline
CBAD gc_comment_keep_looking
CBB5 gc_comment_found_end
CBC5 gc_directive_symbols
CBD1 gc_directive_symbols_ok
CBF8 gc_directive_symbols_too_late
CBFD gc_directive_list
CC04 gc_directive_pcodes
CC0A gc_directive_nolist
CC13 gc_semicolon
CC1C gc_assembler_comment_find_end
CC27 gc_assembler_comment_not_eof
CC2E gc_assembler_comment_keep_looking
CC36 gc_backslash_tokens
CC4C gc_backslash_tokens_end
CC4C gc_quote
CC5A gc_quote_loop
CC63 gc_quote_bad
CC68 gc_quote_loop_not_end_of_line
CC7D gc_quote_long_string
CC88 gc_quote_copied_value
CC91 gc_quote_done
CCA3 gc_quote_not_finished
CCB5 gc_quote_backslash_loop
CCC0 gc_quote_bad_string
CCC5 gc_quote_hex_character_done
CCC9 gc_quote_found_backslash_character
CCCD gc_quote_not_backslash
CCD9 gc_quote_too_long
CCDE gc_fix_hex
CCE7 gc_fix_hex_not_a_to_f
CCEB gc_quote_hex_character
CD17 gc_quote_hex_character_one_only
CD1A gc_dollar
CD26 gc_hex_literal
CD2F gc_hex_loop
CD6A gc_hex_done
CD6F gc_hex_too_big
CD74 gc_percent
CD80 gc_binary_literal
CD88 gc_binary_loop
CD9E gc_colon
CDA9 gc_assign
CDAF gc_less_than
CDC3 gc_leq
CDC8 gc_neq
CDCD gc_shift_left
CDD2 gc_greater_than
CDDF gc_single_byte_already_knownJ2
CDE2 gc_geq
CDE7 gc_shift_right
CDEC gc_minus
CDEE gc_plus
CE0D gc_ampersand
CE18 gc_logical_and
CE1E gc_bar
CE29 gc_logical_or
CE2F gc_equals
CE3A gc_equality
CE40 gc_bang
CE4B gc_inequality
CE51 RSVWRD
CF44 RSVEND
CF46 pas_get_token
CF4F pas_get_token_eof
CF50 pas_gc_identifier
CF58 pas_gc_loop
CF61 pas_gc_more
CF89 pas_gc_no_match
CF9A GETCHK
CFA5 CHKNOK
CFA8 CHKOK
CFAA CHKTKN
CFAF GET_LOOK
CFB9 i2c_init
CFC4 i2c_delay
CFC8 i2c_toggle_clock
CFD0 i2c_toggle_clock_wait
CFE3 i2c_begin_transmission
CFE7 i2c_begin_transmission_loop
D00A i2c_write
D00D i2c_write_loop
D019 i2c_write_one
D024 i2c_write_clock
D034 i2c_write_clock_wait
D04C i2c_write_lost_arbitration
D04E i2c_write_got_ack
D050 i2c_read
D059 i2c_read_loop
D06E i2c_read_zero
D072 i2c_read_next
D088 i2c_read_nak
D08D i2c_read_ack_or_nak
D092 i2c_read_ack_or_nak_wait
D0A4 i2c_read_done
D0A6 i2c_end_transmission
D0BF i2c_send
D0C7 i2c_send_loop
D0DE i2c_send_done
D0E3 i2c_send_fail
D0E8 i2c_receive
D0F6 i2c_receive_loop
D10B i2c_receive_done
D110 i2c_receive_fail
D115 spi_init
D12E spi_init_clock_high
D133 spi_init2
D140 spi_init_mosi_low
D145 spi_init3
D14B spi_transfer
D150 spi_transfer_loop
D15C spi_send_zero
D161 spi_send_clock_pulse_1
D16E spi_send_clock_high_low
D173 spi_send2
D182 spi_read_02_done
D184 spi_send3
D191 spi_send_clock_low_high
D196 spi_send4
D1A5 spi_read_13_done
D1A7 spi_send_bit_done
D1AF spi_ss_low
D1B7 spi_ss_high
D1BF spi_send_two_bytes
D1CF cp437_font
D9CF introduction
DA1A LCD_welcome
DA39 START
DA55 RESTART
4240 CLOCK_RATE
