Sections:
00: "seg8000" (8000-DD65)
01: "segfffa" (FFFA-0)


Source: "gpascal.asm"
                        	     1: ;***********************************************
                        	     2: ; G-PASCAL COMPILER
                        	     3: ; for Ben Eater's breadboard computer
                        	     4: ;
                        	     5: ; Author: Nick Gammon
                        	     6: ; Date: 20 January 2022
                        	     7: ;
                        	     8: ; To compile:
                        	     9: ;
                        	    10: ;  vasm6502_oldstyle gpascal.asm -wdc02 -esc -Fbin -o gpascal.bin -dotdir -L gpascal.list
                        	    11: ;
                        	    12: ; To program EEPROM:
                        	    13: ;
                        	    14: ;  minipro -p AT28C256 -w gpascal.bin
                        	    15: ;
                        	    16: ;
                        	    17: ;
                        	    18: ; To communicate, I suggest: miniterm /dev/ttyUSB0 4800 -e
                        	    19: ;
                        	    20: ;   Miniterm: Ctrl+]        : to exit.
                        	    21: ;             Ctrl+T Ctrl+H : help
                        	    22: ;             Ctrl+T Ctrl+E : toggle local echo
                        	    23: ;
                        	    24: ;
                        	    25: ;  Copyright 2022 by Nick Gammon
                        	    26: ;
                        	    27: ;  Permission is hereby granted, free of charge, to any person obtaining a copy
                        	    28: ;  of this software and associated documentation files (the "Software"), to deal
                        	    29: ;  in the Software without restriction, including without limitation the rights
                        	    30: ;  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                        	    31: ;  copies of the Software, and to permit persons to whom the Software is
                        	    32: ;  furnished to do so, subject to the following conditions:
                        	    33: ;
                        	    34: ;  The above copyright notice and this permission notice shall be included in all
                        	    35: ;  copies or substantial portions of the Software.
                        	    36: ;
                        	    37: ;  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                        	    38: ;  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                        	    39: ;  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                        	    40: ;  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                        	    41: ;  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                        	    42: ;  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
                        	    43: ;  SOFTWARE.
                        	    44: ;
                        	    45: ;***********************************************
                        	    46: ;
                        	    47: 
                        	    48: ; Note: BCC == BLT and BCS == BGE
                        	    49: ;
                        	    50: 
                        	    51: ;
                        	    52: ;  CONDITIONAL COMPILES
                        	    53: 
                        	    54: EMULATOR = 0          ; for testing on a PC running an emulator
                        	    55: LCD_SUPPORT = 1       ; 1 = support LCD, 0 = not. Unset if you have removed the LCD.
                        	    56: SERIAL_DEBUGGING = 0  ; if set, toggle VIA PA2 when reading a bit, and PA3 when writing a bit
                        	    57:                       ;  DO NOT USE I2C if this is on, as I2C functions use these two pins
                        	    58: USE_CP437_FONT = 1    ; include the symbols for the CP437 font for use with MAX7219 chip
                        	    59: 
                        	    60: ;
                        	    61: ;  CONFIGURATION
                        	    62: ;
                        	    63: CLOCK_RATE   = 1000000   ; 1 Mhz
                        	    64: START_OF_ROM = $8000     ; where the ROM chip starts
                        	    65: HIGHEST_RAM  = $3FFF      ; original board hardware
                        	    66: ;HIGHEST_RAM  = $5FFF    ; with suggested additional AND gate
                        	    67: 
                        	    68: RUNNING_STACK_TOP = $CF   ; top of stack when running assembler code
                        	    69: 
                        	    70: ;
                        	    71: ;  serial output
                        	    72: ;
                        	    73: BAUD_RATE    = 4800         ; baud
                        	    74: BIT_INTERVAL = CLOCK_RATE / BAUD_RATE ; time between bits in Âµs
                        	    75: 
                        	    76: ;
                        	    77: ;  serial input - input commences on the interrupt generated by the falling edge
                        	    78: ;    of the start bit. Bits are then clocked in with a timed loop.
                        	    79: ;  - these delays can be tweaked if you believe the serial input is not being
                        	    80: ;    sampled at the right moment, confirm by turning SERIAL_DEBUGGING on
                        	    81: ;    and checking the debugging pulses compared to the middle of the bit times
                        	    82: ;    with an oscilloscope or logic analyser
                        	    83: ;
                        	    84: SERIAL_DELAY1 = 48    ; initial delay (count) - higher because it is 1.5 bit times
                        	    85: SERIAL_DELAY2 = 35    ; subsequent delays between bits (count)
                        	    86: 
                        	    87: SYMBOL_TABLE_START = HIGHEST_RAM  ; symbol table pointer (ENDSYM) is decremented before being used
                        	    88: 
                        	    89: STACK            =  $100  ; hardware stack address
                        	    90: SPACE            =  $20   ; uh-huh
                        	    91: SINGLE_QUOTE     =  $27
                        	    92: NL               =  $0A   ; newline
                        	    93: CR               =  $0D   ; carriage-return
                        	    94: BACKSPACE        =  $08   ; backspace
                        	    95: 
                        	    96: MAX_STK          =  32
                        	    97: NEW_STK          =  $FF
                        	    98: 
                        	    99:     .if EMULATOR
                        	   100: END_EDITOR_INPUT =  '`'   ; backtick terminates input
                        	   101:     .else
                        	   102: END_EDITOR_INPUT =  $1B   ; Esc terminates editor input
                        	   103:     .endif
                        	   104: 
                        	   105: KEY_DEBUG      = 'D'-$40   ; Ctrl+D start debugging
                        	   106: KEY_TRACE      = 'T'-$40   ; Ctrl+T start tracing
                        	   107: KEY_STOP_TRACE = 'N'-$40   ; Ctrl+N stop tracing
                        	   108: KEY_ABORT      = 'C'-$40   ; Ctrl+C abort execution
                        	   109: 
                        	   110: 
                        	   111:   .if LCD_SUPPORT
                        	   112: ;
                        	   113: ;  Pins connected from the VIA to the LCD
                        	   114: ;
                        	   115: LCD_RS             = %00100000  ; PA 5 - 0 = instruction, 1 = data
                        	   116: LCD_RW             = %01000000  ; PA 6 - 0 = write, 1 = read
                        	   117: LCD_E              = %10000000  ; PA 7 - toggle (0 -> 1 -> 0) to clock out a command or data
                        	   118:   .endif
                        	   119: 
                        	   120:   .include "zp_variables.inc"

Source: "zp_variables.inc"
                        	     1: ;***********************************************
                        	     2: ;
                        	     3: ; Zero-page variables (currently 64 (decimal) bytes are free for your use).
                        	     4: ;  I suggest using the high ones and working down in case there is a change to the code.
                        	     5: ;  For example, start with 0xFF, then 0xFE and so on.
                        	     6: ;
                        	     7: ;***********************************************
                        	     8: 
                        	     9:   .dsect
                        	    10: 
                        	    11: 
                        	    12: ;
                        	    13: ;  General work-areas for arithmetic routines (eg. add, subtract, divide, multiply)
                        	    14: ;   3-byte signed numbers: -8388608 to +8388607
                        	    15: ;
00:0000 00              	    16: VALUE    reserve 3    ; the current value of the token (ie. if a number)
00:0001 *
00:0003 00              	    17: VALUE2   reserve 3    ; used by the assembler expression evaluator
00:0004 *
                        	    18: 
                        	    19: ; SRCE and DEST used in compiler and editor, particularly for string comparisons
                        	    20: ;   (re-using VALUE and VALUE2)
                        	    21: 
                        	    22: SRCE     =  VALUE
                        	    23: DEST     =  VALUE2
                        	    24: 
00:0006 00              	    25: REMAIN   reserve 3    ; division remainder
00:0007 *
                        	    26: 
                        	    27: ;
                        	    28: ;  work "register" - re-using VALUE and VALUE2 again
                        	    29: ;
                        	    30: REG   = VALUE
                        	    31: REGB  = VALUE+2
                        	    32: REG2  = VALUE2
                        	    33: REG2B = VALUE2+2
                        	    34: 
                        	    35: ;
                        	    36: ;  re-using above for CRC-16 calculations
                        	    37: ;
                        	    38: crc_addr = VALUE      ; the address to take a CRC of (2 bytes)
                        	    39: crc_num  = VALUE2     ; the number of bytes to take a CRC of (2 bytes)
                        	    40: crc_val  = REMAIN     ; the current CRC value (2 bytes)
                        	    41: 
                        	    42: ;
                        	    43: ;  current random number - change this to reseed it
                        	    44: ;
00:0009 00              	    45: random         reserve 4 ; 32-bit random number
00:000A *
00:000D 00              	    46: typing_latency reserve 3 ; incremented while waiting for input
00:000E *
                        	    47: 
                        	    48: ;
                        	    49: ;  Used for seeding registers when calling machine code from Pascal
                        	    50: ;
00:0010 00              	    51: call_a reserve 1      ; used when doing a machine code call:  A register
00:0011 00              	    52: call_x reserve 1      ;  ditto: X register
00:0012 00              	    53: call_y reserve 1      ;  ditto: Y register
00:0013 00              	    54: call_p reserve 1      ;  ditto: status register
00:0014 00              	    55: call_s reserve 1      ; stack register, used by BRK
00:0015 00              	    56: brk_address reserve 2 ; BRK address
00:0016 *
                        	    57: 
                        	    58: ;
                        	    59: ;  address of write function (2 bytes)
                        	    60: ;
                        	    61: ;  This is called by "character out" function COUT. It writes the character in "A" to
                        	    62: ;   serial port or LCD. You could conceivably put another function address here if
                        	    63: ;   you wanted to capture output (eg. from calling DISP_BIN) and putting it somewhere else
                        	    64: ;   like into a series of memory locations, or to output to SPI.
                        	    65: ;  The functions write_to_serial and write_to_lcd
                        	    66: ;   put the appropriate outputting functions into this location.
                        	    67: ;
00:0017 00              	    68: write_function reserve 2  ; address of function to write to serial or LCD
00:0018 *
                        	    69: 
                        	    70: 
00:0019 00              	    71: LINE_CNT  reserve 2   ; line counter during compile
00:001A *
                        	    72: LINE_NO  =  LINE_CNT
                        	    73: 
00:001B 00              	    74: WX       reserve 2    ; 2-byte address used during compilation (reserved word lookup)
00:001C *
00:001D 00              	    75: LIST     reserve 1    ; 0 = no listing, 1 = list source during compile
00:001E 00              	    76: DIGIT    reserve 1    ; used only in GET_NUM to process a decimal number
00:001F 00              	    77: SIGN     reserve 1    ; used in compiling and inputting a number - is there a minus sign?
                        	    78: 
00:0020 00              	    79: FRAME    reserve 2    ; stack frame number - not totally certain but it used for procedure calls at runtime
00:0021 *
00:0022 00              	    80: LEVEL    reserve 1    ; current nested procedure/function level (how far we are nested)
00:0023 00              	    81: PCODE    reserve 2    ; current P-code address (increments during compile and running)
00:0024 *
                        	    82: PNTR     =  PCODE     ; 2-byte work pointer used in editor (eg. in find/replace etc.)
00:0025 00              	    83: ACT_PCDA reserve 2    ; start of P-codes (after source) - does not increment
00:0026 *
00:0027 00              	    84: DISPL    reserve 2    ; level? ahhh ... I don't know
00:0028 *
00:0029 00              	    85: OFFSET   reserve 2    ; variable offset? maybe just a work area
00:002A *
00:002B 00              	    86: OPND     reserve 3    ; jump operand ... not sure
00:002C *
00:002E 00              	    87: DCODE    reserve 1     ; 0 = no display, 1 = display P-codes during compile
00:002F 00              	    88: STARTSYM reserve 2    ; start of symbol table
00:0030 *
00:0031 00              	    89: ENDSYM   reserve 2    ; end of symbol table - used for reverse searching symbols
00:0032 *
                        	    90: T        =  ENDSYM     ; stack pointer 2 bytes
00:0033 00              	    91: WORKD    reserve 2    ; work area for holding P-code address
00:0034 *
00:0035 00              	    92: ERRNO    reserve 1    ; current error number, if ERROR called
00:0036 00              	    93: BSAVE    reserve 1    ; seems to be used to save "A" register, lol
00:0037 00              	    94: WORK     reserve 2    ; work area, used for pushing 2-bytes onto the (processor) stack
00:0038 *
00:0039 00              	    95: PRCITM   reserve 2    ; seems to hold the current procedure/function symbol
00:003A *
00:003B 00              	    96: BASE     reserve 2    ; the base interpreter stack frame (for this procedure)
00:003C *
                        	    97: TO       =  BASE      ; Used in editor (from/to list ranges, and copying text)
00:003D 00              	    98: DATA     reserve 2    ; 2-byte address work-area for calculating the address of a variable at runtime
00:003E *
00:003F 00              	    99: RUNNING  reserve 1    ; 0x40 - in editor, 0x80 - executing - affects stuff like numeric conversion
00:0040 00              	   100: SYMITM   reserve 2    ; current symbol table item (found by searching)
00:0041 *
                        	   101: FROM     =  SYMITM    ; Used in editor (from/to list ranges, and copying text)
00:0042 00              	   102: SYNTAX   reserve 1    ; 0 = full compile, 1 = syntax-only compile (no writing to memory)
00:0043 00              	   103: END_PCD  reserve 2    ; where the P-codes ended after a compile
00:0044 *
00:0045 00              	   104: TEMP     reserve 2    ; temporary work area?
00:0046 *
00:0047 00              	   105: CALL     reserve 2    ; the procedure address we are calling
00:0048 *
00:0049 00              	   106: DBGFLG   reserve 1    ; 0 = not debugging, 1 = debugging, $80 = tracing
00:004A 00              	   107: DATTYP   reserve 1    ; 0 for integers and 1 for characters
00:004B 00              	   108: COUNT1   reserve 1    ; work counter
00:004C 00              	   109: COUNT2   reserve 1    ; and another
00:004D 00              	   110: LASTP    reserve 2    ; 2-byte last P-code address executed at runtime (start of this P-code)
00:004E *
00:004F 00              	   111: IO_A     reserve 1    ; dunno
00:0050 00              	   112: IO_Y     reserve 1    ; seems to be used to save and restore Y
00:0051 00              	   113: IO_X     reserve 1    ;  ditto for X
00:0052 00              	   114: RES      reserve 3    ; multiplication result
00:0053 *
00:0055 00              	   115: DIVISOR  reserve 3      ; divisor for division
00:0056 *
00:0058 00              	   116: DVDN     reserve 3    ; dividend
00:0059 *
00:005B 00              	   117: RMNDR    reserve 1    ; for division, 0 if positive, 0x80 if negative
00:005C 00              	   118: bcd_work    reserve 4    ; work area for converting binary to decimal (packed)
00:005D *
00:0060 00              	   119: bcd_result  reserve 8    ; work area for turning numbers into printable (unpacked)
00:0061 *
00:0068 00              	   120: spi_mode   reserve 1   ; SPI mode: 0 to 3
00:0069 00              	   121: QUOT_SYM reserve 1     ; current quote symbol
00:006A 00              	   122: QT_SIZE  reserve 1    ; number of characters in reserved words
00:006B 00              	   123: ASS_OPERAND reserve 1 ; assembler operand type = see defines below
00:006C 00              	   124: OPCODE   reserve 2    ; address of opcode in assembler
00:006D *
00:006E 00              	   125: OPCODE_LEN reserve 1  ; length of opcode
00:006F 00              	   126: ASS_EMIT_COUNT reserve 1 ; number of bytes emitted on this line
00:0070 00              	   127: ASS_OPCODE_WORK reserve 2; for opcode lookups
00:0071 *
00:0072 00              	   128: ASS_COUNT reserve 1 ; for counting opcode matches
00:0073 00              	   129: ASS_VALUE reserve 3 ; the assembler operand (address or immediate) will be here
00:0074 *
00:0076 00              	   130: ASS_PASS  reserve 1 ; which assembler pass we are up to
00:0077 00              	   131: ass_emit_bytes reserve 2 ; how many bytes the assembler emitted altogether
00:0078 *
00:0079 00              	   132: exp_value_stack reserve 2  ; address of assembler value stack
00:007A *
00:007B 00              	   133: exp_value_stack_count reserve 1 ; how far through value stack we are (0 = empty)
00:007C 00              	   134: exp_operator_stack_count reserve 1 ;  how far through operator stack we are (0 = empty)
00:007D 00              	   135: exp_operator reserve 1  ; current operator for expression evaluation
00:007E 00              	   136: exp_operator_precedence reserve 1 ; current operator precedence
00:007F 00              	   137: exp_evaluation_function reserve 2 ; function to evaluate an expression
00:0080 *
00:0081 00              	   138: exp_unary_ok reserve 1  ; true if the next token can be a unary operator (like: - < >)
00:0082 00              	   139: show_symbols reserve 1  ; 4 = list the symbol table after an assemble, 8 = include library symbols
00:0083 00              	   140: ass_current_label reserve 2 ; current symbol table address of the label on this line
00:0084 *
00:0085 00              	   141: str_work reserve 1      ; work byte for string compares
                        	   142:   .if LCD_SUPPORT
00:0086 00              	   143: lcd_work  reserve 1 ; used by the LCD routines
                        	   144:   .endif
                        	   145: 
                        	   146: ;
                        	   147: ;  serial work
                        	   148: ;
00:0087 00              	   149: serial_out_byte reserve 2 ; current byte we are sending
00:0088 *
00:0089 00              	   150: serial_out_bit  reserve 1 ; current bit count
00:008A 00              	   151: serial_in_byte  reserve 1 ; current byte we are receiving
00:008B 00              	   152: serial_in_byte_received  reserve 1 ; last received byte
                        	   153: 
                        	   154: ;
                        	   155: ; hardware
                        	   156: ;
00:008C 00              	   157: hardware_work  reserve 1  ; work for use during interpreting
                        	   158: 
                        	   159: ;
                        	   160: ; maths
                        	   161: ;
00:008D 00              	   162: maths_work  reserve 1 ; work for multiply/divide
                        	   163: ;
                        	   164: ;  for get_token
                        	   165: ;
00:008E 00              	   166: token_start      reserve 2  ; where to start looking for a token
00:008F *
00:0090 00              	   167: token_address    reserve 2  ; where the token actually started
00:0091 *
00:0092 00              	   168: token_length     reserve 1  ; length of the token
00:0093 00              	   169: token_type       reserve 1  ; what type of token it is
00:0094 00              	   170: token_value      reserve 3  ; the value of numeric tokens
00:0095 *
00:0097 00              	   171: token_sign       reserve 1  ; non-zero if negative value
00:0098 00              	   172: token_work       reserve 3  ; temporary work area - also used by handlerLookup
00:0099 *
00:009B 00              	   173: token_digit      reserve 1  ; used by get_token
00:009C 00              	   174: token_line_start reserve 2  ; where the current line starts
00:009D *
                        	   175: 
                        	   176: ;
                        	   177: ;  for editor
                        	   178: ;
00:009E 00              	   179: from_line       reserve 2     ; list, delete, modify: FROM line number
00:009F *
00:00A0 00              	   180: to_line         reserve 2     ; list, delete, modify: TO line number
00:00A1 *
00:00A2 00              	   181: current_line    reserve 2     ; current editor line number
00:00A3 *
00:00A4 00              	   182: insert_limit    reserve 2     ; maximum we can input to
00:00A5 *
00:00A6 00              	   183: mem_move_src    reserve 2     ; for copying memory - source of move
00:00A7 *
00:00A8 00              	   184: mem_move_dest   reserve 2     ; for copying memory - destination of move
00:00A9 *
00:00AA 00              	   185: mem_move_len    reserve 2     ; for copying memory - length of move
00:00AB *
00:00AC 00              	   186: this_line       reserve 2     ; which line we are searching for
00:00AD *
00:00AE 00              	   187: this_line_addr  reserve 2     ; address of the "this" line
00:00AF *
00:00B0 00              	   188: find_from       reserve 1     ; editor find: from offset in INBUF (start of target string)
00:00B1 00              	   189: find_to         reserve 1     ; editor find: to offset in INBUF (end of target string)
00:00B2 00              	   190: find_pos        reserve 1     ; which offset in the current line we are currently searching from
00:00B3 00              	   191: find_len        reserve 1     ; the length of the find text
00:00B4 00              	   192: find_delimiter  reserve 1     ; the find/replace delimiter
00:00B5 00              	   193: rep_from        reserve 1     ; editor replace: start of replacement string
00:00B6 00              	   194: rep_to          reserve 1     ; editor replace: end of replacement string
00:00B7 00              	   195: rep_diff        reserve 2     ; difference in find/replace string lengths (signed 2 bytes)
00:00B8 *
00:00B9 00              	   196: find_count      reserve 2     ; count of find/replace
00:00BA *
00:00BB 00              	   197: found_this_line reserve 1     ; did we find something on this line?
                        	   198: insert_last_char = find_from  ; the last character we inserted in INSERT/LOAD mode
                        	   199: 
00:00BC 00              	   200: editor_flags    reserve 1     ; various flags, see below
                        	   201: 
                        	   202: EFLAG_SHOW_LINE        = %00000001    ; set after receiving a newline, so we display the next line
                        	   203: EFLAG_ALLOW_ZERO_FROM  = %00000010    ; for use with MEMORY, allow them to start from $0000
                        	   204: EFLAG_LOAD             = %00000100    ; doing a LOAD, do not show line numbers when inserting
                        	   205: EFLAG_SAVE             = %00001000    ; doing a SAVE, do not show line numbers
                        	   206: EFLAG_FIND             = %00010000    ; doing a FIND
                        	   207: EFLAG_REPLACE          = %00100000    ; doing a REPLACE
                        	   208: EFLAG_SUPPRESS_NEWLINE = %01000000    ; don't show newlines
                        	   209: EFLAG_NO_LINE_NUMBERS  = %10000000    ; don't show line numbers
                        	   210: 
00:00BD 00              	   211: find_flags     reserve 1      ; find/replace flags, see below
                        	   212: 
                        	   213: FFLAG_IGNORE_CASE = %00000001
                        	   214: FFLAG_GLOBAL      = %00000010
                        	   215: FFLAG_QUIET       = %00000100
                        	   216: 
                        	   217: ;
                        	   218: ;  system flags
                        	   219: ;
                        	   220: 
00:00BE 00              	   221: system_flags    reserve 1    ; general flags
                        	   222: 
                        	   223: FLAG_COMPILING      = %00000001
                        	   224: FLAG_ASSEMBLING     = %00000010
                        	   225: FLAG_LIST_SOURCE    = %00000100
                        	   226: FLAG_VALID_COMPILE  = %00001000
                        	   227: FLAG_VALID_ASSEMBLE = %00010000
                        	   228: FLAG_RUNNING        = %00100000
                        	   229: FLAG_ONLY_ALPHA     = %01000000   ; for editor, so you can L5 to do LIST 5
                        	   230: FLAG_BRK_REACHED    = %10000000   ; Breakpoint encountered during run
                        	   231: 

Source: "gpascal.asm"
                        	   121: 
                        	   122: ;
                        	   123: ;  A general work-buffer is allocated from $200 to $2FF for use during keyboard input, and also
                        	   124: ;  for converting strings during tokenisation (eg. two quotes in a row to one quote, and handling
                        	   125: ;  string escape sequences). It is also used during assembly as a 256-byte operator stack.
                        	   126: ;
                        	   127:   .org $200
                        	   128: INBUF_SIZE = 256          ; we use this for string storage during tokenisation
01:0200 00              	   129: INBUF  reserve INBUF_SIZE ; and also for preprocessing string literals (eg. backslash expansion)
01:0201 *
                        	   130: TEXT_START = *            ; where source goes in memory (currently $300)
                        	   131:   .dend
                        	   132: 
                        	   133: 
                        	   134: 
                        	   135: ;------------------------------------------
                        	   136: ;  Macros
                        	   137: ;------------------------------------------
                        	   138: 
                        	   139:  .macro tknjmpItem ; tknjmp entry: token, handler
                        	   140:    dfb   \1
                        	   141:    word  \2
                        	   142:  .endmacro
                        	   143: 
                        	   144:  .macro makeHandler ; table of words and handlers: word, handler
                        	   145:    asciiz   \1
                        	   146:    word  \2
                        	   147:  .endmacro
                        	   148: 
                        	   149: ;
                        	   150: ; makePasLibraryFunction NAME (SYMNAM), TYPE (SYMTYP), ARG_COUNT (SYMARG), EXECUTION_ADDRESS (SYMDSP)
                        	   151: ;
                        	   152: ;   TYPE = SYMBOL_LIBRARY_PROCEDURE or SYMBOL_LIBRARY_FUNCTION
                        	   153:    .macro makePasLibraryFunction
                        	   154:      asciiz   \1
                        	   155:      dfb      \2
                        	   156:      dfb      \3
                        	   157:      word     \4
                        	   158:    .endmacro
                        	   159: 
                        	   160: ;
                        	   161: ; makeAsmLibraryFunction NAME (SYMNAM), EXECUTION_ADDRESS (SYMDSP)
                        	   162: ;
                        	   163:    .macro makeAsmLibraryFunction
                        	   164:      asciiz   \1
                        	   165:      word     \2
                        	   166:    .endmacro
                        	   167: 
                        	   168:   ORG  START_OF_ROM   ; normally $8000 in the case of Ben Eater's board
                        	   169: 
00:8000 4C30DD          	   170:   JMP  START   ; where RESET takes us - a cold start
00:8003 4C4CDD          	   171:   JMP  RESTART ; where NMI takes us - a warm start
                        	   172: 
                        	   173: ;***********************************************
                        	   174: ; INCLUDES
                        	   175: ;***********************************************
                        	   176: 
                        	   177:   .include "memory.inc"

Source: "memory.inc"
                        	     1: ;---------------------------
                        	     2: ; standard library stuff
                        	     3: ;---------------------------
                        	     4: 
                        	     5: ;
                        	     6: ;  character type masks
                        	     7: ;
                        	     8: m_upper   = %00000001    ; $01
                        	     9: m_lower   = %00000010    ; $02
                        	    10: m_alpha   = %00000100    ; $04
                        	    11: m_digit   = %00001000    ; $08
                        	    12: m_xdigit  = %00010000    ; $10
                        	    13: m_space   = %00100000    ; $20
                        	    14: m_cntrl   = %01000000    ; $40
                        	    15: m_alnum   = %10000000    ; $80
                        	    16: 
                        	    17: ;
                        	    18: ;  for fast checks which corrupt registers
                        	    19: ;
                        	    20: ;    ldx THE_CHARACTER_TO_BE_TESTED
                        	    21: ;    lda character_types_table,X
                        	    22: ;    bne IS_IN_THAT_CLASS
                        	    23: ;
                        	    24: 
                        	    25: character_types_table = *
00:8006 40              	    26:   dfb $40,$40,$40,$40,$40,$40,$40,$40    ; 0x00
00:8007 40
00:8008 40
00:8009 40
00:800A 40
00:800B 40
00:800C 40
00:800D 40
00:800E 40              	    27:   dfb $40,$60,$60,$60,$60,$60,$40,$40    ; 0x08
00:800F 60
00:8010 60
00:8011 60
00:8012 60
00:8013 60
00:8014 40
00:8015 40
00:8016 40              	    28:   dfb $40,$40,$40,$40,$40,$40,$40,$40    ; 0x10
00:8017 40
00:8018 40
00:8019 40
00:801A 40
00:801B 40
00:801C 40
00:801D 40
00:801E 40              	    29:   dfb $40,$40,$40,$40,$40,$40,$40,$40    ; 0x18
00:801F 40
00:8020 40
00:8021 40
00:8022 40
00:8023 40
00:8024 40
00:8025 40
00:8026 20              	    30:   dfb $20,$00,$00,$00,$00,$00,$00,$00    ; 0x20   !"#$%&'
00:8027 00
00:8028 00
00:8029 00
00:802A 00
00:802B 00
00:802C 00
00:802D 00
00:802E 00              	    31:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x28  ()*+,-./
00:802F 00
00:8030 00
00:8031 00
00:8032 00
00:8033 00
00:8034 00
00:8035 00
00:8036 98              	    32:   dfb $98,$98,$98,$98,$98,$98,$98,$98    ; 0x30  01234567
00:8037 98
00:8038 98
00:8039 98
00:803A 98
00:803B 98
00:803C 98
00:803D 98
00:803E 98              	    33:   dfb $98,$98,$00,$00,$00,$00,$00,$00    ; 0x38  89:;<=>?
00:803F 98
00:8040 00
00:8041 00
00:8042 00
00:8043 00
00:8044 00
00:8045 00
00:8046 00              	    34:   dfb $00,$95,$95,$95,$95,$95,$95,$85    ; 0x40  @ABCDEFG
00:8047 95
00:8048 95
00:8049 95
00:804A 95
00:804B 95
00:804C 95
00:804D 85
00:804E 85              	    35:   dfb $85,$85,$85,$85,$85,$85,$85,$85    ; 0x48  HIJKLMNO
00:804F 85
00:8050 85
00:8051 85
00:8052 85
00:8053 85
00:8054 85
00:8055 85
00:8056 85              	    36:   dfb $85,$85,$85,$85,$85,$85,$85,$85    ; 0x50  PQRSTUVW
00:8057 85
00:8058 85
00:8059 85
00:805A 85
00:805B 85
00:805C 85
00:805D 85
00:805E 85              	    37:   dfb $85,$85,$85,$00,$00,$00,$00,$00    ; 0x58  XYZ[\]^_
00:805F 85
00:8060 85
00:8061 00
00:8062 00
00:8063 00
00:8064 00
00:8065 00
00:8066 00              	    38:   dfb $00,$96,$96,$96,$96,$96,$96,$86    ; 0x60  `abcdefg
00:8067 96
00:8068 96
00:8069 96
00:806A 96
00:806B 96
00:806C 96
00:806D 86
00:806E 86              	    39:   dfb $86,$86,$86,$86,$86,$86,$86,$86    ; 0x68  hijklmno
00:806F 86
00:8070 86
00:8071 86
00:8072 86
00:8073 86
00:8074 86
00:8075 86
00:8076 86              	    40:   dfb $86,$86,$86,$86,$86,$86,$86,$86    ; 0x70  pqrstuvw
00:8077 86
00:8078 86
00:8079 86
00:807A 86
00:807B 86
00:807C 86
00:807D 86
00:807E 86              	    41:   dfb $86,$86,$86,$00,$00,$00,$00,$40    ; 0x78  xyz{|}~
00:807F 86
00:8080 86
00:8081 00
00:8082 00
00:8083 00
00:8084 00
00:8085 40
00:8086 00              	    42:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x80
00:8087 00
00:8088 00
00:8089 00
00:808A 00
00:808B 00
00:808C 00
00:808D 00
00:808E 00              	    43:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x88
00:808F 00
00:8090 00
00:8091 00
00:8092 00
00:8093 00
00:8094 00
00:8095 00
00:8096 00              	    44:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x90
00:8097 00
00:8098 00
00:8099 00
00:809A 00
00:809B 00
00:809C 00
00:809D 00
00:809E 00              	    45:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x98
00:809F 00
00:80A0 00
00:80A1 00
00:80A2 00
00:80A3 00
00:80A4 00
00:80A5 00
00:80A6 00              	    46:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xA0
00:80A7 00
00:80A8 00
00:80A9 00
00:80AA 00
00:80AB 00
00:80AC 00
00:80AD 00
00:80AE 00              	    47:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xA8
00:80AF 00
00:80B0 00
00:80B1 00
00:80B2 00
00:80B3 00
00:80B4 00
00:80B5 00
00:80B6 00              	    48:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xB0
00:80B7 00
00:80B8 00
00:80B9 00
00:80BA 00
00:80BB 00
00:80BC 00
00:80BD 00
00:80BE 00              	    49:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xB8
00:80BF 00
00:80C0 00
00:80C1 00
00:80C2 00
00:80C3 00
00:80C4 00
00:80C5 00
00:80C6 00              	    50:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xC0
00:80C7 00
00:80C8 00
00:80C9 00
00:80CA 00
00:80CB 00
00:80CC 00
00:80CD 00
00:80CE 00              	    51:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xC8
00:80CF 00
00:80D0 00
00:80D1 00
00:80D2 00
00:80D3 00
00:80D4 00
00:80D5 00
00:80D6 00              	    52:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xD0
00:80D7 00
00:80D8 00
00:80D9 00
00:80DA 00
00:80DB 00
00:80DC 00
00:80DD 00
00:80DE 00              	    53:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xD8
00:80DF 00
00:80E0 00
00:80E1 00
00:80E2 00
00:80E3 00
00:80E4 00
00:80E5 00
00:80E6 00              	    54:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xE0
00:80E7 00
00:80E8 00
00:80E9 00
00:80EA 00
00:80EB 00
00:80EC 00
00:80ED 00
00:80EE 00              	    55:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xE8
00:80EF 00
00:80F0 00
00:80F1 00
00:80F2 00
00:80F3 00
00:80F4 00
00:80F5 00
00:80F6 00              	    56:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xF0
00:80F7 00
00:80F8 00
00:80F9 00
00:80FA 00
00:80FB 00
00:80FC 00
00:80FD 00
00:80FE 00              	    57:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xF8
00:80FF 00
00:8100 00
00:8101 00
00:8102 00
00:8103 00
00:8104 00
00:8105 00
                        	    58: 
                        	    59: ;
                        	    60: ;  character type tests: test character in A, Carry set if true, carry clear if false
                        	    61: ;    -no registers changed
                        	    62: ;
                        	    63: is_xxx_fail:
00:8106 FA              	    64:   plx
00:8107 68              	    65:   pla
00:8108 18              	    66:   clc
00:8109 60              	    67:   rts
                        	    68: 
                        	    69: is_xxx_pass:
00:810A FA              	    70:   plx
00:810B 68              	    71:   pla
00:810C 38              	    72:   sec
00:810D 60              	    73:   rts
                        	    74: 
                        	    75:   .macro isXXX
                        	    76: \1 = *
                        	    77:   pha
                        	    78:   phx
                        	    79:   tax
                        	    80:   lda character_types_table,x
                        	    81:   and #\2
                        	    82:   beq is_xxx_fail
                        	    83:   bra is_xxx_pass
                        	    84:   .endmacro
                        	    85: 
                        	    86: ;
                        	    87: ;  generate the various character type tests - done by fast table lookup
                        	    88: ;
                        	    89:   isXXX isupper,  m_upper
                        	     1M isupper = *
00:810E 48              	     2M   pha
00:810F DA              	     3M   phx
00:8110 AA              	     4M   tax
00:8111 BD0680          	     5M   lda character_types_table,x
00:8114 2901            	     6M   and #m_upper
00:8116 F0EE            	     7M   beq is_xxx_fail
00:8118 80F0            	     8M   bra is_xxx_pass
                        	    90:   isXXX islower,  m_lower
                        	     1M islower = *
00:811A 48              	     2M   pha
00:811B DA              	     3M   phx
00:811C AA              	     4M   tax
00:811D BD0680          	     5M   lda character_types_table,x
00:8120 2902            	     6M   and #m_lower
00:8122 F0E2            	     7M   beq is_xxx_fail
00:8124 80E4            	     8M   bra is_xxx_pass
                        	    91:   isXXX isalpha,  m_alpha
                        	     1M isalpha = *
00:8126 48              	     2M   pha
00:8127 DA              	     3M   phx
00:8128 AA              	     4M   tax
00:8129 BD0680          	     5M   lda character_types_table,x
00:812C 2904            	     6M   and #m_alpha
00:812E F0D6            	     7M   beq is_xxx_fail
00:8130 80D8            	     8M   bra is_xxx_pass
                        	    92:   isXXX isdigit,  m_digit
                        	     1M isdigit = *
00:8132 48              	     2M   pha
00:8133 DA              	     3M   phx
00:8134 AA              	     4M   tax
00:8135 BD0680          	     5M   lda character_types_table,x
00:8138 2908            	     6M   and #m_digit
00:813A F0CA            	     7M   beq is_xxx_fail
00:813C 80CC            	     8M   bra is_xxx_pass
                        	    93:   isXXX isxdigit, m_xdigit
                        	     1M isxdigit = *
00:813E 48              	     2M   pha
00:813F DA              	     3M   phx
00:8140 AA              	     4M   tax
00:8141 BD0680          	     5M   lda character_types_table,x
00:8144 2910            	     6M   and #m_xdigit
00:8146 F0BE            	     7M   beq is_xxx_fail
00:8148 80C0            	     8M   bra is_xxx_pass
                        	    94:   isXXX isspace,  m_space
                        	     1M isspace = *
00:814A 48              	     2M   pha
00:814B DA              	     3M   phx
00:814C AA              	     4M   tax
00:814D BD0680          	     5M   lda character_types_table,x
00:8150 2920            	     6M   and #m_space
00:8152 F0B2            	     7M   beq is_xxx_fail
00:8154 80B4            	     8M   bra is_xxx_pass
                        	    95:   isXXX iscntrl,  m_cntrl
                        	     1M iscntrl = *
00:8156 48              	     2M   pha
00:8157 DA              	     3M   phx
00:8158 AA              	     4M   tax
00:8159 BD0680          	     5M   lda character_types_table,x
00:815C 2940            	     6M   and #m_cntrl
00:815E F0A6            	     7M   beq is_xxx_fail
00:8160 80A8            	     8M   bra is_xxx_pass
                        	    96:   isXXX isalnum,  m_alnum
                        	     1M isalnum = *
00:8162 48              	     2M   pha
00:8163 DA              	     3M   phx
00:8164 AA              	     4M   tax
00:8165 BD0680          	     5M   lda character_types_table,x
00:8168 2980            	     6M   and #m_alnum
00:816A F09A            	     7M   beq is_xxx_fail
00:816C 809C            	     8M   bra is_xxx_pass
                        	    97: 
                        	    98: ;
                        	    99: ;  ran out of bits so implemented this one manually
                        	   100: ;
                        	   101: isbinary   =  *
00:816E C930            	   102:          cmp  #'0'
00:8170 F004            	   103:          beq  isbin
00:8172 C931            	   104:          cmp  #'1'
00:8174 D002            	   105:          bne  notbin
                        	   106: isbin:
00:8176 38              	   107:          sec
00:8177 60              	   108:          rts
                        	   109: notbin:
00:8178 18              	   110:          clc
00:8179 60              	   111:          rts
                        	   112: 
                        	   113: ;
                        	   114: ; Move memory down  (mem_move_dest is < mem_move_src)
                        	   115: ;
                        	   116: ;  Copies first byte first, working upwards
                        	   117: ;
                        	   118: ; mem_move_src = source start address
                        	   119: ; mem_move_dest = destination start address
                        	   120: ; mem_move_len = number of bytes mem_move_dest move
                        	   121: ;
                        	   122: movedown:
00:817A A5AA            	   123:   lda mem_move_len
00:817C 05AB            	   124:   ora mem_move_len+1
00:817E F01C            	   125:   beq movedown_done
00:8180 A000            	   126:   ldy #0
00:8182 8498            	   127:   sty  token_work      ; counter
00:8184 8499            	   128:   sty  token_work+1
                        	   129: ;
                        	   130: ;  copy one byte, increment counter
                        	   131: ;
                        	   132: movedown_loop:
00:8186 B1A6            	   133:   lda (mem_move_src),Y
00:8188 91A8            	   134:   sta (mem_move_dest),Y
00:818A E698            	   135:   inc token_work
00:818C D002            	   136:   bne movedown2
00:818E E699            	   137:   inc token_work+1
                        	   138: ;
                        	   139: ;  see if length reached
                        	   140: ;
                        	   141: movedown2:
                        	   142: 
00:8190 A598            	   143:   lda  token_work
00:8192 C5AA            	   144:   cmp  mem_move_len
00:8194 D007            	   145:   bne  movedown1
00:8196 A599            	   146:   lda  token_work+1
00:8198 C5AB            	   147:   cmp  mem_move_len+1
00:819A D001            	   148:   bne  movedown1
                        	   149: movedown_done:
00:819C 60              	   150:   rts
                        	   151: 
                        	   152: ;
                        	   153: ; increment Y, and increment high-order address bytes if necessary
                        	   154: ;
                        	   155: movedown1:
00:819D C8              	   156:   iny
00:819E D0E6            	   157:   bne  movedown_loop
00:81A0 E6A7            	   158:   inc  mem_move_src+1
00:81A2 E6A9            	   159:   inc  mem_move_dest+1
00:81A4 80E0            	   160:   bra  movedown_loop
                        	   161: 
                        	   162: ; Move memory up (mem_move_dest is > mem_move_src)
                        	   163: ;
                        	   164: ;   Copies last byte first, moving downwards
                        	   165: ;
                        	   166: ; mem_move_src = source start address
                        	   167: ; mem_move_dest = destination start address
                        	   168: ; mem_move_len = number of bytes mem_move_dest move
                        	   169: ;
                        	   170: moveup:
00:81A6 A5AA            	   171:   lda mem_move_len
00:81A8 05AB            	   172:   ora mem_move_len+1
00:81AA F038            	   173:   beq moveup_done
00:81AC A000            	   174:   ldy #0
00:81AE 8498            	   175:   sty  token_work      ; counter
00:81B0 8499            	   176:   sty  token_work+1
                        	   177:   ;
                        	   178:   ;  calculate final address of source
                        	   179:   ;
00:81B2 18              	   180:   clc
00:81B3 A5A6            	   181:   lda mem_move_src
00:81B5 65AA            	   182:   adc mem_move_len
00:81B7 85A6            	   183:   sta mem_move_src
00:81B9 A5A7            	   184:   lda mem_move_src+1
00:81BB 65AB            	   185:   adc mem_move_len+1
00:81BD 85A7            	   186:   sta mem_move_src+1
                        	   187:   ;
                        	   188:   ;  calculate final address of destination
                        	   189:   ;
00:81BF 18              	   190:   clc
00:81C0 A5A8            	   191:   lda mem_move_dest
00:81C2 65AA            	   192:   adc mem_move_len
00:81C4 85A8            	   193:   sta mem_move_dest
00:81C6 A5A9            	   194:   lda mem_move_dest+1
00:81C8 65AB            	   195:   adc mem_move_len+1
00:81CA 85A9            	   196:   sta mem_move_dest+1
00:81CC 8017            	   197:   bra moveup_next   ; have to decrement first
                        	   198: ;
                        	   199: ; move one byte, count moves
                        	   200: ;
                        	   201: moveup_loop:
00:81CE B1A6            	   202:   lda (mem_move_src),Y
00:81D0 91A8            	   203:   sta (mem_move_dest),Y
00:81D2 E698            	   204:   inc token_work
00:81D4 D002            	   205:   bne moveup3
00:81D6 E699            	   206:   inc token_work+1
                        	   207: moveup3:
                        	   208: ;
                        	   209: ;  see if length reached
                        	   210: ;
00:81D8 A598            	   211:   lda token_work
00:81DA C5AA            	   212:   cmp mem_move_len
00:81DC D007            	   213:   bne moveup_next
00:81DE A599            	   214:   lda token_work+1
00:81E0 C5AB            	   215:   cmp mem_move_len+1
00:81E2 D001            	   216:   bne moveup_next
                        	   217: moveup_done:
00:81E4 60              	   218:   rts
                        	   219: ;
                        	   220: ;  decrement Y, and decrement high-order address bytes if necessary
                        	   221: ;
                        	   222: moveup_next   =  *
00:81E5 88              	   223:   dey
00:81E6 C0FF            	   224:   cpy #$FF
00:81E8 D0E4            	   225:   bne moveup_loop
00:81EA C6A7            	   226:   dec mem_move_src+1
00:81EC C6A9            	   227:   dec mem_move_dest+1
00:81EE 80DE            	   228:   bra moveup_loop
                        	   229: 
                        	   230: ;
                        	   231: ;
                        	   232: ; String compare - case significant (max 128 byte strings)
                        	   233: ;
                        	   234: ; SRCE = source start address
                        	   235: ; DEST = destination start address
                        	   236: ; Y    = length of both strings (range 1 to 128)
                        	   237: ;
                        	   238: ;  returns Z set if strings are equal
                        	   239: ;
                        	   240: 
                        	   241: str_compare:
00:81F0 88              	   242:   dey             ; make zero-relative
00:81F1 300B            	   243:   bmi str_compare_done
00:81F3 B100            	   244:   lda (SRCE),y
00:81F5 8585            	   245:   sta str_work
00:81F7 B103            	   246:   lda (DEST),y
00:81F9 C585            	   247:   cmp str_work
00:81FB F0F3            	   248:   beq str_compare
00:81FD 60              	   249:   rts   ; no match, zero flag not set
                        	   250: str_compare_done:
00:81FE A900            	   251:   lda #0    ; set Z flag
00:8200 60              	   252:   rts
                        	   253: 
                        	   254: ;
                        	   255: ; String compare - case NOT significant (max 128 byte strings)
                        	   256: ;
                        	   257: ; SRCE = source start address
                        	   258: ; DEST = destination start address
                        	   259: ; Y    = length of both strings (range 1 to 128)
                        	   260: ;
                        	   261: ;  returns Z set if strings are equal
                        	   262: ;
                        	   263: 
                        	   264: str_ic_compare:
00:8201 88              	   265:   dey
00:8202 301F            	   266:   bmi str_ic_compare_done
00:8204 B100            	   267:   lda (SRCE),y
00:8206 C97B            	   268:   cmp #'z'+1
00:8208 B006            	   269:   bcs str_ic_compare_fixed_srce  ; BGE
00:820A C961            	   270:   cmp #'a'
00:820C 9002            	   271:   bcc str_ic_compare_fixed_srce  ; BLT
00:820E E920            	   272:   sbc #$20    ; make upper-case
                        	   273: str_ic_compare_fixed_srce:
00:8210 8585            	   274:   sta str_work
00:8212 B103            	   275:   lda (DEST),y
00:8214 C97B            	   276:   cmp #'z'+1
00:8216 B006            	   277:   bcs str_ic_compare_fixed_dest  ; BGE
00:8218 C961            	   278:   cmp #'a'
00:821A 9002            	   279:   bcc str_ic_compare_fixed_dest  ; BLT
00:821C E920            	   280:   sbc #$20    ; make upper-case
                        	   281: str_ic_compare_fixed_dest:
00:821E C585            	   282:   cmp str_work
00:8220 F0DF            	   283:   beq str_ic_compare
00:8222 60              	   284:   rts       ; no match, zero flag not set
                        	   285: str_ic_compare_done:
00:8223 A900            	   286:   lda #0    ; set Z flag
00:8225 60              	   287:   rts
                        	   288: 
                        	   289: 

Source: "gpascal.asm"
                        	   178:   .include "editor.inc"

Source: "editor.inc"
                        	     1: ;-------------------------------------------------
                        	     2: ;
                        	     3: ;  Shell, and text editor
                        	     4: ;
                        	     5: ;-------------------------------------------------
                        	     6: 
                        	     7: 
                        	     8: ;-------------------------------------------------
                        	     9: ;  print null-terminated message, message in A (lo) and X (hi)
                        	    10: ;  returns the length of the message in Y
                        	    11: ;-------------------------------------------------
                        	    12: print:
00:8226 A8              	    13:   tay   ; save A
00:8227 A503            	    14:   lda REG2 ; save REG2
00:8229 48              	    15:   pha
00:822A A504            	    16:   lda REG2+1  ; save REG2+1
00:822C 48              	    17:   pha
00:822D 98              	    18:   tya   ; get original A back
00:822E 8503            	    19:   sta REG2
00:8230 8604            	    20:   stx REG2+1
00:8232 A000            	    21:   ldy #0
                        	    22: print_loop:
00:8234 B103            	    23:   lda (REG2),y
00:8236 F006            	    24:   beq print_done
00:8238 209A96          	    25:   jsr COUT
00:823B C8              	    26:   iny
00:823C D0F6            	    27:   bne print_loop  ; give up if we overflow
                        	    28: print_done:
                        	    29: ;  stz serial_in_byte_received   ; TODO: Not sure about this
                        	    30: ;
                        	    31: ;  get REG2 back
                        	    32: ;
00:823E 68              	    33:   pla
00:823F 8504            	    34:   sta REG2+1
00:8241 68              	    35:   pla
00:8242 8503            	    36:   sta REG2
00:8244 60              	    37:   rts
                        	    38: 
00:8245 3A20            	    39: prompt       asciiz ": "
00:8247 00
00:8248 556E6B6E6F776E20	    40: bad_command  asciiz "Unknown command, type H for help.\n"
00:8250 636F6D6D616E642C
00:8258 2074797065204820
00:8260 666F722068656C70
00:8268 2E0A
00:826A 00
                        	    41: 
                        	    42: ;-------------------------------------------------
                        	    43: ; Start here after Reset or NMI - show introduction
                        	    44: ;-------------------------------------------------
                        	    45: 
                        	    46: main_start:
00:826B A9C6            	    47:   lda #<introduction
00:826D A2DC            	    48:   ldx #>introduction
00:826F 202682          	    49:   jsr print
                        	    50: 
                        	    51: main_prompt:
00:8272 A2FF            	    52:   ldx  #NEW_STK
00:8274 9A              	    53:   txs
00:8275 D8              	    54:   cld
                        	    55: 
00:8276 A945            	    56:   lda #<prompt
00:8278 A282            	    57:   ldx #>prompt
00:827A 202682          	    58:   jsr print
                        	    59: 
00:827D 207296          	    60:   jsr  GET_LINE
                        	    61: 
00:8280 A900            	    62:   lda #<INBUF
00:8282 858E            	    63:   sta token_start
00:8284 A902            	    64:   lda #>INBUF
00:8286 858F            	    65:   sta token_start+1
                        	    66: 
00:8288 A901            	    67:   lda #1
00:828A 853F            	    68:   sta RUNNING
                        	    69: 
                        	    70: ;-------------------------------------------------
                        	    71: ; EDITOR (SHELL) MAIN LOOP
                        	    72: ;-------------------------------------------------
                        	    73: 
                        	    74: main_loop:
00:828C 64BC            	    75:   stz editor_flags  ; no flags yet
00:828E 64BD            	    76:   stz find_flags    ;  ditto
00:8290 A901            	    77:   lda #FLAG_COMPILING
00:8292 0902            	    78:   ora #FLAG_ASSEMBLING
00:8294 14BE            	    79:   trb system_flags  ; not compiling or assembling now
                        	    80: 
00:8296 A940            	    81:   lda #FLAG_ONLY_ALPHA
00:8298 04BE            	    82:   tsb system_flags  ; we only want alpha commands, thus we can enter L1 and be the same as List 1
                        	    83: 
00:829A 208FCC          	    84:   jsr get_token
00:829D F0D3            	    85:   beq main_prompt   ; no input
                        	    86: 
                        	    87: ;
                        	    88: ;  Shortcut: If the input is "R" or "r" followed directly by a newline, assume they want to Run
                        	    89: ;
00:829F C949            	    90:   cmp #TOKEN_IDENTIFIER
00:82A1 D015            	    91:   bne main_loop_not_run
                        	    92: 
00:82A3 A000            	    93:   ldy #0
00:82A5 B190            	    94:   lda (token_address),y
00:82A7 20A892          	    95:   jsr MAKE_UPPER
00:82AA C952            	    96:   cmp #'R'
00:82AC D00A            	    97:   bne main_loop_not_run
00:82AE C8              	    98:   iny
00:82AF B190            	    99:   lda (token_address),y
00:82B1 C90A            	   100:   cmp #NL
00:82B3 D003            	   101:   bne main_loop_not_run
00:82B5 4C298F          	   102:   jmp editor_run
                        	   103: 
                        	   104: ;
                        	   105: ;  Not a RUN shortcut, look up the command in our table
                        	   106: ;
                        	   107: main_loop_not_run:
                        	   108: ;
                        	   109: ;  set up our input line as where to find tokens
                        	   110: ;
00:82B8 A590            	   111:   lda token_address
00:82BA 8500            	   112:   sta SRCE
00:82BC A591            	   113:   lda token_address+1
00:82BE 8501            	   114:   sta SRCE+1
                        	   115: 
                        	   116: ;
                        	   117: ;  get editor handlers
                        	   118: ;
00:82C0 A9D6            	   119:   lda #<editor_handlers
00:82C2 8503            	   120:   sta DEST
00:82C4 A982            	   121:   lda #>editor_handlers
00:82C6 8504            	   122:   sta DEST+1
                        	   123: 
                        	   124: ;
                        	   125: ;  get the token length and look up the handler
                        	   126: ;
00:82C8 A592            	   127:   lda token_length
00:82CA 203192          	   128:   jsr partial_handler_Lookup
                        	   129: 
                        	   130: ;
                        	   131: ;  if we returned, unknown command
                        	   132: ;
00:82CD A948            	   133:   lda #<bad_command
00:82CF A282            	   134:   ldx #>bad_command
00:82D1 202682          	   135:   jsr print
00:82D4 809C            	   136:   bra  main_prompt
                        	   137: 
                        	   138: 
                        	   139: editor_handlers:
                        	   140:   makeHandler "LIST",    editor_list
00:82D6 4C495354        	     1M    asciiz   "LIST"
00:82DA 00
00:82DB 6387            	     2M    word  editor_list
                        	   141:   makeHandler "INSERT",  editor_insert
00:82DD 494E53455254    	     1M    asciiz   "INSERT"
00:82E3 00
00:82E4 168A            	     2M    word  editor_insert
                        	   142:   makeHandler "LOAD",    editor_load
00:82E6 4C4F4144        	     1M    asciiz   "LOAD"
00:82EA 00
00:82EB 128A            	     2M    word  editor_load
                        	   143:   makeHandler "DELETE",  editor_delete
00:82ED 44454C455445    	     1M    asciiz   "DELETE"
00:82F3 00
00:82F4 A48B            	     2M    word  editor_delete
                        	   144:   makeHandler "HELP",    editor_help
00:82F6 48454C50        	     1M    asciiz   "HELP"
00:82FA 00
00:82FB 1B85            	     2M    word  editor_help
                        	   145:   makeHandler "COMPILE" ,editor_compile
00:82FD 434F4D50494C45  	     1M    asciiz   "COMPILE" 
00:8304 00
00:8305 158F            	     2M    word  editor_compile
                        	   146:   makeHandler "SYNTAX",  editor_syntax
00:8307 53594E544158    	     1M    asciiz   "SYNTAX"
00:830D 00
00:830E 1F8F            	     2M    word  editor_syntax
                        	   147:   makeHandler "SAVE",    editor_save
00:8310 53415645        	     1M    asciiz   "SAVE"
00:8314 00
00:8315 5D87            	     2M    word  editor_save
                        	   148: ;  makeHandler "TEST",    editor_test
                        	   149:   makeHandler "MEMORY",  editor_memory
00:8317 4D454D4F5259    	     1M    asciiz   "MEMORY"
00:831D 00
00:831E FC8C            	     2M    word  editor_memory
                        	   150:  ; makeHandler "SYMTBL", editor_symbol_table_list
                        	   151:   makeHandler "INFO",    editor_info
00:8320 494E464F        	     1M    asciiz   "INFO"
00:8324 00
00:8325 038F            	     2M    word  editor_info
                        	   152:   makeHandler "TRACE",   editor_trace
00:8327 5452414345      	     1M    asciiz   "TRACE"
00:832C 00
00:832D F18E            	     2M    word  editor_trace
                        	   153:   makeHandler "DEBUG",   editor_debug
00:832F 4445425547      	     1M    asciiz   "DEBUG"
00:8334 00
00:8335 D58E            	     2M    word  editor_debug
                        	   154:   makeHandler "ASSEMBLE",editor_assemble
00:8337 415353454D424C45	     1M    asciiz   "ASSEMBLE"
00:833F 00
00:8340 D88F            	     2M    word  editor_assemble
                        	   155:   makeHandler "FIND",    editor_find
00:8342 46494E44        	     1M    asciiz   "FIND"
00:8346 00
00:8347 5787            	     2M    word  editor_find
                        	   156:   makeHandler "REPLACE", editor_replace
00:8349 5245504C414345  	     1M    asciiz   "REPLACE"
00:8350 00
00:8351 4F87            	     2M    word  editor_replace
                        	   157:   makeHandler "RUN",     editor_run
00:8353 52554E          	     1M    asciiz   "RUN"
00:8356 00
00:8357 298F            	     2M    word  editor_run
                        	   158:   makeHandler "RESUME",  editor_resume
00:8359 524553554D45    	     1M    asciiz   "RESUME"
00:835F 00
00:8360 FD8F            	     2M    word  editor_resume
                        	   159:   makeHandler "RECOVER", editor_recover
00:8362 5245434F564552  	     1M    asciiz   "RECOVER"
00:8369 00
00:836A 868E            	     2M    word  editor_recover
                        	   160:   makeHandler "POKE",    editor_poke
00:836C 504F4B45        	     1M    asciiz   "POKE"
00:8370 00
00:8371 5390            	     2M    word  editor_poke
                        	   161:   makeHandler "JSR",     editor_jsr
00:8373 4A5352          	     1M    asciiz   "JSR"
00:8376 00
00:8377 1091            	     2M    word  editor_jsr
                        	   162:   makeHandler "JMP",     editor_jmp
00:8379 4A4D50          	     1M    asciiz   "JMP"
00:837C 00
00:837D 4191            	     2M    word  editor_jmp
                        	   163:   makeHandler "LIBRARY", editor_library
00:837F 4C494252415259  	     1M    asciiz   "LIBRARY"
00:8386 00
00:8387 6291            	     2M    word  editor_library
00:8389 00              	   164:   dfb 0
                        	   165: 
                        	   166: editor_help_info:
00:838A 417661696C61626C	   167:   asc "Available actions:\n\n"
00:8392 6520616374696F6E
00:839A 733A0A0A
00:839E 4C6973742F534176	   168:   asc "List/SAve   line_number_range\n"
00:83A6 652020206C696E65
00:83AE 5F6E756D6265725F
00:83B6 72616E67650A
00:83BC 44656C6574652020	   169:   asc "Delete      line_number_range\n"
00:83C4 202020206C696E65
00:83CC 5F6E756D6265725F
00:83D4 72616E67650A
00:83DA 496E736572742F4C	   170:   asc "Insert/LOad after_line\n"
00:83E2 4F61642061667465
00:83EA 725F6C696E650A
00:83F1 46696E6420202020	   171:   asc "Find        line_number_range /target/flags\n"
00:83F9 202020206C696E65
00:8401 5F6E756D6265725F
00:8409 72616E6765202F74
00:8411 61726765742F666C
00:8419 6167730A
00:841D 5265706C61636520	   172:   asc "Replace     line_number_range /target/replacement/flags\n"
00:8425 202020206C696E65
00:842D 5F6E756D6265725F
00:8435 72616E6765202F74
00:843D 61726765742F7265
00:8445 706C6163656D656E
00:844D 742F666C6167730A
00:8455 0A              	   173:   asc "\n"
00:8456 48656C700A      	   174:   asc "Help\n"
00:845B 494E666F2F4C4942	   175:   asc "INfo/LIBrary\n"
00:8463 726172790A
00:8468 4D656D6F72792020	   176:   asc "Memory      first_address last_address\n"
00:8470 2020202066697273
00:8478 745F616464726573
00:8480 73206C6173745F61
00:8488 6464726573730A
00:848F 436F6D70696C652F	   177:   asc "Compile/Syntax/Assemble\n"
00:8497 53796E7461782F41
00:849F 7373656D626C650A
00:84A7 52556E2F44454275	   178:   asc "RUn/DEBug/Trace/RESume\n"
00:84AF 672F54726163652F
00:84B7 524553756D650A
00:84BE 506F6B652F4A7372	   179:   asc "Poke/Jsr/JMp\n"
00:84C6 2F4A4D700A
00:84CB 5245436F7665720A	   180:   asc "RECover\n"
00:84D3 28416374696F6E73	   181:   asc "(Actions may be abbreviated)\n"
00:84DB 206D617920626520
00:84E3 6162627265766961
00:84EB 746564290A
00:84F0 28466C6167733A20	   182:   asc "(Flags: 'I'gnore case, 'G'lobal, 'Q'uiet)\n"
00:84F8 274927676E6F7265
00:8500 20636173652C2027
00:8508 47276C6F62616C2C
00:8510 2027512775696574
00:8518 290A
00:851A 00              	   183:   dfb 0
                        	   184: 
                        	   185: 
                        	   186: ;--------------------------------------------
                        	   187: ;  HELP
                        	   188: ;--------------------------------------------
                        	   189: editor_help:
00:851B 204086          	   190:   jsr editor_check_no_more
00:851E A98A            	   191:   lda #<editor_help_info
00:8520 8500            	   192:   sta REG
00:8522 A983            	   193:   lda #>editor_help_info
00:8524 8501            	   194:   sta REG+1
                        	   195: editor_help_loop:
00:8526 A000            	   196:   ldy #0
00:8528 B100            	   197:   lda (REG),Y
00:852A F00B            	   198:   beq editor_help_done
00:852C 209A96          	   199:   jsr COUT
00:852F E600            	   200:   inc REG
00:8531 D0F3            	   201:   bne editor_help_loop
00:8533 E601            	   202:   inc REG+1
00:8535 80EF            	   203:   bra editor_help_loop
                        	   204: editor_help_done:
00:8537 4C7282          	   205:   jmp main_prompt
                        	   206: 
                        	   207: ;
                        	   208: ;  Sets default range from 1 to 65535
                        	   209: ;
                        	   210: editor_default_range:
                        	   211: ;
                        	   212: ;  default to all lines
                        	   213: ;
00:853A A901            	   214:   lda #1
00:853C 859E            	   215:   sta from_line
00:853E 649F            	   216:   stz from_line+1
00:8540 A9FF            	   217:   lda #$FF
00:8542 85A0            	   218:   sta to_line
00:8544 85A1            	   219:   sta to_line+1
00:8546 60              	   220:   rts
                        	   221: 
                        	   222: number_expected_message:
00:8547 4E756D6265722065	   223:   asciiz "Number expected\n"
00:854F 787065637465640A
00:8557 00
                        	   224: 
                        	   225: editor_bad_number:
00:8558 A947            	   226:   lda #<number_expected_message
00:855A A285            	   227:   ldx #>number_expected_message
00:855C 202682          	   228:   jsr print
00:855F 4C7282          	   229:   jmp main_prompt
                        	   230: 
                        	   231: ;
                        	   232: ;  get a number for the editor: accepts eof or newline as "no number"
                        	   233: ;  otherwise must be a number and in the range 0x0001 to 0xFFFF
                        	   234: ;  returns carry set if a number (in token_value) and carry clear if
                        	   235: ;  no number. Raises an error otherwise
                        	   236: ;
                        	   237: editor_get_number:
00:8562 203DD2          	   238:   jsr pas_get_token   ; use this to find END as a token
00:8565 F065            	   239:   beq editor_get_number_none ; no token? return with carry set
00:8567 C90A            	   240:   cmp #NL
00:8569 F061            	   241:   beq editor_get_number_none ; newline counts as no token
00:856B C94E            	   242:   cmp #TOKEN_NUMBER
00:856D F04B            	   243:   beq editor_get_number_ok
00:856F C989            	   244:   cmp #TOKEN_END
00:8571 F05B            	   245:   beq editor_get_number_end
00:8573 C949            	   246:   cmp #TOKEN_IDENTIFIER
00:8575 D02D            	   247:   bne editor_get_number_not_identifier
00:8577 A592            	   248:   lda token_length
00:8579 C903            	   249:   cmp #3
00:857B D0DB            	   250:   bne editor_bad_number
00:857D A000            	   251:   ldy #0
00:857F B190            	   252:   lda (token_address),y
00:8581 20A892          	   253:   jsr MAKE_UPPER
00:8584 C941            	   254:   cmp #'A'
00:8586 D0D0            	   255:   bne editor_bad_number
00:8588 C8              	   256:   iny
00:8589 B190            	   257:   lda (token_address),y
00:858B 20A892          	   258:   jsr MAKE_UPPER
00:858E C94C            	   259:   cmp #'L'
00:8590 D0C6            	   260:   bne editor_bad_number
00:8592 C8              	   261:   iny
00:8593 B190            	   262:   lda (token_address),y
00:8595 20A892          	   263:   jsr MAKE_UPPER
00:8598 C94C            	   264:   cmp #'L'
00:859A D0BC            	   265:   bne editor_bad_number
00:859C 203A85          	   266:   jsr editor_default_range
00:859F 204086          	   267:   jsr editor_check_no_more ; can't have ALL - something
00:85A2 8028            	   268:   bra editor_get_number_none
                        	   269: ;
                        	   270: ;  find / replace can go straight to the delimiter
                        	   271: ;
                        	   272: editor_get_number_not_identifier:
00:85A4 A910            	   273:   lda #EFLAG_FIND
00:85A6 0920            	   274:   ora #EFLAG_REPLACE
00:85A8 25BC            	   275:   and editor_flags
00:85AA F0AC            	   276:   beq editor_bad_number
00:85AC A592            	   277:   lda token_length
00:85AE C901            	   278:   cmp #1
00:85B0 D0A6            	   279:   bne editor_bad_number
                        	   280: ;
                        	   281: ;  go back one character, we need get_token to find this again later
                        	   282: ;
00:85B2 C68E            	   283:   dec token_start
00:85B4 D016            	   284:   bne editor_get_number_none
00:85B6 C68F            	   285:   dec token_start+1
00:85B8 8012            	   286:   bra editor_get_number_none
                        	   287: 
                        	   288: editor_get_number_ok:
00:85BA A596            	   289:   lda token_value+2         ; must be a number
00:85BC D03C            	   290:   bne editor_line_number_too_big
00:85BE A5BC            	   291:   lda editor_flags
00:85C0 2902            	   292:   and #EFLAG_ALLOW_ZERO_FROM
00:85C2 D006            	   293:   bne editor_get_number_done
00:85C4 A594            	   294:   lda token_value
00:85C6 0595            	   295:   ora token_value+1
00:85C8 F030            	   296:   beq editor_line_number_too_big  ; too small actually
                        	   297: editor_get_number_done:
00:85CA 38              	   298:   sec
00:85CB 60              	   299:   rts
                        	   300: 
                        	   301: editor_get_number_none:
00:85CC 18              	   302:   clc
00:85CD 60              	   303:   rts
                        	   304: 
                        	   305: ;
                        	   306: ;  the word "END" will count as the highest possible line number
                        	   307: ;
                        	   308: editor_get_number_end:
00:85CE A9FF            	   309:   lda #$FF
00:85D0 8594            	   310:   sta token_value
00:85D2 8595            	   311:   sta token_value+1
00:85D4 6496            	   312:   stz token_value+2
00:85D6 204086          	   313:   jsr editor_check_no_more ; can't have END - something
00:85D9 38              	   314:   sec
00:85DA 60              	   315:   rts
                        	   316: 
                        	   317: number_too_large_message:
00:85DB 4E756D6265722074	   318:   asciiz "Number too large or too small\n"
00:85E3 6F6F206C61726765
00:85EB 206F7220746F6F20
00:85F3 736D616C6C0A
00:85F9 00
                        	   319: 
                        	   320: editor_line_number_too_big:
00:85FA A9DB            	   321:   lda #<number_too_large_message
00:85FC A285            	   322:   ldx #>number_too_large_message
00:85FE 202682          	   323:   jsr print
00:8601 4C7282          	   324:   jmp main_prompt
                        	   325: 
                        	   326: number_bad_range_message:
00:8604 52616E676520696E	   327:   asciiz "Range invalid\n"
00:860C 76616C69640A
00:8612 00
                        	   328: 
                        	   329: editor_bad_range:
00:8613 A904            	   330:   lda #<number_bad_range_message
00:8615 A286            	   331:   ldx #>number_bad_range_message
00:8617 202682          	   332:   jsr print
00:861A 4C7282          	   333:   jmp main_prompt
                        	   334: 
                        	   335: too_much_on_line:
00:861D 556E657870656374	   336:   asciiz "Unexpected trailing input on line\n"
00:8625 656420747261696C
00:862D 696E6720696E7075
00:8635 74206F6E206C696E
00:863D 650A
00:863F 00
                        	   337: 
                        	   338: ;
                        	   339: ;  check that all is left on the line is spaces
                        	   340: ;
                        	   341: editor_check_no_more:
00:8640 A000            	   342:   ldy #0
                        	   343: editor_check_no_more_loop:
00:8642 B18E            	   344:   lda (token_start),y
00:8644 F016            	   345:   beq editor_check_no_more_ok   ; end of file
00:8646 C90A            	   346:   cmp #NL
00:8648 F012            	   347:   beq editor_check_no_more_ok   ; newline is OK
00:864A 204A81          	   348:   jsr isspace
00:864D 9003            	   349:   bcc editor_check_no_more_failed ; not spaces is bad
00:864F C8              	   350:   iny
00:8650 D0F0            	   351:   bne editor_check_no_more_loop   ; skip spaces
                        	   352: 
                        	   353: editor_check_no_more_failed:
00:8652 A91D            	   354:   lda #<too_much_on_line
00:8654 A286            	   355:   ldx #>too_much_on_line
00:8656 202682          	   356:   jsr print
00:8659 4C7282          	   357:   jmp main_prompt
                        	   358: editor_check_no_more_ok:
00:865C 60              	   359:   rts
                        	   360: 
                        	   361: 
                        	   362: 
                        	   363: ;--------------------------------------------
                        	   364: ;  get a range of line numbers (eg. L 1,10; D 4; M 6,10 )
                        	   365: ;--------------------------------------------
                        	   366: 
                        	   367: editor_get_range:
                        	   368: 
                        	   369: 
                        	   370: ;
                        	   371: ;  get the first line number (if any)
                        	   372: ;
00:865D 206285          	   373:   jsr editor_get_number
00:8660 9049            	   374:   bcc editor_get_range_done ; no token? take defaults
                        	   375: ;
                        	   376: ;  store the from line
                        	   377: ;
00:8662 A594            	   378:   lda token_value
00:8664 859E            	   379:   sta from_line
00:8666 85A0            	   380:   sta to_line
00:8668 A595            	   381:   lda token_value+1
00:866A 859F            	   382:   sta from_line+1
00:866C 85A1            	   383:   sta to_line+1
                        	   384: 
                        	   385: ;
                        	   386: ;  comma or hyphen?
                        	   387: ;
00:866E 208FCC          	   388:   jsr get_token
00:8671 F038            	   389:   beq editor_get_range_done   ; line done, just the single line wanted
                        	   390: 
00:8673 C92D            	   391:   cmp #'-'
00:8675 F01C            	   392:   beq editor_get_range_hyphen
00:8677 C94E            	   393:   cmp #TOKEN_NUMBER
00:8679 F01D            	   394:   beq editor_get_range_number
00:867B C989            	   395:   cmp #TOKEN_END
00:867D F019            	   396:   beq editor_get_range_number
00:867F C92C            	   397:   cmp #','
00:8681 F010            	   398:   beq editor_get_range_hyphen
                        	   399: ;
                        	   400: ;  find and replace may have another character after the first line number
                        	   401: ;  which isn't a second line number or a hyphen/comma
                        	   402: ;
00:8683 A910            	   403:   lda #EFLAG_FIND
00:8685 0920            	   404:   ora #EFLAG_REPLACE
00:8687 25BC            	   405:   and editor_flags
00:8689 F088            	   406:   beq editor_bad_range
                        	   407: 
                        	   408: ;
                        	   409: ;  go back one character, we need get_token to find this again later
                        	   410: ;
00:868B C68E            	   411:   dec token_start
00:868D D01C            	   412:   bne editor_get_range_done
00:868F C68F            	   413:   dec token_start+1
00:8691 8018            	   414:   bra editor_get_range_done
                        	   415: 
                        	   416: editor_get_range_hyphen:
                        	   417: ;
                        	   418: ;  get the second line number
                        	   419: ;
00:8693 206285          	   420:   jsr editor_get_number
00:8696 9014            	   421:   bcc editor_bad_rangeJ
                        	   422: 
                        	   423: editor_get_range_number:
00:8698 A594            	   424:   lda token_value
00:869A 85A0            	   425:   sta to_line
00:869C A595            	   426:   lda token_value+1
00:869E 85A1            	   427:   sta to_line+1
                        	   428: 
                        	   429: ;
                        	   430: ;  make sure range ascends
                        	   431: ;
00:86A0 38              	   432:   sec
00:86A1 A5A0            	   433:   lda to_line
00:86A3 E59E            	   434:   sbc from_line
00:86A5 A5A1            	   435:   lda to_line+1
00:86A7 E59F            	   436:   sbc from_line+1
00:86A9 9001            	   437:   bcc editor_bad_rangeJ    ; <sigh> because of the way SBC works
                        	   438: 
                        	   439: editor_get_range_done:
00:86AB 60              	   440:   rts
                        	   441: 
00:86AC 4C1386          	   442: editor_bad_rangeJ jmp editor_bad_range
                        	   443: 
                        	   444: ;
                        	   445: 
00:86AF 20666F756E640A  	   446: found_message asciiz  ' found\n'
00:86B6 00
                        	   447: 
                        	   448: 
                        	   449: 
00:86B7 46726F6D3A20    	   450: from_msg: asciiz "From: "
00:86BD 00
00:86BE 20746F20        	   451: to_msg:   asciiz " to "
00:86C2 00
                        	   452: 
00:86C3 4261642064656C69	   453: bad_delimiter_message asciiz "Bad delimiter\n"
00:86CB 6D697465720A
00:86D1 00
                        	   454: 
                        	   455: editor_bad_delimiter:
00:86D2 A9C3            	   456:   lda #<bad_delimiter_message
00:86D4 A286            	   457:   ldx #>bad_delimiter_message
                        	   458: editor_find_problem:
00:86D6 202682          	   459:   jsr print
00:86D9 4C7282          	   460:   jmp main_prompt
                        	   461: 
00:86DC 46696E642F726570	   462: find_string_too_long_message asciiz "Find/replace string too long\n"
00:86E4 6C61636520737472
00:86EC 696E6720746F6F20
00:86F4 6C6F6E670A
00:86F9 00
                        	   463: 
                        	   464: find_string_too_long:
00:86FA A9DC            	   465:   lda #<find_string_too_long_message
00:86FC A286            	   466:   ldx #>find_string_too_long_message
00:86FE 80D6            	   467:   bra editor_find_problem
                        	   468: 
                        	   469: editor_get_delimiter:
00:8700 208FCC          	   470:   jsr get_token
00:8703 C949            	   471:   cmp #TOKEN_IDENTIFIER
00:8705 F0CB            	   472:   beq editor_bad_delimiter
00:8707 C94E            	   473:   cmp #TOKEN_NUMBER
00:8709 F0C7            	   474:   beq editor_bad_delimiter
00:870B C922            	   475:   cmp #TOKEN_STRING
00:870D F0C3            	   476:   beq editor_bad_delimiter
00:870F A692            	   477:   ldx token_length
00:8711 E001            	   478:   cpx #1
00:8713 D0BD            	   479:   bne editor_bad_delimiter
00:8715 85B4            	   480:   sta find_delimiter
00:8717 60              	   481:   rts
                        	   482: 
00:8718 4E6F20636C6F7369	   483: editor_no_closing_delimiter_message asciiz "No closing delimiter\n"
00:8720 6E672064656C696D
00:8728 697465720A
00:872D 00
                        	   484: 
                        	   485: editor_no_closing_delimiter:
00:872E A918            	   486:   lda #<editor_no_closing_delimiter_message
00:8730 A287            	   487:   ldx #>editor_no_closing_delimiter_message
00:8732 80A2            	   488:   bra editor_find_problem
                        	   489: 
00:8734 5461726765742073	   490: no_find_message asciiz "Target string empty\n"
00:873C 7472696E6720656D
00:8744 7074790A
00:8748 00
                        	   491: 
                        	   492: editor_no_find_string:
00:8749 A934            	   493:   lda #<no_find_message
00:874B A287            	   494:   ldx #>no_find_message
00:874D 8087            	   495:   bra editor_find_problem
                        	   496: 
                        	   497: ;--------------------------------------------
                        	   498: ;  LIST / SAVE / FIND / REPLACE / MODIFY
                        	   499: ;
                        	   500: ;  This rather complex routine lists the source between from_line and to_line
                        	   501: ;   In the process it can show or omit line numbers  (omit for SAVE)
                        	   502: ;  Also, it can find the target text, and optionally replace it with the replacement text
                        	   503: ;  In find/replace mode the lines are not shown unless they had something found (unless
                        	   504: ;   the Quiet flag is set)
                        	   505: ;
                        	   506: ;--------------------------------------------
                        	   507: 
                        	   508: editor_replace:
00:874F A920            	   509:   lda #EFLAG_REPLACE
00:8751 0910            	   510:   ora #EFLAG_FIND   ; makes things simpler later on
00:8753 85BC            	   511:   sta editor_flags
00:8755 800C            	   512:   bra editor_list
                        	   513: 
                        	   514: editor_find:
                        	   515: 
00:8757 A910            	   516:   lda #EFLAG_FIND
00:8759 85BC            	   517:   sta editor_flags
00:875B 8006            	   518:   bra editor_list
                        	   519: 
                        	   520: editor_save
                        	   521: 
00:875D A980            	   522:   lda #EFLAG_NO_LINE_NUMBERS
00:875F 0908            	   523:   ora #EFLAG_SAVE
00:8761 85BC            	   524:   sta editor_flags
                        	   525: 
                        	   526: ;
                        	   527: ;  main entry point - get the from and to lines
                        	   528: ;
                        	   529: editor_list:
00:8763 203A85          	   530:   jsr editor_default_range
00:8766 205D86          	   531:   jsr editor_get_range
                        	   532: 
                        	   533: ;
                        	   534: ;  turn the from_line into an address and put it into PCODE
                        	   535: ;
00:8769 A59E            	   536:   lda from_line
00:876B 85AC            	   537:   sta this_line
00:876D A59F            	   538:   lda from_line+1
00:876F 85AD            	   539:   sta this_line+1
00:8771 20858C          	   540:   jsr find_line    ; find the "from" line address (this_line in fact)
00:8774 A5AE            	   541:   lda this_line_addr
00:8776 8523            	   542:   sta PCODE
00:8778 A5AF            	   543:   lda this_line_addr+1
00:877A 8524            	   544:   sta PCODE+1
00:877C 64B9            	   545:   stz find_count
00:877E 64BA            	   546:   stz find_count+1
                        	   547: 
                        	   548: ;
                        	   549: ;  for FIND and REPLACE, get the first delimiter
                        	   550: ;
00:8780 A5BC            	   551:   lda editor_flags
00:8782 2910            	   552:   and #EFLAG_FIND
00:8784 D003            	   553:   bne editor_list_doing_find
00:8786 4C5388          	   554:   jmp editor_list_not_find
                        	   555: 
                        	   556: editor_list_doing_find:
00:8789 200087          	   557:   jsr editor_get_delimiter
                        	   558: ;
                        	   559: ;  token_next should now be the start of what we are searching for
                        	   560: ;
00:878C 38              	   561:   sec
00:878D A58E            	   562:   lda token_start
00:878F E900            	   563:   sbc #<INBUF
00:8791 85B0            	   564:   sta find_from
00:8793 B00B            	   565:   bcs editor_list_got_from_point ; delimiter should be a single byte
                        	   566: 
                        	   567: editor_find_bug:
00:8795 A214            	   568:   ldx #20  ; ERROR: bug
00:8797 4C4F9A          	   569:   jmp ERROR
                        	   570: 
00:879A 4CFA86          	   571: find_string_too_longJ         jmp find_string_too_long
00:879D 4C2E87          	   572: editor_no_closing_delimiterJ  jmp editor_no_closing_delimiter
                        	   573: 
                        	   574: editor_list_got_from_point:
                        	   575: 
                        	   576: ;
                        	   577: ;  Now find closing delimiter by a simple scan as we will pass who-knows-what on the way
                        	   578: ;
00:87A0 A6B0            	   579:   ldx find_from
                        	   580: editor_find_second_delimiter_loop:
00:87A2 E8              	   581:   inx
00:87A3 BD0002          	   582:   lda INBUF,x
00:87A6 F0F5            	   583:   beq editor_no_closing_delimiterJ
00:87A8 C90A            	   584:   cmp #NL
00:87AA F0F1            	   585:   beq editor_no_closing_delimiterJ
00:87AC C5B4            	   586:   cmp find_delimiter
00:87AE D0F2            	   587:   bne editor_find_second_delimiter_loop
                        	   588: 
                        	   589: ;
                        	   590: ;  found the closing delimiter
                        	   591: ;
00:87B0 86B1            	   592:   stx find_to
00:87B2 E4B0            	   593:   cpx find_from
00:87B4 F093            	   594:   beq editor_no_find_string
                        	   595: ;
                        	   596: ;  maximum 127 byte find string
                        	   597: ;
00:87B6 38              	   598:   sec
00:87B7 A5B1            	   599:   lda find_to
00:87B9 E5B0            	   600:   sbc find_from
00:87BB 30DD            	   601:   bmi find_string_too_longJ
00:87BD 85B3            	   602:   sta find_len    ; save for later memory move calculations
                        	   603: 
00:87BF A920            	   604:   lda #EFLAG_REPLACE
00:87C1 25BC            	   605:   and editor_flags
00:87C3 F02A            	   606:   beq editor_find_get_flags
                        	   607: 
                        	   608: ;
                        	   609: ;  doing a replace - find second delimiter
                        	   610: ;
                        	   611: 
00:87C5 86B5            	   612:   stx rep_from
00:87C7 E6B5            	   613:   inc rep_from    ; get past the delimiter
                        	   614: 
                        	   615: editor_find_third_delimiter_loop:
00:87C9 E8              	   616:   inx
00:87CA BD0002          	   617:   lda INBUF,x
00:87CD F0CE            	   618:   beq editor_no_closing_delimiterJ
00:87CF C90A            	   619:   cmp #NL
00:87D1 F0CA            	   620:   beq editor_no_closing_delimiterJ
00:87D3 C5B4            	   621:   cmp find_delimiter
00:87D5 D0F2            	   622:   bne editor_find_third_delimiter_loop
                        	   623: 
                        	   624: ;
                        	   625: ;  found the replacement closing delimiter
00:87D7 86B6            	   626:   stx rep_to
                        	   627: 
                        	   628: ;
                        	   629: ;  maximum 127 byte replacement string
                        	   630: ;
00:87D9 38              	   631:   sec
00:87DA A5B6            	   632:   lda rep_to
00:87DC E5B5            	   633:   sbc rep_from
00:87DE 30BA            	   634:   bmi find_string_too_longJ
                        	   635: 
                        	   636: ;
                        	   637: ;  now find the signed difference between the find and replace strings
                        	   638: ;  namely: (rep_to - rep_from) - find_len
                        	   639: ;
00:87E0 64B8            	   640:   stz rep_diff+1
00:87E2 38              	   641:   sec
00:87E3 A5B6            	   642:   lda rep_to
00:87E5 E5B5            	   643:   sbc rep_from
00:87E7 E5B3            	   644:   sbc find_len
00:87E9 85B7            	   645:   sta rep_diff
00:87EB 1002            	   646:   bpl editor_find_get_flags
00:87ED C6B8            	   647:   dec rep_diff+1   ; make that $ff
                        	   648: 
                        	   649: ;
                        	   650: ; get any find/replace flags
                        	   651: ;
                        	   652: editor_find_get_flags:
00:87EF 64BD            	   653:   stz find_flags
                        	   654: 
                        	   655: editor_flags_loop:
00:87F1 E8              	   656:   inx
00:87F2 BD0002          	   657:   lda INBUF,X
00:87F5 C90A            	   658:   cmp #NL
00:87F7 F042            	   659:   beq editor_list_fix_target_string
00:87F9 204A81          	   660:   jsr isspace
00:87FC B0F3            	   661:   bcs editor_flags_loop
00:87FE 20A892          	   662:   jsr MAKE_UPPER
00:8801 C951            	   663:   cmp #'Q'
00:8803 D00A            	   664:   bne editor_flags1
00:8805 A904            	   665:   lda #FFLAG_QUIET
00:8807 04BD            	   666:   tsb find_flags
00:8809 A980            	   667:   lda #EFLAG_NO_LINE_NUMBERS
00:880B 04BC            	   668:   tsb editor_flags
00:880D 80E2            	   669:   bra editor_flags_loop
                        	   670: editor_flags1:
00:880F C947            	   671:   cmp #'G'
00:8811 D006            	   672:   bne editor_flags2
00:8813 A902            	   673:   lda #FFLAG_GLOBAL
00:8815 04BD            	   674:   tsb find_flags
00:8817 80D8            	   675:   bra editor_flags_loop
                        	   676: editor_flags2:
00:8819 C949            	   677:   cmp #'I'
00:881B D006            	   678:   bne editor_flags3
00:881D A901            	   679:   lda #FFLAG_IGNORE_CASE
00:881F 04BD            	   680:   tsb find_flags
00:8821 80CE            	   681:   bra editor_flags_loop
                        	   682: editor_flags3:
00:8823 A92D            	   683:   lda #<bad_flag_message
00:8825 A288            	   684:   ldx #>bad_flag_message
00:8827 202682          	   685:   jsr print
00:882A 4C7282          	   686:   jmp main_prompt
                        	   687: 
00:882D 556E6B6E6F776E20	   688: bad_flag_message: asciiz "Unknown flag\n"
00:8835 666C61670A
00:883A 00
                        	   689: 
                        	   690: editor_list_fix_target_string:
                        	   691: 
00:883B A901            	   692:   lda #FFLAG_IGNORE_CASE
00:883D 25BD            	   693:   and find_flags
00:883F F015            	   694:   beq editor_list_get_on_with_it
                        	   695: 
                        	   696: ;
                        	   697: ;  for case insensitive compare force target to be upper case
                        	   698: ;
00:8841 A6B0            	   699:   ldx find_from
                        	   700: editor_list_fixup_loop:
00:8843 E4B1            	   701:   cpx find_to
00:8845 F00F            	   702:   beq editor_list_get_on_with_it
00:8847 BD0002          	   703:   lda INBUF,X
00:884A 20A892          	   704:   jsr MAKE_UPPER
00:884D 9D0002          	   705:   sta INBUF,X
00:8850 E8              	   706:   inx
00:8851 80F0            	   707:   bra editor_list_fixup_loop
                        	   708: 
                        	   709: 
                        	   710: editor_list_not_find:
                        	   711: ;
                        	   712: ;  we should have no more tokens now
                        	   713: ;
00:8853 204086          	   714:   jsr editor_check_no_more
                        	   715: 
                        	   716: editor_list_get_on_with_it:
                        	   717: ;
                        	   718: ;  make sure current_line is correct
                        	   719: ;
00:8856 A59E            	   720:   lda from_line
00:8858 85A2            	   721:   sta current_line
00:885A A59F            	   722:   lda from_line+1
00:885C 85A3            	   723:   sta current_line+1
                        	   724: 
                        	   725: ;
                        	   726: ;  exit immediately if no source from here on
                        	   727: ;
00:885E A000            	   728:   ldy #0
00:8860 B123            	   729:   lda (PCODE),Y
00:8862 D003            	   730:   bne editor_list_have_source
00:8864 4C8289          	   731:   jmp editor_list_done
                        	   732: 
                        	   733: editor_list_have_source:
00:8867 A901            	   734:   lda #EFLAG_SHOW_LINE
00:8869 04BC            	   735:   tsb editor_flags
00:886B 8006            	   736:   bra editor_list_loop
                        	   737: 
00:886D 4C8289          	   738: editor_list_doneJ jmp editor_list_done
00:8870 4C4489          	   739: editor_list_no_line_numberJ jmp editor_list_no_line_number
                        	   740: 
                        	   741: editor_list_loop:
00:8873 A58B            	   742:   lda serial_in_byte_received
00:8875 C903            	   743:   cmp  #KEY_ABORT
00:8877 F021            	   744:   beq  editor_list_aborted
00:8879 64BB            	   745:   stz  found_this_line
00:887B A000            	   746:   ldy #0
00:887D B123            	   747:   lda (PCODE),Y
00:887F F0EC            	   748:   beq editor_list_doneJ
00:8881 A5BC            	   749:   lda editor_flags
00:8883 2901            	   750:   and #EFLAG_SHOW_LINE
00:8885 F0E9            	   751:   beq  editor_list_no_line_numberJ
00:8887 A5BC            	   752:   lda editor_flags
00:8889 2908            	   753:   and #EFLAG_SAVE
00:888B D0E3            	   754:   bne editor_list_no_line_numberJ
                        	   755: ;
                        	   756: ;  At this exact point we know we are at the start of a line
                        	   757: ;  and we aren't doing a Save. Now, if we are doing a Find then
                        	   758: ;  we need to know if this line (from here to the next newline)
                        	   759: ;  matches our find string, and if not, to skip it
                        	   760: 
00:888D A940            	   761:   lda #EFLAG_SUPPRESS_NEWLINE
00:888F 14BC            	   762:   trb editor_flags              ; we can show newlines now
                        	   763: 
00:8891 A5BC            	   764:   lda editor_flags
00:8893 2910            	   765:   and #EFLAG_FIND
00:8895 D010            	   766:   bne editor_find_or_replacing
                        	   767: 
00:8897 4C3789          	   768:   jmp  editor_list_not_finding
                        	   769: 
                        	   770: ;
                        	   771: ;  Here when Ctrl+C pressed
                        	   772: ;
                        	   773: editor_list_aborted:
00:889A A232            	   774:   ldx #50
00:889C A000            	   775:   ldy #0
00:889E 20B993          	   776:   jsr delay   ; 50 ms delay to allow serial to settle
00:88A1 200C95          	   777:   jsr CROUT
00:88A4 4C8289          	   778:   jmp editor_list_done
                        	   779: 
                        	   780: editor_find_or_replacing:
                        	   781: 
                        	   782: ;
                        	   783: ;  here if finding or replacing
                        	   784: ;
                        	   785: 
00:88A7 A900            	   786:   lda #0
                        	   787: 
                        	   788: ;
                        	   789: ;  we come back here for multiple replacements with a new starting pos
                        	   790: ;
                        	   791: editor_replacement_loop:
00:88A9 85B2            	   792:   sta find_pos    ; searching line from beginning (or not, if doing a multiple replace)
                        	   793: 
                        	   794: editor_find_loop:
00:88AB A6B0            	   795:   ldx find_from   ; out target string position in INBUF
00:88AD A4B2            	   796:   ldy find_pos    ; where we are on the line
                        	   797: editor_find_inner_loop:
00:88AF E4B1            	   798:   cpx find_to     ; reached end of target, found the string!
00:88B1 F037            	   799:   beq editor_find_found_it
00:88B3 B123            	   800:   lda (PCODE),Y
00:88B5 C90A            	   801:   cmp #NL
00:88B7 F01B            	   802:   beq editor_find_no_match ; hit end of line without matching
                        	   803: 
                        	   804: ;
                        	   805: ;  force to upper-case if required
                        	   806: ;
00:88B9 48              	   807:   pha
00:88BA A901            	   808:   lda #FFLAG_IGNORE_CASE
00:88BC 25BD            	   809:   and find_flags
00:88BE F006            	   810:   beq editor_find_case_sensitive
00:88C0 68              	   811:   pla
00:88C1 20A892          	   812:   jsr MAKE_UPPER
00:88C4 8001            	   813:   bra editor_find_test_character
                        	   814: editor_find_case_sensitive:
00:88C6 68              	   815:   pla
                        	   816: editor_find_test_character:
00:88C7 DD0002          	   817:   cmp INBUF,X     ; does source byte match target byte?
00:88CA D004            	   818:   bne editor_find_skip_this
00:88CC C8              	   819:   iny
00:88CD E8              	   820:   inx
00:88CE 80DF            	   821:   bra editor_find_inner_loop
                        	   822: 
                        	   823: editor_find_skip_this:
00:88D0 E6B2            	   824:   inc find_pos
00:88D2 D0D7            	   825:   bne editor_find_loop  ; if it wraps, give up
                        	   826: 
                        	   827: ;
                        	   828: ;  we are at the newline without a match, increment PCODE to match
                        	   829: ;  where we are and go onto newline processing
                        	   830: ;
                        	   831: editor_find_no_match:
00:88D4 A5BB            	   832:    lda found_this_line
00:88D6 D05F            	   833:    bne editor_list_not_finding
00:88D8 18              	   834:    clc
00:88D9 98              	   835:    tya
00:88DA 6523            	   836:    adc PCODE
00:88DC 8523            	   837:    sta PCODE
00:88DE A900            	   838:    lda #0
00:88E0 6524            	   839:    adc PCODE+1
00:88E2 8524            	   840:    sta PCODE+1
00:88E4 A940            	   841:    lda #EFLAG_SUPPRESS_NEWLINE
00:88E6 04BC            	   842:    tsb editor_flags
00:88E8 8062            	   843:    bra editor_newline_processing
                        	   844: 
                        	   845: ;
                        	   846: ;  here when find succeeded
                        	   847: ;
                        	   848: editor_find_found_it:
00:88EA E6B9            	   849:   inc find_count
00:88EC D002            	   850:   bne editor_find_found_it1
00:88EE E6BA            	   851:   inc find_count+1
                        	   852: editor_find_found_it1:
00:88F0 A901            	   853:   lda #1
00:88F2 85BB            	   854:   sta found_this_line
00:88F4 A920            	   855:   lda #EFLAG_REPLACE
00:88F6 25BC            	   856:   and editor_flags
00:88F8 D00E            	   857:   bne editor_do_the_replace
                        	   858: 
00:88FA A902            	   859:   lda #FFLAG_GLOBAL
00:88FC 25BD            	   860:   and find_flags
00:88FE F037            	   861:   beq editor_list_not_finding   ; one replace is enough
                        	   862: 
                        	   863: ;
                        	   864: ;  add the find length to Y (moving past what we just found)
                        	   865: ;
                        	   866: ;
00:8900 18              	   867:   clc
00:8901 A5B2            	   868:   lda find_pos
00:8903 65B3            	   869:   adc find_len
00:8905 4CA988          	   870:   jmp editor_replacement_loop
                        	   871: 
                        	   872: ;
                        	   873: ;  here when replacing
                        	   874: ;
                        	   875: editor_do_the_replace:
00:8908 A908            	   876:   lda #FLAG_VALID_COMPILE   ; compile or assemble no longer valid
00:890A 0910            	   877:   ora #FLAG_VALID_ASSEMBLE
00:890C 14BE            	   878:   trb system_flags
                        	   879: 
00:890E A5B7            	   880:   lda rep_diff ; same length?
00:8910 F003            	   881:   beq editor_easy_replace
00:8912 4CA289          	   882:   jmp editor_do_replace
                        	   883: 
                        	   884: editor_easy_replace:
00:8915 A4B2            	   885:   ldy find_pos
00:8917 A6B5            	   886:   ldx rep_from
                        	   887: editor_easy_replace_loop:
00:8919 E4B6            	   888:   cpx rep_to
00:891B F009            	   889:   beq editor_easy_replace_done
00:891D BD0002          	   890:   lda INBUF,x
00:8920 9123            	   891:   sta (PCODE),y
00:8922 C8              	   892:   iny
00:8923 E8              	   893:   inx
00:8924 D0F3            	   894:   bne editor_easy_replace_loop  ; keep replacing
                        	   895: 
                        	   896: editor_easy_replace_done:
00:8926 A902            	   897:   lda #FFLAG_GLOBAL
00:8928 25BD            	   898:   and find_flags
00:892A F00B            	   899:   beq editor_list_not_finding   ; one replace is enough
                        	   900: 
                        	   901: ;
                        	   902: ;  add the replacement length to Y (moving past what we just replaced)
                        	   903: ;   the replacement length is rep_to - rep_from
                        	   904: ;
00:892C 18              	   905:   clc
00:892D A5B2            	   906:   lda find_pos
00:892F 65B6            	   907:   adc rep_to
00:8931 38              	   908:   sec
00:8932 E5B5            	   909:   sbc rep_from
00:8934 4CA988          	   910:   jmp editor_replacement_loop
                        	   911: 
                        	   912: ;
                        	   913: ;
                        	   914: ;  display the line number
                        	   915: ;
                        	   916: editor_list_not_finding:
00:8937 A901            	   917:   lda #EFLAG_SHOW_LINE
00:8939 14BC            	   918:   trb editor_flags      ; cancel flag until next newline
00:893B A980            	   919:   lda #EFLAG_NO_LINE_NUMBERS
00:893D 25BC            	   920:   and editor_flags
00:893F D003            	   921:   bne editor_list_no_line_number
00:8941 20478C          	   922:   jsr show_current_line_number
                        	   923: 
                        	   924: editor_list_no_line_number:
00:8944 A000            	   925:   ldy  #0
00:8946 B123            	   926:   lda  (PCODE),Y
00:8948 C90A            	   927:   cmp  #NL
00:894A D022            	   928:   bne  editor_list_not_newline
                        	   929: 
                        	   930: editor_newline_processing:
00:894C A901            	   931:   lda  #EFLAG_SHOW_LINE
00:894E 04BC            	   932:   tsb  editor_flags
00:8950 E6A2            	   933:   inc  current_line
00:8952 D002            	   934:   bne  editor_list_check_to_line
00:8954 E6A3            	   935:   inc  current_line+1
                        	   936: 
                        	   937: ;
                        	   938: ;  see if we hit the wanted "to" line
                        	   939: ;
                        	   940: editor_list_check_to_line:
00:8956 A5A3            	   941:   lda  current_line+1
00:8958 C5A1            	   942:   cmp  to_line+1
00:895A 900A            	   943:   bcc  editor_list_check_to_line_ok
00:895C D024            	   944:   bne  editor_list_done
00:895E A5A2            	   945:   lda  current_line
00:8960 C5A0            	   946:   cmp  to_line
00:8962 9002            	   947:   bcc  editor_list_check_to_line_ok
00:8964 D01C            	   948:   bne  editor_list_done
                        	   949: 
                        	   950: editor_list_check_to_line_ok:
                        	   951: 
00:8966 A940            	   952:   lda #EFLAG_SUPPRESS_NEWLINE
00:8968 25BC            	   953:   and editor_flags
00:896A D00D            	   954:   bne editor_list_skip_newline
00:896C A90A            	   955:   lda #NL   ; put the newline back
                        	   956: 
                        	   957: ;
                        	   958: ;  just echo the character, and increment the memory address
                        	   959: ;
                        	   960: editor_list_not_newline:
00:896E AA              	   961:   tax
00:896F A904            	   962:   lda #FFLAG_QUIET
00:8971 25BD            	   963:   and find_flags
00:8973 D004            	   964:   bne editor_list_skip_newline
00:8975 8A              	   965:   txa
00:8976 206995          	   966:   jsr PRCHAR
                        	   967: 
                        	   968: editor_list_skip_newline:
00:8979 E623            	   969:   inc PCODE
00:897B D002            	   970:   bne editor_list_loopJ
00:897D E624            	   971:   inc PCODE+1
                        	   972: 
                        	   973: editor_list_loopJ:
00:897F 4C7388          	   974:   jmp editor_list_loop
                        	   975: 
                        	   976: editor_list_done:
00:8982 200C95          	   977:   jsr CROUT
                        	   978: 
00:8985 A5B9            	   979:   lda find_count
00:8987 05BA            	   980:   ora find_count+1
00:8989 F014            	   981:   beq  editor_list_completely_done
00:898B A5B9            	   982:   lda find_count
00:898D 8500            	   983:   sta REG
00:898F A5BA            	   984:   lda find_count+1
00:8991 8501            	   985:   sta REG+1
00:8993 6402            	   986:   stz REGB
00:8995 203694          	   987:   jsr display_in_decimal
00:8998 A9AF            	   988:   lda #<found_message
00:899A A286            	   989:   ldx #>found_message
00:899C 202682          	   990:   jsr print
                        	   991: 
                        	   992: editor_list_completely_done:
00:899F 4C7282          	   993:   jmp main_prompt
                        	   994: 
                        	   995: ;
                        	   996: ;  This if for replacing when the lengths differ
                        	   997: ;
                        	   998: editor_do_replace:
                        	   999: ;
                        	  1000: ; add our current find_pos to PCODE to get where we are in memory
                        	  1001: ;
00:89A2 18              	  1002:   clc
00:89A3 A523            	  1003:   lda  PCODE
00:89A5 48              	  1004:   pha   ; save where we currently are
00:89A6 65B2            	  1005:   adc  find_pos
00:89A8 85A6            	  1006:   sta  mem_move_src
00:89AA A524            	  1007:   lda  PCODE+1
00:89AC 48              	  1008:   pha
00:89AD 6900            	  1009:   adc  #0
00:89AF 85A7            	  1010:   sta  mem_move_src+1
                        	  1011: 
                        	  1012: ;
                        	  1013: ;  add the source string length as we don't need to copy that
                        	  1014: ;
00:89B1 18              	  1015:   clc
00:89B2 A5A6            	  1016:   lda mem_move_src
00:89B4 65B3            	  1017:   adc find_len
00:89B6 85A6            	  1018:   sta mem_move_src
00:89B8 A5A7            	  1019:   lda mem_move_src+1
00:89BA 6900            	  1020:   adc #0
00:89BC 85A7            	  1021:   sta mem_move_src+1
                        	  1022: 
                        	  1023: ;
                        	  1024: ;  the move destination is the source plus the replacement length
                        	  1025: ;   (ie. a gap of the difference in bytes)
                        	  1026: 
00:89BE 18              	  1027:   clc
00:89BF A5A6            	  1028:   lda mem_move_src
00:89C1 65B7            	  1029:   adc rep_diff
00:89C3 85A8            	  1030:   sta mem_move_dest
00:89C5 A5A7            	  1031:   lda mem_move_src+1
00:89C7 65B8            	  1032:   adc rep_diff+1
00:89C9 85A9            	  1033:   sta mem_move_dest+1
                        	  1034: 
                        	  1035: 
00:89CB 20B98C          	  1036:   jsr find_source_end   ; goes into PCODE
                        	  1037: ;
                        	  1038: ;  the length to move will be (the end of the source) - (the start of the move)
                        	  1039: ;
00:89CE 38              	  1040:   sec
00:89CF A523            	  1041:   lda PCODE
00:89D1 E5A6            	  1042:   sbc mem_move_src
00:89D3 85AA            	  1043:   sta mem_move_len
00:89D5 A524            	  1044:   lda PCODE+1
00:89D7 E5A7            	  1045:   sbc mem_move_src+1
00:89D9 85AB            	  1046:   sta mem_move_len+1
                        	  1047: 
00:89DB A5B8            	  1048:   lda rep_diff+1
00:89DD 3005            	  1049:   bmi editor_do_replace_smaller
00:89DF 20A681          	  1050:   jsr moveup      ; replacing with larger string
00:89E2 8003            	  1051:   bra editor_do_replace_copy_done
                        	  1052: 
                        	  1053: editor_do_replace_smaller:
00:89E4 207A81          	  1054:   jsr movedown    ; replacing with smaller string
                        	  1055: 
                        	  1056: editor_do_replace_copy_done:
                        	  1057: ;
                        	  1058: ;  get the current source address back
                        	  1059: ;
00:89E7 68              	  1060:   pla
00:89E8 8524            	  1061:   sta  PCODE+1
00:89EA 68              	  1062:   pla
00:89EB 8523            	  1063:   sta  PCODE
00:89ED 4C1589          	  1064:   jmp  editor_easy_replace    ; now move in new string
                        	  1065: 
                        	  1066: 
00:89F0 456E74657220736F	  1067: load_message asciiz "Enter source, terminate with Esc\n"
00:89F8 757263652C207465
00:8A00 726D696E61746520
00:8A08 7769746820457363
00:8A10 0A
00:8A11 00
                        	  1068: 
                        	  1069: ;--------------------------------------------
                        	  1070: ;  INSERT / LOAD
                        	  1071: ;--------------------------------------------
                        	  1072: editor_load:
                        	  1073: 
00:8A12 A904            	  1074:   lda #EFLAG_LOAD
00:8A14 85BC            	  1075:   sta editor_flags
                        	  1076: 
                        	  1077: editor_insert:
00:8A16 206285          	  1078:   jsr editor_get_number
00:8A19 9015            	  1079:   bcc editor_insert_at_start
                        	  1080: 
                        	  1081:   ;
                        	  1082:   ; I really want to insert AFTER this line so I'll add 1 to whatever line number they gave
                        	  1083:   ; To insert at the start use Insert without a line number
                        	  1084:   ;
00:8A1B 18              	  1085:   clc
00:8A1C A594            	  1086:   lda token_value
00:8A1E 6901            	  1087:   adc #1
00:8A20 85AC            	  1088:   sta this_line
00:8A22 A595            	  1089:   lda token_value+1
00:8A24 6900            	  1090:   adc #0
00:8A26 85AD            	  1091:   sta this_line+1
                        	  1092: 
00:8A28 204086          	  1093:   jsr editor_check_no_more
00:8A2B 20858C          	  1094:   jsr find_line    ; find the "from" line address
00:8A2E 800E            	  1095:   bra editor_insert_common
                        	  1096: 
                        	  1097: editor_insert_at_start:
00:8A30 A900            	  1098:   lda #<TEXT_START
00:8A32 85AE            	  1099:   sta this_line_addr
00:8A34 A903            	  1100:   lda #>TEXT_START
00:8A36 85AF            	  1101:   sta this_line_addr+1
00:8A38 A901            	  1102:   lda #1
00:8A3A 85A2            	  1103:   sta current_line    ; current line number (1)
00:8A3C 64A3            	  1104:   stz current_line+1
                        	  1105: 
                        	  1106: editor_insert_common:
00:8A3E 20B98C          	  1107:   jsr find_source_end
                        	  1108: 
                        	  1109: ;
                        	  1110: ;  move existing source to end of RAM
                        	  1111: ;
00:8A41 38              	  1112:   sec
00:8A42 A523            	  1113:   lda PCODE
00:8A44 E5AE            	  1114:   sbc this_line_addr
00:8A46 85AA            	  1115:   sta mem_move_len
00:8A48 A524            	  1116:   lda PCODE+1
00:8A4A E5AF            	  1117:   sbc this_line_addr+1
00:8A4C 85AB            	  1118:   sta mem_move_len+1
                        	  1119: 
                        	  1120: ;
                        	  1121: ;  find where to move to
                        	  1122: ;
00:8A4E 38              	  1123:   sec
00:8A4F A9FF            	  1124:   lda #<HIGHEST_RAM
00:8A51 E5AA            	  1125:   sbc mem_move_len
00:8A53 85A8            	  1126:   sta mem_move_dest
00:8A55 85A4            	  1127:   sta insert_limit
00:8A57 A93F            	  1128:   lda #>HIGHEST_RAM
00:8A59 E5AB            	  1129:   sbc mem_move_len+1
00:8A5B 85A9            	  1130:   sta mem_move_dest+1
00:8A5D 85A5            	  1131:   sta insert_limit+1
                        	  1132: 
                        	  1133: ;
                        	  1134: ;  the source of the move
                        	  1135: ;
00:8A5F A5AE            	  1136:   lda this_line_addr
00:8A61 85A6            	  1137:   sta mem_move_src
00:8A63 A5AF            	  1138:   lda this_line_addr+1
00:8A65 85A7            	  1139:   sta mem_move_src+1
                        	  1140: 
00:8A67 20A681          	  1141:   jsr moveup
                        	  1142: 
                        	  1143: ;
                        	  1144: ;  put input at from_line_addr
                        	  1145: ;
                        	  1146: 
00:8A6A A5AE            	  1147:   lda this_line_addr
00:8A6C 8523            	  1148:   sta PCODE
00:8A6E A5AF            	  1149:   lda this_line_addr+1
00:8A70 8524            	  1150:   sta PCODE+1
                        	  1151: 
00:8A72 A9F0            	  1152:   lda  #<load_message
00:8A74 A289            	  1153:   ldx  #>load_message
00:8A76 202682          	  1154:   jsr  print
                        	  1155: 
                        	  1156: ;
                        	  1157: ;  show the first line number
                        	  1158: ;
                        	  1159: 
00:8A79 A901            	  1160:   lda #EFLAG_SHOW_LINE
00:8A7B 04BC            	  1161:   tsb editor_flags
00:8A7D A000            	  1162:   ldy #0    ; offset from PCODE for inserting (should always be zero)
00:8A7F A200            	  1163:   ldx #0    ; last character we inserted
                        	  1164: 
                        	  1165: editor_insert_loop:
00:8A81 A904            	  1166:   lda #EFLAG_LOAD         ; no line numbers on load
00:8A83 25BC            	  1167:   and editor_flags
00:8A85 D00B            	  1168:   bne editor_insert_no_line_number
                        	  1169: 
00:8A87 A5BC            	  1170:   lda editor_flags
00:8A89 2901            	  1171:   and #EFLAG_SHOW_LINE
00:8A8B F005            	  1172:   beq  editor_insert_no_line_number
                        	  1173: ;
                        	  1174: ;  display the line number
                        	  1175: ;
                        	  1176: 
00:8A8D 64BC            	  1177:   stz editor_flags      ; cancel flag until next newline
00:8A8F 20478C          	  1178:   jsr show_current_line_number
                        	  1179: 
                        	  1180: editor_insert_no_line_number:
00:8A92 200FCC          	  1181:   jsr  CHRIN
00:8A95 C90D            	  1182:   cmp  #CR                          ; carriage-return?
00:8A97 F0F9            	  1183:   beq  editor_insert_no_line_number ; yes, ignore
00:8A99 C91B            	  1184:   cmp  #END_EDITOR_INPUT            ; Esc?
00:8A9B F04F            	  1185:   beq  editor_insert_done
00:8A9D C908            	  1186:   cmp  #BACKSPACE
00:8A9F F029            	  1187:   beq  editor_insert_backspace
00:8AA1 C90A            	  1188:   cmp  #NL
00:8AA3 D00C            	  1189:   bne  editor_insert_not_newline
00:8AA5 A901            	  1190:   lda  #EFLAG_SHOW_LINE
00:8AA7 04BC            	  1191:   tsb  editor_flags
00:8AA9 A90A            	  1192:   lda  #NL            ; get the newline back
00:8AAB E6A2            	  1193:   inc  current_line
00:8AAD D002            	  1194:   bne  editor_insert_not_newline
00:8AAF E6A3            	  1195:   inc  current_line+1
                        	  1196: editor_insert_not_newline:
00:8AB1 9123            	  1197:   sta  (PCODE),y
00:8AB3 AA              	  1198:   tax                ; for detecting final newline
00:8AB4 E623            	  1199:   inc  PCODE
00:8AB6 D002            	  1200:   bne  editor_insert_loop1
00:8AB8 E624            	  1201:   inc  PCODE+1
                        	  1202: 
                        	  1203: editor_insert_loop1:
00:8ABA A5A5            	  1204:   lda  insert_limit+1
00:8ABC C524            	  1205:   cmp  PCODE+1
00:8ABE B0C1            	  1206:   bcs  editor_insert_loop   ; carry is SET if we didn't borrow
00:8AC0 D056            	  1207:   bne  editor_too_full
00:8AC2 A5A4            	  1208:   lda  insert_limit
00:8AC4 C523            	  1209:   cmp  PCODE
00:8AC6 F050            	  1210:   beq  editor_too_full
00:8AC8 80B7            	  1211:   bra  editor_insert_loop
                        	  1212: 
                        	  1213: ;
                        	  1214: ;  backspace reduces our pointer by one, unless we are at the start
                        	  1215: ;
                        	  1216: editor_insert_backspace:
00:8ACA A523            	  1217:   lda PCODE
00:8ACC C5AE            	  1218:   cmp this_line_addr
00:8ACE D006            	  1219:   bne editor_insert_backspace_not_at_start
00:8AD0 A524            	  1220:   lda PCODE+1
00:8AD2 C5AF            	  1221:   cmp this_line_addr+1
00:8AD4 F0AB            	  1222:   beq editor_insert_loop    ; at start, ignore backspace
                        	  1223: 
                        	  1224: editor_insert_backspace_not_at_start:
00:8AD6 38              	  1225:   sec                       ; move source pointer back one
00:8AD7 A523            	  1226:   lda PCODE
00:8AD9 E901            	  1227:   sbc #1
00:8ADB 8523            	  1228:   sta PCODE
00:8ADD A524            	  1229:   lda PCODE+1
00:8ADF E900            	  1230:   sbc #0
00:8AE1 8524            	  1231:   sta PCODE+1
00:8AE3 B123            	  1232:   lda (PCODE),y
00:8AE5 AA              	  1233:   tax                      ; this is now the last character we inserted
                        	  1234: ;
                        	  1235: ;  however we don't want them backspacing over a previous line, so if we detect a newline
                        	  1236: ;  just go back up and put it back (and increment PCODE back to where it was)
                        	  1237: ;
00:8AE6 C90A            	  1238:   cmp #NL
00:8AE8 F0C7            	  1239:   beq editor_insert_not_newline
00:8AEA 8095            	  1240:   bra editor_insert_loop
                        	  1241: 
                        	  1242: editor_insert_done:
00:8AEC 8A              	  1243:   txa
00:8AED F00E            	  1244:   beq editor_insert_done_with_newline   ; nothing got inserted at all
00:8AEF C90A            	  1245:   cmp #NL
00:8AF1 F00A            	  1246:   beq editor_insert_done_with_newline  ; skip inserting a newline if we just got a newline
                        	  1247: ;
                        	  1248: ;  They finished inserting, but without a newline ... add one
                        	  1249: ;
00:8AF3 A90A            	  1250:   lda #NL
00:8AF5 9123            	  1251:   sta (PCODE),y
00:8AF7 E623            	  1252:   inc PCODE
00:8AF9 D002            	  1253:   bne editor_insert_done_with_newline
00:8AFB E624            	  1254:   inc PCODE+1
                        	  1255: 
                        	  1256: ;
                        	  1257: ;  they are done - copy the rest back to the end of where they just inserted
                        	  1258: ;
                        	  1259: editor_insert_done_with_newline:
                        	  1260: 
00:8AFD 64BE            	  1261:   stz system_flags     ; compile is not valid any more
                        	  1262: 
00:8AFF A523            	  1263:   lda PCODE
00:8B01 85A8            	  1264:   sta mem_move_dest
00:8B03 A524            	  1265:   lda PCODE+1
00:8B05 85A9            	  1266:   sta mem_move_dest+1
                        	  1267: 
00:8B07 A5A4            	  1268:   lda insert_limit
00:8B09 85A6            	  1269:   sta mem_move_src
00:8B0B A5A5            	  1270:   lda insert_limit+1
00:8B0D 85A7            	  1271:   sta mem_move_src+1
                        	  1272: 
00:8B0F 207A81          	  1273:   jsr movedown
                        	  1274: 
00:8B12 200C95          	  1275:   jsr CROUT   ; put a newline after the ESC character
00:8B15 4C7282          	  1276:   jmp main_prompt
                        	  1277: 
                        	  1278: editor_too_full:
00:8B18 A943            	  1279:   lda #<memory_full
00:8B1A A28B            	  1280:   ldx #>memory_full
00:8B1C 202682          	  1281:   jsr print
                        	  1282: ;
                        	  1283: ;  consume input so it isn't mistaken for a command
                        	  1284: ;
                        	  1285: editor_too_full_loop:
00:8B1F 200FCC          	  1286:   jsr CHRIN
00:8B22 C91B            	  1287:   cmp #END_EDITOR_INPUT
00:8B24 D0F9            	  1288:   bne editor_too_full_loop
                        	  1289: ;
                        	  1290: ;  another message, they may miss the first one during a bulk load
                        	  1291: ;
00:8B26 A95E            	  1292:   lda #<memory_filled_up
00:8B28 A28B            	  1293:   ldx #>memory_filled_up
00:8B2A 202682          	  1294:   jsr print
00:8B2D 4CEC8A          	  1295:   jmp editor_insert_done
                        	  1296: 
00:8B30 4E6F2072616E6765	  1297: editor_no_lines  asciiz "No range supplied\n"
00:8B38 20737570706C6965
00:8B40 640A
00:8B42 00
00:8B43 0A0A4D656D6F7279	  1298: memory_full      asciiz "\n\nMemory full - press Esc\n"
00:8B4B 2066756C6C202D20
00:8B53 7072657373204573
00:8B5B 630A
00:8B5D 00
00:8B5E 0A0A4E6F20726F6F	  1299: memory_filled_up asciiz "\n\nNo room for source during load/input\n\n"
00:8B66 6D20666F7220736F
00:8B6E 7572636520647572
00:8B76 696E67206C6F6164
00:8B7E 2F696E7075740A0A
00:8B86 00
                        	  1300: 
                        	  1301: ;
                        	  1302: ;  subroutine to check we got a range for certain actions
                        	  1303: ;
                        	  1304: editor_argument_check:
00:8B87 A000            	  1305:   ldy #0
                        	  1306: ;
                        	  1307: ;  skip spaces to make sure we got a range
                        	  1308: ;
                        	  1309: editor_argument_check_loop:
00:8B89 B18E            	  1310:   lda (token_start),y
00:8B8B F00C            	  1311:   beq editor_argument_check_failed
00:8B8D C90A            	  1312:   cmp #NL
00:8B8F F008            	  1313:   beq editor_argument_check_failed
00:8B91 204A81          	  1314:   jsr isspace
00:8B94 900D            	  1315:   bcc editor_argument_check_got_argument
00:8B96 C8              	  1316:   iny
00:8B97 D0F0            	  1317:   bne editor_argument_check_loop
                        	  1318: 
                        	  1319: ;
                        	  1320: ;  only found spaces, not good enough
                        	  1321: ;
                        	  1322: editor_argument_check_failed:
00:8B99 A930            	  1323:   lda #<editor_no_lines
00:8B9B A28B            	  1324:   ldx #>editor_no_lines
00:8B9D 202682          	  1325:   jsr print
00:8BA0 4C7282          	  1326:   jmp  main_prompt
                        	  1327: 
                        	  1328: editor_argument_check_got_argument:
00:8BA3 60              	  1329:   rts
                        	  1330: 
                        	  1331: 
                        	  1332: ;--------------------------------------------
                        	  1333: ;  DELETE
                        	  1334: ;--------------------------------------------
                        	  1335: editor_delete:
                        	  1336: ;
                        	  1337: ;  default to no lines
                        	  1338: ;
00:8BA4 649E            	  1339:   stz from_line
00:8BA6 649F            	  1340:   stz from_line+1
00:8BA8 64A0            	  1341:   stz to_line
00:8BAA 64A1            	  1342:   stz to_line+1
                        	  1343: 
00:8BAC 64B9            	  1344:   stz find_count      ; delete count in this case
00:8BAE 64BA            	  1345:   stz find_count+1
00:8BB0 20878B          	  1346:   jsr editor_argument_check ; cannot get away with no arguments
                        	  1347: 
00:8BB3 205D86          	  1348:   jsr editor_get_range
00:8BB6 204086          	  1349:   jsr editor_check_no_more
                        	  1350: 
00:8BB9 A59E            	  1351:   lda from_line
00:8BBB 85AC            	  1352:   sta this_line
00:8BBD A59F            	  1353:   lda from_line+1
00:8BBF 85AD            	  1354:   sta this_line+1
00:8BC1 20858C          	  1355:   jsr find_line       ; find the "from" line address
00:8BC4 A5AE            	  1356:   lda this_line_addr  ; that becomes the destination of the move
00:8BC6 85A8            	  1357:   sta mem_move_dest
00:8BC8 A5AF            	  1358:   lda this_line_addr+1
00:8BCA 85A9            	  1359:   sta mem_move_dest+1
00:8BCC 64AA            	  1360:   stz mem_move_len
00:8BCE 64AB            	  1361:   stz mem_move_len+1
                        	  1362: ;
                        	  1363: ;  now we'll work our way up until we get to the to_line, however we'll
                        	  1364: ;  add one because we want the final address to actually be the start of
                        	  1365: ;  the NEXT line
                        	  1366: ;
00:8BD0 18              	  1367:   clc
00:8BD1 A5A0            	  1368:   lda to_line
00:8BD3 6901            	  1369:   adc #1
00:8BD5 85AC            	  1370:   sta this_line
00:8BD7 A5A1            	  1371:   lda to_line+1
00:8BD9 6900            	  1372:   adc #0
00:8BDB 85AD            	  1373:   sta this_line+1
00:8BDD 20938C          	  1374:   jsr find_line_loop    ; find the "to" line address
00:8BE0 A5AE            	  1375:   lda this_line_addr  ; that becomes the destination of the move
00:8BE2 85A6            	  1376:   sta mem_move_src
00:8BE4 A5AF            	  1377:   lda this_line_addr+1
00:8BE6 85A7            	  1378:   sta mem_move_src+1
                        	  1379: 
                        	  1380: ;
                        	  1381: ;  count how many lines we delete by counting newlines from
                        	  1382: ;   mem_move_dest to mem_move_src
                        	  1383: ;
                        	  1384: 
00:8BE8 A5A8            	  1385:   lda mem_move_dest
00:8BEA 8523            	  1386:   sta PCODE
00:8BEC A5A9            	  1387:   lda mem_move_dest+1
00:8BEE 8524            	  1388:   sta PCODE+1
00:8BF0 A000            	  1389:   ldy #0
                        	  1390: 
                        	  1391: editor_delete_line_count_loop:
00:8BF2 A523            	  1392:   lda PCODE
00:8BF4 C5A6            	  1393:   cmp mem_move_src
00:8BF6 D006            	  1394:   bne editor_delete_line_count_not_done
00:8BF8 A524            	  1395:   lda PCODE+1
00:8BFA C5A7            	  1396:   cmp mem_move_src+1
00:8BFC F014            	  1397:   beq editor_delete_line_count_done
                        	  1398: 
                        	  1399: editor_delete_line_count_not_done:
00:8BFE B123            	  1400:   lda (PCODE),y
00:8C00 C90A            	  1401:   cmp #NL
00:8C02 D006            	  1402:   bne editor_delete_line_count_not_newline
00:8C04 E6B9            	  1403:   inc find_count
00:8C06 D002            	  1404:   bne editor_delete_line_count_not_newline
00:8C08 E6BA            	  1405:   inc find_count+1
                        	  1406: editor_delete_line_count_not_newline:
00:8C0A E623            	  1407:   inc PCODE
00:8C0C D0E4            	  1408:   bne editor_delete_line_count_loop
00:8C0E E624            	  1409:   inc PCODE+1
00:8C10 80E0            	  1410:   bra editor_delete_line_count_loop
                        	  1411: 
                        	  1412: ;
                        	  1413: ;  now find where the source ends
                        	  1414: ;  PCODE will now be at the first line to not be deleted
                        	  1415: ;
                        	  1416: editor_delete_line_count_done:
                        	  1417: 
00:8C12 20C18C          	  1418:   jsr find_source_end_loop
00:8C15 38              	  1419:   sec
00:8C16 A523            	  1420:   lda PCODE
00:8C18 E5AE            	  1421:   sbc this_line_addr
00:8C1A 85AA            	  1422:   sta mem_move_len
00:8C1C A524            	  1423:   lda PCODE+1
00:8C1E E5AF            	  1424:   sbc this_line_addr+1
00:8C20 85AB            	  1425:   sta mem_move_len+1
00:8C22 207A81          	  1426:   jsr movedown  ; that should do it
                        	  1427: 
00:8C25 A5B9            	  1428:   lda find_count
00:8C27 8500            	  1429:   sta REG
00:8C29 A5BA            	  1430:   lda find_count+1
00:8C2B 8501            	  1431:   sta REG+1
00:8C2D 6402            	  1432:   stz REGB
00:8C2F 203694          	  1433:   jsr display_in_decimal
00:8C32 A93C            	  1434:   lda #<lines_deleted_message
00:8C34 A28C            	  1435:   ldx #>lines_deleted_message
00:8C36 202682          	  1436:   jsr print
00:8C39 4C7282          	  1437:   jmp main_prompt
                        	  1438: 
00:8C3C 2064656C65746564	  1439: lines_deleted_message asciiz " deleted.\n"
00:8C44 2E0A
00:8C46 00
                        	  1440: 
                        	  1441: ;--------------------------------------------
                        	  1442: ;  show current line number with leading spaces
                        	  1443: ;--------------------------------------------
                        	  1444: show_current_line_number:
00:8C47 48              	  1445:   pha
00:8C48 DA              	  1446:   phx
00:8C49 5A              	  1447:   phy
                        	  1448: ;
                        	  1449: ;  get the line number into REG ready for printing
                        	  1450: ;
00:8C4A A5A2            	  1451:   lda current_line
00:8C4C 8500            	  1452:   sta REG
00:8C4E A6A3            	  1453:   ldx current_line+1
00:8C50 8601            	  1454:   stx REG+1
00:8C52 A000            	  1455:   ldy #0        ; count of leading spaces
00:8C54 8402            	  1456:   sty REGB
00:8C56 E003            	  1457:   cpx #>1000    ; if the number is >= 1000 don't print any spaces
00:8C58 9006            	  1458:   bcc line_number_lt_1000
00:8C5A D013            	  1459:   bne line_number_output_spaces
00:8C5C C9E8            	  1460:   cmp #<1000
00:8C5E B00F            	  1461:   bcs line_number_output_spaces
                        	  1462: line_number_lt_1000:
00:8C60 C8              	  1463:   iny           ; output one space
00:8C61 E000            	  1464:   cpx  #0       ; if line number > 255 then one space is all we need
00:8C63 D00A            	  1465:   bne  line_number_output_spaces
00:8C65 C964            	  1466:   cmp  #100     ; if line number >= 100 then one space is all we need
00:8C67 B006            	  1467:   bcs  line_number_output_spaces
00:8C69 C8              	  1468:   iny           ; output two spaces
00:8C6A C90A            	  1469:   cmp  #10      ; if line number >= 10 then two spaces are all we need
00:8C6C B001            	  1470:   bcs  line_number_output_spaces
00:8C6E C8              	  1471:   iny           ; output three spaces
                        	  1472: line_number_output_spaces:
00:8C6F C000            	  1473:   cpy #0            ; leading spaces in front of line number
00:8C71 F008            	  1474:   beq  show_current_line_number_done
00:8C73 5A              	  1475:   phy
00:8C74 209795          	  1476:   jsr  PUTSP      ; output the space
00:8C77 7A              	  1477:   ply
00:8C78 88              	  1478:   dey             ; count them
00:8C79 D0F4            	  1479:   bne  line_number_output_spaces  ; more spaces to go
                        	  1480: show_current_line_number_done:
00:8C7B 203694          	  1481:   jsr  display_in_decimal    ; now the actual number
00:8C7E 209795          	  1482:   jsr  PUTSP      ; and a space after it
00:8C81 7A              	  1483:   ply
00:8C82 FA              	  1484:   plx
00:8C83 68              	  1485:   pla
00:8C84 60              	  1486:   rts
                        	  1487: 
                        	  1488: ;--------------------------------------------
                        	  1489: ;  find_line
                        	  1490: ;
                        	  1491: ;  finds address of this_line in memory - returns in this_line_addr
                        	  1492: ;--------------------------------------------
                        	  1493: find_line:
00:8C85 A901            	  1494:   lda #1
00:8C87 85A2            	  1495:   sta current_line    ; current line number (1)
00:8C89 64A3            	  1496:   stz current_line+1
00:8C8B A900            	  1497:   lda #<TEXT_START   ; start at start of source
00:8C8D 85AE            	  1498:   sta this_line_addr
00:8C8F A903            	  1499:   lda #>TEXT_START
00:8C91 85AF            	  1500:   sta this_line_addr+1
                        	  1501: find_line_loop:
00:8C93 A000            	  1502:   ldy #0
00:8C95 A5A2            	  1503:   lda current_line
00:8C97 C5AC            	  1504:   cmp this_line
00:8C99 D007            	  1505:   bne find_line_next
00:8C9B A5A3            	  1506:   lda current_line+1
00:8C9D C5AD            	  1507:   cmp this_line+1
00:8C9F D001            	  1508:   bne find_line_next
00:8CA1 60              	  1509:   rts
                        	  1510: find_line_next:
00:8CA2 B1AE            	  1511:   lda (this_line_addr),Y
00:8CA4 F012            	  1512:   beq find_line_eof
00:8CA6 C90A            	  1513:   cmp #NL
00:8CA8 D006            	  1514:   bne find_line_same_line
00:8CAA E6A2            	  1515:   inc current_line       ; add 1 to our line number counter
00:8CAC D002            	  1516:   bne find_line_same_line
00:8CAE E6A3            	  1517:   inc current_line+1
                        	  1518: find_line_same_line:
00:8CB0 E6AE            	  1519:   inc this_line_addr     ; onto next address - which means that a newline
00:8CB2 D0DF            	  1520:   bne find_line_loop     ; will actually end up being the start of the new
00:8CB4 E6AF            	  1521:   inc this_line_addr+1   ; line, which is what we want
00:8CB6 80DB            	  1522:   bra find_line_loop
                        	  1523: find_line_eof:           ; we are pointing to 0x00 - make that the address
00:8CB8 60              	  1524:   rts
                        	  1525: 
                        	  1526: 
                        	  1527: 
                        	  1528: ;***********************************************
                        	  1529: ; Find text end
                        	  1530: ;***********************************************
                        	  1531: find_source_end:
00:8CB9 A900            	  1532:   lda  #<TEXT_START        ; start at start of source
00:8CBB 8523            	  1533:   sta  PCODE
00:8CBD A903            	  1534:   lda  #>TEXT_START
00:8CBF 8524            	  1535:   sta  PCODE+1
                        	  1536: find_source_end_loop =  *
00:8CC1 A000            	  1537:   ldy  #0
00:8CC3 B123            	  1538:   lda  (PCODE),Y             ; keep going until 0x00 indicates end of source
00:8CC5 F008            	  1539:   beq  find_source_end_wrap
00:8CC7 E623            	  1540:   inc  PCODE
00:8CC9 D0F6            	  1541:   bne  find_source_end_loop
00:8CCB E624            	  1542:   inc  PCODE+1
00:8CCD 80F2            	  1543:   bra  find_source_end_loop
                        	  1544: ;
                        	  1545: ;  include final 0x00
                        	  1546: ;
                        	  1547: find_source_end_wrap =  *
00:8CCF E623            	  1548:   inc  PCODE
00:8CD1 D002            	  1549:   bne  find_source_end_done
00:8CD3 E624            	  1550:   inc  PCODE+1
                        	  1551: find_source_end_done =  *
00:8CD5 60              	  1552:   rts
                        	  1553: 
                        	  1554: ;
                        	  1555: ;  testing BRK handling
                        	  1556: ;
00:8CD6 0A526573756D6564	  1557: brk_resumed asciiz "\nResumed after BRK\n"
00:8CDE 2061667465722042
00:8CE6 524B0A
00:8CE9 00
                        	  1558: 
                        	  1559: editor_test:
00:8CEA A912            	  1560:   lda #$12
00:8CEC A223            	  1561:   ldx #$23
00:8CEE A042            	  1562:   ldy #$42
00:8CF0 C912            	  1563:   cmp #$12
00:8CF2 00              	  1564:   brk
00:8CF3 99              	  1565:   dfb $99   ; break number
00:8CF4 A9D6            	  1566:   lda #<brk_resumed
00:8CF6 A28C            	  1567:   ldx #>brk_resumed
00:8CF8 202682          	  1568:   jsr print
00:8CFB 60              	  1569:   rts
                        	  1570: 
                        	  1571: ;
                        	  1572: ;  memory dump
                        	  1573: ;
                        	  1574: editor_memory:
00:8CFC 20878B          	  1575:   jsr editor_argument_check  ; check they supplied some sort of range
00:8CFF 203A85          	  1576:   jsr editor_default_range
00:8D02 A902            	  1577:   lda #EFLAG_ALLOW_ZERO_FROM
00:8D04 85BC            	  1578:   sta editor_flags
00:8D06 205D86          	  1579:   jsr editor_get_range
00:8D09 204086          	  1580:   jsr editor_check_no_more
00:8D0C 64A2            	  1581:   stz current_line      ; count of bytes shown
00:8D0E A59E            	  1582:   lda from_line
00:8D10 85AE            	  1583:   sta this_line_addr
00:8D12 A59F            	  1584:   lda from_line+1
00:8D14 85AF            	  1585:   sta this_line_addr+1
                        	  1586: 
                        	  1587: editor_memory_loop:
00:8D16 A58B            	  1588:   lda serial_in_byte_received
00:8D18 C903            	  1589:   cmp  #KEY_ABORT
00:8D1A F053            	  1590:   beq  editor_memory_aborted
                        	  1591: 
00:8D1C A5A2            	  1592:   lda current_line
00:8D1E D017            	  1593:   bne editor_memory_loop1
                        	  1594: ;
                        	  1595: ;  show address
                        	  1596: ;
00:8D20 A924            	  1597:   lda #'$'
00:8D22 209A96          	  1598:   jsr COUT
00:8D25 A59F            	  1599:   lda from_line+1
00:8D27 208195          	  1600:   jsr PRBYTE
00:8D2A A59E            	  1601:   lda from_line
00:8D2C 208195          	  1602:   jsr PRBYTE
00:8D2F A93A            	  1603:   lda #':'
00:8D31 209A96          	  1604:   jsr COUT
00:8D34 209795          	  1605:   jsr PUTSP
                        	  1606: editor_memory_loop1:
00:8D37 A000            	  1607:   ldy #0
00:8D39 B19E            	  1608:   lda (from_line),Y
00:8D3B 208195          	  1609:   jsr PRBYTE
00:8D3E 209795          	  1610:   jsr PUTSP
00:8D41 E6A2            	  1611:   inc current_line
00:8D43 E69E            	  1612:   inc from_line
00:8D45 D002            	  1613:   bne editor_memory_loop2
00:8D47 E69F            	  1614:   inc from_line+1
                        	  1615: editor_memory_loop2:
                        	  1616: ;
                        	  1617: ;  if we wrap around back to zero, stop
                        	  1618: ;
00:8D49 A59E            	  1619:   lda from_line
00:8D4B 059F            	  1620:   ora from_line+1
00:8D4D F01D            	  1621:   beq editor_memory_done
00:8D4F A59F            	  1622:   lda from_line+1
00:8D51 C5A1            	  1623:   cmp to_line+1
00:8D53 900A            	  1624:   bcc editor_memory_loop3   ; less than
00:8D55 D015            	  1625:   bne editor_memory_done    ; greater than
00:8D57 A59E            	  1626:   lda from_line             ; equal, so try low-order byte
00:8D59 C5A0            	  1627:   cmp to_line
00:8D5B 9002            	  1628:   bcc editor_memory_loop3   ; less than
00:8D5D D00D            	  1629:   bne editor_memory_done    ; greater than
                        	  1630: editor_memory_loop3:
00:8D5F A5A2            	  1631:   lda current_line
00:8D61 C910            	  1632:   cmp #16
00:8D63 90B1            	  1633:   bcc editor_memory_loop
00:8D65 20758D          	  1634:   jsr editor_memory_show_ascii
00:8D68 64A2            	  1635:   stz current_line      ; count of bytes shown
00:8D6A 80AA            	  1636:   bra editor_memory_loop
                        	  1637: 
                        	  1638: editor_memory_done:
00:8D6C 20758D          	  1639:   jsr editor_memory_show_ascii
                        	  1640: editor_memory_aborted:
00:8D6F 200C95          	  1641:   jsr CROUT
00:8D72 4C7282          	  1642:   jmp  main_prompt
                        	  1643: 
                        	  1644: editor_memory_show_ascii:
                        	  1645: ;
                        	  1646: ;  now the ASCII equivalents
                        	  1647: ;
00:8D75 209795          	  1648:   jsr PUTSP
00:8D78 A000            	  1649:   ldy #0
                        	  1650: editor_memory_ascii:
00:8D7A B1AE            	  1651:   lda (this_line_addr),Y
00:8D7C C920            	  1652:   cmp #$20
00:8D7E B002            	  1653:   bcs editor_memory_not_control
00:8D80 8004            	  1654:   bra editor_memory_show_dot
                        	  1655: editor_memory_not_control:
00:8D82 C97F            	  1656:   cmp #$7F
00:8D84 9002            	  1657:   bcc editor_memory_not_high
                        	  1658: editor_memory_show_dot
00:8D86 A92E            	  1659:   lda #'.'
                        	  1660: editor_memory_not_high:
00:8D88 209A96          	  1661:   jsr COUT
00:8D8B 209795          	  1662:   jsr PUTSP
00:8D8E C8              	  1663:   iny
00:8D8F C6A2            	  1664:   dec current_line
00:8D91 D0E7            	  1665:   bne editor_memory_ascii
                        	  1666: ;
                        	  1667: ;  adjust the ASCII printing address
                        	  1668: ;
00:8D93 A59E            	  1669:   lda from_line
00:8D95 85AE            	  1670:   sta this_line_addr
00:8D97 A59F            	  1671:   lda from_line+1
00:8D99 85AF            	  1672:   sta this_line_addr+1
                        	  1673: 
00:8D9B 200C95          	  1674:   jsr CROUT
00:8D9E 60              	  1675:   rts
                        	  1676: 
                        	  1677: 
                        	  1678: 
                        	  1679: 
00:8D9F 4164647220507265	  1680: symbol_table_message asciiz "Addr Prev L  T Dsp  Ar Da Ln Name\n"
00:8DA7 76204C2020542044
00:8DAF 7370202041722044
00:8DB7 61204C6E204E616D
00:8DBF 650A
00:8DC1 00
                        	  1681: 
                        	  1682: editor_symbol_table_list  = *
00:8DC2 A99F            	  1683:   lda #<symbol_table_message
00:8DC4 A28D            	  1684:   ldx #>symbol_table_message
00:8DC6 202682          	  1685:   jsr print
                        	  1686: 
00:8DC9 A532            	  1687:   lda  ENDSYM+1    ; get the end of the symbol table
00:8DCB 8541            	  1688:   sta  SYMITM+1    ; make it the current symbol
00:8DCD A531            	  1689:   lda  ENDSYM
00:8DCF 800B            	  1690:   bra  ST_SYMTBL_LIST_CHECK
                        	  1691: 
                        	  1692: ST_SYMTBL_LIST_NEXT =  *
00:8DD1 A000            	  1693:   ldy  #SYMPRV
00:8DD3 B140            	  1694:   lda  (SYMITM),Y
00:8DD5 AA              	  1695:   tax
00:8DD6 C8              	  1696:   iny
00:8DD7 B140            	  1697:   lda  (SYMITM),Y
00:8DD9 8541            	  1698:   sta  SYMITM+1   ; previous link
00:8DDB 8A              	  1699:   txa
                        	  1700: ;
                        	  1701: ;  go to the previous symbol table item
                        	  1702: ;
                        	  1703: ST_SYMTBL_LIST_CHECK     =  *
00:8DDC 8540            	  1704:   sta  SYMITM
00:8DDE C9FF            	  1705:   cmp  #<SYMBOL_TABLE_START
00:8DE0 D009            	  1706:   bne  ST_SYMTBL_LIST_LINE
00:8DE2 A541            	  1707:   lda  SYMITM+1
00:8DE4 C93F            	  1708:   cmp  #>SYMBOL_TABLE_START
00:8DE6 D003            	  1709:   bne  ST_SYMTBL_LIST_LINE       ; more to go
00:8DE8 4C718E          	  1710:   jmp  ST_SYMTBL_LIST_DONE       ; finished if symitm and symitm+1 are both zero
                        	  1711: 
                        	  1712: ST_SYMTBL_LIST_LINE = *
00:8DEB A541            	  1713:   lda  SYMITM+1
00:8DED 208195          	  1714:   jsr  PRBYTE
00:8DF0 A540            	  1715:   lda  SYMITM
00:8DF2 208195          	  1716:   jsr  PRBYTE
00:8DF5 A920            	  1717:   lda  #' '
00:8DF7 206995          	  1718:   jsr  PRCHAR
00:8DFA A001            	  1719:   ldy  #SYMPRV+1
00:8DFC B140            	  1720:   lda  (SYMITM),Y
00:8DFE 208195          	  1721:   jsr  PRBYTE
00:8E01 88              	  1722:   dey
00:8E02 B140            	  1723:   lda  (SYMITM),Y
00:8E04 208195          	  1724:   jsr  PRBYTE
00:8E07 A920            	  1725:   lda  #' '
00:8E09 206995          	  1726:   jsr  PRCHAR
00:8E0C A002            	  1727:   ldy  #SYMLVL
00:8E0E B140            	  1728:   lda  (SYMITM),Y  ; level
00:8E10 208195          	  1729:   jsr  PRBYTE
00:8E13 A920            	  1730:   lda  #' '
00:8E15 206995          	  1731:   jsr  PRCHAR
00:8E18 A003            	  1732:   ldy  #SYMTYP
00:8E1A B140            	  1733:   lda  (SYMITM),Y  ; type
00:8E1C 206995          	  1734:   jsr  PRCHAR
00:8E1F A920            	  1735:   lda  #' '
00:8E21 206995          	  1736:   jsr  PRCHAR
00:8E24 A004            	  1737:   ldy  #SYMDSP
00:8E26 C8              	  1738:   iny
00:8E27 B140            	  1739:   lda  (SYMITM),Y  ; displacement
00:8E29 208195          	  1740:   jsr  PRBYTE
00:8E2C 88              	  1741:   dey
00:8E2D B140            	  1742:   lda  (SYMITM),Y  ; displacement
00:8E2F 208195          	  1743:   jsr  PRBYTE
00:8E32 A920            	  1744:   lda  #' '
00:8E34 206995          	  1745:   jsr  PRCHAR
00:8E37 A006            	  1746:   ldy  #SYMARG
00:8E39 B140            	  1747:   lda  (SYMITM),Y  ; argument count
00:8E3B 208195          	  1748:   jsr  PRBYTE
00:8E3E A920            	  1749:   lda  #' '
00:8E40 206995          	  1750:   jsr  PRCHAR
00:8E43 A008            	  1751:   ldy  #SYMDAT
00:8E45 B140            	  1752:   lda  (SYMITM),Y  ; data type
00:8E47 208195          	  1753:   jsr  PRBYTE
00:8E4A A920            	  1754:   lda  #' '
00:8E4C 206995          	  1755:   jsr  PRCHAR
00:8E4F A009            	  1756:   ldy  #SYMLEN
00:8E51 B140            	  1757:   lda  (SYMITM),Y  ; length
00:8E53 48              	  1758:   pha
00:8E54 208195          	  1759:   jsr  PRBYTE
00:8E57 A920            	  1760:   lda  #' '
00:8E59 206995          	  1761:   jsr  PRCHAR
00:8E5C A00A            	  1762:   ldy  #SYMNAM
00:8E5E 68              	  1763:   pla
00:8E5F AA              	  1764:   tax
                        	  1765: ST_SYMTBL_LIST_NAME = *
00:8E60 B140            	  1766:   lda  (SYMITM),Y  ; name
00:8E62 5A              	  1767:   phy
00:8E63 206995          	  1768:   jsr  PRCHAR
00:8E66 7A              	  1769:   ply
00:8E67 C8              	  1770:   iny
00:8E68 CA              	  1771:   dex
00:8E69 D0F5            	  1772:   bne ST_SYMTBL_LIST_NAME
00:8E6B 200C95          	  1773:   jsr CROUT
00:8E6E 4CD18D          	  1774:   jmp ST_SYMTBL_LIST_NEXT
                        	  1775: 
                        	  1776: ST_SYMTBL_LIST_DONE = *
                        	  1777: 
00:8E71 4C7282          	  1778:   jmp main_prompt
                        	  1779: 
                        	  1780: 
00:8E74 446F6E650A      	  1781: recover_done asciiz "Done\n"
00:8E79 00
00:8E7A 4E6F74206E656564	  1782: recover_not_needed asciiz "Not needed\n"
00:8E82 65640A
00:8E85 00
                        	  1783: 
                        	  1784: ;
                        	  1785: ; Recover: if the first byte of the source is 0x00, change it to a space
                        	  1786: ;
                        	  1787: editor_recover:
00:8E86 204086          	  1788:   jsr editor_check_no_more
00:8E89 A900            	  1789:   lda  #<TEXT_START
00:8E8B 8540            	  1790:   sta  FROM
00:8E8D A903            	  1791:   lda  #>TEXT_START
00:8E8F 8541            	  1792:   sta  FROM+1
00:8E91 A000            	  1793:   ldy  #0
00:8E93 B140            	  1794:   lda  (FROM),Y
00:8E95 D00E            	  1795:   bne  editor_recover_not_needed
00:8E97 A920            	  1796:   lda  #' '
00:8E99 9140            	  1797:   sta  (FROM),Y
                        	  1798: editor_done_message:
00:8E9B A974            	  1799:   lda #<recover_done
00:8E9D A28E            	  1800:   ldx #>recover_done
00:8E9F 202682          	  1801:   jsr print
00:8EA2 4C7282          	  1802:   jmp main_prompt
                        	  1803: 
                        	  1804: editor_recover_not_needed:
00:8EA5 A97A            	  1805:   lda #<recover_not_needed
00:8EA7 A28E            	  1806:   ldx #>recover_not_needed
00:8EA9 202682          	  1807:   jsr print
00:8EAC 4C7282          	  1808:   jmp main_prompt
                        	  1809: 
00:8EAF 43616E6E6F742074	  1810: not_assembler_message asciiz "Cannot trace or debug assembler code\n"
00:8EB7 72616365206F7220
00:8EBF 6465627567206173
00:8EC7 73656D626C657220
00:8ECF 636F64650A
00:8ED4 00
                        	  1811: 
                        	  1812: editor_debug:
00:8ED5 204086          	  1813:   jsr editor_check_no_more
00:8ED8 A910            	  1814:   lda  #FLAG_VALID_ASSEMBLE
00:8EDA 25BE            	  1815:   and  system_flags
00:8EDC F00A            	  1816:   beq editor_debug_ok
                        	  1817: 
                        	  1818: editor_not_assembler:
00:8EDE A9AF            	  1819:   lda #<not_assembler_message
00:8EE0 A28E            	  1820:   ldx #>not_assembler_message
00:8EE2 202682          	  1821:   jsr print
00:8EE5 4C7282          	  1822:   jmp main_prompt
                        	  1823: 
                        	  1824: editor_debug_ok:
00:8EE8 A901            	  1825:   lda #1
00:8EEA 8549            	  1826:   sta  DBGFLG
00:8EEC 852E            	  1827:   sta  DCODE
00:8EEE 4C4F96          	  1828:   jmp  CHK_RUN
                        	  1829: 
                        	  1830: editor_trace:
00:8EF1 204086          	  1831:   jsr editor_check_no_more
00:8EF4 A910            	  1832:   lda  #FLAG_VALID_ASSEMBLE
00:8EF6 25BE            	  1833:   and  system_flags
00:8EF8 D0E4            	  1834:   bne  editor_not_assembler
00:8EFA A980            	  1835:   lda  #$80
00:8EFC 8549            	  1836:   sta  DBGFLG
00:8EFE 852E            	  1837:   sta  DCODE
00:8F00 4C4F96          	  1838:   jmp  CHK_RUN
                        	  1839: 
                        	  1840: 
                        	  1841: editor_info  = *
00:8F03 204086          	  1842:   jsr editor_check_no_more
00:8F06 20828F          	  1843:   jsr show_source_start
00:8F09 205A8F          	  1844:   jsr show_source_end
00:8F0C 20A48F          	  1845:   jsr show_source_lines
00:8F0F 206793          	  1846:   jsr crc_source
00:8F12 4C7282          	  1847:   jmp main_prompt
                        	  1848: 
                        	  1849: editor_compile:
00:8F15 204086          	  1850:   jsr editor_check_no_more
00:8F18 A900            	  1851:   lda  #0
00:8F1A 8542            	  1852:   sta  SYNTAX
00:8F1C 4C46BD          	  1853:   jmp  COMPIL
                        	  1854: 
                        	  1855: editor_syntax:
00:8F1F 204086          	  1856:   jsr editor_check_no_more
00:8F22 A901            	  1857:   lda #1
00:8F24 8542            	  1858:   sta  SYNTAX
00:8F26 4C46BD          	  1859:   jmp  COMPIL
                        	  1860: 
                        	  1861: editor_run:
00:8F29 204086          	  1862:   jsr editor_check_no_more
00:8F2C A900            	  1863:   lda  #0
00:8F2E 8549            	  1864:   sta  DBGFLG
00:8F30 852E            	  1865:   sta  DCODE
00:8F32 4C4F96          	  1866:   jmp  CHK_RUN
                        	  1867: 
                        	  1868:   ;
                        	  1869: show_symbol_table_end:
00:8F35 A9F4            	  1870:   lda  #<symbol_table_ended_message    ; Symbol table ended at
00:8F37 A295            	  1871:   ldx  #>symbol_table_ended_message
00:8F39 202682          	  1872:   jsr  print
00:8F3C A532            	  1873:   lda  ENDSYM+1
00:8F3E 208195          	  1874:   jsr  PRBYTE
00:8F41 A531            	  1875:   lda  ENDSYM
00:8F43 203696          	  1876:   jsr  PRBYTECR
00:8F46 60              	  1877:   rts
                        	  1878: 
                        	  1879: 
00:8F47 536F757263652065	  1880: source_ended_message asciiz "Source ends   at $"
00:8F4F 6E64732020206174
00:8F57 2024
00:8F59 00
                        	  1881: show_source_end:
00:8F5A A947            	  1882:   lda #<source_ended_message
00:8F5C A28F            	  1883:   ldx #>source_ended_message
00:8F5E 202682          	  1884:   jsr print
00:8F61 20B98C          	  1885:   jsr find_source_end
00:8F64 A524            	  1886:   lda PCODE+1
00:8F66 208195          	  1887:   jsr PRBYTE
00:8F69 A523            	  1888:   lda PCODE
00:8F6B 203696          	  1889:   jsr PRBYTECR
00:8F6E 60              	  1890:   rts
                        	  1891: 
00:8F6F 536F757263652073	  1892: source_starts_message asciiz "Source starts at $"    ; source starts at
00:8F77 7461727473206174
00:8F7F 2024
00:8F81 00
                        	  1893: show_source_start:
00:8F82 A96F            	  1894:   lda #<source_starts_message
00:8F84 A28F            	  1895:   ldx #>source_starts_message
00:8F86 202682          	  1896:   jsr print
00:8F89 A903            	  1897:   lda #>TEXT_START
00:8F8B 208195          	  1898:   jsr PRBYTE
00:8F8E A900            	  1899:   lda #<TEXT_START
00:8F90 203696          	  1900:   jsr PRBYTECR
00:8F93 60              	  1901:   rts
                        	  1902: 
                        	  1903: ;--------------------------------------------
                        	  1904: ;  show_source_lines - show count of number of source lines
                        	  1905: ;--------------------------------------------
00:8F94 536F75726365206C	  1906: source_line_count asciiz "Source lines:  "    ; count of lines
00:8F9C 696E65733A2020
00:8FA3 00
                        	  1907: show_source_lines:
00:8FA4 6400            	  1908:   stz VALUE      ; line count in this case
00:8FA6 6401            	  1909:   stz VALUE+1
00:8FA8 6402            	  1910:   stz VALUE+2
                        	  1911: 
00:8FAA A900            	  1912:   lda #<TEXT_START
00:8FAC 8523            	  1913:   sta PCODE
00:8FAE A903            	  1914:   lda #>TEXT_START
00:8FB0 8524            	  1915:   sta PCODE+1
00:8FB2 A000            	  1916:   ldy #0
                        	  1917: 
                        	  1918: editor_line_count_loop:
00:8FB4 B123            	  1919:   lda (PCODE),y
00:8FB6 F012            	  1920:   beq editor_line_count_done    ; 0x00 means end of source
00:8FB8 C90A            	  1921:   cmp #NL                       ; newline?
00:8FBA D006            	  1922:   bne editor_line_count_not_newline
00:8FBC E600            	  1923:   inc VALUE
00:8FBE D002            	  1924:   bne editor_line_count_not_newline
00:8FC0 E601            	  1925:   inc VALUE+1
                        	  1926: ;
                        	  1927: ;  increment pointer
                        	  1928: ;
                        	  1929: editor_line_count_not_newline:
00:8FC2 E623            	  1930:   inc PCODE
00:8FC4 D0EE            	  1931:   bne editor_line_count_loop
00:8FC6 E624            	  1932:   inc PCODE+1
00:8FC8 80EA            	  1933:   bra editor_line_count_loop
                        	  1934: 
                        	  1935: editor_line_count_done:
00:8FCA A994            	  1936:   lda #<source_line_count
00:8FCC A28F            	  1937:   ldx #>source_line_count
00:8FCE 202682          	  1938:   jsr print
00:8FD1 203694          	  1939:   jsr display_in_decimal
00:8FD4 200C95          	  1940:   jsr CROUT
00:8FD7 60              	  1941:   rts
                        	  1942: 
                        	  1943: editor_assemble:
00:8FD8 204086          	  1944:   jsr editor_check_no_more
00:8FDB 4C2D9B          	  1945:   jmp ASSEMBLE
                        	  1946: 
00:8FDE 4E6F2042524B2070	  1947: no_break_message asciiz "No BRK previously encountered\n"
00:8FE6 726576696F75736C
00:8FEE 7920656E636F756E
00:8FF6 74657265640A
00:8FFC 00
                        	  1948: 
                        	  1949: ;--------------------------------------------
                        	  1950: ;  editor_resume - resume after a breakpoint
                        	  1951: ;--------------------------------------------
                        	  1952: editor_resume:
00:8FFD 203C96          	  1953:   jsr CHK_VAL     ; check we had a valid compile/assemble
00:9000 A5BE            	  1954:   lda system_flags
00:9002 2980            	  1955:   and #FLAG_BRK_REACHED    ; BRK reached yet?
00:9004 D00A            	  1956:   bne editor_resume_ok
00:9006 A9DE            	  1957:   lda #<no_break_message
00:9008 A28F            	  1958:   ldx #>no_break_message
00:900A 202682          	  1959:   jsr print
00:900D 4C7282          	  1960:   jmp main_prompt
                        	  1961: editor_resume_ok:
00:9010 A980            	  1962:   lda #FLAG_BRK_REACHED    ; no BRK reached yet
00:9012 14BE            	  1963:   trb system_flags
                        	  1964: ;
                        	  1965: ;  put the stack back to what it was and push the
                        	  1966: ;   processor flags and breakpoint address
                        	  1967: ;
00:9014 18              	  1968:   clc
00:9015 A514            	  1969:   lda call_s
00:9017 6905            	  1970:   adc #5      ; undo effect of pushing X and Y, and the 3 pushes the processor did
00:9019 AA              	  1971:   tax
00:901A 9A              	  1972:   txs         ; switch back to what the stack pointer was
00:901B A516            	  1973:   lda brk_address+1   ; put stuff back ready for rti
00:901D 48              	  1974:   pha
00:901E A515            	  1975:   lda brk_address
00:9020 48              	  1976:   pha
00:9021 A513            	  1977:   lda call_p
00:9023 48              	  1978:   pha         ; processor flags
00:9024 A510            	  1979:   lda call_a  ; get registers back
00:9026 A412            	  1980:   ldy call_y
00:9028 A611            	  1981:   ldx call_x
00:902A 40              	  1982:   rti
                        	  1983: 
                        	  1984: 
00:902B 4E65656420616E20	  1985: editor_poke_message asciiz "Need an address and at least one value\n"
00:9033 6164647265737320
00:903B 616E64206174206C
00:9043 65617374206F6E65
00:904B 2076616C75650A
00:9052 00
                        	  1986: 
                        	  1987: ;--------------------------------------------
                        	  1988: ;  editor_poke - put stuff into memory
                        	  1989: ;
                        	  1990: ;  Note that as we do two passes over the input line, if they
                        	  1991: ;  choose a one-character string, get_token parses strings
                        	  1992: ;  into INBUF, so INBUF will be corrupted, however even in
                        	  1993: ;  the worst-case scenario: p8'a'
                        	  1994: ;  The corruption is only over the 'p' and re-parsing works OK. Just.
                        	  1995: ;--------------------------------------------
                        	  1996: editor_poke:
                        	  1997: ;
                        	  1998: ;  first check how many numbers are on the input line
                        	  1999: ;
00:9053 64B9            	  2000:   stz find_count
00:9055 A58E            	  2001:   lda token_start
00:9057 859E            	  2002:   sta from_line
00:9059 A58F            	  2003:   lda token_start+1
00:905B 859F            	  2004:   sta from_line+1
                        	  2005: 
                        	  2006: editor_poke_loop:
00:905D 208FCC          	  2007:   jsr get_token
00:9060 F02D            	  2008:   beq editor_poke_got_all_numbers
00:9062 C94E            	  2009:   cmp #TOKEN_NUMBER
00:9064 F011            	  2010:   beq editor_poke_got_number
00:9066 C922            	  2011:   cmp #TOKEN_STRING           ; a one-byte string is OK, eg. poke $1000 'a'
00:9068 D00A            	  2012:   bne editor_poke_bad_token
00:906A A5B9            	  2013:   lda find_count
00:906C F006            	  2014:   beq editor_poke_bad_token   ; however not for the address
00:906E A592            	  2015:   lda token_length
00:9070 C901            	  2016:   cmp #1
00:9072 F003            	  2017:   beq editor_poke_got_number
                        	  2018: ;
                        	  2019: ;  here when we got neither a number or a single-byte string
                        	  2020: ;
                        	  2021: editor_poke_bad_token:
00:9074 4C5885          	  2022:   jmp editor_bad_number
                        	  2023: editor_poke_got_number:
00:9077 E6B9            	  2024:   inc find_count
00:9079 A5B9            	  2025:   lda find_count
00:907B C901            	  2026:   cmp #1
00:907D D007            	  2027:   bne editor_poke_not_first
                        	  2028: ;
                        	  2029: ;  here for first number - must be in range 0x0000 to 0xffff
                        	  2030: ;
00:907F A596            	  2031:   lda token_value+2
00:9081 F0DA            	  2032:   beq editor_poke_loop
00:9083 4CFA85          	  2033:   jmp editor_line_number_too_big
                        	  2034: editor_poke_not_first:
                        	  2035: ;
                        	  2036: ;  here for subsequent numbers - must be in range 0x00 to 0xff
                        	  2037: ;
00:9086 A595            	  2038:   lda token_value+1
00:9088 0596            	  2039:   ora token_value+2
00:908A F0D1            	  2040:   beq editor_poke_loop
00:908C 4CFA85          	  2041:   jmp editor_line_number_too_big
                        	  2042: 
                        	  2043: ;
                        	  2044: ;  must have at least two numbers
                        	  2045: ;
                        	  2046: editor_poke_got_all_numbers:
00:908F A5B9            	  2047:   lda find_count
00:9091 C902            	  2048:   cmp #2
00:9093 B00A            	  2049:   bcs editor_poke_got_enough
00:9095 A92B            	  2050:   lda #<editor_poke_message
00:9097 A290            	  2051:   ldx #>editor_poke_message
00:9099 202682          	  2052:   jsr print
00:909C 4C7282          	  2053:   jmp main_prompt
                        	  2054: 
                        	  2055: editor_poke_got_enough:
                        	  2056: ;
                        	  2057: ;  reset for get_token to do its stuff again
                        	  2058: ;
00:909F A59E            	  2059:   lda from_line
00:90A1 858E            	  2060:   sta token_start
00:90A3 A59F            	  2061:   lda from_line+1
00:90A5 858F            	  2062:   sta token_start+1
                        	  2063: ;
                        	  2064: ;  get address again - we know it is valid since we checked above
                        	  2065: ;
00:90A7 208FCC          	  2066:   jsr get_token
                        	  2067: ;
                        	  2068: ;  where to put stuff
                        	  2069: ;
00:90AA A594            	  2070:   lda token_value
00:90AC 859E            	  2071:   sta from_line
00:90AE A595            	  2072:   lda token_value+1
00:90B0 859F            	  2073:   sta from_line+1
                        	  2074: 
                        	  2075: editor_poking_loop:
00:90B2 208FCC          	  2076:   jsr get_token
00:90B5 D003            	  2077:   bne editor_poke_another
00:90B7 4C9B8E          	  2078:   jmp editor_done_message
                        	  2079: 
                        	  2080: editor_poke_another:
00:90BA A000            	  2081:   ldy #0
00:90BC A594            	  2082:   lda token_value
00:90BE 919E            	  2083:   sta (from_line),y
                        	  2084: ;
                        	  2085: ;  check change was successful - if not, probably trying to change ROM
                        	  2086: ;
00:90C0 D19E            	  2087:   cmp (from_line),y
00:90C2 D029            	  2088:   bne editor_poke_failed
00:90C4 E69E            	  2089:   inc from_line
00:90C6 D0EA            	  2090:   bne editor_poking_loop
00:90C8 E69F            	  2091:   inc from_line+1
00:90CA 80E6            	  2092:   bra editor_poking_loop
                        	  2093: 
00:90CC 4661696C65642074	  2094: editor_poke_failed_message asciiz "Failed to change address $"
00:90D4 6F206368616E6765
00:90DC 2061646472657373
00:90E4 2024
00:90E6 00
00:90E7 20746F2024      	  2095: editor_poke_to_message     asciiz " to $"
00:90EC 00
                        	  2096: 
                        	  2097: editor_poke_failed:
00:90ED A9CC            	  2098:   lda #<editor_poke_failed_message
00:90EF A290            	  2099:   ldx #>editor_poke_failed_message
00:90F1 202682          	  2100:   jsr print
00:90F4 A59F            	  2101:   lda from_line+1
00:90F6 208195          	  2102:   jsr PRBYTE
00:90F9 A59E            	  2103:   lda from_line
00:90FB 208195          	  2104:   jsr PRBYTE
00:90FE A9E7            	  2105:   lda #<editor_poke_to_message
00:9100 A290            	  2106:   ldx #>editor_poke_to_message
00:9102 202682          	  2107:   jsr print
00:9105 A594            	  2108:   lda token_value
00:9107 208195          	  2109:   jsr PRBYTE
00:910A 200C95          	  2110:   jsr CROUT
00:910D 4C7282          	  2111:   jmp main_prompt
                        	  2112: 
                        	  2113: ;--------------------------------------------
                        	  2114: ;  editor_jsr - jump to subroutine
                        	  2115: ;--------------------------------------------
                        	  2116: editor_jsr:
00:9110 208FCC          	  2117:   jsr get_token
00:9113 C94E            	  2118:   cmp #TOKEN_NUMBER
00:9115 F003            	  2119:   beq editor_jsr_got_number
00:9117 4C5885          	  2120:   jmp editor_bad_number
                        	  2121: ;
                        	  2122: ;  check in range 0x0000 to 0xFFFF
                        	  2123: ;
                        	  2124: editor_jsr_got_number:
00:911A A596            	  2125:   lda token_value+2
00:911C F003            	  2126:   beq editor_jsr_number_in_range
00:911E 4CFA85          	  2127:   jmp editor_line_number_too_big
                        	  2128: 
                        	  2129: editor_jsr_number_in_range:
00:9121 204086          	  2130:   jsr editor_check_no_more
00:9124 A513            	  2131:   lda  call_p      ; status register
00:9126 48              	  2132:   pha
00:9127 A510            	  2133:   lda  call_a      ; A register
00:9129 A611            	  2134:   ldx  call_x      ; X register
00:912B A412            	  2135:   ldy  call_y      ; Y register
00:912D 28              	  2136:   plp              ; get status register back
00:912E 203E91          	  2137:   jsr  editor_jsr_got_number_execute  ; call the subroutine
00:9131 08              	  2138:   php              ; save the status register
00:9132 8510            	  2139:   sta  call_a      ; store the A/X/Y register
00:9134 8611            	  2140:   stx  call_x
00:9136 8412            	  2141:   sty  call_y
00:9138 68              	  2142:   pla              ; get status register back
00:9139 8513            	  2143:   sta  call_p      ; save it
00:913B 4C7282          	  2144:   jmp main_prompt
                        	  2145: 
00:913E 6C9400          	  2146: editor_jsr_got_number_execute  jmp  (token_value)
                        	  2147: 
                        	  2148: 
                        	  2149: ;--------------------------------------------
                        	  2150: ;  editor_jmp - jump to address
                        	  2151: ;--------------------------------------------
                        	  2152: editor_jmp:
00:9141 208FCC          	  2153:   jsr get_token
00:9144 C94E            	  2154:   cmp #TOKEN_NUMBER
00:9146 F003            	  2155:   beq editor_jmp_got_number
00:9148 4C5885          	  2156:   jmp editor_bad_number
                        	  2157: ;
                        	  2158: ;  check in range 0x0000 to 0xFFFF
                        	  2159: ;
                        	  2160: editor_jmp_got_number:
00:914B A596            	  2161:   lda token_value+2
00:914D F003            	  2162:   beq editor_jmp_number_in_range
00:914F 4CFA85          	  2163:   jmp editor_line_number_too_big
                        	  2164: 
                        	  2165: editor_jmp_number_in_range:
00:9152 204086          	  2166:   jsr editor_check_no_more
00:9155 A513            	  2167:   lda  call_p      ; status register
00:9157 48              	  2168:   pha
00:9158 A510            	  2169:   lda  call_a      ; A register
00:915A A611            	  2170:   ldx  call_x      ; X register
00:915C A412            	  2171:   ldy  call_y      ; Y register
00:915E 28              	  2172:   plp              ; get status register back
00:915F 6C9400          	  2173:   jmp  (token_value)
                        	  2174: 
                        	  2175: ;--------------------------------------------
                        	  2176: ;  editor_library - list library symbols
                        	  2177: ;--------------------------------------------
                        	  2178: editor_library:
00:9162 208FCC          	  2179:   jsr get_token
00:9165 F01E            	  2180:   beq editor_library_no_search
00:9167 C949            	  2181:   cmp #TOKEN_IDENTIFIER
00:9169 F003            	  2182:   beq editor_library_search
00:916B 4C5286          	  2183:   jmp editor_check_no_more_failed
                        	  2184: 
                        	  2185: editor_library_search:
00:916E 204086          	  2186:   jsr editor_check_no_more
                        	  2187: ;
                        	  2188: ;  put a null after the end of the search string
                        	  2189: ;
00:9171 A492            	  2190:   ldy token_length
00:9173 A900            	  2191:   lda #0
00:9175 9190            	  2192:   sta (token_address),Y
                        	  2193: ;
                        	  2194: ;  force match string to lower-case
                        	  2195: ;
00:9177 A000            	  2196:   ldy #0
                        	  2197: editor_library_make_lower_loop:
00:9179 B190            	  2198:   lda (token_address),Y
00:917B F008            	  2199:   beq editor_library_no_search
00:917D 20B392          	  2200:   jsr MAKE_LOWER
00:9180 9190            	  2201:   sta (token_address),Y
00:9182 C8              	  2202:   iny
00:9183 D0F4            	  2203:   bne editor_library_make_lower_loop
                        	  2204: 
                        	  2205: editor_library_no_search:
00:9185 A9B1            	  2206:   lda #<assembler_library_functions_table
00:9187 8500            	  2207:   sta REG
00:9189 A9A8            	  2208:   lda #>assembler_library_functions_table
00:918B 8501            	  2209:   sta REG+1
                        	  2210: editor_library_loop:
00:918D A000            	  2211:   ldy #0
00:918F B100            	  2212:   lda (REG),Y
00:9191 F058            	  2213:   beq editor_library_done   ; end of names
                        	  2214: 
                        	  2215: ;
                        	  2216: ;  filter out unwanted names
                        	  2217: ;
                        	  2218: 
00:9193 A593            	  2219:   lda token_type
00:9195 C949            	  2220:   cmp #TOKEN_IDENTIFIER
00:9197 D018            	  2221:   bne editor_library_name_loop    ; no filter
00:9199 A000            	  2222:   ldy #0
                        	  2223: editor_library_filter_loop:
00:919B B190            	  2224:   lda (token_address),Y
00:919D F010            	  2225:   beq edit_library_continue  ; end of search string, must have matched
00:919F D100            	  2226:   cmp (REG),y
00:91A1 D003            	  2227:   bne editor_library_filter_reject  ; doesn't match, therefore discard it
00:91A3 C8              	  2228:   iny
00:91A4 80F5            	  2229:   bra editor_library_filter_loop
                        	  2230: 
                        	  2231: editor_library_filter_reject:
00:91A6 A000            	  2232:   ldy #0
                        	  2233: editor_library_filter_reject_loop:
00:91A8 C8              	  2234:   iny
00:91A9 B100            	  2235:   lda (REG),Y
00:91AB D0FB            	  2236:   bne editor_library_filter_reject_loop
00:91AD 802B            	  2237:   bra editor_library_name_onto_next
                        	  2238: 
                        	  2239: edit_library_continue:
00:91AF A000            	  2240:   ldy #0
                        	  2241: ;
                        	  2242: ;  find name length
                        	  2243: ;
                        	  2244: editor_library_name_loop
00:91B1 C8              	  2245:   iny
00:91B2 E692            	  2246:   inc token_length
00:91B4 B100            	  2247:   lda (REG),Y
00:91B6 D0F9            	  2248:   bne editor_library_name_loop
                        	  2249: 
00:91B8 C8              	  2250:   iny             ; get next byte
00:91B9 B100            	  2251:   lda (REG),Y     ; get function address low-byte
00:91BB 48              	  2252:   pha
00:91BC C8              	  2253:   iny             ; get next byte
00:91BD A924            	  2254:   lda #'$'
00:91BF 209A96          	  2255:   jsr COUT
00:91C2 B100            	  2256:   lda (REG),Y     ; get function address high-byte
00:91C4 208195          	  2257:   jsr PRBYTE      ; show high-order address byte
00:91C7 68              	  2258:   pla
00:91C8 208195          	  2259:   jsr PRBYTE      ; show high-order address byte
00:91CB 209795          	  2260:   jsr PUTSP
00:91CE A500            	  2261:   lda REG
00:91D0 A601            	  2262:   ldx REG+1
00:91D2 88              	  2263:   dey             ; subtract 2, leaving the length of the name in Y
00:91D3 88              	  2264:   dey
00:91D4 209B95          	  2265:   jsr PT
00:91D7 200C95          	  2266:   jsr CROUT
                        	  2267: 
                        	  2268: editor_library_name_onto_next:
00:91DA C8              	  2269:   iny         ; add 2 to get past the address
00:91DB C8              	  2270:   iny
00:91DC C8              	  2271:   iny         ; get past that last 0x00  byte
00:91DD 98              	  2272:   tya         ; move REG onto next entry
00:91DE 18              	  2273:   clc
00:91DF 6500            	  2274:   adc REG
00:91E1 8500            	  2275:   sta REG
00:91E3 A900            	  2276:   lda #0
00:91E5 6501            	  2277:   adc REG+1
00:91E7 8501            	  2278:   sta REG+1
00:91E9 80A2            	  2279:   bra editor_library_loop
                        	  2280: 
                        	  2281: editor_library_done:
00:91EB 4C7282          	  2282:   jmp main_prompt
                        	  2283: 
                        	  2284: 
                        	  2285: ;16-bit number comparison...
                        	  2286: ;
                        	  2287: ;         lda #>x               ; MSB of 1st number
                        	  2288: ;         cmp #>y               ; MSB of 2nd number
                        	  2289: ;         bcc islower           ; X < Y
                        	  2290: ;
                        	  2291: ;         bne ishigher          ; X > Y
                        	  2292: ;
                        	  2293: ;         lda #<x               ; LSB of 1st number
                        	  2294: ;         cmp #<y               ; LSB of 2nd number
                        	  2295: ;         bcc islower           ; X < Y
                        	  2296: ;
                        	  2297: ;         beq issame            ; X = Y
                        	  2298: ;
                        	  2299: ;         bne ishigher          ; X > Y
                        	  2300: ;
                        	  2301: ;
                        	  2302: 

Source: "gpascal.asm"
                        	   179:   .include "utilities.inc"

Source: "utilities.inc"
                        	     1: ;
                        	     2: ;  function to look up a handler for a word (eg. assembler directive)
                        	     3: ;
                        	     4: ;  word in SRCE
                        	     5: ;
                        	     6: ;  table of words/handlers in DEST
                        	     7: ;
                        	     8: ;  length of word in A
                        	     9: ;
                        	    10: ;  see makeHandler for making the table
                        	    11: ;
                        	    12: ;  Basically:
                        	    13: ;    asciiz "foo"
                        	    14: ;    word   foo_handler
                        	    15: ;
                        	    16: ;  In other words:
                        	    17: ;    makeHandler "foo",foo_handler
                        	    18: ;
                        	    19: ;  Returns with carry set if no match, otherwise calls the handler which should clear carry
                        	    20: ;
                        	    21: 
                        	    22: handlerLookup:
00:91EE 8598            	    23:   sta token_work    ; save length
                        	    24: 
                        	    25: ;
                        	    26: ;  find the length of the word
                        	    27: ;
                        	    28: handler_loop:
00:91F0 A000            	    29:   ldy #0
00:91F2 B103            	    30:   lda (DEST),y
00:91F4 F036            	    31:   beq handlers_done
                        	    32: handler_find_length:
00:91F6 B103            	    33:   lda (DEST),y
00:91F8 F005            	    34:   beq handler_found_length
00:91FA C8              	    35:   iny
00:91FB F02F            	    36:   beq handlers_done   ; sanity clause
00:91FD 80F7            	    37:   bra handler_find_length
                        	    38: handler_found_length:
                        	    39: 
                        	    40: ;  lda #'i'
                        	    41: ;  jsr ass_debug_point
                        	    42: 
00:91FF C498            	    43:   cpy token_work
00:9201 F010            	    44:   beq handler_same_length
                        	    45: ;
                        	    46: ;  not the same length, or no match on the string
                        	    47: ;
                        	    48: handler_next:
00:9203 98              	    49:   tya
00:9204 18              	    50:   clc
00:9205 6903            	    51:   adc #3  ; skip the 0x00 and the execution address
00:9207 6503            	    52:   adc DEST
00:9209 8503            	    53:   sta DEST
00:920B A504            	    54:   lda DEST+1
00:920D 6900            	    55:   adc #0
00:920F 8504            	    56:   sta DEST+1
00:9211 80DD            	    57:   bra handler_loop
                        	    58: 
                        	    59: handler_same_length:
                        	    60: 
                        	    61: ;  lda #'j'
                        	    62: ;  jsr ass_debug_point
                        	    63: 
00:9213 5A              	    64:   phy  ; save the length
00:9214 201195          	    65:   jsr COMSTL
00:9217 F003            	    66:   beq  handler_found_directive
00:9219 7A              	    67:   ply
00:921A 80E7            	    68:   bra handler_next
                        	    69: handler_found_directive:
00:921C 7A              	    70:   ply  ; get the length back
00:921D C8              	    71:   iny  ; skip past the 0x00 byte
00:921E B103            	    72:   lda (DEST),y
00:9220 8599            	    73:   sta token_work+1
00:9222 C8              	    74:   iny
00:9223 B103            	    75:   lda (DEST),y
00:9225 859A            	    76:   sta token_work+2
00:9227 202E92          	    77:   jsr call_handler
00:922A 18              	    78:   clc
00:922B 60              	    79:   rts
                        	    80: 
                        	    81: handlers_done:
                        	    82: ;  lda #'h'
                        	    83: ;  jsr ass_debug_point
00:922C 38              	    84:   sec     ; error flag
00:922D 60              	    85:   rts
                        	    86: 
                        	    87: call_handler:
                        	    88: ;  lda #'g'
                        	    89: ;  jsr ass_debug_point
                        	    90: 
00:922E 6C9900          	    91:   jmp (token_work+1)   ; do handler - it will RTS for us
                        	    92: 
                        	    93: 
                        	    94: ;
                        	    95: ;  function to look up a handler for a word on a partial match (eg. editor command)
                        	    96: ;
                        	    97: ;  word in SRCE
                        	    98: ;
                        	    99: ;  table of words/handlers in DEST - in UPPER CASE
                        	   100: ;
                        	   101: ;  length of word in A
                        	   102: ;
                        	   103: ;  see makeHandler for making the table
                        	   104: ;
                        	   105: ;  Basically:
                        	   106: ;    asciiz "FOO"
                        	   107: ;    word   foo_handler
                        	   108: ;
                        	   109: ;  In other words:
                        	   110: ;    makeHandler "FOO",foo_handler
                        	   111: ;
                        	   112: ;  Returns if no match, otherwise jumps to the handler and thus doesn't return
                        	   113: ;
                        	   114: 
                        	   115: partial_handler_Lookup:
00:9231 8598            	   116:   sta token_work    ; save length
                        	   117: ;
                        	   118: ;  here for a new table item
                        	   119: ;
                        	   120: partial_handler_next_item:
00:9233 A000            	   121:   ldy #0
00:9235 B103            	   122:   lda (DEST),y
00:9237 F03C            	   123:   beq partial_handler_done
00:9239 A698            	   124:   ldx token_work        ; source length
                        	   125: partial_handler_next_loop:
                        	   126: ;
                        	   127: ;  ensure the nth character matches until the source runs out
                        	   128: ;
00:923B B100            	   129:   lda (SRCE),y
00:923D 20A892          	   130:   jsr MAKE_UPPER
00:9240 D103            	   131:   cmp (DEST),y
00:9242 D006            	   132:   bne partial_handler_next
00:9244 C8              	   133:   iny
00:9245 CA              	   134:   dex     ; one less count
00:9246 F019            	   135:   beq partial_handler_found_directive ; source has finished and we found the directive
00:9248 80F1            	   136:   bra partial_handler_next_loop       ; try matching the next one
                        	   137: ;
                        	   138: ;  no match on the string - advance Y to the end of the destination string
                        	   139: ;
                        	   140: partial_handler_next:
00:924A B103            	   141:   lda (DEST),y
00:924C F003            	   142:   beq partial_handler_next_found_item_length
00:924E C8              	   143:   iny
00:924F 80F9            	   144:   bra partial_handler_next
                        	   145: partial_handler_next_found_item_length:
00:9251 98              	   146:   tya     ; length of the word in the table
00:9252 18              	   147:   clc
00:9253 6903            	   148:   adc #3  ; skip the 0x00 and the execution address
00:9255 6503            	   149:   adc DEST
00:9257 8503            	   150:   sta DEST
00:9259 A504            	   151:   lda DEST+1
00:925B 6900            	   152:   adc #0
00:925D 8504            	   153:   sta DEST+1
00:925F 80D2            	   154:   bra partial_handler_next_item
                        	   155: 
                        	   156: partial_handler_found_directive:
00:9261 B103            	   157:   lda (DEST),y
00:9263 F003            	   158:   beq partial_handler_skipped_string
00:9265 C8              	   159:   iny
00:9266 80F9            	   160:   bra partial_handler_found_directive
                        	   161: partial_handler_skipped_string:
00:9268 C8              	   162:   iny  ; skip past the 0x00 byte
00:9269 B103            	   163:   lda (DEST),y
00:926B 8599            	   164:   sta token_work+1
00:926D C8              	   165:   iny
00:926E B103            	   166:   lda (DEST),y
00:9270 859A            	   167:   sta token_work+2
00:9272 6C9900          	   168:   jmp (token_work+1)   ; do partial_partial_handler_ - it will RTS for us
                        	   169: 
                        	   170: partial_handler_done:
00:9275 60              	   171:   rts
                        	   172: 
                        	   173: ;***********************************************
                        	   174: ; JUMP ON TOKEN
                        	   175: ; X/Y = START OF TABLE
                        	   176: ; END OF TABLE IS A NULL
                        	   177: ; A = TOKEN
                        	   178: ;***********************************************
                        	   179: TKNJMP   =  *
00:9276 8600            	   180:          stx  REG     ; save table address
00:9278 8401            	   181:          sty  REG+1
                        	   182: 
00:927A 20A892          	   183:          jsr MAKE_UPPER
00:927D AA              	   184:          tax          ; save the token
                        	   185: JMP1     =  *
00:927E A000            	   186:          ldy  #0
00:9280 B100            	   187:          lda  (REG),Y
00:9282 D002            	   188:          bne  JMP2
                        	   189: ; failed to find the token
00:9284 8A              	   190:          txa          ; retore the token
00:9285 60              	   191:          rts
                        	   192: JMP2     =  *
00:9286 8A              	   193:          txa          ; get token back
00:9287 D100            	   194:          cmp  (REG),Y
00:9289 D010            	   195:          bne  JMP3    ; branch if not found
00:928B 68              	   196:          pla
00:928C 68              	   197:          pla          ; remove return address for TKNJMP call
00:928D C8              	   198:          iny          ; move Y on to routine address
00:928E B100            	   199:          lda  (REG),Y ; get low order byte of routine
00:9290 8503            	   200:          sta  REG2
00:9292 C8              	   201:          iny          ; next byte
00:9293 B100            	   202:          lda  (REG),Y ; get high order byte
00:9295 8504            	   203:          sta  REG2+1
00:9297 8A              	   204:          txa          ; get token back
00:9298 6C0300          	   205:          jmp  (REG2)  ; go to routine
                        	   206: JMP3     =  *
00:929B A500            	   207:          lda  REG     ; skip this token sequence
00:929D 18              	   208:          clc
00:929E 6903            	   209:          adc  #3
00:92A0 8500            	   210:          sta  REG
00:92A2 90DA            	   211:          bcc  JMP1
00:92A4 E601            	   212:          inc  REG+1
00:92A6 80D6            	   213:          bra  JMP1    ; try again
                        	   214: 
                        	   215: ;
                        	   216: 
                        	   217: 
                        	   218: ;***********************************************
                        	   219: ;
                        	   220: ; Case conversion
                        	   221: ;
                        	   222: ;***********************************************
                        	   223: 
                        	   224: 
                        	   225: MAKE_UPPER = *
00:92A8 C97B            	   226:          CMP  #('z'+1)
00:92AA B006            	   227:          BCS  MAKE_UPPER_DONE
00:92AC C961            	   228:          CMP  #'a'
00:92AE 9002            	   229:          BCC  MAKE_UPPER_DONE
00:92B0 E920            	   230:          SBC  #$20  ; make upper-case - we want carry set so there is no borrow
                        	   231: MAKE_UPPER_DONE = *
00:92B2 60              	   232:          RTS
                        	   233: 
                        	   234: MAKE_LOWER = *
00:92B3 C941            	   235:          CMP  #'A'
00:92B5 9006            	   236:          BCC  MAKE_LOWER_DONE
00:92B7 C95B            	   237:          CMP  #('Z'+1)
00:92B9 B002            	   238:          BCS  MAKE_LOWER_DONE
00:92BB 6920            	   239:          ADC  #$20  ; make upper-case - we want carry clear so there is no carry
                        	   240: MAKE_LOWER_DONE = *
00:92BD 60              	   241:          RTS
                        	   242: 
                        	   243: 
                        	   244: ;
                        	   245: ;  generate the next random number
                        	   246: ;
                        	   247: gen_random:
00:92BE 0609            	   248:     asl random
00:92C0 260A            	   249:     rol random+1
00:92C2 260B            	   250:     rol random+2
00:92C4 260C            	   251:     rol random+3
00:92C6 9018            	   252:     bcc gen_random1
00:92C8 A509            	   253:     lda random
00:92CA 49B7            	   254:     eor #$B7
00:92CC 8509            	   255:     sta random
00:92CE A50A            	   256:     lda random+1
00:92D0 491D            	   257:     eor #$1D
00:92D2 850A            	   258:     sta random+1
00:92D4 A50B            	   259:     lda random+2
00:92D6 49C1            	   260:     eor #$C1
00:92D8 850B            	   261:     sta random+2
00:92DA A50C            	   262:     lda random+3
00:92DC 4904            	   263:     eor #$04
00:92DE 850C            	   264:     sta random+3
                        	   265: gen_random1:
00:92E0 60              	   266:     rts
                        	   267: 
                        	   268: 
                        	   269: 
                        	   270: ;
                        	   271: ;  From: http://www.6502.org/source/integers/crc-more.html
                        	   272: ;
                        	   273: ;   jacksum  -a crc:16,1021,FFFF,false,false,0 -X SOME_FILE
                        	   274: ;
                        	   275: ;   https://jacksum.net/en/index.html
                        	   276: ;
                        	   277: ;   With a starting CRC of $FFFF, the binary string $01 $02 $03 $04 should evaluate to $89C3.
                        	   278: ;
                        	   279: ;   Start at crc_addr, for crc_num bytes
                        	   280: ;
                        	   281: crc16 = *
                        	   282: ;
                        	   283: ;  initialise CRC
                        	   284: ;
00:92E1 A9FF            	   285:   lda #$FF
00:92E3 8506            	   286:   sta crc_val
00:92E5 8507            	   287:   sta crc_val+1
00:92E7 A503            	   288:   lda crc_num
00:92E9 0504            	   289:   ora crc_num+1
00:92EB F01B            	   290:   beq crc_done
                        	   291: 
                        	   292: ;
                        	   293: ;  here for each byte
                        	   294: ;
                        	   295: crc16_loop  = *
00:92ED A000            	   296:   ldy #0
00:92EF B100            	   297:   lda (crc_addr),y  ; get next byte
00:92F1 200993          	   298:   jsr crc_byte
                        	   299:   ;
                        	   300:   ;  onto next address
                        	   301:   ;
00:92F4 E600            	   302:   inc crc_addr
00:92F6 D002            	   303:   bne crc16_next
00:92F8 E601            	   304:   inc crc_addr+1       ; Step to next byte
                        	   305: crc16_next:
                        	   306:   ;
                        	   307:   ; now do a 16-bit decrement
                        	   308:   ;
00:92FA A503            	   309:   LDA crc_num
00:92FC D002            	   310:   BNE crc16_skip    ; decrement the high-order byte if we are about to wrap
00:92FE C604            	   311:   DEC crc_num+1
                        	   312: crc16_skip:
00:9300 C603            	   313:   DEC crc_num       ; decrement the low-order byte
00:9302 D0E9            	   314:   BNE crc16_loop    ; not zero, keep going
00:9304 A504            	   315:   LDA crc_num+1     ; are we zero here too?
00:9306 D0E5            	   316:   BNE crc16_loop    ; not yet
                        	   317: 
                        	   318: crc_done:
00:9308 60              	   319:   rts
                        	   320: 
                        	   321: ;
                        	   322: ;  do a CRC of one byte (in A) updating crc_val
                        	   323: ;
                        	   324: crc_byte = *
00:9309 4507            	   325:   eor crc_val+1     ; A contained the data
00:930B 8507            	   326:   sta crc_val+1     ; XOR it into high byte
00:930D 4A              	   327:   lsr               ; right shift A 4 bits
00:930E 4A              	   328:   lsr               ; to make top of x^12 term
00:930F 4A              	   329:   lsr               ; ($1...)
00:9310 4A              	   330:   lsr
00:9311 AA              	   331:   tax               ; save it
00:9312 0A              	   332:   asl               ; then make top of x^5 term
00:9313 4506            	   333:   eor crc_val       ; and XOR that with low byte
00:9315 8506            	   334:   sta crc_val       ; and save
00:9317 8A              	   335:   txa               ; restore partial term
00:9318 4507            	   336:   eor crc_val+1     ; and update high byte
00:931A 8507            	   337:   sta crc_val+1     ; and save
00:931C 0A              	   338:   asl               ; left shift three
00:931D 0A              	   339:   asl               ; the rest of the terms
00:931E 0A              	   340:   asl               ; have feedback from x^12
00:931F AA              	   341:   tax               ; save bottom of x^12
00:9320 0A              	   342:   asl               ; left shift two more
00:9321 0A              	   343:   asl               ; watch the carry flag
00:9322 4507            	   344:   eor crc_val+1     ; bottom of x^5 ($..2.)
00:9324 A8              	   345:   tay               ; save high byte
00:9325 8A              	   346:   txa               ; fetch temp value
00:9326 2A              	   347:   rol               ; bottom of x^12, middle of x^5!
00:9327 4506            	   348:   eor crc_val       ; finally update low byte
00:9329 8507            	   349:   sta crc_val+1     ; then swap high and low bytes
00:932B 8406            	   350:   sty crc_val
00:932D 60              	   351:   rts
                        	   352: 
                        	   353: 
                        	   354: crc_helper = *
00:932E 5A              	   355:   phy
00:932F DA              	   356:   phx
00:9330 200993          	   357:   jsr crc_byte
00:9333 E603            	   358:   inc crc_num
00:9335 D002            	   359:   bne crc_helper1
00:9337 E604            	   360:   inc crc_num+1
                        	   361: crc_helper1:
00:9339 FA              	   362:   plx
00:933A 7A              	   363:   ply
00:933B 60              	   364:   rts
                        	   365: 
00:933C 536F757263652043	   366: crc_message asciiz "Source CRC       $"               ; source CRC
00:9344 5243202020202020
00:934C 2024
00:934E 00
00:934F 536F75726365206C	   367: source_length_message asciiz "Source length: "    ; source length
00:9357 656E6774683A20
00:935E 00
00:935F 2062797465730A  	   368: bytes_message asciiz " bytes\n"
00:9366 00
                        	   369: 
                        	   370: crc_source = *
00:9367 20B98C          	   371:   jsr find_source_end
                        	   372: 
                        	   373: ;
                        	   374: ;  move existing source to end of RAM
                        	   375: ;
00:936A 18              	   376:   clc             ; don't count the final 0x00 byte
00:936B A523            	   377:   lda PCODE
00:936D E900            	   378:   sbc #<TEXT_START
00:936F 8503            	   379:   sta crc_num
00:9371 A524            	   380:   lda PCODE+1
00:9373 E903            	   381:   sbc #>TEXT_START
00:9375 8504            	   382:   sta crc_num+1
                        	   383: ;
                        	   384: ;  Show the length of the source
                        	   385: ;
00:9377 A94F            	   386:   lda #<source_length_message
00:9379 A293            	   387:   ldx #>source_length_message
00:937B 202682          	   388:   jsr print
00:937E A503            	   389:   lda crc_num
00:9380 8500            	   390:   sta REG
00:9382 A504            	   391:   lda crc_num+1
00:9384 8501            	   392:   sta REG+1
00:9386 6402            	   393:   stz REGB
00:9388 203694          	   394:   jsr display_in_decimal
00:938B A95F            	   395:   lda #<bytes_message
00:938D A293            	   396:   ldx #>bytes_message
00:938F 202682          	   397:   jsr print
                        	   398: 
                        	   399: ;
                        	   400: ;  now the CRC
                        	   401: ;
00:9392 A900            	   402:   lda #<TEXT_START
00:9394 8500            	   403:   sta crc_addr
00:9396 A903            	   404:   lda #>TEXT_START
00:9398 8501            	   405:   sta crc_addr+1
00:939A 20E192          	   406:   jsr crc16
00:939D A93C            	   407:   lda  #<crc_message            ;  source CRC
00:939F A293            	   408:   ldx  #>crc_message            ;
00:93A1 202682          	   409:   jsr  print
00:93A4 A507            	   410:   lda crc_val+1
00:93A6 208195          	   411:   jsr PRBYTE
00:93A9 A506            	   412:   lda crc_val
00:93AB 203696          	   413:   jsr PRBYTECR
00:93AE 60              	   414:   rts
                        	   415: 
                        	   416: 
                        	   417: ;
                        	   418: ;  delays for roughly 1 ms - changes no registers
                        	   419: ;
                        	   420: delay_1ms = *
00:93AF DA              	   421:          phx
00:93B0 A26C            	   422:          ldx #108
                        	   423: delay_1ms_loop:
00:93B2 EA              	   424:          nop
00:93B3 EA              	   425:          nop
00:93B4 CA              	   426:          dex
00:93B5 D0FB            	   427:          bne delay_1ms_loop
00:93B7 FA              	   428:          plx
00:93B8 60              	   429:          rts
                        	   430: 
                        	   431: ;
                        	   432: ; delay for YYXX ms (Y = high-order byte, X = lo-order byte)
                        	   433: ;  maximum delay 0x7FFF, that is 32767 ms
                        	   434: ;  Changes X and Y
                        	   435: ;
                        	   436: delay = *
00:93B9 20AF93          	   437:   jsr delay_1ms
00:93BC CA              	   438:   dex
00:93BD D0FA            	   439:   bne delay
00:93BF 88              	   440:   dey
00:93C0 10F7            	   441:   bpl delay
00:93C2 60              	   442:   rts
                        	   443: 
                        	   444: 
                        	   445: ;--------------------------------------------------------------------------
                        	   446: ;
                        	   447: ;  BINARY TO DECIMAL CONVERSION
                        	   448: ;
                        	   449: ;  This works as follows:
                        	   450: ;
                        	   451: ;  1. First the number is checked if it is negative (sign bit set).
                        	   452: ;  2. If so, a "-" is output and the number subtracted from zero to make it positive.
                        	   453: ;  3. Our next step is to set a BCD (binary coded decimal) output area to all zeroes.
                        	   454: ;      In BCD, the number 1234 is actually stored as 0x1234.
                        	   455: ;      With BCD mode turned on in the processor, doing adds results in an early carry
                        	   456: ;      so that numbers add "the decimal way" rather than the binary way.
                        	   457: ;  4. Then we a loop of 24 iterations (one for each bit) which adds the appropriate number from bcd_table
                        	   458: ;      if that bit was set in the original value.
                        	   459: ;  5. The function bcd_unpack is then called to convert the BCD format into ASCII format. It takes each
                        	   460: ;     nibble and adds 0x30 ('0') to it, and saves that in bcd_result.
                        	   461: ;  6. At this stage bcd_result has a 8-digit ASCII number in it.
                        	   462: ;  7. We then skip leading zeroes in bcd_result.
                        	   463: ;  8. Finally the remaining digits in bcd_result are output.
                        	   464: ;
                        	   465: ;
                        	   466: ;   I'm not sure where the idea for this came from. There was no Internet when this was written in 1979
                        	   467: ;   so it is possibly (probably) my own.
                        	   468: ;   My original implementation, although similar, was more complex than this one, which I found at:
                        	   469: ;              http://www.6502.org/source/integers/hex2dec.htm
                        	   470: ;
                        	   471: ;   Other suggestions for binary to decimal conversion I found recently do not employ this method. One
                        	   472: ;   technique (as described by Ben Eater here: https://www.youtube.com/watch?v=v3-a-zqKfgA ) is to
                        	   473: ;   repeatedly divide by 10 and use the remainder as the digit. This has to be done until the result of
                        	   474: ;   the division is zero. Dividing a 3-byte number by 10 on an 8-bit machine is not particularly fast,
                        	   475: ;   as it involves an inner loop of 24 iterations (one for each bit) and this would have to be done for
                        	   476: ;   each digit, so the number of loops of 24 iterations would increase for each digit. Therefore an
                        	   477: ;   8-digit number (like 80000000) would take 144 iterations in the divide loop. Then the digits have to
                        	   478: ;   be reversed because the remainder gives you the low-order decimal digit first.
                        	   479: ;
                        	   480: ;   Another technique is the "Double dabble" routine.
                        	   481: ;
                        	   482: ;     https://en.wikipedia.org/wiki/Double_dabble
                        	   483: ;
                        	   484: ;   The method below seems fairly efficient, as the inner loop only does anything substantial if a
                        	   485: ;     1-bit is detected. Thus large numbers can be produced quite efficiently, however it would be a
                        	   486: ;     bit slower if the input number had a lot of 1-bits set.
                        	   487: ;
                        	   488: ;   Considering that this is only used when outputting to serial, itself a slow process, speed is not
                        	   489: ;   really the issue here.
                        	   490: ;
                        	   491: ;   - Nick Gammon
                        	   492: ;
                        	   493: ;
                        	   494: ;--------------------------------------------------------------------------
                        	   495: ;
                        	   496: ; Converts BCD to ASCII
                        	   497: ;
                        	   498: bcd_unpack:
00:93C3 48              	   499:   pha  ; save the number for later
                        	   500: ;
                        	   501: ;  shift right 4 bits
                        	   502: ;
00:93C4 4A              	   503:   lsr A
00:93C5 4A              	   504:   lsr A
00:93C6 4A              	   505:   lsr A
00:93C7 4A              	   506:   lsr A
00:93C8 0930            	   507:   ora #'0'          ; make printable
00:93CA 9560            	   508:   sta bcd_result,X  ; save in bcd_result
00:93CC E8              	   509:   inx
00:93CD 68              	   510:   pla               ; get the original character back
00:93CE 290F            	   511:   and #$0F          ; take low-order bits and make printable
00:93D0 0930            	   512:   ora #'0'
00:93D2 9560            	   513:   sta bcd_result,X  ; save in bcd_result
00:93D4 E8              	   514:   inx
00:93D5 60              	   515:   rts               ; done!
                        	   516: 
                        	   517: ;
                        	   518: ;
                        	   519: ; Table for adding into the BCD result.
                        	   520: ;
                        	   521: bcd_table  =  *
00:93D6 00              	   522:   dfb $00,$00,$00,$01   ; 0000001
00:93D7 00
00:93D8 00
00:93D9 01
00:93DA 00              	   523:   dfb $00,$00,$00,$02   ; 0000002
00:93DB 00
00:93DC 00
00:93DD 02
00:93DE 00              	   524:   dfb $00,$00,$00,$04   ; 0000004
00:93DF 00
00:93E0 00
00:93E1 04
00:93E2 00              	   525:   dfb $00,$00,$00,$08   ; 0000008
00:93E3 00
00:93E4 00
00:93E5 08
00:93E6 00              	   526:   dfb $00,$00,$00,$16   ; 0000016
00:93E7 00
00:93E8 00
00:93E9 16
00:93EA 00              	   527:   dfb $00,$00,$00,$32   ; 0000032
00:93EB 00
00:93EC 00
00:93ED 32
00:93EE 00              	   528:   dfb $00,$00,$00,$64   ; 0000064
00:93EF 00
00:93F0 00
00:93F1 64
00:93F2 00              	   529:   dfb $00,$00,$01,$28   ; 0000128
00:93F3 00
00:93F4 01
00:93F5 28
00:93F6 00              	   530:   dfb $00,$00,$02,$56   ; 0000256
00:93F7 00
00:93F8 02
00:93F9 56
00:93FA 00              	   531:   dfb $00,$00,$05,$12   ; 0000512
00:93FB 00
00:93FC 05
00:93FD 12
00:93FE 00              	   532:   dfb $00,$00,$10,$24   ; 0001024
00:93FF 00
00:9400 10
00:9401 24
00:9402 00              	   533:   dfb $00,$00,$20,$48   ; 0002048
00:9403 00
00:9404 20
00:9405 48
00:9406 00              	   534:   dfb $00,$00,$40,$96   ; 0004096
00:9407 00
00:9408 40
00:9409 96
00:940A 00              	   535:   dfb $00,$00,$81,$92   ; 0008192
00:940B 00
00:940C 81
00:940D 92
00:940E 00              	   536:   dfb $00,$01,$63,$84   ; 0016384
00:940F 01
00:9410 63
00:9411 84
00:9412 00              	   537:   dfb $00,$03,$27,$68   ; 0032768
00:9413 03
00:9414 27
00:9415 68
00:9416 00              	   538:   dfb $00,$06,$55,$36   ; 0065536
00:9417 06
00:9418 55
00:9419 36
00:941A 00              	   539:   dfb $00,$13,$10,$72   ; 0131072
00:941B 13
00:941C 10
00:941D 72
00:941E 00              	   540:   dfb $00,$26,$21,$44   ; 0262144
00:941F 26
00:9420 21
00:9421 44
00:9422 00              	   541:   dfb $00,$52,$42,$88   ; 0524288
00:9423 52
00:9424 42
00:9425 88
00:9426 01              	   542:   dfb $01,$04,$85,$76   ; 1048576
00:9427 04
00:9428 85
00:9429 76
00:942A 02              	   543:   dfb $02,$09,$71,$52   ; 2097152
00:942B 09
00:942C 71
00:942D 52
00:942E 04              	   544:   dfb $04,$19,$43,$04   ; 4194304
00:942F 19
00:9430 43
00:9431 04
00:9432 08              	   545:   dfb $08,$38,$86,$08   ; 8388608
00:9433 38
00:9434 86
00:9435 08
                        	   546: 
                        	   547: ;--------------------------------------------------------------------------
                        	   548: ; display_in_decimal - start here - VALUE will be zero after this is executed
                        	   549: ;--------------------------------------------------------------------------
                        	   550: 
                        	   551: display_in_decimal  =  *
00:9436 A502            	   552:   lda  VALUE+2
00:9438 1008            	   553:   bpl  bcd_positive
                        	   554: ;
                        	   555: ;  if the number is negative, output a minus sign and make it positive
                        	   556: ;
00:943A A92D            	   557:   lda  #'-'
00:943C 209A96          	   558:   jsr  COUT
00:943F 2009AF          	   559:   jsr  exp_unary_minus
                        	   560: ;
                        	   561: ;  number is now positive
                        	   562: ;
                        	   563: bcd_positive:
                        	   564: 
00:9442 205F94          	   565:   jsr binary_to_decimal   ; do the conversion
                        	   566: 
00:9445 A207            	   567:   ldx  #7         ; zero suppress count (always keep the last zero)
00:9447 A000            	   568:   ldy  #0
                        	   569: ;
                        	   570: ;  this is skipping the leading zeroes
                        	   571: ;
                        	   572: bcd_skip_zeroes:
00:9449 B96000          	   573:   lda  bcd_result,Y
00:944C C930            	   574:   cmp  #'0'
00:944E D004            	   575:   bne  bcd_output_digit
00:9450 C8              	   576:   iny
00:9451 CA              	   577:   dex
00:9452 D0F5            	   578:   bne  bcd_skip_zeroes
                        	   579: ;
                        	   580: ;  now we have a non-zero, start outputting them
                        	   581: ;
                        	   582: ;  Y points to how far we are through bcd_result
                        	   583: ;  X is how many digits to go
                        	   584: ;
                        	   585: bcd_output_digit:
00:9454 B96000          	   586:   lda  bcd_result,Y
00:9457 209A96          	   587:   jsr  COUT
00:945A C8              	   588:   iny
00:945B CA              	   589:   dex
00:945C 10F6            	   590:   bpl  bcd_output_digit
                        	   591: ;
                        	   592: ;  done!
                        	   593: ;
00:945E 60              	   594:   rts
                        	   595: 
                        	   596: ;--------------------------------------------------------------------------
                        	   597: ;
                        	   598: ;  Binary to decimal routine: Converts VALUE into bcd_result (8 digits)
                        	   599: ;
                        	   600: ;  See: http://www.6502.org/source/integers/hex2dec.htm
                        	   601: ;
                        	   602: ;  - VALUE will be zero after this is executed
                        	   603: ;
                        	   604: ;--------------------------------------------------------------------------
                        	   605: binary_to_decimal:
00:945F F8              	   606:   sed                 ; decimal mode for adds below
00:9460 645C            	   607:   stz  bcd_work       ; zero our result area (4 bytes = 8 digits)
00:9462 645D            	   608:   stz  bcd_work+1
00:9464 645E            	   609:   stz  bcd_work+2
00:9466 645F            	   610:   stz  bcd_work+3
                        	   611: 
00:9468 A25C            	   612:   ldx  #(4*23)        ; X points to the start of the highest entry
                        	   613: 
                        	   614: binary_to_decimal_loop:
00:946A 0600            	   615:   asl VALUE      ;  shift out high-order bit into Carry
00:946C 2601            	   616:   rol VALUE+1
00:946E 2602            	   617:   rol VALUE+2
00:9470 901D            	   618:   bcc binary_to_decimal_next  ; if carry clear, no add needs to be done
                        	   619: ;
                        	   620: ;  that bit was set, so add the appropriate BCD number from the table (eg. 1, 2, 4, 8, 16 and so on)
                        	   621: ;
00:9472 18              	   622:   clc
00:9473 A55C            	   623:   lda bcd_work
00:9475 7DD993          	   624:   adc bcd_table+3,X
00:9478 855C            	   625:   sta bcd_work
00:947A A55D            	   626:   lda bcd_work+1
00:947C 7DD893          	   627:   adc bcd_table+2,X
00:947F 855D            	   628:   sta bcd_work+1
00:9481 A55E            	   629:   lda bcd_work+2
00:9483 7DD793          	   630:   adc bcd_table+1,X
00:9486 855E            	   631:   sta bcd_work+2
00:9488 A55F            	   632:   lda bcd_work+3
00:948A 7DD693          	   633:   adc bcd_table,X
00:948D 855F            	   634:   sta bcd_work+3
                        	   635: 
                        	   636: binary_to_decimal_next:
00:948F CA              	   637:   dex      ; back to the previous table item
00:9490 CA              	   638:   dex
00:9491 CA              	   639:   dex
00:9492 CA              	   640:   dex
00:9493 10D5            	   641:   bpl binary_to_decimal_loop
00:9495 D8              	   642:   cld     ; decimal mode off
                        	   643: 
                        	   644: 
                        	   645: ;
                        	   646: ;  convert BCD to ASCII - note that UNPACK increments x by two each time
                        	   647: ;    - the results are in bcd_result - an 8-character field
                        	   648: ;
                        	   649: ;  We unpack the high-order bytes first, naturally
                        	   650: ;
00:9496 A200            	   651:   ldx  #0
00:9498 A55F            	   652:   lda  bcd_work+3
00:949A 20C393          	   653:   jsr  bcd_unpack
00:949D A55E            	   654:   lda  bcd_work+2
00:949F 20C393          	   655:   jsr  bcd_unpack
00:94A2 A55D            	   656:   lda  bcd_work+1
00:94A4 20C393          	   657:   jsr  bcd_unpack
00:94A7 A55C            	   658:   lda  bcd_work
00:94A9 20C393          	   659:   jsr  bcd_unpack
00:94AC 60              	   660:   rts
                        	   661: 
00:94AD 4E6F20736F757263	   662: NOSCE    asciiz  'No source file.\n'   ; No source file
00:94B5 652066696C652E0A
00:94BD 00
                        	   663: 
                        	   664: ;***********************************************
                        	   665: ;
                        	   666: ; Initialize a compile or assembly
                        	   667: ;
                        	   668: ;***********************************************
                        	   669: 
                        	   670: 
                        	   671: INIT     =  *
                        	   672: ;
                        	   673: ;  set up symbol table pointer
                        	   674: ;
                        	   675: 
00:94BE A93F            	   676:   lda  #>SYMBOL_TABLE_START
00:94C0 8532            	   677:   sta  ENDSYM+1
00:94C2 8530            	   678:   sta  STARTSYM+1
00:94C4 A9FF            	   679:   lda  #<SYMBOL_TABLE_START
00:94C6 8531            	   680:   sta  ENDSYM
00:94C8 852F            	   681:   sta  STARTSYM
                        	   682: 
                        	   683: INIT_SECOND_PASS:   ; for assembler
                        	   684: 
00:94CA A900            	   685:   lda  #0
00:94CC 851D            	   686:   sta  LIST            ; not listing
00:94CE 8522            	   687:   sta  LEVEL           ; variable level zero
00:94D0 852E            	   688:   sta  DCODE
00:94D2 853F            	   689:   sta  RUNNING         ; not running
00:94D4 8539            	   690:   sta  PRCITM
00:94D6 853A            	   691:   sta  PRCITM+1
00:94D8 8502            	   692:   sta  REGB
00:94DA 8593            	   693:   sta  token_type
00:94DC 64BE            	   694:   stz  system_flags
00:94DE A901            	   695:   lda #1
00:94E0 85A2            	   696:   sta  current_line        ; we are currently on line 1
00:94E2 64A3            	   697:   stz  current_line+1
                        	   698: 
                        	   699: ;
                        	   700: ;  set up for reading first byte of source
                        	   701: ;
00:94E4 A900            	   702:   lda  #<TEXT_START
00:94E6 858E            	   703:   sta  token_start
00:94E8 859C            	   704:   sta  token_line_start
00:94EA A903            	   705:   lda  #>TEXT_START
00:94EC 858F            	   706:   sta  token_start+1
00:94EE 859D            	   707:   sta  token_line_start+1
00:94F0 20B98C          	   708:   jsr  find_source_end
00:94F3 A523            	   709:   lda  PCODE
00:94F5 8525            	   710:   sta  ACT_PCDA
00:94F7 A524            	   711:   lda  PCODE+1
00:94F9 8526            	   712:   sta  ACT_PCDA+1
00:94FB A000            	   713:   ldy  #0
00:94FD B18E            	   714:   lda  (token_start),y
00:94FF D00A            	   715:   bne  INIT9
00:9501 A9AD            	   716:   lda  #<NOSCE
00:9503 A294            	   717:   ldx  #>NOSCE
00:9505 202682          	   718:   jsr  print                      ; No source file
00:9508 4C7282          	   719:   jmp  main_prompt
00:950B 60              	   720: INIT9    rts
                        	   721: 
                        	   722: 
                        	   723: 
                        	   724: 
                        	   725: ;
                        	   726: CROUT    =  *             ; show a newline
00:950C A90A            	   727:   lda  #NL         ; was a carriage-return in legacy, now is newline
00:950E 4C9A96          	   728:   jmp  COUT
                        	   729: ;
                        	   730: ;***********************************************
                        	   731: ; COMPARE STRING - compare SRCE to DEST, assumes DEST is upper-case
                        	   732: ;                - length in Y (therefore max 255 characters)
                        	   733: ;                - zero flag set if match (therefore do a BEQ to see if strings match)
                        	   734: ;***********************************************
                        	   735: COMSTL   =  *
00:9511 88              	   736:          dey
00:9512 300A            	   737:          bmi  COMS8
00:9514 B100            	   738:          lda  (SRCE),Y
00:9516 20A892          	   739:          jsr MAKE_UPPER
00:9519 D103            	   740:          cmp  (DEST),Y
00:951B F0F4            	   741:          beq  COMSTL
00:951D 60              	   742: COMS9    rts             ; NOT EQUAL
00:951E A900            	   743: COMS8    lda  #0
00:9520 60              	   744:          rts             ; EQUAL
                        	   745: 
                        	   746: ;***********************************************
                        	   747: ; DISPLAY A LINE
                        	   748: ;
                        	   749: 
                        	   750: ;
                        	   751: ; DISPLAY IN HEX
                        	   752: ;
00:9521 208195          	   753: DISHX    jsr  PRBYTE
00:9524 4C9795          	   754:          jmp  PUTSP
                        	   755: ;
                        	   756: 
                        	   757: ;***********************************************
                        	   758: ; DISPLAY PCODE ADDRESS
                        	   759: ;***********************************************
                        	   760: DISPAD   =  *
00:9527 A52E            	   761:          lda  DCODE
00:9529 F017            	   762:          beq  DISPAD2
                        	   763: DISPAD1  =  *
00:952B A928            	   764:          lda  #'('
00:952D 209A96          	   765:          jsr  COUT
00:9530 A524            	   766:          lda  PCODE+1
00:9532 208195          	   767:          jsr  PRBYTE
00:9535 A523            	   768:          lda  PCODE
00:9537 208195          	   769:          jsr  PRBYTE
00:953A A929            	   770:          lda  #')'
00:953C 209A96          	   771:          jsr  COUT
00:953F 4C9795          	   772:          jmp  PUTSP
00:9542 60              	   773: DISPAD2  rts
                        	   774: ;
                        	   775: 
                        	   776: ;***********************************************
                        	   777: ; PUSH 'WORK' ONTO STACK
                        	   778: ;***********************************************
                        	   779: PSHWRK   =  *
00:9543 8536            	   780:          sta  BSAVE
00:9545 68              	   781:          pla
00:9546 AA              	   782:          tax
00:9547 68              	   783:          pla
00:9548 A8              	   784:          tay
00:9549 A538            	   785:          lda  WORK+1
00:954B 48              	   786:          pha
00:954C A537            	   787:          lda  WORK
00:954E 48              	   788:          pha
00:954F 98              	   789:          tya
00:9550 48              	   790:          pha
00:9551 8A              	   791:          txa
00:9552 48              	   792:          pha
00:9553 A536            	   793:          lda  BSAVE
00:9555 60              	   794: PSH9     rts
                        	   795: ;
                        	   796: ;***********************************************
                        	   797: ; PULL 'WORK' FROM STACK
                        	   798: ;***********************************************
                        	   799: PULWRK   =  *
00:9556 8536            	   800:          sta  BSAVE
00:9558 68              	   801:          pla
00:9559 AA              	   802:          tax
00:955A 68              	   803:          pla
00:955B A8              	   804:          tay
00:955C 68              	   805:          pla
00:955D 8537            	   806:          sta  WORK
00:955F 68              	   807:          pla
00:9560 8538            	   808:          sta  WORK+1
00:9562 98              	   809:          tya
00:9563 48              	   810:          pha
00:9564 8A              	   811:          txa
00:9565 48              	   812:          pha
00:9566 A536            	   813:          lda  BSAVE
00:9568 60              	   814:          rts
                        	   815: ;
                        	   816: ;***********************************************
                        	   817: ; PRINTING SUBROUTINES
                        	   818: ; Control characters print with a ^ in front of them, eg. ^A
                        	   819: ;***********************************************
                        	   820: PRCHAR   =  *
00:9569 48              	   821:   pha
00:956A C90A            	   822:   cmp #NL
00:956C F00E            	   823:   beq prchar_not_control
00:956E C920            	   824:   cmp #$20
00:9570 B00A            	   825:   bcs prchar_not_control
00:9572 48              	   826:   pha
00:9573 A95E            	   827:   lda #'^'
00:9575 209A96          	   828:   jsr COUT
00:9578 68              	   829:   pla
00:9579 18              	   830:   clc
00:957A 6940            	   831:   adc #$40  ; make 0x01 print as ^A
                        	   832: prchar_not_control:
00:957C 209A96          	   833:   jsr  COUT
00:957F 68              	   834:   pla
00:9580 60              	   835:   rts
                        	   836: ;
                        	   837: ; Prints A in hex
                        	   838: ;
                        	   839: PRBYTE:
00:9581 48              	   840:   pha
00:9582 4A              	   841:   lsr
00:9583 4A              	   842:   lsr
00:9584 4A              	   843:   lsr
00:9585 4A              	   844:   lsr
00:9586 208C95          	   845:   jsr  PRHEXZ    ; first nibble
00:9589 68              	   846:   pla            ; now do other nibble
                        	   847: PRHEX:
00:958A 290F            	   848:   and  #$0F
                        	   849: PRHEXZ:
00:958C 0930            	   850:   ora  #'0'
00:958E C93A            	   851:   cmp  #'0' + $0A
00:9590 9002            	   852:   bcc  PRHEX1
00:9592 6926            	   853:   adc  #$26  ; (carry is set: adding 7 to make 0x0a become 'a')
                        	   854: PRHEX1:
00:9594 4C6995          	   855:   jmp  PRCHAR
                        	   856: ;
                        	   857: PUTSP    =  *
00:9597 A920            	   858:   lda  #' '
00:9599 80F9            	   859:   bra  PRHEX1
                        	   860: ;
                        	   861: ;
                        	   862: ;  PT - put text
                        	   863: ;   Low-order address in A, high-order address in X, count in Y
                        	   864: ;
                        	   865: ;
                        	   866: PT:
00:959B 8503            	   867:   sta  REG2
00:959D 8604            	   868:   stx  REG2+1
00:959F 98              	   869:   tya    ; count of bytes to print
00:95A0 AA              	   870:   tax    ; put that into X
00:95A1 A000            	   871:   ldy  #0
                        	   872: PT6:
00:95A3 B103            	   873:   lda  (REG2),Y    ; next character
00:95A5 209A96          	   874:   jsr COUT         ; show it
00:95A8 C8              	   875:   iny
00:95A9 CA              	   876:   dex
00:95AA D0F7            	   877:   bne  PT6
00:95AC 60              	   878:   rts
                        	   879: ;
                        	   880: ;
                        	   881: ;
                        	   882: ;---- token_address --> WORK
                        	   883: ;
                        	   884: TKNWRK   =  *
00:95AD 48              	   885:          PHA
00:95AE A590            	   886:          LDA  token_address
00:95B0 8537            	   887:          STA  WORK
00:95B2 A591            	   888:          LDA  token_address+1
00:95B4 8538            	   889:          STA  WORK+1
00:95B6 68              	   890:          PLA
00:95B7 60              	   891:          RTS
                        	   892: ;
                        	   893: ;---- WORK --> token_address
                        	   894: ;
                        	   895: WRKTKN   =  *
00:95B8 48              	   896:          PHA
00:95B9 A537            	   897:          LDA  WORK
00:95BB 8590            	   898:          STA  token_address
00:95BD A538            	   899:          LDA  WORK+1
00:95BF 8591            	   900:          STA  token_address+1
00:95C1 68              	   901:          PLA
00:95C2 60              	   902:          RTS
                        	   903: ;
                        	   904: 
                        	   905: 
                        	   906: ;***********************************************
                        	   907: ; MENU, FILE HANDLING
                        	   908: ;***********************************************
                        	   909: ;
00:95C3 502D636F64657320	   910: pcodes_ended_message        asciiz  "P-codes ended at $"
00:95CB 656E646564206174
00:95D3 2024
00:95D5 00
00:95D6 436F6D70696C6520	   911: compile_finished_message    asciiz  "Compile finished: No errors.\n"
00:95DE 66696E6973686564
00:95E6 3A204E6F20657272
00:95EE 6F72732E0A
00:95F3 00
00:95F4 53796D626F6C2074	   912: symbol_table_ended_message  asciiz "Symbol table ended at $"
00:95FC 61626C6520656E64
00:9604 65642061742024
00:960B 00
00:960C 4E6F2076616C6964	   913: no_valid_compile_message    asciiz  'No valid compile or assemble done before\n'
00:9614 20636F6D70696C65
00:961C 206F722061737365
00:9624 6D626C6520646F6E
00:962C 65206265666F7265
00:9634 0A
00:9635 00
                        	   914: ;
                        	   915: PRBYTECR =  *
00:9636 208195          	   916:          JSR  PRBYTE
00:9639 4C0C95          	   917:          JMP  CROUT
                        	   918: ;
                        	   919: ;
                        	   920: ;
                        	   921: CHK_VAL  =  *
00:963C A908            	   922:          lda  #FLAG_VALID_COMPILE
00:963E 0910            	   923:          ora  #FLAG_VALID_ASSEMBLE
00:9640 25BE            	   924:          and  system_flags
00:9642 D00A            	   925:          bne  CHK_VAL9
00:9644 A90C            	   926:          lda  #<no_valid_compile_message    ; No valid Compile or Assemble done before
00:9646 A296            	   927:          ldx  #>no_valid_compile_message
00:9648 202682          	   928:          jsr  print
00:964B 4C7282          	   929:          jmp  main_prompt
                        	   930: CHK_VAL9 =  *
                        	   931: BELL1X   =  *          ; no bell yet
00:964E 60              	   932:          rts
                        	   933: ;
00:964F 203C96          	   934: CHK_RUN  jsr  CHK_VAL
00:9652 A910            	   935:          lda  #FLAG_VALID_ASSEMBLE
00:9654 25BE            	   936:          and  system_flags
00:9656 D003            	   937:          bne  run_assembler
00:9658 4C49B1          	   938:          jmp  INTERP
                        	   939: run_assembler:
00:965B A2CF            	   940:          ldx #RUNNING_STACK_TOP           ; don't use all of stack
00:965D 9A              	   941:          txs
00:965E A980            	   942:          lda #FLAG_BRK_REACHED    ; no BRK reached yet
00:9660 14BE            	   943:          trb system_flags
00:9662 206896          	   944:          jsr call_assembler
00:9665 4CE5B1          	   945:          jmp  EX_FINISHD
                        	   946: ;
                        	   947: ;  let's assume they put a RTS at the end of their code
                        	   948: ;
                        	   949: call_assembler:
00:9668 A9D7            	   950:          lda  #<running_message   ; Running
00:966A A2B0            	   951:          ldx  #>running_message
00:966C 202682          	   952:          jsr  print
00:966F 6C2500          	   953:          jmp (ACT_PCDA)
                        	   954: 
                        	   955: ;
                        	   956: 
                        	   957: ;
                        	   958: ; Get a line, read byte by byte until we get a newline, store in INBUF
                        	   959: ;   returns length in Y - handles backspace, ignores carriage-return
                        	   960: ;
                        	   961: GET_LINE =  *
                        	   962: GETLN1   =  *
00:9672 A000            	   963:   ldy  #0
                        	   964: GET1:
00:9674 200FCC          	   965:   jsr  CHRIN
00:9677 C90D            	   966:   cmp  #CR       ; carriage-return?
00:9679 F0F9            	   967:   beq  GET1       ; ignore it
00:967B 990002          	   968:   sta  INBUF,Y    ; SAVE IN BUFFER
00:967E C8              	   969:   iny
00:967F F016            	   970:   beq  GETLN_OVERFLOW       ; overflow
00:9681 C90A            	   971:   cmp  #NL        ; END OF LINE?
00:9683 F00C            	   972:   beq  GET3       ; yes
00:9685 C908            	   973:   cmp  #BACKSPACE ; backspace?
00:9687 D0EB            	   974:   bne  GET1       ; no - keep adding to buffer
                        	   975: ;
                        	   976: ;  here for backspace
                        	   977: ;
00:9689 88              	   978:   dey  ; get rid of backspace
00:968A 88              	   979:   dey  ; get rid of character we backspaced over
00:968B C0FF            	   980:   cpy  #$FF
00:968D F0E3            	   981:   beq  GETLN1   ; if Y underflowed, go back to zero
00:968F 80E3            	   982:   bra GET1
                        	   983: 
                        	   984: GET3:
00:9691 A900            	   985:   lda  #0
00:9693 990002          	   986:   sta  INBUF,Y    ; turn newline into 0x00
00:9696 60              	   987:   rts             ; RETURN
                        	   988: ;
                        	   989: ;  here on INBUF overflow
                        	   990: ;
                        	   991: GETLN_OVERFLOW:
00:9697 88              	   992:   dey           ; get back to 255 (last byte)
00:9698 80F7            	   993:   bra  GET3     ; store a zero there
                        	   994: 
                        	   995: 
                        	   996: ;
                        	   997: ;  output a character - saves all registers
                        	   998: ;
                        	   999: COUT:
00:969A 48              	  1000:   pha
00:969B DA              	  1001:   phx
00:969C 5A              	  1002:   phy
00:969D 20A496          	  1003:   jsr COUT_CALL   ; call the current outputting routine
00:96A0 7A              	  1004:   ply
00:96A1 FA              	  1005:   plx
00:96A2 68              	  1006:   pla
00:96A3 60              	  1007:   rts
                        	  1008: 
                        	  1009: 
                        	  1010: COUT_CALL:
00:96A4 6C1700          	  1011:   jmp (write_function)
                        	  1012: 
                        	  1013: 

Source: "gpascal.asm"
                        	   180:   .include "errors.inc"

Source: "errors.inc"
                        	     1: 
                        	     2: errors_table:
00:96A7 4D656D6F72792066	     3:   asciiz "Memory full"                               ;  1
00:96AF 756C6C
00:96B2 00
00:96B3 436F6E7374616E74	     4:   asciiz "Constant expected"                         ;  2
00:96BB 2065787065637465
00:96C3 64
00:96C4 00
00:96C5 3D20657870656374	     5:   asciiz "= expected"                                ;  3
00:96CD 6564
00:96CF 00
00:96D0 4964656E74696669	     6:   asciiz "Identifier expected"                       ;  4
00:96D8 6572206578706563
00:96E0 746564
00:96E3 00
00:96E4 2C206F72203A2065	     7:   asciiz ", or : expected"                           ;  5
00:96EC 78706563746564
00:96F3 00
00:96F4 427567          	     8:   asciiz "Bug"                                       ;  6
00:96F7 00
00:96F8 2A29206F72207D20	     9:   asciiz "*) or } expected"                          ;  7
00:9700 6578706563746564
00:9708 00
00:9709 496E636F72726563	    10:   asciiz "Incorrect string"                          ;  8
00:9711 7420737472696E67
00:9719 00
00:971A 2E20657870656374	    11:   asciiz ". expected"                                ;  9
00:9722 6564
00:9724 00
00:9725 3B20657870656374	    12:   asciiz "; expected"                                ; 10
00:972D 6564
00:972F 00
00:9730 556E6465636C6172	    13:   asciiz "Undeclared identifier"                     ; 11
00:9738 6564206964656E74
00:9740 6966696572
00:9745 00
00:9746 496C6C6567616C20	    14:   asciiz "Illegal identifier"                        ; 12
00:974E 6964656E74696669
00:9756 6572
00:9758 00
00:9759 3A3D206578706563	    15:   asciiz ":= expected"                               ; 13
00:9761 746564
00:9764 00
00:9765 4C69746572616C20	    16:   asciiz "Literal string of zero length"             ; 14
00:976D 737472696E67206F
00:9775 66207A65726F206C
00:977D 656E677468
00:9782 00
00:9783 436F6D70696C6572	    17:   asciiz "Compiler limits exceeded"                  ; 15
00:978B 206C696D69747320
00:9793 6578636565646564
00:979B 00
00:979C 5448454E20657870	    18:   asciiz "THEN expected"                             ; 16
00:97A4 6563746564
00:97A9 00
00:97AA 3B206F7220454E44	    19:   asciiz "; or END expected"                         ; 17
00:97B2 2065787065637465
00:97BA 64
00:97BB 00
00:97BC 444F206578706563	    20:   asciiz "DO expected"                               ; 18
00:97C4 746564
00:97C7 00
00:97C8 496E636F72726563	    21:   asciiz "Incorrect symbol"                          ; 19
00:97D0 742073796D626F6C
00:97D8 00
00:97D9 427567          	    22:   asciiz "Bug"                                       ; 20
00:97DC 00
00:97DD 557365206F662070	    23:   asciiz "Use of procedure identifier in expression" ; 21
00:97E5 726F636564757265
00:97ED 206964656E746966
00:97F5 69657220696E2065
00:97FD 787072657373696F
00:9805 6E
00:9806 00
00:9807 2920657870656374	    24:   asciiz ") expected"                                ; 22
00:980F 6564
00:9811 00
00:9812 496C6C6567616C20	    25:   asciiz "Illegal factor"                            ; 23
00:981A 666163746F72
00:9820 00
00:9821 54797065206D6973	    26:   asciiz "Type mismatch"                             ; 24
00:9829 6D61746368
00:982E 00
00:982F 424547494E206578	    27:   asciiz "BEGIN expected"                            ; 25
00:9837 706563746564
00:983D 00
00:983E 4F46206578706563	    28:   asciiz "OF expected"                               ; 26
00:9846 746564
00:9849 00
00:984A 537461636B206675	    29:   asciiz "Stack full"                                ; 27
00:9852 6C6C
00:9854 00
00:9855 544F206F7220444F	    30:   asciiz "TO or DOWNTO expected"                     ; 28
00:985D 574E544F20657870
00:9865 6563746564
00:986A 00
00:986B 537472696E67206C	    31:   asciiz "String literal too big"                    ; 29
00:9873 69746572616C2074
00:987B 6F6F20626967
00:9881 00
00:9882 4E756D626572206F	    32:   asciiz "Number out of range"                       ; 30
00:988A 7574206F66207261
00:9892 6E6765
00:9895 00
00:9896 2820657870656374	    33:   asciiz "( expected"                                ; 31
00:989E 6564
00:98A0 00
00:98A1 2C20657870656374	    34:   asciiz ", expected"                                ; 32
00:98A9 6564
00:98AB 00
00:98AC 5B20657870656374	    35:   asciiz "[ expected"                                ; 33
00:98B4 6564
00:98B6 00
00:98B7 5D20657870656374	    36:   asciiz "] expected"                                ; 34
00:98BF 6564
00:98C1 00
00:98C2 506172616D657465	    37:   asciiz "Parameters mismatched"                     ; 35
00:98CA 7273206D69736D61
00:98D2 7463686564
00:98D7 00
00:98D8 4461746120747970	    38:   asciiz "Data type not recognised"                  ; 36
00:98E0 65206E6F74207265
00:98E8 636F676E69736564
00:98F0 00
00:98F1 53796D626F6C2074	    39:   asciiz "Symbol table full"                         ; 37
00:98F9 61626C652066756C
00:9901 6C
00:9902 00
00:9903 4475706C69636174	    40:   asciiz "Duplicate identifier"                      ; 38
00:990B 65206964656E7469
00:9913 66696572
00:9917 00
00:9918 56616C7565206578	    41:   asciiz "Value expected"                            ; 39
00:9920 706563746564
00:9926 00
00:9927 496C6C6567616C20	    42:   asciiz "Illegal opcode"                            ; 40
00:992F 6F70636F6465
00:9935 00
00:9936 496C6C6567616C20	    43:   asciiz "Illegal addressing mode"                   ; 41
00:993E 6164647265737369
00:9946 6E67206D6F6465
00:994D 00
00:994E 4272616E6368206F	    44:   asciiz "Branch out of range"                       ; 42
00:9956 7574206F66207261
00:995E 6E6765
00:9961 00
00:9962 4E656564207A6572	    45:   asciiz "Need zero page address"                    ; 43
00:996A 6F20706167652061
00:9972 646472657373
00:9978 00
00:9979 4F706572616E6420	    46:   asciiz "Operand too large"                         ; 44
00:9981 746F6F206C617267
00:9989 65
00:998A 00
00:998B 53796D626F6C2061	    47:   asciiz "Symbol address changed"                    ; 45
00:9993 6464726573732063
00:999B 68616E676564
00:99A1 00
00:99A2 4578707265737369	    48:   asciiz "Expression too complex"                    ; 46
00:99AA 6F6E20746F6F2063
00:99B2 6F6D706C6578
00:99B8 00
00:99B9 4469766964652062	    49:   asciiz "Divide by zero"                            ; 47
00:99C1 79207A65726F
00:99C7 00
00:99C8 4C6162656C207265	    50:   asciiz "Label required"                            ; 48
00:99D0 717569726564
00:99D6 00
00:99D7 53796D626F6C2074	    51:   asciiz "Symbol table in use"                       ; 49
00:99DF 61626C6520696E20
00:99E7 757365
00:99EA 00
00:99EB 4E6F204C4344    	    52:   asciiz "No LCD"                                    ; 50
00:99F1 00
00:99F2 436F646520616C72	    53:   asciiz "Code already generated"                    ; 51
00:99FA 656164792067656E
00:9A02 657261746564
00:9A08 00
                        	    54: assertion_failed_message:   ; used by Pascal assert function
00:9A09 417373657274696F	    55:   asciiz "Assertion failed"                          ; 52
00:9A11 6E206661696C6564
00:9A19 00
00:9A1A 557365206F662066	    56:   asciiz "Use of function identifier in statement"   ; 53
00:9A22 756E6374696F6E20
00:9A2A 6964656E74696669
00:9A32 657220696E207374
00:9A3A 6174656D656E74
00:9A41 00
00:9A42 00              	    57:   dfb 0
                        	    58: 
                        	    59: ;***********************************************
                        	    60: ; DISPLAY ERROR - this does not return to the caller
                        	    61: ;  but to main_prompt
                        	    62: ;  Error number in X
                        	    63: ;***********************************************
00:9A43 2A2A2A204572726F	    64: ERRLIT   asciiz  '*** Error: '
00:9A4B 723A20
00:9A4E 00
                        	    65: 
00:9A4F 8635            	    66: ERROR    stx  ERRNO
00:9A51 A53F            	    67:          lda  RUNNING
00:9A53 F003            	    68:          beq  ERR7
00:9A55 4C8C9A          	    69:          jmp  ERR6
                        	    70: ERR7     =  *
00:9A58 A51D            	    71:          lda  LIST
00:9A5A D006            	    72:          bne  ERR1
00:9A5C 200C95          	    73:          jsr  CROUT
00:9A5F 20E49A          	    74:          jsr  show_current_line
                        	    75: ERR1     =  *
00:9A62 A590            	    76:          lda  token_address
00:9A64 38              	    77:          sec
00:9A65 E59C            	    78:          sbc  token_line_start  ; TODO: what about high-order byte?
00:9A67 48              	    79:          pha             ; CHARS UP TO ERROR POINT
00:9A68 A943            	    80:          lda  #<ERRLIT   ; *** Error
00:9A6A A29A            	    81:          ldx  #>ERRLIT
00:9A6C 202682          	    82:          jsr  print
00:9A6F 68              	    83:          pla
00:9A70 18              	    84:          clc
00:9A71 6901            	    85:          adc   #1
00:9A73 8545            	    86:          sta  TEMP       ; BYTES TO ERROR POINT
00:9A75 AA              	    87:          tax
                        	    88: ERR3     =  *
00:9A76 209795          	    89:          jsr  PUTSP
00:9A79 CA              	    90:          dex
00:9A7A D0FA            	    91:          bne  ERR3
00:9A7C A95E            	    92:          lda  #'^'
00:9A7E 209A96          	    93:          jsr  COUT
00:9A81 200C95          	    94:          jsr  CROUT
00:9A84 A209            	    95:          ldx  #9
                        	    96: ERR5     =  *
00:9A86 209795          	    97:          jsr  PUTSP
00:9A89 CA              	    98:          dex
00:9A8A D0FA            	    99:          bne  ERR5
                        	   100: ERR6     =  *
00:9A8C A9A7            	   101:   lda #<errors_table
00:9A8E 8500            	   102:   sta REG
00:9A90 A996            	   103:   lda #>errors_table
00:9A92 8501            	   104:   sta REG+1
00:9A94 A200            	   105:   ldx #0
00:9A96 A000            	   106:   ldy #0
                        	   107: error_next:
00:9A98 E8              	   108:   inx
                        	   109: error_loop:
00:9A99 E435            	   110:   cpx ERRNO
00:9A9B F02A            	   111:   beq error_found
                        	   112: error_find_next:
00:9A9D B100            	   113:   lda (REG),Y
00:9A9F 48              	   114:   pha
00:9AA0 E600            	   115:   inc REG
00:9AA2 D002            	   116:   bne error1
00:9AA4 E601            	   117:   inc REG+1
                        	   118: error1:
00:9AA6 68              	   119:   pla           ; get the previous byte
00:9AA7 D0F4            	   120:   bne error_find_next
00:9AA9 B100            	   121:   lda (REG),Y   ; a null after a null?
00:9AAB F002            	   122:   beq error_not_found
00:9AAD 80E9            	   123:   bra error_next  ; we got a null, so add 1 to our current error number (X)
                        	   124: 
                        	   125: error_not_found:
00:9AAF A9D4            	   126:   lda #<error_not_found_message
00:9AB1 A29A            	   127:   ldx #>error_not_found_message
00:9AB3 202682          	   128:   jsr print
00:9AB6 A535            	   129:   lda ERRNO
00:9AB8 8500            	   130:   sta REG
00:9ABA 6401            	   131:   stz REG+1
00:9ABC 6402            	   132:   stz REGB
00:9ABE 203694          	   133:   jsr display_in_decimal
00:9AC1 200C95          	   134:   jsr CROUT
00:9AC4 4C7282          	   135:   jmp main_prompt
                        	   136: 
                        	   137: error_found:
00:9AC7 A500            	   138:   lda REG
00:9AC9 A601            	   139:   ldx REG+1
00:9ACB 202682          	   140:   jsr print
00:9ACE 200C95          	   141:   jsr CROUT
00:9AD1 4C7282          	   142:   jmp  main_prompt
                        	   143: 
00:9AD4 556E6B6E6F776E20	   144: error_not_found_message asciiz "Unknown error: "
00:9ADC 6572726F723A20
00:9AE3 00
                        	   145: 
                        	   146: show_current_line:
00:9AE4 A928            	   147:   lda #'('
00:9AE6 209A96          	   148:   jsr COUT
00:9AE9 A524            	   149:   lda PCODE+1
00:9AEB 208195          	   150:   jsr PRBYTE
00:9AEE A523            	   151:   lda PCODE
00:9AF0 208195          	   152:   jsr PRBYTE
00:9AF3 A929            	   153:   lda #')'
00:9AF5 209A96          	   154:   jsr COUT
00:9AF8 209795          	   155:   jsr PUTSP
00:9AFB 20478C          	   156:   jsr show_current_line_number
00:9AFE A59C            	   157:   lda token_line_start
00:9B00 85A6            	   158:   sta mem_move_src
00:9B02 A59D            	   159:   lda token_line_start+1
00:9B04 85A7            	   160:   sta mem_move_src+1
                        	   161: 
                        	   162: show_current_line_loop:
00:9B06 A000            	   163:   ldy #0
00:9B08 B1A6            	   164:   lda (mem_move_src),Y
00:9B0A F01D            	   165:   beq show_current_line_done
00:9B0C C90A            	   166:   cmp #NL
00:9B0E F019            	   167:   beq show_current_line_done
00:9B10 C920            	   168:   cmp #$20
00:9B12 B00A            	   169:   bcs show_current_line_loop_print_one_character
00:9B14 48              	   170:   pha
00:9B15 A95E            	   171:   lda #'^'
00:9B17 209A96          	   172:   jsr COUT
00:9B1A 68              	   173:   pla
00:9B1B 18              	   174:   clc
00:9B1C 6940            	   175:   adc #$40  ; make 0x01 print as ^A
                        	   176: show_current_line_loop_print_one_character:
00:9B1E 209A96          	   177:   jsr COUT    ; show that byte
00:9B21 E6A6            	   178:   inc mem_move_src
00:9B23 D0E1            	   179:   bne show_current_line_loop
00:9B25 E6A7            	   180:   inc mem_move_src+1
00:9B27 80DD            	   181:   bra show_current_line_loop
                        	   182: 
                        	   183: show_current_line_done:
00:9B29 200C95          	   184:   jsr CROUT
00:9B2C 60              	   185:   rts
                        	   186: 

Source: "gpascal.asm"
                        	   181:   .include "assembler.inc"

Source: "assembler.inc"
                        	     1: ;***********************************************
                        	     2: ;
                        	     3: ; Assembler
                        	     4: ;
                        	     5: ;***********************************************
                        	     6: 
                        	     7: ;***********************************************
                        	     8: ; Assembler operand types
                        	     9: ;***********************************************
                        	    10: 
                        	    11: ASS_OPERAND_ABSOLUTE                           =  1      ; a
                        	    12: ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT          =  2      ; (a,x)
                        	    13: ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X            =  3      ; a,x
                        	    14: ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y            =  4      ; a,y
                        	    15: ASS_OPERAND_ABSOLUTE_INDIRECT                  =  5      ; (a)
                        	    16: ASS_OPERAND_ACCUMULATOR_A                      =  6      ; A
                        	    17: ASS_OPERAND_IMMEDIATE                          =  7      ; #
                        	    18: ASS_OPERAND_IMPLIED                            =  8      ; i
                        	    19: ASS_OPERAND_PROGRAM_COUNTER_RELATIVE           =  9      ; r
                        	    20: ASS_OPERAND_STACK                              = 10      ; s
                        	    21: ASS_OPERAND_ZERO_PAGE                          = 11      ; zp
                        	    22: ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT         = 12      ; (zp,x)
                        	    23: ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X           = 13      ; zp,x
                        	    24: ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y           = 14      ; zp,y
                        	    25: ASS_OPERAND_ZERO_PAGE_INDIRECT                 = 15      ; (zp)
                        	    26: ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y  = 16      ; (zp),y
                        	    27: ASS_OPERAND_STRING                             = 17      ; "But does it get goat's blood out?"
                        	    28: ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE             = 18      ; zp,r
                        	    29: 
                        	    30: ;
                        	    31: ;  Entry point for assembler
                        	    32: ;
                        	    33: ASSEMBLE:
                        	    34: 
00:9B2D A2FF            	    35:    ldx  #NEW_STK
00:9B2F 9A              	    36:    txs    ; set stack back to 0xFF
00:9B30 6476            	    37:    stz  ASS_PASS  ; first pass
00:9B32 20BE94          	    38:    jsr  INIT       ; sets up pointers, calls LINE
00:9B35 2071AD          	    39:    jsr  add_assembler_library_functions  ; add our inbuilt functions to the symbol table
00:9B38 8005            	    40:    bra  ASSEMBLE_PASS
                        	    41: 
                        	    42: ASSEMBLE_SECOND_PASS:
00:9B3A E676            	    43:    inc  ASS_PASS
00:9B3C 20CA94          	    44:    jsr  INIT_SECOND_PASS    ; don't re-initialise the symbol table
                        	    45: ASSEMBLE_PASS:
00:9B3F 64A2            	    46:    stz  current_line  ; we'll got for zero, not one
                        	    47: 
00:9B41 A902            	    48:    lda  #FLAG_ASSEMBLING
00:9B43 04BE            	    49:    tsb  system_flags
                        	    50: 
                        	    51: ;
                        	    52: ;  no listing yet
                        	    53: ;
00:9B45 642E            	    54:    stz  DCODE
00:9B47 641D            	    55:    stz  LIST
00:9B49 6442            	    56:    stz  SYNTAX
00:9B4B 6482            	    57:    stz  show_symbols
                        	    58: ;
                        	    59: ; zero line count
                        	    60: ;
00:9B4D 6419            	    61:    stz  LINE_CNT
00:9B4F 641A            	    62:    stz  LINE_CNT+1
                        	    63: 
                        	    64: ;
                        	    65: ;  and emitted bytes count
                        	    66: ;
00:9B51 6477            	    67:    stz ass_emit_bytes
00:9B53 6478            	    68:    stz ass_emit_bytes+1
                        	    69: 
                        	    70: ;
                        	    71: ; no previous token
                        	    72: ;
00:9B55 6493            	    73:    stz  token_type
00:9B57 800E            	    74:    bra ass_line
                        	    75: 
                        	    76: ass_finish_line:
00:9B59 A593            	    77:    lda token_type
00:9B5B C90A            	    78:    cmp #NL
00:9B5D F008            	    79:    beq ass_line
00:9B5F A213            	    80:    ldx #19    ; Incorrect Symbol
00:9B61 4C95A1          	    81:    jmp ass_error
                        	    82: 
                        	    83: ass_done_jump:
00:9B64 4C689E          	    84:    jmp ass_done
                        	    85: ;
                        	    86: ;  here for the start of a line
                        	    87: ;
                        	    88: ass_line:
00:9B67 A576            	    89:   lda ASS_PASS    ; only showing codes on 2nd pass
00:9B69 F00B            	    90:   beq ass_line1
00:9B6B A56F            	    91:   lda ASS_EMIT_COUNT  ; only need a newline if we actually output a code
00:9B6D F007            	    92:   beq ass_line1
00:9B6F A52E            	    93:   lda DCODE           ; is showing codes on?
00:9B71 F003            	    94:   beq ass_line1
00:9B73 200C95          	    95:   jsr CROUT
                        	    96: ass_line1:
00:9B76 A000            	    97:   ldy #0
00:9B78 B18E            	    98:   lda (token_start),y ; quick test so we don't list a non-existent line
00:9B7A F0E8            	    99:   beq ass_done_jump
                        	   100: 
00:9B7C A58E            	   101:   lda token_start
00:9B7E 859C            	   102:   sta token_line_start
00:9B80 A58F            	   103:   lda token_start+1
00:9B82 859D            	   104:   sta token_line_start+1
00:9B84 202FCD          	   105:   jsr token_line        ; list the next line
                        	   106: 
00:9B87 646B            	   107:   stz ASS_OPERAND   ; no operand yet
00:9B89 646F            	   108:   stz ASS_EMIT_COUNT
00:9B8B 6483            	   109:   stz ass_current_label
00:9B8D 6484            	   110:   stz ass_current_label+1
                        	   111: 
00:9B8F 208FCC          	   112:   jsr get_token
                        	   113: 
00:9B92 C949            	   114:   cmp #TOKEN_IDENTIFIER  ; could be a label if in column 1
00:9B94 F011            	   115:   beq ass_identifier
00:9B96 C93D            	   116:   cmp #'='               ; = directive is OK
00:9B98 F00D            	   117:   beq ass_identifier
                        	   118: 
00:9B9A C90A            	   119:   cmp #NL
00:9B9C F0C9            	   120:   beq ass_line
                        	   121: 
00:9B9E C900            	   122:   cmp #0
00:9BA0 F0C2            	   123:   beq ass_done_jump
                        	   124: 
                        	   125: ass_bad_identifier:
00:9BA2 A204            	   126:   ldx #4      ; Identifier expected
00:9BA4 4C95A1          	   127:   JMP ass_error
                        	   128: 
                        	   129: ass_identifier:
                        	   130: 
                        	   131: ;
                        	   132: ;  if the identifier is at the start of the line, it is a label, not an opcode
                        	   133: ;
00:9BA7 A590            	   134:   lda token_address
00:9BA9 C59C            	   135:   cmp token_line_start
00:9BAB D069            	   136:   bne ass_opcode
00:9BAD A591            	   137:   lda token_address+1
00:9BAF C59D            	   138:   cmp token_line_start+1
00:9BB1 D063            	   139:   bne ass_opcode
                        	   140: 
00:9BB3 A593            	   141:   lda token_type         ; can't have = as an identifier
00:9BB5 C93D            	   142:   cmp #'='               ; or "="
00:9BB7 F0E9            	   143:   beq ass_bad_identifier
                        	   144: 
                        	   145: ;
                        	   146: ;  here for label - on the first pass, add it to the symbol table, on the second pass look it up
                        	   147: ;
00:9BB9 A576            	   148:   lda ASS_PASS
00:9BBB D01A            	   149:   bne ass_lookup_existing_label
                        	   150: ;
                        	   151: ;  here for first pass
                        	   152: ;
00:9BBD 2036BD          	   153:   jsr CHKDUP
                        	   154: ;
                        	   155: ; not a duplicate - add it
                        	   156: ;
00:9BC0 A523            	   157:   lda PCODE
00:9BC2 8594            	   158:   sta token_value
00:9BC4 A524            	   159:   lda PCODE+1
00:9BC6 8595            	   160:   sta token_value+1
00:9BC8 6496            	   161:   stz token_value+2
00:9BCA A943            	   162:   lda #SYMBOL_CONSTANT
00:9BCC 208FBC          	   163:   jsr ADDSYM
00:9BCF A002            	   164:   ldy #SYMLIB     ; the "level" of user symbols is 0
00:9BD1 A900            	   165:   lda #0
00:9BD3 9140            	   166:   sta (SYMITM),Y
00:9BD5 8016            	   167:   bra ass_added_symbol
                        	   168: 
                        	   169: ;
                        	   170: ;  here for second pass
                        	   171: ;
                        	   172: ass_lookup_existing_label:
00:9BD7 2013BC          	   173:   jsr SEARCH  ; look it up
00:9BDA D005            	   174:   bne ass_lookup_save_address  ; it should be!
00:9BDC A206            	   175:   ldx #6  ; ERROR: bug
00:9BDE 4C95A1          	   176:   jmp ass_error
                        	   177: 
                        	   178: ass_lookup_save_address:
00:9BE1 A594            	   179:   lda token_value
00:9BE3 8573            	   180:   sta ASS_VALUE
00:9BE5 A595            	   181:   lda token_value+1
00:9BE7 8574            	   182:   sta ASS_VALUE+1
00:9BE9 A596            	   183:   lda token_value+2
00:9BEB 8575            	   184:   sta ASS_VALUE+2
                        	   185: 
                        	   186: ;
                        	   187: ;  the symbol has either been added, or looked up to make sure it is still there
                        	   188: ;
                        	   189: ass_added_symbol:
                        	   190: 
                        	   191: ;
                        	   192: ;  remember its address in case we have an EQU directive
                        	   193: ;
00:9BED A540            	   194:   lda SYMITM
00:9BEF 8583            	   195:   sta ass_current_label
00:9BF1 A541            	   196:   lda SYMITM+1
00:9BF3 8584            	   197:   sta ass_current_label+1
                        	   198: 
                        	   199: ;
                        	   200: ;  get whatever is after the label
                        	   201: ;
00:9BF5 208FCC          	   202:   jsr get_token
00:9BF8 C93A            	   203:   cmp #':'
00:9BFA D003            	   204:   bne ass_not_colon
00:9BFC 208FCC          	   205:   jsr get_token  ; skip the colon
                        	   206: ass_not_colon:
00:9BFF C90A            	   207:   cmp #NL     ; newline means this is just a label line
00:9C01 D003            	   208:   bne ass_not_colon2
00:9C03 4C599B          	   209:   jmp ass_finish_line
                        	   210: 
                        	   211: ass_not_colon2:
00:9C06 C949            	   212:   cmp #TOKEN_IDENTIFIER  ; should be an opcode now
00:9C08 F00C            	   213:   beq ass_opcode
00:9C0A C93D            	   214:   cmp #'='               ; = directive is OK
00:9C0C F008            	   215:   beq ass_opcode
                        	   216: 
                        	   217: ass_illegal_opcode:
00:9C0E 208195          	   218:   jsr PRBYTE
00:9C11 A228            	   219:   ldx #40      ; ERROR: illegal opcode
00:9C13 4C95A1          	   220:   JMP ass_error
                        	   221: 
                        	   222: ass_opcode:
                        	   223: 
                        	   224: ;
                        	   225: ;  this will be our assembler mnemonic or directive so save its start point and length
                        	   226: ;
                        	   227: 
00:9C16 A690            	   228:   ldx token_address
00:9C18 866C            	   229:   stx OPCODE
00:9C1A A691            	   230:   ldx token_address+1
00:9C1C 866D            	   231:   stx OPCODE+1
00:9C1E A692            	   232:   ldx token_length
00:9C20 866E            	   233:   stx OPCODE_LEN
                        	   234: 
                        	   235: ;
                        	   236: ;  if we had a label on the line, check its address hasn't changed (on the second pass)
                        	   237: ;   UNLESS it is an EQU directive in which case it probably did change
                        	   238: ;
00:9C22 A576            	   239:   lda ASS_PASS
00:9C24 F046            	   240:   beq ass_opcode2
00:9C26 A583            	   241:   lda ass_current_label
00:9C28 0584            	   242:   ora ass_current_label+1   ; was there a label?
00:9C2A F040            	   243:   beq ass_opcode2    ; nope
00:9C2C A593            	   244:   lda token_type
00:9C2E C93D            	   245:   cmp #'='
00:9C30 F03A            	   246:   beq ass_opcode2   ; don't check on "=" directive
00:9C32 A592            	   247:   lda token_length
00:9C34 C903            	   248:   cmp #3
00:9C36 D034            	   249:   bne ass_opcode2   ; can't be EQU
                        	   250: ;
                        	   251: ; this is truly crap, but I am feeling lazy
                        	   252: ;
00:9C38 A000            	   253:   ldy #0
00:9C3A B190            	   254:   lda (token_address),y
00:9C3C 20A892          	   255:   jsr MAKE_UPPER
00:9C3F C945            	   256:   cmp #'E'
00:9C41 D014            	   257:   bne ass_check_label_changed
00:9C43 C8              	   258:   iny
00:9C44 B190            	   259:   lda (token_address),y
00:9C46 20A892          	   260:   jsr MAKE_UPPER
00:9C49 C951            	   261:   cmp #'Q'
00:9C4B D00A            	   262:   bne ass_check_label_changed
00:9C4D C8              	   263:   iny
00:9C4E B190            	   264:   lda (token_address),y
00:9C50 20A892          	   265:   jsr MAKE_UPPER
00:9C53 C955            	   266:   cmp #'U'
00:9C55 F015            	   267:   beq ass_opcode2
                        	   268: 
                        	   269: ;
                        	   270: ;  we looked up the label earlier, when it was the current token,
                        	   271: ;   and we saved its value in ASS_VALUE
                        	   272: ;
                        	   273: 
                        	   274: ass_check_label_changed:
00:9C57 A523            	   275:   lda PCODE
00:9C59 C573            	   276:   cmp ASS_VALUE
00:9C5B D00A            	   277:   bne ass_symbol_address_changed
00:9C5D A524            	   278:   lda PCODE+1
00:9C5F C574            	   279:   cmp ASS_VALUE+1
00:9C61 D004            	   280:   bne ass_symbol_address_changed
00:9C63 A575            	   281:   lda ASS_VALUE+2   ; 3rd byte should be zero
00:9C65 F005            	   282:   beq ass_opcode2
                        	   283: 
                        	   284: ass_symbol_address_changed:
00:9C67 A22D            	   285:   ldx #45     ; ERROR: Symbol address changed
00:9C69 4C95A1          	   286:   jmp ass_error
                        	   287: 
                        	   288: 
                        	   289: 
                        	   290: ass_opcode2:
                        	   291: ;
                        	   292: ;  look up operand
                        	   293: ;
                        	   294: 
00:9C6C 208FCC          	   295:   jsr get_token
00:9C6F C90A            	   296:   cmp #NL           ; or end of line?
00:9C71 D00D            	   297:   bne ass_operand
                        	   298: 
                        	   299: ;
                        	   300: ;  here when the opcode is followed by (spaces) or a newline
                        	   301: ;
00:9C73 A908            	   302:   lda #ASS_OPERAND_IMPLIED
00:9C75 856B            	   303:   sta ASS_OPERAND
00:9C77 20BF9D          	   304:   jsr opcode_lookup
00:9C7A 20AB9E          	   305:   jsr ass_check_no_more_tokens
                        	   306: ass_finish_lineJ:
00:9C7D 4C599B          	   307:   jmp ass_finish_line
                        	   308: 
                        	   309: ass_operand:
00:9C80 C923            	   310:   cmp #'#'  ; immediate?
00:9C82 F01B            	   311:   beq ass_immediate
00:9C84 C928            	   312:   cmp #'('  ; indirect?
00:9C86 F02A            	   313:   beq ass_indirect
00:9C88 C949            	   314:   cmp #TOKEN_IDENTIFIER
00:9C8A F02F            	   315:   beq ass_identifier_operand
00:9C8C C922            	   316:   cmp #TOKEN_STRING
00:9C8E F002            	   317:   beq ass_string
                        	   318: ;
                        	   319: ;  here for some kind of numeric address
                        	   320: ;
00:9C90 804A            	   321:   bra ass_operand_value
                        	   322: 
                        	   323: ;
                        	   324: ;  Here for a string as an operand, should be a compiler directive, eg.  ASC "Hello, world"
                        	   325: ;
                        	   326: ass_string:
00:9C92 A911            	   327:   lda #ASS_OPERAND_STRING
00:9C94 856B            	   328:   sta ASS_OPERAND
00:9C96 20BF9D          	   329:   jsr opcode_lookup
00:9C99 208FCC          	   330:   jsr get_token  ; NOW get the next token
00:9C9C 4C599B          	   331:   jmp ass_finish_line
                        	   332: 
                        	   333: ;
                        	   334: ;  immediate, that is:  #<expression>
                        	   335: ;
                        	   336: ass_immediate:
00:9C9F A907            	   337:   lda #ASS_OPERAND_IMMEDIATE
00:9CA1 856B            	   338:   sta ASS_OPERAND
00:9CA3 208FCC          	   339:   jsr get_token
00:9CA6 20C29F          	   340:   jsr ass_get_value
00:9CA9 20AB9E          	   341:   jsr ass_check_no_more_tokens
00:9CAC 20BF9D          	   342:   jsr opcode_lookup
00:9CAF 4C599B          	   343:   jmp ass_finish_line
                        	   344: 
                        	   345: ;
                        	   346: ;  indirect, that is: (expression) OR (expression,X) OR (expression),Y
                        	   347: ;
                        	   348: ass_indirect:
00:9CB2 A905            	   349:   lda #ASS_OPERAND_ABSOLUTE_INDIRECT  ; first guess
00:9CB4 856B            	   350:   sta ASS_OPERAND
00:9CB6 208FCC          	   351:   jsr get_token    ; skip the bracket
00:9CB9 8021            	   352:   bra ass_operand_value
                        	   353: 
                        	   354: ;
                        	   355: ;  some sort of identifier, possibly the start of an expression or maybe just "A"
                        	   356: ;
                        	   357: ass_identifier_operand:
                        	   358: 
                        	   359: ;
                        	   360: ;  see if the operand is just the letter "A"
                        	   361: ;
00:9CBB A592            	   362:   lda token_length
00:9CBD C901            	   363:   cmp #1
00:9CBF D01B            	   364:   bne ass_operand_value
00:9CC1 A000            	   365:   ldy #0
00:9CC3 B190            	   366:   lda (token_address),Y
00:9CC5 20A892          	   367:   jsr MAKE_UPPER
00:9CC8 C941            	   368:   cmp #'A'
00:9CCA D010            	   369:   bne ass_operand_value
00:9CCC A906            	   370:   lda #ASS_OPERAND_ACCUMULATOR_A
00:9CCE 856B            	   371:   sta ASS_OPERAND
00:9CD0 208FCC          	   372:   jsr get_token  ; skip past A
00:9CD3 20AB9E          	   373:   jsr ass_check_no_more_tokens
00:9CD6 20BF9D          	   374:   jsr opcode_lookup
00:9CD9 4C599B          	   375:   jmp ass_finish_line
                        	   376: 
                        	   377: ;
                        	   378: ;  a number or identifier - evaluate as an expression
                        	   379: ;
                        	   380: ass_operand_value:
                        	   381: 
00:9CDC A593            	   382:   lda token_type ; get token back
00:9CDE 20C29F          	   383:   jsr ass_get_value  ; should have some sort of address now in VALUE
                        	   384: ;
                        	   385: ;  we come back with the first non-value token loaded in TOKEN
                        	   386: ;  now see if we originally had a bracket, so this must be one of those indirect things
                        	   387: ;
00:9CE1 A56B            	   388:   lda ASS_OPERAND
00:9CE3 C905            	   389:   cmp #ASS_OPERAND_ABSOLUTE_INDIRECT
00:9CE5 D02D            	   390:   bne ass_value_not_indirectJ
00:9CE7 A593            	   391:   lda token_type   ; now we should have a comma or a bracket
00:9CE9 C929            	   392:   cmp #')'
00:9CEB F02F            	   393:   beq ass_indirect_with_bracket
                        	   394: ;
                        	   395: ;  We had an opening bracket but not a closing bracket. Must be a comma then
                        	   396: ;
                        	   397: 
00:9CED A92C            	   398:   lda #','
00:9CEF A220            	   399:   ldx #32  ; ERROR: , expected
00:9CF1 20A1D2          	   400:   jsr CHKTKN
                        	   401: ;
                        	   402: ;  now we must have X
                        	   403: ;
00:9CF4 20589D          	   404:   jsr ass_check_we_have_x_or_y
00:9CF7 901E            	   405:   bcc ass_bad_indirect
00:9CF9 C958            	   406:   cmp #'X'
00:9CFB D01A            	   407:   bne ass_bad_indirect
00:9CFD A902            	   408:   lda #ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
00:9CFF 856B            	   409:   sta ASS_OPERAND
00:9D01 A929            	   410:   lda #')'
00:9D03 A216            	   411:   ldx #22  ; ERROR: ) expected
00:9D05 2091D2          	   412:   jsr GETCHK
00:9D08 208FCC          	   413:   jsr get_token
00:9D0B 20AB9E          	   414:   jsr ass_check_no_more_tokens
00:9D0E 20BF9D          	   415:   jsr opcode_lookup
00:9D11 4C599B          	   416:   jmp ass_finish_line
                        	   417: 
00:9D14 4C769D          	   418: ass_value_not_indirectJ jmp ass_value_not_indirect
                        	   419: 
                        	   420: ass_bad_indirect:
00:9D17 A229            	   421:   ldx #41  ; ERROR: illegal addressing mode
00:9D19 4C95A1          	   422:   jmp ass_error
                        	   423: 
                        	   424: 
                        	   425: ;
                        	   426: ;  we have some sort of indirect expression followed by a bracket, so see if there is ",Y" after it
                        	   427: ;
                        	   428: ass_indirect_with_bracket:
                        	   429: ;
                        	   430: ;  can only be (a), (zp) or (zp),y
                        	   431: ;
00:9D1C 208FCC          	   432:   jsr get_token
00:9D1F C92C            	   433:   cmp #','
00:9D21 F00D            	   434:   beq ass_zp_indirect_indexed
00:9D23 20AB9E          	   435:   jsr ass_check_no_more_tokens
00:9D26 A905            	   436:   lda #ASS_OPERAND_ABSOLUTE_INDIRECT
00:9D28 856B            	   437:   sta ASS_OPERAND
00:9D2A 20BF9D          	   438:   jsr opcode_lookup
00:9D2D 4C599B          	   439:   jmp ass_finish_line
                        	   440: 
                        	   441: 
                        	   442: ;
                        	   443: ;  For indirect followed by a comma, we must have Y and nothing else
                        	   444: ;  Also, the operand must be a zero-page address
                        	   445: ;
                        	   446: ass_zp_indirect_indexed:
00:9D30 20589D          	   447:   jsr ass_check_we_have_x_or_y
00:9D33 90E2            	   448:   bcc ass_bad_indirect
00:9D35 C959            	   449:   cmp #'Y'
00:9D37 D0DE            	   450:   bne ass_bad_indirect
00:9D39 A574            	   451:   lda ASS_VALUE+1
00:9D3B D014            	   452:   bne ass_bad_zp_indirect_indexed
00:9D3D A575            	   453:   lda ASS_VALUE+2
00:9D3F D010            	   454:   bne ass_bad_zp_indirect_indexed
00:9D41 A910            	   455:   lda #ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
00:9D43 856B            	   456:   sta ASS_OPERAND
00:9D45 208FCC          	   457:   jsr get_token  ; skip the Y
00:9D48 20AB9E          	   458:   jsr ass_check_no_more_tokens
00:9D4B 20BF9D          	   459:   jsr opcode_lookup
00:9D4E 4C599B          	   460:   jmp ass_finish_line
                        	   461: 
                        	   462: ass_bad_zp_indirect_indexed:
00:9D51 A22B            	   463:   ldx #43
00:9D53 4C95A1          	   464:   jmp ass_error
                        	   465: 
                        	   466: ass_not_x_or_y:
00:9D56 18              	   467:   clc
00:9D57 60              	   468:   rts
                        	   469: 
                        	   470: ;
                        	   471: ;  we had (<expression>),<something> so check that <something> is X or Y
                        	   472: ;   sets carry if it is
                        	   473: ;
                        	   474: ass_check_we_have_x_or_y:
00:9D58 208FCC          	   475:   jsr get_token
00:9D5B C949            	   476:   cmp #TOKEN_IDENTIFIER
00:9D5D D0F7            	   477:   bne ass_not_x_or_y
00:9D5F A592            	   478:   lda token_length
00:9D61 C901            	   479:   cmp #1
00:9D63 D0F1            	   480:   bne ass_not_x_or_y
00:9D65 A000            	   481:   ldy #0
00:9D67 B190            	   482:   lda (token_address),y
00:9D69 20A892          	   483:   jsr MAKE_UPPER
00:9D6C C959            	   484:   cmp #'Y'
00:9D6E F004            	   485:   beq ass_check_we_have_x_or_y_ok
00:9D70 C958            	   486:   cmp #'X'
00:9D72 D0E2            	   487:   bne ass_not_x_or_y
                        	   488: ass_check_we_have_x_or_y_ok:
00:9D74 38              	   489:   sec
00:9D75 60              	   490:   rts
                        	   491: 
                        	   492: ;
                        	   493: ;  we had a non-indirect expression, so was it followed by a comma?
                        	   494: ;
                        	   495: 
                        	   496: ass_value_not_indirect:
00:9D76 A593            	   497:   lda token_type
00:9D78 C92C            	   498:   cmp #','
00:9D7A F00D            	   499:   beq ass_indexed
00:9D7C A901            	   500:   lda #ASS_OPERAND_ABSOLUTE
00:9D7E 856B            	   501:   sta ASS_OPERAND
                        	   502: ass_value_done:
00:9D80 20AB9E          	   503:   jsr ass_check_no_more_tokens
00:9D83 20BF9D          	   504:   jsr opcode_lookup
00:9D86 4C599B          	   505:   jmp ass_finish_line
                        	   506: 
                        	   507: ;
                        	   508: ;  <expression>,X or <expression>,Y is what we are expecting here
                        	   509: ;
                        	   510: ;  OR: in the case of BBR0 ... BBR7 and BBS0 ... BBS7 : another expression
                        	   511: ;
                        	   512: 
                        	   513: ass_indexed:
                        	   514: ;
                        	   515: ;  save the value in case we find a second one
                        	   516: ;
                        	   517: ;  checking for another one may change VALUE so we do this now
                        	   518: ;
00:9D89 A500            	   519:   lda VALUE
00:9D8B 8506            	   520:   sta REMAIN
00:9D8D A501            	   521:   lda VALUE+1
00:9D8F 8507            	   522:   sta REMAIN+1
00:9D91 A502            	   523:   lda VALUE+2
00:9D93 8508            	   524:   sta REMAIN+2
00:9D95 20589D          	   525:   jsr ass_check_we_have_x_or_y
00:9D98 9016            	   526:   bcc ass_absolute_another_value
00:9D9A C958            	   527:   cmp #'X'
00:9D9C F009            	   528:   beq ass_indexed_x
00:9D9E A904            	   529:   lda #ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
00:9DA0 856B            	   530:   sta ASS_OPERAND
00:9DA2 208FCC          	   531:   jsr get_token ; skip the Y
00:9DA5 80D9            	   532:   bra ass_value_done
                        	   533: ass_indexed_x:
00:9DA7 A903            	   534:   lda #ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
00:9DA9 856B            	   535:   sta ASS_OPERAND
00:9DAB 208FCC          	   536:   jsr get_token ; skip the X
00:9DAE 80D0            	   537:   bra ass_value_done
                        	   538: 
                        	   539: ;
                        	   540: ;  this is hopefully something like BBR0 $42,foo
                        	   541: ;   so we need to evaluate foo
                        	   542: ;
                        	   543: ass_absolute_another_value:
00:9DB0 A593            	   544:   lda token_type ; get token back
00:9DB2 20C29F          	   545:   jsr ass_get_value  ; should have some sort of address now in VALUE
                        	   546: ;  jsr ass_check_no_more_tokens
00:9DB5 A912            	   547:   lda #ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE
00:9DB7 856B            	   548:   sta ASS_OPERAND
00:9DB9 20BF9D          	   549:   jsr opcode_lookup
00:9DBC 4C599B          	   550:   jmp ass_finish_line
                        	   551: 
                        	   552: 
                        	   553: ;
                        	   554: ;  look up opcode
                        	   555: ;
                        	   556: opcode_lookup:
                        	   557:   ; the opcode we are looking up
00:9DBF A56C            	   558:   lda OPCODE
00:9DC1 8500            	   559:   sta SRCE
00:9DC3 A56D            	   560:   lda OPCODE+1
00:9DC5 8501            	   561:   sta SRCE+1
00:9DC7 6472            	   562:   stz ASS_COUNT   ; count of matches
                        	   563: ;
                        	   564: ;  get the address of our table of tables
                        	   565: ;
00:9DC9 A909            	   566:   lda #<OPCODE_LOOKUP_TABLE
00:9DCB 8570            	   567:   sta ASS_OPCODE_WORK
00:9DCD A9A2            	   568:   lda #>OPCODE_LOOKUP_TABLE
00:9DCF 8571            	   569:   sta ASS_OPCODE_WORK+1
                        	   570: opcode_lookup_loop:
00:9DD1 A000            	   571:   ldy #OPCODE_LOOKUP_OPCODE_LENGTH
00:9DD3 B170            	   572:   lda (ASS_OPCODE_WORK),Y       ; get opcode length
00:9DD5 F058            	   573:   beq opcode_lookup_loop_done   ; end of table
00:9DD7 C56E            	   574:   cmp OPCODE_LEN                ; right length?
00:9DD9 F00F            	   575:   beq opcode_lookup_correct_length ; yes
                        	   576: ;
                        	   577: ; no, try the next table item
                        	   578: ;
                        	   579: opcode_lookup_next_table:
00:9DDB 18              	   580:   clc
00:9DDC A570            	   581:   lda ASS_OPCODE_WORK
00:9DDE 6906            	   582:   adc #OPCODE_LOOKUP_TABLE_SIZE  ; onto next item
00:9DE0 8570            	   583:   sta ASS_OPCODE_WORK
00:9DE2 A571            	   584:   lda ASS_OPCODE_WORK+1
00:9DE4 6900            	   585:   adc #0
00:9DE6 8571            	   586:   sta ASS_OPCODE_WORK+1
00:9DE8 80E7            	   587:   bra opcode_lookup_loop
                        	   588: opcode_lookup_correct_length:
00:9DEA A002            	   589:   ldy #OPCODE_LOOKUP_OPCODE_TABLE
00:9DEC B170            	   590:   lda (ASS_OPCODE_WORK),Y ; get table address low-order byte
00:9DEE 8503            	   591:   sta DEST
00:9DF0 C8              	   592:   iny
00:9DF1 B170            	   593:   lda (ASS_OPCODE_WORK),Y ; get table address high-order byte
00:9DF3 8504            	   594:   sta DEST+1
00:9DF5 2033A1          	   595:   jsr ass_lookup_loop
00:9DF8 90E1            	   596:   bcc opcode_lookup_next_table  ; not found
00:9DFA AA              	   597:   tax   ; save the machine code byte
00:9DFB E672            	   598:   inc ASS_COUNT
00:9DFD A001            	   599:   ldy #OPCODE_LOOKUP_OPERAND_TYPE
00:9DFF A56B            	   600:   lda ASS_OPERAND         ; get wanted type of operand?
00:9E01 D170            	   601:   cmp (ASS_OPCODE_WORK),Y ; compare to operand type in table
00:9E03 F013            	   602:   beq opcode_lookup_correct_operand  ; yes
00:9E05 C906            	   603:   cmp #ASS_OPERAND_ACCUMULATOR_A  ; see if in range 1 to 5
00:9E07 B0D2            	   604:   bcs opcode_lookup_next_table
                        	   605: ;
                        	   606: ;  so if we have a so-called ASS_OPERAND_ABSOLUTE (with various indexing modes)
                        	   607: ;  see if we can match on ASS_OPERAND_ZERO_PAGE by adding 10 to the operand type
                        	   608: ;  - also applies to all the absolute modes (1 to 5)
                        	   609: ;
00:9E09 18              	   610:   clc
00:9E0A 690A            	   611:   adc #10
00:9E0C D170            	   612:   cmp (ASS_OPCODE_WORK),Y
00:9E0E D0CB            	   613:   bne opcode_lookup_next_table
                        	   614: ;
                        	   615: ;  plus, the operand has to be in the zero page
                        	   616: ;
00:9E10 A574            	   617:   lda ASS_VALUE+1
00:9E12 D0C7            	   618:   bne opcode_lookup_next_table
00:9E14 A575            	   619:   lda ASS_VALUE+2
00:9E16 D0C3            	   620:   bne opcode_lookup_next_table
                        	   621: opcode_lookup_correct_operand:
00:9E18 8A              	   622:   txa   ; get the byte to emit back
                        	   623: 
                        	   624: ;
                        	   625: ; we have a match! emit the opcode
                        	   626: ;
00:9E19 2057A1          	   627:   jsr ass_emit            ; emit it
00:9E1C A004            	   628:   ldy #OPCODE_LOOKUP_HANDLER  ; offset of handler
00:9E1E B170            	   629:   lda (ASS_OPCODE_WORK),Y ; get opcode handler address low-order byte
00:9E20 AA              	   630:   tax
00:9E21 C8              	   631:   iny
00:9E22 B170            	   632:   lda (ASS_OPCODE_WORK),Y ; get opcode handler address high-order byte
00:9E24 F008            	   633:   beq opcode_lookup_no_handler
00:9E26 8571            	   634:   sta ASS_OPCODE_WORK+1
00:9E28 8A              	   635:   txa
00:9E29 8570            	   636:   sta ASS_OPCODE_WORK
00:9E2B 6C7000          	   637:   jmp (ASS_OPCODE_WORK)   ; do handler - it will RTS for us
                        	   638: 
                        	   639: opcode_lookup_no_handler:
                        	   640: ; put nothing here as it won't be done if there is a handler
00:9E2E 60              	   641:   rts    ; done!
                        	   642: 
                        	   643: opcode_lookup_loop_done:
                        	   644: ;
                        	   645: ;  look for assembler directives
                        	   646: ;
00:9E2F A9AC            	   647:   lda #<DIRECTIVES
00:9E31 8503            	   648:   sta DEST
00:9E33 A9A2            	   649:   lda #>DIRECTIVES
00:9E35 8504            	   650:   sta DEST+1
00:9E37 A56E            	   651:   lda OPCODE_LEN
                        	   652: 
                        	   653: ;  pha
                        	   654: ;   lda #'c'
                        	   655: ;   jsr ass_debug_point
                        	   656: ;   pla
                        	   657: 
00:9E39 20EE91          	   658:   jsr handlerLookup
00:9E3C 9029            	   659:   bcc opcode_lookup_ok
                        	   660: 
                        	   661: ;   lda #'d'
                        	   662: ;   jsr ass_debug_point
                        	   663: 
                        	   664: ;
                        	   665: ;  here for unknown opcode
                        	   666: ;
00:9E3E A56C            	   667:   lda OPCODE
00:9E40 8590            	   668:   sta token_address
00:9E42 A56D            	   669:   lda OPCODE+1
00:9E44 8591            	   670:   sta token_address+1
00:9E46 A56E            	   671:   lda OPCODE_LEN
00:9E48 8592            	   672:   sta token_length
                        	   673: 
                        	   674: ;
                        	   675: ;  if we NEVER found a match, this is an illegal opcode
                        	   676: ;
00:9E4A A921            	   677:   lda #'!'
00:9E4C 209A96          	   678:   jsr COUT
00:9E4F A66E            	   679:   ldx OPCODE_LEN
00:9E51 A000            	   680:   ldy #0
                        	   681: wtf_loop:
00:9E53 B16C            	   682:    lda (OPCODE),Y
00:9E55 209A96          	   683:    jsr COUT
00:9E58 C8              	   684:    iny
00:9E59 CA              	   685:    dex
00:9E5A D0F7            	   686:    bne wtf_loop
                        	   687: 
                        	   688: 
00:9E5C A228            	   689:   ldx  #40    ; illegal opcode
00:9E5E A572            	   690:   lda ASS_COUNT
00:9E60 F002            	   691:   beq opcode_lookup_loop_unknown
                        	   692: ;
                        	   693: ;  if we found a match, but not for this addressing mode, they used an illegal mode
                        	   694: ;
00:9E62 A229            	   695:   ldx  #41   ; illegal addressing mode
                        	   696: opcode_lookup_loop_unknown:
00:9E64 4C95A1          	   697:   JMP  ass_error
                        	   698: 
                        	   699: opcode_lookup_ok:
                        	   700: 
                        	   701: ;   lda #'e'
                        	   702: ; jsr ass_debug_point
                        	   703: 
00:9E67 60              	   704:   rts
                        	   705: 
                        	   706: ass_done:
00:9E68 200C95          	   707:   jsr  CROUT
00:9E6B A576            	   708:   LDA  ASS_PASS
00:9E6D D003            	   709:   bne  ass_done_second_pass
00:9E6F 4C3A9B          	   710:   jmp  ASSEMBLE_SECOND_PASS
                        	   711: ass_done_second_pass:
00:9E72 A98D            	   712:   LDA  #<ass_done_message  ; Assemble finished: No Errors
00:9E74 A29E            	   713:   LDX  #>ass_done_message
00:9E76 202682          	   714:   JSR  print
00:9E79 A910            	   715:   lda  #FLAG_VALID_ASSEMBLE
00:9E7B 04BE            	   716:   tsb  system_flags
00:9E7D 20358F          	   717:   jsr  show_symbol_table_end
00:9E80 205A8F          	   718:   jsr  show_source_end
00:9E83 A582            	   719:   lda  show_symbols
00:9E85 F003            	   720:   beq  ass_done1
00:9E87 2050A8          	   721:   jsr  list_symbols
                        	   722: ass_done1:
00:9E8A 4C7282          	   723:   JMP  main_prompt
                        	   724: 
00:9E8D 417373656D626C65	   725: ass_done_message asciiz "Assemble finished: No errors\n"
00:9E95 2066696E69736865
00:9E9D 643A204E6F206572
00:9EA5 726F72730A
00:9EAA 00
                        	   726: 
                        	   727: ass_check_no_more_tokens:
00:9EAB A593            	   728:   lda token_type
00:9EAD C90A            	   729:   cmp #NL           ; or end of line?
00:9EAF F005            	   730:   beq ass_check_no_more_tokens_ok
00:9EB1 A213            	   731:   ldx #19    ; ERROR: incorrect symbol
00:9EB3 4C95A1          	   732:   jmp ass_error
                        	   733: 
                        	   734: ass_check_no_more_tokens_ok:
00:9EB6 60              	   735:   rts
                        	   736: 
                        	   737: ;
                        	   738: ;  push a 3-byte value (in VALUE) onto the evaluation stack
                        	   739: ;    changes A and Y
                        	   740: ;
                        	   741: exp_push_value = *
00:9EB7 A57B            	   742:   lda exp_value_stack_count
00:9EB9 C9FF            	   743:   cmp #$FF
00:9EBB D005            	   744:   bne exp_push_value_ok
                        	   745: exp_push_value_memory_full:
00:9EBD A22E            	   746:   ldx #46   ; ERROR: Expression too complex
00:9EBF 4C95A1          	   747:   jmp ass_error
                        	   748: exp_push_value_ok:
00:9EC2 E67B            	   749:   inc exp_value_stack_count
00:9EC4 38              	   750:   sec
00:9EC5 A579            	   751:   lda exp_value_stack
00:9EC7 E903            	   752:   sbc #3
00:9EC9 8579            	   753:   sta exp_value_stack
00:9ECB A57A            	   754:   lda exp_value_stack+1
00:9ECD E900            	   755:   sbc #0
00:9ECF 857A            	   756:   sta exp_value_stack+1
                        	   757: ;
                        	   758: ;  has our expression value fallen down into our P-codes?
                        	   759: ;
                        	   760: ;  This doesn't work if the output (PCODE) has been relocated to above
                        	   761: ;  the symbol table and I can't think of an easy solution, so let's ignore
                        	   762: ;  it and hope it doesn't happen.
                        	   763: ;
                        	   764: ;
                        	   765: ; lda  PCODE+1               ; see if P-codes full
                        	   766: ; cmp  exp_value_stack+1     ; in other words, have we hit the symbol table?
                        	   767: ; bcc  exp_push_value_not_full      ; less than
                        	   768: ; bne  exp_push_value_memory_full   ; greater than
                        	   769: ; lda  PCODE
                        	   770: ; cmp  exp_value_stack
                        	   771: ; bcs  exp_push_value_memory_full   ; BGE
                        	   772: 
                        	   773: exp_push_value_not_full:
00:9ED1 A000            	   774:   ldy #0
00:9ED3 A500            	   775:   lda VALUE
00:9ED5 9179            	   776:   sta (exp_value_stack),y
00:9ED7 C8              	   777:   iny
00:9ED8 A501            	   778:   lda VALUE+1
00:9EDA 9179            	   779:   sta (exp_value_stack),y
00:9EDC C8              	   780:   iny
00:9EDD A502            	   781:   lda VALUE+2
00:9EDF 9179            	   782:   sta (exp_value_stack),y
00:9EE1 60              	   783:   rts
                        	   784: 
                        	   785: ;
                        	   786: ;  pop a 3-byte value (into VALUE) from the evaluation stack
                        	   787: ;    changes A and Y
                        	   788: ;
                        	   789: exp_pop_value = *
00:9EE2 A57B            	   790:   lda exp_value_stack_count
00:9EE4 D005            	   791:   bne exp_pop_value_ok
00:9EE6 A217            	   792:   ldx #23    ; ERROR: illegal factor
00:9EE8 4C95A1          	   793:   jmp ass_error
                        	   794: exp_pop_value_ok:
00:9EEB C67B            	   795:   dec exp_value_stack_count
00:9EED A000            	   796:   ldy #0
00:9EEF B179            	   797:   lda (exp_value_stack),y
00:9EF1 8500            	   798:   sta VALUE
00:9EF3 C8              	   799:   iny
00:9EF4 B179            	   800:   lda (exp_value_stack),y
00:9EF6 8501            	   801:   sta VALUE+1
00:9EF8 C8              	   802:   iny
00:9EF9 B179            	   803:   lda (exp_value_stack),y
00:9EFB 8502            	   804:   sta VALUE+2
00:9EFD 18              	   805:   clc
00:9EFE A579            	   806:   lda exp_value_stack
00:9F00 6903            	   807:   adc #3
00:9F02 8579            	   808:   sta exp_value_stack
00:9F04 A57A            	   809:   lda exp_value_stack+1
00:9F06 6900            	   810:   adc #0
00:9F08 857A            	   811:   sta exp_value_stack+1
00:9F0A 60              	   812:   rts
                        	   813: 
                        	   814: ;
                        	   815: ;  I needed a work area for operators, and initially used INBUF however that got
                        	   816: ;  repurposed for managing strings (in particular handling \Xnn and double quotes)
                        	   817: ;  so now I am using the memory at the current PCODE address as a work area.
                        	   818: ;  It is only needed during expression evaluation, and should hopefully be available.
                        	   819: ;
                        	   820: ;
                        	   821: ;  push an operator (A) onto the operator stack
                        	   822: ;   changes X and Y
                        	   823: ;
                        	   824: exp_push_operator:
00:9F0B A67C            	   825:   ldx exp_operator_stack_count
00:9F0D E0FA            	   826:   cpx #250  ; make sure we don't overflow our operator stack
00:9F0F 9005            	   827:   bcc exp_push_operator_ok
00:9F11 A22E            	   828:   ldx #46   ; ERROR: Expression too complex
00:9F13 4C95A1          	   829:   jmp ass_error
                        	   830: exp_push_operator_ok:
00:9F16 E67C            	   831:   inc exp_operator_stack_count  ; add, then store
00:9F18 A47C            	   832:   ldy exp_operator_stack_count
00:9F1A 9123            	   833:   sta (PCODE),Y
00:9F1C 60              	   834:   rts
                        	   835: 
                        	   836: ;
                        	   837: ;  pop an operator (into A) from the operator stack
                        	   838: ;   changes X and Y
                        	   839: ;
                        	   840: exp_pop_operator:
00:9F1D A67C            	   841:   ldx exp_operator_stack_count
00:9F1F D005            	   842:   bne exp_pop_operator_ok
00:9F21 A217            	   843:   ldx #23   ; ERROR: Illegal factor
00:9F23 4C95A1          	   844:   jmp ass_error
                        	   845: exp_pop_operator_ok:
00:9F26 A47C            	   846:   ldy exp_operator_stack_count  ; retrieve, then decrement
00:9F28 B123            	   847:   lda (PCODE),Y
00:9F2A C67C            	   848:   dec exp_operator_stack_count
00:9F2C 60              	   849:   rts
                        	   850: 
                        	   851: ;
                        	   852: ;  get an operator (into A) from the operator stack (without removing it)
                        	   853: ;   changes X and Y
                        	   854: ;
                        	   855: exp_get_operator:
00:9F2D A67C            	   856:   ldx exp_operator_stack_count
00:9F2F D005            	   857:   bne exp_get_operator_ok
00:9F31 A217            	   858:   ldx #23   ; ERROR: Illegal factor
00:9F33 4C95A1          	   859:   jmp ass_error
                        	   860: exp_get_operator_ok:
00:9F36 A47C            	   861:   ldy exp_operator_stack_count
00:9F38 B123            	   862:   lda (PCODE),Y
00:9F3A 60              	   863:   rts
                        	   864: 
                        	   865:  .macro makePrecedenceTable ; table of operators, precedence, handler
                        	   866:    dfb   \1
                        	   867:    dfb   \2
                        	   868:    word  \3
                        	   869:  .endmacro
                        	   870: 
                        	   871: ; cannot have more than 64 entries because we index into this with X
                        	   872: exp_precedence_table:
                        	   873:   makePrecedenceTable '~', 1, exp_negate
00:9F3B 7E              	     1M    dfb   '~'
00:9F3C 01              	     2M    dfb   1
00:9F3D E8AE            	     3M    word  exp_negate
                        	   874:   makePrecedenceTable '!', 1, exp_not
00:9F3F 21              	     1M    dfb   '!'
00:9F40 01              	     2M    dfb   1
00:9F41 FBAE            	     3M    word  exp_not
                        	   875:   makePrecedenceTable TOKEN_UNARY_MINUS, 1, exp_unary_minus
00:9F43 4D              	     1M    dfb   TOKEN_UNARY_MINUS
00:9F44 01              	     2M    dfb   1
00:9F45 09AF            	     3M    word  exp_unary_minus
                        	   876:   makePrecedenceTable TOKEN_LOW_BYTE, 1, exp_low_byte
00:9F47 56              	     1M    dfb   TOKEN_LOW_BYTE
00:9F48 01              	     2M    dfb   1
00:9F49 1DAF            	     3M    word  exp_low_byte
                        	   877:   makePrecedenceTable TOKEN_HIGH_BYTE, 1, exp_high_byte
00:9F4B 57              	     1M    dfb   TOKEN_HIGH_BYTE
00:9F4C 01              	     2M    dfb   1
00:9F4D 22AF            	     3M    word  exp_high_byte
                        	   878:   makePrecedenceTable TOKEN_SHIFT_LEFT, 2, exp_shift_left
00:9F4F 4C              	     1M    dfb   TOKEN_SHIFT_LEFT
00:9F50 02              	     2M    dfb   2
00:9F51 B6AE            	     3M    word  exp_shift_left
                        	   879:   makePrecedenceTable TOKEN_SHIFT_RIGHT, 2, exp_shift_right
00:9F53 52              	     1M    dfb   TOKEN_SHIFT_RIGHT
00:9F54 02              	     2M    dfb   2
00:9F55 CFAE            	     3M    word  exp_shift_right
                        	   880:   makePrecedenceTable '&', 3, exp_bitwise_and
00:9F57 26              	     1M    dfb   '&'
00:9F58 03              	     2M    dfb   3
00:9F59 65AE            	     3M    word  exp_bitwise_and
                        	   881:   makePrecedenceTable '^', 4, exp_bitwise_xor
00:9F5B 5E              	     1M    dfb   '^'
00:9F5C 04              	     2M    dfb   4
00:9F5D 7AAE            	     3M    word  exp_bitwise_xor
                        	   882:   makePrecedenceTable '|', 5, exp_bitwise_or
00:9F5F 7C              	     1M    dfb   '|'
00:9F60 05              	     2M    dfb   5
00:9F61 50AE            	     3M    word  exp_bitwise_or
                        	   883:   makePrecedenceTable '*', 6, exp_multiply
00:9F63 2A              	     1M    dfb   '*'
00:9F64 06              	     2M    dfb   6
00:9F65 90AF            	     3M    word  exp_multiply
                        	   884:   makePrecedenceTable '/', 6, exp_divide
00:9F67 2F              	     1M    dfb   '/'
00:9F68 06              	     2M    dfb   6
00:9F69 C9AF            	     3M    word  exp_divide
                        	   885:   makePrecedenceTable '%', 6, exp_modulo
00:9F6B 25              	     1M    dfb   '%'
00:9F6C 06              	     2M    dfb   6
00:9F6D 29B0            	     3M    word  exp_modulo
                        	   886:   makePrecedenceTable '+', 7, exp_add
00:9F6F 2B              	     1M    dfb   '+'
00:9F70 07              	     2M    dfb   7
00:9F71 C2AD            	     3M    word  exp_add
                        	   887:   makePrecedenceTable '-', 7, exp_subtract
00:9F73 2D              	     1M    dfb   '-'
00:9F74 07              	     2M    dfb   7
00:9F75 D6AD            	     3M    word  exp_subtract
                        	   888:   makePrecedenceTable '<', 8, exp_less_than
00:9F77 3C              	     1M    dfb   '<'
00:9F78 08              	     2M    dfb   8
00:9F79 24AE            	     3M    word  exp_less_than
                        	   889:   makePrecedenceTable '>', 8, exp_greater_than
00:9F7B 3E              	     1M    dfb   '>'
00:9F7C 08              	     2M    dfb   8
00:9F7D 2BAE            	     3M    word  exp_greater_than
                        	   890:   makePrecedenceTable TOKEN_LEQ, 8, exp_leq
00:9F7F 80              	     1M    dfb   TOKEN_LEQ
00:9F80 08              	     2M    dfb   8
00:9F81 3AAE            	     3M    word  exp_leq
                        	   891:   makePrecedenceTable TOKEN_GEQ, 8, exp_geq
00:9F83 81              	     1M    dfb   TOKEN_GEQ
00:9F84 08              	     2M    dfb   8
00:9F85 49AE            	     3M    word  exp_geq
                        	   892:   makePrecedenceTable TOKEN_EQUALITY, 9, exp_eql
00:9F87 45              	     1M    dfb   TOKEN_EQUALITY
00:9F88 09              	     2M    dfb   9
00:9F89 FCAD            	     3M    word  exp_eql
                        	   893:   makePrecedenceTable TOKEN_NEQ, 9, exp_neq     ; <>
00:9F8B 55              	     1M    dfb   TOKEN_NEQ
00:9F8C 09              	     2M    dfb   9
00:9F8D 10AE            	     3M    word  exp_neq     
                        	   894:   makePrecedenceTable TOKEN_INEQUALITY, 9, exp_neq  ; !=
00:9F8F 5A              	     1M    dfb   TOKEN_INEQUALITY
00:9F90 09              	     2M    dfb   9
00:9F91 10AE            	     3M    word  exp_neq  
                        	   895:   makePrecedenceTable TOKEN_LOGICAL_AND, 10, exp_logical_and
00:9F93 58              	     1M    dfb   TOKEN_LOGICAL_AND
00:9F94 0A              	     2M    dfb   10
00:9F95 A4AE            	     3M    word  exp_logical_and
                        	   896:   makePrecedenceTable TOKEN_LOGICAL_OR, 11, exp_logical_or
00:9F97 59              	     1M    dfb   TOKEN_LOGICAL_OR
00:9F98 0B              	     2M    dfb   11
00:9F99 95AE            	     3M    word  exp_logical_or
                        	   897: 
                        	   898: exp_precedence_table_end = *
                        	   899: 
                        	   900: ;
                        	   901: ;  finds precedence of operator in A, returns it in Y (returns 0 if not found)
                        	   902: ;    changes X, A
                        	   903: ;  also stores the operator evaluation function (eg. exp_add) in exp_evaluation_function
                        	   904: ;
                        	   905: exp_get_precedence:
00:9F9B A200            	   906:   ldx #0
                        	   907: exp_get_precedence_loop:
00:9F9D DD3B9F          	   908:   cmp exp_precedence_table,x
00:9FA0 F00F            	   909:   beq exp_get_precedence_found
00:9FA2 E8              	   910:   inx   ; skip operator
00:9FA3 E8              	   911:   inx   ; skip precedence
00:9FA4 E8              	   912:   inx   ; skip evaluation function
00:9FA5 E8              	   913:   inx   ;  (2 bytes)
00:9FA6 E060            	   914:   cpx #exp_precedence_table_end - exp_precedence_table
00:9FA8 90F3            	   915:   bcc exp_get_precedence_loop
00:9FAA A000            	   916:   ldy #0
00:9FAC 647F            	   917:   stz exp_evaluation_function
00:9FAE 6480            	   918:   stz exp_evaluation_function+1
00:9FB0 60              	   919:   rts
                        	   920: exp_get_precedence_found:
00:9FB1 E8              	   921:   inx
00:9FB2 BC3B9F          	   922:   ldy exp_precedence_table,x
00:9FB5 E8              	   923:   inx
00:9FB6 BD3B9F          	   924:   lda exp_precedence_table,x
00:9FB9 857F            	   925:   sta exp_evaluation_function
00:9FBB E8              	   926:   inx
00:9FBC BD3B9F          	   927:   lda exp_precedence_table,x
00:9FBF 8580            	   928:   sta exp_evaluation_function+1
00:9FC1 60              	   929:   rts
                        	   930: 
                        	   931: ;
                        	   932: ;  Convert an expression into a value
                        	   933: ;
                        	   934: ;   Ideas from https://www.geeksforgeeks.org/expression-evaluation/
                        	   935: ;
                        	   936: ass_get_value:
                        	   937: ;
                        	   938: ;  set up expression evaluation stack
                        	   939: ;
00:9FC2 647B            	   940:   stz exp_value_stack_count
00:9FC4 647C            	   941:   stz exp_operator_stack_count
00:9FC6 A531            	   942:   lda ENDSYM
00:9FC8 8579            	   943:   sta exp_value_stack
00:9FCA A532            	   944:   lda ENDSYM+1
00:9FCC 857A            	   945:   sta exp_value_stack+1
                        	   946: 
00:9FCE 6473            	   947:   stz ASS_VALUE
00:9FD0 6474            	   948:   stz ASS_VALUE+1
00:9FD2 6475            	   949:   stz ASS_VALUE+2
00:9FD4 A901            	   950:   lda #1
00:9FD6 8581            	   951:   sta exp_unary_ok  ; unary operators can appear at the start of the expression
00:9FD8 A593            	   952:   lda token_type
                        	   953: ;  jsr START_TRACE
                        	   954: ;
                        	   955: ;  one token lookahead
                        	   956: ;
00:9FDA 8003            	   957:   bra ass_expression_loop_initial
                        	   958: 
                        	   959: ;
                        	   960: ;  1.1 Get the next token
                        	   961: ;
                        	   962: ass_expression_loop:
00:9FDC 208FCC          	   963:   jsr get_token
                        	   964: ass_expression_loop_initial:
                        	   965: 
                        	   966: ;
                        	   967: ;  1.2.1 If it's a number, push onto the value stack
                        	   968: ;
00:9FDF C94E            	   969:   cmp #TOKEN_NUMBER
00:9FE1 D013            	   970:   bne ass_expression_loop1a
                        	   971: ass_expression_number:
00:9FE3 A594            	   972:   lda token_value
00:9FE5 8500            	   973:   sta VALUE
00:9FE7 A595            	   974:   lda token_value+1
00:9FE9 8501            	   975:   sta VALUE+1
00:9FEB A596            	   976:   lda token_value+2
00:9FED 8502            	   977:   sta VALUE+2
00:9FEF 20B79E          	   978:   jsr exp_push_value
00:9FF2 6481            	   979:   stz exp_unary_ok          ; don't have unary operators after numbers
00:9FF4 80E6            	   980:   bra ass_expression_loop
                        	   981: ;
                        	   982: ;  if it's a string and only 1 or 2 bytes, consider as a number
                        	   983: ;
                        	   984: ass_expression_loop1a:
00:9FF6 C922            	   985:   cmp #TOKEN_STRING
00:9FF8 D013            	   986:   bne ass_expression_loop1
00:9FFA A592            	   987:   lda token_length
00:9FFC C903            	   988:   cmp #3
00:9FFE B008            	   989:   bcs ass_expression_not_small_string  ; too long?
                        	   990: ;
                        	   991: ;  one or two character string - is this an immediate operand?
                        	   992: ;
00:A000 A56B            	   993:   lda ASS_OPERAND
00:A002 C907            	   994:   cmp #ASS_OPERAND_IMMEDIATE
00:A004 D002            	   995:   bne ass_expression_not_small_string
00:A006 80DB            	   996:   bra ass_expression_number   ; treat as a number (its value should be in VALUE)
                        	   997: 
                        	   998: ass_expression_not_small_string:
00:A008 A21D            	   999:   ldx #29     ; string literal too big
00:A00A 4C95A1          	  1000:   jmp ass_error
                        	  1001: 
                        	  1002: ;
                        	  1003: ;  1.2.2 If it's an identifier, get its value and push onto the value stack
                        	  1004: ;
                        	  1005: ass_expression_loop1:
00:A00D C949            	  1006:   cmp #TOKEN_IDENTIFIER
00:A00F D029            	  1007:   bne ass_expression_loop2
00:A011 6481            	  1008:   stz exp_unary_ok          ; don't have unary operators after identifiers
                        	  1009: 
00:A013 2013BC          	  1010:   jsr SEARCH    ; should be in symbol table as a constant, and the value in VALUE
00:A016 D011            	  1011:   bne ass_expression_found_value
00:A018 A576            	  1012:   lda ASS_PASS
00:A01A F005            	  1013:   beq ass_label_not_found_yet
                        	  1014: 
                        	  1015: ;
                        	  1016: ; it's an error if it isn't there on the second pass
                        	  1017: ;
00:A01C A20B            	  1018:   ldx #11  ; ERROR: Undeclared Identifier
00:A01E 4C95A1          	  1019:   jmp ass_error
                        	  1020: 
                        	  1021: ;
                        	  1022: ;  label not found on first pass, make the value 0x6666 for now
                        	  1023: ;   - we don't want a zero-page address assumption because that
                        	  1024: ;     will throw out opcode lengths (it might assume a zero page opcode
                        	  1025: ;     which is shorter and then change it to a longer one)
                        	  1026: ;
                        	  1027: ass_label_not_found_yet:
00:A021 A966            	  1028:   lda #$66
00:A023 8500            	  1029:   sta VALUE
00:A025 8501            	  1030:   sta VALUE+1
00:A027 6402            	  1031:   stz VALUE+2
                        	  1032: ass_expression_found_value:
00:A029 A594            	  1033:   lda token_value
00:A02B 8500            	  1034:   sta VALUE
00:A02D A595            	  1035:   lda token_value+1
00:A02F 8501            	  1036:   sta VALUE+1
00:A031 A596            	  1037:   lda token_value+2
00:A033 8502            	  1038:   sta VALUE+2
00:A035 20B79E          	  1039:   jsr exp_push_value
00:A038 80A2            	  1040:   bra ass_expression_loop
                        	  1041: 
                        	  1042: ;
                        	  1043: ; 1.2.3 If it's a left parenthesis: push it onto the operator stack.
                        	  1044: ;
                        	  1045: ass_expression_loop2:
00:A03A C928            	  1046:   cmp #'('
00:A03C D00B            	  1047:   bne ass_expression_loop3
00:A03E 48              	  1048:   pha
00:A03F A901            	  1049:   lda  #1
00:A041 8581            	  1050:   sta exp_unary_ok          ; unary operators can follow left parentheses
00:A043 68              	  1051:   pla
                        	  1052: 
00:A044 200B9F          	  1053:   jsr exp_push_operator
00:A047 8093            	  1054:   bra ass_expression_loop
                        	  1055: 
                        	  1056: ;
                        	  1057: ;  1.2.4 A right parenthesis:
                        	  1058: ;       1 While the thing on top of the operator stack is not a
                        	  1059: ;         left parenthesis,
                        	  1060: ;           1 Pop the operator from the operator stack.
                        	  1061: ;           2 Pop the value stack twice, getting two operands.
                        	  1062: ;           3 Apply the operator to the operands, in the correct order.
                        	  1063: ;           4 Push the result onto the value stack.
                        	  1064: ;        2 Pop the left parenthesis from the operator stack, and discard it.
                        	  1065: 
                        	  1066: 
                        	  1067: ass_expression_loop3:
00:A049 C929            	  1068:   cmp #')'
00:A04B D016            	  1069:   bne ass_expression_loop4
                        	  1070: ass_expression_loop3b:
                        	  1071: ;
                        	  1072: ;  a RH parenthesis with an empty operator stack is probably the end of the expression, eg. ($1234),x
                        	  1073: ;  where the ")" belongs to the indexed operand stuff and not the expression
                        	  1074: ;
00:A04D A57C            	  1075:   lda exp_operator_stack_count
00:A04F F078            	  1076:   beq exp_no_operators_left
00:A051 202D9F          	  1077:   jsr exp_get_operator
00:A054 C928            	  1078:   cmp #'('
00:A056 F005            	  1079:   beq ass_expression_loop3c
                        	  1080: ;
                        	  1081: ;  not a left parenthesis
                        	  1082: ;
                        	  1083: ass_expression_loop3a:
00:A058 20EFA0          	  1084:   jsr ass_expression_apply_operator ; pop the operator and two values, apply the operator and push the result
00:A05B 80F0            	  1085:   bra ass_expression_loop3b          ; keep going until we don't have a left parenthesis
                        	  1086: 
                        	  1087: ass_expression_loop3c:
00:A05D 201D9F          	  1088:   jsr exp_pop_operator              ;  2 Pop the left parenthesis from the operator stack, and discard it.
                        	  1089: ass_expression_loopJ:
00:A060 4CDC9F          	  1090:   jmp ass_expression_loop
                        	  1091: 
                        	  1092: ;       1.2.5 An operator (call it thisOp):
                        	  1093: ;         1 While the operator stack is not empty, and the top thing on the
                        	  1094: ;           operator stack has the same or greater precedence as thisOp,
                        	  1095: ;           1 Pop the operator from the operator stack.
                        	  1096: ;           2 Pop the value stack twice, getting two operands.
                        	  1097: ;           3 Apply the operator to the operands, in the correct order.
                        	  1098: ;           4 Push the result onto the value stack.
                        	  1099: ;         2 Push thisOp onto the operator stack.
                        	  1100: 
                        	  1101: ass_expression_loop4:
                        	  1102: ;
                        	  1103: ;  look for unary operators
                        	  1104: ;
00:A063 A681            	  1105:   ldx exp_unary_ok
00:A065 F034            	  1106:   beq ass_expression_cannot_be_unary
00:A067 C92D            	  1107:   cmp #'-'
00:A069 D006            	  1108:   bne ass_not_unary_minus
00:A06B A94D            	  1109:   lda #TOKEN_UNARY_MINUS
00:A06D 8593            	  1110:   sta token_type
00:A06F 802A            	  1111:   bra ass_expression_cannot_be_unary
                        	  1112: ass_not_unary_minus:
00:A071 C93C            	  1113:   cmp #'<'
00:A073 D006            	  1114:   bne ass_not_unary_less_than
00:A075 A956            	  1115:   lda #TOKEN_LOW_BYTE
00:A077 8593            	  1116:   sta token_type
00:A079 8020            	  1117:   bra ass_expression_cannot_be_unary
                        	  1118: ass_not_unary_less_than:
00:A07B C93E            	  1119:   cmp #'>'
00:A07D D006            	  1120:   bne ass_not_unary_greater_than
00:A07F A957            	  1121:   lda #TOKEN_HIGH_BYTE
00:A081 8593            	  1122:   sta token_type
00:A083 8000            	  1123:   bra ass_not_unary_greater_than
                        	  1124: ass_not_unary_greater_than:
00:A085 C92A            	  1125:   cmp #'*'
00:A087 D012            	  1126:   bne ass_expression_cannot_be_unary
                        	  1127: ;
                        	  1128: ;  A '*' where a unary expression is allowed will be the current emit address (eg. foo = *)
                        	  1129: ;
00:A089 A523            	  1130:   lda PCODE
00:A08B 8594            	  1131:   sta token_value
00:A08D A524            	  1132:   lda PCODE+1
00:A08F 8595            	  1133:   sta token_value+1
00:A091 6496            	  1134:   stz token_value+2
00:A093 6481            	  1135:   stz exp_unary_ok          ; don't have unary operators after numbers
00:A095 A94E            	  1136:   lda #TOKEN_NUMBER
00:A097 8593            	  1137:   sta token_type            ; make get_token think a sign as a token on its own
00:A099 808E            	  1138:   bra ass_expression_found_value
                        	  1139: 
                        	  1140: ass_expression_cannot_be_unary:
00:A09B 48              	  1141:   pha
00:A09C A901            	  1142:   lda #1
00:A09E 8581            	  1143:   sta exp_unary_ok          ; can have unary operators after operators
00:A0A0 68              	  1144:   pla
                        	  1145: 
00:A0A1 209B9F          	  1146:   jsr exp_get_precedence
00:A0A4 847E            	  1147:   sty exp_operator_precedence ; thisOp's precedence
00:A0A6 C000            	  1148:   cpy #0
00:A0A8 F01F            	  1149:   beq exp_no_operators_left
                        	  1150: 
                        	  1151: ass_expression_loop7:         ; 1 While the operator stack is not empty
00:A0AA A57C            	  1152:   lda exp_operator_stack_count
00:A0AC F013            	  1153:   beq ass_expression_loop6    ; stack empty
00:A0AE 202D9F          	  1154:   jsr exp_get_operator    ; find the top thing on the operator stack
00:A0B1 C928            	  1155:   cmp #'('                ; if a bracket, consider that low precedence
00:A0B3 F00C            	  1156:   beq ass_expression_loop6
00:A0B5 209B9F          	  1157:   jsr exp_get_precedence  ; and its precedence
00:A0B8 C47E            	  1158:   cpy exp_operator_precedence
00:A0BA B005            	  1159:   bcs ass_expression_loop6  ; thing on top has less precedence (a higher value) than thisOp
00:A0BC 20EFA0          	  1160:   jsr ass_expression_apply_operator  ; pop the operator and two values, apply the operator and push the result
00:A0BF 80E9            	  1161:   bra ass_expression_loop7
                        	  1162: 
                        	  1163: ass_expression_loop6:
00:A0C1 A593            	  1164:   lda token_type       ; thisOp
00:A0C3 200B9F          	  1165:   jsr exp_push_operator
00:A0C6 4CDC9F          	  1166:   jmp ass_expression_loop
                        	  1167: 
                        	  1168: 
                        	  1169: ; 2. While the operator stack is not empty,
                        	  1170: ;     1 Pop the operator from the operator stack.
                        	  1171: ;     2 Pop the value stack twice, getting two operands.
                        	  1172: ;     3 Apply the operator to the operands, in the correct order.
                        	  1173: ;     4 Push the result onto the value stack.
                        	  1174: 
                        	  1175: 
                        	  1176: exp_no_operators_left:
00:A0C9 A57C            	  1177:     lda exp_operator_stack_count
00:A0CB F005            	  1178:     beq exp_done
00:A0CD 20EFA0          	  1179:     jsr ass_expression_apply_operator ; pop the operator and two values, apply the operator and push the result
00:A0D0 80F7            	  1180:     bra exp_no_operators_left
                        	  1181: 
                        	  1182: exp_done:
00:A0D2 A57B            	  1183:       lda exp_value_stack_count
00:A0D4 C901            	  1184:       cmp #1
00:A0D6 F005            	  1185:       beq exp_done_ok
                        	  1186: exp_done_error:
00:A0D8 A217            	  1187:       ldx #23       ; ERROR: Illegal factor
00:A0DA 4C95A1          	  1188:       jmp ass_error
                        	  1189: 
                        	  1190: exp_done_ok:
00:A0DD A57C            	  1191:       lda exp_operator_stack_count
00:A0DF D0F7            	  1192:       bne exp_done_error
00:A0E1 20E29E          	  1193:       jsr exp_pop_value   ; pop the finished value
00:A0E4 A500            	  1194:       lda VALUE
00:A0E6 8573            	  1195:       sta ASS_VALUE
00:A0E8 A501            	  1196:       lda VALUE+1
00:A0EA 8574            	  1197:       sta ASS_VALUE+1
00:A0EC 6475            	  1198:       stz ASS_VALUE+2   ; make high-order byte zero just in case
00:A0EE 60              	  1199:       rts
                        	  1200: 
                        	  1201: ;
                        	  1202: ;
                        	  1203: ;     1 Pop the operator from the operator stack.
                        	  1204: ;     2 Pop the value stack twice, getting two operands.
                        	  1205: ;     3 Apply the operator to the operands, in the correct order.
                        	  1206: ;     4 Push the result onto the value stack.
                        	  1207: 
                        	  1208: ;
                        	  1209: ass_expression_apply_operator:
00:A0EF 20E29E          	  1210:   jsr exp_pop_value         ; 2 Pop the value stack twice, getting two operands.
00:A0F2 202D9F          	  1211:   jsr exp_get_operator
00:A0F5 C97E            	  1212:   cmp #'~'
00:A0F7 F01F            	  1213:   beq ass_expression_unary
00:A0F9 C921            	  1214:   cmp #'!'
00:A0FB F01B            	  1215:   beq ass_expression_unary
00:A0FD C94D            	  1216:   cmp #TOKEN_UNARY_MINUS
00:A0FF F017            	  1217:   beq ass_expression_unary
00:A101 C956            	  1218:   cmp #TOKEN_LOW_BYTE
00:A103 F013            	  1219:   beq ass_expression_unary
00:A105 C957            	  1220:   cmp #TOKEN_HIGH_BYTE
00:A107 F00F            	  1221:   beq ass_expression_unary
                        	  1222: 
                        	  1223: ;
                        	  1224: ;  if a binary operator get the second value
                        	  1225: ;
00:A109 A500            	  1226:   lda VALUE                 ; copy top value to VALUE2
00:A10B 8503            	  1227:   sta VALUE2
00:A10D A501            	  1228:   lda VALUE+1
00:A10F 8504            	  1229:   sta VALUE2+1
00:A111 A502            	  1230:   lda VALUE+2
00:A113 8505            	  1231:   sta VALUE2+2
00:A115 20E29E          	  1232:   jsr exp_pop_value         ; second pop
                        	  1233: ass_expression_unary:
                        	  1234: 
                        	  1235: ;
                        	  1236: ;  now we have the top two values in VALUE (and VALUE2 in the case of binary operators)
                        	  1237: ;
00:A118 201D9F          	  1238:   jsr exp_pop_operator      ; 1 Pop the operator from the operator stack.
00:A11B 857D            	  1239:   sta exp_operator
00:A11D 209B9F          	  1240:   jsr exp_get_precedence    ; find the evaluation function
00:A120 C000            	  1241:   cpy #0
00:A122 F0CB            	  1242:   beq ass_expression_apply_operator ; should not be here if the operator isn't in the table
00:A124 2030A1          	  1243:   jsr ass_evaluate_operator ; do the evaluation
00:A127 20B79E          	  1244:   jsr exp_push_value        ; 4 Push the result onto the value stack.
00:A12A 60              	  1245:   rts
                        	  1246: 
                        	  1247: ass_expression_apply_operator_bug:
00:A12B A206            	  1248:   ldx #6
00:A12D 4C95A1          	  1249:   jmp ass_error
                        	  1250: 
                        	  1251: ass_evaluate_operator:
00:A130 6C7F00          	  1252:   jmp (exp_evaluation_function)
                        	  1253: 
                        	  1254: 
                        	  1255: ;
                        	  1256: ;  look up opcodes in a table
                        	  1257: ;  returns carry set if found, carry clear if not found
                        	  1258: ;
                        	  1259: ass_lookup_loop:
00:A133 A46E            	  1260:   ldy OPCODE_LEN
00:A135 201195          	  1261:   jsr COMSTL
00:A138 F017            	  1262:   beq ass_opcode_found
                        	  1263: ;
                        	  1264: ;  add the opcode length, plus 1 to DEST
                        	  1265: ;
00:A13A 18              	  1266:   clc
00:A13B A46E            	  1267:   ldy OPCODE_LEN
00:A13D C8              	  1268:   iny
00:A13E 98              	  1269:   tya
00:A13F 6503            	  1270:   adc DEST
00:A141 8503            	  1271:   sta DEST
00:A143 A504            	  1272:   lda DEST+1
00:A145 6900            	  1273:   adc #0
00:A147 8504            	  1274:   sta DEST+1
                        	  1275: ;
                        	  1276: ;  end of table?
                        	  1277: ;
00:A149 A000            	  1278:   ldy #0
00:A14B B103            	  1279:   lda (DEST),Y
00:A14D D0E4            	  1280:   bne ass_lookup_loop   ; not yet
00:A14F 18              	  1281:   clc
00:A150 60              	  1282:   rts
                        	  1283: 
                        	  1284: 
                        	  1285: ass_opcode_found:
00:A151 A46E            	  1286:   ldy OPCODE_LEN
00:A153 B103            	  1287:   lda (DEST),Y
00:A155 38              	  1288:   sec   ; indicate found
00:A156 60              	  1289:   rts
                        	  1290: 
                        	  1291: ass_emit:
00:A157 A476            	  1292:   ldy ASS_PASS
00:A159 F031            	  1293:   beq ass_emit3  ; only emit codes on 2nd pass
                        	  1294:   ;
                        	  1295:   ;  first time for this line of code, indent by two spaces
                        	  1296:   ;
00:A15B A46F            	  1297:   ldy ASS_EMIT_COUNT
00:A15D D00C            	  1298:   bne ass_emit2
00:A15F A42E            	  1299:   ldy DCODE
00:A161 F008            	  1300:   beq ass_emit2
00:A163 48              	  1301:   pha
00:A164 209795          	  1302:   jsr PUTSP
00:A167 209795          	  1303:   jsr PUTSP
00:A16A 68              	  1304:   pla
                        	  1305: ass_emit2:
                        	  1306: ;
                        	  1307: ;  if this is the *first* byte we emitted, then make that the start address
                        	  1308: ;  for running the code. That is, if you relocate the code, the first byte
                        	  1309: ;  actually emitted will be considered the runtime address.
                        	  1310: ;
                        	  1311: ;  this lets you relocate code (eg. to $4500) and have it run from there if
                        	  1312: ;  you happen to hit Run.
                        	  1313: ;
00:A16B 48              	  1314:   pha
00:A16C A577            	  1315:   lda ass_emit_bytes
00:A16E 0578            	  1316:   ora ass_emit_bytes+1
00:A170 D008            	  1317:   bne ass_already_emitted
00:A172 A523            	  1318:   lda PCODE
00:A174 8525            	  1319:   sta ACT_PCDA
00:A176 A524            	  1320:   lda PCODE+1
00:A178 8526            	  1321:   sta ACT_PCDA+1
                        	  1322: ass_already_emitted:
00:A17A 68              	  1323:   pla
                        	  1324: ;
                        	  1325: ;  write the byte to memory
                        	  1326: ;
00:A17B A000            	  1327:   ldy #0
00:A17D 9123            	  1328:   sta (PCODE),Y
00:A17F E677            	  1329:   inc ass_emit_bytes
00:A181 D002            	  1330:   bne ass_emit4
00:A183 E678            	  1331:   inc ass_emit_bytes+1
                        	  1332: ass_emit4:
                        	  1333: 
                        	  1334: ;
                        	  1335: ;  if displaying codes, show the emitted byte
                        	  1336: ;
00:A185 A42E            	  1337:   ldy DCODE
00:A187 F003            	  1338:   beq ass_emit3
00:A189 202195          	  1339:   jsr DISHX
                        	  1340: ;
                        	  1341: ;  increment the PCODE (output) address
                        	  1342: ;
                        	  1343: ass_emit3:
00:A18C E623            	  1344:   inc PCODE
00:A18E D002            	  1345:   bne ass_emit1
00:A190 E624            	  1346:   inc PCODE+1
                        	  1347: ass_emit1:
00:A192 E66F            	  1348:   inc ASS_EMIT_COUNT
00:A194 60              	  1349:   rts
                        	  1350: 
                        	  1351: ass_error:
00:A195 A56F            	  1352:   lda ASS_EMIT_COUNT
00:A197 F003            	  1353:   beq ass_error1
00:A199 200C95          	  1354:   jsr CROUT
                        	  1355: ass_error1:
00:A19C 4C4F9A          	  1356:   jmp ERROR
                        	  1357: 
                        	  1358: ass_fixup_bbr_branch:
00:A19F A507            	  1359:   lda REMAIN+1
00:A1A1 D043            	  1360:   bne ass_emit_zero_page_too_high
00:A1A3 A508            	  1361:   lda REMAIN+2
00:A1A5 D03F            	  1362:   bne ass_emit_zero_page_too_high
00:A1A7 A506            	  1363:   lda REMAIN
00:A1A9 2057A1          	  1364:   jsr ass_emit  ; output zero page address
                        	  1365: 
                        	  1366: ;
                        	  1367: ;  now fall down and emit the branch
                        	  1368: ;
                        	  1369: 
                        	  1370: ass_fixup_branch:
00:A1AC 18              	  1371:   clc         ; I want to subtract one more, so I CLEAR carry <sigh>
00:A1AD A573            	  1372:   lda ASS_VALUE
00:A1AF E523            	  1373:   sbc PCODE
00:A1B1 8573            	  1374:   sta ASS_VALUE
                        	  1375: 
00:A1B3 A574            	  1376:   lda ASS_VALUE+1
00:A1B5 E524            	  1377:   sbc PCODE+1
00:A1B7 C9FF            	  1378:   cmp #$FF  ; backwards branch
00:A1B9 F00A            	  1379:   beq ass_branch_backwards
00:A1BB C900            	  1380:   cmp #0
00:A1BD D010            	  1381:   bne ass_branch_out_of_range
00:A1BF A573            	  1382:   lda ASS_VALUE ; must be 0x00 to 0x7F
00:A1C1 300C            	  1383:   bmi ass_branch_out_of_range
00:A1C3 8004            	  1384:   bra ass_branch_ok
                        	  1385: 
                        	  1386: ass_branch_backwards:
00:A1C5 A573            	  1387:   lda ASS_VALUE   ; must be 0x80 to 0xFF
00:A1C7 1006            	  1388:   bpl ass_branch_out_of_range
                        	  1389: 
                        	  1390: ass_branch_ok:
00:A1C9 A573            	  1391:   lda ASS_VALUE
00:A1CB 2057A1          	  1392:   jsr ass_emit  ; output relative address
00:A1CE 60              	  1393:   rts
                        	  1394: 
                        	  1395: ass_branch_out_of_range:
00:A1CF A576            	  1396:   lda ASS_PASS
00:A1D1 F0F6            	  1397:   beq ass_branch_ok   ; out of range is OK on first pass, we don't know how far the branch is
00:A1D3 A22A            	  1398:   ldx #42
00:A1D5 4C95A1          	  1399:   jmp ass_error  ; branch out of range
                        	  1400: 
                        	  1401: ass_emit_zero_page:
00:A1D8 A574            	  1402:   lda ASS_VALUE+1
00:A1DA D00A            	  1403:   bne ass_emit_zero_page_too_high
00:A1DC A575            	  1404:   lda ASS_VALUE+2
00:A1DE D006            	  1405:   bne ass_emit_zero_page_too_high
00:A1E0 A573            	  1406:   lda ASS_VALUE
00:A1E2 2057A1          	  1407:   jsr ass_emit  ; output zero page address
00:A1E5 60              	  1408:   rts
                        	  1409: 
                        	  1410: 
                        	  1411: ass_emit_zero_page_too_high:
00:A1E6 A22B            	  1412:   ldx #43       ; Need zero page address
00:A1E8 4C95A1          	  1413:   jmp ass_error
                        	  1414: 
                        	  1415: ass_emit_immediate:
00:A1EB A574            	  1416:   lda ASS_VALUE+1
00:A1ED D00A            	  1417:   bne ass_emit_immediate_too_high
00:A1EF A575            	  1418:   lda ASS_VALUE+2
00:A1F1 D006            	  1419:   bne ass_emit_immediate_too_high
00:A1F3 A573            	  1420:   lda ASS_VALUE
00:A1F5 2057A1          	  1421:   jsr ass_emit  ; output immediate operand
00:A1F8 60              	  1422:   rts
                        	  1423: 
                        	  1424: ass_emit_immediate_too_high:
00:A1F9 A22C            	  1425:   ldx #44
00:A1FB 4C95A1          	  1426:   jmp ass_error
                        	  1427: 
                        	  1428: 
                        	  1429: ass_emit_absolute:
00:A1FE A573            	  1430:   lda ASS_VALUE
00:A200 2057A1          	  1431:   jsr ass_emit  ; output absolute address - low-order byte
00:A203 A574            	  1432:   lda ASS_VALUE+1
00:A205 2057A1          	  1433:   jsr ass_emit  ; output absolute address - high-order byte
00:A208 60              	  1434:   rts
                        	  1435: 
                        	  1436: 
                        	  1437: ;------------------------------------
                        	  1438: ;  Opcode master table
                        	  1439: ;------------------------------------
                        	  1440: 
                        	  1441:    .macro makeOpcodeLookup ; table of opcodes, length of opcode, wanted operand type, special handler
                        	  1442:      dfb   \1
                        	  1443:      dfb   \2
                        	  1444:      word  \3
                        	  1445:      word   \4
                        	  1446:    .endmacro
                        	  1447: 
                        	  1448: ;
                        	  1449: ;  So, for an opcode to match, it has to:
                        	  1450: ;     a) be the right length (usually 3 or 4 characters)
                        	  1451: ;     b) have the right type of operand (eg. ASS_OPERAND_IMMEDIATE)
                        	  1452: ;     c) the opcode must match the name in the list
                        	  1453: ;
                        	  1454: ;   If those conditions are met we output the corresponding opcode,
                        	  1455: ;   return with the operand type in A
                        	  1456: ;
                        	  1457: ;   Otherwise, we return 0 in A
                        	  1458: ;
                        	  1459: 
                        	  1460: OPCODE_LOOKUP_OPCODE_LENGTH = 0
                        	  1461: OPCODE_LOOKUP_OPERAND_TYPE = 1
                        	  1462: OPCODE_LOOKUP_OPCODE_TABLE = 2    ; 2 bytes
                        	  1463: OPCODE_LOOKUP_HANDLER = 4         ; 2 bytes
                        	  1464: OPCODE_LOOKUP_TABLE_SIZE = 6      ; all of the above
                        	  1465: 
                        	  1466: OPCODE_LOOKUP_TABLE = *
                        	  1467: ;
                        	  1468: ;  zero-page opcodes go first as they are preferred if we are accessing a zero-page address
                        	  1469: ;
                        	  1470:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE, OPCODE_ASS_OPERAND_ZERO_PAGE, ass_emit_zero_page ; (11)
00:A209 03              	     1M      dfb   3
00:A20A 0B              	     2M      dfb   ASS_OPERAND_ZERO_PAGE
00:A20B 96A5            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE
00:A20D D8A1            	     4M      word   ass_emit_zero_page 
                        	  1471:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE, OPCODE_ASS_OPERAND_ZERO_PAGE_TOKENISED, ass_emit_zero_page ; (11)
00:A20F 01              	     1M      dfb   1
00:A210 0B              	     2M      dfb   ASS_OPERAND_ZERO_PAGE
00:A211 F7A5            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_TOKENISED
00:A213 D8A1            	     4M      word   ass_emit_zero_page 
                        	  1472:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT, ass_em
00:A215 03              	     1M      dfb   3
00:A216 0C              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
00:A217 FAA5            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
00:A219 D8A1            	     4M      word   ass_emit_zero_page 
                        	  1473:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT_TOKENIS
00:A21B 01              	     1M      dfb   1
00:A21C 0C              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
00:A21D 1BA6            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT_TOKENISED
00:A21F D8A1            	     4M      word   ass_emit_zero_page 
                        	  1474:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X, ass_emit_z
00:A221 03              	     1M      dfb   3
00:A222 0D              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
00:A223 1EA6            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
00:A225 D8A1            	     4M      word   ass_emit_zero_page 
                        	  1475:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X_TOKENISED, 
00:A227 01              	     1M      dfb   1
00:A228 0D              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
00:A229 67A6            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X_TOKENISED
00:A22B D8A1            	     4M      word   ass_emit_zero_page 
                        	  1476:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y, ass_emit_z
00:A22D 03              	     1M      dfb   3
00:A22E 0E              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
00:A22F 6AA6            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
00:A231 D8A1            	     4M      word   ass_emit_zero_page 
                        	  1477:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDIRECT, OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT, ass_emit_zero_page ; (
00:A233 03              	     1M      dfb   3
00:A234 0F              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDIRECT
00:A235 73A6            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT
00:A237 D8A1            	     4M      word   ass_emit_zero_page 
                        	  1478:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE_INDIRECT, OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_TOKENISED, ass_emit_zer
00:A239 01              	     1M      dfb   1
00:A23A 0F              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDIRECT
00:A23B 94A6            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_TOKENISED
00:A23D D8A1            	     4M      word   ass_emit_zero_page 
                        	  1479:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_
00:A23F 03              	     1M      dfb   3
00:A240 10              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
00:A241 97A6            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
00:A243 D8A1            	     4M      word   ass_emit_zero_page 
                        	  1480:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_
00:A245 01              	     1M      dfb   1
00:A246 10              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
00:A247 B8A6            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y_TOKENISED
00:A249 D8A1            	     4M      word   ass_emit_zero_page 
                        	  1481: 
                        	  1482: ;
                        	  1483: ;  non zero-page opcodes
                        	  1484: ;
                        	  1485:     makeOpcodeLookup  4,  ASS_OPERAND_ABSOLUTE, OPCODE_4_CHAR_ZERO_PAGE,  ass_emit_zero_page  ; (11)
00:A24B 04              	     1M      dfb   4
00:A24C 01              	     2M      dfb   ASS_OPERAND_ABSOLUTE
00:A24D 12A4            	     3M      word  OPCODE_4_CHAR_ZERO_PAGE
00:A24F D8A1            	     4M      word   ass_emit_zero_page  
                        	  1486:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE, OPCODE_ASS_OPERAND_ABSOLUTE,  ass_emit_absolute  ; (1)
00:A251 03              	     1M      dfb   3
00:A252 01              	     2M      dfb   ASS_OPERAND_ABSOLUTE
00:A253 63A4            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE
00:A255 FEA1            	     4M      word   ass_emit_absolute  
                        	  1487:     makeOpcodeLookup  1,  ASS_OPERAND_ABSOLUTE, OPCODE_ASS_OPERAND_ABSOLUTE_TOKENISED,  ass_emit_absolute  ; (1)
00:A257 01              	     1M      dfb   1
00:A258 01              	     2M      dfb   ASS_OPERAND_ABSOLUTE
00:A259 CCA4            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_TOKENISED
00:A25B FEA1            	     4M      word   ass_emit_absolute  
                        	  1488: 
                        	  1489:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT, ass_emit
00:A25D 03              	     1M      dfb   3
00:A25E 02              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
00:A25F CFA4            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
00:A261 FEA1            	     4M      word   ass_emit_absolute 
                        	  1490:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X, ass_emit_abs
00:A263 03              	     1M      dfb   3
00:A264 03              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
00:A265 D4A4            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
00:A267 FEA1            	     4M      word   ass_emit_absolute 
                        	  1491:     makeOpcodeLookup  1,  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X_TOKENISED, as
00:A269 01              	     1M      dfb   1
00:A26A 03              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
00:A26B 19A5            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X_TOKENISED
00:A26D FEA1            	     4M      word   ass_emit_absolute 
                        	  1492:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y, ass_emit_abs
00:A26F 03              	     1M      dfb   3
00:A270 04              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
00:A271 1CA5            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
00:A273 FEA1            	     4M      word   ass_emit_absolute 
                        	  1493:     makeOpcodeLookup  1,  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y_TOKENISED, as
00:A275 01              	     1M      dfb   1
00:A276 04              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
00:A277 41A5            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y_TOKENISED
00:A279 FEA1            	     4M      word   ass_emit_absolute 
                        	  1494:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDIRECT, OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT, ass_emit_absolute ; (5)
00:A27B 03              	     1M      dfb   3
00:A27C 05              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDIRECT
00:A27D 5DA5            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT
00:A27F FEA1            	     4M      word   ass_emit_absolute 
                        	  1495:     makeOpcodeLookup  1,  ASS_OPERAND_ABSOLUTE_INDIRECT, OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED, ass_emit_absolute ; (5
00:A281 01              	     1M      dfb   1
00:A282 05              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDIRECT
00:A283 93A5            	     3M      word  OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED
00:A285 FEA1            	     4M      word   ass_emit_absolute 
                        	  1496:     makeOpcodeLookup  3,  ASS_OPERAND_ACCUMULATOR_A, OPCODE_ASS_OPERAND_ACCUMULATOR_A, 0 ; (6)
00:A287 03              	     1M      dfb   3
00:A288 06              	     2M      dfb   ASS_OPERAND_ACCUMULATOR_A
00:A289 44A5            	     3M      word  OPCODE_ASS_OPERAND_ACCUMULATOR_A
00:A28B 0000            	     4M      word   0 
                        	  1497:     makeOpcodeLookup  3,  ASS_OPERAND_IMMEDIATE, OPCODE_ASS_OPERAND_IMMEDIATE, ass_emit_immediate ; (7)
00:A28D 03              	     1M      dfb   3
00:A28E 07              	     2M      dfb   ASS_OPERAND_IMMEDIATE
00:A28F 62A5            	     3M      word  OPCODE_ASS_OPERAND_IMMEDIATE
00:A291 EBA1            	     4M      word   ass_emit_immediate 
                        	  1498:     makeOpcodeLookup  1,  ASS_OPERAND_IMMEDIATE, OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED, ass_emit_immediate ; (7)
00:A293 01              	     1M      dfb   1
00:A294 07              	     2M      dfb   ASS_OPERAND_IMMEDIATE
00:A295 93A5            	     3M      word  OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED
00:A297 EBA1            	     4M      word   ass_emit_immediate 
                        	  1499:     makeOpcodeLookup  3,  ASS_OPERAND_IMPLIED,  OPCODE_3_CHAR_IMPLIED,    0  ; (8) and (10)
00:A299 03              	     1M      dfb   3
00:A29A 08              	     2M      dfb   ASS_OPERAND_IMPLIED
00:A29B 95A3            	     3M      word  OPCODE_3_CHAR_IMPLIED
00:A29D 0000            	     4M      word   0  
                        	  1500:     makeOpcodeLookup  4,  ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE, OPCODE_4_CHAR_BRANCH,     ass_fixup_bbr_branch  ; (9)
00:A29F 04              	     1M      dfb   4
00:A2A0 12              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE
00:A2A1 1FA3            	     3M      word  OPCODE_4_CHAR_BRANCH
00:A2A3 9FA1            	     4M      word   ass_fixup_bbr_branch  
                        	  1501:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE, OPCODE_3_CHAR_BRANCH,     ass_fixup_branch  ; (9)
00:A2A5 03              	     1M      dfb   3
00:A2A6 01              	     2M      dfb   ASS_OPERAND_ABSOLUTE
00:A2A7 70A3            	     3M      word  OPCODE_3_CHAR_BRANCH
00:A2A9 ACA1            	     4M      word   ass_fixup_branch  
00:A2AB 00              	  1502:     dfb 0
                        	  1503: 
                        	  1504: 
                        	  1505: ;------------------------------------
                        	  1506: ;  directives
                        	  1507: ;------------------------------------
                        	  1508: 
                        	  1509: 
                        	  1510: DIRECTIVES = *
                        	  1511:   makeHandler "ASSERT",   asm_do_assert
00:A2AC 415353455254    	     1M    asciiz   "ASSERT"
00:A2B2 00
00:A2B3 BBA6            	     2M    word  asm_do_assert
                        	  1512:   makeHandler "LIST",     asm_do_list
00:A2B5 4C495354        	     1M    asciiz   "LIST"
00:A2B9 00
00:A2BA D2A6            	     2M    word  asm_do_list
                        	  1513:   makeHandler "NOLIST",   asm_do_nolist
00:A2BC 4E4F4C495354    	     1M    asciiz   "NOLIST"
00:A2C2 00
00:A2C3 E1A6            	     2M    word  asm_do_nolist
                        	  1514:   makeHandler "ASC",      asm_do_asc
00:A2C5 415343          	     1M    asciiz   "ASC"
00:A2C8 00
00:A2C9 20A7            	     2M    word  asm_do_asc
                        	  1515:   makeHandler "ASCII",    asm_do_asc
00:A2CB 4153434949      	     1M    asciiz   "ASCII"
00:A2D0 00
00:A2D1 20A7            	     2M    word  asm_do_asc
                        	  1516:   makeHandler "ASCIIZ",   asm_do_string
00:A2D3 41534349495A    	     1M    asciiz   "ASCIIZ"
00:A2D9 00
00:A2DA 3BA7            	     2M    word  asm_do_string
                        	  1517:   makeHandler "STRING",   asm_do_string
00:A2DC 535452494E47    	     1M    asciiz   "STRING"
00:A2E2 00
00:A2E3 3BA7            	     2M    word  asm_do_string
                        	  1518:   makeHandler "EQU",      asm_do_equ
00:A2E5 455155          	     1M    asciiz   "EQU"
00:A2E8 00
00:A2E9 44A7            	     2M    word  asm_do_equ
                        	  1519:   makeHandler "=",        asm_do_equ
00:A2EB 3D              	     1M    asciiz   "="
00:A2EC 00
00:A2ED 44A7            	     2M    word  asm_do_equ
                        	  1520:   makeHandler "ORG",      asm_do_org
00:A2EF 4F5247          	     1M    asciiz   "ORG"
00:A2F2 00
00:A2F3 61A7            	     2M    word  asm_do_org
                        	  1521:   makeHandler "DFB",      asm_do_dfb
00:A2F5 444642          	     1M    asciiz   "DFB"
00:A2F8 00
00:A2F9 75A7            	     2M    word  asm_do_dfb
                        	  1522:   makeHandler "DFW",      asm_do_dfw
00:A2FB 444657          	     1M    asciiz   "DFW"
00:A2FE 00
00:A2FF B5A7            	     2M    word  asm_do_dfw
                        	  1523:   makeHandler "WORD",     asm_do_dfw
00:A301 574F5244        	     1M    asciiz   "WORD"
00:A305 00
00:A306 B5A7            	     2M    word  asm_do_dfw
                        	  1524:   makeHandler "BLK",      asm_do_blk
00:A308 424C4B          	     1M    asciiz   "BLK"
00:A30B 00
00:A30C F2A7            	     2M    word  asm_do_blk
                        	  1525:   makeHandler "RESERVE",  asm_do_reserve
00:A30E 52455345525645  	     1M    asciiz   "RESERVE"
00:A315 00
00:A316 10A8            	     2M    word  asm_do_reserve
                        	  1526:   makeHandler "SYM",      asm_do_sym
00:A318 53594D          	     1M    asciiz   "SYM"
00:A31B 00
00:A31C 2BA8            	     2M    word  asm_do_sym
                        	  1527: 
00:A31E 00              	  1528:   dfb 0
                        	  1529: 
                        	  1530: ;------------------------------------
                        	  1531: ;  4-character branch opcodes
                        	  1532: ;------------------------------------
                        	  1533: 
                        	  1534: 
                        	  1535: OPCODE_4_CHAR_BRANCH = *
00:A31F 42425230        	  1536:   asc "BBR0",$0F
00:A323 0F
00:A324 42425231        	  1537:   asc "BBR1",$1F
00:A328 1F
00:A329 42425232        	  1538:   asc "BBR2",$2F
00:A32D 2F
00:A32E 42425233        	  1539:   asc "BBR3",$3F
00:A332 3F
00:A333 42425234        	  1540:   asc "BBR4",$4F
00:A337 4F
00:A338 42425235        	  1541:   asc "BBR5",$5F
00:A33C 5F
00:A33D 42425236        	  1542:   asc "BBR6",$6F
00:A341 6F
00:A342 42425237        	  1543:   asc "BBR7",$7F
00:A346 7F
00:A347 42425330        	  1544:   asc "BBS0",$8F
00:A34B 8F
00:A34C 42425331        	  1545:   asc "BBS1",$9F
00:A350 9F
00:A351 42425332        	  1546:   asc "BBS2",$AF
00:A355 AF
00:A356 42425333        	  1547:   asc "BBS3",$BF
00:A35A BF
00:A35B 42425334        	  1548:   asc "BBS4",$CF
00:A35F CF
00:A360 42425335        	  1549:   asc "BBS5",$DF
00:A364 DF
00:A365 42425336        	  1550:   asc "BBS6",$EF
00:A369 EF
00:A36A 42425337        	  1551:   asc "BBS7",$FF
00:A36E FF
00:A36F 00              	  1552:   dfb 0
                        	  1553: 
                        	  1554: ;------------------------------------
                        	  1555: ;  3-character branch opcodes
                        	  1556: ;------------------------------------
                        	  1557: 
                        	  1558: 
                        	  1559: OPCODE_3_CHAR_BRANCH = *
00:A370 424343          	  1560:   asc "BCC",$90
00:A373 90
00:A374 424353          	  1561:   asc "BCS",$B0
00:A377 B0
00:A378 424551          	  1562:   asc "BEQ",$F0
00:A37B F0
00:A37C 424D49          	  1563:   asc "BMI",$30
00:A37F 30
00:A380 424E45          	  1564:   asc "BNE",$D0
00:A383 D0
00:A384 42504C          	  1565:   asc "BPL",$10
00:A387 10
00:A388 425241          	  1566:   asc "BRA",$80
00:A38B 80
00:A38C 425643          	  1567:   asc "BVC",$50
00:A38F 50
00:A390 425653          	  1568:   asc "BVS",$70
00:A393 70
00:A394 00              	  1569:   dfb 0
                        	  1570: 
                        	  1571: 
                        	  1572: ;------------------------------------
                        	  1573: ;  3-character implied opcodes (no operand)
                        	  1574: ;------------------------------------
                        	  1575: 
                        	  1576: OPCODE_3_CHAR_IMPLIED = *
00:A395 42524B          	  1577:   asc "BRK",$00
00:A398 00
00:A399 434C43          	  1578:   asc "CLC",$18
00:A39C 18
00:A39D 434C44          	  1579:   asc "CLD",$D8
00:A3A0 D8
00:A3A1 434C49          	  1580:   asc "CLI",$58
00:A3A4 58
00:A3A5 434C56          	  1581:   asc "CLV",$B8
00:A3A8 B8
00:A3A9 444558          	  1582:   asc "DEX",$CA
00:A3AC CA
00:A3AD 444559          	  1583:   asc "DEY",$88
00:A3B0 88
00:A3B1 494E58          	  1584:   asc "INX",$E8
00:A3B4 E8
00:A3B5 494E59          	  1585:   asc "INY",$C8
00:A3B8 C8
00:A3B9 4E4F50          	  1586:   asc "NOP",$EA
00:A3BC EA
00:A3BD 504841          	  1587:   asc "PHA",$48
00:A3C0 48
00:A3C1 504850          	  1588:   asc "PHP",$08
00:A3C4 08
00:A3C5 504858          	  1589:   asc "PHX",$DA
00:A3C8 DA
00:A3C9 504859          	  1590:   asc "PHY",$5A
00:A3CC 5A
00:A3CD 504C41          	  1591:   asc "PLA",$68
00:A3D0 68
00:A3D1 504C50          	  1592:   asc "PLP",$28
00:A3D4 28
00:A3D5 504C58          	  1593:   asc "PLX",$FA
00:A3D8 FA
00:A3D9 504C59          	  1594:   asc "PLY",$7A
00:A3DC 7A
00:A3DD 525449          	  1595:   asc "RTI",$40
00:A3E0 40
00:A3E1 525453          	  1596:   asc "RTS",$60
00:A3E4 60
00:A3E5 534543          	  1597:   asc "SEC",$38
00:A3E8 38
00:A3E9 534544          	  1598:   asc "SED",$F8
00:A3EC F8
00:A3ED 534549          	  1599:   asc "SEI",$78
00:A3F0 78
00:A3F1 535450          	  1600:   asc "STP",$DB
00:A3F4 DB
00:A3F5 544158          	  1601:   asc "TAX",$AA
00:A3F8 AA
00:A3F9 544159          	  1602:   asc "TAY",$A8
00:A3FC A8
00:A3FD 545358          	  1603:   asc "TSX",$BA
00:A400 BA
00:A401 545841          	  1604:   asc "TXA",$8A
00:A404 8A
00:A405 545853          	  1605:   asc "TXS",$9A
00:A408 9A
00:A409 545941          	  1606:   asc "TYA",$98
00:A40C 98
00:A40D 574149          	  1607:   asc "WAI",$CB
00:A410 CB
00:A411 00              	  1608:   dfb 0
                        	  1609: 
                        	  1610: ;------------------------------------
                        	  1611: ;  4-character zero page opcodes (operand must be zero-page address)
                        	  1612: ;------------------------------------
                        	  1613: OPCODE_4_CHAR_ZERO_PAGE = *
00:A412 534D4230        	  1614:   asc "SMB0",$87
00:A416 87
00:A417 534D4231        	  1615:   asc "SMB1",$97
00:A41B 97
00:A41C 534D4232        	  1616:   asc "SMB2",$A7
00:A420 A7
00:A421 534D4233        	  1617:   asc "SMB3",$B7
00:A425 B7
00:A426 534D4234        	  1618:   asc "SMB4",$C7
00:A42A C7
00:A42B 534D4235        	  1619:   asc "SMB5",$D7
00:A42F D7
00:A430 534D4236        	  1620:   asc "SMB6",$E7
00:A434 E7
00:A435 534D4237        	  1621:   asc "SMB7",$F7
00:A439 F7
00:A43A 524D4230        	  1622:   asc "RMB0",$07
00:A43E 07
00:A43F 524D4231        	  1623:   asc "RMB1",$17
00:A443 17
00:A444 524D4232        	  1624:   asc "RMB2",$27
00:A448 27
00:A449 524D4233        	  1625:   asc "RMB3",$37
00:A44D 37
00:A44E 524D4234        	  1626:   asc "RMB4",$47
00:A452 47
00:A453 524D4235        	  1627:   asc "RMB5",$57
00:A457 57
00:A458 524D4236        	  1628:   asc "RMB6",$67
00:A45C 67
00:A45D 524D4237        	  1629:   asc "RMB7",$77
00:A461 77
00:A462 00              	  1630:   dfb 0
                        	  1631: 
                        	  1632: ;------------------------------------
                        	  1633: ;  ASS_OPERAND_ABSOLUTE
                        	  1634: ;------------------------------------
                        	  1635: OPCODE_ASS_OPERAND_ABSOLUTE = *
00:A463 414443          	  1636:   asc "ADC",$6D
00:A466 6D
00:A467 414E44          	  1637:   asc "AND",$2D
00:A46A 2D
00:A46B 41534C          	  1638:   asc "ASL",$0E
00:A46E 0E
00:A46F 424954          	  1639:   asc "BIT",$2C
00:A472 2C
00:A473 434D50          	  1640:   asc "CMP",$CD
00:A476 CD
00:A477 435058          	  1641:   asc "CPX",$EC
00:A47A EC
00:A47B 435059          	  1642:   asc "CPY",$CC
00:A47E CC
00:A47F 444543          	  1643:   asc "DEC",$CE
00:A482 CE
00:A483 454F52          	  1644:   asc "EOR",$4D
00:A486 4D
00:A487 494E43          	  1645:   asc "INC",$EE
00:A48A EE
00:A48B 4A4D50          	  1646:   asc "JMP",$4C
00:A48E 4C
00:A48F 4A5352          	  1647:   asc "JSR",$20
00:A492 20
00:A493 4C4441          	  1648:   asc "LDA",$AD
00:A496 AD
00:A497 4C4458          	  1649:   asc "LDX",$AE
00:A49A AE
00:A49B 4C4459          	  1650:   asc "LDY",$AC
00:A49E AC
00:A49F 4C5352          	  1651:   asc "LSR",$4E
00:A4A2 4E
00:A4A3 4F5241          	  1652:   asc "ORA",$0D
00:A4A6 0D
00:A4A7 524F4C          	  1653:   asc "ROL",$2E
00:A4AA 2E
00:A4AB 524F52          	  1654:   asc "ROR",$6E
00:A4AE 6E
00:A4AF 534243          	  1655:   asc "SBC",$ED
00:A4B2 ED
00:A4B3 535441          	  1656:   asc "STA",$8D
00:A4B6 8D
00:A4B7 535458          	  1657:   asc "STX",$8E
00:A4BA 8E
00:A4BB 535459          	  1658:   asc "STY",$8C
00:A4BE 8C
00:A4BF 53545A          	  1659:   asc "STZ",$9C
00:A4C2 9C
00:A4C3 545242          	  1660:   asc "TRB",$1C
00:A4C6 1C
00:A4C7 545342          	  1661:   asc "TSB",$0C
00:A4CA 0C
00:A4CB 00              	  1662:   dfb 0
                        	  1663: 
                        	  1664: ;------------------------------------
                        	  1665: ;  ASS_OPERAND_ABSOLUTE - for tokenised opcodes like AND
                        	  1666: ;------------------------------------
                        	  1667: OPCODE_ASS_OPERAND_ABSOLUTE_TOKENISED = *
00:A4CC 8D              	  1668:   dfb TOKEN_AND,$2D
00:A4CD 2D
00:A4CE 00              	  1669:   dfb 0
                        	  1670: 
                        	  1671: 
                        	  1672: ;------------------------------------
                        	  1673: ;  ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
                        	  1674: ;------------------------------------
                        	  1675: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT = *
00:A4CF 4A4D50          	  1676:   asc "JMP",$7C
00:A4D2 7C
00:A4D3 00              	  1677:   dfb 0
                        	  1678: 
                        	  1679: ;------------------------------------
                        	  1680: ;  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
                        	  1681: ;------------------------------------
                        	  1682: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X = *
00:A4D4 414443          	  1683:   asc "ADC",$7D
00:A4D7 7D
00:A4D8 414E44          	  1684:   asc "AND",$3D
00:A4DB 3D
00:A4DC 41534C          	  1685:   asc "ASL",$1E
00:A4DF 1E
00:A4E0 424954          	  1686:   asc "BIT",$3C
00:A4E3 3C
00:A4E4 434D50          	  1687:   asc "CMP",$DD
00:A4E7 DD
00:A4E8 444543          	  1688:   asc "DEC",$DE
00:A4EB DE
00:A4EC 454F52          	  1689:   asc "EOR",$5D
00:A4EF 5D
00:A4F0 494E43          	  1690:   asc "INC",$FE
00:A4F3 FE
00:A4F4 4C4441          	  1691:   asc "LDA",$BD
00:A4F7 BD
00:A4F8 4C4459          	  1692:   asc "LDY",$BC
00:A4FB BC
00:A4FC 4C5352          	  1693:   asc "LSR",$5E
00:A4FF 5E
00:A500 4F5241          	  1694:   asc "ORA",$1D
00:A503 1D
00:A504 524F4C          	  1695:   asc "ROL",$3E
00:A507 3E
00:A508 524F52          	  1696:   asc "ROR",$7E
00:A50B 7E
00:A50C 534243          	  1697:   asc "SBC",$FD
00:A50F FD
00:A510 535441          	  1698:   asc "STA",$9D
00:A513 9D
00:A514 53545A          	  1699:   asc "STZ",$9E
00:A517 9E
00:A518 00              	  1700:   dfb 0
                        	  1701: 
                        	  1702: ;------------------------------------
                        	  1703: ;  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X - for tokenised opcodes like AND
                        	  1704: ;------------------------------------
                        	  1705: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X_TOKENISED = *
00:A519 8D              	  1706:   dfb TOKEN_AND,$3D
00:A51A 3D
00:A51B 00              	  1707:   dfb 0
                        	  1708: 
                        	  1709: ;------------------------------------
                        	  1710: ;  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
                        	  1711: ;------------------------------------
                        	  1712: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y = *
00:A51C 414443          	  1713:   asc "ADC",$79
00:A51F 79
00:A520 414E44          	  1714:   asc "AND",$39
00:A523 39
00:A524 434D50          	  1715:   asc "CMP",$D9
00:A527 D9
00:A528 454F52          	  1716:   asc "EOR",$59
00:A52B 59
00:A52C 4C4441          	  1717:   asc "LDA",$B9
00:A52F B9
00:A530 4C4458          	  1718:   asc "LDX",$BE
00:A533 BE
00:A534 4F5241          	  1719:   asc "ORA",$19
00:A537 19
00:A538 534243          	  1720:   asc "SBC",$F9
00:A53B F9
00:A53C 535441          	  1721:   asc "STA",$99
00:A53F 99
00:A540 00              	  1722:   dfb 0
                        	  1723: 
                        	  1724: ;------------------------------------
                        	  1725: ;  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y - for tokenised opcodes like AND
                        	  1726: ;------------------------------------
                        	  1727: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y_TOKENISED = *
00:A541 8D              	  1728:   dfb TOKEN_AND,$39
00:A542 39
00:A543 00              	  1729:   dfb 0
                        	  1730: 
                        	  1731: ;------------------------------------
                        	  1732: ;  ASS_OPERAND_ACCUMULATOR_A
                        	  1733: ;------------------------------------
                        	  1734: OPCODE_ASS_OPERAND_ACCUMULATOR_A = *
00:A544 41534C          	  1735:   asc "ASL",$0A
00:A547 0A
00:A548 444543          	  1736:   asc "DEC",$3A
00:A54B 3A
00:A54C 494E43          	  1737:   asc "INC",$1A
00:A54F 1A
00:A550 4C5352          	  1738:   asc "LSR",$4A
00:A553 4A
00:A554 524F4C          	  1739:   asc "ROL",$2A
00:A557 2A
00:A558 524F52          	  1740:   asc "ROR",$6A
00:A55B 6A
00:A55C 00              	  1741:   dfb 0
                        	  1742: 
                        	  1743: ;------------------------------------
                        	  1744: ;  ASS_OPERAND_ABSOLUTE_INDIRECT
                        	  1745: ;------------------------------------
                        	  1746: OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT = *
00:A55D 4A4D50          	  1747:   asc "JMP",$6C
00:A560 6C
00:A561 00              	  1748:   dfb 0
                        	  1749: 
                        	  1750: ;------------------------------------
                        	  1751: ;  ASS_OPERAND_IMMEDIATE
                        	  1752: ;------------------------------------
                        	  1753: OPCODE_ASS_OPERAND_IMMEDIATE = *
00:A562 414443          	  1754:   asc "ADC",$69
00:A565 69
00:A566 414E44          	  1755:   asc "AND",$29
00:A569 29
00:A56A 424954          	  1756:   asc "BIT",$89
00:A56D 89
00:A56E 434D50          	  1757:   asc "CMP",$C9
00:A571 C9
00:A572 435058          	  1758:   asc "CPX",$E0
00:A575 E0
00:A576 435059          	  1759:   asc "CPY",$C0
00:A579 C0
00:A57A 454F52          	  1760:   asc "EOR",$49
00:A57D 49
00:A57E 4C4441          	  1761:   asc "LDA",$A9
00:A581 A9
00:A582 4C4458          	  1762:   asc "LDX",$A2
00:A585 A2
00:A586 4C4459          	  1763:   asc "LDY",$A0
00:A589 A0
00:A58A 4F5241          	  1764:   asc "ORA",$09
00:A58D 09
00:A58E 534243          	  1765:   asc "SBC",$E9
00:A591 E9
00:A592 00              	  1766:   dfb 0
                        	  1767: 
                        	  1768: ;------------------------------------
                        	  1769: ;  ASS_OPERAND_IMMEDIATE - for tokenised opcodes like AND
                        	  1770: ;------------------------------------
                        	  1771: OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED = *
00:A593 8D              	  1772:   dfb TOKEN_AND,$29
00:A594 29
00:A595 00              	  1773:   dfb 0
                        	  1774: 
                        	  1775: ;------------------------------------
                        	  1776: ;  ASS_OPERAND_ZERO_PAGE
                        	  1777: ;------------------------------------
                        	  1778: OPCODE_ASS_OPERAND_ZERO_PAGE = *
00:A596 414443          	  1779:   asc "ADC",$65
00:A599 65
00:A59A 414E44          	  1780:   asc "AND",$25
00:A59D 25
00:A59E 41534C          	  1781:   asc "ASL",$06
00:A5A1 06
00:A5A2 424954          	  1782:   asc "BIT",$24
00:A5A5 24
00:A5A6 434D50          	  1783:   asc "CMP",$C5
00:A5A9 C5
00:A5AA 435058          	  1784:   asc "CPX",$E4
00:A5AD E4
00:A5AE 435059          	  1785:   asc "CPY",$C4
00:A5B1 C4
00:A5B2 444543          	  1786:   asc "DEC",$C6
00:A5B5 C6
00:A5B6 454F52          	  1787:   asc "EOR",$45
00:A5B9 45
00:A5BA 494E43          	  1788:   asc "INC",$E6
00:A5BD E6
00:A5BE 4C4441          	  1789:   asc "LDA",$A5
00:A5C1 A5
00:A5C2 4C4458          	  1790:   asc "LDX",$A6
00:A5C5 A6
00:A5C6 4C4459          	  1791:   asc "LDY",$A4
00:A5C9 A4
00:A5CA 4C5352          	  1792:   asc "LSR",$46
00:A5CD 46
00:A5CE 4F5241          	  1793:   asc "ORA",$05
00:A5D1 05
00:A5D2 524F4C          	  1794:   asc "ROL",$26
00:A5D5 26
00:A5D6 524F52          	  1795:   asc "ROR",$66
00:A5D9 66
00:A5DA 534243          	  1796:   asc "SBC",$E5
00:A5DD E5
00:A5DE 535441          	  1797:   asc "STA",$85
00:A5E1 85
00:A5E2 535458          	  1798:   asc "STX",$86
00:A5E5 86
00:A5E6 535459          	  1799:   asc "STY",$84
00:A5E9 84
00:A5EA 53545A          	  1800:   asc "STZ",$64
00:A5ED 64
00:A5EE 545242          	  1801:   asc "TRB",$14
00:A5F1 14
00:A5F2 545342          	  1802:   asc "TSB",$04
00:A5F5 04
00:A5F6 00              	  1803:   dfb 0
                        	  1804: 
                        	  1805: ;------------------------------------
                        	  1806: ;  ASS_OPERAND_ZERO_PAGE  - for tokenised opcodes like AND
                        	  1807: ;------------------------------------
                        	  1808: OPCODE_ASS_OPERAND_ZERO_PAGE_TOKENISED = *
00:A5F7 8D              	  1809:   dfb TOKEN_AND,$25
00:A5F8 25
00:A5F9 00              	  1810:   dfb 0
                        	  1811: 
                        	  1812: 
                        	  1813: ;------------------------------------
                        	  1814: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
                        	  1815: ;------------------------------------
                        	  1816: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT = *
00:A5FA 414443          	  1817:   asc "ADC",$61
00:A5FD 61
00:A5FE 414E44          	  1818:   asc "AND",$21
00:A601 21
00:A602 434D50          	  1819:   asc "CMP",$C1
00:A605 C1
00:A606 454F52          	  1820:   asc "EOR",$41
00:A609 41
00:A60A 4C4441          	  1821:   asc "LDA",$A1
00:A60D A1
00:A60E 4F5241          	  1822:   asc "ORA",$01
00:A611 01
00:A612 534243          	  1823:   asc "SBC",$E1
00:A615 E1
00:A616 535441          	  1824:   asc "STA",$81
00:A619 81
00:A61A 00              	  1825:   dfb 0
                        	  1826: 
                        	  1827: ;------------------------------------
                        	  1828: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT  - for tokenised opcodes like AND
                        	  1829: ;------------------------------------
                        	  1830: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT_TOKENISED  = *
00:A61B 8D              	  1831:   dfb TOKEN_AND,$21
00:A61C 21
00:A61D 00              	  1832:   dfb 0
                        	  1833: 
                        	  1834: 
                        	  1835: ;------------------------------------
                        	  1836: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
                        	  1837: ;------------------------------------
                        	  1838: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X = *
00:A61E 414443          	  1839:   asc "ADC",$75
00:A621 75
00:A622 414E44          	  1840:   asc "AND",$35
00:A625 35
00:A626 41534C          	  1841:   asc "ASL",$16
00:A629 16
00:A62A 424954          	  1842:   asc "BIT",$34
00:A62D 34
00:A62E 434D50          	  1843:   asc "CMP",$D5
00:A631 D5
00:A632 444543          	  1844:   asc "DEC",$D6
00:A635 D6
00:A636 454F52          	  1845:   asc "EOR",$55
00:A639 55
00:A63A 494E43          	  1846:   asc "INC",$F6
00:A63D F6
00:A63E 4C4441          	  1847:   asc "LDA",$B5
00:A641 B5
00:A642 4C4459          	  1848:   asc "LDY",$B4
00:A645 B4
00:A646 4C5352          	  1849:   asc "LSR",$56
00:A649 56
00:A64A 4F5241          	  1850:   asc "ORA",$15
00:A64D 15
00:A64E 524F4C          	  1851:   asc "ROL",$36
00:A651 36
00:A652 524F52          	  1852:   asc "ROR",$76
00:A655 76
00:A656 534243          	  1853:   asc "SBC",$F5
00:A659 F5
00:A65A 535441          	  1854:   asc "STA",$95
00:A65D 95
00:A65E 535459          	  1855:   asc "STY",$94
00:A661 94
00:A662 53545A          	  1856:   asc "STZ",$74
00:A665 74
00:A666 00              	  1857:   dfb 0
                        	  1858: 
                        	  1859: ;------------------------------------
                        	  1860: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X  - for tokenised opcodes like AND
                        	  1861: ;------------------------------------
                        	  1862: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X_TOKENISED = *
00:A667 8D              	  1863:   dfb TOKEN_AND,$35
00:A668 35
00:A669 00              	  1864:   dfb 0
                        	  1865: 
                        	  1866: ;------------------------------------
                        	  1867: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
                        	  1868: ;------------------------------------
                        	  1869: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y = *
00:A66A 4C4458          	  1870:   asc "LDX",$B6
00:A66D B6
00:A66E 535458          	  1871:   asc "STX",$96
00:A671 96
00:A672 00              	  1872:   dfb 0
                        	  1873: 
                        	  1874: ;------------------------------------
                        	  1875: ;  ASS_OPERAND_ZERO_PAGE_INDIRECT
                        	  1876: ;------------------------------------
                        	  1877: OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT = *
00:A673 414443          	  1878:   asc "ADC",$72
00:A676 72
00:A677 414E44          	  1879:   asc "AND",$32
00:A67A 32
00:A67B 434D50          	  1880:   asc "CMP",$D2
00:A67E D2
00:A67F 454F52          	  1881:   asc "EOR",$52
00:A682 52
00:A683 4C4441          	  1882:   asc "LDA",$B2
00:A686 B2
00:A687 4F5241          	  1883:   asc "ORA",$12
00:A68A 12
00:A68B 534243          	  1884:   asc "SBC",$F2
00:A68E F2
00:A68F 535441          	  1885:   asc "STA",$92
00:A692 92
00:A693 00              	  1886:   dfb 0
                        	  1887: 
                        	  1888: ;------------------------------------
                        	  1889: ;  ASS_OPERAND_ZERO_PAGE_INDIRECT  - for tokenised opcodes like AND
                        	  1890: ;------------------------------------
                        	  1891: OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_TOKENISED = *
00:A694 8D              	  1892:   dfb TOKEN_AND,$32
00:A695 32
00:A696 00              	  1893:   dfb 0
                        	  1894: 
                        	  1895: ;------------------------------------
                        	  1896: ;  ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
                        	  1897: ;------------------------------------
                        	  1898: OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y = *
00:A697 414443          	  1899:   asc "ADC",$71
00:A69A 71
00:A69B 414E44          	  1900:   asc "AND",$31
00:A69E 31
00:A69F 434D50          	  1901:   asc "CMP",$D1
00:A6A2 D1
00:A6A3 454F52          	  1902:   asc "EOR",$51
00:A6A6 51
00:A6A7 4C4441          	  1903:   asc "LDA",$B1
00:A6AA B1
00:A6AB 4F5241          	  1904:   asc "ORA",$11
00:A6AE 11
00:A6AF 534243          	  1905:   asc "SBC",$F1
00:A6B2 F1
00:A6B3 535441          	  1906:   asc "STA",$91
00:A6B6 91
00:A6B7 00              	  1907:   dfb 0
                        	  1908: 
                        	  1909: ;------------------------------------
                        	  1910: ;  ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y - for tokenised opcodes like AND
                        	  1911: ;------------------------------------
                        	  1912: OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y_TOKENISED  = *
00:A6B8 8D              	  1913:   dfb TOKEN_AND,$31
00:A6B9 31
00:A6BA 00              	  1914:   dfb 0
                        	  1915: 
                        	  1916: 
                        	  1917: ; ---------------------------
                        	  1918: ; Compiler directives
                        	  1919: ; ---------------------------
                        	  1920: 
                        	  1921: ;
                        	  1922: ;  ASSERT <expression>  - raises an error if <expression> is zero
                        	  1923: ;
                        	  1924: asm_do_assert:
00:A6BB A56B            	  1925:   lda ASS_OPERAND
00:A6BD C901            	  1926:   cmp #ASS_OPERAND_ABSOLUTE
00:A6BF D00E            	  1927:   bne asm_do_constant_expectedJ
00:A6C1 A500            	  1928:   lda VALUE
00:A6C3 0501            	  1929:   ora VALUE+1
00:A6C5 0502            	  1930:   ora VALUE+2
00:A6C7 F001            	  1931:   beq asm_do_assert_failed
00:A6C9 60              	  1932:   rts
                        	  1933: 
                        	  1934: asm_do_assert_failed:
00:A6CA A234            	  1935:   ldx #52
00:A6CC 4C95A1          	  1936:   jmp ass_error
                        	  1937: 
00:A6CF 4C67A7          	  1938: asm_do_constant_expectedJ jmp asm_do_constant_expected
                        	  1939: 
                        	  1940: ;
                        	  1941: ; LIST (0= none, 1=source, 2=opcodes, 4=symbols, can OR these together)
                        	  1942: ; LIST  is the same as LIST 3
                        	  1943: 
                        	  1944: asm_do_list = *
                        	  1945: 
                        	  1946: ;   lda #'f'
                        	  1947: ;   jsr ass_debug_point
                        	  1948: 
00:A6D2 A56B            	  1949:   lda ASS_OPERAND
00:A6D4 C908            	  1950:   cmp #ASS_OPERAND_IMPLIED      ; implied (ie. no operand) will resolve to be the same as LIST 3
00:A6D6 F01A            	  1951:   beq asm_do_list_no_operand
00:A6D8 C901            	  1952:   cmp #ASS_OPERAND_ABSOLUTE
00:A6DA F01A            	  1953:   beq asm_do_list_ok
00:A6DC A202            	  1954:   ldx #2    ; ERROR: constant expected
00:A6DE 4C95A1          	  1955:   jmp ass_error
                        	  1956: 
                        	  1957: ;
                        	  1958: ;  NOLIST is the same as LIST 0
                        	  1959: ;
                        	  1960: asm_do_nolist:
00:A6E1 A56B            	  1961:   lda ASS_OPERAND
00:A6E3 C908            	  1962:   cmp #ASS_OPERAND_IMPLIED
00:A6E5 F005            	  1963:   beq asm_do_nolist_ok              ; should have no operand
00:A6E7 A217            	  1964:   ldx #23   ; ERROR: Illegal factor
00:A6E9 4C95A1          	  1965:   jmp ass_error
                        	  1966: asm_do_nolist_ok:
00:A6EC A900            	  1967:   lda #0
00:A6EE 8500            	  1968:   sta VALUE
00:A6F0 8004            	  1969:   bra asm_do_list_ok
                        	  1970: 
                        	  1971: asm_do_list_no_operand:
00:A6F2 A903            	  1972:   lda #3
00:A6F4 8573            	  1973:   sta ASS_VALUE
                        	  1974: asm_do_list_ok:
00:A6F6 A576            	  1975:   lda ASS_PASS
00:A6F8 F025            	  1976:   beq asm_do_list_first_pass  ; ignore on first pass
                        	  1977: 
                        	  1978: ;  lda ASS_VALUE
                        	  1979: ;  clc
                        	  1980: ;  adc #'0'
                        	  1981: ;  jsr ass_debug_point
                        	  1982: 
00:A6FA A573            	  1983:   lda ASS_VALUE
00:A6FC 2901            	  1984:   and #$01
00:A6FE F00C            	  1985:   beq asm_do_list_not    ; no listing wanted
00:A700 A904            	  1986:   lda #FLAG_LIST_SOURCE ; already listing?
00:A702 25BE            	  1987:   and system_flags
00:A704 D00A            	  1988:   bne  asm_do_list1   ; yep
00:A706 A904            	  1989:   lda #FLAG_LIST_SOURCE
00:A708 04BE            	  1990:   tsb system_flags
                        	  1991: ;  jsr token_line        ; list the current line  TODO: don't know, I think it bumps the line number wrongly
00:A70A 8004            	  1992:   bra asm_do_list1
                        	  1993: 
                        	  1994: ;
                        	  1995: ;  turn off list flag
                        	  1996: ;
                        	  1997: asm_do_list_not:
00:A70C A904            	  1998:   lda #FLAG_LIST_SOURCE
00:A70E 14BE            	  1999:   trb system_flags
                        	  2000: 
                        	  2001: asm_do_list1:
                        	  2002: 
                        	  2003: 
00:A710 A573            	  2004:   lda ASS_VALUE
00:A712 2902            	  2005:   and #$02
00:A714 852E            	  2006:   sta DCODE
                        	  2007: 
                        	  2008: 
00:A716 A573            	  2009:   lda ASS_VALUE
00:A718 290C            	  2010:   and #($04|$08)
00:A71A 8582            	  2011:   sta show_symbols
                        	  2012: ;
                        	  2013: ;  output a newline, to get past the asterisks
                        	  2014: ;
00:A71C 200C95          	  2015:   jsr CROUT
                        	  2016: asm_do_list_first_pass:
00:A71F 60              	  2017:   rts
                        	  2018: 
                        	  2019: ;
                        	  2020: ;  ASC "String"
                        	  2021: ;
                        	  2022: asm_do_asc = *
00:A720 A56B            	  2023:   lda ASS_OPERAND
00:A722 C911            	  2024:   cmp #ASS_OPERAND_STRING
00:A724 F005            	  2025:   beq asm_do_asc_ok
00:A726 A208            	  2026:   ldx #8    ; ERROR: incorrect string
00:A728 4C95A1          	  2027:   jmp ass_error
                        	  2028: ;
                        	  2029: ;  now emit the string
                        	  2030: ;
                        	  2031: asm_do_asc_ok:
00:A72B A000            	  2032:   ldy  #0
                        	  2033: asm_do_asc_loop:
00:A72D B90002          	  2034:   lda  INBUF,Y
00:A730 C8              	  2035:   iny         ; onto next character in the string
00:A731 5A              	  2036:   phy
00:A732 2057A1          	  2037:   jsr ass_emit
00:A735 7A              	  2038:   ply
                        	  2039: 
                        	  2040: asm_do_asc_next:
00:A736 C692            	  2041:   dec token_length
00:A738 D0F3            	  2042:   bne asm_do_asc_loop
00:A73A 60              	  2043:   rts
                        	  2044: 
                        	  2045: 
                        	  2046: ;
                        	  2047: ;  ASCIIZ / STRING - output a string with a null terminator
                        	  2048: ;
                        	  2049: 
                        	  2050: asm_do_string:
00:A73B 2020A7          	  2051:   jsr asm_do_asc    ; do the string
00:A73E A900            	  2052:   lda #0            ; and the terminator
00:A740 2057A1          	  2053:   jsr ass_emit
00:A743 60              	  2054:   rts
                        	  2055: 
                        	  2056: 
                        	  2057: ;
                        	  2058: ;  EQU
                        	  2059: ;
                        	  2060: ;  The label, which must be present, takes on the value of the expression
                        	  2061: ;
                        	  2062: 
                        	  2063: asm_do_equ:
00:A744 A56B            	  2064:   lda ASS_OPERAND
00:A746 C901            	  2065:   cmp #ASS_OPERAND_ABSOLUTE
00:A748 D01D            	  2066:   bne asm_do_constant_expected
00:A74A A583            	  2067:   lda ass_current_label
00:A74C 0584            	  2068:   ora ass_current_label+1
00:A74E D005            	  2069:   bne asm_do_equ_have_label
00:A750 A230            	  2070:   ldx #48    ; ERROR: label required
00:A752 4C95A1          	  2071:   jmp ass_error
                        	  2072: 
                        	  2073: asm_do_equ_have_label:
00:A755 A004            	  2074:   ldy #SYMDSP
00:A757 A573            	  2075:   lda ASS_VALUE
00:A759 9183            	  2076:   sta (ass_current_label),y
00:A75B C8              	  2077:   iny
00:A75C A574            	  2078:   lda ASS_VALUE+1
00:A75E 9183            	  2079:   sta (ass_current_label),y
00:A760 60              	  2080:   rts
                        	  2081: 
                        	  2082: ;
                        	  2083: ;  ORG
                        	  2084: ;
                        	  2085: ;  The program counter becomes the value of the expression
                        	  2086: ;
                        	  2087: 
                        	  2088: asm_do_org:
00:A761 A56B            	  2089:   lda ASS_OPERAND
00:A763 C901            	  2090:   cmp #ASS_OPERAND_ABSOLUTE
00:A765 F005            	  2091:   beq asm_do_org_ok
                        	  2092: asm_do_constant_expected:
00:A767 A202            	  2093:   ldx #2    ; ERROR: constant expected
00:A769 4C95A1          	  2094:   jmp ass_error
                        	  2095: 
                        	  2096: asm_do_org_ok:
00:A76C A573            	  2097:   lda ASS_VALUE
00:A76E 8523            	  2098:   sta PCODE
00:A770 A574            	  2099:   lda ASS_VALUE+1
00:A772 8524            	  2100:   sta PCODE+1
00:A774 60              	  2101:   rts
                        	  2102: 
                        	  2103: ;
                        	  2104: ;  DFB - define one byte (value being the expression)
                        	  2105: ;
                        	  2106: 
                        	  2107: asm_do_dfb:
00:A775 A56B            	  2108:   lda ASS_OPERAND
00:A777 C912            	  2109:   cmp #ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE  ; multiple values?
00:A779 F008            	  2110:   beq asm_do_dfb_multiple
00:A77B C901            	  2111:   cmp #ASS_OPERAND_ABSOLUTE
00:A77D D0E8            	  2112:   bne asm_do_constant_expected
00:A77F 20A7A7          	  2113:   jsr asm_emit_one_byte
00:A782 60              	  2114:   rts
                        	  2115: 
                        	  2116: ;
                        	  2117: ;  so if we got here we thought we had two values (like a BBR0 $12,foo)
                        	  2118: ;  - the first is in REMAIN and the other in VALUE
                        	  2119: ;
                        	  2120: ;  let's emit REMAIN, then VALUE, then look for other values
                        	  2121: ;
                        	  2122: asm_do_dfb_multiple:
00:A783 A507            	  2123:   lda REMAIN+1
00:A785 D01B            	  2124:   bne asm_do_dfb_too_big
00:A787 A508            	  2125:   lda REMAIN+2
00:A789 D017            	  2126:   bne asm_do_dfb_too_big
00:A78B A506            	  2127:   lda REMAIN
00:A78D 2057A1          	  2128:   jsr ass_emit  ; emit REMAIN
                        	  2129: asm_do_dfb_multiple_loop:
00:A790 20A7A7          	  2130:   jsr asm_emit_one_byte  ; emit VALUE
00:A793 A593            	  2131:   lda token_type
00:A795 C92C            	  2132:   cmp #','      ; another?
00:A797 D008            	  2133:   bne asm_do_dfb_multiple_done
00:A799 208FCC          	  2134:   jsr get_token
00:A79C 20C29F          	  2135:   jsr ass_get_value  ; should have some sort of address now in VALUE
00:A79F 80EF            	  2136:   bra asm_do_dfb_multiple_loop
                        	  2137: 
                        	  2138: asm_do_dfb_multiple_done:
00:A7A1 60              	  2139:   rts
                        	  2140: 
                        	  2141: 
                        	  2142: asm_do_dfb_too_big:
00:A7A2 A22C            	  2143:   ldx #44
00:A7A4 4C95A1          	  2144:   jmp ass_error
                        	  2145: 
                        	  2146: asm_emit_one_byte:
00:A7A7 A574            	  2147:   lda ASS_VALUE+1
00:A7A9 D0F7            	  2148:   bne asm_do_dfb_too_big
00:A7AB A575            	  2149:   lda ASS_VALUE+2
00:A7AD D0F3            	  2150:   bne asm_do_dfb_too_big
00:A7AF A573            	  2151:   lda ASS_VALUE
00:A7B1 2057A1          	  2152:   jsr ass_emit
00:A7B4 60              	  2153:   rts
                        	  2154: 
                        	  2155: 
                        	  2156: ;
                        	  2157: ;  DFW - define two bytes (value being the expression)
                        	  2158: ;
                        	  2159: 
                        	  2160: asm_do_dfw:
00:A7B5 A56B            	  2161:   lda ASS_OPERAND
00:A7B7 C912            	  2162:   cmp #ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE  ; multiple values?
00:A7B9 F008            	  2163:   beq asm_do_dfw_multiple
00:A7BB C901            	  2164:   cmp #ASS_OPERAND_ABSOLUTE
00:A7BD D0A8            	  2165:   bne asm_do_constant_expected
00:A7BF 20E3A7          	  2166:   jsr asm_emit_two_bytes
00:A7C2 60              	  2167:   rts
                        	  2168: 
                        	  2169: ;
                        	  2170: ;  so if we got here we thought we had two values (like a BBR0 $12,foo)
                        	  2171: ;  - the first is in REMAIN and the other in VALUE
                        	  2172: ;
                        	  2173: ;  let's emit REMAIN, then VALUE, then look for other values
                        	  2174: ;
                        	  2175: asm_do_dfw_multiple:
00:A7C3 A508            	  2176:   lda REMAIN+2
00:A7C5 D0DB            	  2177:   bne asm_do_dfb_too_big
00:A7C7 A506            	  2178:   lda REMAIN
00:A7C9 2057A1          	  2179:   jsr ass_emit  ; emit REMAIN
00:A7CC A507            	  2180:   lda REMAIN+1
00:A7CE 2057A1          	  2181:   jsr ass_emit  ; emit REMAIN+1
                        	  2182: asm_do_dfw_multiple_loop:
00:A7D1 20E3A7          	  2183:   jsr asm_emit_two_bytes  ; emit VALUE
00:A7D4 A593            	  2184:   lda token_type
00:A7D6 C92C            	  2185:   cmp #','      ; another?
00:A7D8 D008            	  2186:   bne asm_do_dfw_multiple_done
00:A7DA 208FCC          	  2187:   jsr get_token
00:A7DD 20C29F          	  2188:   jsr ass_get_value  ; should have some sort of address now in VALUE
00:A7E0 80EF            	  2189:   bra asm_do_dfw_multiple_loop
                        	  2190: 
                        	  2191: asm_do_dfw_multiple_done:
00:A7E2 60              	  2192:   rts
                        	  2193: 
                        	  2194: 
                        	  2195: asm_emit_two_bytes:
00:A7E3 A575            	  2196:   lda ASS_VALUE+2
00:A7E5 D0BB            	  2197:   bne asm_do_dfb_too_big
00:A7E7 A573            	  2198:   lda ASS_VALUE
00:A7E9 2057A1          	  2199:   jsr ass_emit
00:A7EC A574            	  2200:   lda ASS_VALUE+1
00:A7EE 2057A1          	  2201:   jsr ass_emit
00:A7F1 60              	  2202:   rts
                        	  2203: 
                        	  2204: 
                        	  2205: 
                        	  2206: ;
                        	  2207: ;  BLK - zero fill <expression> bytes (eg. BLK 5 output 5 zeroes)
                        	  2208: ;
                        	  2209: 
                        	  2210: asm_do_blk:
00:A7F2 A56B            	  2211:   lda ASS_OPERAND
00:A7F4 C901            	  2212:   cmp #ASS_OPERAND_ABSOLUTE
00:A7F6 D030            	  2213:   bne asm_do_constant_expectedJ2
00:A7F8 A575            	  2214:   lda ASS_VALUE+2
00:A7FA D0A6            	  2215:   bne asm_do_dfb_too_big
                        	  2216: ;
                        	  2217: ; handle (obscure) case of them defining zero bytes
                        	  2218: ;
00:A7FC A573            	  2219:   lda ASS_VALUE
00:A7FE 0574            	  2220:   ora ASS_VALUE+1
00:A800 F00D            	  2221:   beq asm_do_blk_done
                        	  2222: asm_do_blk_loop:
                        	  2223: ;
                        	  2224: ;  emit one zero
                        	  2225: ;
00:A802 A900            	  2226:   lda #0
00:A804 2057A1          	  2227:   jsr ass_emit
00:A807 C673            	  2228:   dec ASS_VALUE
00:A809 D0F7            	  2229:   bne asm_do_blk_loop
00:A80B C674            	  2230:   dec ASS_VALUE+1
00:A80D 10F3            	  2231:   bpl asm_do_blk_loop
                        	  2232: asm_do_blk_done:
00:A80F 60              	  2233:   rts
                        	  2234: 
                        	  2235: ;
                        	  2236: ;  RESERVE - reserve <expression> bytes without writing to them
                        	  2237: ;   useful for leaving a gap (eg. for zero-page variables)
                        	  2238: ;
                        	  2239: 
                        	  2240: asm_do_reserve:
00:A810 A56B            	  2241:   lda ASS_OPERAND
00:A812 C901            	  2242:   cmp #ASS_OPERAND_ABSOLUTE
00:A814 D012            	  2243:   bne asm_do_constant_expectedJ2
00:A816 A575            	  2244:   lda ASS_VALUE+2
00:A818 D088            	  2245:   bne asm_do_dfb_too_big
00:A81A 18              	  2246:   clc
00:A81B A523            	  2247:   lda PCODE
00:A81D 6573            	  2248:   adc ASS_VALUE
00:A81F 8523            	  2249:   sta PCODE
00:A821 A524            	  2250:   lda PCODE+1
00:A823 6574            	  2251:   adc ASS_VALUE+1
00:A825 8524            	  2252:   sta PCODE+1
00:A827 60              	  2253:   rts
                        	  2254: 
00:A828 4C67A7          	  2255: asm_do_constant_expectedJ2 jmp asm_do_constant_expected
                        	  2256: 
                        	  2257: ;
                        	  2258: ;  SYM <address> symbol table relocation
                        	  2259: ;
                        	  2260: asm_do_sym:
00:A82B A56B            	  2261:   lda ASS_OPERAND
00:A82D C901            	  2262:   cmp #ASS_OPERAND_ABSOLUTE
00:A82F D0F7            	  2263:   bne asm_do_constant_expectedJ2
                        	  2264: ;
                        	  2265: ;  only relocate symbol table on the first pass
                        	  2266: ;
00:A831 A576            	  2267:   lda ASS_PASS
00:A833 D00F            	  2268:   bne asm_do_sym_done
                        	  2269: 
00:A835 A573            	  2270:   lda  ASS_VALUE
00:A837 8531            	  2271:   sta  ENDSYM
00:A839 852F            	  2272:   sta  STARTSYM
00:A83B A574            	  2273:   lda  ASS_VALUE+1
00:A83D 8532            	  2274:   sta  ENDSYM+1        ; store symbol table address
00:A83F 8530            	  2275:   sta  STARTSYM+1
                        	  2276: ;
                        	  2277: ;  put our library functions back into the symbol table
                        	  2278: ;
00:A841 2071AD          	  2279:   jsr  add_assembler_library_functions  ; add our inbuilt functions to the symbol table
                        	  2280: 
                        	  2281: asm_do_sym_done:
00:A844 60              	  2282:   rts
                        	  2283: ;
                        	  2284: 
                        	  2285: 
00:A845 41646472204E616D	  2286: info_message asciiz "Addr Name\n"
00:A84D 650A
00:A84F 00
                        	  2287: 
                        	  2288: list_symbols  = *
00:A850 A945            	  2289:          lda #<info_message
00:A852 A2A8            	  2290:          ldx #>info_message
00:A854 202682          	  2291:          jsr print
                        	  2292: 
00:A857 A532            	  2293:          lda  ENDSYM+1    ; get the end of the symbol table
00:A859 8541            	  2294:          sta  SYMITM+1    ; make it the current symbol
00:A85B A531            	  2295:          lda  ENDSYM
00:A85D 800B            	  2296:          bra  list_symbols_check
                        	  2297: 
                        	  2298: list_symbols_next =  *
00:A85F A000            	  2299:          ldy  #SYMPRV
00:A861 B140            	  2300:          lda  (SYMITM),Y
00:A863 AA              	  2301:          tax
00:A864 C8              	  2302:          iny
00:A865 B140            	  2303:          lda  (SYMITM),Y
00:A867 8541            	  2304:          sta  SYMITM+1   ; previous link
00:A869 8A              	  2305:          txa
                        	  2306: ;
                        	  2307: ;  go to the previous symbol table item
                        	  2308: ;
                        	  2309: list_symbols_check     =  *
00:A86A 8540            	  2310:          sta  SYMITM
00:A86C C52F            	  2311:          cmp  STARTSYM
00:A86E D009            	  2312:          bne  list_symbols_line
00:A870 A541            	  2313:          lda  SYMITM+1
00:A872 C530            	  2314:          cmp  STARTSYM+1
00:A874 D003            	  2315:          bne  list_symbols_line       ; more to go
00:A876 4CB0A8          	  2316:          jmp  list_symbols_done       ; finished if symitm and symitm+1 are both zero
                        	  2317: 
                        	  2318: list_symbols_line = *
00:A879 A002            	  2319:          ldy  #SYMLIB
00:A87B B140            	  2320:          lda  (SYMITM),Y
00:A87D F006            	  2321:          beq  list_symbols_user
                        	  2322: ;
                        	  2323: ;  this is a library symbol - do they want to see it?
                        	  2324: ;
00:A87F A582            	  2325:          lda show_symbols
00:A881 2908            	  2326:          and #8
00:A883 F0DA            	  2327:          beq list_symbols_next  ; apparently not
                        	  2328: ;
                        	  2329: ;  here to show this symbol
                        	  2330: ;
                        	  2331: list_symbols_user:
00:A885 A004            	  2332:          ldy  #SYMDSP
00:A887 C8              	  2333:          iny
00:A888 B140            	  2334:          lda  (SYMITM),Y  ; displacement
00:A88A 208195          	  2335:          jsr  PRBYTE
00:A88D 88              	  2336:          dey
00:A88E B140            	  2337:          lda  (SYMITM),Y  ; displacement
00:A890 208195          	  2338:          jsr  PRBYTE
00:A893 A920            	  2339:          lda  #' '
00:A895 206995          	  2340:          jsr  PRCHAR
00:A898 A009            	  2341:          ldy  #SYMLEN
00:A89A B140            	  2342:          lda  (SYMITM),Y  ; length
00:A89C AA              	  2343:          tax
00:A89D A00A            	  2344:          ldy  #SYMNAM
                        	  2345: list_symbols_name = *
00:A89F B140            	  2346:          lda  (SYMITM),Y  ; name
00:A8A1 5A              	  2347:          phy
00:A8A2 206995          	  2348:          jsr  PRCHAR
00:A8A5 7A              	  2349:          ply
00:A8A6 C8              	  2350:          iny
00:A8A7 CA              	  2351:          dex
00:A8A8 D0F5            	  2352:          bne list_symbols_name
00:A8AA 200C95          	  2353:          jsr CROUT
00:A8AD 4C5FA8          	  2354:          jmp list_symbols_next
                        	  2355: 
                        	  2356: list_symbols_done = *
00:A8B0 60              	  2357:          rts
                        	  2358: 
                        	  2359: assembler_library_functions_table:
                        	  2360:   makeAsmLibraryFunction "bcd_result",           bcd_result
00:A8B1 6263645F72657375	     1M      asciiz   "bcd_result"
00:A8B9 6C74
00:A8BB 00
00:A8BC 6000            	     2M      word     bcd_result
                        	  2361:   makeAsmLibraryFunction "binary_to_decimal",    binary_to_decimal
00:A8BE 62696E6172795F74	     1M      asciiz   "binary_to_decimal"
00:A8C6 6F5F646563696D61
00:A8CE 6C
00:A8CF 00
00:A8D0 5F94            	     2M      word     binary_to_decimal
                        	  2362:   makeAsmLibraryFunction "call_a",               call_a
00:A8D2 63616C6C5F61    	     1M      asciiz   "call_a"
00:A8D8 00
00:A8D9 1000            	     2M      word     call_a
                        	  2363:   makeAsmLibraryFunction "call_p",               call_p
00:A8DB 63616C6C5F70    	     1M      asciiz   "call_p"
00:A8E1 00
00:A8E2 1300            	     2M      word     call_p
                        	  2364:   makeAsmLibraryFunction "call_s",               call_s
00:A8E4 63616C6C5F73    	     1M      asciiz   "call_s"
00:A8EA 00
00:A8EB 1400            	     2M      word     call_s
                        	  2365:   makeAsmLibraryFunction "call_x",               call_x
00:A8ED 63616C6C5F78    	     1M      asciiz   "call_x"
00:A8F3 00
00:A8F4 1100            	     2M      word     call_x
                        	  2366:   makeAsmLibraryFunction "call_y",               call_y
00:A8F6 63616C6C5F79    	     1M      asciiz   "call_y"
00:A8FC 00
00:A8FD 1200            	     2M      word     call_y
                        	  2367:   makeAsmLibraryFunction "comstl",               COMSTL
00:A8FF 636F6D73746C    	     1M      asciiz   "comstl"
00:A905 00
00:A906 1195            	     2M      word     COMSTL
                        	  2368:   makeAsmLibraryFunction "cout",                 COUT
00:A908 636F7574        	     1M      asciiz   "cout"
00:A90C 00
00:A90D 9A96            	     2M      word     COUT
                        	  2369:   .if USE_CP437_FONT
                        	  2370:     makeAsmLibraryFunction "cp437_font",         cp437_font
00:A90F 63703433375F666F	     1M      asciiz   "cp437_font"
00:A917 6E74
00:A919 00
00:A91A C6D4            	     2M      word     cp437_font
                        	  2371:   .endif
                        	  2372:   makeAsmLibraryFunction "crc16",                crc16
00:A91C 6372633136      	     1M      asciiz   "crc16"
00:A921 00
00:A922 E192            	     2M      word     crc16
                        	  2373:   makeAsmLibraryFunction "crc_addr",             crc_addr
00:A924 6372635F61646472	     1M      asciiz   "crc_addr"
00:A92C 00
00:A92D 0000            	     2M      word     crc_addr
                        	  2374:   makeAsmLibraryFunction "crc_byte",             crc_byte
00:A92F 6372635F62797465	     1M      asciiz   "crc_byte"
00:A937 00
00:A938 0993            	     2M      word     crc_byte
                        	  2375:   makeAsmLibraryFunction "crc_num",              crc_num
00:A93A 6372635F6E756D  	     1M      asciiz   "crc_num"
00:A941 00
00:A942 0300            	     2M      word     crc_num
                        	  2376:   makeAsmLibraryFunction "crc_val",              crc_val
00:A944 6372635F76616C  	     1M      asciiz   "crc_val"
00:A94B 00
00:A94C 0600            	     2M      word     crc_val
                        	  2377:   makeAsmLibraryFunction "crout",                CROUT
00:A94E 63726F7574      	     1M      asciiz   "crout"
00:A953 00
00:A954 0C95            	     2M      word     CROUT
                        	  2378:   makeAsmLibraryFunction "delay_1ms",            delay_1ms
00:A956 64656C61795F316D	     1M      asciiz   "delay_1ms"
00:A95E 73
00:A95F 00
00:A960 AF93            	     2M      word     delay_1ms
                        	  2379:   makeAsmLibraryFunction "delay",                delay
00:A962 64656C6179      	     1M      asciiz   "delay"
00:A967 00
00:A968 B993            	     2M      word     delay
                        	  2380:   makeAsmLibraryFunction "dest",                 DEST
00:A96A 64657374        	     1M      asciiz   "dest"
00:A96E 00
00:A96F 0300            	     2M      word     DEST
                        	  2381:   makeAsmLibraryFunction "digitalread",          digitalread
00:A971 6469676974616C72	     1M      asciiz   "digitalread"
00:A979 656164
00:A97C 00
00:A97D DCCB            	     2M      word     digitalread
                        	  2382:   makeAsmLibraryFunction "digitalwrite",         digitalwrite
00:A97F 6469676974616C77	     1M      asciiz   "digitalwrite"
00:A987 72697465
00:A98B 00
00:A98C ADCB            	     2M      word     digitalwrite
                        	  2383:   makeAsmLibraryFunction "display_in_decimal",   display_in_decimal
00:A98E 646973706C61795F	     1M      asciiz   "display_in_decimal"
00:A996 696E5F646563696D
00:A99E 616C
00:A9A0 00
00:A9A1 3694            	     2M      word     display_in_decimal
                        	  2384:   makeAsmLibraryFunction "exp_abs_val",          exp_abs_val
00:A9A3 6578705F6162735F	     1M      asciiz   "exp_abs_val"
00:A9AB 76616C
00:A9AE 00
00:A9AF 2BAF            	     2M      word     exp_abs_val
                        	  2385:   makeAsmLibraryFunction "exp_add",              exp_add
00:A9B1 6578705F616464  	     1M      asciiz   "exp_add"
00:A9B8 00
00:A9B9 C2AD            	     2M      word     exp_add
                        	  2386:   makeAsmLibraryFunction "exp_bitwise_and",      exp_bitwise_and
00:A9BB 6578705F62697477	     1M      asciiz   "exp_bitwise_and"
00:A9C3 6973655F616E64
00:A9CA 00
00:A9CB 65AE            	     2M      word     exp_bitwise_and
                        	  2387:   makeAsmLibraryFunction "exp_bitwise_or",       exp_bitwise_or
00:A9CD 6578705F62697477	     1M      asciiz   "exp_bitwise_or"
00:A9D5 6973655F6F72
00:A9DB 00
00:A9DC 50AE            	     2M      word     exp_bitwise_or
                        	  2388:   makeAsmLibraryFunction "exp_bitwise_xor",      exp_bitwise_xor
00:A9DE 6578705F62697477	     1M      asciiz   "exp_bitwise_xor"
00:A9E6 6973655F786F72
00:A9ED 00
00:A9EE 7AAE            	     2M      word     exp_bitwise_xor
                        	  2389:   makeAsmLibraryFunction "exp_divide",           exp_divide
00:A9F0 6578705F64697669	     1M      asciiz   "exp_divide"
00:A9F8 6465
00:A9FA 00
00:A9FB C9AF            	     2M      word     exp_divide
                        	  2390:   makeAsmLibraryFunction "exp_eql",              exp_eql
00:A9FD 6578705F65716C  	     1M      asciiz   "exp_eql"
00:AA04 00
00:AA05 FCAD            	     2M      word     exp_eql
                        	  2391:   makeAsmLibraryFunction "exp_false",            exp_false
00:AA07 6578705F66616C73	     1M      asciiz   "exp_false"
00:AA0F 65
00:AA10 00
00:AA11 F5AD            	     2M      word     exp_false
                        	  2392:   makeAsmLibraryFunction "exp_geq",              exp_geq
00:AA13 6578705F676571  	     1M      asciiz   "exp_geq"
00:AA1A 00
00:AA1B 49AE            	     2M      word     exp_geq
                        	  2393:   makeAsmLibraryFunction "exp_greater_than",     exp_greater_than
00:AA1D 6578705F67726561	     1M      asciiz   "exp_greater_than"
00:AA25 7465725F7468616E
00:AA2D 00
00:AA2E 2BAE            	     2M      word     exp_greater_than
                        	  2394:   makeAsmLibraryFunction "exp_high_byte",        exp_high_byte
00:AA30 6578705F68696768	     1M      asciiz   "exp_high_byte"
00:AA38 5F62797465
00:AA3D 00
00:AA3E 22AF            	     2M      word     exp_high_byte
                        	  2395:   makeAsmLibraryFunction "exp_leq",              exp_leq
00:AA40 6578705F6C6571  	     1M      asciiz   "exp_leq"
00:AA47 00
00:AA48 3AAE            	     2M      word     exp_leq
                        	  2396:   makeAsmLibraryFunction "exp_less_than",        exp_less_than
00:AA4A 6578705F6C657373	     1M      asciiz   "exp_less_than"
00:AA52 5F7468616E
00:AA57 00
00:AA58 24AE            	     2M      word     exp_less_than
                        	  2397:   makeAsmLibraryFunction "exp_logical_and",      exp_logical_and
00:AA5A 6578705F6C6F6769	     1M      asciiz   "exp_logical_and"
00:AA62 63616C5F616E64
00:AA69 00
00:AA6A A4AE            	     2M      word     exp_logical_and
                        	  2398:   makeAsmLibraryFunction "exp_logical_or",       exp_logical_or
00:AA6C 6578705F6C6F6769	     1M      asciiz   "exp_logical_or"
00:AA74 63616C5F6F72
00:AA7A 00
00:AA7B 95AE            	     2M      word     exp_logical_or
                        	  2399:   makeAsmLibraryFunction "exp_low_byte",         exp_low_byte
00:AA7D 6578705F6C6F775F	     1M      asciiz   "exp_low_byte"
00:AA85 62797465
00:AA89 00
00:AA8A 1DAF            	     2M      word     exp_low_byte
                        	  2400:   makeAsmLibraryFunction "exp_modulo",           exp_modulo
00:AA8C 6578705F6D6F6475	     1M      asciiz   "exp_modulo"
00:AA94 6C6F
00:AA96 00
00:AA97 29B0            	     2M      word     exp_modulo
                        	  2401:   makeAsmLibraryFunction "exp_multiply",         exp_multiply
00:AA99 6578705F6D756C74	     1M      asciiz   "exp_multiply"
00:AAA1 69706C79
00:AAA5 00
00:AAA6 90AF            	     2M      word     exp_multiply
                        	  2402:   makeAsmLibraryFunction "exp_negate",           exp_negate
00:AAA8 6578705F6E656761	     1M      asciiz   "exp_negate"
00:AAB0 7465
00:AAB2 00
00:AAB3 E8AE            	     2M      word     exp_negate
                        	  2403:   makeAsmLibraryFunction "exp_neq",              exp_neq
00:AAB5 6578705F6E6571  	     1M      asciiz   "exp_neq"
00:AABC 00
00:AABD 10AE            	     2M      word     exp_neq
                        	  2404:   makeAsmLibraryFunction "exp_not",              exp_not
00:AABF 6578705F6E6F74  	     1M      asciiz   "exp_not"
00:AAC6 00
00:AAC7 FBAE            	     2M      word     exp_not
                        	  2405:   makeAsmLibraryFunction "exp_shift_left",       exp_shift_left
00:AAC9 6578705F73686966	     1M      asciiz   "exp_shift_left"
00:AAD1 745F6C656674
00:AAD7 00
00:AAD8 B6AE            	     2M      word     exp_shift_left
                        	  2406:   makeAsmLibraryFunction "exp_shift_right",      exp_shift_right
00:AADA 6578705F73686966	     1M      asciiz   "exp_shift_right"
00:AAE2 745F7269676874
00:AAE9 00
00:AAEA CFAE            	     2M      word     exp_shift_right
                        	  2407:   makeAsmLibraryFunction "exp_subtract",         exp_subtract
00:AAEC 6578705F73756274	     1M      asciiz   "exp_subtract"
00:AAF4 72616374
00:AAF8 00
00:AAF9 D6AD            	     2M      word     exp_subtract
                        	  2408:   makeAsmLibraryFunction "exp_true",             exp_true
00:AAFB 6578705F74727565	     1M      asciiz   "exp_true"
00:AB03 00
00:AB04 ECAD            	     2M      word     exp_true
                        	  2409:   makeAsmLibraryFunction "exp_unary_minus",      exp_unary_minus
00:AB06 6578705F756E6172	     1M      asciiz   "exp_unary_minus"
00:AB0E 795F6D696E7573
00:AB15 00
00:AB16 09AF            	     2M      word     exp_unary_minus
                        	  2410:   makeAsmLibraryFunction "gen_random",           gen_random
00:AB18 67656E5F72616E64	     1M      asciiz   "gen_random"
00:AB20 6F6D
00:AB22 00
00:AB23 BE92            	     2M      word     gen_random
                        	  2411:   makeAsmLibraryFunction "getin",                GETIN
00:AB25 676574696E      	     1M      asciiz   "getin"
00:AB2A 00
00:AB2B 0FCC            	     2M      word     GETIN
                        	  2412:   makeAsmLibraryFunction "hardware_init",        hardware_init
00:AB2D 6861726477617265	     1M      asciiz   "hardware_init"
00:AB35 5F696E6974
00:AB3A 00
00:AB3B 26CC            	     2M      word     hardware_init
                        	  2413:   makeAsmLibraryFunction "i2c_init",             i2c_init
00:AB3D 6932635F696E6974	     1M      asciiz   "i2c_init"
00:AB45 00
00:AB46 B0D2            	     2M      word     i2c_init
                        	  2414:   makeAsmLibraryFunction "i2c_receive",          i2c_receive
00:AB48 6932635F72656365	     1M      asciiz   "i2c_receive"
00:AB50 697665
00:AB53 00
00:AB54 DFD3            	     2M      word     i2c_receive
                        	  2415:   makeAsmLibraryFunction "i2c_send",             i2c_send
00:AB56 6932635F73656E64	     1M      asciiz   "i2c_send"
00:AB5E 00
00:AB5F B6D3            	     2M      word     i2c_send
                        	  2416:   makeAsmLibraryFunction "inbuf",                INBUF
00:AB61 696E627566      	     1M      asciiz   "inbuf"
00:AB66 00
00:AB67 0002            	     2M      word     INBUF
                        	  2417:   makeAsmLibraryFunction "isalnum",              isalnum
00:AB69 6973616C6E756D  	     1M      asciiz   "isalnum"
00:AB70 00
00:AB71 6281            	     2M      word     isalnum
                        	  2418:   makeAsmLibraryFunction "isalpha",              isalpha
00:AB73 6973616C706861  	     1M      asciiz   "isalpha"
00:AB7A 00
00:AB7B 2681            	     2M      word     isalpha
                        	  2419:   makeAsmLibraryFunction "iscntrl",              iscntrl
00:AB7D 6973636E74726C  	     1M      asciiz   "iscntrl"
00:AB84 00
00:AB85 5681            	     2M      word     iscntrl
                        	  2420:   makeAsmLibraryFunction "isdigit",              isdigit
00:AB87 69736469676974  	     1M      asciiz   "isdigit"
00:AB8E 00
00:AB8F 3281            	     2M      word     isdigit
                        	  2421:   makeAsmLibraryFunction "islower",              islower
00:AB91 69736C6F776572  	     1M      asciiz   "islower"
00:AB98 00
00:AB99 1A81            	     2M      word     islower
                        	  2422:   makeAsmLibraryFunction "isspace",              isspace
00:AB9B 69737370616365  	     1M      asciiz   "isspace"
00:ABA2 00
00:ABA3 4A81            	     2M      word     isspace
                        	  2423:   makeAsmLibraryFunction "isupper",              isupper
00:ABA5 69737570706572  	     1M      asciiz   "isupper"
00:ABAC 00
00:ABAD 0E81            	     2M      word     isupper
                        	  2424:   makeAsmLibraryFunction "isxdigit",             isxdigit
00:ABAF 6973786469676974	     1M      asciiz   "isxdigit"
00:ABB7 00
00:ABB8 3E81            	     2M      word     isxdigit
                        	  2425:   makeAsmLibraryFunction "lcd_clear_display",    lcd_clear_display
00:ABBA 6C63645F636C6561	     1M      asciiz   "lcd_clear_display"
00:ABC2 725F646973706C61
00:ABCA 79
00:ABCB 00
00:ABCC E7BB            	     2M      word     lcd_clear_display
                        	  2426:   makeAsmLibraryFunction "lcd_get_address",      lcd_get_address
00:ABCE 6C63645F6765745F	     1M      asciiz   "lcd_get_address"
00:ABD6 61646472657373
00:ABDD 00
00:ABDE 73BB            	     2M      word     lcd_get_address
                        	  2427:   makeAsmLibraryFunction "lcd_home",             lcd_home
00:ABE0 6C63645F686F6D65	     1M      asciiz   "lcd_home"
00:ABE8 00
00:ABE9 F7BB            	     2M      word     lcd_home
                        	  2428:   makeAsmLibraryFunction "lcd_instruction",      lcd_instruction
00:ABEB 6C63645F696E7374	     1M      asciiz   "lcd_instruction"
00:ABF3 72756374696F6E
00:ABFA 00
00:ABFB 93BB            	     2M      word     lcd_instruction
                        	  2429:   makeAsmLibraryFunction "lcd_print_char",       lcd_print_char
00:ABFD 6C63645F7072696E	     1M      asciiz   "lcd_print_char"
00:AC05 745F63686172
00:AC0B 00
00:AC0C B5BB            	     2M      word     lcd_print_char
                        	  2430:   makeAsmLibraryFunction "lcd_print_message",    lcd_print_message
00:AC0E 6C63645F7072696E	     1M      asciiz   "lcd_print_message"
00:AC16 745F6D6573736167
00:AC1E 65
00:AC1F 00
00:AC20 FFBB            	     2M      word     lcd_print_message
                        	  2431:   makeAsmLibraryFunction "lcd_second_line",      lcd_second_line
00:AC22 6C63645F7365636F	     1M      asciiz   "lcd_second_line"
00:AC2A 6E645F6C696E65
00:AC31 00
00:AC32 EFBB            	     2M      word     lcd_second_line
                        	  2432:   makeAsmLibraryFunction "lcd_wait",             lcd_wait
00:AC34 6C63645F77616974	     1M      asciiz   "lcd_wait"
00:AC3C 00
00:AC3D 58BB            	     2M      word     lcd_wait
                        	  2433:   makeAsmLibraryFunction "nmi",                  RESTART
00:AC3F 6E6D69          	     1M      asciiz   "nmi"
00:AC42 00
00:AC43 4CDD            	     2M      word     RESTART
                        	  2434:   makeAsmLibraryFunction "pinmode",              pinmode
00:AC45 70696E6D6F6465  	     1M      asciiz   "pinmode"
00:AC4C 00
00:AC4D 7ECB            	     2M      word     pinmode
                        	  2435:   makeAsmLibraryFunction "prbyte",               PRBYTE
00:AC4F 707262797465    	     1M      asciiz   "prbyte"
00:AC55 00
00:AC56 8195            	     2M      word     PRBYTE
                        	  2436:   makeAsmLibraryFunction "prchar",               PRCHAR
00:AC58 707263686172    	     1M      asciiz   "prchar"
00:AC5E 00
00:AC5F 6995            	     2M      word     PRCHAR
                        	  2437:   makeAsmLibraryFunction "print",                print
00:AC61 7072696E74      	     1M      asciiz   "print"
00:AC66 00
00:AC67 2682            	     2M      word     print
                        	  2438:   makeAsmLibraryFunction "putsp",                PUTSP
00:AC69 7075747370      	     1M      asciiz   "putsp"
00:AC6E 00
00:AC6F 9795            	     2M      word     PUTSP
                        	  2439:   makeAsmLibraryFunction "random",               random
00:AC71 72616E646F6D    	     1M      asciiz   "random"
00:AC77 00
00:AC78 0900            	     2M      word     random
                        	  2440:   makeAsmLibraryFunction "remain",               REMAIN
00:AC7A 72656D61696E    	     1M      asciiz   "remain"
00:AC80 00
00:AC81 0600            	     2M      word     REMAIN
                        	  2441:   makeAsmLibraryFunction "reset",                START
00:AC83 7265736574      	     1M      asciiz   "reset"
00:AC88 00
00:AC89 30DD            	     2M      word     START
                        	  2442:   makeAsmLibraryFunction "serial_available",     serial_available
00:AC8B 73657269616C5F61	     1M      asciiz   "serial_available"
00:AC93 7661696C61626C65
00:AC9B 00
00:AC9C 20CC            	     2M      word     serial_available
                        	  2443:   makeAsmLibraryFunction "serial_print_message", serial_print_message
00:AC9E 73657269616C5F70	     1M      asciiz   "serial_print_message"
00:ACA6 72696E745F6D6573
00:ACAE 73616765
00:ACB2 00
00:ACB3 7ECC            	     2M      word     serial_print_message
                        	  2444:   makeAsmLibraryFunction "spi_init",             spi_init
00:ACB5 7370695F696E6974	     1M      asciiz   "spi_init"
00:ACBD 00
00:ACBE 0CD4            	     2M      word     spi_init
                        	  2445:   makeAsmLibraryFunction "spi_send_two_bytes",   spi_send_two_bytes
00:ACC0 7370695F73656E64	     1M      asciiz   "spi_send_two_bytes"
00:ACC8 5F74776F5F627974
00:ACD0 6573
00:ACD2 00
00:ACD3 B6D4            	     2M      word     spi_send_two_bytes
                        	  2446:   makeAsmLibraryFunction "spi_ss_high",          spi_ss_high
00:ACD5 7370695F73735F68	     1M      asciiz   "spi_ss_high"
00:ACDD 696768
00:ACE0 00
00:ACE1 AED4            	     2M      word     spi_ss_high
                        	  2447:   makeAsmLibraryFunction "spi_ss_low",           spi_ss_low
00:ACE3 7370695F73735F6C	     1M      asciiz   "spi_ss_low"
00:ACEB 6F77
00:ACED 00
00:ACEE A6D4            	     2M      word     spi_ss_low
                        	  2448:   makeAsmLibraryFunction "spi_transfer",         spi_transfer
00:ACF0 7370695F7472616E	     1M      asciiz   "spi_transfer"
00:ACF8 73666572
00:ACFC 00
00:ACFD 42D4            	     2M      word     spi_transfer
                        	  2449:   makeAsmLibraryFunction "srce",                 SRCE
00:ACFF 73726365        	     1M      asciiz   "srce"
00:AD03 00
00:AD04 0000            	     2M      word     SRCE
                        	  2450:   makeAsmLibraryFunction "tknjmp",               TKNJMP
00:AD06 746B6E6A6D70    	     1M      asciiz   "tknjmp"
00:AD0C 00
00:AD0D 7692            	     2M      word     TKNJMP
                        	  2451:   makeAsmLibraryFunction "typing_latency",       typing_latency
00:AD0F 747970696E675F6C	     1M      asciiz   "typing_latency"
00:AD17 6174656E6379
00:AD1D 00
00:AD1E 0D00            	     2M      word     typing_latency
                        	  2452:   makeAsmLibraryFunction "value2",               VALUE2
00:AD20 76616C756532    	     1M      asciiz   "value2"
00:AD26 00
00:AD27 0300            	     2M      word     VALUE2
                        	  2453:   makeAsmLibraryFunction "value",                VALUE
00:AD29 76616C7565      	     1M      asciiz   "value"
00:AD2E 00
00:AD2F 0000            	     2M      word     VALUE
                        	  2454:   makeAsmLibraryFunction "write_char",           write_char
00:AD31 77726974655F6368	     1M      asciiz   "write_char"
00:AD39 6172
00:AD3B 00
00:AD3C 59CC            	     2M      word     write_char
                        	  2455:   makeAsmLibraryFunction "write_function",       write_function
00:AD3E 77726974655F6675	     1M      asciiz   "write_function"
00:AD46 6E6374696F6E
00:AD4C 00
00:AD4D 1700            	     2M      word     write_function
                        	  2456:   makeAsmLibraryFunction "write_to_lcd",         write_to_lcd
00:AD4F 77726974655F746F	     1M      asciiz   "write_to_lcd"
00:AD57 5F6C6364
00:AD5B 00
00:AD5C 04CC            	     2M      word     write_to_lcd
                        	  2457:   makeAsmLibraryFunction "write_to_serial",      write_to_serial
00:AD5E 77726974655F746F	     1M      asciiz   "write_to_serial"
00:AD66 5F73657269616C
00:AD6D 00
00:AD6E F9CB            	     2M      word     write_to_serial
                        	  2458: 
00:AD70 00              	  2459:   dfb 0   ; end of table
                        	  2460: 
                        	  2461: ;
                        	  2462: ;  Assembler library symbols will be loaded from the above table into
                        	  2463: ;  the symbol table. The symbol type will be SYMBOL_CONSTANT, the
                        	  2464: ;  displacement will be the address of the symbol, and SYMLIB will
                        	  2465: ;  be 1 to indicate an inbuilt symbol.
                        	  2466: ;
                        	  2467: 
                        	  2468: add_assembler_library_functions:
00:AD71 A9B1            	  2469:   lda #<assembler_library_functions_table
00:AD73 8500            	  2470:   sta REG
00:AD75 A9A8            	  2471:   lda #>assembler_library_functions_table
00:AD77 8501            	  2472:   sta REG+1
                        	  2473: add_assembler_library_functions_loop:
00:AD79 A000            	  2474:   ldy #0
00:AD7B B100            	  2475:   lda (REG),Y
00:AD7D F042            	  2476:   beq add_assembler_library_functions_done
00:AD7F A500            	  2477:   lda REG
00:AD81 8590            	  2478:   sta token_address
00:AD83 A501            	  2479:   lda REG+1
00:AD85 8591            	  2480:   sta token_address+1
00:AD87 6492            	  2481:   stz token_length
                        	  2482: ;
                        	  2483: ;  find name length
                        	  2484: ;
                        	  2485: add_assembler_library_functions_name_loop
00:AD89 C8              	  2486:   iny
00:AD8A E692            	  2487:   inc token_length
00:AD8C B100            	  2488:   lda (REG),Y
00:AD8E D0F9            	  2489:   bne add_assembler_library_functions_name_loop
00:AD90 5A              	  2490:   phy
00:AD91 2036BD          	  2491:   jsr CHKDUP
00:AD94 A943            	  2492:   lda #SYMBOL_CONSTANT  ; add the symbol as a constant for now
00:AD96 208FBC          	  2493:   jsr ADDSYM
00:AD99 7A              	  2494:   ply
                        	  2495: 
00:AD9A C8              	  2496:   iny             ; get next byte
00:AD9B B100            	  2497:   lda (REG),Y     ; get function address low-byte
00:AD9D 5A              	  2498:   phy
00:AD9E A004            	  2499:   ldy #SYMDSP
00:ADA0 9140            	  2500:   sta (SYMITM),Y  ; save function address low-byte
00:ADA2 7A              	  2501:   ply
                        	  2502: 
00:ADA3 C8              	  2503:   iny             ; get next byte
00:ADA4 B100            	  2504:   lda (REG),Y     ; get function address high-byte
00:ADA6 5A              	  2505:   phy
00:ADA7 A005            	  2506:   ldy #SYMDSP+1
00:ADA9 9140            	  2507:   sta (SYMITM),Y  ; save function address high-byte
00:ADAB A002            	  2508:   ldy #SYMLIB     ; the "level" of library symbols is 1
00:ADAD A901            	  2509:   lda #1
00:ADAF 9140            	  2510:   sta (SYMITM),Y
00:ADB1 7A              	  2511:   ply
                        	  2512: 
00:ADB2 C8              	  2513:   iny         ; get past that last byte
00:ADB3 98              	  2514:   tya         ; move REG onto next entry
00:ADB4 18              	  2515:   clc
00:ADB5 6500            	  2516:   adc REG
00:ADB7 8500            	  2517:   sta REG
00:ADB9 A900            	  2518:   lda #0
00:ADBB 6501            	  2519:   adc REG+1
00:ADBD 8501            	  2520:   sta REG+1
00:ADBF 80B8            	  2521:   bra add_assembler_library_functions_loop
                        	  2522: 
                        	  2523: add_assembler_library_functions_done:
00:ADC1 60              	  2524:   rts
                        	  2525: 

Source: "gpascal.asm"
                        	   182:   .include "math.inc"

Source: "math.inc"
                        	     1: ;--------------------------------------------------
                        	     2: ; Maths routines. 3-byte operations on VALUE and VALUE2
                        	     3: ;
                        	     4: ;--------------------------------------------------
                        	     5: exp_add:
00:ADC2 18              	     6:   clc
00:ADC3 A500            	     7:   lda VALUE
00:ADC5 6503            	     8:   adc VALUE2
00:ADC7 8500            	     9:   sta VALUE
00:ADC9 A501            	    10:   lda VALUE+1
00:ADCB 6504            	    11:   adc VALUE2+1
00:ADCD 8501            	    12:   sta VALUE+1
00:ADCF A502            	    13:   lda VALUE+2
00:ADD1 6505            	    14:   adc VALUE2+2
00:ADD3 8502            	    15:   sta VALUE+2
00:ADD5 60              	    16:   rts
                        	    17: 
                        	    18: ;
                        	    19: ;  subtract VALUE2 from VALUE, store in VALUE, also set the sign bit
                        	    20: ;   and put the low order two bytes in X and Y
                        	    21: ;
                        	    22: exp_subtract:
00:ADD6 38              	    23:   sec
00:ADD7 A500            	    24:   lda VALUE
00:ADD9 E503            	    25:   sbc VALUE2
00:ADDB 8500            	    26:   sta VALUE
00:ADDD A8              	    27:   tay
00:ADDE A501            	    28:   lda VALUE+1
00:ADE0 E504            	    29:   sbc VALUE2+1
00:ADE2 AA              	    30:   tax
00:ADE3 8501            	    31:   sta VALUE+1
00:ADE5 A502            	    32:   lda VALUE+2
00:ADE7 E505            	    33:   sbc VALUE2+2
00:ADE9 8502            	    34:   sta VALUE+2
00:ADEB 60              	    35:   rts
                        	    36: 
                        	    37: exp_true:
00:ADEC A901            	    38:   lda #1
00:ADEE 8500            	    39:   sta VALUE
00:ADF0 6401            	    40:   stz VALUE+1
00:ADF2 6402            	    41:   stz VALUE+2
00:ADF4 60              	    42:   rts
                        	    43: 
                        	    44: exp_false:
00:ADF5 6400            	    45:   stz VALUE
00:ADF7 6401            	    46:   stz VALUE+1
00:ADF9 6402            	    47:   stz VALUE+2
00:ADFB 60              	    48:   rts
                        	    49: 
                        	    50: exp_eql:
00:ADFC A500            	    51:   lda VALUE
00:ADFE C503            	    52:   cmp VALUE2
00:AE00 D0F3            	    53:   bne exp_false
00:AE02 A501            	    54:   lda VALUE+1
00:AE04 C504            	    55:   cmp VALUE2+1
00:AE06 D0ED            	    56:   bne exp_false
00:AE08 A502            	    57:   lda VALUE+2
00:AE0A C505            	    58:   cmp VALUE2+2
00:AE0C D0E7            	    59:   bne exp_false
00:AE0E 80DC            	    60:   bra exp_true
                        	    61: 
                        	    62: exp_neq:
00:AE10 A500            	    63:   lda VALUE
00:AE12 C503            	    64:   cmp VALUE2
00:AE14 D0D6            	    65:   bne exp_true
00:AE16 A501            	    66:   lda VALUE+1
00:AE18 C504            	    67:   cmp VALUE2+1
00:AE1A D0D0            	    68:   bne exp_true
00:AE1C A502            	    69:   lda VALUE+2
00:AE1E C505            	    70:   cmp VALUE2+2
00:AE20 D0CA            	    71:   bne exp_true
00:AE22 80D1            	    72:   bra exp_false
                        	    73: 
                        	    74: exp_less_than:
00:AE24 20D6AD          	    75:   jsr exp_subtract
00:AE27 30C3            	    76:   bmi exp_true
00:AE29 10CA            	    77:   bpl exp_false
                        	    78: 
                        	    79: exp_greater_than:
00:AE2B 20D6AD          	    80:   jsr exp_subtract
00:AE2E 30C5            	    81:   bmi exp_false
00:AE30 D0BA            	    82:   bne exp_true
00:AE32 98              	    83:   tya
00:AE33 D0B7            	    84:   bne exp_true
00:AE35 8A              	    85:   txa
00:AE36 D0B4            	    86:   bne exp_true
00:AE38 10BB            	    87:   bpl exp_false
                        	    88: 
                        	    89: exp_leq:
00:AE3A 20D6AD          	    90:   jsr exp_subtract
00:AE3D 30AD            	    91:   bmi exp_true
00:AE3F D0B4            	    92:   bne exp_false
00:AE41 98              	    93:   tya
00:AE42 D0B1            	    94:   bne exp_false
00:AE44 8A              	    95:   txa
00:AE45 D0AE            	    96:   bne exp_false
00:AE47 10A3            	    97:   bpl exp_true
                        	    98: 
                        	    99: exp_geq:
00:AE49 20D6AD          	   100:   jsr exp_subtract
00:AE4C 30A7            	   101:   bmi exp_false
00:AE4E 109C            	   102:   bpl exp_true
                        	   103: 
                        	   104: exp_bitwise_or:
00:AE50 A500            	   105:   lda VALUE
00:AE52 0503            	   106:   ora VALUE2
00:AE54 8500            	   107:   sta VALUE
00:AE56 A8              	   108:   tay
00:AE57 A501            	   109:   lda VALUE+1
00:AE59 0504            	   110:   ora VALUE2+1
00:AE5B 8501            	   111:   sta VALUE+1
00:AE5D AA              	   112:   tax
00:AE5E A502            	   113:   lda VALUE+2
00:AE60 0505            	   114:   ora VALUE2+2
00:AE62 8502            	   115:   sta VALUE+2
00:AE64 60              	   116:   rts
                        	   117: 
                        	   118: exp_bitwise_and:
00:AE65 A500            	   119:   lda VALUE
00:AE67 2503            	   120:   and VALUE2
00:AE69 8500            	   121:   sta VALUE
00:AE6B A8              	   122:   tay
00:AE6C A501            	   123:   lda VALUE+1
00:AE6E 2504            	   124:   and VALUE2+1
00:AE70 8501            	   125:   sta VALUE+1
00:AE72 AA              	   126:   tax
00:AE73 A502            	   127:   lda VALUE+2
00:AE75 2505            	   128:   and VALUE2+2
00:AE77 8502            	   129:   sta VALUE+2
00:AE79 60              	   130:   rts
                        	   131: 
                        	   132: exp_bitwise_xor:
00:AE7A A500            	   133:   lda VALUE
00:AE7C 4503            	   134:   eor VALUE2
00:AE7E 8500            	   135:   sta VALUE
00:AE80 A8              	   136:   tay
00:AE81 A501            	   137:   lda VALUE+1
00:AE83 4504            	   138:   eor VALUE2+1
00:AE85 8501            	   139:   sta VALUE+1
00:AE87 AA              	   140:   tax
00:AE88 A502            	   141:   lda VALUE+2
00:AE8A 4505            	   142:   eor VALUE2+2
00:AE8C 8502            	   143:   sta VALUE+2
00:AE8E 60              	   144:   rts
                        	   145: 
                        	   146: 
00:AE8F 4CECAD          	   147: exp_trueJ jmp exp_true
00:AE92 4CF5AD          	   148: exp_falseJ jmp exp_false
                        	   149: 
                        	   150: exp_logical_or:
00:AE95 2050AE          	   151:   jsr exp_bitwise_or
00:AE98 D0F5            	   152:   bne exp_trueJ
00:AE9A E000            	   153:   cpx #0
00:AE9C D0F1            	   154:   bne exp_trueJ
00:AE9E C000            	   155:   cpy #0
00:AEA0 D0ED            	   156:   bne exp_trueJ
00:AEA2 80EE            	   157:   bra exp_falseJ
                        	   158: 
                        	   159: exp_logical_and:
00:AEA4 A500            	   160:   lda VALUE
00:AEA6 0501            	   161:   ora VALUE+1
00:AEA8 0502            	   162:   ora VALUE+2
00:AEAA F0E6            	   163:   beq exp_falseJ  ; if VALUE has all bits zero the logical "and" must be false
                        	   164: ;
                        	   165: ;  VALUE is non-zero, how about VALUE2?
                        	   166: ;
00:AEAC A503            	   167:   lda VALUE2
00:AEAE 0504            	   168:   ora VALUE2+1
00:AEB0 0505            	   169:   ora VALUE2+2
00:AEB2 F0DE            	   170:   beq exp_falseJ  ; if VALUE2 has all bits zero the logical "and" must be false
00:AEB4 80D9            	   171:   bra exp_trueJ   ; both are non-zero, therefore the result is true
                        	   172: 
                        	   173: exp_shift_left:
00:AEB6 A504            	   174:   lda VALUE2+1
00:AEB8 0505            	   175:   ora VALUE2+2
00:AEBA D0D6            	   176:   bne exp_falseJ  ; big shifts will return zero
00:AEBC A503            	   177:   lda VALUE2
00:AEBE F00E            	   178:   beq exp_shift_left_done ; shift by zero? we are done then
00:AEC0 AA              	   179:   tax
00:AEC1 29E0            	   180:   and #$E0        ; maximum of 32 shifts
00:AEC3 D0CD            	   181:   bne exp_falseJ
                        	   182: exp_shift_left_loop:
00:AEC5 0600            	   183:   asl VALUE
00:AEC7 2601            	   184:   rol VALUE+1
00:AEC9 2602            	   185:   rol VALUE+2
00:AECB CA              	   186:   dex
00:AECC D0F7            	   187:   bne exp_shift_left_loop
                        	   188: exp_shift_left_done:
00:AECE 60              	   189:   rts
                        	   190: 
                        	   191: exp_shift_right:
00:AECF A504            	   192:   lda VALUE2+1
00:AED1 0505            	   193:   ora VALUE2+2
00:AED3 D0BD            	   194:   bne exp_falseJ  ; big shifts will return zero
00:AED5 A503            	   195:   lda VALUE2
00:AED7 F00E            	   196:   beq exp_shift_right_done ; shift by zero? we are done then
00:AED9 AA              	   197:   tax
00:AEDA 29E0            	   198:   and #$E0        ; maximum of 32 shifts
00:AEDC D0B4            	   199:   bne exp_falseJ
                        	   200: exp_shift_right_loop:
00:AEDE 4602            	   201:   lsr VALUE+2
00:AEE0 6601            	   202:   ror VALUE+1
00:AEE2 6600            	   203:   ror VALUE
00:AEE4 CA              	   204:   dex
00:AEE5 D0F7            	   205:   bne exp_shift_right_loop
                        	   206: exp_shift_right_done:
00:AEE7 60              	   207:   rts
                        	   208: 
                        	   209: exp_negate:
00:AEE8 A500            	   210:   lda VALUE
00:AEEA 49FF            	   211:   eor #$FF
00:AEEC 8500            	   212:   sta VALUE
00:AEEE A501            	   213:   lda VALUE+1
00:AEF0 49FF            	   214:   eor #$FF
00:AEF2 8501            	   215:   sta VALUE+1
00:AEF4 A502            	   216:   lda VALUE+2
00:AEF6 49FF            	   217:   eor #$FF
00:AEF8 8502            	   218:   sta VALUE+2
00:AEFA 60              	   219:   rts
                        	   220: 
                        	   221: exp_not:
00:AEFB A500            	   222:   lda VALUE
00:AEFD D093            	   223:   bne exp_falseJ
00:AEFF A501            	   224:   lda VALUE+1
00:AF01 D08F            	   225:   bne exp_falseJ
00:AF03 A502            	   226:   lda VALUE+2
00:AF05 D08B            	   227:   bne exp_falseJ
00:AF07 8086            	   228:   bra exp_trueJ
                        	   229: 
                        	   230: exp_unary_minus:
00:AF09 38              	   231:   sec
00:AF0A A900            	   232:   lda #0
00:AF0C E500            	   233:   sbc VALUE
00:AF0E 8500            	   234:   sta VALUE
00:AF10 A900            	   235:   lda #0
00:AF12 E501            	   236:   sbc VALUE+1
00:AF14 8501            	   237:   sta VALUE+1
00:AF16 A900            	   238:   lda #0
00:AF18 E502            	   239:   sbc VALUE+2
00:AF1A 8502            	   240:   sta VALUE+2
00:AF1C 60              	   241:   rts
                        	   242: 
                        	   243: 
                        	   244: exp_low_byte:
00:AF1D 6401            	   245:   stz VALUE+1
00:AF1F 6402            	   246:   stz VALUE+2
00:AF21 60              	   247:   rts
                        	   248: 
                        	   249: exp_high_byte:
00:AF22 A501            	   250:   lda VALUE+1
00:AF24 8500            	   251:   sta VALUE
00:AF26 6401            	   252:   stz VALUE+1
00:AF28 6402            	   253:   stz VALUE+2
00:AF2A 60              	   254:   rts
                        	   255: 
                        	   256: ;
                        	   257: ;  make VALUE positive
                        	   258: ;
                        	   259: exp_abs_val:
00:AF2B A502            	   260:   lda  VALUE+2  ; check high-order byte, see if negative
00:AF2D 1013            	   261:   bpl  exp_abs_val_done
                        	   262: exp_negate_val:
00:AF2F 38              	   263:   sec
00:AF30 A900            	   264:   lda  #0
00:AF32 E500            	   265:   sbc  VALUE
00:AF34 8500            	   266:   sta  VALUE
00:AF36 A900            	   267:   lda  #0
00:AF38 E501            	   268:   sbc  VALUE+1
00:AF3A 8501            	   269:   sta  VALUE+1
00:AF3C A900            	   270:   lda  #0
00:AF3E E502            	   271:   sbc  VALUE+2
00:AF40 8502            	   272:   sta  VALUE+2
                        	   273: exp_abs_val_done:
00:AF42 60              	   274:   rts
                        	   275: 
                        	   276: ;
                        	   277: ;  make VALUE2 positive
                        	   278: ;
                        	   279: exp_abs_val2:
00:AF43 A505            	   280:   lda  VALUE2+2  ; check high-order byte, see if negative
00:AF45 1013            	   281:   bpl  exp_abs_val2_done
                        	   282: exp_negate_val2:
00:AF47 38              	   283:   sec
00:AF48 A900            	   284:   lda  #0
00:AF4A E503            	   285:   sbc  VALUE2
00:AF4C 8503            	   286:   sta  VALUE2
00:AF4E A900            	   287:   lda  #0
00:AF50 E504            	   288:   sbc  VALUE2+1
00:AF52 8504            	   289:   sta  VALUE2+1
00:AF54 A900            	   290:   lda  #0
00:AF56 E505            	   291:   sbc  VALUE2+2
00:AF58 8505            	   292:   sta  VALUE2+2
                        	   293: exp_abs_val2_done:
00:AF5A 60              	   294:   rts
                        	   295: 
                        	   296: 
                        	   297: ZERRES:
00:AF5B A900            	   298:   lda  #0
00:AF5D 8552            	   299:   sta  RES
00:AF5F 8553            	   300:   sta  RES+1
00:AF61 8554            	   301:   sta  RES+2
00:AF63 60              	   302:   rts
                        	   303: 
                        	   304: exp_find_sign:
00:AF64 205BAF          	   305:    jsr  ZERRES     ; zero result
00:AF67 A502            	   306:    lda  VALUE+2
00:AF69 2980            	   307:    and  #$80
00:AF6B 855B            	   308:    sta  RMNDR
00:AF6D A505            	   309:    lda  VALUE2+2
00:AF6F 2980            	   310:    and  #$80
00:AF71 455B            	   311:    eor  RMNDR
00:AF73 855B            	   312:    sta  RMNDR     ; RMNDR is 0x80 if the result needs to be negative
00:AF75 202BAF          	   313:    jsr  exp_abs_val
00:AF78 2043AF          	   314:    jsr  exp_abs_val2
00:AF7B 60              	   315:    rts
                        	   316: ;
                        	   317: 
                        	   318: exp_fix_sign:
00:AF7C A55B            	   319:   lda  RMNDR
00:AF7E 100F            	   320:   bpl  exp_fix_sign_done      ; nothing needs to be changed
00:AF80 38              	   321:   sec                         ; subtract result from zero
00:AF81 A900            	   322:   lda  #0
00:AF83 E552            	   323:   sbc  RES
00:AF85 AA              	   324:   tax
00:AF86 A900            	   325:   lda  #0
00:AF88 E553            	   326:   sbc  RES+1
00:AF8A A8              	   327:   tay
00:AF8B A900            	   328:   lda  #0
00:AF8D E554            	   329:   sbc  RES+2
                        	   330: exp_fix_sign_done:
00:AF8F 60              	   331:   rts
                        	   332: 
                        	   333: 
                        	   334: ;
                        	   335: ;  multiply VALUE1 by VALUE2 and store in VALUE
                        	   336: ;
                        	   337: ;  see: https://llx.com/Neil/a2/mult.html for a discussion
                        	   338: ;
                        	   339: 
                        	   340: exp_multiply:
00:AF90 2064AF          	   341:   jsr exp_find_sign
00:AF93 A218            	   342:   ldx  #24       ; for all 24 bits
                        	   343: exp_multiply_loop:
00:AF95 0652            	   344:   asl  RES
00:AF97 2653            	   345:   rol  RES+1
00:AF99 2654            	   346:   rol  RES+2                    ; shift RES left one bit
00:AF9B 0600            	   347:   asl  VALUE
00:AF9D 2601            	   348:   rol  VALUE+1
00:AF9F 2602            	   349:   rol  VALUE+2                  ; shift one argument left one bit and get the low-order bit into carry
00:AFA1 9013            	   350:   bcc  exp_multiply_no_add      ; if no low-order bit, don't add anything
00:AFA3 18              	   351:   clc                           ; add the other argument to the result
00:AFA4 A503            	   352:   lda  VALUE2
00:AFA6 6552            	   353:   adc  RES
00:AFA8 8552            	   354:   sta  RES
00:AFAA A504            	   355:   lda  VALUE2+1
00:AFAC 6553            	   356:   adc  RES+1
00:AFAE 8553            	   357:   sta  RES+1
00:AFB0 A505            	   358:   lda  VALUE2+2
00:AFB2 6554            	   359:   adc  RES+2
00:AFB4 8554            	   360:   sta  RES+2
                        	   361: exp_multiply_no_add:
00:AFB6 CA              	   362:   dex                      ; count bits
00:AFB7 D0DC            	   363:   bne  exp_multiply_loop   ; go back if more to go
00:AFB9 207CAF          	   364:   jsr  exp_fix_sign
00:AFBC A552            	   365:   lda  RES
00:AFBE 8500            	   366:   sta  VALUE
00:AFC0 A553            	   367:   lda  RES+1
00:AFC2 8501            	   368:   sta  VALUE+1
00:AFC4 A554            	   369:   lda  RES+2
00:AFC6 8502            	   370:   sta  VALUE+2
00:AFC8 60              	   371:   rts
                        	   372: 
                        	   373: ;
                        	   374: ;  divide VALUE by VALUE2, store result in VALUE
                        	   375: ;
                        	   376: exp_divide:
00:AFC9 2064AF          	   377:   jsr exp_find_sign
                        	   378: 
00:AFCC A503            	   379:   lda  VALUE2
00:AFCE 0504            	   380:   ora  VALUE2+1
00:AFD0 0505            	   381:   ora  VALUE2+2
00:AFD2 D005            	   382:   bne  exp_divide_not_zero  ; check not dividing by zero
00:AFD4 A22F            	   383:   ldx  #47                  ; ERROR: divide by zero
00:AFD6 4C95A1          	   384:   jmp  ass_error
                        	   385:   ;
                        	   386: exp_divide_not_zero:
00:AFD9 205BAF          	   387:   jsr  ZERRES     ; zero result (RES) - leaves zero in A register
00:AFDC 8506            	   388:   sta  REMAIN
00:AFDE 8507            	   389:   sta  REMAIN+1
00:AFE0 8508            	   390:   sta  REMAIN+2
00:AFE2 A918            	   391:   lda  #24       ; for all 24 bits of the operands ...
00:AFE4 858D            	   392:   sta  maths_work
                        	   393: exp_divide_loop:
00:AFE6 0600            	   394:   asl  VALUE
00:AFE8 2601            	   395:   rol  VALUE+1
00:AFEA 2602            	   396:   rol  VALUE+2    ; shift the dividend left one bit
00:AFEC 2606            	   397:   rol  REMAIN    ; the low-order bit of the dividend is shifted into the remainder
00:AFEE 2607            	   398:   rol  REMAIN+1
00:AFF0 2608            	   399:   rol  REMAIN+2
00:AFF2 38              	   400:   sec
00:AFF3 A506            	   401:   lda  REMAIN    ; do a trial subtraction of: remainder - divisor
00:AFF5 E503            	   402:   sbc  VALUE2
00:AFF7 AA              	   403:   tax
00:AFF8 A507            	   404:   lda  REMAIN+1
00:AFFA E504            	   405:   sbc  VALUE2+1
00:AFFC A8              	   406:   tay
00:AFFD A508            	   407:   lda  REMAIN+2
00:AFFF E505            	   408:   sbc  VALUE2+2
00:B001 300B            	   409:   bmi  exp_divide_subtraction_negative      ; if the subtraction fails (is negative) then discard the result
00:B003 8508            	   410:   sta  REMAIN+2  ; if it succeeds then the result of the subtraction is our new remainder
00:B005 98              	   411:   tya
00:B006 8507            	   412:   sta  REMAIN+1
00:B008 8A              	   413:   txa
00:B009 8506            	   414:   sta  REMAIN
00:B00B 38              	   415:   sec            ; shift a one-bit into the quotient
00:B00C B001            	   416:   bcs  exp_divide_subtraction_positive
                        	   417: exp_divide_subtraction_negative:
00:B00E 18              	   418:   clc            ; here if subtraction failed, quotient (RES) gets a 0-bit shifted in
                        	   419: exp_divide_subtraction_positive:
00:B00F 2652            	   420:   rol  RES       ; the carry bit (from above) is shifted into the quotient
00:B011 2653            	   421:   rol  RES+1
00:B013 2654            	   422:   rol  RES+2
00:B015 C68D            	   423:   dec  maths_work      ; one less bit to go
00:B017 D0CD            	   424:   bne  exp_divide_loop      ; repeat until 24 bits done
00:B019 207CAF          	   425:   jsr  exp_fix_sign
00:B01C A552            	   426:   lda  RES
00:B01E 8500            	   427:   sta  VALUE
00:B020 A553            	   428:   lda  RES+1
00:B022 8501            	   429:   sta  VALUE+1
00:B024 A554            	   430:   lda  RES+2
00:B026 8502            	   431:   sta  VALUE+2
00:B028 60              	   432:   rts
                        	   433: 
                        	   434: exp_modulo:
00:B029 20C9AF          	   435:   jsr exp_divide
00:B02C A506            	   436:   lda REMAIN
00:B02E 8500            	   437:   sta VALUE
00:B030 A507            	   438:   lda REMAIN+1
00:B032 8501            	   439:   sta VALUE+1
00:B034 A508            	   440:   lda REMAIN+2
00:B036 8502            	   441:   sta VALUE+2
00:B038 60              	   442:   rts
                        	   443: 

Source: "gpascal.asm"
                        	   183:   .include "interpreter.inc"

Source: "interpreter.inc"
                        	     1: ;--------------------------------------------------
                        	     2: ; Runtime P-code interpreter
                        	     3: ;
                        	     4: ;--------------------------------------------------
                        	     5: 
                        	     6: 
                        	     7: ;--------------------------------
                        	     8: ; P-codes - these are generated in the compilation phase and looked up
                        	     9: ;           in execution_address_table at runtime
                        	    10: ;
                        	    11: ; Note: some P-codes must appear in sequence, eg. PCODE_STO and PCODE_STOC
                        	    12: ;       That is because one refers to integers (STO) and one refers to characters (STOC)
                        	    13: ;       The code in various places is virtually identical except it adds 1 to the P-code
                        	    14: ;       for characters. These generally are the Load/Store operations.
                        	    15: ;--------------------------------
                        	    16: 
                        	    17: ; Not implemented yet: $05, $13, $15, $39
                        	    18: 
                        	    19: ;                 Code            Description                         Arguments
                        	    20: ;                 ----            -----------------------------       -----------------------
                        	    21: PCODE_LIT     =   $00 ; Dec:  0 - Load constant                     - 3-byte literal (number)
                        	    22: PCODE_STACK   =   $01 ; Dec:  1 - Alter runtime stack to address    - 2-byte stack address
                        	    23: PCODE_NEG     =   $02 ; Dec:  2 - Unary minus 0 - (sp)              - none
                        	    24: PCODE_LIB_CALL =  $03 ; Dec:  3 - Call library function/procedure   - absolute address
                        	    25: PCODE_ADD     =   $04 ; Dec:  4 - Add (sp) to (sp - 1)              - none
                        	    26: PCODE_SUB     =   $06 ; Dec:  6 - Subtract (sp) from (sp - 1)       - none
                        	    27: PCODE_MUL     =   $08 ; Dec:  8 - Multiply (sp) * (sp - 1)          - none
                        	    28: PCODE_DIV     =   $0A ; Dec: 10 - Divide (sp - 1) / (sp)            - none
                        	    29: PCODE_MOD     =   $0B ; Dec: 11 - Modulus (sp - 1) MOD (sp)         - none
                        	    30: PCODE_ADRNN   =   $0C ; Dec: 12 - Address of integer                - level, displ
                        	    31: PCODE_ADRNC   =   $0D ; Dec: 13 - Address of character              - level, displ
                        	    32: PCODE_ADRAN   =   $0E ; Dec: 14 - Address of integer array          - level, displ
                        	    33: PCODE_ADRAC   =   $0F ; Dec: 15 - Address of character array        - level, displ
                        	    34: PCODE_EQL     =   $10 ; Dec: 16 - Test (sp - 1) == (sp)             - none
                        	    35: PCODE_FINISHD =   $11 ; Dec: 17 - Stop run (end program)            - none
                        	    36: PCODE_NEQ     =   $12 ; Dec: 18 - Test (sp - 1) != (sp)             - none
                        	    37: PCODE_LSS     =   $14 ; Dec: 20 - Test (sp - 1) < (sp)              - none
                        	    38: PCODE_GEQ     =   $16 ; Dec: 22 - Test (sp - 1) >= (sp)             - none
                        	    39: PCODE_GTR     =   $18 ; Dec: 24 - Test (sp - 1) > (sp)              - none
                        	    40: PCODE_LEQ     =   $19 ; Dec: 25 - Test (sp - 1) <= (sp)             - none
                        	    41: PCODE_ORR     =   $1A ; Dec: 26 - OR  (sp - 1) | (sp)               - none
                        	    42: PCODE_AND     =   $1B ; Dec: 27 - AND (sp - 1) & (sp)               - none
                        	    43: PCODE_INP     =   $1C ; Dec: 28 - Input number                      - none
                        	    44: PCODE_INPC    =   $1D ; Dec: 29 - Input character                   - none
                        	    45: PCODE_OUT     =   $1E ; Dec: 30 - Output number                     - none
                        	    46: PCODE_OUTC    =   $1F ; Dec: 31 - Output character                  - none
                        	    47: PCODE_EOR     =   $20 ; Dec: 32 - Not (sp) (logical negate)         - none
                        	    48: PCODE_OUH     =   $21 ; Dec: 33 - Output hex number                 - none
                        	    49: PCODE_SHL     =   $22 ; Dec: 34 - Shift left (sp) bits              - none
                        	    50: PCODE_OUS     =   $23 ; Dec: 35 - Output string                     - length, string
                        	    51: PCODE_SHR     =   $24 ; Dec: 36 - Shift right (sp) bits             - none
                        	    52: PCODE_INS     =   $25 ; Dec: 37 - Input string into array           - max, level, displ
                        	    53: PCODE_INC     =   $26 ; Dec: 38 - Increment (sp) by 1               - none
                        	    54: PCODE_CLL     =   $27 ; Dec: 39 - Relative procedure/function call  - level, relative address
                        	    55: PCODE_DEC     =   $28 ; Dec: 40 - Decrement (sp) by 1               - none
                        	    56: PCODE_RTN     =   $29 ; Dec: 41 - Procedure/function return         - none
                        	    57: PCODE_MOV     =   $2A ; Dec: 42 - Copy (sp) to (sp + 1)             - none
                        	    58: PCODE_CLA     =   $2B ; Dec: 43 - Call absolute address             - none
                        	    59: PCODE_LOD     =   $2C ; Dec: 44 - Load integer onto stack           - level, displ
                        	    60: PCODE_LODC    =   $2D ; Dec: 45 - Load character onto stack         - level, displ
                        	    61: PCODE_LDA     =   $2E ; Dec: 46 - Load absolute address integer     - none
                        	    62: PCODE_LDAC    =   $2F ; Dec: 47 - Load absolute address character   - none
                        	    63: PCODE_LDI     =   $30 ; Dec: 48 - Load integer indexed              - level, displ
                        	    64: PCODE_LDIC    =   $31 ; Dec: 49 - Load character indexed            - level, displ
                        	    65: PCODE_STO     =   $32 ; Dec: 50 - Store integer                     - level, displ
                        	    66: PCODE_STOC    =   $33 ; Dec: 51 - Store character                   - level, displ
                        	    67: PCODE_STA     =   $34 ; Dec: 52 - Store integer absolute address    - none
                        	    68: PCODE_STAC    =   $35 ; Dec: 53 - Store character absolute address  - none
                        	    69: PCODE_STI     =   $36 ; Dec: 54 - Store integer indexed             - level, displ
                        	    70: PCODE_STIC    =   $37 ; Dec: 55 - Store character indexed           - level, displ
                        	    71: PCODE_ABSCLL  =   $38 ; Dec: 56 - Absolute procedure/function call  - level, absolute address
                        	    72: PCODE_XOR     =   $3A ; Dec: 58 - XOR (sp - 1) ^ (sp)               - none
                        	    73: PCODE_INT     =   $3B ; Dec: 59 - Increment stack pointer           - increment
                        	    74: PCODE_JMP     =   $3C ; Dec: 60 - Jump unconditionally              - relative address
                        	    75: PCODE_JMZ     =   $3D ; Dec: 61 - Jump if (sp) zero                 - relative address
                        	    76: PCODE_JM1     =   $3E ; Dec: 62 - Jump if (sp) not zero             - relative address
                        	    77: PCODE_OUTCR   =   $40 ; Dec: 64 - Output a carriage-return          - none
                        	    78: PCODE_LCD_WRITE_NUM = $42 ; Dec: 66 - Write number to LCD           - none
                        	    79: PCODE_LCD_WRITE_STR = $43 ; Dec: 67 - Write string to LCD           - none
                        	    80: PCODE_LCD_WRITE_HEX = $44 ; Dec: 68 - Write hex number to LCD       - none
                        	    81: PCODE_LCD_WRITE_CHR = $45 ; Dec: 69 - Write character to LCD        - none
                        	    82: 
                        	    83: PCODE_LAST    =   PCODE_LCD_WRITE_CHR  ; PUT THIS LAST! (error check)                  -
                        	    84: 
                        	    85: ; 0x80 to 0xFF - Load low literal (onto stack), where literal is P-code with 8-bit clear (ie. P-code & 0x7F)
                        	    86: 
                        	    87: 
                        	    88: ;
                        	    89: ;  P-code execution routine lookup.
                        	    90: ;  For symbolic version see list above
                        	    91: ;
                        	    92: ;  Y is zero when starting to execute these routines
                        	    93: ;
                        	    94: execution_address_table  =  *
00:B039 6AB3            	    95:   word  EX_LIT             ; $00 = LIT      Load constant
00:B03B 5EB7            	    96:   word  EX_NEW_STACK       ; $01 =          Change stack to addr
00:B03D 7CB3            	    97:   word  EX_NEG             ; $02 = NEG      Unary minus: 0 - (sp)
00:B03F EAB8            	    98:   word  EX_LIB_CALL        ; $03 = LIB_CALL Library function call
00:B041 85B3            	    99:   word  EX_ADD             ; $04 = ADD      Add (sp) to (sp - 1)
00:B043 98B2            	   100:   word  EX_INVINS          ; $05 =          NOT IMPLEMENTED
00:B045 8EB3            	   101:   word  EX_SUB             ; $06 = SUB      Subtract (sp) from (sp - 1)
00:B047 98B2            	   102:   word  EX_INVINS          ; $07 =          NOT IMPLEMENTED
00:B049 9AB3            	   103:   word  EX_MUL             ; $08 = MUL      Multiply (sp) * (sp - 1)
00:B04B 98B2            	   104:   word  EX_INVINS          ; $09 =          NOT IMPLEMENTED
00:B04D D5B3            	   105:   word  EX_DIV             ; $0A = DIV      Divide (sp - 1) / (sp)
00:B04F AAB3            	   106:   word  EX_MOD             ; $0B = MOD      Modulus (sp - 1) MOD (sp)
00:B051 49B8            	   107:   word  EX_ADRNN           ; $0C = ADRNN    Address of integer
00:B053 39B8            	   108:   word  EX_ADRNC           ; $0D = ADRNC    Address of character
00:B055 57B8            	   109:   word  EX_ADRAN           ; $0E = ADRAN    Address of integer array
00:B057 5DB8            	   110:   word  EX_ADRAC           ; $0F = ADRAC    Address of character array
00:B059 F2B3            	   111:   word  EX_EQL             ; $10 = EQL      Test (sp - 1) == (sp)
00:B05B E5B1            	   112:   word  EX_FINISHD         ; $11 = FINISHD  Stop run (end program)
00:B05D 0CB4            	   113:   word  EX_NEQ             ; $12 = NEQ      Test (sp - 1) != (sp)
00:B05F 98B2            	   114:   word  EX_INVINS          ; $13 =          NOT IMPLEMENTED
00:B061 15B4            	   115:   word  EX_LSS             ; $14 = LSS      Test (sp - 1) < (sp)
00:B063 98B2            	   116:   word  EX_INVINS          ; $15 =          NOT IMPLEMENTED
00:B065 2DB4            	   117:   word  EX_GEQ             ; $16 = GEQ      Test (sp - 1) >= (sp)
00:B067 98B2            	   118:   word  EX_INVINS          ; $17 =          NOT IMPLEMENTED
00:B069 21B4            	   119:   word  EX_GTR             ; $18 = GTR      Test (sp - 1) > (sp)
00:B06B 39B4            	   120:   word  EX_LEQ             ; $19 = LEQ      Test (sp - 1) <= (sp)
00:B06D 4EB4            	   121:   word  EX_ORR             ; $1A = ORR      OR  (sp - 1) | (sp)
00:B06F 57B4            	   122:   word  EX_AND             ; $1B = AND      AND (sp - 1) & (sp)
00:B071 D7B5            	   123:   word  EX_INP             ; $1C = INP      Input number
00:B073 9FB7            	   124:   word  EX_INPC            ; $1D = INPC     Input character
00:B075 17B6            	   125:   word  EX_OUT             ; $1E = OUT      Output number
00:B077 B9B7            	   126:   word  EX_OUTC            ; $1F = OUTC     Output character
00:B079 60B4            	   127:   word  EX_EOR             ; $20 = EOR      Not (sp) (logical negate)
00:B07B 2BB6            	   128:   word  EX_OUH             ; $21 = OUH      Output hex number
00:B07D 69B4            	   129:   word  EX_SHL             ; $22 = SHL      Shift left (sp) bits
00:B07F 4BB6            	   130:   word  EX_OUS             ; $23 = OUS      Output string
00:B081 75B4            	   131:   word  EX_SHR             ; $24 = SHR      Shift right (sp) bits
00:B083 DBB7            	   132:   word  EX_INS             ; $25 = INS      Input string into array
00:B085 81B4            	   133:   word  EX_INC             ; $26 = INC      Increment (sp) by 1
00:B087 85B6            	   134:   word  EX_CLL             ; $27 = CLL      Relative procedure/function call
00:B089 99B4            	   135:   word  EX_DEC             ; $28 = DEC      Decrement (sp) by 1
00:B08B 9EB5            	   136:   word  EX_RTN             ; $29 = RTN      Procedure/function return
00:B08D B1B4            	   137:   word  EX_MOV             ; $2A = MOV      Copy (sp) to (sp + 1)
00:B08F 14B7            	   138:   word  EX_CLA             ; $2B = CLA      Call absolute address
00:B091 D4B4            	   139:   word  EX_LOD             ; $2C = LOD      Load integer onto stack
00:B093 C2B4            	   140:   word  EX_LODC            ; $2D = LODC     Load character onto stack
00:B095 F5B4            	   141:   word  EX_LDA             ; $2E = LDA      Load absolute address integer
00:B097 EAB4            	   142:   word  EX_LDAC            ; $2F = LDAC     Load absolute address character
00:B099 30B5            	   143:   word  EX_LDI             ; $30 = LDI      Load integer indexed
00:B09B 2AB5            	   144:   word  EX_LDIC            ; $31 = LDIC     Load character indexed
00:B09D 43B5            	   145:   word  EX_STO             ; $32 = STO      Store integer
00:B09F 36B5            	   146:   word  EX_STOC            ; $33 = STOC     Store character
00:B0A1 56B5            	   147:   word  EX_STA             ; $34 = STA      Store integer absolute address
00:B0A3 6CB5            	   148:   word  EX_STAC            ; $35 = STAC     Store character absolute address
00:B0A5 83B5            	   149:   word  EX_STI             ; $36 = STI      Store integer indexed
00:B0A7 75B5            	   150:   word  EX_STIC            ; $37 = STIC     Store character indexed
00:B0A9 7EB6            	   151:   word  EX_ABSCLL          ; $38 = ABSCLL   Absolute procedure/function call
00:B0AB 98B2            	   152:   word  EX_INVINS          ; $39 =          NOT IMPLEMENTED
00:B0AD 45B4            	   153:   word  EX_XOR             ; $3A = XOR      XOR (sp - 1) ^ (sp)
00:B0AF 34B7            	   154:   word  EX_INT             ; $3B = INT      Increment stack pointer
00:B0B1 70B7            	   155:   word  EX_JMP             ; $3C = JMP      Jump unconditionally
00:B0B3 83B7            	   156:   word  EX_JMZ             ; $3D = JMZ      Jump if (sp) zero
00:B0B5 94B7            	   157:   word  EX_JM1             ; $3E = JM1      Jump if (sp) not zero
00:B0B7 98B2            	   158:   word  EX_INVINS          ; $3F =          NOT IMPLEMENTED
00:B0B9 45B2            	   159:   word  EX_OUTCR           ; $40 = OUTCR    Output a carriage-return
00:B0BB 98B2            	   160:   word  EX_INVINS          ; $41 =          NOT IMPLEMENTED
00:B0BD 1CB6            	   161:   word  EX_LCD_WRITE_NUM   ; $42 = LCD_WRITE_NUM  Write number to LCD
00:B0BF 50B6            	   162:   word  EX_LCD_WRITE_STR   ; $43 = LCD_WRITE_STR  Write string to LCD
00:B0C1 30B6            	   163:   word  EX_LCD_WRITE_HEX   ; $44 = LCD_WRITE_HEX  Write hex to LCD
00:B0C3 BEB7            	   164:   word  EX_LCD_WRITE_CHR   ; $45 = LCD_WRITE_CHR  Write character to LCD
                        	   165: 
                        	   166: ;--------------------------------------------------------------------------
                        	   167: ;
                        	   168: ;  STACK FRAMES
                        	   169: ;
                        	   170: ;  The compiler can't know where variables are actually going to be stored because
                        	   171: ;  they will be relative to the (interpreter) stack (not the processor stack) which
                        	   172: ;  is an unknown address because procedures/functions can be called directly or from
                        	   173: ;  other procedures/functions.
                        	   174: ;
                        	   175: ;  Hence variables are referenced to BASE which is the base of the current stack frame,
                        	   176: ;  thus a variable will be a certain offset from that. However in the case of nested
                        	   177: ;  calls we need to go back to a previous stack frame. That is what the 6-byte "stack
                        	   178: ;  frame linkage data" is about.
                        	   179: ;
                        	   180: ;  Variables are referred to by a "level difference" and a displacement. For the current
                        	   181: ;  procedure the level difference will be zero, and thus the variable will be BASE +
                        	   182: ;  the offset for this particular variable.
                        	   183: ;
                        	   184: ;  For variables in earlier procedures/functions (ones which called this one) there will
                        	   185: ;  be a level difference, being the depth (lexically) between the called function and the
                        	   186: ;  one with the variable. For example, if foo calls bar, and bar recurses five times, foo
                        	   187: ;  and bar are still only one level apart, from the point of view of accessing foo's
                        	   188: ;  variables.
                        	   189: ;
                        	   190: ;  Thus, to find an address we need to "walk" back through the STATIC stack frame links
                        	   191: ;  (bytes 5 and 6 of the stack frame data) to find the appropriate stack frame, and then
                        	   192: ;  take the offset from that.
                        	   193: ;
                        	   194: ;  However for recursive calls, once a recursed call ends, we need to get back the stack
                        	   195: ;  frame of the caller, which will be different from the static frame. So, to restore the
                        	   196: ;  stack frame after a procedure/function ends, we must take the DYNAMIC stack frame address
                        	   197: ;  (bytes 3 and 4 of the stack frame data) to get back the previous stack frame. In fact,
                        	   198: ;  all procedures/functions do this, it's just that the static and dynamic stack frames will
                        	   199: ;  be the same if the procedure/function does not recurse.
                        	   200: ;
                        	   201: ;  Finally, the return address (in the P-codes) for the procedure/function call is also
                        	   202: ;  stored in the stack frame data (bytes 1 and 2 of the stack frame data) so that, after
                        	   203: ;  doing a return, we can restore the P-code address to the PCODE variable after the call.
                        	   204: ;
                        	   205: ;  When a procedure/function is called these 6 bytes are pushed onto the stack. Then, for
                        	   206: ;  some reason, the code moves the stack pointer back 6 (adds to it). Then as part of the
                        	   207: ;  procedure/function initialisation the stack pointer has 6 or 9 added to it, to allow
                        	   208: ;  for not overwriting this stack frame data, and in the case of functions, the extra 3
                        	   209: ;  bytes are for the returned value.
                        	   210: ;
                        	   211: ;  Note that the stack grows downwards, as it starts at "high memory" (whatever that is
                        	   212: ;  defined as, and grows downwards, taking the gap between the end of the P-codes and the
                        	   213: ;  end of memory.
                        	   214: ;
                        	   215: ;  Then the function will add additional spaces to the stack (ie. by subtracting from the
                        	   216: ;  stack pointer) to make room for variables declared in that procedure/function. Now we
                        	   217: ;  are ready to push data onto the stack as part of normal expression evalution. It follows
                        	   218: ;  from this that variables initially have undefined values, as they will contain whatever
                        	   219: ;  happened to be in the stack when this space was allocated.
                        	   220: ;
                        	   221: ;  The function GETADR resolves these addresses by starting with BASE, the stack frame base
                        	   222: ;  for the current procedure/function, and then using the static stack frame link to load a
                        	   223: ;  (temporary) new base, and repeating that until the level difference is zero. Then it adds
                        	   224: ;  the offset of the wanted variable to the stack base to derive the actual variable address.
                        	   225: ;
                        	   226: ;--------------------------------------------------------------------------
                        	   227: 
                        	   228: 
                        	   229: ;
00:B0C5 20537461636B3A20	   230: DM1               asciiz  ' Stack: '
00:B0CD 00
00:B0CE 20426173653A2020	   231: DM2               asciiz  ' Base:  '
00:B0D6 00
00:B0D7 52756E6E696E670A	   232: running_message   asciiz  'Running\n'
00:B0DF 00
                        	   233: 
                        	   234: ;
                        	   235: DEBUG    =  *
00:B0E0 202795          	   236: DB11     jsr  DISPAD    ; display P-code address
00:B0E3 A523            	   237:          lda  PCODE
00:B0E5 8537            	   238:          sta  WORK
00:B0E7 A524            	   239:          lda  PCODE+1
00:B0E9 8538            	   240:          sta  WORK+1
00:B0EB A204            	   241:          ldx  #4
00:B0ED 20A9B1          	   242:          jsr  display_x_characters      ; display 4 bytes from WORK (ie. the P-codes)
00:B0F0 200C95          	   243:          jsr  CROUT
00:B0F3 A649            	   244:          ldx  DBGFLG
00:B0F5 3051            	   245:          bmi  DEBUG_DONE        ; trace only
00:B0F7 A9C5            	   246:          lda  #<DM1             ; ' Stack: '
00:B0F9 A2B0            	   247:          ldx  #>DM1
00:B0FB 202682          	   248:          jsr  print
00:B0FE A532            	   249:          lda  T+1
00:B100 208195          	   250:          jsr  PRBYTE        ; display the stack pointer address
00:B103 A531            	   251:          lda  T
00:B105 202195          	   252:          jsr  DISHX         ; display hex and a space after
00:B108 A93D            	   253:          lda  #'='
00:B10A 209A96          	   254:          jsr  COUT
00:B10D A531            	   255:          lda  T
00:B10F 8537            	   256:          sta  WORK
00:B111 A532            	   257:          lda  T+1
00:B113 8538            	   258:          sta  WORK+1
00:B115 A209            	   259:          ldx  #9         ; show 9 bytes on stack, namely 3 variables
00:B117 20A9B1          	   260:          jsr  display_x_characters
00:B11A 200C95          	   261:          jsr  CROUT
00:B11D A9CE            	   262:          lda  #<DM2       ; ' Base:  '
00:B11F A2B0            	   263:          ldx  #>DM2
00:B121 202682          	   264:          jsr  print
00:B124 A53C            	   265:          lda  BASE+1
00:B126 208195          	   266:          jsr  PRBYTE      ; display the base pointer address
00:B129 A53B            	   267:          lda  BASE
00:B12B 202195          	   268:          jsr  DISHX
00:B12E A93D            	   269:          lda  #'='
00:B130 209A96          	   270:          jsr  COUT
00:B133 A53B            	   271:          lda  BASE
00:B135 38              	   272:          sec
00:B136 E906            	   273:          sbc  #6    ; the linkage data is 6 bytes below the base
00:B138 8537            	   274:          sta  WORK
00:B13A A53C            	   275:          lda  BASE+1
00:B13C E900            	   276:          sbc  #0
00:B13E 8538            	   277:          sta  WORK+1
00:B140 A206            	   278:          ldx  #6    ; show 6 bytes of base linkage data (return, dynamic link, static link)
00:B142 20A9B1          	   279:          jsr  display_x_characters
00:B145 4C0C95          	   280:          jmp  CROUT
                        	   281: 
00:B148 60              	   282: DEBUG_DONE rts
                        	   283: 
                        	   284: 
                        	   285: ;***********************************************
                        	   286: ; Interpreter initialization
                        	   287: ;***********************************************
                        	   288: 
                        	   289: INTERP   =  *
00:B149 08              	   290:   php
00:B14A 68              	   291:   pla
00:B14B 8513            	   292:   sta  call_p   ; make sure call_p has some reasonable value in it
                        	   293: ;
                        	   294: ;  Move the start of where the P-codes start into PCODE (our first P-code)
                        	   295: ;
00:B14D A525            	   296:   lda  ACT_PCDA
00:B14F 8523            	   297:   sta  PCODE
00:B151 A526            	   298:   lda  ACT_PCDA+1
00:B153 8524            	   299:   sta  PCODE+1
                        	   300: ;
                        	   301: ;  Running message
                        	   302: ;
00:B155 A9D7            	   303:   lda  #<running_message   ; Running
00:B157 A2B0            	   304:   ldx  #>running_message
00:B159 202682          	   305:   jsr  print
                        	   306: ;
                        	   307: ;  Running flag
                        	   308: ;
00:B15C A00C            	   309:   ldy  #$0C
00:B15E 843F            	   310:   sty  RUNNING
                        	   311: ;
                        	   312: ;  Set up the runtime stack pointer which is also our first stack frame base
                        	   313: ;
00:B160 A9FF            	   314:   lda  #<HIGHEST_RAM
00:B162 8531            	   315:   sta  T
00:B164 853B            	   316:   sta  BASE
00:B166 A93F            	   317:   lda  #>HIGHEST_RAM
00:B168 8532            	   318:   sta  T+1
00:B16A 853C            	   319:   sta  BASE+1
                        	   320: 
00:B16C 4C5AB2          	   321:   jmp  MAIN ; start interpreting
                        	   322: ;
                        	   323: ;
                        	   324: ;
                        	   325: 
                        	   326: 
                        	   327: ;***********************************************
                        	   328: ;  INTERPRETER
                        	   329: ;***********************************************
                        	   330: 
                        	   331: ;
                        	   332: ;
00:B16F 496C6C6567616C20	   333: DM5      asciiz  "Illegal instruction\n"
00:B177 696E737472756374
00:B17F 696F6E0A
00:B183 00
00:B184 427265616B202E2E	   334: DM6      asciiz  'Break ...\n'
00:B18C 2E0A
00:B18E 00
00:B18F 4572726F72206F63	   335: DM7      asciiz  "Error occurred at P-code "
00:B197 6375727265642061
00:B19F 7420502D636F6465
00:B1A7 20
00:B1A8 00
                        	   336: 
                        	   337: ;
                        	   338: ; DISPLAY (X) CHARACTERS FROM (WORK)
                        	   339: ;
                        	   340: display_x_characters:
00:B1A9 8A              	   341:          txa
00:B1AA 48              	   342:          pha
00:B1AB 209795          	   343:          jsr  PUTSP
00:B1AE 68              	   344:          pla
00:B1AF AA              	   345:          tax
00:B1B0 A000            	   346: DIS5     ldy  #0
00:B1B2 B137            	   347:          lda  (WORK),Y
00:B1B4 E637            	   348:          inc  WORK
00:B1B6 D002            	   349:          bne  DIS5_A
00:B1B8 E638            	   350:          inc  WORK+1
                        	   351: DIS5_A   =  *
00:B1BA A8              	   352:          tay
00:B1BB 8A              	   353:          txa
00:B1BC 48              	   354:          pha
00:B1BD 98              	   355:          tya
00:B1BE 202195          	   356:          jsr  DISHX
00:B1C1 68              	   357:          pla
00:B1C2 AA              	   358:          tax
00:B1C3 CA              	   359:          dex
00:B1C4 D0EA            	   360:          bne  DIS5
00:B1C6 60              	   361:          rts
                        	   362: 
                        	   363: ;
                        	   364: ; Ding a bell - however we don't have it on this board
                        	   365: ;
                        	   366: BELL1    =  *
00:B1C7 48              	   367:          pha
00:B1C8 A900            	   368:          lda  #0
00:B1CA 853F            	   369:          sta  RUNNING
00:B1CC 200C95          	   370:          jsr  CROUT
00:B1CF 68              	   371:          pla
00:B1D0 60              	   372:          rts
                        	   373: ;
                        	   374: ;
00:B1D1 20C7B1          	   375: RUNERR   jsr  BELL1
00:B1D4 A98F            	   376:          lda  #<DM7  ; Error occurred at P-code
00:B1D6 A2B1            	   377:          ldx  #>DM7
00:B1D8 202682          	   378:          jsr  print
00:B1DB A54E            	   379:          lda  LASTP+1
00:B1DD 208195          	   380:          jsr  PRBYTE
00:B1E0 A54D            	   381:          lda  LASTP
00:B1E2 202195          	   382:          jsr  DISHX
                        	   383: EX_FINISHD  =  *
00:B1E5 A900            	   384:          lda  #0
00:B1E7 200C95          	   385:          jsr  CROUT
00:B1EA A9FC            	   386:          lda  #<FIN_MSG
00:B1EC A2B1            	   387:          ldx  #>FIN_MSG
00:B1EE 202682          	   388:          jsr  print
00:B1F1 648B            	   389:          stz  serial_in_byte_received  ; get rid of read-ahead
00:B1F3 200FCC          	   390:          jsr  GETIN      ; wait till message seen
00:B1F6 200C95          	   391:          jsr  CROUT      ; output a newline in case they press space or something
00:B1F9 4C4CDD          	   392:          jmp  RESTART
                        	   393: ;
00:B1FC 52756E2066696E69	   394: FIN_MSG  asciiz  'Run finished - press a key ...'
00:B204 73686564202D2070
00:B20C 726573732061206B
00:B214 6579202E2E2E
00:B21A 00
                        	   395: ;
                        	   396: ;
                        	   397: CHK_KBD  =  *
00:B21B C90E            	   398:          cmp  #KEY_STOP_TRACE       ; Ctrl+N - stop tracing
00:B21D D008            	   399:          bne  CHK_NOTN
00:B21F 648B            	   400:          stz  serial_in_byte_received
00:B221 A900            	   401:          lda  #0
00:B223 8549            	   402:          sta  DBGFLG
00:B225 38              	   403:          sec
00:B226 60              	   404:          rts
00:B227 C914            	   405: CHK_NOTN cmp  #KEY_TRACE      ; Ctrl+T - start tracing
00:B229 D00A            	   406:          bne  CHK_NOTT
00:B22B 648B            	   407:          stz  serial_in_byte_received
00:B22D A980            	   408:          lda  #$80
00:B22F 8549            	   409:          sta  DBGFLG
00:B231 852E            	   410:          sta  DCODE
00:B233 38              	   411:          sec
00:B234 60              	   412:          rts
00:B235 C904            	   413: CHK_NOTT cmp  #KEY_DEBUG      ; Ctrl+D - start debugging
00:B237 D00A            	   414:          bne  CHK_NOTD
00:B239 648B            	   415:          stz  serial_in_byte_received
00:B23B A901            	   416:          lda  #1
00:B23D 8549            	   417:          sta  DBGFLG
00:B23F 852E            	   418:          sta  DCODE
00:B241 38              	   419:          sec
00:B242 60              	   420:          rts
00:B243 18              	   421: CHK_NOTD clc
00:B244 60              	   422:          rts
                        	   423: ;
                        	   424: EX_OUTCR    =  *
00:B245 200C95          	   425:   jsr  CROUT      ; OUTPUT C/R
00:B248 4C5AB2          	   426:   jmp  MAIN
                        	   427: ;
                        	   428: ;  Here for a "low literal" - a P-code with the 0x80 bit set. Clear that bit and push
                        	   429: ;   the resulting number onto the stack
                        	   430: ;
                        	   431: LOWLIT:
00:B24B E623            	   432:   inc  PCODE     ; increment P-code past the low literal
00:B24D D002            	   433:   bne  LOWLIT1
00:B24F E624            	   434:   inc  PCODE+1
                        	   435: LOWLIT1:
00:B251 8401            	   436:   sty  REG+1     ; Y and REGB were cleared below
00:B253 297F            	   437:   and  #$7F
00:B255 8500            	   438:   sta  REG
                        	   439: ;
                        	   440: ;  fall down to push this value
                        	   441: ;
                        	   442: 
                        	   443: 
                        	   444: ;
                        	   445: ; Push previous result (REG) and then drop down to do the next instruction
                        	   446: ;
                        	   447: MAINP:
00:B257 2037B3          	   448:  jsr  PSHTOP    ; push REG onto stack and go back to MAIN
                        	   449: 
                        	   450: ;
                        	   451: ;  Main interpreter loop - each instruction jumps back here (or to MAINP above if it
                        	   452: ;              needs to push a previous calculation result)
                        	   453: ;
                        	   454: MAIN:
00:B25A A549            	   455:   lda  DBGFLG   ; debugging?
00:B25C F003            	   456:   beq  MAIN_2   ; no
00:B25E 20E0B0          	   457:   jsr  DEBUG    ; yes - show debug info
                        	   458: MAIN_2   =  *
                        	   459: ; check if key pressed here, to abort, or turn on/off tracing or debugging
00:B261 A58B            	   460:   lda  serial_in_byte_received
00:B263 F00A            	   461:   beq  MAIN_OK
00:B265 C903            	   462:   cmp  #KEY_ABORT
00:B267 D003            	   463:   bne  MAIN_NOT_ABORT
00:B269 4CE5B1          	   464:   jmp  EX_FINISHD
                        	   465: MAIN_NOT_ABORT = *
00:B26C 201BB2          	   466:   jsr  CHK_KBD          ; check for turning on trace, debug, etc.
                        	   467: MAIN_OK  =  *
00:B26F A523            	   468:   lda  PCODE             ; save P-code address as LASTP (for errors I presume)
00:B271 854D            	   469:   sta  LASTP
00:B273 A524            	   470:   lda  PCODE+1
00:B275 854E            	   471:   sta  LASTP+1
                        	   472: ;
                        	   473: ;  now grab the P-code
                        	   474: ;
00:B277 A000            	   475:   ldy  #0
00:B279 8402            	   476:   sty  REGB
00:B27B B123            	   477:   lda  (PCODE),Y         ; get the P-code from the P-codes
00:B27D 30CC            	   478:   bmi  LOWLIT            ; low literal - just handle it
00:B27F C946            	   479:   cmp  #PCODE_LAST+1
00:B281 B015            	   480:   bcs  EX_INVINS         ; error if off end of table
                        	   481: ;
                        	   482: ;  increment past this P-code
                        	   483: ;
                        	   484: MAIN_5   =  *
00:B283 E623            	   485:   inc  PCODE
00:B285 D002            	   486:   bne  MAIN_1
00:B287 E624            	   487:   inc  PCODE+1
                        	   488: ;
                        	   489: ;  grab the execution handler from the execution_address_table
                        	   490: ;
                        	   491: MAIN_1   =  *
00:B289 0A              	   492:   asl  A             ; double the P-code because each address takes 2 bytes
00:B28A AA              	   493:   tax
00:B28B BD39B0          	   494:   lda  execution_address_table,X      ; otherwise get the execution address
00:B28E 8537            	   495:   sta  WORK
00:B290 BD3AB0          	   496:   lda  execution_address_table+1,X    ; and the high-order byte
00:B293 8538            	   497:   sta  WORK+1
00:B295 6C3700          	   498:   jmp  (WORK)        ; execute the appropriate P-code implementation routine
                        	   499: 
                        	   500: ;
                        	   501: NOTIMP   =  *
                        	   502: EX_INVINS   =  *
00:B298 A96F            	   503:          LDA  #<DM5   ; Illegal Instruction
00:B29A A2B1            	   504:          LDX  #>DM5
                        	   505: NOTIM1   =  *
00:B29C 202682          	   506:          JSR  print
00:B29F 4CD1B1          	   507:          JMP  RUNERR
                        	   508: ;
                        	   509: BREAK    =  *
00:B2A2 A984            	   510:          LDA  #<DM6  ; Break ...
00:B2A4 A2B1            	   511:          LDX  #>DM6
00:B2A6 4C9CB2          	   512:          JMP  NOTIM1
                        	   513: 
                        	   514: 
00:B2A9 A000            	   515: GETADR   LDY  #0
00:B2AB B123            	   516:          LDA  (PCODE),Y     ; level
00:B2AD 854B            	   517:          STA  COUNT1        ; count of levels to work through
00:B2AF A53C            	   518:          LDA  BASE+1        ; start with our stack base address
00:B2B1 A63B            	   519:          LDX  BASE
                        	   520: GET2     =  *
00:B2B3 853E            	   521:          STA  DATA+1        ; our data is relative to the stack base
00:B2B5 863D            	   522:          STX  DATA
00:B2B7 A8              	   523:          TAY
00:B2B8 A54B            	   524:          LDA  COUNT1        ; any levels left?
00:B2BA F018            	   525:          BEQ  GETADR1       ; no, we can continue
00:B2BC 38              	   526:          SEC                ; yes
00:B2BD 8A              	   527:          TXA                ; subtract 2 from the base to get the static link
00:B2BE E902            	   528:          SBC  #2
00:B2C0 8537            	   529:          STA  WORK
00:B2C2 98              	   530:          TYA
00:B2C3 E900            	   531:          SBC  #0
00:B2C5 8538            	   532:          STA  WORK+1        ; BASE - 2 -> WORK
00:B2C7 A000            	   533:          LDY  #0
00:B2C9 B137            	   534:          LDA  (WORK),Y      ; grab contents of BASE-2
00:B2CB C8              	   535:          INY
00:B2CC AA              	   536:          TAX
00:B2CD B137            	   537:          LDA  (WORK),Y
00:B2CF C64B            	   538:          DEC  COUNT1        ; one less level
00:B2D1 4CB3B2          	   539:          JMP  GET2          ; keep going until we used all levels
                        	   540: 
                        	   541: GETADR1     =  *
00:B2D4 A001            	   542:          LDY  #1            ; now get the offset
00:B2D6 18              	   543:          CLC
00:B2D7 B123            	   544:          LDA  (PCODE),Y     ; offset low-order byte
00:B2D9 653D            	   545:          ADC  DATA          ; add base
00:B2DB 853D            	   546:          STA  DATA
00:B2DD C8              	   547:          INY
00:B2DE B123            	   548:          LDA  (PCODE),Y     ; offset high-order byte
00:B2E0 653E            	   549:          ADC  DATA+1        ; add base
00:B2E2 853E            	   550:          STA  DATA+1        ; DATA now holds the data address
00:B2E4 A523            	   551:          LDA  PCODE         ; add 3 to PCODE to skip level and offset
00:B2E6 18              	   552:          CLC
00:B2E7 6903            	   553:          ADC  #3
00:B2E9 8523            	   554:          STA  PCODE
00:B2EB 9002            	   555:          BCC  GET1_A
00:B2ED E624            	   556:          INC  PCODE+1
                        	   557: GET1_A   =  *
00:B2EF 60              	   558:          RTS                ; done - we can use DATA to access whatever-it-is
                        	   559: 
                        	   560: ;
                        	   561: ;  Pull the top item on the runtime stack into REG (aka VALUE)
                        	   562: ;
                        	   563: PULTOP   =  *
00:B2F0 A000            	   564:          LDY  #0
00:B2F2 B131            	   565:          LDA  (T),Y
00:B2F4 8500            	   566:          STA  REG
00:B2F6 C8              	   567:          INY
00:B2F7 B131            	   568:          LDA  (T),Y
00:B2F9 8501            	   569:          STA  REG+1
00:B2FB C8              	   570:          INY
00:B2FC B131            	   571:          LDA  (T),Y
00:B2FE 8502            	   572:          STA  REGB
00:B300 A531            	   573:          LDA  T
00:B302 18              	   574:          CLC      ; add 3 to the stack because we removed one integer from it
00:B303 6903            	   575:          ADC  #3
00:B305 8531            	   576:          STA  T
00:B307 9002            	   577:          BCC  PUL_END
00:B309 E632            	   578:          INC  T+1
                        	   579: PUL_END  =  *
00:B30B A500            	   580:          LDA  REG
00:B30D A601            	   581:          LDX  REG+1
00:B30F A402            	   582:          LDY  REGB
00:B311 60              	   583:          RTS
                        	   584: 
00:B312 20F0B2          	   585: PULBOTH  JSR  PULTOP     ; Pulls both of them - do one and then fall through to do the other
                        	   586: 
                        	   587: ;
                        	   588: ;  Pull the top item on the runtime stack into REG2 (aka VALUE2)
                        	   589: ;
                        	   590: PULTOP2  =  *
00:B315 A000            	   591:          LDY  #0
00:B317 B131            	   592:          LDA  (T),Y
00:B319 8503            	   593:          STA  REG2
00:B31B C8              	   594:          INY
00:B31C B131            	   595:          LDA  (T),Y
00:B31E 8504            	   596:          STA  REG2+1
00:B320 C8              	   597:          INY
00:B321 B131            	   598:          LDA  (T),Y
00:B323 8505            	   599:          STA  REG2B
00:B325 A531            	   600:          LDA  T
00:B327 18              	   601:          CLC         ; add 3 to the stack because we removed one integer from it
00:B328 6903            	   602:          ADC  #3
00:B32A 8531            	   603:          STA  T
00:B32C 9002            	   604:          BCC  PUL2_END
00:B32E E632            	   605:          INC  T+1
                        	   606: PUL2_END =  *
00:B330 A503            	   607:          LDA  REG2
00:B332 A604            	   608:          LDX  REG2+1
00:B334 A405            	   609:          LDY  REG2B
00:B336 60              	   610:          RTS
                        	   611: 
                        	   612: ;
                        	   613: ;  Push REG (aka VALUE) onto the runtime stack
                        	   614: ;
                        	   615: PSHTOP   =  *
00:B337 38              	   616:          SEC        ;  subtract 3 from the stack because we are about to add one integer to it
00:B338 A531            	   617:          LDA  T
00:B33A E903            	   618:          SBC  #3
00:B33C 8531            	   619:          STA  T
00:B33E B002            	   620:          BCS  PSH1
00:B340 C632            	   621:          DEC  T+1
                        	   622: PSH1     =  *
00:B342 A000            	   623:          LDY  #0
00:B344 A500            	   624:          LDA  REG
00:B346 9131            	   625:          STA  (T),Y
00:B348 C8              	   626:          INY
00:B349 A501            	   627:          LDA  REG+1
00:B34B 9131            	   628:          STA  (T),Y
00:B34D C8              	   629:          INY
00:B34E A502            	   630:          LDA  REGB
00:B350 9131            	   631:          STA  (T),Y
00:B352 60              	   632:          RTS
                        	   633: ;
                        	   634: ;  get a literal (2 bytes) from the P-codes and put it into REG
                        	   635: ;
                        	   636: GETLIT   =  *
00:B353 A000            	   637:   ldy  #0
00:B355 B123            	   638:   lda  (PCODE),Y
00:B357 8500            	   639:   sta  REG
00:B359 C8              	   640:   iny
00:B35A B123            	   641:   lda  (PCODE),Y
00:B35C 8501            	   642:   sta  REG+1
00:B35E A523            	   643:   lda  PCODE
00:B360 18              	   644:   clc         ; P-code address goes up by 2
00:B361 6902            	   645:   adc  #2
00:B363 8523            	   646:   sta  PCODE
00:B365 9002            	   647:   bcc  GET_END
00:B367 E624            	   648:   inc  PCODE+1
                        	   649: GET_END:
00:B369 60              	   650:   rts
                        	   651: ;
                        	   652: ; load literal onto the stack (the literal is the next 3 bytes after the P-code)
                        	   653: ;
                        	   654: EX_LIT:
00:B36A 2053B3          	   655:   jsr  GETLIT   ; get the first 2 bytes
00:B36D A000            	   656:   ldy  #0
00:B36F B123            	   657:   lda  (PCODE),Y    ; now the third byte
00:B371 8502            	   658:   sta  REGB
00:B373 E623            	   659:   inc  PCODE
00:B375 D002            	   660:   bne  LIT1
00:B377 E624            	   661:   inc  PCODE+1
                        	   662: LIT1:
00:B379 4C57B2          	   663:   jmp  MAINP    ; now we can push it
                        	   664: ;
                        	   665: ;  Negate (0 - (sp) )
                        	   666: ;
                        	   667: EX_NEG:
00:B37C 20F0B2          	   668:   jsr PULTOP
00:B37F 2009AF          	   669:   jsr exp_unary_minus
00:B382 4C57B2          	   670:   jmp MAINP
                        	   671: ;
                        	   672: ;  Add (sp) to (sp -1)
                        	   673: ;
                        	   674: EX_ADD:
00:B385 2012B3          	   675:   JSR  PULBOTH
00:B388 20C2AD          	   676:   jsr  exp_add
00:B38B 4C57B2          	   677:   JMP  MAINP
                        	   678: ;
                        	   679: ;
                        	   680: ;  Add (sp) from (sp - 1)
                        	   681: ;
                        	   682: EX_SUB:
00:B38E 2015B3          	   683:   JSR  PULTOP2
00:B391 20F0B2          	   684:   jsr  PULTOP
00:B394 20D6AD          	   685:   jsr  exp_subtract
00:B397 4C57B2          	   686:   JMP  MAINP
                        	   687: ;
                        	   688: ;  Multiply (sp) by (sp - 1)
                        	   689: ;
                        	   690: EX_MUL:
00:B39A 2012B3          	   691:   jsr PULBOTH
00:B39D 2090AF          	   692:   jsr exp_multiply
00:B3A0 4C57B2          	   693:   jmp MAINP
                        	   694: 
                        	   695: ;
                        	   696: ;  we will take the current key (and return to the user)
                        	   697: ;  and zero it out anyway, so that consumes the key
                        	   698: ;
                        	   699: EX_GETKEY   =  *
00:B3A3 A58B            	   700:   lda  serial_in_byte_received
00:B3A5 648B            	   701:   stz  serial_in_byte_received
00:B3A7 4CFDB3          	   702:   jmp  TRUE2
                        	   703: ;
                        	   704: ;  Modulus (remainder)
                        	   705: ;
                        	   706: EX_MOD:
00:B3AA 2015B3          	   707:   jsr PULTOP2
                        	   708: ;
                        	   709: ;  check for divide by zero because I want a run-time error message
                        	   710: ;
00:B3AD A503            	   711:   lda VALUE2
00:B3AF 0504            	   712:   ora VALUE2+1
00:B3B1 0505            	   713:   ora VALUE2+2
00:B3B3 F009            	   714:   beq EX_DIVIDE_BY_ZERO
00:B3B5 20F0B2          	   715:   jsr PULTOP
00:B3B8 2029B0          	   716:   jsr exp_modulo
00:B3BB 4C57B2          	   717:   jmp MAINP
                        	   718: ;
                        	   719: 
                        	   720: EX_DIVIDE_BY_ZERO:
00:B3BE A9C5            	   721:   lda  #<DIVBY0
00:B3C0 A2B3            	   722:   ldx  #>DIVBY0
00:B3C2 4C9CB2          	   723:   jmp  NOTIM1
                        	   724: 
00:B3C5 4469766964652062	   725: DIVBY0   asciiz  'Divide by zero\n'
00:B3CD 79207A65726F0A
00:B3D4 00
                        	   726: ;
                        	   727: ;  Divide (sp - 1) by (sp)
                        	   728: ;
                        	   729: EX_DIV:
00:B3D5 2015B3          	   730:   jsr PULTOP2
00:B3D8 A503            	   731:   lda VALUE2
00:B3DA 0504            	   732:   ora VALUE2+1
00:B3DC 0505            	   733:   ora VALUE2+2
00:B3DE F0DE            	   734:   beq EX_DIVIDE_BY_ZERO
00:B3E0 20F0B2          	   735:   jsr PULTOP
00:B3E3 20C9AF          	   736:   jsr exp_divide
00:B3E6 4C57B2          	   737:   jmp MAINP
                        	   738: 
                        	   739: ;
                        	   740: ;  Absolute value of (sp)
                        	   741: ;
                        	   742: EX_ABS:
00:B3E9 20F0B2          	   743:   jsr  PULTOP
00:B3EC 202BAF          	   744:   jsr exp_abs_val
00:B3EF 4C57B2          	   745:   jmp  MAINP
                        	   746: 
                        	   747: ; Equal
                        	   748: ;
                        	   749: EX_EQL:
00:B3F2 2012B3          	   750:   jsr PULBOTH
00:B3F5 20FCAD          	   751:   jsr exp_eql
00:B3F8 4C57B2          	   752:   jmp MAINP
                        	   753: 
                        	   754: ;
                        	   755: ;  Push 1
                        	   756: ;
                        	   757: TRUE:
00:B3FB A901            	   758:   lda  #1
                        	   759: ;
                        	   760: ;  Push A into low-order byte, zero other two bytes
                        	   761: ;
                        	   762: TRUE2:
00:B3FD 8500            	   763:   sta  REG
00:B3FF A900            	   764:   lda  #0
00:B401 8501            	   765:   sta  REG+1
00:B403 8502            	   766:   sta  REGB
00:B405 4C57B2          	   767:   jmp  MAINP
                        	   768: 
                        	   769: ;
                        	   770: ;  Push 0
                        	   771: ;
                        	   772: FALSE:
00:B408 A900            	   773:   lda  #0
00:B40A 80F1            	   774:   bra TRUE2
                        	   775: ;
                        	   776: ;  Not equal
                        	   777: ;
                        	   778: EX_NEQ:
00:B40C 2012B3          	   779:     jsr PULBOTH
00:B40F 2010AE          	   780:     jsr exp_neq
00:B412 4C57B2          	   781:     jmp MAINP
                        	   782: 
                        	   783: ;
                        	   784: ;  Less than
                        	   785: ;
                        	   786: EX_LSS:
00:B415 2015B3          	   787:   jsr PULTOP2
00:B418 20F0B2          	   788:   jsr PULTOP
00:B41B 2024AE          	   789:   jsr exp_less_than
00:B41E 4C57B2          	   790:   jmp MAINP
                        	   791: 
                        	   792: ;
                        	   793: ;  Greater than
                        	   794: ;
                        	   795: EX_GTR:
00:B421 2015B3          	   796:   jsr PULTOP2
00:B424 20F0B2          	   797:   jsr PULTOP
00:B427 202BAE          	   798:   jsr exp_greater_than
00:B42A 4C57B2          	   799:   jmp MAINP
                        	   800: 
                        	   801: ;
                        	   802: ;  Greater than or equal
                        	   803: ;
                        	   804: EX_GEQ:
00:B42D 2015B3          	   805:   jsr PULTOP2
00:B430 20F0B2          	   806:   jsr PULTOP
00:B433 2049AE          	   807:   jsr exp_geq
00:B436 4C57B2          	   808:   jmp MAINP
                        	   809: 
                        	   810: ;
                        	   811: ;  Less than or equal
                        	   812: ;
                        	   813: EX_LEQ:
00:B439 2015B3          	   814:   jsr PULTOP2
00:B43C 20F0B2          	   815:   jsr PULTOP
00:B43F 203AAE          	   816:   jsr exp_leq
00:B442 4C57B2          	   817:   jmp MAINP
                        	   818: 
                        	   819: ;
                        	   820: ;  Exclusive OR
                        	   821: ;
                        	   822: EX_XOR:
00:B445 2012B3          	   823:   jsr PULBOTH
00:B448 207AAE          	   824:   jsr exp_bitwise_xor
00:B44B 4C57B2          	   825:   jmp MAINP
                        	   826: ;
                        	   827: ;  Or
                        	   828: ;
                        	   829: EX_ORR:
00:B44E 2012B3          	   830:   jsr PULBOTH
00:B451 2050AE          	   831:   jsr exp_bitwise_or
00:B454 4C57B2          	   832:   jmp MAINP
                        	   833: 
                        	   834: ;
                        	   835: ;  And
                        	   836: ;
                        	   837: EX_AND:
00:B457 2012B3          	   838:   jsr  PULBOTH
00:B45A 2065AE          	   839:   jsr exp_bitwise_and
00:B45D 4C57B2          	   840:   jmp MAINP
                        	   841: 
                        	   842: ;
                        	   843: ;  Not
                        	   844: ;
                        	   845: EX_EOR:
00:B460 20F0B2          	   846:   jsr PULTOP
00:B463 20FBAE          	   847:   jsr exp_not
00:B466 4C57B2          	   848:   jmp MAINP
                        	   849: ;
                        	   850: ; Shift left
                        	   851: ;
                        	   852: EX_SHL:
00:B469 2015B3          	   853:   jsr PULTOP2
00:B46C 20F0B2          	   854:   jsr PULTOP
00:B46F 20B6AE          	   855:   jsr exp_shift_left
00:B472 4C57B2          	   856:   jmp MAINP
                        	   857: 
                        	   858: ;
                        	   859: ;  Shift right
                        	   860: ;
                        	   861: EX_SHR:
00:B475 2015B3          	   862:   jsr PULTOP2
00:B478 20F0B2          	   863:   jsr PULTOP
00:B47B 20CFAE          	   864:   jsr exp_shift_right
00:B47E 4C57B2          	   865:   jmp MAINP
                        	   866: 
                        	   867: ;
                        	   868: ;  increment number on top of stack by one
                        	   869: ;
                        	   870: EX_INC:
00:B481 18              	   871:   clc
00:B482 B131            	   872:   lda  (T),Y
00:B484 6901            	   873:   adc  #1
00:B486 9131            	   874:   sta  (T),Y
00:B488 C8              	   875:   iny
00:B489 B131            	   876:   lda  (T),Y
00:B48B 6900            	   877:   adc  #0
00:B48D 9131            	   878:   sta  (T),Y
00:B48F C8              	   879:   iny
00:B490 B131            	   880:   lda  (T),Y
00:B492 6900            	   881:   adc  #0
00:B494 9131            	   882:   sta  (T),Y
00:B496 4C5AB2          	   883:   jmp  MAIN
                        	   884: ;
                        	   885: ;  decrement number on top of stack by one
                        	   886: ;
                        	   887: 
                        	   888: EX_DEC:
00:B499 38              	   889:   sec
00:B49A B131            	   890:   lda  (T),Y
00:B49C E901            	   891:   sbc  #1
00:B49E 9131            	   892:   sta  (T),Y
00:B4A0 C8              	   893:   iny
00:B4A1 B131            	   894:   lda  (T),Y
00:B4A3 E900            	   895:   sbc  #0
00:B4A5 9131            	   896:   sta  (T),Y
00:B4A7 C8              	   897:   iny
00:B4A8 B131            	   898:   lda  (T),Y
00:B4AA E900            	   899:   sbc  #0
00:B4AC 9131            	   900:   sta  (T),Y
00:B4AE 4C5AB2          	   901:   jmp  MAIN
                        	   902: 
                        	   903: ;
                        	   904: ;  Copy (sp) to (sp + 1)
                        	   905: ;
                        	   906: EX_MOV:
00:B4B1 B131            	   907:   lda  (T),Y  ; get item at top of stack
00:B4B3 8500            	   908:   sta REG
00:B4B5 C8              	   909:   iny
00:B4B6 B131            	   910:   lda  (T),Y
00:B4B8 8501            	   911:   sta REG+1
00:B4BA C8              	   912:   iny
00:B4BB B131            	   913:   lda  (T),Y
00:B4BD 8502            	   914:   sta REGB
00:B4BF 4C57B2          	   915:   jmp MAINP   ; push it
                        	   916: 
                        	   917: ;
                        	   918: ;  Load a single-character value (variable) onto the stack
                        	   919: ;
                        	   920: 
                        	   921: EX_LODC:
00:B4C2 20A9B2          	   922:   jsr  GETADR
                        	   923: EX_LOD3:
00:B4C5 A002            	   924:   ldy  #2
                        	   925: EX_LOD3_A:
00:B4C7 A900            	   926:   lda  #0      ; since this is a character zero out the high-order bytes
00:B4C9 8501            	   927:   sta  REG+1
00:B4CB 8502            	   928:   sta  REGB
00:B4CD B13D            	   929:   lda  (DATA),Y  ; (DATA) contains the lower-order byte
00:B4CF 8500            	   930:   sta  REG       ; REG will be pushed
00:B4D1 4C57B2          	   931:   jmp  MAINP     ; push REG and go to MAIN
                        	   932: ;
                        	   933: ;  Load a 3-byte value (variable) onto the stack
                        	   934: ;
                        	   935: EX_LOD:
00:B4D4 20A9B2          	   936:   jsr  GETADR
                        	   937: EX_LOD2:
00:B4D7 A000            	   938:   ldy  #0
00:B4D9 B13D            	   939:   lda  (DATA),Y    ; (DATA) contains the variable value
00:B4DB 8500            	   940:   sta  REG
00:B4DD C8              	   941:   iny
00:B4DE B13D            	   942:   lda  (DATA),Y
00:B4E0 8501            	   943:   sta  REG+1
00:B4E2 C8              	   944:   iny
00:B4E3 B13D            	   945:   lda  (DATA),Y
00:B4E5 8502            	   946:   sta REGB
00:B4E7 4C57B2          	   947:   jmp MAINP   ; push it
                        	   948: 
                        	   949: ;
                        	   950: ;  Load absolute address character
                        	   951: ;
                        	   952: EX_LDAC:
00:B4EA 20F0B2          	   953:   jsr  PULTOP
00:B4ED 853D            	   954:   sta  DATA
00:B4EF 863E            	   955:   stx  DATA+1
00:B4F1 A000            	   956:   ldy  #0
00:B4F3 F0D2            	   957:   beq  EX_LOD3_A
                        	   958: ;
                        	   959: ;  Load absolute address integer
                        	   960: ;
                        	   961: EX_LDA:
00:B4F5 20F0B2          	   962:   jsr  PULTOP
00:B4F8 853D            	   963:   sta  DATA
00:B4FA 863E            	   964:   stx  DATA+1
00:B4FC 4CD7B4          	   965:   jmp  EX_LOD2
                        	   966: ;
                        	   967: ;  Get address of indexed character
                        	   968: ;
                        	   969: GETIDC:
00:B4FF 2015B3          	   970:   jsr  PULTOP2    ; pull index into REG2
00:B502 20A9B2          	   971:   jsr  GETADR
00:B505 4C1CB5          	   972:   jmp  GETID2
                        	   973: ;
                        	   974: ;  Get address of indexed integer
                        	   975: ;
                        	   976: GETIDX   =  *
00:B508 2015B3          	   977:   jsr  PULTOP2  ; pull index into REG2
00:B50B 0603            	   978:   asl  REG2     ; now multiply by 3
00:B50D 2604            	   979:   rol  REG2+1
00:B50F 18              	   980:   clc
00:B510 6503            	   981:   adc  REG2
00:B512 8503            	   982:   sta  REG2
00:B514 8A              	   983:   txa
00:B515 6504            	   984:   adc  REG2+1
00:B517 8504            	   985:   sta  REG2+1     ; TIMES 3
00:B519 20A9B2          	   986:   jsr  GETADR
                        	   987: ;
                        	   988: ;  Get address of indexed integer/character
                        	   989: ;
                        	   990: ;  It looks like arrays expand downwards
                        	   991: ;
                        	   992: GETID2:
00:B51C A53D            	   993:   lda  DATA     ; initial address
00:B51E 38              	   994:   sec           ; subtract subscript
00:B51F E503            	   995:   sbc  REG2
00:B521 853D            	   996:   sta  DATA
00:B523 A53E            	   997:   lda  DATA+1
00:B525 E504            	   998:   sbc  REG2+1
00:B527 853E            	   999:   sta  DATA+1
00:B529 60              	  1000:   rts
                        	  1001: ;
                        	  1002: ;  Load indexed character
                        	  1003: ;
                        	  1004: EX_LDIC:
00:B52A 20FFB4          	  1005:   jsr  GETIDC
00:B52D 4CC5B4          	  1006:   jmp  EX_LOD3
                        	  1007: ;
                        	  1008: ;  Load indexed integer
                        	  1009: ;
                        	  1010: EX_LDI:
00:B530 2008B5          	  1011:   jsr  GETIDX
00:B533 4CD7B4          	  1012:   jmp  EX_LOD2
                        	  1013: ;
                        	  1014: ;  Store character
                        	  1015: ;
                        	  1016: EX_STOC:
00:B536 20A9B2          	  1017:   jsr  GETADR
00:B539 20F0B2          	  1018:   jsr  PULTOP
00:B53C A002            	  1019:   ldy  #2   ; why?
                        	  1020: EX_STO5:
00:B53E 913D            	  1021:   sta  (DATA),Y
00:B540 4C5AB2          	  1022:   jmp  MAIN
                        	  1023: ;
                        	  1024: ;  Store integer
                        	  1025: ;
                        	  1026: EX_STO:
00:B543 20A9B2          	  1027:   jsr  GETADR   ; get its address
00:B546 20F0B2          	  1028:   jsr  PULTOP   ; get the value to store
                        	  1029: EX_STO2:
00:B549 A000            	  1030:   ldy  #0
00:B54B 913D            	  1031:   sta  (DATA),Y
00:B54D C8              	  1032:   iny
00:B54E 8A              	  1033:   txa
00:B54F 913D            	  1034:   sta  (DATA),Y
00:B551 A502            	  1035:   lda  REGB
00:B553 C8              	  1036:   iny
00:B554 D0E8            	  1037:   bne  EX_STO5
                        	  1038: ;
                        	  1039: ;  Store integer at absolute address
                        	  1040: ;
                        	  1041: EX_STA:
00:B556 2012B3          	  1042:   jsr  PULBOTH  ; get address into REG2 and value into REG
00:B559 A000            	  1043:   ldy  #0
00:B55B A500            	  1044:   lda  REG
00:B55D 9103            	  1045:   sta  (REG2),Y
00:B55F C8              	  1046:   iny
00:B560 A501            	  1047:   lda  REG+1
00:B562 9103            	  1048:   sta  (REG2),Y
00:B564 C8              	  1049:   iny
00:B565 A502            	  1050:   lda  REGB
                        	  1051: EX_STA5:
00:B567 9103            	  1052:   sta  (REG2),Y
00:B569 4C5AB2          	  1053:   jmp  MAIN
                        	  1054: ;
                        	  1055: ;  Store character at absolute address
                        	  1056: ;
                        	  1057: EX_STAC:
00:B56C 2012B3          	  1058:   jsr  PULBOTH  ; get address into REG2 and value into REG
00:B56F A500            	  1059:   lda  REG
00:B571 A000            	  1060:   ldy  #0
00:B573 F0F2            	  1061:   beq  EX_STA5
                        	  1062: ;
                        	  1063: ;     Store character indexed
                        	  1064: ;
                        	  1065: EX_STIC:
00:B575 20F0B2          	  1066:   jsr  PULTOP
00:B578 8545            	  1067:   sta  TEMP
00:B57A 20FFB4          	  1068:   jsr  GETIDC
00:B57D A545            	  1069:   lda  TEMP
00:B57F A002            	  1070:   ldy  #2
00:B581 D0BB            	  1071:   bne  EX_STO5
                        	  1072: ;
                        	  1073: ;     Store integer indexed
                        	  1074: ;
                        	  1075: EX_STI :
00:B583 20F0B2          	  1076:   jsr  PULTOP
00:B586 8545            	  1077:   sta  TEMP
00:B588 8646            	  1078:   stx  TEMP+1
00:B58A 98              	  1079:   tya
00:B58B 48              	  1080:   pha
00:B58C 2008B5          	  1081:   jsr  GETIDX
00:B58F A000            	  1082:   ldy  #0
00:B591 A545            	  1083:   lda  TEMP
00:B593 913D            	  1084:   sta  (DATA),Y
00:B595 A546            	  1085:   lda  TEMP+1
00:B597 C8              	  1086:   iny
00:B598 913D            	  1087:   sta  (DATA),Y
00:B59A 68              	  1088:   pla
00:B59B C8              	  1089:   iny
00:B59C D0A0            	  1090:   bne  EX_STO5
                        	  1091: ;
                        	  1092: ;  Procedure/function return
                        	  1093: ;
                        	  1094: ;  Stack frame linkage data:
                        	  1095: ;
                        	  1096: ;    (from low to high address)
                        	  1097: ;
                        	  1098: ;    Return address <-- P-code to return to when function/procedure exits
                        	  1099: ;    Dynamic link   <-- The previous stack frame from the earlier function call
                        	  1100: ;    Static link    <-- The stack frame of the previous static function
                        	  1101: ;
                        	  1102: ;  Static and dynamic links will be the same except for recursive calls.
                        	  1103: ;
                        	  1104: ;  To unwind the stack we have to go back to the previous dynamic link (on a return)
                        	  1105: ;
                        	  1106: ;  However to find variables in previous lexical declarations we have to use the static link.
                        	  1107: ;
                        	  1108: ;
                        	  1109: EX_RTN:
                        	  1110: ;
                        	  1111: ;  Subtract 6 from the base address, put result into WORK
                        	  1112: ;
00:B59E 38              	  1113:   sec
00:B59F A53B            	  1114:   lda  BASE
00:B5A1 E906            	  1115:   sbc  #6
00:B5A3 8537            	  1116:   sta  WORK
00:B5A5 A53C            	  1117:   lda  BASE+1
00:B5A7 E900            	  1118:   sbc  #0
00:B5A9 8538            	  1119:   sta  WORK+1
                        	  1120: ;
                        	  1121: ;  The return address was at the bottom of BASE, so put that into PCODE
                        	  1122: ;
00:B5AB A000            	  1123:   ldy  #0
00:B5AD B137            	  1124:   lda  (WORK),Y
00:B5AF 8523            	  1125:   sta  PCODE
00:B5B1 C8              	  1126:   iny
00:B5B2 B137            	  1127:   lda  (WORK),Y
00:B5B4 8524            	  1128:   sta  PCODE+1
                        	  1129: 
                        	  1130: ;
                        	  1131: ;  The base address becomes our new top of runtime stack
                        	  1132: ;
00:B5B6 A53C            	  1133:   lda  BASE+1
00:B5B8 8532            	  1134:   sta  T+1
00:B5BA A53B            	  1135:   lda  BASE
00:B5BC 8531            	  1136:   sta  T
                        	  1137: ;
                        	  1138: ;  The dynamic stack frame address is 4 bytes down from the BASE - put that into WORK
                        	  1139: ;
00:B5BE 38              	  1140:   sec
00:B5BF E904            	  1141:   sbc  #4
00:B5C1 8537            	  1142:   sta  WORK
00:B5C3 A53C            	  1143:   lda  BASE+1
00:B5C5 E900            	  1144:   sbc  #0
00:B5C7 8538            	  1145:   sta  WORK+1
                        	  1146: ;
                        	  1147: ;  Get the previous dynamic stack frame address and put it into BASE (in case of
                        	  1148: ;   recursive function calls)
                        	  1149: ;
00:B5C9 A000            	  1150:   ldy  #0
00:B5CB B137            	  1151:   lda  (WORK),Y
00:B5CD 853B            	  1152:   sta  BASE
00:B5CF C8              	  1153:   iny
00:B5D0 B137            	  1154:   lda  (WORK),Y
00:B5D2 853C            	  1155:   sta  BASE+1
                        	  1156: ;
                        	  1157: ;  Stack, base and Pcode all changed, ready for next instruction
                        	  1158: ;
00:B5D4 4C5AB2          	  1159:   jmp  MAIN
                        	  1160: 
                        	  1161: ;
                        	  1162: ; Input a number into a variable
                        	  1163: ;
                        	  1164: EX_INP      =  *
00:B5D7 A980            	  1165:   lda #$80
00:B5D9 853F            	  1166:   sta  RUNNING
00:B5DB 207296          	  1167:   JSR  GET_LINE
00:B5DE AD0002          	  1168:   lda  INBUF
00:B5E1 C903            	  1169:   cmp  #KEY_ABORT   ; check for aborting with Ctrl+C
00:B5E3 D003            	  1170:   bne  EX_INP_OK
00:B5E5 4C32B8          	  1171:   jmp  ex_input_aborted
                        	  1172: 
                        	  1173: EX_INP_OK:
00:B5E8 A900            	  1174:   lda #<INBUF
00:B5EA 858E            	  1175:   sta token_start
00:B5EC A902            	  1176:   lda #>INBUF
00:B5EE 858F            	  1177:   sta token_start+1
00:B5F0 6493            	  1178:   stz token_type
00:B5F2 208FCC          	  1179:   jsr get_token
00:B5F5 C94E            	  1180:   cmp #TOKEN_NUMBER
00:B5F7 D016            	  1181:   bne BAD_INP
00:B5F9 A694            	  1182:   LDX  token_value
00:B5FB A495            	  1183:   LDY  token_value+1
00:B5FD A596            	  1184:   LDA  token_value+2
                        	  1185: INP3:
00:B5FF 8401            	  1186:   sty  REG+1
00:B601 8600            	  1187:   stx  REG
00:B603 8502            	  1188:   sta  REGB
00:B605 2037B3          	  1189:   jsr  PSHTOP
00:B608 A20C            	  1190:   ldx  #12
00:B60A 863F            	  1191:   stx  RUNNING
00:B60C 4C5AB2          	  1192:   jmp  MAIN
                        	  1193: ;
                        	  1194: ;  bad number: set it to $800000
                        	  1195: ;
                        	  1196: BAD_INP:
00:B60F A980            	  1197:   lda #$80
00:B611 A200            	  1198:   ldx #0
00:B613 A000            	  1199:   ldy #0
00:B615 F0E8            	  1200:   beq INP3
                        	  1201: ;
                        	  1202: ; write a number to output
                        	  1203: ;
                        	  1204: EX_OUT:
00:B617 20F9CB          	  1205:   jsr write_to_serial
00:B61A 8003            	  1206:   bra OUT_COMMON
                        	  1207: 
                        	  1208: EX_LCD_WRITE_NUM:
00:B61C 2004CC          	  1209:   jsr write_to_lcd
                        	  1210: 
                        	  1211: OUT_COMMON:
00:B61F 20F0B2          	  1212:   jsr  PULTOP
00:B622 203694          	  1213:   jsr  display_in_decimal
00:B625 20F9CB          	  1214:   jsr  write_to_serial
00:B628 4C5AB2          	  1215:   jmp  MAIN
                        	  1216: ;
                        	  1217: ;
                        	  1218: ; Output 6 hex characters (3 bytes)
                        	  1219: ;
                        	  1220: EX_OUH:
00:B62B 20F9CB          	  1221:   jsr write_to_serial
00:B62E 8003            	  1222:   bra EX_OUH_COMMON
                        	  1223: 
                        	  1224: EX_LCD_WRITE_HEX:
00:B630 2004CC          	  1225:   jsr write_to_lcd
                        	  1226: 
                        	  1227: EX_OUH_COMMON:
00:B633 20F0B2          	  1228:   jsr  PULTOP
00:B636 A502            	  1229:   lda  REGB
00:B638 208195          	  1230:   jsr  PRBYTE
00:B63B A501            	  1231:   lda  REG+1
00:B63D 208195          	  1232:   jsr  PRBYTE
00:B640 A500            	  1233:   lda  REG
00:B642 208195          	  1234:   jsr  PRBYTE
00:B645 20F9CB          	  1235:   jsr  write_to_serial
00:B648 4C5AB2          	  1236:   jmp  MAIN
                        	  1237: ;
                        	  1238: ;  write a string to output
                        	  1239: ;
                        	  1240: EX_OUS      =  *
00:B64B 20F9CB          	  1241:   jsr write_to_serial
00:B64E 8003            	  1242:   bra EX_OUS_COMMON
                        	  1243: 
                        	  1244: EX_LCD_WRITE_STR:
00:B650 2004CC          	  1245:   jsr write_to_lcd
                        	  1246: 
                        	  1247: EX_OUS_COMMON:
00:B653 A523            	  1248:   lda  PCODE
00:B655 18              	  1249:   clc
00:B656 6901            	  1250:   adc  #1
00:B658 8537            	  1251:   sta  WORK
00:B65A A524            	  1252:   lda  PCODE+1
00:B65C 6900            	  1253:   adc  #0
00:B65E 8538            	  1254:   sta  WORK+1
00:B660 B123            	  1255:   lda  (PCODE),Y
00:B662 854B            	  1256:   sta  COUNT1     ; NO. OF CHARS
00:B664 18              	  1257:   clc
00:B665 6901            	  1258:   adc  #1
00:B667 6523            	  1259:   adc  PCODE
00:B669 8523            	  1260:   sta  PCODE
00:B66B 9002            	  1261:   bcc  EX_OUS1
00:B66D E624            	  1262:   inc  PCODE+1
                        	  1263: EX_OUS1:
00:B66F A537            	  1264:   lda  WORK
00:B671 A638            	  1265:   ldx  WORK+1
00:B673 A44B            	  1266:   ldy  COUNT1
00:B675 209B95          	  1267:   jsr  PT
00:B678 20F9CB          	  1268:   jsr write_to_serial
00:B67B 4C5AB2          	  1269:   jmp  MAIN
                        	  1270: 
                        	  1271: 
                        	  1272: 
                        	  1273: ;
                        	  1274: ;  Stack frame linkage data:
                        	  1275: ;
                        	  1276: ;    (from low to high address)
                        	  1277: ;
                        	  1278: ;    Return address <-- P-code to return to when function/procedure exits
                        	  1279: ;    Dynamic link   <-- The previous stack frame from the earlier function call
                        	  1280: ;    Static link    <-- The stack frame of the previous static function
                        	  1281: ;
                        	  1282: ;  Static and dynamic links will be the same except for recursive calls.
                        	  1283: ;
                        	  1284: ;  To unwind the stack we have to go back to the previous dynamic link (on a return)
                        	  1285: ;
                        	  1286: ;  However to find variables in previous lexical declarations we have to use the static link.
                        	  1287: ;
                        	  1288: ;
                        	  1289: ; Call absolute procedure - I don't think this is used in this version TBH
                        	  1290: ;
                        	  1291: ; Note: Y is zero when entering
                        	  1292: ;
                        	  1293: EX_ABSCLL   =  *
00:B67E 8447            	  1294:   sty  CALL      ; zero out address to be called
00:B680 8448            	  1295:   sty  CALL+1    ; (offset therefore becomes absolute address)
00:B682 4C8DB6          	  1296:   jmp  EX_CLL_A
                        	  1297: ;
                        	  1298: ; Call relative procedure
                        	  1299: ;
                        	  1300: ; Note: Y is zero when entering
                        	  1301: ;
                        	  1302: EX_CLL      =  *
00:B685 A54D            	  1303:   lda  LASTP
00:B687 8547            	  1304:   sta  CALL
00:B689 A54E            	  1305:   lda  LASTP+1
00:B68B 8548            	  1306:   sta  CALL+1
                        	  1307: EX_CLL_A    =  *
00:B68D B123            	  1308:   lda  (PCODE),Y     ; level
00:B68F 854B            	  1309:   sta  COUNT1
00:B691 C8              	  1310:   iny
00:B692 18              	  1311:   clc
00:B693 B123            	  1312:   lda  (PCODE),Y     ; relative address
00:B695 6547            	  1313:   adc  CALL          ; add to current P-code address
00:B697 8547            	  1314:   sta  CALL
00:B699 C8              	  1315:   iny
00:B69A B123            	  1316:   lda  (PCODE),Y
00:B69C 6548            	  1317:   adc  CALL+1
00:B69E 8548            	  1318:   sta  CALL+1
00:B6A0 A523            	  1319:   lda  PCODE         ; add 3 to P-code to bypass level / address
00:B6A2 18              	  1320:   clc                ; this will become our return address
00:B6A3 6903            	  1321:   adc  #3
00:B6A5 8523            	  1322:   sta  PCODE
00:B6A7 9002            	  1323:   bcc  EX_CLL4
00:B6A9 E624            	  1324:   inc  PCODE+1
                        	  1325: EX_CLL4     =  *
00:B6AB A53C            	  1326:   lda  BASE+1
00:B6AD A63B            	  1327:   ldx  BASE
                        	  1328: EX_CLL2     =  *
00:B6AF 853E            	  1329:   sta  DATA+1      ; this was BASE
00:B6B1 863D            	  1330:   stx  DATA
00:B6B3 A8              	  1331:   tay
00:B6B4 A54B            	  1332:   lda  COUNT1      ; this was the level
00:B6B6 F018            	  1333:   beq  EX_CLL3
00:B6B8 38              	  1334:   sec
00:B6B9 8A              	  1335:   txa
00:B6BA E902            	  1336:   sbc  #2          ; subtract 2 from BASE, store in WORK
00:B6BC 8537            	  1337:   sta  WORK
00:B6BE 98              	  1338:   tya
00:B6BF E900            	  1339:   sbc  #0
00:B6C1 8538            	  1340:   sta  WORK+1
00:B6C3 A000            	  1341:   ldy  #0
00:B6C5 B137            	  1342:   lda  (WORK),Y
00:B6C7 C8              	  1343:   iny
00:B6C8 AA              	  1344:   tax
00:B6C9 B137            	  1345:   lda  (WORK),Y
00:B6CB C64B            	  1346:   dec  COUNT1
00:B6CD 4CAFB6          	  1347:   jmp  EX_CLL2
                        	  1348: EX_CLL3     =  *
00:B6D0 A531            	  1349:   lda  T         ; our stack pointer
00:B6D2 8545            	  1350:   sta  TEMP      ; save it
00:B6D4 A532            	  1351:   lda  T+1
00:B6D6 8546            	  1352:   sta  TEMP+1
                        	  1353: ;
                        	  1354: ; this is as confusing as all-get-out but it looks like we
                        	  1355: ; are pushing onto the stack: DATA / BASE / PCODE (return address)
                        	  1356: ;  (which is why we saved T into TEMP so it didn't change during the pushes)
                        	  1357: ;
                        	  1358: 
00:B6D8 A53D            	  1359:   lda  DATA      ; put DATA into REG
00:B6DA 8501            	  1360:   sta  REG+1
00:B6DC A53E            	  1361:   lda  DATA+1
00:B6DE 8502            	  1362:   sta  REGB
00:B6E0 A53C            	  1363:   lda  BASE+1
00:B6E2 8500            	  1364:   sta  REG
00:B6E4 2037B3          	  1365:   jsr  PSHTOP      ; push REG (DATA + BASE[1])
00:B6E7 A53B            	  1366:   lda  BASE
00:B6E9 8502            	  1367:   sta  REGB
00:B6EB A545            	  1368:   lda  TEMP        ; old stack pointer
00:B6ED 853B            	  1369:   sta  BASE        ; becomes BASE
00:B6EF A546            	  1370:   lda  TEMP+1      ; ditto for other byte
00:B6F1 853C            	  1371:   sta  BASE+1
00:B6F3 A523            	  1372:   lda  PCODE       ; get ready to push current P-Code
00:B6F5 8500            	  1373:   sta  REG
00:B6F7 A524            	  1374:   lda  PCODE+1
00:B6F9 8501            	  1375:   sta  REG+1
00:B6FB 2037B3          	  1376:   jsr  PSHTOP     ; push REG (BASE[0] + PCODE)
00:B6FE A547            	  1377:   lda  CALL       ; now get the address of the place we want to call
00:B700 8523            	  1378:   sta  PCODE      ; and put it into PCODE
00:B702 A548            	  1379:   lda  CALL+1
00:B704 8524            	  1380:   sta  PCODE+1
00:B706 18              	  1381:   clc             ; add 6 to the stack pointer because we later emit the code to INT 6 (leave room for base stuff)
00:B707 A531            	  1382:   lda  T
00:B709 6906            	  1383:   adc  #6
00:B70B 8531            	  1384:   sta  T
00:B70D 9002            	  1385:   bcc  EX_CLL5
00:B70F E632            	  1386:   inc  T+1
                        	  1387: EX_CLL5     =  *
00:B711 4C5AB2          	  1388:   jmp  MAIN        ; we are done, MAIN will now go to the called subroutine
                        	  1389: ;
                        	  1390: ;  Here for calling machine code from Pascal
                        	  1391: ;
                        	  1392: EX_CLA:
00:B714 20F0B2          	  1393:   jsr  PULTOP      ; pull the address to be called from the stack
00:B717 A513            	  1394:   lda  call_p      ; status register
00:B719 48              	  1395:   pha
00:B71A A510            	  1396:   lda  call_a      ; A register
00:B71C A611            	  1397:   ldx  call_x      ; X register
00:B71E A412            	  1398:   ldy  call_y      ; Y register
00:B720 28              	  1399:   plp              ; get status register back
00:B721 2031B7          	  1400:   jsr  EX_CLL_JMP  ; call the subroutine
00:B724 08              	  1401:   php              ; save the status register
00:B725 8510            	  1402:   sta  call_a      ; store the A/X/Y register
00:B727 8611            	  1403:   stx  call_x
00:B729 8412            	  1404:   sty  call_y
00:B72B 68              	  1405:   pla              ; get status register back
00:B72C 8513            	  1406:   sta  call_p      ; save it
00:B72E 4C5AB2          	  1407:   jmp  MAIN        ; done!
                        	  1408: 
00:B731 6C0000          	  1409: EX_CLL_JMP  jmp  (REG)
                        	  1410: ;
                        	  1411: ;
                        	  1412: ; increment stack pointer (that is, subtract the literal from it, as it grows downwards)
                        	  1413: ;
                        	  1414: EX_INT:
00:B734 2053B3          	  1415:   jsr  GETLIT
00:B737 38              	  1416:   sec
00:B738 A531            	  1417:   lda  T
00:B73A E500            	  1418:   sbc  REG
00:B73C 8531            	  1419:   sta  T
00:B73E A532            	  1420:   lda  T+1
00:B740 E501            	  1421:   sbc  REG+1
00:B742 8532            	  1422:   sta  T+1
00:B744 C544            	  1423:   cmp  END_PCD+1
00:B746 9003            	  1424:   bcc  INT_ERR
00:B748 4C5AB2          	  1425:   jmp  MAIN
                        	  1426: ;
                        	  1427: INT_ERR  =  *
00:B74B A952            	  1428:   lda  #<INT_ERRM    ; stack full
00:B74D A2B7            	  1429:   ldx  #>INT_ERRM
00:B74F 4C9CB2          	  1430:   jmp  NOTIM1
                        	  1431: ;
00:B752 537461636B206675	  1432: INT_ERRM asciiz "Stack full\n"    ; stack full
00:B75A 6C6C0A
00:B75D 00
                        	  1433: ;
                        	  1434: 
                        	  1435: ;
                        	  1436: ;  Change the runtime stack to the address given (assuming stack is empty)
                        	  1437: ;   Done by the {%S nnnn} compiler directive.
                        	  1438: ;
                        	  1439: EX_NEW_STACK:
00:B75E 2053B3          	  1440:   jsr GETLIT
00:B761 A500            	  1441:   lda REG
00:B763 8531            	  1442:   sta T
00:B765 853B            	  1443:   sta BASE
00:B767 A501            	  1444:   lda REG+1
00:B769 8532            	  1445:   sta T+1
00:B76B 853C            	  1446:   sta BASE+1
00:B76D 4C5AB2          	  1447:   jmp MAIN
                        	  1448: 
                        	  1449: ;
                        	  1450: ;  Jump to the address following the P-code
                        	  1451: ;
                        	  1452: EX_JMP:
00:B770 2053B3          	  1453:   jsr  GETLIT   ; get the address
00:B773 18              	  1454:   clc
00:B774 A500            	  1455:   lda  REG
00:B776 654D            	  1456:   adc  LASTP
00:B778 8523            	  1457:   sta  PCODE
00:B77A A501            	  1458:   lda  REG+1
00:B77C 654E            	  1459:   adc  LASTP+1
00:B77E 8524            	  1460:   sta  PCODE+1
00:B780 4C5AB2          	  1461:   jmp  MAIN
                        	  1462: ;
                        	  1463: ;  Jump if the top of the stack is zero
                        	  1464: ;
                        	  1465: EX_JMZ:
00:B783 20F0B2          	  1466:   jsr  PULTOP   ; puts REG into A
00:B786 0501            	  1467:   ora  REG+1
00:B788 0502            	  1468:   ora  REGB
00:B78A D002            	  1469:   bne  EX_NOJUMP
00:B78C F0E2            	  1470:   beq  EX_JMP
                        	  1471: ;
                        	  1472: ;  Don't jump, just move past the address (TODO: just add 2?)
                        	  1473: ;
                        	  1474: EX_NOJUMP:
00:B78E 2053B3          	  1475:   jsr  GETLIT
00:B791 4C5AB2          	  1476:   jmp  MAIN
                        	  1477: ;
                        	  1478: ;  Jump if the top of the stack is non-zero
                        	  1479: ;
                        	  1480: EX_JM1:
00:B794 20F0B2          	  1481:   jsr  PULTOP    ; puts REG into A
00:B797 0501            	  1482:   ora  REG+1
00:B799 0502            	  1483:   ora  REGB
00:B79B D0D3            	  1484:   bne  EX_JMP
00:B79D F0EF            	  1485:   beq  EX_NOJUMP
                        	  1486: ;
                        	  1487: ;
                        	  1488: EX_INPC:
00:B79F 200FCC          	  1489:   jsr GETIN
00:B7A2 C903            	  1490:   cmp  #KEY_ABORT   ; check for aborting with Ctrl+C
00:B7A4 D003            	  1491:   bne  EX_INPC_OK
00:B7A6 4C32B8          	  1492:   jmp  ex_input_aborted
                        	  1493: 
                        	  1494: EX_INPC_OK:
00:B7A9 201BB2          	  1495:   jsr CHK_KBD
00:B7AC B0F1            	  1496:   bcs EX_INPC
00:B7AE 8500            	  1497:   sta REG
00:B7B0 A900            	  1498:   lda #0
00:B7B2 8501            	  1499:   sta REG+1
00:B7B4 8502            	  1500:   sta REGB
00:B7B6 4C57B2          	  1501:   jmp  MAINP
                        	  1502: ;
                        	  1503: EX_OUTC:
00:B7B9 20F9CB          	  1504:   jsr write_to_serial
00:B7BC 8003            	  1505:   bra EX_OUTC_COMMON
                        	  1506: 
                        	  1507: EX_LCD_WRITE_CHR:
00:B7BE 2004CC          	  1508:   jsr write_to_lcd
                        	  1509: 
                        	  1510: EX_OUTC_COMMON:
00:B7C1 20F0B2          	  1511:   jsr  PULTOP
00:B7C4 A500            	  1512:   lda  REG
00:B7C6 209A96          	  1513:   jsr  COUT
00:B7C9 20F9CB          	  1514:   jsr write_to_serial
00:B7CC 4C5AB2          	  1515:   jmp  MAIN
                        	  1516:   ;
                        	  1517: 
                        	  1518: EX_LCDHOME:
00:B7CF 20F7BB          	  1519:   jsr lcd_home
00:B7D2 4C5AB2          	  1520:   JMP MAIN
                        	  1521: 
                        	  1522: 
                        	  1523: EX_LCDCLEAR:
00:B7D5 20E7BB          	  1524:   jsr lcd_clear_display
00:B7D8 4C5AB2          	  1525:   JMP MAIN
                        	  1526: 
                        	  1527: EX_INS      =  *
00:B7DB B123            	  1528:   lda  (PCODE),Y   ; wanted length
00:B7DD 8545            	  1529:   sta  TEMP
00:B7DF E623            	  1530:   inc  PCODE
00:B7E1 D002            	  1531:   bne  EX_INS3
00:B7E3 E624            	  1532:   inc  PCODE+1
                        	  1533: EX_INS3     =  *
00:B7E5 207296          	  1534:   jsr  GET_LINE
00:B7E8 AD0002          	  1535:   lda  INBUF
00:B7EB C903            	  1536:   cmp  #KEY_ABORT     ; check for them aborting the run on input
00:B7ED F043            	  1537:   beq  ex_input_aborted
00:B7EF 201BB2          	  1538:   jsr  CHK_KBD
00:B7F2 B0F1            	  1539:   bcs  EX_INS3      ; we turned on/off tracing etc, ignore this line
00:B7F4 98              	  1540:   tya               ; length of line
00:B7F5 18              	  1541:   clc
00:B7F6 6901            	  1542:   adc  #1        ; why?
00:B7F8 C545            	  1543:   cmp  TEMP
00:B7FA 9002            	  1544:   bcc  EX_INS1
00:B7FC A545            	  1545:   lda  TEMP      ; use max allowed length rather than received length
                        	  1546: EX_INS1     =  *
00:B7FE 8546            	  1547:   sta  TEMP+1    ; this is the length we are copying
00:B800 20A9B2          	  1548:   jsr  GETADR    ; get address to put the line
00:B803 A003            	  1549:   ldy  #3        ; why?
00:B805 A200            	  1550:   ldx  #0
                        	  1551: ;
                        	  1552: ;  copying loop - arrays are stored downwards, so we subtract from DATA each time
                        	  1553: ;
                        	  1554: EX_INS2     =  *
00:B807 C63D            	  1555:   dec  DATA
00:B809 A53D            	  1556:   lda  DATA
00:B80B C9FF            	  1557:   cmp  #$FF
00:B80D D002            	  1558:   bne  EX_INS4
00:B80F C63E            	  1559:   dec  DATA+1
                        	  1560: EX_INS4     =  *
00:B811 BD0002          	  1561:   lda  INBUF,X
00:B814 913D            	  1562:   sta  (DATA),Y
00:B816 E8              	  1563:   inx
00:B817 C646            	  1564:   dec  TEMP+1      ; count of bytes to copy
00:B819 D0EC            	  1565:   bne  EX_INS2
00:B81B 4C5AB2          	  1566:   jmp  MAIN        ; stop now
                        	  1567:   ;
                        	  1568: 
00:B81E 0A45786563757469	  1569: execution_aborted_message asciiz "\nExecution aborted\n"
00:B826 6F6E2061626F7274
00:B82E 65640A
00:B831 00
                        	  1570: 
                        	  1571: ex_input_aborted:
00:B832 A91E            	  1572:   lda #<execution_aborted_message
00:B834 A2B8            	  1573:   ldx #>execution_aborted_message
00:B836 4C9CB2          	  1574:   jmp NOTIM1
                        	  1575: ;
                        	  1576: ;
                        	  1577: EX_ADRNC    =  *
00:B839 20A9B2          	  1578:   jsr  GETADR
                        	  1579: EX_ADRNC2   =  *
00:B83C A53D            	  1580:   lda  DATA
00:B83E 18              	  1581:   clc
00:B83F 6902            	  1582:   adc  #2
00:B841 853D            	  1583:   sta  DATA
00:B843 9007            	  1584:   bcc  EX_ADRN2
00:B845 E63E            	  1585:   inc  DATA+1
00:B847 B003            	  1586:   bcs  EX_ADRN2
                        	  1587: EX_ADRNN    =  *
00:B849 20A9B2          	  1588:   jsr  GETADR
                        	  1589: EX_ADRN2    =  *
00:B84C A53D            	  1590:   lda  DATA
00:B84E 8500            	  1591:   sta  REG
00:B850 A53E            	  1592:   lda  DATA+1
00:B852 8501            	  1593:   sta  REG+1
00:B854 4C57B2          	  1594:   jmp  MAINP
                        	  1595: ;
                        	  1596: EX_ADRAN    =  *
00:B857 2008B5          	  1597:   jsr  GETIDX
00:B85A 4C4CB8          	  1598:   jmp  EX_ADRN2
                        	  1599: ;
                        	  1600: EX_ADRAC    =  *
00:B85D 20FFB4          	  1601:    jsr  GETIDC
00:B860 4C3CB8          	  1602:    jmp  EX_ADRNC2
                        	  1603: ;
                        	  1604: ;
                        	  1605: ;
                        	  1606: 
                        	  1607: 
                        	  1608: ;
                        	  1609: ;  DIGITALREAD (pin) pin:0 to 15; pushes 0 or 1
                        	  1610: ;
                        	  1611: EX_DIGITALREAD = *
00:B863 20F0B2          	  1612:   jsr PULTOP  ; which pin
00:B866 20DCCB          	  1613:   jsr digitalread
00:B869 D003            	  1614:   bne EX_DIGITALREAD_ONE
00:B86B 4C08B4          	  1615:   jmp FALSE
                        	  1616: EX_DIGITALREAD_ONE:
00:B86E 4CFBB3          	  1617:   jmp TRUE    ; done
                        	  1618: 
                        	  1619: ;
                        	  1620: ;  LCDPOS (line, column)
                        	  1621: ;
                        	  1622: 
                        	  1623: EX_LCDPOS = *
00:B871 20F0B2          	  1624:   jsr PULTOP   ; x
00:B874 290F            	  1625:   and #$0F     ; max 15
00:B876 858C            	  1626:   sta hardware_work  ; save it
00:B878 20F0B2          	  1627:   jsr PULTOP   ; y
00:B87B 2901            	  1628:   and #1       ; can be 0 or 1
00:B87D F002            	  1629:   beq EX_LCDPOS_1
00:B87F A940            	  1630:   lda #$40
                        	  1631: EX_LCDPOS_1:
00:B881 058C            	  1632:   ora hardware_work  ; or in the column
00:B883 0980            	  1633:   ora #$80     ; command to set the address
00:B885 2093BB          	  1634:   jsr lcd_instruction
00:B888 4C5AB2          	  1635:   jmp MAIN
                        	  1636: 
                        	  1637: ;
                        	  1638: ;  RANDOM
                        	  1639: ;
                        	  1640: EX_RANDOM:
00:B88B 20BE92          	  1641:   jsr gen_random
00:B88E A509            	  1642:   lda random
00:B890 8500            	  1643:   sta REG
00:B892 A50A            	  1644:   lda random+1
00:B894 8501            	  1645:   sta REG+1
00:B896 A50B            	  1646:   lda random+2
00:B898 8502            	  1647:   sta REGB
00:B89A 4C57B2          	  1648:   jmp MAINP
                        	  1649: 
                        	  1650: 
                        	  1651: ;
                        	  1652: ;  LATENCY
                        	  1653: ;
                        	  1654: EX_LATENCY:
00:B89D A50D            	  1655:   lda typing_latency
00:B89F 8500            	  1656:   sta REG
00:B8A1 A50E            	  1657:   lda typing_latency+1
00:B8A3 8501            	  1658:   sta REG+1
00:B8A5 A50F            	  1659:   lda typing_latency+2
00:B8A7 8502            	  1660:   sta REGB
00:B8A9 4C57B2          	  1661:   jmp MAINP
                        	  1662: 
                        	  1663: ; PULTOP puts stuff here thus:
                        	  1664: ;
                        	  1665: ;        LDA  REG
                        	  1666: ;        LDX  REG+1
                        	  1667: ;        LDY  REGB
                        	  1668: 
                        	  1669: EX_DELAY = *
00:B8AC 20F0B2          	  1670:   JSR  PULTOP  ; get the time interval in ms
                        	  1671:   ; (Y = high-order byte, X = lo-order byte)
00:B8AF A600            	  1672:   ldx REG
00:B8B1 A501            	  1673:   lda REG+1
00:B8B3 297F            	  1674:   and #$7F
00:B8B5 A8              	  1675:   tay
00:B8B6 20B993          	  1676:   jsr delay
00:B8B9 4C5AB2          	  1677:   jmp MAIN
                        	  1678: 
                        	  1679: ;
                        	  1680: ;  RANDOMSEED
                        	  1681: ;
                        	  1682: EX_RANDOMSEED = *
00:B8BC 20F0B2          	  1683:   JSR  PULTOP  ; get the seed
00:B8BF 850A            	  1684:   sta random+1
00:B8C1 860B            	  1685:   stx random+2
00:B8C3 840C            	  1686:   sty random+3
00:B8C5 A9FF            	  1687:   lda #$FF     ; ensure seed has some 1 bits
00:B8C7 8509            	  1688:   sta random
00:B8C9 4C5AB2          	  1689:   jmp MAIN
                        	  1690: 
                        	  1691: ;
                        	  1692: ;  PINMODE (pin, mode) pin:0 to 15; mode: 0=read, 1=write
                        	  1693: ;
                        	  1694: EX_PINMODE = *
00:B8CC 20F0B2          	  1695:   jsr PULTOP  ; the mode
00:B8CF AA              	  1696:   tax         ; input or output?
00:B8D0 DA              	  1697:   phx         ; save the mode
00:B8D1 20F0B2          	  1698:   jsr PULTOP  ; which pin
00:B8D4 FA              	  1699:   plx         ; get mode back
00:B8D5 207ECB          	  1700:   jsr pinmode ; pin in A, mode in X
00:B8D8 4C5AB2          	  1701:   jmp MAIN    ; done
                        	  1702: 
                        	  1703: ;
                        	  1704: ;  DIGITALWRITE (pin, value) pin:0 to 15; value: 0 or 1
                        	  1705: ;
                        	  1706: EX_DIGITALWRITE = *
00:B8DB 20F0B2          	  1707:   jsr PULTOP  ; the value
00:B8DE AA              	  1708:   tax         ;
00:B8DF DA              	  1709:   phx         ; save the value
00:B8E0 20F0B2          	  1710:   jsr PULTOP  ; which pin
00:B8E3 FA              	  1711:   plx         ; get mode back
00:B8E4 20ADCB          	  1712:   jsr digitalwrite ; pin in A, value in X
00:B8E7 4C5AB2          	  1713:   jmp MAIN    ; done
                        	  1714: 
                        	  1715: EX_LIB_CALL:
00:B8EA 2053B3          	  1716:   JSR  GETLIT
00:B8ED 6C0000          	  1717:   jmp  (REG)
                        	  1718: 
                        	  1719: ;
                        	  1720: ;  Assert (expression)
                        	  1721: ;
                        	  1722: 
                        	  1723: EX_ASSERT:
00:B8F0 20F0B2          	  1724:   jsr PULTOP  ; the value
00:B8F3 A500            	  1725:   lda REG
00:B8F5 0501            	  1726:   ora REG+1
00:B8F7 0502            	  1727:   ora REGB
00:B8F9 D00A            	  1728:   bne EX_ASSERT_OK
00:B8FB A909            	  1729:   lda #<assertion_failed_message  ; "Assertion failed"
00:B8FD A29A            	  1730:   ldx #>assertion_failed_message
00:B8FF 202682          	  1731:   jsr print
00:B902 4CD1B1          	  1732:   jmp RUNERR
                        	  1733: 
                        	  1734: EX_ASSERT_OK:
00:B905 4C5AB2          	  1735:   jmp MAIN
                        	  1736: 

Source: "gpascal.asm"
                        	   184:   .include "interrupts.inc"

Source: "interrupts.inc"
                        	     1: 
00:B908 0A42524B20657865	     2: break_message     asciiz "\nBRK executed at address $"
00:B910 6375746564206174
00:B918 2061646472657373
00:B920 2024
00:B922 00
00:B923 2C2041203D2024  	     3: a_equals_message  asciiz ", A = $"
00:B92A 00
00:B92B 2C2058203D2024  	     4: x_equals_message  asciiz ", X = $"
00:B932 00
00:B933 2C2059203D2024  	     5: y_equals_message  asciiz ", Y = $"
00:B93A 00
00:B93B 2C2050203D2024  	     6: p_equals_message  asciiz ", P = $"
00:B942 00
00:B943 2C2053203D2024  	     7: s_equals_message  asciiz ", S = $"
00:B94A 00
00:B94B 2C206964203D2024	     8: id_equals_message asciiz ", id = $"
00:B953 00
                        	     9: 
                        	    10: ;--------------------------------------------------
                        	    11: ;  IRQ - here on BRK interrupt
                        	    12: ;--------------------------------------------------
                        	    13: brk_executed:
00:B954 8412            	    14:   sty call_y    ; save Y - we didn't touch that
00:B956 8614            	    15:   stx call_s    ; X still has the stack pointer in it
00:B958 FA              	    16:   plx           ; get X back
00:B959 8611            	    17:   stx call_x
00:B95B 68              	    18:   pla           ; get A back
00:B95C 8510            	    19:   sta call_a    ; save A
00:B95E 68              	    20:   pla           ; get the processor flags from the stack
00:B95F 8513            	    21:   sta call_p
00:B961 68              	    22:   pla           ; low-order address of BRK
00:B962 8515            	    23:   sta brk_address
00:B964 68              	    24:   pla           ; high order address of BRK
00:B965 8516            	    25:   sta brk_address+1
                        	    26: 
00:B967 A2FF            	    27:   ldx  #NEW_STK
00:B969 9A              	    28:   txs             ; reset stack so we don't write over it
                        	    29: 
00:B96A 58              	    30:   cli           ; allow interrupts now so we can print
                        	    31: 
                        	    32: ;
                        	    33: ;  display BRK info for the user
                        	    34: ;
                        	    35:   ;
                        	    36:   ;  subtract 2 from brk_address to get where it actually was
                        	    37:   ;
00:B96B 38              	    38:   sec
00:B96C A515            	    39:   lda brk_address
00:B96E E902            	    40:   sbc #2
00:B970 8515            	    41:   sta brk_address
00:B972 A516            	    42:   lda brk_address+1
00:B974 E900            	    43:   sbc #0
00:B976 8516            	    44:   sta brk_address+1
00:B978 A908            	    45:   lda #<break_message
00:B97A A2B9            	    46:   ldx #>break_message
00:B97C 202682          	    47:   jsr print
00:B97F A516            	    48:   lda brk_address+1
00:B981 208195          	    49:   jsr PRBYTE
00:B984 A515            	    50:   lda brk_address
00:B986 208195          	    51:   jsr PRBYTE
                        	    52: ;
                        	    53: ;  show A, X, Y, P, S
                        	    54: ;
00:B989 A923            	    55:   lda #<a_equals_message
00:B98B A2B9            	    56:   ldx #>a_equals_message
00:B98D 202682          	    57:   jsr print
00:B990 A510            	    58:   lda call_a
00:B992 208195          	    59:   jsr PRBYTE
00:B995 A92B            	    60:   lda #<x_equals_message
00:B997 A2B9            	    61:   ldx #>x_equals_message
00:B999 202682          	    62:   jsr print
00:B99C A511            	    63:   lda call_x
00:B99E 208195          	    64:   jsr PRBYTE
00:B9A1 A933            	    65:   lda #<y_equals_message
00:B9A3 A2B9            	    66:   ldx #>y_equals_message
00:B9A5 202682          	    67:   jsr print
00:B9A8 A512            	    68:   lda call_y
00:B9AA 208195          	    69:   jsr PRBYTE
00:B9AD A93B            	    70:   lda #<p_equals_message
00:B9AF A2B9            	    71:   ldx #>p_equals_message
00:B9B1 202682          	    72:   jsr print
00:B9B4 A513            	    73:   lda call_p
00:B9B6 208195          	    74:   jsr PRBYTE
00:B9B9 A943            	    75:   lda #<s_equals_message
00:B9BB A2B9            	    76:   ldx #>s_equals_message
00:B9BD 202682          	    77:   jsr print
00:B9C0 A514            	    78:   lda call_s
00:B9C2 208195          	    79:   jsr PRBYTE
00:B9C5 A94B            	    80:   lda #<id_equals_message
00:B9C7 A2B9            	    81:   ldx #>id_equals_message
00:B9C9 202682          	    82:   jsr print
                        	    83: ;
                        	    84: ;  advance one byte to get the break ID (byte after the BRK)
                        	    85: ;
00:B9CC E615            	    86:   inc brk_address
00:B9CE D002            	    87:   bne brk_executed1
00:B9D0 E616            	    88:   inc brk_address+1
                        	    89: brk_executed1:
00:B9D2 A000            	    90:   ldy #0
00:B9D4 B115            	    91:   lda (brk_address),Y
00:B9D6 208195          	    92:   jsr PRBYTE
                        	    93: ;
                        	    94: ;  put brk_address back to where we should resume from
                        	    95: ;
00:B9D9 E615            	    96:   inc brk_address
00:B9DB D002            	    97:   bne brk_executed2
00:B9DD E616            	    98:   inc brk_address+1
                        	    99: brk_executed2:
                        	   100: 
00:B9DF 200C95          	   101:   jsr CROUT
                        	   102: ;
                        	   103: ;  display stack
                        	   104: ;
00:B9E2 A913            	   105:   lda #<stack_message
00:B9E4 A2BA            	   106:   ldx #>stack_message
00:B9E6 202682          	   107:   jsr print
00:B9E9 A514            	   108:   lda call_s
00:B9EB 18              	   109:   clc
00:B9EC 6906            	   110:   adc #6  ; the interrupt pushed 3 we pushed 2, plus the stack points to the first UNUSED spot
00:B9EE AA              	   111:   tax
                        	   112: brk_executed3:
00:B9EF BD0001          	   113:   lda $100,x
00:B9F2 DA              	   114:   phx
00:B9F3 208195          	   115:   jsr PRBYTE
00:B9F6 209795          	   116:   jsr PUTSP
00:B9F9 FA              	   117:   plx
00:B9FA E8              	   118:   inx
00:B9FB F00C            	   119:   beq brk_executed4
00:B9FD A910            	   120:   lda #FLAG_VALID_ASSEMBLE
00:B9FF 25BE            	   121:   and system_flags
00:BA01 F0EC            	   122:   beq brk_executed3
                        	   123: ;
                        	   124: ;  for run/assembler break, stop when stack reaches RUNNING_STACK_TOP
                        	   125: ;
00:BA03 E0D0            	   126:   cpx #(RUNNING_STACK_TOP + 1)
00:BA05 F002            	   127:   beq brk_executed4         ; we started here so let's stop here
00:BA07 80E6            	   128:   bra brk_executed3
                        	   129: 
                        	   130: ;
                        	   131: ;  we are done now
                        	   132: ;
                        	   133: brk_executed4:
00:BA09 200C95          	   134:   jsr CROUT
00:BA0C A980            	   135:   lda #FLAG_BRK_REACHED
00:BA0E 04BE            	   136:   tsb system_flags
00:BA10 4C7282          	   137:   jmp main_prompt
                        	   138: 
00:BA13 537461636B3A20  	   139: stack_message asciiz "Stack: "
00:BA1A 00
                        	   140: 
00:BA1B 4C54B9          	   141: brk_executedJ jmp brk_executed
                        	   142: 
                        	   143: ;--------------------------------------------------
                        	   144: ;  IRQ - here on maskable interrupt
                        	   145: ;--------------------------------------------------
                        	   146: 
                        	   147: irq:
00:BA1E 48              	   148:   pha       ; save A and X
00:BA1F DA              	   149:   phx
00:BA20 BA              	   150:   tsx       ; get stack pointer
00:BA21 E0FB            	   151:   cpx #$FB  ; should be lesss than $FB (since the interrupt pushed 3 and we pushed 2)
00:BA23 9006            	   152:   bcc irq1
00:BA25 A21B            	   153:   ldx #27   ; ERROR: stack full
00:BA27 58              	   154:   cli       ; allow interrupts or error won't print
00:BA28 4C4F9A          	   155:   jmp ERROR
                        	   156: 
                        	   157: irq1:
00:BA2B BD0301          	   158:   lda $103,X    ; this will be the processor flags on the stack (3 up from where we are now)
00:BA2E 2910            	   159:   and #$10      ; check BRK flag
00:BA30 D0E9            	   160:   bne brk_executedJ
                        	   161: ;
                        	   162: ;  here for a hardware IRQ
                        	   163: ;
00:BA32 ADFD7F          	   164:   lda VIA_IFR
00:BA35 2908            	   165:   and #VIA_FLAG_CB2        ; CB2 active edge
00:BA37 D00A            	   166:   bne cb2_interrupt
                        	   167: 
00:BA39 ADFD7F          	   168:   lda VIA_IFR
00:BA3C 2940            	   169:   and #VIA_FLAG_TIMER1     ; Time out of T1
00:BA3E D034            	   170:   bne timer1_interrupt
                        	   171: 
                        	   172: 
                        	   173: ;
                        	   174: ;  we shouldn't get here, and if we do we will probably just loop servicing the interrupt
                        	   175: ;
                        	   176:   .if SERIAL_DEBUGGING
                        	   177: 
                        	   178:     lda #SERIAL_SPARE2_MASK
                        	   179:     tsb VIA_PORTA
                        	   180:     trb VIA_PORTA
                        	   181: 
                        	   182:   .endif  ; SERIAL_DEBUGGING
                        	   183: 
00:BA40 4CA3BA          	   184:   jmp irq_done
                        	   185: 
                        	   186: ;
                        	   187: ;  here for incoming start bit
                        	   188: ;
                        	   189: cb2_interrupt:
                        	   190: 
00:BA43 8DFE7F          	   191:   sta VIA_IER           ; turn off that interrupt
00:BA46 8DFD7F          	   192:   sta VIA_IFR           ; indicate we noticed it
                        	   193: 
00:BA49 DA              	   194:   phx
00:BA4A 5A              	   195:   phy
                        	   196: 
00:BA4B A208            	   197:   ldx #8              ; count of bits
00:BA4D A030            	   198:   ldy #SERIAL_DELAY1  ; delay interval for first bit (allow for code above) TODO - probably needs to be less now
                        	   199: serial_in_loop:
                        	   200: ;
                        	   201: ; wait for bit time to be up
                        	   202: ;
00:BA4F 88              	   203:   dey
00:BA50 D0FD            	   204:   bne serial_in_loop
                        	   205: 
                        	   206:   .if SERIAL_DEBUGGING
                        	   207:     lda #SERIAL_DEBUG1_MASK     ; toggle debug flag (2 cycles)
                        	   208:     tsb VIA_PORTA               ; paint the fence: up (6 cycles)
                        	   209:     trb VIA_PORTA               ; down (6 cycles)
                        	   210:                                 ; look eye! always look eye
                        	   211:   .else
00:BA52 EA              	   212:     NOP    ; take the same time so the timing isn't thrown out
00:BA53 EA              	   213:     NOP    ; 2 cycles each
00:BA54 EA              	   214:     NOP
00:BA55 EA              	   215:     NOP
00:BA56 EA              	   216:     NOP
00:BA57 EA              	   217:     NOP
00:BA58 EA              	   218:     NOP    ; total of 14 cycles
                        	   219:   .endif  ; SERIAL_DEBUGGING
                        	   220: 
00:BA59 ADF17F          	   221:   lda VIA_PORTA
00:BA5C 6A              	   222:   ror A                 ; put incoming bit into carry
00:BA5D 668A            	   223:   ror serial_in_byte    ; shift one bit in
00:BA5F A023            	   224:   ldy #SERIAL_DELAY2    ; delay interval for remaining bits
00:BA61 CA              	   225:   dex
00:BA62 D0EB            	   226:   bne serial_in_loop
                        	   227: 
00:BA64 7A              	   228:   ply
00:BA65 FA              	   229:   plx
                        	   230: ;
                        	   231: ;  re-enable interrupts on the falling edge
                        	   232: ;
00:BA66 A988            	   233:   lda #VIA_FLAG_ENABLE | VIA_FLAG_CB2
00:BA68 8DFE7F          	   234:   sta VIA_IER
00:BA6B 8DFD7F          	   235:   sta VIA_IFR   ; indicate we know about previous falling edges
                        	   236: 
                        	   237: ;
                        	   238: ;  move to place that we know it will be noticed
                        	   239: ;
00:BA6E A58A            	   240:   lda serial_in_byte
00:BA70 858B            	   241:   sta serial_in_byte_received
                        	   242: 
00:BA72 802F            	   243:   bra irq_done
                        	   244: 
                        	   245: ;
                        	   246: ;  here for time to send another outgoing bit
                        	   247: ;
                        	   248: timer1_interrupt :
                        	   249: 
00:BA74 8DFD7F          	   250:   sta VIA_IFR           ; indicate we noticed it
00:BA77 A589            	   251:   lda serial_out_bit    ; are we in fact sending a byte?
00:BA79 F028            	   252:   beq irq_done          ; no, just exit
                        	   253: 
                        	   254:   .if SERIAL_DEBUGGING
                        	   255: 
                        	   256:   lda #SERIAL_DEBUG2_MASK     ; toggle debug flag (2 cycles)
                        	   257:   tsb VIA_PORTA               ; wash on   (6 cycles)
                        	   258:   trb VIA_PORTA               ; wash off  (6 cycles)
                        	   259:                               ; now, sand the floor
                        	   260:  .else
00:BA7B EA              	   261:      NOP    ; take the same time so the timing isn't thrown out
00:BA7C EA              	   262:      NOP    ; 2 cycles each
00:BA7D EA              	   263:      NOP
00:BA7E EA              	   264:      NOP
00:BA7F EA              	   265:      NOP
00:BA80 EA              	   266:      NOP
00:BA81 EA              	   267:      NOP    ; total of 14 cycles
                        	   268:   .endif  ; SERIAL_DEBUGGING
                        	   269: 
00:BA82 6688            	   270:   ror serial_out_byte+1  ; we don't care about the high-order bit
00:BA84 6687            	   271:   ror serial_out_byte    ; get the low-order bit into Carry
00:BA86 9007            	   272:   bcc write_zero
00:BA88 A902            	   273:   lda #SERIAL_OUT_MASK   ; (send a 1 bit)
00:BA8A 0DF17F          	   274:   ora VIA_PORTA
00:BA8D 8005            	   275:   bra serial_send_count_bits
                        	   276: 
                        	   277: write_zero:
00:BA8F A9FD            	   278:   lda #~SERIAL_OUT_MASK  ; (send a 0 bit)
00:BA91 2DF17F          	   279:   and VIA_PORTA
                        	   280: 
                        	   281: serial_send_count_bits:
00:BA94 8DF17F          	   282:   sta VIA_PORTA          ; output this bit
00:BA97 C689            	   283:   dec serial_out_bit     ; remember bit count for later
00:BA99 D008            	   284:   bne irq_done
                        	   285: 
                        	   286: ; here when all bits have been sent
                        	   287: ; disable the timer as we don't need it any more
                        	   288: ; and this will be a flag that we can send another byte
                        	   289: 
00:BA9B A940            	   290:   lda #VIA_FLAG_DISABLE | VIA_FLAG_TIMER1  ; cancel interrupt on T1 timeout
00:BA9D 8DFE7F          	   291:   sta VIA_IER
00:BAA0 ADF47F          	   292:   lda VIA_T1C_L     ; clear interrupt flag
                        	   293: 
                        	   294: irq_done:
00:BAA3 FA              	   295:   plx   ; restore X
00:BAA4 68              	   296:   pla   ; restore A
00:BAA5 40              	   297:   rti
                        	   298: 

Source: "gpascal.asm"
                        	   185:   .include "lcd.inc"

Source: "lcd.inc"
                        	     1:   .if !EMULATOR
                        	     2:   .if LCD_SUPPORT
                        	     3: 
                        	     4: ;
                        	     5: ;  LCD stuff
                        	     6: ;
                        	     7: 
                        	     8: lcd_initialise:
                        	     9: ;
                        	    10: ;  LCD initialise
                        	    11: ;
                        	    12: 
00:BAA6 ADF37F          	    13:   lda VIA_DDRA
00:BAA9 09E0            	    14:   ora #(LCD_RW|LCD_RS|LCD_E)    ; set appropriate pins on Port A to output
00:BAAB 8DF37F          	    15:   sta VIA_DDRA
                        	    16: 
                        	    17:   ; see HD44780U documentation: "Initializing by Instruction" (page 46)
00:BAAE 2027BB          	    18:   jsr lcd_prepare_to_write_instruction
00:BAB1 A930            	    19:   lda #$30
00:BAB3 2087BB          	    20:   jsr lcd_write_instruction_nibble
                        	    21:   ; wait > 4.1 ms
00:BAB6 A214            	    22:   ldx #20
00:BAB8 A000            	    23:   ldy #0
00:BABA 20B993          	    24:   jsr delay      ; 20 ms delay (in case of faster board clock speeds)
00:BABD 2087BB          	    25:   jsr lcd_write_instruction_nibble
00:BAC0 20AF93          	    26:   jsr delay_1ms  ; do it 4 times in case of faster board clock speeds
00:BAC3 20AF93          	    27:   jsr delay_1ms
00:BAC6 20AF93          	    28:   jsr delay_1ms
00:BAC9 20AF93          	    29:   jsr delay_1ms
00:BACC 2087BB          	    30:   jsr lcd_write_instruction_nibble
00:BACF 20AF93          	    31:   jsr delay_1ms  ; do it 4 times in case of faster board clock speeds
00:BAD2 20AF93          	    32:   jsr delay_1ms
00:BAD5 20AF93          	    33:   jsr delay_1ms
00:BAD8 20AF93          	    34:   jsr delay_1ms
00:BADB A920            	    35:   lda #$20    ; switch to 4-bit mode
00:BADD 2087BB          	    36:   jsr lcd_write_instruction_nibble
00:BAE0 20AF93          	    37:   jsr delay_1ms  ; do it 4 times in case of faster board clock speeds
00:BAE3 20AF93          	    38:   jsr delay_1ms
00:BAE6 20AF93          	    39:   jsr delay_1ms
00:BAE9 20AF93          	    40:   jsr delay_1ms
                        	    41: ;
                        	    42: ;  now we can switch to sending 8-bits in two nibbles
                        	    43: ;
00:BAEC A928            	    44:   lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
00:BAEE 2093BB          	    45:   jsr lcd_instruction
00:BAF1 A90C            	    46:   lda #%00001100 ; DCB: Display on; cursor off; blink off
00:BAF3 2093BB          	    47:   jsr lcd_instruction
00:BAF6 A906            	    48:   lda #%00000110 ; Increment and shift cursor; don't shift display
00:BAF8 2093BB          	    49:   jsr lcd_instruction
00:BAFB 20E7BB          	    50:   jsr lcd_clear_display
00:BAFE 60              	    51:   rts
                        	    52: 
                        	    53: lcd_prepare_to_read_register:
00:BAFF ADF17F          	    54:   lda VIA_PORTA
00:BB02 0940            	    55:   ora #LCD_RW             ; set RW bit  (ie. enable reading)
00:BB04 295F            	    56:   and #<(~(LCD_RS|LCD_E)) ; Clear RS/E bits
00:BB06 8DF17F          	    57:   sta VIA_PORTA
00:BB09 ADF27F          	    58:   lda VIA_DDRB
00:BB0C 290F            	    59:   and #$0F
00:BB0E 8DF27F          	    60:   sta VIA_DDRB            ; we are reading from DDRB
00:BB11 60              	    61:   rts
                        	    62: 
                        	    63: lcd_prepare_to_write_data:
00:BB12 48              	    64:   pha
00:BB13 ADF17F          	    65:   lda VIA_PORTA
00:BB16 293F            	    66:   and #<(~(LCD_RW|LCD_E))  ; clear RW and E (enable writing)
00:BB18 0920            	    67:   ora #LCD_RS              ; setting this means we write a character
00:BB1A 8DF17F          	    68:   sta VIA_PORTA
00:BB1D ADF27F          	    69:   lda VIA_DDRB
00:BB20 09F0            	    70:   ora #$F0      ; Set high-order pins on port B to output
00:BB22 8DF27F          	    71:   sta VIA_DDRB
00:BB25 68              	    72:   pla
00:BB26 60              	    73:   rts
                        	    74: 
                        	    75: lcd_prepare_to_write_instruction:
00:BB27 48              	    76:   pha
00:BB28 ADF17F          	    77:   lda VIA_PORTA
00:BB2B 291F            	    78:   and #<(~(LCD_RW|LCD_RS|LCD_E))  ; clear RW, RS and E (enable writing)
00:BB2D 8DF17F          	    79:   sta VIA_PORTA
00:BB30 ADF27F          	    80:   lda VIA_DDRB
00:BB33 09F0            	    81:   ora #$F0      ; Set high-order pins on port B to output
00:BB35 8DF27F          	    82:   sta VIA_DDRB
00:BB38 68              	    83:   pla
00:BB39 60              	    84:   rts
                        	    85: 
                        	    86: lcd_set_enable:
00:BB3A ADF17F          	    87:   lda VIA_PORTA
00:BB3D 0980            	    88:   ora #LCD_E
00:BB3F 8DF17F          	    89:   sta VIA_PORTA   ; Set enable (E)
00:BB42 60              	    90:   rts
                        	    91: 
                        	    92: lcd_clear_enable:
00:BB43 ADF17F          	    93:   lda VIA_PORTA
00:BB46 297F            	    94:   and #<(~LCD_E)  ; Clear enable (E)
00:BB48 8DF17F          	    95:   sta VIA_PORTA
00:BB4B 60              	    96:   rts
                        	    97: 
                        	    98: lcd_read_instruction_nibble:
00:BB4C 203ABB          	    99:   jsr lcd_set_enable
00:BB4F ADF07F          	   100:   lda VIA_PORTB   ; read the data on port B
00:BB52 48              	   101:   pha             ; save the data
00:BB53 2043BB          	   102:   jsr lcd_clear_enable
00:BB56 68              	   103:   pla             ; get the data back
00:BB57 60              	   104:   rts
                        	   105: 
                        	   106: ;
                        	   107: ; wait until LCD is not busy
                        	   108: ;
                        	   109: lcd_wait:
00:BB58 DA              	   110:   phx
00:BB59 5A              	   111:   phy
00:BB5A 48              	   112:   pha
00:BB5B 20FFBA          	   113:   jsr lcd_prepare_to_read_register
00:BB5E A200            	   114:   ldx #0
                        	   115: lcdbusy:
                        	   116: ;
                        	   117: ;  timeout after 256 iterations of this loop so we don't hang
                        	   118: ;  if there is no LCD or it doesn't respond
                        	   119: ;
00:BB60 CA              	   120:   dex
00:BB61 F00C            	   121:   beq lcd_wait_timeout
00:BB63 204CBB          	   122:   jsr lcd_read_instruction_nibble
00:BB66 2980            	   123:   and #$80        ; get busy flag
00:BB68 A8              	   124:   tay             ; save busy status
00:BB69 204CBB          	   125:   jsr lcd_read_instruction_nibble   ; do second nibble
00:BB6C 98              	   126:   tya             ; get busy status back
00:BB6D D0F1            	   127:   bne lcdbusy     ; if busy go back
                        	   128: ;
                        	   129: ;  here when not busy any more
                        	   130: ;
                        	   131: lcd_wait_timeout:
00:BB6F 68              	   132:   pla
00:BB70 7A              	   133:   ply
00:BB71 FA              	   134:   plx
00:BB72 60              	   135:   rts
                        	   136: 
                        	   137: ;
                        	   138: ;  Find the current LCD (cursor) address - useful for knowing
                        	   139: ;  if we exceed the limit of line 1
                        	   140: ;
                        	   141: lcd_get_address:
00:BB73 20FFBA          	   142:   jsr lcd_prepare_to_read_register
00:BB76 204CBB          	   143:   jsr lcd_read_instruction_nibble
00:BB79 2970            	   144:   and #$70        ; ignore busy bit, mask out other junk
00:BB7B 8586            	   145:   sta lcd_work
00:BB7D 204CBB          	   146:   jsr lcd_read_instruction_nibble
00:BB80 4A              	   147:   lsr A   ; shift this lot into low-order bits
00:BB81 4A              	   148:   lsr A
00:BB82 4A              	   149:   lsr A
00:BB83 4A              	   150:   lsr A
00:BB84 0586            	   151:   ora lcd_work    ; get the high-order bits back
00:BB86 60              	   152:   rts
                        	   153: 
                        	   154: lcd_write_instruction_nibble:
00:BB87 48              	   155:   pha
00:BB88 8DF07F          	   156:   sta VIA_PORTB         ; set up the data
00:BB8B 203ABB          	   157:   jsr lcd_set_enable    ; toggle enable
00:BB8E 2043BB          	   158:   jsr lcd_clear_enable
00:BB91 68              	   159:   pla
00:BB92 60              	   160:   rts
                        	   161: 
                        	   162: ;
                        	   163: ;  send an instruction to the LCD
                        	   164: ;
                        	   165: lcd_instruction:
00:BB93 2058BB          	   166:   jsr lcd_wait
00:BB96 2027BB          	   167:   jsr lcd_prepare_to_write_instruction
00:BB99 2087BB          	   168:   jsr lcd_write_instruction_nibble
00:BB9C 48              	   169:   pha
00:BB9D 0A              	   170:   asl a   ; move the low-order bits into the high-order bits
00:BB9E 0A              	   171:   asl a   ; because the high-order 4 bits are the active ones
00:BB9F 0A              	   172:   asl a
00:BBA0 0A              	   173:   asl a
00:BBA1 2087BB          	   174:   jsr lcd_write_instruction_nibble
00:BBA4 68              	   175:   pla
00:BBA5 60              	   176:   rts
                        	   177: 
                        	   178: lcd_data_nibble:
00:BBA6 48              	   179:   pha
00:BBA7 2012BB          	   180:   jsr lcd_prepare_to_write_data
00:BBAA 8DF07F          	   181:   sta VIA_PORTB
00:BBAD 203ABB          	   182:   jsr lcd_set_enable
00:BBB0 2043BB          	   183:   jsr lcd_clear_enable
00:BBB3 68              	   184:   pla
00:BBB4 60              	   185:   rts
                        	   186: 
                        	   187: ;
                        	   188: ;  print a character to the LCD
                        	   189: ;
                        	   190: lcd_print_char:
00:BBB5 2058BB          	   191:   jsr lcd_wait  ; wait for previous write to finish
00:BBB8 C90A            	   192:   cmp #NL
00:BBBA D004            	   193:   bne lcd_print_not_newline ; newline jumps to 2nd line
00:BBBC 20EFBB          	   194:   jsr lcd_second_line       ; go to second line
00:BBBF 60              	   195:   rts                       ; and don't print the newline :)
                        	   196: 
                        	   197: lcd_print_not_newline:
00:BBC0 48              	   198:   pha                   ; save the character we want to print
00:BBC1 2073BB          	   199:   jsr lcd_get_address
00:BBC4 C910            	   200:   cmp #16         ; 16 characters on the first line
00:BBC6 900E            	   201:   bcc lcd_print_char_ok ; not there yet
00:BBC8 D005            	   202:   bne lcd_print_char_on_2nd_line  ; not < 16 and not == 16, must be > 16
                        	   203:   ; we have exactly 16, so drop down to address 64
00:BBCA 20EFBB          	   204:   jsr lcd_second_line  ; at char 16 go to 2nd line (address 64)
00:BBCD 8007            	   205:   bra lcd_print_char_ok
                        	   206: 
                        	   207: lcd_print_char_on_2nd_line:
00:BBCF C950            	   208:   cmp #80                  ; more than 16 characters on in 2nd line? (64 + 16)
00:BBD1 9003            	   209:   bcc lcd_print_char_ok    ; nah
00:BBD3 20E7BB          	   210:   jsr lcd_clear_display    ; yes, clear display then and start again
                        	   211: lcd_print_char_ok:
                        	   212: lcd_print_char_newline:
00:BBD6 2012BB          	   213:   jsr lcd_prepare_to_write_data
00:BBD9 68              	   214:   pla                      ; get the character back
00:BBDA 20A6BB          	   215:   jsr lcd_data_nibble
00:BBDD 48              	   216:   pha
00:BBDE 0A              	   217:   asl a     ; now send the low-order bits
00:BBDF 0A              	   218:   asl a
00:BBE0 0A              	   219:   asl a
00:BBE1 0A              	   220:   asl a
00:BBE2 20A6BB          	   221:   jsr lcd_data_nibble
00:BBE5 68              	   222:   pla
00:BBE6 60              	   223:   rts
                        	   224: 
                        	   225: lcd_clear_display:
00:BBE7 48              	   226:   pha
00:BBE8 A901            	   227:   lda #%00000001 ; Clear display
00:BBEA 2093BB          	   228:   jsr lcd_instruction
00:BBED 68              	   229:   pla
00:BBEE 60              	   230:   rts
                        	   231: 
                        	   232: lcd_second_line:
00:BBEF 48              	   233:   pha
00:BBF0 A9C0            	   234:   lda #$C0 ; set output address to 0x40 (set DDRAM address)
00:BBF2 2093BB          	   235:   jsr lcd_instruction
00:BBF5 68              	   236:   pla
00:BBF6 60              	   237:   rts
                        	   238: 
                        	   239: lcd_home:
00:BBF7 48              	   240:   pha
00:BBF8 A980            	   241:   lda #$80 ; set output address to 0 (set DDRAM address)
00:BBFA 2093BB          	   242:   jsr lcd_instruction
00:BBFD 68              	   243:   pla
00:BBFE 60              	   244:   rts
                        	   245: 
                        	   246: 
                        	   247: ;
                        	   248: ;  print null-terminated message on LCD, message in A (lo) and X (hi)
                        	   249: ;  returns the length of the message in Y
                        	   250: ;
                        	   251: lcd_print_message:
00:BBFF 8503            	   252:   sta REG2
00:BC01 8604            	   253:   stx REG2+1
00:BC03 A000            	   254:   ldy #0
00:BC05 20E7BB          	   255:   jsr lcd_clear_display
                        	   256: lcd_print:
00:BC08 B103            	   257:   lda (REG2),y
00:BC0A F006            	   258:   beq lcd_print_done
00:BC0C 20B5BB          	   259:   jsr lcd_print_char
00:BC0F C8              	   260:   iny
00:BC10 80F6            	   261:   bra lcd_print
                        	   262: 
00:BC12 60              	   263: lcd_print_done rts
                        	   264: 
                        	   265:   .else ; LCD_SUPPORT
                        	   266: 
                        	   267: lcd_print_char :
                        	   268: lcd_clear_display :
                        	   269: lcd_second_line:
                        	   270: lcd_print_message:
                        	   271: lcd_instruction:
                        	   272: lcd_get_address:
                        	   273: lcd_home:
                        	   274: lcd_wait:
                        	   275:     ldx #50     ; No LCD
                        	   276:     jmp ERROR
                        	   277: 
                        	   278: 
                        	   279:   .endif  ; (no) LCD_SUPPORT
                        	   280: 
                        	   281:   .endif  ; not emulator
                        	   282: 

Source: "gpascal.asm"
                        	   186:   .include "symbols.inc"

Source: "symbols.inc"
                        	     1: ;***********************************************
                        	     2: ; SYMBOL TABLE STUFF: Offsets from the start of a particular symbol
                        	     3: ; Stored as a linked list, where you search backwards so the more local one is found first
                        	     4: ;***********************************************
                        	     5: 
                        	     6: SYMPRV   =  0         ; address of previous symbol (for working backwards through symbols)
                        	     7: SYMLVL   =  2         ; nested level (eg. entering a procedure/function increments the level,
                        	     8:                       ;                   and leaving it decrements the level)
                        	     9:                       ; - used to detect duplicate symbols at the same level
                        	    10: SYMLIB   =  2         ; (re-used above for assembler symbols: 0 = user-declared, 1 = library)
                        	    11: SYMTYP   =  3         ; Symbol type: C = constant, V = variable, Y = function return value
                        	    12:                       ;              P = procedure, F = function, A = array
                        	    13:                       ;              p = library procedure, f = library function
                        	    14:                       ;  See defines below.
                        	    15: SYMDSP   =  4         ; if the symbol is a constant, what the value is (3 bytes)
                        	    16:                       ; if the symbol is a variable, array or function return then this is the offset (2 bytes)
                        	    17: SYMARG   =  6         ; if the symbol is a procedure/function, count of arguments (can be zero)
                        	    18: SYMSUB   =  6         ; MAX SUBSCRIPT+1 - for arrays, so this is the actual array length
                        	    19: SYMDAT   =  8         ; data type: 0 = integer, 1 = char
                        	    20: SYMLEN   =  9         ; length of the name, der
                        	    21: SYMNAM   =  10        ; name of symbol for SYMLEN characters, stored in upper-case
                        	    22: 
                        	    23: ;
                        	    24: ; Symbol types
                        	    25: ;
                        	    26: 
                        	    27: SYMBOL_CONSTANT          = 'C'
                        	    28: SYMBOL_VARIABLE          = 'V'
                        	    29: SYMBOL_FUNCTION_RETURN   = 'Y'
                        	    30: SYMBOL_PROCEDURE         = 'P'
                        	    31: SYMBOL_FUNCTION          = 'F'
                        	    32: SYMBOL_LIBRARY_PROCEDURE = 'Q'  ; library procedures and functions are implemented in assembler
                        	    33: SYMBOL_LIBRARY_FUNCTION  = 'R'
                        	    34: SYMBOL_ARRAY             = 'A'
                        	    35: 
                        	    36: 
                        	    37: 
                        	    38: ;
                        	    39: ;***********************************************
                        	    40: ;SEARCH SYMBOL TABLE - returns Z if not found (BEQ <not found>)
                        	    41: ;***********************************************
                        	    42: SEARCH   =  *
00:BC13 A532            	    43:          lda  ENDSYM+1    ; get the end of the symbol table
00:BC15 8541            	    44:          sta  SYMITM+1    ; make it the current symbol
00:BC17 A531            	    45:          lda  ENDSYM
00:BC19 800B            	    46:          bra  SEA1
                        	    47: 
                        	    48: SEA_NEXT =  *
00:BC1B A000            	    49:          ldy  #SYMPRV
00:BC1D B140            	    50:          lda  (SYMITM),Y
00:BC1F AA              	    51:          tax
00:BC20 C8              	    52:          iny
00:BC21 B140            	    53:          lda  (SYMITM),Y
00:BC23 8541            	    54:          sta  SYMITM+1   ; previous link
00:BC25 8A              	    55:          txa
                        	    56: ;
                        	    57: ;  go to the previous symbol table item
                        	    58: ;
                        	    59: SEA1     =  *
00:BC26 8540            	    60:          sta  SYMITM
00:BC28 C52F            	    61:          cmp  STARTSYM
00:BC2A D007            	    62:          bne  SEA2
00:BC2C A541            	    63:          lda  SYMITM+1
00:BC2E C530            	    64:          cmp  STARTSYM+1
00:BC30 D001            	    65:          bne  SEA2       ; more to go
00:BC32 60              	    66:          rts             ; finished if we are back at the start of the symbol table
                        	    67: 
                        	    68: SEA2     =  *
00:BC33 A009            	    69:          ldy  #SYMLEN
00:BC35 B140            	    70:          lda  (SYMITM),Y  ; get this item's length
00:BC37 C592            	    71:          cmp  token_length      ; compare to the token legnth we got
00:BC39 D0E0            	    72:          bne  SEA_NEXT    ; wrong length - try another
00:BC3B A540            	    73:          lda  SYMITM      ; back to this symbol's start address
00:BC3D 18              	    74:          clc
00:BC3E 690A            	    75:          adc  #SYMNAM     ; add the offset of the name to it
00:BC40 8503            	    76:          sta  DEST
00:BC42 A541            	    77:          lda  SYMITM+1
00:BC44 6900            	    78:          adc  #0
00:BC46 8504            	    79:          sta  DEST+1      ; the memory location of the symbol name is in DEST
00:BC48 A590            	    80:          lda  token_address      ; now put the token's address into SRCE
00:BC4A 8500            	    81:          sta  SRCE
00:BC4C A591            	    82:          lda  token_address+1
00:BC4E 8501            	    83:          sta  SRCE+1
00:BC50 A492            	    84:          ldy  token_length
00:BC52 201195          	    85:          jsr  COMSTL      ; compare SRCE to DEST
00:BC55 D0C4            	    86:          bne  SEA_NEXT    ; not that one - try another
00:BC57 20CFBD          	    87:          jsr  GET_DAT     ; get the symbol's data type into DATTYP
00:BC5A A002            	    88:          ldy  #SYMLVL     ; and level - why isn't this a function, huh?
00:BC5C B140            	    89:          lda  (SYMITM),Y
00:BC5E AA              	    90:          tax              ; level into X
00:BC5F A003            	    91:          ldy  #SYMTYP
00:BC61 B140            	    92:          lda  (SYMITM),Y  ; get type of symbol
00:BC63 8536            	    93:          sta  BSAVE       ; symbol type -> BSAVE
00:BC65 C943            	    94:          cmp  #SYMBOL_CONSTANT       ; constant?
00:BC67 D013            	    95:          bne  SEA4        ; nah
                        	    96: ;
                        	    97: ;  symbol is a constant
                        	    98: ;
00:BC69 A004            	    99:          ldy  #SYMDSP     ; if a constant, this is the value
00:BC6B B140            	   100:          lda  (SYMITM),Y
00:BC6D 8594            	   101:          sta  token_value
00:BC6F C8              	   102:          iny
00:BC70 B140            	   103:          lda  (SYMITM),Y
00:BC72 8595            	   104:          sta  token_value+1
00:BC74 C8              	   105:          iny
00:BC75 B140            	   106:          lda  (SYMITM),Y
00:BC77 8596            	   107:          sta  token_value+2     ; token_value (3 bytes) now has the value in it
00:BC79 4C87BC          	   108:          jmp  SEA3
                        	   109: ;
                        	   110: ;  symbol is not a constant
                        	   111: ;
                        	   112: SEA4     =  *                           ; not constant
00:BC7C C956            	   113:          cmp  #SYMBOL_VARIABLE          ; variable?
00:BC7E F004            	   114:          beq  SEA5                      ; yes
00:BC80 C959            	   115:          cmp  #SYMBOL_FUNCTION_RETURN   ; argument?
00:BC82 D003            	   116:          bne  SEA3                      ; no - must be SYMBOL_ARRAY, SYMBOL_PROCEDURE or SYMBOL_FUNCTION
                        	   117: ;
                        	   118: ;  here for variables and function return values
                        	   119: ;
                        	   120: SEA5     =  *
00:BC84 202ABE          	   121:          jsr  GET_OFF    ; get the variable's offset
                        	   122: SEA3     =  *
00:BC87 A536            	   123:          lda  BSAVE      ; A now has the symbol type in it
                        	   124: 
                        	   125: ; Types are: SYMBOL_CONSTANT, SYMBOL_VARIABLE, SYMBOL_FUNCTION_RETURN,
                        	   126: ;            SYMBOL_PROCEDURE, SYMBOL_FUNCTION, SYMBOL_ARRAY
                        	   127: 
00:BC89 60              	   128:          rts             ; SHOULD SET 'NEQ' FLAG
                        	   129: 
                        	   130: 
00:BC8A A225            	   131: SYM_FULL ldx  #37     ; ERROR: Symbol table full
00:BC8C 4C4F9A          	   132:          jmp  ERROR
                        	   133: 
                        	   134: ;***********************************************
                        	   135: ; ADD SYMBOL TO SYMBOL TABLE - going downwards until we hit the P-codes
                        	   136: ;  A = the symbol type
                        	   137: ;***********************************************
                        	   138: ADDSYM   =  *
00:BC8F 48              	   139:          pha            ; save the symbol type
                        	   140: 
00:BC90 A631            	   141:          ldx  ENDSYM    ; get the end of the symbol table
00:BC92 8640            	   142:          stx  SYMITM    ; make it the current symbol
00:BC94 A632            	   143:          ldx  ENDSYM+1
00:BC96 8641            	   144:          stx  SYMITM+1
                        	   145: ;
                        	   146: ;  since we are going downwards, we need to subtract the fixed size of a symbol table item,
                        	   147: ;  plus the symbol length, from SYMITM
                        	   148: ;
00:BC98 38              	   149:          sec            ; first subtract the token length
00:BC99 A540            	   150:          lda  SYMITM
00:BC9B E592            	   151:          sbc  token_length
00:BC9D 8540            	   152:          sta  SYMITM
00:BC9F 8503            	   153:          sta  DEST      ; put this spot into DEST for copying the name
00:BCA1 A541            	   154:          lda  SYMITM+1
00:BCA3 E900            	   155:          sbc  #0
00:BCA5 8541            	   156:          sta  SYMITM+1
00:BCA7 8504            	   157:          sta  DEST+1
00:BCA9 38              	   158:          sec            ; and now the fixed size
00:BCAA A540            	   159:          lda  SYMITM
00:BCAC E90A            	   160:          sbc  #SYMNAM
00:BCAE 8540            	   161:          sta  SYMITM
00:BCB0 A541            	   162:          lda  SYMITM+1
00:BCB2 E900            	   163:          sbc  #0
00:BCB4 8541            	   164:          sta  SYMITM+1
                        	   165: ;
                        	   166: ;  check we haven't hit the P-codes
                        	   167: ;
00:BCB6 A902            	   168:          lda  #FLAG_ASSEMBLING
00:BCB8 25BE            	   169:          and  system_flags
00:BCBA D008            	   170:          bne  ADDSYM_NOT_FULL
00:BCBC A524            	   171:          lda  PCODE+1
00:BCBE C541            	   172:          cmp  SYMITM+1
00:BCC0 9002            	   173:          bcc  ADDSYM_NOT_FULL   ; less than - ok
00:BCC2 80C6            	   174:          bra  SYM_FULL          ; greater than or equal (high-order byte) - uh oh
                        	   175: ;
                        	   176: ;  ah, for assembling it is a pain to know whether the symbol table has overflowed, so I'm going
                        	   177: ;  to ignore that as a problem for now. Checking against PCODE will not work if the assembler output
                        	   178: ;  has been relocated to above the symbol table, and the only other thing we can compare against is
                        	   179: ;  the end of the source which we don't necessarily know.
                        	   180: ;
                        	   181: ;
                        	   182: ;  now put the previous start in as the link for the previous one for this item
                        	   183: ;
                        	   184: ADDSYM_NOT_FULL:
00:BCC4 A000            	   185:          ldy  #SYMPRV
00:BCC6 A531            	   186:          lda  ENDSYM
00:BCC8 9140            	   187:          sta  (SYMITM),Y
00:BCCA A532            	   188:          lda  ENDSYM+1
00:BCCC C8              	   189:          iny
00:BCCD 9140            	   190:          sta  (SYMITM),Y
                        	   191: ;
                        	   192: ;  SYMITM now becomes the start of the symbol table
                        	   193: ;
00:BCCF A540            	   194:          lda  SYMITM
00:BCD1 8531            	   195:          sta  ENDSYM
00:BCD3 A541            	   196:          lda  SYMITM+1
00:BCD5 8532            	   197:          sta  ENDSYM+1
                        	   198: ;
                        	   199: ;  OK, we should be done linking it in.
                        	   200: ;  SYMITM now points to this (as yet unfilled-in) item and the first two bytes now point to
                        	   201: ;   where the symbols previously ended
                        	   202: ;
00:BCD7 68              	   203:          pla                ; get symbol type back
00:BCD8 A003            	   204:          ldy  #SYMTYP
00:BCDA 9140            	   205:          sta  (SYMITM),Y    ; store the type which was in A
00:BCDC A002            	   206:          ldy  #SYMLVL
00:BCDE 48              	   207:          pha                ; save symbol type again
00:BCDF A522            	   208:          lda  LEVEL
00:BCE1 9140            	   209:          sta  (SYMITM),Y    ; store the level
00:BCE3 A009            	   210:          ldy  #SYMLEN
00:BCE5 A592            	   211:          lda  token_length
00:BCE7 9140            	   212:          sta  (SYMITM),Y    ; store the token length
00:BCE9 A8              	   213:          tay
00:BCEA 88              	   214:          dey                ; make zero-relative
                        	   215: ADD1     =  *               ; copy the name across, in upper case
00:BCEB B190            	   216:          lda  (token_address),Y
00:BCED 20A892          	   217:          jsr  MAKE_UPPER
00:BCF0 9103            	   218:          sta  (DEST),Y
00:BCF2 88              	   219:          dey
00:BCF3 10F6            	   220:          bpl  ADD1      ; keep copying
                        	   221: 
                        	   222: ;
                        	   223: ;  we have added name to the table, now do the rest
                        	   224: ;
00:BCF5 68              	   225:          pla                     ; get symbol type back again
00:BCF6 AA              	   226:          tax                     ; symbol type
00:BCF7 C943            	   227:          cmp  #SYMBOL_CONSTANT   ; CONSTANT??
00:BCF9 D013            	   228:          bne  ADD4
                        	   229: ;
                        	   230: ;  constant
                        	   231: ;
00:BCFB A004            	   232:          ldy  #SYMDSP            ; put this token's value into SYMDSP offset from SYMITM (for 3 bytes)
00:BCFD A594            	   233:          lda  token_value
00:BCFF 9140            	   234:          sta  (SYMITM),Y
00:BD01 C8              	   235:          iny
00:BD02 A595            	   236:          lda  token_value+1
00:BD04 9140            	   237:          sta  (SYMITM),Y
00:BD06 C8              	   238:          iny
00:BD07 A596            	   239:          lda  token_value+2
00:BD09 9140            	   240:          sta  (SYMITM),Y
00:BD0B 4C2ABD          	   241:          jmp  ADD9
                        	   242: ;
                        	   243: ;  not a constant
                        	   244: ;
                        	   245: ADD4     =  *
00:BD0E A008            	   246:          ldy  #SYMDAT
00:BD10 A901            	   247:          lda  #1            ; char type (?)
00:BD12 9140            	   248:          sta  (SYMITM),Y
00:BD14 8A              	   249:          txa                ; get symbol type back
00:BD15 C956            	   250:          cmp  #SYMBOL_VARIABLE
00:BD17 D011            	   251:          bne  ADD9
                        	   252: ;
                        	   253: ;  variable type
                        	   254: ;
00:BD19 A005            	   255:          ldy  #SYMDSP+1
00:BD1B A521            	   256:          lda  FRAME+1       ; save frame
00:BD1D 9140            	   257:          sta  (SYMITM),Y
00:BD1F 88              	   258:          dey
00:BD20 A520            	   259:          lda  FRAME
00:BD22 9140            	   260:          sta  (SYMITM),Y
00:BD24 E620            	   261:          inc  FRAME         ; add 1 to frame number
00:BD26 D002            	   262:          bne  ADD9
00:BD28 E621            	   263:          inc  FRAME+1
                        	   264: ADD9     =  *
00:BD2A 60              	   265:          rts
                        	   266: ;
                        	   267: 
                        	   268: ;
                        	   269: LOOKUP   =  *
00:BD2B 2013BC          	   270:          JSR  SEARCH
00:BD2E D005            	   271:          BNE  LOOK1
00:BD30 A20B            	   272:          LDX  #11     ; ERROR: Undeclared Identifier
00:BD32 4C4F9A          	   273:          jmp  ERROR
00:BD35 60              	   274: LOOK1    RTS
                        	   275: ;
00:BD36 2013BC          	   276: CHKDUP   JSR  SEARCH
00:BD39 F00A            	   277:          BEQ  DUP9
00:BD3B 8A              	   278:          TXA
00:BD3C C522            	   279:          CMP  LEVEL
00:BD3E D005            	   280:          BNE  DUP9
00:BD40 A226            	   281:          LDX  #38   ; ERROR: Duplicate Identifier
00:BD42 4C4F9A          	   282:          jmp  ERROR
00:BD45 60              	   283: DUP9     RTS
                        	   284: 

Source: "gpascal.asm"
                        	   187:   .include "compiler.inc"

Source: "compiler.inc"
                        	     1: 
                        	     2: ;***********************************************
                        	     3: ; COMPILER
                        	     4: ;***********************************************
                        	     5: 
                        	     6: 
                        	     7: ;
                        	     8: ;
                        	     9: ;  Compiler directives:
                        	    10: ;
                        	    11: ;    {%L} - list during compile (source code and current P-code address)
                        	    12: ;    {%P} - show generated P-codes during compile - only works during compile (not syntax check)
                        	    13: ;    {%N} - stop listing during compile (cancels %L and %P)
                        	    14: ;    {%S <address>} - relocate symbol table to <address> - must be done before defining symbols
                        	    15: ;                     also generates an opcode to relocate the runtime stack
                        	    16: ;
                        	    17: ;   The % must directly follow the start of the comment.
                        	    18: ;
                        	    19: ;
                        	    20: ;  Comments:  (* some comment *) or { some comment }
                        	    21: ;             "(*" / "{", and "*)" / "}" are treated interchangeably so (* some comment } would work
                        	    22: ;  Comments cannot be nested.
                        	    23: ;
                        	    24: ;  Tips:
                        	    25: ;
                        	    26: ;   Procedures and functions must be declared at the START of a block, not in the middle.
                        	    27: ;   The order is important. CONST first, then VAR, then procedure/function declarations, then BEGIN
                        	    28: 
                        	    29: ;    eg.
                        	    30: ;
                        	    31: ;    const limit = 10;   { <-- this is the start of a block: CONST before VAR }
                        	    32: ;    var k: integer;     { we declare variables and constants here - BEFORE "begin" }
                        	    33: ;    line : array [100] of char;  { array }
                        	    34: ;    function foo;       { and functions and procedures - this is the start of another block}
                        	    35: ;    begin
                        	    36: ;      foo := 42         { assign to function return value }
                        	    37: ;    end;                { end of the function block - note semicolon }
                        	    38: ;    begin               { end of declarations - now we have the block statements }
                        	    39: ;     for k := 1 to limit do
                        	    40: ;       writeln ("square of ", k, " is ", k * k);
                        	    41: ;     write (foo)        { call function }
                        	    42: ;    end.
                        	    43: ;
                        	    44: ;    ARGUMENTS: If the procedure or function does not take arguments OMIT THE BRACKETS.
                        	    45: ;               Likewise, omit the brackets if you call the procedure or function (unlike C)
                        	    46: ;
                        	    47: ;    Semicolons SEPARATE statements, they don't terminate them.
                        	    48: ;
                        	    49: ; Warnings: * Functions which do not assign to the function return value give undefined results.
                        	    50: ;           * Multiplication discards high-order bits if result is too large.
                        	    51: ;           * Divide remainder is always positive (ie. MOD always gives a positive result, regardless of operand signs)
                        	    52: ;           * Function arguments are always integers and always return an integer.
                        	    53: ;           * One to three-byte strings can be used as integer constants
                        	    54: ;               eg. a := "abc"; write (a);   --> Result: 6513249 (ie. 0x636261 or "abc")
                        	    55: ;               The first character is the low-order byte in the number, explaining the above results.
                        	    56: ;           * Strings can start with single or double quotes, whatever starts the string must terminate it.
                        	    57: ;           * String literals can have the same character that started the string embedded, to do that put it twice.
                        	    58: ;             eg. 'Nick''s cat'
                        	    59: ;           * Array access it not range-checked.
                        	    60: ;           * Arrays start at zero. The array size declared is the maximum index (unlike C) so foo: array [10] of integ
                        	    61: ;               would declare an array of 11 elements, numbered from foo [0] to foo [10]
                        	    62: ;           * Maximum arguments to a procedure/function is 85 (255 / 3) due to internal coding
                        	    63: ;
                        	    64: 
                        	    65: 
                        	    66: ;
00:BD46 A2FF            	    67: COMPIL   LDX  #NEW_STK
00:BD48 9A              	    68:   txs    ; set stack back to 0xFF
                        	    69: 
00:BD49 20BE94          	    70:   jsr  INIT
00:BD4C A901            	    71:   lda  #FLAG_COMPILING
00:BD4E 04BE            	    72:   tsb  system_flags
00:BD50 20B7C9          	    73:   jsr  add_pascal_library_functions
00:BD53 203DD2          	    74:   jsr  pas_get_token
00:BD56 203AC6          	    75:   jsr  BLOCK
00:BD59 A92E            	    76:   lda  #'.'
00:BD5B A209            	    77:   ldx  #9        ; ERROR: . expected
00:BD5D 20A1D2          	    78:   jsr  CHKTKN
00:BD60 A900            	    79:   lda  #0
00:BD62 A213            	    80:   ldx  #19       ; ERROR: Incorrect Symbol
00:BD64 2091D2          	    81:   jsr  GETCHK
00:BD67 200C95          	    82:   jsr  CROUT
00:BD6A A9C3            	    83:   lda  #<pcodes_ended_message  ; P-codes ended at
00:BD6C A295            	    84:   ldx  #>pcodes_ended_message
00:BD6E 202682          	    85:   jsr  print
00:BD71 A524            	    86:   lda  PCODE+1
00:BD73 8544            	    87:   sta  END_PCD+1
00:BD75 208195          	    88:   jsr  PRBYTE
00:BD78 A523            	    89:   lda  PCODE
00:BD7A 8543            	    90:   sta  END_PCD
00:BD7C 203696          	    91:   jsr  PRBYTECR
00:BD7F 20358F          	    92:   jsr  show_symbol_table_end
00:BD82 205A8F          	    93:   jsr  show_source_end
                        	    94: 
00:BD85 A9D6            	    95:   lda  #<compile_finished_message  ; <C>ompile finished: No Errors
00:BD87 A295            	    96:   ldx  #>compile_finished_message
00:BD89 202682          	    97:   jsr  print
00:BD8C A642            	    98:   ldx  SYNTAX
00:BD8E D004            	    99:   bne  END_CMP
00:BD90 A908            	   100:   lda  #FLAG_VALID_COMPILE
00:BD92 04BE            	   101:   tsb  system_flags
                        	   102: END_CMP  =  *
00:BD94 4C7282          	   103:   jmp  main_prompt
                        	   104: ;
                        	   105: 
                        	   106: ;
                        	   107: CHKLHP   =  *
00:BD97 A928            	   108:          LDA  #'('
00:BD99 A21F            	   109:          LDX  #31     ; ERROR: ( expected
00:BD9B 4C91D2          	   110:          JMP  GETCHK
                        	   111: ;
                        	   112: CHKRHP   =  *
00:BD9E A929            	   113:          LDA  #')'
00:BDA0 A216            	   114:          LDX  #22     ; ERROR: ) expected
00:BDA2 20A1D2          	   115:          JSR  CHKTKN
00:BDA5 4C3DD2          	   116:          JMP  pas_get_token
                        	   117: ;
                        	   118: GETSUB   =  *
00:BDA8 20B1BD          	   119:          JSR  CHKLHB
00:BDAB 20C2C0          	   120:          JSR  EXPRES
00:BDAE 4CBBBD          	   121:          JMP  CHKRHB
                        	   122: ;
                        	   123: CHKLHB   =  *
00:BDB1 A95B            	   124:          LDA  #'['
00:BDB3 A221            	   125:          LDX  #33     ; ERROR: [ expected
00:BDB5 2091D2          	   126:          JSR  GETCHK
00:BDB8 4C3DD2          	   127:          JMP  pas_get_token
                        	   128: ;
                        	   129: CHKRHB   =  *
00:BDBB A95D            	   130:          LDA  #']'
00:BDBD A222            	   131:          LDX  #34     ; ERROR: ] expected
00:BDBF 20A1D2          	   132:          JSR  CHKTKN
00:BDC2 4C3DD2          	   133:          JMP  pas_get_token
                        	   134: ;
                        	   135: GET_LEV  =  *
00:BDC5 A522            	   136:          LDA  LEVEL
00:BDC7 A002            	   137:          LDY  #SYMLVL
00:BDC9 38              	   138:          SEC
00:BDCA F140            	   139:          SBC  (SYMITM),Y
00:BDCC 8527            	   140:          STA  DISPL
00:BDCE 60              	   141:          RTS
                        	   142: ;
                        	   143: GET_DAT  =  *
00:BDCF A008            	   144:          LDY  #SYMDAT
00:BDD1 B140            	   145:          LDA  (SYMITM),Y
00:BDD3 854A            	   146:          STA  DATTYP
00:BDD5 60              	   147:          RTS
                        	   148: ;
                        	   149: 
                        	   150: 
                        	   151: 
                        	   152: ; CONSTANT DEC
                        	   153: ;
                        	   154: CONDEC   =  *
00:BDD6 A949            	   155:          LDA  #TOKEN_IDENTIFIER
00:BDD8 A204            	   156:          LDX  #4        ; ERROR: Identifier expected
00:BDDA 20A1D2          	   157:          JSR  CHKTKN
00:BDDD 20AD95          	   158:          JSR  TKNWRK
00:BDE0 A592            	   159:          LDA  token_length
00:BDE2 48              	   160:          PHA
00:BDE3 A93D            	   161:          LDA  #'='
00:BDE5 A203            	   162:          LDX  #3        ; ERROR: = expected
00:BDE7 2091D2          	   163:          JSR  GETCHK
00:BDEA 203DD2          	   164:          JSR  pas_get_token
00:BDED 20C9BE          	   165:          JSR  CONST
00:BDF0 20B895          	   166:          JSR  WRKTKN
00:BDF3 68              	   167:          PLA
00:BDF4 8592            	   168:          STA  token_length
00:BDF6 2036BD          	   169:          JSR  CHKDUP
00:BDF9 A943            	   170:          LDA  #SYMBOL_CONSTANT
00:BDFB 208FBC          	   171:          JSR  ADDSYM
00:BDFE 4C3DD2          	   172:          JMP  pas_get_token
                        	   173: ;
                        	   174: ;
                        	   175: ;--- SYMITM --> WORK
                        	   176: ;
                        	   177: SYMWRK   =  *
00:BE01 48              	   178:          PHA
00:BE02 A540            	   179:          LDA  SYMITM
00:BE04 8537            	   180:          STA  WORK
00:BE06 A541            	   181:          LDA  SYMITM+1
00:BE08 8538            	   182:          STA  WORK+1
00:BE0A 68              	   183:          PLA
00:BE0B 60              	   184:          RTS
                        	   185: ;
                        	   186: ;--- WORK --> SYMITM
                        	   187: ;
                        	   188: WRKSYM   =  *
00:BE0C 48              	   189:          PHA
00:BE0D A537            	   190:          LDA  WORK
00:BE0F 8540            	   191:          STA  SYMITM
00:BE11 A538            	   192:          LDA  WORK+1
00:BE13 8541            	   193:          STA  SYMITM+1
00:BE15 68              	   194:          PLA
00:BE16 60              	   195:          RTS
                        	   196: ;
                        	   197: ; PUSH PCODE ONTO STACK
                        	   198: ;
                        	   199: PSHPCODE =  *
00:BE17 8536            	   200:          STA  BSAVE
00:BE19 68              	   201:          PLA
00:BE1A AA              	   202:          TAX
00:BE1B 68              	   203:          PLA
00:BE1C A8              	   204:          TAY
00:BE1D A524            	   205:          LDA  PCODE+1
00:BE1F 48              	   206:          PHA
00:BE20 A523            	   207:          LDA  PCODE
00:BE22 48              	   208:          PHA
00:BE23 98              	   209:          TYA
00:BE24 48              	   210:          PHA
00:BE25 8A              	   211:          TXA
00:BE26 48              	   212:          PHA
00:BE27 A536            	   213:          LDA  BSAVE
00:BE29 60              	   214:          RTS
                        	   215: ;
                        	   216: ;  Get the offset of this current symbol into OFFSET
                        	   217: ;
                        	   218: GET_OFF  =  *
00:BE2A 48              	   219:          PHA
00:BE2B A004            	   220:          LDY  #SYMDSP
00:BE2D B140            	   221:          LDA  (SYMITM),Y
00:BE2F 8529            	   222:          STA  OFFSET
00:BE31 C8              	   223:          INY
00:BE32 B140            	   224:          LDA  (SYMITM),Y
00:BE34 852A            	   225:          STA  OFFSET+1
00:BE36 A003            	   226:          LDY  #SYMTYP
00:BE38 B140            	   227:          LDA  (SYMITM),Y
00:BE3A C956            	   228:          CMP  #SYMBOL_VARIABLE
00:BE3C F008            	   229:          BEQ  GETO_1
00:BE3E C941            	   230:          CMP  #SYMBOL_ARRAY
00:BE40 F004            	   231:          BEQ  GETO_1
00:BE42 C959            	   232:          CMP  #SYMBOL_FUNCTION_RETURN
00:BE44 D00D            	   233:          BNE  GETO_2
                        	   234: ;
                        	   235: ;  here if the symbol is a variable, array or function return value
                        	   236: ;   subtract the offset from -3
                        	   237: ;
                        	   238: GETO_1   =  *
00:BE46 38              	   239:          SEC
00:BE47 A9FD            	   240:          LDA  #$FD
00:BE49 E529            	   241:          SBC  OFFSET
00:BE4B 8529            	   242:          STA  OFFSET
00:BE4D A9FF            	   243:          LDA  #$FF
00:BE4F E52A            	   244:          SBC  OFFSET+1
00:BE51 852A            	   245:          STA  OFFSET+1
                        	   246: GETO_2   =  *
00:BE53 68              	   247:          PLA
00:BE54 60              	   248:          RTS
                        	   249: ;
                        	   250: GETEXPR  =  *
00:BE55 203DD2          	   251:          JSR  pas_get_token
00:BE58 4CC2C0          	   252:          JMP  EXPRES
                        	   253: ;
                        	   254: ;
                        	   255: PCD_WRKD =  *
00:BE5B 48              	   256:          PHA
00:BE5C A523            	   257:          LDA  PCODE
00:BE5E 8533            	   258:          STA  WORKD
00:BE60 A524            	   259:          LDA  PCODE+1
00:BE62 8534            	   260:          STA  WORKD+1
00:BE64 68              	   261:          PLA
00:BE65 60              	   262:          RTS
                        	   263: ;
                        	   264: WRK_OPND =  *
00:BE66 48              	   265:          PHA
00:BE67 A537            	   266:          LDA  WORK
00:BE69 852B            	   267:          STA  OPND
00:BE6B A538            	   268:          LDA  WORK+1
00:BE6D 852C            	   269:          STA  OPND+1
00:BE6F 68              	   270:          PLA
00:BE70 60              	   271:          RTS
                        	   272: ;
                        	   273: WRKD_WRK =  *
00:BE71 48              	   274:          PHA
00:BE72 A533            	   275:          LDA  WORKD
00:BE74 8537            	   276:          STA  WORK
00:BE76 A534            	   277:          LDA  WORKD+1
00:BE78 8538            	   278:          STA  WORK+1
00:BE7A 68              	   279:          PLA
00:BE7B 60              	   280:          RTS
                        	   281: ;
                        	   282: WRK_WRKD =  *
00:BE7C 48              	   283:          PHA
00:BE7D A537            	   284:          LDA  WORK
00:BE7F 8533            	   285:          STA  WORKD
00:BE81 A538            	   286:          LDA  WORK+1
00:BE83 8534            	   287:          STA  WORKD+1
00:BE85 68              	   288:          PLA
00:BE86 60              	   289:          RTS
                        	   290: ;
                        	   291: GET_COMM =  *
00:BE87 A92C            	   292:          LDA  #','
00:BE89 A220            	   293:          LDX  #32     ; ERROR: , expected
00:BE8B 4CA1D2          	   294:          JMP  CHKTKN
                        	   295: ;
                        	   296: GET_ITEM =  *
00:BE8E 2087BE          	   297:          JSR  GET_COMM   ; check for comma
00:BE91 4C55BE          	   298:          JMP  GETEXPR
                        	   299: ;
                        	   300: ;  Load (push) a constant (ie. a literal number)
                        	   301: ;
                        	   302: ;  Numbers in the range 0 to 0x7F are turned into a "low literal" which is a P-code
                        	   303: ;  with the 0x80 bit set. These then become a single-byte P-code which simply pushes
                        	   304: ;  that number onto the stack, thus saving having to have a 4-byte P-code being PCODE_LIT
                        	   305: ;  followed by a 3-byte number, 2 bytes of which would be zero.
                        	   306: ;
                        	   307: VAL_MOVE =  *
00:BE94 48              	   308:          PHA
00:BE95 18              	   309:          CLC
00:BE96 A594            	   310:          LDA  token_value
00:BE98 8527            	   311:          STA  DISPL   ; why?
00:BE9A 1001            	   312:          BPL  VAL_1   ; is it 0x00 to 0x7F?
00:BE9C 38              	   313:          SEC          ; no, set carry bit
                        	   314: VAL_1    =  *
00:BE9D A595            	   315:          LDA  token_value+1
00:BE9F F001            	   316:          BEQ  VAL_2   ; is second byte 0x00?
00:BEA1 38              	   317:          SEC          ; no, set carry bit
                        	   318: VAL_2    =  *
00:BEA2 8529            	   319:          STA  OFFSET
00:BEA4 A596            	   320:          LDA  token_value+2
00:BEA6 852A            	   321:          STA  OFFSET+1
00:BEA8 F001            	   322:          BEQ  VAL_3   ; is third byte 0x00?
00:BEAA 38              	   323:          SEC          ; no, set carry bit
                        	   324: VAL_3    =  *
00:BEAB 9007            	   325:          BCC  VAL_5   ; did we ever set the carry bit?
00:BEAD A900            	   326:          LDA  #PCODE_LIT  ; yes, so just generate a "load literal"
00:BEAF 207ACA          	   327:          JSR  GENADR
00:BEB2 68              	   328:          PLA
00:BEB3 60              	   329:          RTS
                        	   330: VAL_5    =  *
00:BEB4 A594            	   331:          LDA  token_value   ; get the low-order byte back
00:BEB6 0980            	   332:          ORA  #$80    ; set the 0x80 bit as a flag
00:BEB8 2061CA          	   333:          JSR  GENNOP  ; output one P-code
00:BEBB 68              	   334:          PLA
00:BEBC 60              	   335:          RTS
                        	   336: ;
                        	   337: ;
                        	   338: CHK_STAK =  *
00:BEBD BA              	   339:          TSX
00:BEBE 8A              	   340:          TXA
00:BEBF C920            	   341:          CMP  #MAX_STK
00:BEC1 9001            	   342:          BCC  STK_FULL
00:BEC3 60              	   343:          RTS
                        	   344: STK_FULL =  *
00:BEC4 A21B            	   345: STK_ERR  LDX  #27     ; ERROR: Stack full
00:BEC6 4C4F9A          	   346:          jmp  ERROR      ; FULL
                        	   347: ;
                        	   348: ;
                        	   349: ; CONST get the value into token_value
                        	   350: ;
                        	   351: CONST    =  *
00:BEC9 A593            	   352:          LDA  token_type
00:BECB C94E            	   353:          CMP  #TOKEN_NUMBER
00:BECD F01F            	   354:          BEQ  CONST9
00:BECF C949            	   355:          CMP  #TOKEN_IDENTIFIER
00:BED1 F00D            	   356:          BEQ  CONST1
00:BED3 C922            	   357:          CMP  #TOKEN_STRING
00:BED5 D00E            	   358:          BNE  CONST3
00:BED7 A692            	   359:          LDX  token_length
00:BED9 E004            	   360:          CPX  #4
00:BEDB 9011            	   361:          BCC  CONST9
00:BEDD 4C71C0          	   362:          JMP  FACERR1    ; STRING TOO BIG
00:BEE0 2013BC          	   363: CONST1   JSR  SEARCH
00:BEE3 D005            	   364:          BNE  CONST2
                        	   365: CONST3   =  *
00:BEE5 A202            	   366:          LDX  #2        ; ERROR: Constant expected
00:BEE7 4C4F9A          	   367:          jmp  ERROR
00:BEEA C943            	   368: CONST2   CMP  #SYMBOL_CONSTANT
00:BEEC D0F7            	   369:          BNE  CONST3
00:BEEE 60              	   370: CONST9   RTS
                        	   371: ;
                        	   372: ; VARIABLE DEC
                        	   373: ;
00:BEEF A949            	   374: VARDEC   LDA  #TOKEN_IDENTIFIER
00:BEF1 A204            	   375:          LDX  #4      ; ERROR: Identifier expected
00:BEF3 20A1D2          	   376:          JSR  CHKTKN
00:BEF6 2036BD          	   377:          JSR  CHKDUP
00:BEF9 A956            	   378:          LDA  #SYMBOL_VARIABLE
00:BEFB 208FBC          	   379:          JSR  ADDSYM
00:BEFE 4C3DD2          	   380:          JMP  pas_get_token
                        	   381: ;
                        	   382: ; SIMPLE EXPRESSION
                        	   383: ;
                        	   384: SIMEXP   =  *
00:BF01 A593            	   385:          LDA  token_type
00:BF03 C92B            	   386:          CMP  #'+'
00:BF05 F004            	   387:          BEQ  SIM1
00:BF07 C92D            	   388:          CMP  #'-'
00:BF09 D048            	   389:          BNE  SIM2
00:BF0B 48              	   390: SIM1     PHA
00:BF0C 203DD2          	   391:          JSR  pas_get_token
00:BF0F 2073BF          	   392:          JSR  TERM
00:BF12 68              	   393:          PLA
00:BF13 C92D            	   394:          CMP  #'-'
00:BF15 D005            	   395:          BNE  SIM3
00:BF17 A902            	   396:          LDA  #PCODE_NEG      ; NEG       Negate (sp)
00:BF19 2061CA          	   397:          JSR  GENNOP     ; NEGATE
00:BF1C A593            	   398: SIM3     LDA  token_type
00:BF1E C92B            	   399:          CMP  #'+'
00:BF20 F00D            	   400:          BEQ  SIM4
00:BF22 C92D            	   401:          CMP  #'-'
00:BF24 F009            	   402:          BEQ  SIM4
00:BF26 C98A            	   403:          CMP  #TOKEN_OR       ; OR
00:BF28 F005            	   404:          BEQ  SIM4
00:BF2A C9A4            	   405:          CMP  #TOKEN_XOR      ; XOR
00:BF2C F001            	   406:          BEQ  SIM4
00:BF2E 60              	   407:          RTS
00:BF2F 48              	   408: SIM4     PHA
00:BF30 203DD2          	   409:          JSR  pas_get_token
00:BF33 2073BF          	   410:          JSR  TERM
00:BF36 68              	   411:          PLA
00:BF37 C92D            	   412:          CMP  #'-'
00:BF39 F010            	   413:          BEQ  SIM5
00:BF3B C92B            	   414:          CMP  #'+'
00:BF3D F010            	   415:          BEQ  SIM6
00:BF3F C9A4            	   416:          CMP  #TOKEN_XOR          ; XOR
00:BF41 F016            	   417:          BEQ  SIM8
00:BF43 A91A            	   418:          LDA  #PCODE_ORR          ; ORR       OR  (sp - 1) | (sp)
00:BF45 2061CA          	   419: SIM7     JSR  GENNOP
00:BF48 4C1CBF          	   420:          JMP  SIM3
00:BF4B A906            	   421: SIM5     LDA  #PCODE_SUB          ; MINUS
00:BF4D D0F6            	   422:          BNE  SIM7
00:BF4F A904            	   423: SIM6     LDA  #PCODE_ADD          ; PLUS
00:BF51 D0F2            	   424:          BNE  SIM7
00:BF53 2073BF          	   425: SIM2     JSR  TERM
00:BF56 4C1CBF          	   426:          JMP  SIM3
00:BF59 A93A            	   427: SIM8     LDA  #PCODE_XOR         ; XOR
00:BF5B D0E8            	   428:          BNE  SIM7
                        	   429: ;
                        	   430: ; TERM
                        	   431: ;
00:BF5D 2A              	   432: TERMT1   ASC    '*'
00:BF5E 80BF            	   433:          word   TERM1
00:BF60 8B              	   434:          DFB    TOKEN_DIV    ; div
00:BF61 80BF            	   435:          word   TERM1
00:BF63 2F              	   436:          ASC    '/'
00:BF64 80BF            	   437:          word   TERM1
00:BF66 8D              	   438:          DFB    TOKEN_AND    ; and
00:BF67 80BF            	   439:          word   TERM1
00:BF69 8C              	   440:          DFB    TOKEN_MOD    ; mod
00:BF6A 80BF            	   441:          word   TERM1
00:BF6C 8E              	   442:          DFB    TOKEN_SHL    ; shl
00:BF6D 80BF            	   443:          word   TERM1
00:BF6F 8F              	   444:          DFB    TOKEN_SHR    ; shr
00:BF70 80BF            	   445:          word   TERM1
00:BF72 00              	   446:          DFB    0
                        	   447: ;
00:BF73 20C1BF          	   448: TERM     JSR  FACTOR
00:BF76 A25D            	   449: TERM2    LDX  #<TERMT1
00:BF78 A0BF            	   450:          LDY  #>TERMT1
00:BF7A A593            	   451:          LDA  token_type
00:BF7C 207692          	   452:          JSR  TKNJMP
00:BF7F 60              	   453:          RTS
                        	   454: ;
00:BF80 48              	   455: TERM1    PHA
00:BF81 203DD2          	   456:          JSR  pas_get_token
00:BF84 20C1BF          	   457:          JSR  FACTOR
00:BF87 68              	   458:          PLA
00:BF88 A2AB            	   459:          LDX  #<TERMT3
00:BF8A A0BF            	   460:          LDY  #>TERMT3
00:BF8C 207692          	   461:          JSR  TKNJMP
                        	   462: ;
00:BF8F A90A            	   463: TERM4    LDA  #PCODE_DIV       ; Divide (sp - 1) / (sp)
00:BF91 2061CA          	   464: TERM3    JSR  GENNOP
00:BF94 4C76BF          	   465:          JMP  TERM2
00:BF97 A91B            	   466: TERM5    LDA  #PCODE_AND        ; AND
00:BF99 D0F6            	   467:          BNE  TERM3
00:BF9B A90B            	   468: TERM6    LDA  #PCODE_MOD        ; MOD
00:BF9D D0F2            	   469:          BNE  TERM3
00:BF9F A922            	   470: TERM7    LDA  #PCODE_SHL       ; Shift left (sp) bits
00:BFA1 D0EE            	   471:          BNE  TERM3
00:BFA3 A924            	   472: TERM8    LDA  #PCODE_SHR       ; Shift right (sp) bits
00:BFA5 D0EA            	   473:          BNE  TERM3
00:BFA7 A908            	   474: TERM9    LDA  #PCODE_MUL        ; Multiply (sp) * (sp - 1)
00:BFA9 D0E6            	   475:          BNE  TERM3
                        	   476: ;
00:BFAB 8B              	   477: TERMT3   DFB    TOKEN_DIV     ; div
00:BFAC 8FBF            	   478:          word   TERM4
00:BFAE 2F              	   479:          ASC    '/'
00:BFAF 8FBF            	   480:          word   TERM4
00:BFB1 8D              	   481:          DFB    TOKEN_AND     ; and
00:BFB2 97BF            	   482:          word   TERM5
00:BFB4 8C              	   483:          DFB    TOKEN_MOD     ; mod
00:BFB5 9BBF            	   484:          word   TERM6
00:BFB7 8E              	   485:          DFB    TOKEN_SHL     ; shl
00:BFB8 9FBF            	   486:          word   TERM7
00:BFBA 8F              	   487:          DFB    TOKEN_SHR     ; shr
00:BFBB A3BF            	   488:          word   TERM8
00:BFBD 2A              	   489:          ASC    '*'
00:BFBE A7BF            	   490:          word   TERM9
00:BFC0 00              	   491:          DFB  0
                        	   492: ;
                        	   493: ; FACTOR
                        	   494: ;
00:BFC1 20BDBE          	   495: FACTOR   JSR  CHK_STAK
00:BFC4 A593            	   496:          LDA  token_type
00:BFC6 A2A9            	   497:          LDX  #<FACTB1
00:BFC8 A0C0            	   498:          LDY  #>FACTB1
00:BFCA 207692          	   499:          JSR  TKNJMP
00:BFCD A217            	   500:          LDX  #23     ; ERROR: Illegal factor
00:BFCF 4C4F9A          	   501:          jmp  ERROR
                        	   502: ;
00:BFD2 202BBD          	   503: IDENT    JSR  LOOKUP
00:BFD5 C950            	   504: IDENT1   CMP  #SYMBOL_PROCEDURE
00:BFD7 F004            	   505:          beq  IDENT1A
00:BFD9 C951            	   506:          CMP  #SYMBOL_LIBRARY_PROCEDURE
00:BFDB D005            	   507:          BNE  IDENT2
                        	   508: IDENT1A:
00:BFDD A215            	   509:          LDX  #21     ; ERROR: Use of procedure Identifier in expression
00:BFDF 4C4F9A          	   510:          jmp  ERROR
00:BFE2 C959            	   511: IDENT2   CMP  #SYMBOL_FUNCTION_RETURN
00:BFE4 D015            	   512:          BNE  IDENT2A
00:BFE6 A000            	   513:          LDY  #SYMPRV      ; this symbol is actually the function return value symbol
00:BFE8 B140            	   514:          LDA  (SYMITM),Y   ; so go to the previous symbol which will be the function
00:BFEA AA              	   515:          TAX               ; declaration symbol with the address of the function to be called
00:BFEB C8              	   516:          INY
00:BFEC B140            	   517:          LDA  (SYMITM),Y
00:BFEE 8541            	   518:          STA  SYMITM+1
00:BFF0 8A              	   519:          TXA
00:BFF1 8540            	   520:          STA  SYMITM
00:BFF3 A980            	   521:          lda  #$80       ; push 0 onto the stack which will be the default function return value
00:BFF5 2061CA          	   522:          jsr  GENNOP     ; when the function returns this will be left on the top of the stack
00:BFF8 4C42C3          	   523:          JMP  FNCPRC     ; with the function's assigned value in it (or zero if nothing assigned);
                        	   524: 
00:BFFB C952            	   525: IDENT2A  CMP #SYMBOL_LIBRARY_FUNCTION
00:BFFD D003            	   526:          bne IDENT3
00:BFFF 4C11CA          	   527:          jmp  library_function_call
                        	   528: 
00:C002 C941            	   529: IDENT3   CMP  #SYMBOL_ARRAY
00:C004 F030            	   530:          BEQ  IDENT4
00:C006 C943            	   531:          CMP  #SYMBOL_CONSTANT
00:C008 D00E            	   532:          BNE  IDENT5
00:C00A 2094BE          	   533:          JSR  VAL_MOVE
00:C00D 4C2BC0          	   534:          JMP  IDENT7
                        	   535: ;
                        	   536: ;   Here for address of integer variable
                        	   537: ;
00:C010 A90C            	   538: FACAD1   LDA  #PCODE_ADRNN
00:C012 201AC0          	   539:          JSR  IDENT5_A
00:C015 4C9EBD          	   540:          JMP  CHKRHP
                        	   541: ;
00:C018 A92C            	   542: IDENT5   LDA  #PCODE_LOD   ; load integer onto stack
00:C01A 48              	   543: IDENT5_A PHA
                        	   544: ;
00:C01B 8636            	   545:          STX  BSAVE
00:C01D A522            	   546:          LDA  LEVEL
00:C01F 38              	   547:          SEC
00:C020 E536            	   548:          SBC  BSAVE
00:C022 8527            	   549:          STA  DISPL
00:C024 68              	   550:          PLA
00:C025 18              	   551: IDENT6   CLC
00:C026 654A            	   552:          ADC  DATTYP
00:C028 207ACA          	   553:          JSR  GENADR
00:C02B 4C3DD2          	   554: IDENT7   JMP  pas_get_token
                        	   555: ;
00:C02E A90E            	   556: FACAD2   LDA  #PCODE_ADRAN  ; address of integer array
00:C030 2038C0          	   557:          JSR  IDENT4_A
00:C033 4C9EBD          	   558:          JMP  CHKRHP
                        	   559: ;
                        	   560: ;    Here for load indexed integer
                        	   561: ;
00:C036 A930            	   562: IDENT4   LDA  #PCODE_LDI         ; Load integer indexed
00:C038 48              	   563: IDENT4_A PHA
                        	   564: ;
00:C039 2001BE          	   565:          JSR  SYMWRK
00:C03C 204395          	   566:          JSR  PSHWRK
00:C03F 20A8BD          	   567:          JSR  GETSUB
00:C042 205695          	   568:          JSR  PULWRK
00:C045 200CBE          	   569:          JSR  WRKSYM
00:C048 20CFBD          	   570:          JSR  GET_DAT
00:C04B 20C5BD          	   571:          JSR  GET_LEV
00:C04E 202ABE          	   572:          JSR  GET_OFF
00:C051 68              	   573:          PLA
00:C052 18              	   574:          CLC
00:C053 654A            	   575:          ADC  DATTYP
00:C055 4C7ACA          	   576:          JMP  GENADR
                        	   577: ;
                        	   578: ; ADDRESS (IDENTIFIER)
                        	   579: ;
                        	   580: ;
                        	   581: FACADR   =  *
00:C058 2097BD          	   582:          JSR  CHKLHP
00:C05B 20A6D2          	   583:          JSR  GET_LOOK
00:C05E C956            	   584:          CMP  #SYMBOL_VARIABLE
00:C060 F0AE            	   585:          BEQ  FACAD1
00:C062 C941            	   586:          CMP  #SYMBOL_ARRAY
00:C064 F0C8            	   587:          BEQ  FACAD2
00:C066 A217            	   588:          LDX  #23     ; ERROR: Illegal factor
00:C068 4C4F9A          	   589:          jmp  ERROR
                        	   590: ;
                        	   591: ;
00:C06B A592            	   592: FACSTR   LDA  token_length
00:C06D C904            	   593:          CMP  #4
00:C06F 9005            	   594:          BCC  FACNUM    ; BLT
00:C071 A21D            	   595: FACERR1  LDX  #29        ; ERROR: string literal too big
00:C073 4C4F9A          	   596:          jmp  ERROR
                        	   597: FACNUM   =  *
00:C076 2094BE          	   598:          JSR  VAL_MOVE
00:C079 4C2BC0          	   599:          JMP  IDENT7
                        	   600: ;
00:C07C 2055BE          	   601: PAREN    JSR  GETEXPR
00:C07F 4C9EBD          	   602:          JMP  CHKRHP
                        	   603: ;
00:C082 A900            	   604: FACMEM   LDA  #0          ; add zero below to get PCODE_LDA
00:C084 854A            	   605:          STA  DATTYP
00:C086 F004            	   606:          BEQ  FACM2
00:C088 A901            	   607: FACMMC   LDA  #1          ; add one below to get PCODE_LDAC
00:C08A 854A            	   608:          STA  DATTYP
00:C08C A54A            	   609: FACM2    LDA  DATTYP
00:C08E 48              	   610:          PHA
00:C08F 20A8BD          	   611:          JSR  GETSUB
00:C092 68              	   612:          PLA
00:C093 18              	   613:          CLC
00:C094 692E            	   614:          ADC  #PCODE_LDA    ; Load absolute address integer or PCODE_LDAC if we added 1
00:C096 D008            	   615:          BNE  GENNOP1
                        	   616: ;
00:C098 203DD2          	   617: FACNOT   JSR  pas_get_token
00:C09B 20C1BF          	   618:          JSR  FACTOR
00:C09E A920            	   619:          LDA  #PCODE_EOR     ; Not (sp) (logical negate)
00:C0A0 4C61CA          	   620: GENNOP1  JMP  GENNOP
                        	   621: ;
00:C0A3 2061CA          	   622: FACRND1  JSR  GENNOP
00:C0A6 4C3DD2          	   623:          JMP  pas_get_token
                        	   624: ;
                        	   625: ;
                        	   626: ;
00:C0A9 49              	   627: FACTB1   DFB    TOKEN_IDENTIFIER
00:C0AA D2BF            	   628:          word   IDENT
00:C0AC 4E              	   629:          ASC    TOKEN_NUMBER
00:C0AD 76C0            	   630:          word   FACNUM
00:C0AF 22              	   631: FACTQT1  DFB    TOKEN_STRING        ; QUOTE SYMBOL
00:C0B0 6BC0            	   632:          word   FACSTR
00:C0B2 28              	   633:          ASC    '('
00:C0B3 7CC0            	   634:          word   PAREN
00:C0B5 91              	   635:          DFB    TOKEN_MEM
00:C0B6 82C0            	   636:          word   FACMEM     ; MEM
00:C0B8 90              	   637:          DFB    TOKEN_NOT
00:C0B9 98C0            	   638:          word   FACNOT
00:C0BB A2              	   639:          DFB    TOKEN_MEMC
00:C0BC 88C0            	   640:          word   FACMMC     ; MEMC
00:C0BE A9              	   641:          DFB    TOKEN_ADDRESS
00:C0BF 58C0            	   642:          word   FACADR
00:C0C1 00              	   643:          DFB  0
                        	   644: ;
                        	   645: ; EXPRESSION
                        	   646: ;
00:C0C2 20BDBE          	   647: EXPRES   JSR  CHK_STAK
00:C0C5 2001BF          	   648:          JSR  SIMEXP
00:C0C8 A593            	   649:          LDA  token_type
00:C0CA A2D2            	   650:          LDX  #<EXPTB1
00:C0CC A0C0            	   651:          LDY  #>EXPTB1
00:C0CE 207692          	   652:          JSR  TKNJMP
00:C0D1 60              	   653:          RTS
                        	   654: ;
00:C0D2 3D              	   655: EXPTB1   ASC    '='
00:C0D3 E5C0            	   656:          word   EXPR1
00:C0D5 55              	   657:          DFB    TOKEN_NEQ
00:C0D6 E5C0            	   658:          word   EXPR1
00:C0D8 3C              	   659:          ASC    '<'
00:C0D9 E5C0            	   660:          word   EXPR1
00:C0DB 80              	   661:          DFB    TOKEN_LEQ
00:C0DC E5C0            	   662:          word   EXPR1
00:C0DE 81              	   663:          DFB    TOKEN_GEQ
00:C0DF E5C0            	   664:          word   EXPR1
00:C0E1 3E              	   665:          ASC    '>'
00:C0E2 E5C0            	   666:          word   EXPR1
00:C0E4 00              	   667:          DFB  0
                        	   668: ;
00:C0E5 48              	   669: EXPR1    PHA
00:C0E6 203DD2          	   670:          JSR  pas_get_token
00:C0E9 2001BF          	   671:          JSR  SIMEXP
00:C0EC 68              	   672:          PLA
00:C0ED A2F4            	   673:          LDX  #<EXPTB3
00:C0EF A0C0            	   674:          LDY  #>EXPTB3
00:C0F1 207692          	   675:          JSR  TKNJMP
                        	   676: ;
00:C0F4 3D              	   677: EXPTB3   ASC    '='
00:C0F5 07C1            	   678:          word   EXPR2
00:C0F7 55              	   679:          ASC    TOKEN_NEQ
00:C0F8 0DC1            	   680:          word   EXPR3
00:C0FA 3C              	   681:          ASC    '<'
00:C0FB 11C1            	   682:          word   EXPR4
00:C0FD 81              	   683:          DFB    TOKEN_GEQ
00:C0FE 15C1            	   684:          word   EXPR5
00:C100 3E              	   685:          ASC    '>'
00:C101 19C1            	   686:          word   EXPR6
00:C103 80              	   687:          DFB    TOKEN_LEQ
00:C104 1DC1            	   688:          word   EXPR7
00:C106 00              	   689:          DFB  0
                        	   690: ;
00:C107 A910            	   691: EXPR2    LDA  #PCODE_EQL       ; EQL      Test (sp - 1) == (sp)
00:C109 2061CA          	   692: EXPR8    JSR  GENNOP
00:C10C 60              	   693:          RTS
00:C10D A912            	   694: EXPR3    LDA  #PCODE_NEQ       ; NEQ      Test (sp - 1) != (sp)
00:C10F D0F8            	   695:          BNE  EXPR8
00:C111 A914            	   696: EXPR4    LDA  #PCODE_LSS       ; LSS      Test (sp - 1) < (sp)
00:C113 D0F4            	   697:          BNE  EXPR8
00:C115 A916            	   698: EXPR5    LDA  #PCODE_GEQ       ; GEQ      Test (sp - 1) >= (sp)
00:C117 D0F0            	   699:          BNE  EXPR8
00:C119 A918            	   700: EXPR6    LDA  #PCODE_GTR       ; GTR      Test (sp - 1) > (sp)
00:C11B D0EC            	   701:          BNE  EXPR8
00:C11D A919            	   702: EXPR7    LDA  #PCODE_LEQ       ; LEQ      Test (sp - 1) <= (sp)
00:C11F D0E8            	   703:          BNE  EXPR8
                        	   704: ;
                        	   705: ; STATEMENT
                        	   706: ;
00:C121 20BDBE          	   707: STMNT    JSR  CHK_STAK
00:C124 A593            	   708:          LDA  token_type
00:C126 A22E            	   709:          LDX  #<STMNT1
00:C128 A0C1            	   710:          LDY  #>STMNT1
00:C12A 207692          	   711:          JSR  TKNJMP
00:C12D 60              	   712:          RTS
                        	   713: ;
00:C12E 49              	   714: STMNT1   DFB    TOKEN_IDENTIFIER
00:C12F 59C1            	   715:          word   ASSIGN
00:C131 92              	   716:          DFB    TOKEN_IF
00:C132 C9C3            	   717:          word   IF
00:C134 9A              	   718:          DFB    TOKEN_FOR
00:C135 30C5            	   719:          word   FOR
00:C137 96              	   720:          DFB    TOKEN_WHILE
00:C138 43C4            	   721:          word   WHILE
00:C13A 95              	   722:          DFB    TOKEN_CASE
00:C13B 75C4            	   723:          word   CASE
00:C13D 98              	   724:          DFB    TOKEN_REPEAT
00:C13E 1FC4            	   725:          word   REPEAT
00:C140 88              	   726:          DFB    TOKEN_BEGIN
00:C141 09C4            	   727:          word   BEG
00:C143 9E              	   728:          DFB    TOKEN_READ
00:C144 71C2            	   729:          word   READ
00:C146 9D              	   730:          DFB    TOKEN_WRITE
00:C147 CFC1            	   731:          word   WRITE
00:C149 91              	   732:          DFB    TOKEN_MEM
00:C14A 1AC3            	   733:          word   MEM
00:C14C 9F              	   734:          DFB    TOKEN_CALL
00:C14D 35C3            	   735:          word   CALLSB
00:C14F A2              	   736:          DFB    TOKEN_MEMC
00:C150 1FC3            	   737:          word   MEMC
00:C152 FF              	   738:          DFB    TOKEN_WRITELN
00:C153 C0C1            	   739:          word   WRITELN
00:C155 F1              	   740:          DB     TOKEN_LCDWRITE
00:C156 20C2            	   741:          word   STMNT_WRITE_LCD
00:C158 00              	   742:          DFB  0
                        	   743: ;
                        	   744: ; ASSIGNMENT - this is where we store an integer/char into a variable or array index
                        	   745: ;
00:C159 202BBD          	   746: ASSIGN   JSR  LOOKUP
00:C15C A268            	   747: ASS1     LDX  #<ASSTB1
00:C15E A0C1            	   748:          LDY  #>ASSTB1
00:C160 207692          	   749:          JSR  TKNJMP
00:C163 A218            	   750:          LDX  #24     ; ERROR: Type mismatch
00:C165 4C4F9A          	   751:          jmp  ERROR
                        	   752: ;
00:C168 41              	   753: ASSTB1   DFB   SYMBOL_ARRAY
00:C169 83C1            	   754:          word  ASSARR
00:C16B 56              	   755:          DFB   SYMBOL_VARIABLE
00:C16C 95C1            	   756:          word  ASSVAR
00:C16E 59              	   757:          DFB   SYMBOL_FUNCTION_RETURN
00:C16F 95C1            	   758:          word  ASSVAR
00:C171 50              	   759:          DFB   SYMBOL_PROCEDURE
00:C172 42C3            	   760:          word  FNCPRC
00:C174 51              	   761:          DFB   SYMBOL_LIBRARY_PROCEDURE
00:C175 11CA            	   762:          word  library_function_call
00:C177 46              	   763:          DFB   SYMBOL_FUNCTION
00:C178 7EC1            	   764:          word  assign_bad_identifier
00:C17A 52              	   765:          DFB   SYMBOL_LIBRARY_FUNCTION
00:C17B 7EC1            	   766:          word  assign_bad_identifier
00:C17D 00              	   767:          DFB  0
                        	   768: 
                        	   769: assign_bad_identifier:
00:C17E A235            	   770:           ldx #53   ; ERROR: Use of function identifier in statement
00:C180 4C4F9A          	   771:           jmp ERROR
                        	   772: ;
00:C183 2001BE          	   773: ASSARR   JSR  SYMWRK
00:C186 204395          	   774:          JSR  PSHWRK
00:C189 A936            	   775:          LDA  #PCODE_STI    ; Store integer indexed
00:C18B 18              	   776:          CLC
00:C18C 654A            	   777:          ADC  DATTYP        ; A becomes PCODE_STIC (Store character indexed) if DATTYP == 1
00:C18E 48              	   778:          PHA
00:C18F 20A8BD          	   779:          JSR  GETSUB
00:C192 4CA4C1          	   780:          JMP  ASS2
                        	   781: ;
00:C195 2001BE          	   782: ASSVAR   JSR  SYMWRK
00:C198 204395          	   783:          JSR  PSHWRK
00:C19B A932            	   784:          LDA  #PCODE_STO    ;  Store integer
00:C19D 18              	   785:          CLC
00:C19E 654A            	   786:          ADC  DATTYP        ; A becomes PCODE_STOC (Store character indexed) if DATTYP == 1
00:C1A0 48              	   787:          PHA
00:C1A1 203DD2          	   788:          JSR  pas_get_token
00:C1A4 A941            	   789: ASS2     LDA  #TOKEN_ASSIGN
00:C1A6 A20D            	   790:          LDX  #13       ; ERROR: := expected
00:C1A8 20A1D2          	   791:          JSR  CHKTKN
00:C1AB 2055BE          	   792:          JSR  GETEXPR
00:C1AE 68              	   793:          PLA
00:C1AF 205695          	   794:          JSR  PULWRK
00:C1B2 200CBE          	   795:          JSR  WRKSYM
00:C1B5 48              	   796:          PHA
00:C1B6 20C5BD          	   797:          JSR  GET_LEV
00:C1B9 202ABE          	   798:          JSR  GET_OFF
00:C1BC 68              	   799:          PLA
00:C1BD 4C7ACA          	   800:          JMP  GENADR
                        	   801: ;
                        	   802: 
                        	   803: ;
                        	   804: ;
                        	   805: ; WRITELN
                        	   806: ;
00:C1C0 203DD2          	   807: WRITELN  JSR  pas_get_token     ; SEE IF ( PRESENT
00:C1C3 C928            	   808:          CMP  #'('
00:C1C5 D003            	   809:          BNE  WRITELN9   ; NOPE
00:C1C7 20D2C1          	   810:          JSR  WRIT9
                        	   811: WRITELN9 =  *
00:C1CA A940            	   812:          LDA  #PCODE_OUTCR   ; OUTPUT C/R
00:C1CC 4C61CA          	   813:          JMP  GENNOP
                        	   814: ;
                        	   815: ;
                        	   816: ; WRITE
                        	   817: ;
00:C1CF 2097BD          	   818: WRITE    JSR  CHKLHP
00:C1D2 203DD2          	   819: WRIT9    JSR  pas_get_token
00:C1D5 C922            	   820:          CMP  #TOKEN_STRING
00:C1D7 D022            	   821:          BNE  WRIT1
00:C1D9 A923            	   822:          LDA  #PCODE_OUS    ; Output string
00:C1DB 20E1C1          	   823:          JSR  W_STRING
00:C1DE 4C0BC2          	   824:          JMP  WRIT5
                        	   825: ;
                        	   826: W_STRING =  *
00:C1E1 2061CA          	   827:          JSR  GENNOP
00:C1E4 A592            	   828:          LDA  token_length
00:C1E6 2061CA          	   829:          JSR  GENNOP
00:C1E9 A000            	   830:          LDY  #0
00:C1EB B90002          	   831: WRIT2    LDA  INBUF,Y
00:C1EE C8              	   832: WRIT10   INY
00:C1EF 5A              	   833:          phy
00:C1F0 2061CA          	   834:          JSR  GENNOP
00:C1F3 7A              	   835:          ply
00:C1F4 C692            	   836:          DEC  token_length
00:C1F6 D0F3            	   837:          BNE  WRIT2
00:C1F8 4C3DD2          	   838:          JMP  pas_get_token
                        	   839: ;
                        	   840: WRIT1    =  *          ; here if not string
00:C1FB C9AB            	   841:          CMP  #TOKEN_CHR       ; CHR?
00:C1FD F015            	   842:          BEQ  W_CHR      ; yes
00:C1FF C9AC            	   843:          CMP  #TOKEN_HEX       ; HEX?
00:C201 F019            	   844:          BEQ  W_HEX      ; yes
00:C203 20C2C0          	   845:          JSR  EXPRES     ; just ordinary number - get it
00:C206 A91E            	   846:          LDA  #PCODE_OUT        ; OUT       Output number
00:C208 2061CA          	   847:          JSR  GENNOP
00:C20B A593            	   848: WRIT5    LDA  token_type
00:C20D C92C            	   849:          CMP  #','
00:C20F F0C1            	   850:          BEQ  WRIT9
00:C211 4C9EBD          	   851:          JMP  CHKRHP
                        	   852: ;
                        	   853: ; here for write (chr(x))
                        	   854: ;
                        	   855: W_CHR    =  *
00:C214 A91F            	   856:          LDA  #PCODE_OUTC   ; OUTC      Output character
                        	   857: W_CHR1   =  *
00:C216 2010C3          	   858:          JSR  WAIT_1     ; process expression in parentheses
00:C219 4C0BC2          	   859:          JMP  WRIT5      ; back for next item
                        	   860: ;
                        	   861: ; here for write (hex(x))
                        	   862: ;
                        	   863: W_HEX    =  *
00:C21C A921            	   864:          LDA  #PCODE_OUH        ; OUH       Output hex number
00:C21E D0F6            	   865:          BNE  W_CHR1
                        	   866: 
                        	   867: ;
                        	   868: ;
                        	   869: ; WRITELCD: can write number, string, hex or chr
                        	   870: ;
00:C220 2097BD          	   871: STMNT_WRITE_LCD    JSR  CHKLHP
00:C223 203DD2          	   872: WRITE_LCD9    JSR  pas_get_token
00:C226 C922            	   873:          CMP  #TOKEN_STRING
00:C228 D022            	   874:          BNE  WRITE_LCD1
00:C22A A943            	   875:          LDA  #PCODE_LCD_WRITE_STR    ; Output string
00:C22C 2032C2          	   876:          JSR  WRITE_LCD_STRING
00:C22F 4C5CC2          	   877:          JMP  WRITE_LCD5
                        	   878: ;
                        	   879: WRITE_LCD_STRING =  *
00:C232 2061CA          	   880:          JSR  GENNOP
00:C235 A592            	   881:          LDA  token_length
00:C237 2061CA          	   882:          JSR  GENNOP
00:C23A A000            	   883:          LDY  #0
00:C23C B90002          	   884: WRITE_LCD2    LDA  INBUF,Y    ; strings are placed in INBUF during parsing
00:C23F C8              	   885:          INY
00:C240 5A              	   886:          phy
00:C241 2061CA          	   887:          JSR  GENNOP
00:C244 7A              	   888:          ply
00:C245 C692            	   889:          DEC  token_length
00:C247 D0F3            	   890:          BNE  WRITE_LCD2
00:C249 4C3DD2          	   891:          JMP  pas_get_token
                        	   892: ;
                        	   893: WRITE_LCD1    =  *            ; here if not string
00:C24C C9AB            	   894:          CMP  #TOKEN_CHR      ; CHR?
00:C24E F015            	   895:          BEQ  WRITE_LDC_CHR   ; yes
00:C250 C9AC            	   896:          CMP  #TOKEN_HEX      ; HEX?
00:C252 F019            	   897:          BEQ  WRITE_LDC_HEX   ; yes
00:C254 20C2C0          	   898:          JSR  EXPRES          ; just ordinary number - get it
00:C257 A942            	   899:          LDA  #PCODE_LCD_WRITE_NUM        ; OUT       Output number
00:C259 2061CA          	   900:          JSR  GENNOP
00:C25C A593            	   901: WRITE_LCD5    LDA  token_type
00:C25E C92C            	   902:          CMP  #','
00:C260 F0C1            	   903:          BEQ  WRITE_LCD9
00:C262 4C9EBD          	   904:          JMP  CHKRHP
                        	   905: ;
                        	   906: ; here for lcdwrite (chr(x))
                        	   907: ;
                        	   908: WRITE_LDC_CHR    =  *
00:C265 A945            	   909:          LDA  #PCODE_LCD_WRITE_CHR   ; OUTC     Output character
                        	   910: WRITE_LDC_CHR1   =  *
00:C267 2010C3          	   911:          JSR  WAIT_1          ; process expression in parentheses
00:C26A 4C5CC2          	   912:          JMP  WRITE_LCD5      ; back for next item
                        	   913: ;
                        	   914: ; here for lcdwrite (hex(x))
                        	   915: ;
                        	   916: WRITE_LDC_HEX    =  *
00:C26D A944            	   917:          LDA  #PCODE_LCD_WRITE_HEX        ; OUH       Output hex number
00:C26F D0F6            	   918:          BNE  WRITE_LDC_CHR1
                        	   919: 
                        	   920: ;
                        	   921: ;
                        	   922: ; READ
                        	   923: ;
00:C271 2097BD          	   924: READ     jsr  CHKLHP    ; check for "("
00:C274 20A6D2          	   925: READ8    jsr  GET_LOOK
00:C277 2001BE          	   926: READ2    jsr  SYMWRK      ; SYMITM --> WORK
00:C27A 204395          	   927:          jsr  PSHWRK
00:C27D A200            	   928:          ldx  #0
00:C27F 864B            	   929:          stx  COUNT1      ; this will have 1 in it if we are reading into an array element
00:C281 C941            	   930:          cmp  #SYMBOL_ARRAY
00:C283 F03B            	   931:          beq  READ3
00:C285 C956            	   932:          cmp  #SYMBOL_VARIABLE
00:C287 F005            	   933:          beq  READ9
00:C289 A20C            	   934:          ldx  #12     ; ERROR: Illegal Identifier
00:C28B 4C4F9A          	   935:          jmp  ERROR
                        	   936: 
00:C28E 208FCC          	   937: READ9    jsr get_token
00:C291 A91C            	   938: READ11   lda  #PCODE_INP  ; Input number
00:C293 18              	   939:          clc
00:C294 654A            	   940:          adc  DATTYP      ; becomes PCODE_INPC (input character) if DATTYP == 1
00:C296 2061CA          	   941:          jsr  GENNOP
00:C299 205695          	   942:          jsr  PULWRK
00:C29C 200CBE          	   943:          jsr  WRKSYM      ; WORK --> SYMITM
00:C29F 20CFBD          	   944:          jsr  GET_DAT
00:C2A2 20C5BD          	   945:          jsr  GET_LEV
00:C2A5 202ABE          	   946:          jsr  GET_OFF
00:C2A8 A932            	   947:          lda  #PCODE_STO    ; Store integer
00:C2AA A64B            	   948:          ldx  COUNT1
00:C2AC F002            	   949:          beq  READ7
00:C2AE A936            	   950:          lda  #PCODE_STI    ; Store integer indexed
00:C2B0 18              	   951: READ7    clc
00:C2B1 654A            	   952:          adc  DATTYP        ; add 1 if a char to become PCODE_STOC / PCODE_STIC
00:C2B3 207ACA          	   953:          jsr  GENADR
00:C2B6 A593            	   954: READ7_A  lda  token_type
00:C2B8 C92C            	   955:          cmp  #','
00:C2BA F0B8            	   956:          beq  READ8         ; get another variable to read into
                        	   957: ;
                        	   958: ;  done with READ statement
                        	   959: ;
00:C2BC 209EBD          	   960:          jsr  CHKRHP        ; check for ")"
00:C2BF 60              	   961:          rts
                        	   962: ;
                        	   963: ;  here for reading into an array
                        	   964: ;
00:C2C0 A54A            	   965: READ3    lda  DATTYP
00:C2C2 48              	   966:          pha              ; push data type of array
00:C2C3 203DD2          	   967:          jsr  pas_get_token
00:C2C6 C95B            	   968:          cmp  #'['
00:C2C8 F025            	   969:          beq  READ3_A
00:C2CA 68              	   970:          pla            ; get back data type of array
00:C2CB 854A            	   971:          sta  DATTYP    ; 0 = integer, 1 = char
00:C2CD D005            	   972:          bne  READ3_B
00:C2CF A218            	   973:          ldx  #24       ; ERROR: Type mismatch (cannot read into array of integer)
00:C2D1 4C4F9A          	   974:          jmp  ERROR
00:C2D4 205695          	   975: READ3_B  jsr  PULWRK
00:C2D7 200CBE          	   976:          jsr  WRKSYM     ; WORK --> SYMITM
00:C2DA A925            	   977:          lda  #PCODE_INS        ; READ STRING - Input string into array
00:C2DC 2061CA          	   978:          jsr  GENNOP
00:C2DF 20C5BD          	   979:          jsr  GET_LEV
00:C2E2 202ABE          	   980:          jsr  GET_OFF
00:C2E5 A006            	   981:          ldy  #SYMSUB
00:C2E7 B140            	   982:          lda  (SYMITM),Y  ; maximum array size
00:C2E9 207ACA          	   983:          jsr  GENADR     ; A = length, not the P-code which we just output above
00:C2EC 4CB6C2          	   984:          jmp  READ7_A
                        	   985: ;
                        	   986: ;  read into subscripted item
                        	   987: ;
00:C2EF 2055BE          	   988: READ3_A  jsr  GETEXPR   ; subscript
00:C2F2 20BBBD          	   989:          jsr  CHKRHB    ; check for "]"
00:C2F5 E64B            	   990:          inc  COUNT1    ; flag for reading into array element
00:C2F7 68              	   991:          pla            ; get back data type of array
00:C2F8 854A            	   992:          sta  DATTYP    ; save
00:C2FA 4C91C2          	   993:          jmp  READ11
                        	   994: ;
                        	   995: 
                        	   996: ;
                        	   997: ;
00:C2FD 2097BD          	   998: TWO_OP   JSR  CHKLHP
00:C300 2055BE          	   999:          JSR  GETEXPR
00:C303 208EBE          	  1000: ONE_OP2  JSR  GET_ITEM
00:C306 209EBD          	  1001: ONE_OP   JSR  CHKRHP
00:C309 68              	  1002:          PLA
00:C30A 4C61CA          	  1003:          JMP  GENNOP
                        	  1004: 
                        	  1005: 
                        	  1006: 
00:C30D 4C61CA          	  1007: GENNOP2  JMP  GENNOP
                        	  1008: ;
                        	  1009: 
00:C310 48              	  1010: WAIT_1   PHA
00:C311 2097BD          	  1011:          JSR  CHKLHP
00:C314 2055BE          	  1012:          JSR  GETEXPR
00:C317 4C06C3          	  1013:          JMP  ONE_OP
                        	  1014: ;
                        	  1015: ; MEM
                        	  1016: ;
00:C31A A900            	  1017: MEM      LDA  #0        ; integer
00:C31C 48              	  1018:          PHA
00:C31D F003            	  1019:          BEQ  MEM2
00:C31F A901            	  1020: MEMC     LDA  #1        ; character
00:C321 48              	  1021:          PHA
00:C322 20A8BD          	  1022: MEM2     JSR  GETSUB
00:C325 A941            	  1023:          LDA  #TOKEN_ASSIGN
00:C327 A20D            	  1024:          LDX  #13     ; ERROR: := expected
00:C329 20A1D2          	  1025:          JSR  CHKTKN
00:C32C 2055BE          	  1026:          JSR  GETEXPR
00:C32F 68              	  1027:          PLA
00:C330 18              	  1028:          CLC
00:C331 6934            	  1029:          ADC  #PCODE_STA     ; Store integer absolute address (or PCODE_STAC if A == 1)
00:C333 D0D8            	  1030:          BNE  GENNOP2
                        	  1031: ;
                        	  1032: ; CALL ABSOLUTE ADDRESS
                        	  1033: ;
00:C335 2097BD          	  1034: CALLSB   JSR  CHKLHP
00:C338 2055BE          	  1035:          JSR  GETEXPR
00:C33B 209EBD          	  1036:          JSR  CHKRHP
00:C33E A92B            	  1037:          LDA  #PCODE_CLA    ; Call absolute address
00:C340 D0CB            	  1038:          BNE  GENNOP2
                        	  1039: ;
                        	  1040: ; FUNCTION OR PROCEDURE CALL
                        	  1041: ;
00:C342 A900            	  1042: FNCPRC   LDA  #0
00:C344 854B            	  1043:          STA  COUNT1      ; number of arguments
00:C346 A006            	  1044:          LDY  #SYMARG
00:C348 B140            	  1045:          LDA  (SYMITM),Y
00:C34A F033            	  1046:          BEQ  FNC1
00:C34C 2097BD          	  1047:          JSR  CHKLHP
00:C34F A54B            	  1048: FNC2     LDA  COUNT1    ; save on stack in case the expression calls functions
00:C351 48              	  1049:          PHA
00:C352 2001BE          	  1050:          JSR  SYMWRK
00:C355 204395          	  1051:          JSR  PSHWRK
00:C358 2055BE          	  1052:          JSR  GETEXPR
00:C35B 205695          	  1053:          JSR  PULWRK
00:C35E 200CBE          	  1054:          JSR  WRKSYM
00:C361 68              	  1055:          PLA            ; get number of arguments back
00:C362 854B            	  1056:          STA  COUNT1
00:C364 E64B            	  1057:          INC  COUNT1    ; add 1 for the one we just processed
00:C366 A593            	  1058:          LDA  token_type
00:C368 C92C            	  1059:          CMP  #','
00:C36A F0E3            	  1060:          BEQ  FNC2
00:C36C A54B            	  1061:          LDA  COUNT1
00:C36E A006            	  1062:          LDY  #SYMARG
00:C370 D140            	  1063:          CMP  (SYMITM),Y   ; check we got the right number of arguments
00:C372 F005            	  1064:          BEQ  FNC3
00:C374 A223            	  1065:          LDX  #35     ; ERROR: Parameters mismatched
00:C376 4C4F9A          	  1066:          jmp  ERROR
00:C379 209EBD          	  1067: FNC3     JSR  CHKRHP
00:C37C 4C82C3          	  1068:          JMP  FNC5
00:C37F 203DD2          	  1069: FNC1     JSR  pas_get_token
00:C382 20C5BD          	  1070: FNC5     JSR  GET_LEV
00:C385 202ABE          	  1071:          JSR  GET_OFF
00:C388 A008            	  1072:          LDY  #SYMDAT
00:C38A B140            	  1073:          LDA  (SYMITM),Y
00:C38C D011            	  1074:          BNE  FNC5A
00:C38E A529            	  1075:          LDA  OFFSET
00:C390 38              	  1076:          SEC
00:C391 E523            	  1077:          SBC  PCODE         ; calculate relative procedure address
00:C393 8529            	  1078:          STA  OFFSET
00:C395 A52A            	  1079:          LDA  OFFSET+1
00:C397 E524            	  1080:          SBC  PCODE+1
00:C399 852A            	  1081:          STA  OFFSET+1
00:C39B A927            	  1082:          LDA  #PCODE_CLL         ; Relative procedure/function call
00:C39D D002            	  1083:          BNE  FNC5B
00:C39F A938            	  1084: FNC5A    LDA  #PCODE_ABSCLL      ; Absolute procedure/function call
00:C3A1 207ACA          	  1085: FNC5B    JSR  GENADR
00:C3A4 A54B            	  1086:          LDA  COUNT1    ; number of arguments
00:C3A6 F01B            	  1087:          BEQ  FNC4
00:C3A8 A54B            	  1088:          LDA  COUNT1     ; TIMES 3
00:C3AA 0A              	  1089:          ASL             ; multiply by two then add one more COUNT1
00:C3AB B017            	  1090:          BCS  FNC6
00:C3AD 654B            	  1091:          ADC  COUNT1
00:C3AF 854B            	  1092:          STA  COUNT1
00:C3B1 B011            	  1093:          BCS  FNC6
00:C3B3 A900            	  1094:          LDA  #0
00:C3B5 38              	  1095:          SEC
00:C3B6 E54B            	  1096:          SBC  COUNT1
00:C3B8 852B            	  1097:          STA  OPND
00:C3BA A9FF            	  1098:          LDA  #$FF
00:C3BC 852C            	  1099:          STA  OPND+1      ;  calculate: 0 - (number_of_arguments * 3)
00:C3BE A93B            	  1100:          LDA  #PCODE_INT     ; Increment stack pointer (allow for arguments)
00:C3C0 20EACA          	  1101:          JSR  GENJMP
00:C3C3 60              	  1102: FNC4     RTS
00:C3C4 A20F            	  1103: FNC6     LDX  #15       ; ERROR: compiler limits exceeded
00:C3C6 4C4F9A          	  1104:          jmp  ERROR
                        	  1105: ;
                        	  1106: ;
                        	  1107: ; IF
                        	  1108: ;
00:C3C9 2055BE          	  1109: IF       JSR  GETEXPR
00:C3CC A993            	  1110:          LDA  #TOKEN_THEN
00:C3CE A210            	  1111:          LDX  #16     ; ERROR: THEN expected
00:C3D0 20A1D2          	  1112:          JSR  CHKTKN
00:C3D3 203DD2          	  1113:          JSR  pas_get_token
00:C3D6 2017BE          	  1114:          JSR  PSHPCODE
00:C3D9 A93D            	  1115:          LDA  #PCODE_JMZ     ; JMZ      Jump if (sp) zero
00:C3DB 20E4CA          	  1116:          JSR  GENNJM
00:C3DE 2021C1          	  1117:          JSR  STMNT
00:C3E1 A593            	  1118:          LDA  token_type
00:C3E3 C994            	  1119:          CMP  #TOKEN_ELSE       ; ELSE
00:C3E5 F007            	  1120:          BEQ  IF1
00:C3E7 205695          	  1121: IF2      JSR  PULWRK
00:C3EA 2018CB          	  1122:          JSR  FIXAD
00:C3ED 60              	  1123:          RTS
00:C3EE 205695          	  1124: IF1      JSR  PULWRK     ; HERE FOR ELSE
00:C3F1 207CBE          	  1125:          JSR  WRK_WRKD
00:C3F4 2017BE          	  1126:          JSR  PSHPCODE
00:C3F7 20E2CA          	  1127:          JSR  GENNJP
00:C3FA 2071BE          	  1128:          JSR  WRKD_WRK
00:C3FD 2018CB          	  1129:          JSR  FIXAD
00:C400 203DD2          	  1130:          JSR  pas_get_token
00:C403 2021C1          	  1131:          JSR  STMNT
00:C406 4CE7C3          	  1132:          JMP  IF2
                        	  1133: ;
                        	  1134: ; BEGIN
                        	  1135: ;
00:C409 203DD2          	  1136: BEG      JSR  pas_get_token
00:C40C 2021C1          	  1137:          JSR  STMNT
00:C40F A593            	  1138:          LDA  token_type
00:C411 C93B            	  1139:          CMP  #';'
00:C413 F0F4            	  1140:          BEQ  BEG
00:C415 A989            	  1141:          LDA  #TOKEN_END       ; END
00:C417 A211            	  1142:          LDX  #17         ; ERROR: ; or END expected
00:C419 20A1D2          	  1143:          JSR  CHKTKN
00:C41C 4C3DD2          	  1144:          JMP  pas_get_token
                        	  1145: ;
                        	  1146: ; REPEAT
                        	  1147: ;
00:C41F 2017BE          	  1148: REPEAT   JSR  PSHPCODE
00:C422 203DD2          	  1149: REP1     JSR  pas_get_token
00:C425 2021C1          	  1150:          JSR  STMNT
00:C428 A593            	  1151:          LDA  token_type
00:C42A C93B            	  1152:          CMP  #';'
00:C42C F0F4            	  1153:          BEQ  REP1
00:C42E A999            	  1154:          LDA  #TOKEN_UNTIL
00:C430 A20A            	  1155:          LDX  #10           ; ERROR: ; expected
00:C432 20A1D2          	  1156:          JSR  CHKTKN
00:C435 2055BE          	  1157:          JSR  GETEXPR
00:C438 205695          	  1158:          JSR  PULWRK
00:C43B 2066BE          	  1159:          JSR  WRK_OPND
00:C43E A93D            	  1160:          LDA  #PCODE_JMZ         ; JMZ      Jump if (sp) zero
00:C440 4CD0CA          	  1161:          JMP  GENRJMP
                        	  1162: ;
                        	  1163: ; WHILE
                        	  1164: ;
00:C443 2017BE          	  1165: WHILE    JSR  PSHPCODE
00:C446 2055BE          	  1166:          JSR  GETEXPR
00:C449 2017BE          	  1167:          JSR  PSHPCODE
00:C44C A93D            	  1168:          LDA  #PCODE_JMZ       ; JMZ      Jump if (sp) zero
00:C44E 20E4CA          	  1169:          JSR  GENNJM
00:C451 A997            	  1170:          LDA  #TOKEN_DO
00:C453 A212            	  1171:          LDX  #18             ; ERROR: DO expected
00:C455 20A1D2          	  1172:          JSR  CHKTKN
00:C458 203DD2          	  1173:          JSR  pas_get_token
00:C45B 2021C1          	  1174:          JSR  STMNT
00:C45E 205695          	  1175:          JSR  PULWRK
00:C461 207CBE          	  1176:          JSR  WRK_WRKD
00:C464 205695          	  1177:          JSR  PULWRK
00:C467 2066BE          	  1178:          JSR  WRK_OPND
00:C46A A93C            	  1179:          LDA  #PCODE_JMP     ; JMP      Jump unconditionally
00:C46C 20D0CA          	  1180:          JSR  GENRJMP
00:C46F 2071BE          	  1181:          JSR  WRKD_WRK
00:C472 4C18CB          	  1182:          JMP  FIXAD
                        	  1183: ;
                        	  1184: ; CASE
                        	  1185: ;
00:C475 2055BE          	  1186: CASE     JSR  GETEXPR
00:C478 A985            	  1187:          LDA  #TOKEN_OF       ; OF
00:C47A A21A            	  1188:          LDX  #26         ; ERROR: "of " expected
00:C47C 20A1D2          	  1189:          JSR  CHKTKN
00:C47F A901            	  1190:          LDA  #1
00:C481 854B            	  1191:          STA  COUNT1
00:C483 A900            	  1192: CASE7    LDA  #0
00:C485 854C            	  1193:          STA  COUNT2
                        	  1194: CASE2    =  *
00:C487 A92A            	  1195:          LDA  #PCODE_MOV  ; make copy of selector:  MOV       Copy (sp) to (sp + 1)
00:C489 2061CA          	  1196:          JSR  GENNOP
00:C48C 2055BE          	  1197:          JSR  GETEXPR    ; next expression to compare
00:C48F A910            	  1198:          LDA  #PCODE_EQL       ;  EQL       Test (sp - 1) == (sp)
00:C491 2061CA          	  1199:          JSR  GENNOP
00:C494 A593            	  1200:          LDA  token_type
00:C496 C93A            	  1201:          CMP  #':'
00:C498 F014            	  1202:          BEQ  CASE1
00:C49A A92C            	  1203:          LDA  #','
00:C49C A205            	  1204:          LDX  #5      ; ERROR: , or : expected
00:C49E 20A1D2          	  1205:          JSR  CHKTKN
00:C4A1 2017BE          	  1206:          JSR  PSHPCODE
00:C4A4 A93E            	  1207:          LDA  #PCODE_JM1     ; JM1      Jump if (sp) not zero
00:C4A6 20E4CA          	  1208:          JSR  GENNJM
00:C4A9 E64C            	  1209:          INC  COUNT2
00:C4AB 4C87C4          	  1210:          JMP  CASE2
00:C4AE 205BBE          	  1211: CASE1    JSR  PCD_WRKD
00:C4B1 A93D            	  1212:          LDA  #PCODE_JMZ     ; JMZ      Jump if (sp) zero
00:C4B3 20E4CA          	  1213:          JSR  GENNJM
00:C4B6 A54C            	  1214:          LDA  COUNT2
00:C4B8 F00A            	  1215:          BEQ  CASE3
00:C4BA 205695          	  1216: CASE4    JSR  PULWRK
00:C4BD 2018CB          	  1217:          JSR  FIXAD
00:C4C0 C64C            	  1218:          DEC  COUNT2
00:C4C2 D0F6            	  1219:          BNE  CASE4
00:C4C4 2071BE          	  1220: CASE3    JSR  WRKD_WRK
00:C4C7 204395          	  1221:          JSR  PSHWRK
00:C4CA 203DD2          	  1222:          JSR  pas_get_token
00:C4CD A54B            	  1223:          LDA  COUNT1
00:C4CF 48              	  1224:          PHA
00:C4D0 2021C1          	  1225:          JSR  STMNT
00:C4D3 68              	  1226:          PLA
00:C4D4 854B            	  1227:          STA  COUNT1
00:C4D6 A593            	  1228:          LDA  token_type
00:C4D8 C994            	  1229:          CMP  #TOKEN_ELSE       ; ELSE
00:C4DA F01B            	  1230:          BEQ  CASE5
00:C4DC C93B            	  1231:          CMP  #';'
00:C4DE D035            	  1232:          BNE  CASE6
00:C4E0 205BBE          	  1233:          JSR  PCD_WRKD
00:C4E3 20E2CA          	  1234:          JSR  GENNJP
00:C4E6 205695          	  1235:          JSR  PULWRK
00:C4E9 2018CB          	  1236:          JSR  FIXAD
00:C4EC 2071BE          	  1237:          JSR  WRKD_WRK
00:C4EF 204395          	  1238:          JSR  PSHWRK
00:C4F2 E64B            	  1239:          INC  COUNT1
00:C4F4 4C83C4          	  1240:          JMP  CASE7
00:C4F7 205BBE          	  1241: CASE5    JSR  PCD_WRKD
00:C4FA 20E2CA          	  1242:          JSR  GENNJP
00:C4FD 205695          	  1243:          JSR  PULWRK
00:C500 2018CB          	  1244:          JSR  FIXAD
00:C503 2071BE          	  1245:          JSR  WRKD_WRK
00:C506 204395          	  1246:          JSR  PSHWRK
00:C509 203DD2          	  1247:          JSR  pas_get_token
00:C50C A54B            	  1248:          LDA  COUNT1
00:C50E 48              	  1249:          PHA
00:C50F 2021C1          	  1250:          JSR  STMNT
00:C512 68              	  1251:          PLA
00:C513 854B            	  1252:          STA  COUNT1
00:C515 A989            	  1253: CASE6    LDA  #TOKEN_END       ; END
00:C517 A211            	  1254:          LDX  #17         ; ERROR: ; or END expected
00:C519 20A1D2          	  1255:          JSR  CHKTKN
00:C51C A54B            	  1256:          LDA  COUNT1
00:C51E F00A            	  1257:          BEQ  CASE8
00:C520 205695          	  1258: CASE9    JSR  PULWRK
00:C523 2018CB          	  1259:          JSR  FIXAD
00:C526 C64B            	  1260:          DEC  COUNT1
00:C528 D0F6            	  1261:          BNE  CASE9
00:C52A 20F6C5          	  1262: CASE8    JSR  FOR6
00:C52D 4C3DD2          	  1263:          JMP  pas_get_token
                        	  1264: ;
                        	  1265: ; FOR
                        	  1266: ;
00:C530 A949            	  1267: FOR      LDA  #TOKEN_IDENTIFIER
00:C532 A204            	  1268:          LDX  #4      ; ERROR:  Identifier expected
00:C534 2091D2          	  1269:          JSR  GETCHK
00:C537 202BBD          	  1270:          JSR  LOOKUP
00:C53A C956            	  1271: FOR1     CMP  #SYMBOL_VARIABLE
00:C53C F009            	  1272:          BEQ  FOR2
00:C53E C959            	  1273:          CMP  #SYMBOL_FUNCTION_RETURN
00:C540 F005            	  1274:          BEQ  FOR2
00:C542 A20C            	  1275:          LDX  #12   ; ERROR: Illegal Identifier
00:C544 4C4F9A          	  1276:          jmp  ERROR
00:C547 2095C1          	  1277: FOR2     JSR  ASSVAR
00:C54A 2001BE          	  1278:          JSR  SYMWRK
00:C54D A900            	  1279:          LDA  #0
00:C54F 854B            	  1280:          STA  COUNT1
00:C551 A593            	  1281:          LDA  token_type
00:C553 C99B            	  1282:          CMP  #TOKEN_TO       ; TO
00:C555 F009            	  1283:          BEQ  FOR3
00:C557 A99C            	  1284:          LDA  #TOKEN_DOWNTO       ; DOWNTO
00:C559 A21C            	  1285:          LDX  #28       ; ERROR: TO or DOWNTO expected
00:C55B 20A1D2          	  1286:          JSR  CHKTKN
00:C55E C64B            	  1287:          DEC  COUNT1
00:C560 A54B            	  1288: FOR3     LDA  COUNT1
00:C562 48              	  1289:          PHA
00:C563 204395          	  1290:          JSR  PSHWRK
00:C566 2055BE          	  1291:          JSR  GETEXPR
00:C569 205695          	  1292:          JSR  PULWRK
00:C56C 200CBE          	  1293:          JSR  WRKSYM
00:C56F 68              	  1294:          PLA
00:C570 854B            	  1295:          STA  COUNT1
00:C572 2017BE          	  1296:          JSR  PSHPCODE
00:C575 A92A            	  1297:          LDA  #PCODE_MOV     ; MOV      Copy (sp) to (sp + 1)
00:C577 2061CA          	  1298:          JSR  GENNOP
00:C57A 20C5BD          	  1299:          JSR  GET_LEV
00:C57D 202ABE          	  1300:          JSR  GET_OFF
00:C580 20CFBD          	  1301:          JSR  GET_DAT
00:C583 18              	  1302:          CLC
00:C584 692C            	  1303:          ADC  #PCODE_LOD  ; Load integer onto stack or PCODE_LODC if a char
00:C586 207ACA          	  1304:          JSR  GENADR
00:C589 A916            	  1305:          LDA  #PCODE_GEQ        ; UP (GEQ): GEQ       Test (sp - 1) >= (sp)
00:C58B A64B            	  1306:          LDX  COUNT1
00:C58D F002            	  1307:          BEQ  FOR4
00:C58F A919            	  1308:          LDA  #PCODE_LEQ        ; DOWN (LEQ): LEQ       Test (sp - 1) <= (sp)
00:C591 2061CA          	  1309: FOR4     JSR  GENNOP
00:C594 2017BE          	  1310:          JSR  PSHPCODE
00:C597 A93D            	  1311:          LDA  #PCODE_JMZ       ;  JMZ       Jump if (sp) zero
00:C599 20E4CA          	  1312:          JSR  GENNJM
00:C59C A54B            	  1313:          LDA  COUNT1
00:C59E 48              	  1314:          PHA
00:C59F 2001BE          	  1315:          JSR  SYMWRK
00:C5A2 204395          	  1316:          JSR  PSHWRK
00:C5A5 A997            	  1317:          LDA  #TOKEN_DO
00:C5A7 A212            	  1318:          LDX  #18       ; ERROR: DO expected
00:C5A9 20A1D2          	  1319:          JSR  CHKTKN
00:C5AC 203DD2          	  1320:          JSR  pas_get_token
00:C5AF 2021C1          	  1321:          JSR  STMNT
00:C5B2 205695          	  1322:          JSR  PULWRK
00:C5B5 200CBE          	  1323:          JSR  WRKSYM
00:C5B8 20C5BD          	  1324:          JSR  GET_LEV
00:C5BB 20CFBD          	  1325:          JSR  GET_DAT
00:C5BE 202ABE          	  1326:          JSR  GET_OFF
00:C5C1 A54A            	  1327:          LDA  DATTYP
00:C5C3 18              	  1328:          CLC
00:C5C4 692C            	  1329:          ADC  #PCODE_LOD       ; LOD      Load integer onto stack
00:C5C6 207ACA          	  1330:          JSR  GENADR
00:C5C9 68              	  1331:          PLA
00:C5CA 854B            	  1332:          STA  COUNT1
00:C5CC A926            	  1333:          LDA  #PCODE_INC     ; INC      Increment (sp) by 1
00:C5CE A64B            	  1334:          LDX  COUNT1
00:C5D0 F002            	  1335:          BEQ  FOR5
00:C5D2 A928            	  1336:          LDA  #PCODE_DEC        ; DEC       Decrement (sp) by 1
00:C5D4 2061CA          	  1337: FOR5     JSR  GENNOP
00:C5D7 A932            	  1338:          LDA  #PCODE_STO       ; STO      Store integer
00:C5D9 18              	  1339:          CLC
00:C5DA 654A            	  1340:          ADC  DATTYP          ; may become PCODE_STOC if a char
00:C5DC 207ACA          	  1341:          JSR  GENADR
00:C5DF 205695          	  1342:          JSR  PULWRK
00:C5E2 207CBE          	  1343:          JSR  WRK_WRKD
00:C5E5 205695          	  1344:          JSR  PULWRK
00:C5E8 2066BE          	  1345:          JSR  WRK_OPND
00:C5EB A93C            	  1346:          LDA  #PCODE_JMP       ; JMP      Jump unconditionally
00:C5ED 20D0CA          	  1347:          JSR  GENRJMP
00:C5F0 2071BE          	  1348:          JSR  WRKD_WRK
00:C5F3 2018CB          	  1349:          JSR  FIXAD
00:C5F6 A9FF            	  1350: FOR6     LDA  #$FF
00:C5F8 852C            	  1351:          STA  OPND+1
00:C5FA A9FD            	  1352:          LDA  #$FD
00:C5FC 852B            	  1353:          STA  OPND
00:C5FE A93B            	  1354:          LDA  #PCODE_INT       ;  INT       Increment stack pointer
00:C600 4CEACA          	  1355:          JMP  GENJMP
                        	  1356: 
                        	  1357: 
                        	  1358: ;***********************************************
                        	  1359: ; MORE OF THE COMPILER (PROCESSING A 'BLOCK')
                        	  1360: ;***********************************************
                        	  1361: 
                        	  1362: CHKGET   =  *
00:C603 20A1D2          	  1363:          JSR  CHKTKN
00:C606 4C3DD2          	  1364:          JMP  pas_get_token
                        	  1365: ;
                        	  1366: ;  copy WORK to token_value
                        	  1367: ;
                        	  1368: WRK_VAL  =  *
00:C609 48              	  1369:          PHA
00:C60A A537            	  1370:          LDA  WORK
00:C60C 8594            	  1371:          STA  token_value
00:C60E A538            	  1372:          LDA  WORK+1
00:C610 8595            	  1373:          STA  token_value+1
00:C612 68              	  1374:          PLA
00:C613 60              	  1375:          RTS
                        	  1376: ;
                        	  1377: ;  copy VALUE to WORK
                        	  1378: ;
                        	  1379: VAL_WRK  =  *
00:C614 48              	  1380:          PHA
00:C615 A594            	  1381:          LDA  token_value
00:C617 8537            	  1382:          STA  WORK
00:C619 A595            	  1383:          LDA  token_value+1
00:C61B 8538            	  1384:          STA  WORK+1
00:C61D 68              	  1385:          PLA
00:C61E 60              	  1386:          RTS
                        	  1387: ;
                        	  1388: ;  copy ENDSYM to WORK
                        	  1389: ;
                        	  1390: END_WRK  =  *
00:C61F 48              	  1391:          PHA
00:C620 A531            	  1392:          LDA  ENDSYM
00:C622 8537            	  1393:          STA  WORK
00:C624 A532            	  1394:          LDA  ENDSYM+1
00:C626 8538            	  1395:          STA  WORK+1
00:C628 68              	  1396:          PLA
00:C629 60              	  1397:          RTS
                        	  1398: ;
                        	  1399: ;***********************************************
                        	  1400: ;
                        	  1401: ;
                        	  1402: ; BLOCK
                        	  1403: ;
00:C62A 82              	  1404: BLCKT1   DFB  TOKEN_CONST
00:C62B 81C6            	  1405:          word BLKCNS
00:C62D 83              	  1406: BLCKT2   DFB  TOKEN_VAR
00:C62E 98C6            	  1407:          word BLKVAR
00:C630 86              	  1408: BLCKT3   DFB  TOKEN_PROCEDURE
00:C631 D5C7            	  1409:          word BLKPRC
00:C633 87              	  1410:          DFB  TOKEN_FUNCTION
00:C634 F5C7            	  1411:          word BLKFNC
00:C636 88              	  1412:          DFB  TOKEN_BEGIN
00:C637 BDC8            	  1413:          word BLKBEG
00:C639 00              	  1414:          DFB  0
                        	  1415: ;
                        	  1416: ;
00:C63A 20BDBE          	  1417: BLOCK    JSR  CHK_STAK
00:C63D A900            	  1418:          LDA  #0
00:C63F 8521            	  1419:          STA  FRAME+1
00:C641 A906            	  1420:          LDA  #6
00:C643 8520            	  1421:          STA  FRAME
00:C645 A539            	  1422:          LDA  PRCITM
00:C647 8537            	  1423:          STA  WORK
00:C649 A63A            	  1424:          LDX  PRCITM+1
00:C64B 8638            	  1425:          STX  WORK+1
00:C64D 053A            	  1426:          ORA  PRCITM+1
00:C64F F014            	  1427:          BEQ  BLK1
                        	  1428: 
                        	  1429: ;
00:C651 A004            	  1430: BLK1A    LDY  #SYMDSP
00:C653 A523            	  1431:          LDA  PCODE
00:C655 9137            	  1432:          STA  (WORK),Y
00:C657 C8              	  1433:          INY
00:C658 A524            	  1434:          LDA  PCODE+1
00:C65A 9137            	  1435:          STA  (WORK),Y
00:C65C A900            	  1436:          LDA  #0
00:C65E A008            	  1437:          LDY  #SYMDAT
00:C660 9137            	  1438:          STA  (WORK),Y   ; FLAG RELATIVE PROCEDURE
00:C662 4C6DC6          	  1439:          JMP  BLK2
00:C665 A523            	  1440: BLK1     LDA  PCODE
00:C667 8537            	  1441:          STA  WORK
00:C669 A524            	  1442:          LDA  PCODE+1
00:C66B 8538            	  1443:          STA  WORK+1
00:C66D 204395          	  1444: BLK2     JSR  PSHWRK
00:C670 20E2CA          	  1445:          JSR  GENNJP
00:C673 A22A            	  1446:          LDX  #<BLCKT1
00:C675 A0C6            	  1447:          LDY  #>BLCKT1
00:C677 A593            	  1448: BLK4     LDA  token_type
00:C679 207692          	  1449:          JSR  TKNJMP
00:C67C A219            	  1450:          LDX  #25       ; ERROR: BEGIN expected
00:C67E 4C4F9A          	  1451:          jmp  ERROR
                        	  1452: ;
                        	  1453: ;
                        	  1454: ; CONSTANT
                        	  1455: ;
00:C681 203DD2          	  1456: BLKCNS   JSR  pas_get_token
00:C684 20D6BD          	  1457: BLKCN1   JSR  CONDEC
00:C687 A93B            	  1458:          LDA  #';'
00:C689 A20A            	  1459:          LDX  #10       ; ERROR: ; expected
00:C68B 2003C6          	  1460:          JSR  CHKGET
00:C68E A22D            	  1461:          LDX  #<BLCKT2
00:C690 A0C6            	  1462:          LDY  #>BLCKT2
00:C692 207692          	  1463:          JSR  TKNJMP
00:C695 4C84C6          	  1464:          JMP  BLKCN1
                        	  1465: ;
                        	  1466: ; VARIABLE
                        	  1467: ;
00:C698 A900            	  1468: BLKVAR   LDA  #0
00:C69A 854B            	  1469:          STA  COUNT1
00:C69C 203DD2          	  1470: BLKVR1   JSR  pas_get_token
00:C69F 20EFBE          	  1471: BLKVR6   JSR  VARDEC    ; check we have an identifier, add it to the symbol table, get another token
00:C6A2 E64B            	  1472:          INC  COUNT1    ; how many variables in this declaration
00:C6A4 1003            	  1473:          BPL  BLKVR7
00:C6A6 4C16C7          	  1474:          JMP  BLKV13     ; ERROR  - compiler limits exceeded (more than 127 variables?)
00:C6A9 A593            	  1475: BLKVR7   LDA  token_type
00:C6AB C92C            	  1476:          CMP  #','
00:C6AD F0ED            	  1477:          BEQ  BLKVR1    ; back for another
00:C6AF A93A            	  1478:          LDA  #':'
00:C6B1 A205            	  1479:          LDX  #5        ; ERROR: , or : expected
00:C6B3 2003C6          	  1480:          JSR  CHKGET
00:C6B6 C984            	  1481:          CMP  #TOKEN_ARRAY   ; ARRAY
00:C6B8 F043            	  1482:          BEQ  BLKVR2
00:C6BA C9FE            	  1483:          CMP  #TOKEN_INTEGER ; INTEGER
00:C6BC F00A            	  1484:          BEQ  BLKVR8
00:C6BE A9A1            	  1485:          LDA  #TOKEN_CHAR    ; CHAR
00:C6C0 A224            	  1486:          LDX  #36            ; ERROR: Data Type not recognised
00:C6C2 20A1D2          	  1487:          JSR  CHKTKN
00:C6C5 4CBDC7          	  1488:          JMP  BLKVR3
                        	  1489: 
                        	  1490: ;
                        	  1491: ;  integer variable
                        	  1492: ;
00:C6C8 2062C7          	  1493: BLKVR8   JSR  BLKVR9  ; subtract COUNT1 from FRAME, put WORK into VALUE, put ENDSYM into WORK
                        	  1494: BLKV10   = *
00:C6CB A008            	  1495:          LDY  #SYMDAT
00:C6CD A900            	  1496:          LDA  #0         ; INTEGER TYPE
00:C6CF 9137            	  1497:          STA  (WORK),Y
00:C6D1 A520            	  1498:          LDA  FRAME
00:C6D3 A004            	  1499:          LDY  #SYMDSP
00:C6D5 9137            	  1500:          STA  (WORK),Y
00:C6D7 C8              	  1501:          INY
00:C6D8 A521            	  1502:          LDA  FRAME+1
00:C6DA 9137            	  1503:          STA  (WORK),Y
00:C6DC 18              	  1504:          CLC
00:C6DD A520            	  1505:          LDA  FRAME
00:C6DF 6903            	  1506:          ADC  #3
00:C6E1 8520            	  1507:          STA  FRAME
00:C6E3 9002            	  1508:          BCC  BLKV10_A
00:C6E5 E621            	  1509:          INC  FRAME+1
                        	  1510: BLKV10_A =  *
00:C6E7 C64B            	  1511:          DEC  COUNT1
00:C6E9 D003            	  1512:          BNE  BLKV10_B
00:C6EB 4CBDC7          	  1513:          JMP  BLKVR3
                        	  1514: 
                        	  1515: BLKV10_B = *
                        	  1516: ;
                        	  1517: ;  more in the list, go to the previous symbol
                        	  1518: ;
00:C6EE A000            	  1519:          LDY  #SYMPRV
00:C6F0 B137            	  1520:          LDA  (WORK),Y
00:C6F2 AA              	  1521:          TAX
00:C6F3 C8              	  1522:          INY
00:C6F4 B137            	  1523:          LDA  (WORK),Y
00:C6F6 8538            	  1524:          STA  WORK+1
00:C6F8 8A              	  1525:          TXA
00:C6F9 8537            	  1526:          STA  WORK       ; PREVIOUS ITEM
00:C6FB 80CE            	  1527:          BRA  BLKV10
                        	  1528: 
                        	  1529: ;
                        	  1530: ; ARRAY [ N ] OF ...
                        	  1531: ;
00:C6FD 20B1BD          	  1532: BLKVR2   JSR  CHKLHB
00:C700 20C9BE          	  1533:          JSR  CONST     ; get how many are in the array
00:C703 A596            	  1534:          LDA  token_value+2   ; can't be more than 65536
00:C705 D00F            	  1535:          BNE  BLKV13
00:C707 A594            	  1536:          LDA  token_value     ; add 1 to the count since array [3] of char means 4 elements
00:C709 18              	  1537:          CLC
00:C70A 6901            	  1538:          ADC  #1
00:C70C 8594            	  1539:          STA  token_value
00:C70E A595            	  1540:          LDA  token_value+1
00:C710 3004            	  1541:          BMI  BLKV13
00:C712 6900            	  1542:          ADC  #0
00:C714 1005            	  1543:          BPL  BLKVR4
00:C716 A20F            	  1544: BLKV13   LDX  #15       ; ERROR: compiler limits exceeded
00:C718 4C4F9A          	  1545:          jmp  ERROR
00:C71B 8595            	  1546: BLKVR4   STA  token_value+1
00:C71D 2014C6          	  1547:          JSR  VAL_WRK   ; put the value (array count) in WORK
00:C720 203DD2          	  1548:          JSR  pas_get_token
00:C723 20BBBD          	  1549:          JSR  CHKRHB
00:C726 A901            	  1550:          LDA  #1        ; char
00:C728 854A            	  1551:          STA  DATTYP
00:C72A A985            	  1552:          LDA  #TOKEN_OF  ; OF
00:C72C A21A            	  1553:          LDX  #26        ; ERROR: "of " expected
00:C72E 2003C6          	  1554:          JSR  CHKGET
00:C731 C9FE            	  1555:          CMP  #TOKEN_INTEGER  ; INTEGER
00:C733 D020            	  1556:          BNE  BLKV11
00:C735 C64A            	  1557:          DEC  DATTYP    ; DATTYP of 0 is integer, and 1 is char
00:C737 2009C6          	  1558:          JSR  WRK_VAL   ; get the array count back into token_value
                        	  1559: ;
                        	  1560: ; MULTIPLY token_value BY 3
                        	  1561: ;
00:C73A A594            	  1562:          LDA  token_value
00:C73C A695            	  1563:          LDX  token_value+1
00:C73E 0694            	  1564:          ASL  token_value
00:C740 2695            	  1565:          ROL  token_value+1
00:C742 B0D2            	  1566:          BCS  BLKV13
00:C744 6594            	  1567:          ADC  token_value
00:C746 8594            	  1568:          STA  token_value
00:C748 8A              	  1569:          TXA
00:C749 6595            	  1570:          ADC  token_value+1
00:C74B B0C9            	  1571:          BCS  BLKV13
00:C74D 8595            	  1572:          STA  token_value+1
00:C74F 2014C6          	  1573:          JSR  VAL_WRK     ; put the array count (times 3) back into WORK
00:C752 4C5CC7          	  1574:          JMP  BLKV12
                        	  1575:  ;
                        	  1576:  ;  here for array of char
                        	  1577:  ;
00:C755 A9A1            	  1578: BLKV11   LDA  #TOKEN_CHAR       ; CHAR
00:C757 A224            	  1579:          LDX  #36           ; ERROR: Data Type not recognised
00:C759 20A1D2          	  1580:          JSR  CHKTKN
00:C75C 2062C7          	  1581: BLKV12   JSR  BLKVR9        ; we are COUNT1 frames back
00:C75F 4C7BC7          	  1582:          JMP  BLKVR5
                        	  1583: 
                        	  1584: BLKVR9   =  *
00:C762 A520            	  1585:          LDA  FRAME         ; subtract COUNT1 (the variable position) from the frame number
00:C764 38              	  1586:          SEC
00:C765 E54B            	  1587:          SBC  COUNT1
00:C767 8520            	  1588:          STA  FRAME
00:C769 A521            	  1589:          LDA  FRAME+1
00:C76B E900            	  1590:          SBC  #0
00:C76D 8521            	  1591:          STA  FRAME+1
00:C76F 2009C6          	  1592:          JSR  WRK_VAL     ; copy WORK to VALUE (array count, possibly multiplied by 3)
00:C772 A531            	  1593:          LDA  ENDSYM      ; end of symbol table into WORK
00:C774 8537            	  1594:          STA  WORK
00:C776 A532            	  1595:          LDA  ENDSYM+1
00:C778 8538            	  1596:          STA  WORK+1
00:C77A 60              	  1597:          RTS
                        	  1598: 
                        	  1599: ;
                        	  1600: ;  we should be here with ENDSYM in WORK (for walking back through the symbol table for all the variables we just decla
                        	  1601: ;  COUNT1 will be the number of symbols we have to fix up
                        	  1602: ;
                        	  1603: BLKVR5   = *
00:C77B A003            	  1604:          ldy  #SYMTYP
00:C77D A941            	  1605:          lda  #SYMBOL_ARRAY
00:C77F 9137            	  1606:          sta  (WORK),Y    ; make symbol type array
00:C781 A004            	  1607:          ldy  #SYMDSP
00:C783 A520            	  1608:          lda  FRAME       ; FRAME is the displacement
00:C785 9137            	  1609:          sta  (WORK),Y
00:C787 C8              	  1610:          iny
00:C788 A521            	  1611:          lda  FRAME+1
00:C78A 9137            	  1612:          sta  (WORK),Y
00:C78C A594            	  1613:          lda  token_value       ; array count (multiplied by 3 in the case of integers)
00:C78E 18              	  1614:          clc
00:C78F 6520            	  1615:          adc  FRAME       ; add to the stack frame address
00:C791 8520            	  1616:          sta  FRAME
00:C793 A595            	  1617:          lda  token_value+1
00:C795 6521            	  1618:          adc  FRAME+1
00:C797 8521            	  1619:          sta  FRAME+1
00:C799 A008            	  1620:          ldy  #SYMDAT
00:C79B A54A            	  1621:          lda  DATTYP       ; save the data type in the symbol
00:C79D 9137            	  1622:          sta  (WORK),Y
00:C79F A006            	  1623:          ldy  #SYMSUB
00:C7A1 A594            	  1624:          lda  token_value        ; max subscript + 1
00:C7A3 9137            	  1625:          sta  (WORK),Y
00:C7A5 A595            	  1626:          lda  token_value+1
00:C7A7 C8              	  1627:          iny
00:C7A8 9137            	  1628:          sta  (WORK),Y
00:C7AA C64B            	  1629:          dec  COUNT1
00:C7AC F00F            	  1630:          beq  BLKVR3
                        	  1631: ;
                        	  1632: ;  onto the previous symbol
                        	  1633: ;
00:C7AE A000            	  1634:          ldy  #SYMPRV
00:C7B0 B137            	  1635:          lda  (WORK),Y
00:C7B2 AA              	  1636:          tax
00:C7B3 C8              	  1637:          iny
00:C7B4 B137            	  1638:          lda  (WORK),Y
00:C7B6 8538            	  1639:          sta  WORK+1
00:C7B8 8A              	  1640:          txa
00:C7B9 8537            	  1641:          sta  WORK       ; PREVIOUS ITEM
00:C7BB 80BE            	  1642:          bra  BLKVR5
                        	  1643: ;
                        	  1644: ;  here at end of variable declaration (after INTEGER / CHAR)
                        	  1645: ;
00:C7BD A93B            	  1646: BLKVR3   LDA  #';'
00:C7BF A20A            	  1647:          LDX  #10       ; ERROR: ; expected
00:C7C1 2091D2          	  1648:          JSR  GETCHK
00:C7C4 203DD2          	  1649:          JSR  pas_get_token
00:C7C7 A230            	  1650:          LDX  #<BLCKT3  ; now look for procedure / function / begin
00:C7C9 A0C6            	  1651:          LDY  #>BLCKT3
00:C7CB 207692          	  1652:          JSR  TKNJMP    ; if not there, look for another variable declaration
00:C7CE A900            	  1653:          LDA  #0        ; zero variables in this list so far
00:C7D0 854B            	  1654:          STA  COUNT1
00:C7D2 4C9FC6          	  1655:          JMP  BLKVR6
                        	  1656: ;
                        	  1657: ; PROCEDURE DECLARATION
                        	  1658: ;
00:C7D5 A949            	  1659: BLKPRC   LDA  #'I'
00:C7D7 A204            	  1660:          LDX  #4         ; ERROR: Identifier expected
00:C7D9 2091D2          	  1661:          JSR  GETCHK
00:C7DC A900            	  1662:          LDA  #0
00:C7DE 854B            	  1663:          STA  COUNT1    ; no function return value
00:C7E0 2036BD          	  1664:          JSR  CHKDUP
00:C7E3 A950            	  1665:          LDA  #SYMBOL_PROCEDURE
00:C7E5 208FBC          	  1666:          JSR  ADDSYM
00:C7E8 E622            	  1667:          INC  LEVEL
00:C7EA A540            	  1668:          LDA  SYMITM
00:C7EC 8539            	  1669:          STA  PRCITM    ; PRCITM is the symbol of the procedure/function
00:C7EE A541            	  1670:          LDA  SYMITM+1
00:C7F0 853A            	  1671:          STA  PRCITM+1
00:C7F2 4C17C8          	  1672:          JMP  BLKPR1
                        	  1673: ;
                        	  1674: ; FUNCTION DECLARATION
                        	  1675: ;
00:C7F5 A949            	  1676: BLKFNC   LDA  #TOKEN_IDENTIFIER
00:C7F7 A204            	  1677:          LDX  #4      ; ERROR: Identifier expected
00:C7F9 2091D2          	  1678:          JSR  GETCHK
00:C7FC 2036BD          	  1679:          JSR  CHKDUP
00:C7FF A946            	  1680:          LDA  #SYMBOL_FUNCTION
00:C801 208FBC          	  1681:          JSR  ADDSYM
00:C804 E622            	  1682:          INC  LEVEL
00:C806 A901            	  1683:          LDA  #1
00:C808 854B            	  1684:          STA  COUNT1    ; we have the function return as a symbol
00:C80A A540            	  1685:          LDA  SYMITM
00:C80C 8539            	  1686:          STA  PRCITM   ; PRCITM is the symbol of the procedure/function
00:C80E A541            	  1687:          LDA  SYMITM+1
00:C810 853A            	  1688:          STA  PRCITM+1
00:C812 A959            	  1689:          LDA  #SYMBOL_FUNCTION_RETURN ; for assigning the results to
00:C814 208FBC          	  1690:          JSR  ADDSYM
                        	  1691: ;
                        	  1692: ; PROCEDURE AND FUNCTION COMMON CODE
                        	  1693: ;
00:C817 A54B            	  1694: BLKPR1   LDA  COUNT1
00:C819 854C            	  1695:          STA  COUNT2    ; remember if we had 0 or 1 extra symbols (function return)
00:C81B 201FC6          	  1696:          JSR  END_WRK
00:C81E 204395          	  1697:          JSR  PSHWRK
00:C821 A520            	  1698:          LDA  FRAME
00:C823 8537            	  1699:          STA  WORK
00:C825 A521            	  1700:          LDA  FRAME+1
00:C827 8538            	  1701:          STA  WORK+1
00:C829 204395          	  1702:          JSR  PSHWRK
00:C82C 203DD2          	  1703:          JSR  pas_get_token
00:C82F C928            	  1704:          CMP  #'('      ; opening bracket after procedure/function name?
00:C831 D016            	  1705:          BNE  BLKPR2
00:C833 203DD2          	  1706: BLKPR3   JSR  pas_get_token
00:C836 20EFBE          	  1707:          JSR  VARDEC
00:C839 E64B            	  1708:          INC  COUNT1    ; count arguments
00:C83B 1003            	  1709:          BPL  BLKPR6
00:C83D 4C16C7          	  1710:          JMP  BLKV13
00:C840 A593            	  1711: BLKPR6   LDA  token_type
00:C842 C92C            	  1712:          CMP  #','
00:C844 F0ED            	  1713:          BEQ  BLKPR3
00:C846 209EBD          	  1714:          JSR  CHKRHP
00:C849 A539            	  1715: BLKPR2   LDA  PRCITM      ; here after argument list, if any
00:C84B 8537            	  1716:          STA  WORK
00:C84D A53A            	  1717:          LDA  PRCITM+1
00:C84F 8538            	  1718:          STA  WORK+1
00:C851 A006            	  1719:          LDY  #SYMARG
00:C853 A54B            	  1720:          LDA  COUNT1
00:C855 38              	  1721:          SEC
00:C856 E54C            	  1722:          SBC  COUNT2      ; subtract 0 or 1 depending on if this is a function or not
00:C858 9137            	  1723:          STA  (WORK),Y    ; store the number of arguments to this procedure/function
00:C85A A93B            	  1724:          LDA  #';'
00:C85C A20A            	  1725:          LDX  #10         ; ERROR: ; expected
00:C85E 20A1D2          	  1726:          JSR  CHKTKN
00:C861 A54B            	  1727:          LDA  COUNT1
00:C863 F02C            	  1728:          BEQ  BLKPR4
00:C865 201FC6          	  1729:          JSR  END_WRK     ; ENDSYM -> WORK
00:C868 A2FD            	  1730:          LDX  #$FD        ; X = -3
                        	  1731: ; WORK starts off pointing to the procedure/function symbol
                        	  1732: BLKPR5   = *
00:C86A A008            	  1733:          LDY  #SYMDAT
00:C86C A900            	  1734:          LDA  #0
00:C86E 9137            	  1735:          STA  (WORK),Y    ; data type = integer
00:C870 A004            	  1736:          LDY  #SYMDSP
00:C872 8A              	  1737:          TXA
00:C873 9137            	  1738:          STA  (WORK),Y
00:C875 38              	  1739:          SEC
00:C876 E903            	  1740:          SBC  #3
00:C878 AA              	  1741:          TAX
00:C879 A9FF            	  1742:          LDA  #$FF
00:C87B C8              	  1743:          INY
00:C87C 9137            	  1744:          STA  (WORK),Y
00:C87E C64B            	  1745:          DEC  COUNT1
00:C880 F00F            	  1746:          beq  BLKPR4
                        	  1747: ;
                        	  1748: ;  back to previous symbol
                        	  1749: ;
00:C882 A000            	  1750:          LDY  #SYMPRV
00:C884 B137            	  1751:          LDA  (WORK),Y
00:C886 48              	  1752:          PHA
00:C887 C8              	  1753:          INY
00:C888 B137            	  1754:          LDA  (WORK),Y
00:C88A 8538            	  1755:          STA  WORK+1
00:C88C 68              	  1756:          PLA
00:C88D 8537            	  1757:          STA  WORK
00:C88F 80D9            	  1758:          bra  BLKPR5
00:C891 203DD2          	  1759: BLKPR4   JSR  pas_get_token
00:C894 203AC6          	  1760:          JSR  BLOCK
00:C897 C622            	  1761:          DEC  LEVEL
00:C899 205695          	  1762:          JSR  PULWRK
00:C89C A537            	  1763:          LDA  WORK
00:C89E 8520            	  1764:          STA  FRAME
00:C8A0 A538            	  1765:          LDA  WORK+1
00:C8A2 8521            	  1766:          STA  FRAME+1
00:C8A4 205695          	  1767:          JSR  PULWRK
00:C8A7 A537            	  1768:          LDA  WORK
00:C8A9 8531            	  1769:          STA  ENDSYM
00:C8AB A538            	  1770:          LDA  WORK+1
00:C8AD 8532            	  1771:          STA  ENDSYM+1
00:C8AF A93B            	  1772:          LDA  #';'
00:C8B1 A20A            	  1773:          LDX  #10       ; ERROR: ; expected
00:C8B3 2003C6          	  1774:          JSR  CHKGET
00:C8B6 A230            	  1775:          LDX  #<BLCKT3
00:C8B8 A0C6            	  1776:          LDY  #>BLCKT3
00:C8BA 4C77C6          	  1777:          JMP  BLK4
                        	  1778: ;
                        	  1779: ; BEGIN (COMPOUND STATEMENT)
                        	  1780: ;
00:C8BD 203DD2          	  1781: BLKBEG   JSR  pas_get_token
00:C8C0 205695          	  1782:          JSR  PULWRK
00:C8C3 A522            	  1783:          LDA  LEVEL
00:C8C5 D006            	  1784:          BNE  BLKB1
00:C8C7 2018CB          	  1785: BLKB3    JSR  FIXAD
00:C8CA 4CE9C8          	  1786:          JMP  BLKB2
00:C8CD 200CBE          	  1787: BLKB1    JSR  WRKSYM
00:C8D0 A004            	  1788:          LDY  #SYMDSP
00:C8D2 B140            	  1789:          LDA  (SYMITM),Y
00:C8D4 8537            	  1790:          STA  WORK
00:C8D6 C8              	  1791:          INY
00:C8D7 B140            	  1792:          LDA  (SYMITM),Y
00:C8D9 8538            	  1793:          STA  WORK+1
00:C8DB A004            	  1794:          LDY  #SYMDSP
00:C8DD A523            	  1795:          LDA  PCODE
00:C8DF 9140            	  1796:          STA  (SYMITM),Y
00:C8E1 A524            	  1797:          LDA  PCODE+1
00:C8E3 C8              	  1798:          INY
00:C8E4 9140            	  1799:          STA  (SYMITM),Y
00:C8E6 4CC7C8          	  1800:          JMP  BLKB3
00:C8E9 A520            	  1801: BLKB2    LDA  FRAME
00:C8EB 852B            	  1802:          STA  OPND
00:C8ED A521            	  1803:          LDA  FRAME+1
00:C8EF 852C            	  1804:          STA  OPND+1
00:C8F1 A93B            	  1805:          LDA  #PCODE_INT         ; INT      Increment stack pointer
00:C8F3 20EACA          	  1806:          JSR  GENJMP
00:C8F6 2021C1          	  1807: BLKB5    JSR  STMNT
00:C8F9 A593            	  1808:          LDA  token_type
00:C8FB C93B            	  1809:          CMP  #';'
00:C8FD D006            	  1810:          BNE  BLKB4
00:C8FF 203DD2          	  1811:          JSR  pas_get_token
00:C902 4CF6C8          	  1812:          JMP  BLKB5
00:C905 A989            	  1813: BLKB4    LDA  #TOKEN_END       ; END
00:C907 A211            	  1814:          LDX  #17         ; ERROR: ; or END expected
00:C909 2003C6          	  1815:          JSR  CHKGET
00:C90C A929            	  1816:          LDA  #PCODE_RTN  ; OK - we are at the end of a block - this is a procedure/function return
00:C90E A622            	  1817:          LDX  LEVEL       ; OR - if we are at level 0, then that is the end of the program
00:C910 D002            	  1818:          BNE  BLKB6
00:C912 A911            	  1819:          LDA  #PCODE_FINISHD        ; Opcode: FINISHED  Stop run (end program)
                        	  1820: TEST1    =  *
00:C914 4C61CA          	  1821: BLKB6    JMP  GENNOP
                        	  1822: ;
                        	  1823: 
                        	  1824: 
                        	  1825: ;
                        	  1826: ;  Writing library functions is quite easy:
                        	  1827: ;
                        	  1828: ;   1. For each of the n arguments that they have (could be zero) do a PULTOP to get
                        	  1829: ;      that value from the runtime stack into REG. Or, PULTOP2 to get the value into REG2.
                        	  1830: ;      For two arguments you can do PULBOTH to get them into REG and REG2.
                        	  1831: ;   2. Do whatever the function/procedure is supposed to do with those arguments
                        	  1832: ;   3. If a procedure, you are finished: JMP MAIN
                        	  1833: ;      For a function, put the result into REG, and then JMP MAINP
                        	  1834: ;      - or - (equivalently): JSR PSHTOP, JMP MAIN
                        	  1835: ;
                        	  1836: ;  Note: PULTOP puts the value into REG and also: A, X and Y registers where A is the low-order
                        	  1837: ;        byte, X the middle byte, and Y the high-order byte.
                        	  1838: ;
                        	  1839: 
                        	  1840: ;                         Name           function or procedure   Args Execution address
                        	  1841: pascal_library_functions_table:
                        	  1842: ;
                        	  1843: ;    functions
                        	  1844: ;
                        	  1845:   makePasLibraryFunction "ABS",          SYMBOL_LIBRARY_FUNCTION,  1, EX_ABS
00:C917 414253          	     1M      asciiz   "ABS"
00:C91A 00
00:C91B 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:C91C 01              	     3M      dfb      1
00:C91D E9B3            	     4M      word     EX_ABS
                        	  1846:   makePasLibraryFunction "DIGITALREAD",  SYMBOL_LIBRARY_FUNCTION,  1, EX_DIGITALREAD
00:C91F 4449474954414C52	     1M      asciiz   "DIGITALREAD"
00:C927 454144
00:C92A 00
00:C92B 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:C92C 01              	     3M      dfb      1
00:C92D 63B8            	     4M      word     EX_DIGITALREAD
                        	  1847:   makePasLibraryFunction "GETKEY",       SYMBOL_LIBRARY_FUNCTION,  0, EX_GETKEY
00:C92F 4745544B4559    	     1M      asciiz   "GETKEY"
00:C935 00
00:C936 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:C937 00              	     3M      dfb      0
00:C938 A3B3            	     4M      word     EX_GETKEY
                        	  1848:   makePasLibraryFunction "RANDOM",       SYMBOL_LIBRARY_FUNCTION,  0, EX_RANDOM
00:C93A 52414E444F4D    	     1M      asciiz   "RANDOM"
00:C940 00
00:C941 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:C942 00              	     3M      dfb      0
00:C943 8BB8            	     4M      word     EX_RANDOM
                        	  1849:   makePasLibraryFunction "LATENCY",      SYMBOL_LIBRARY_FUNCTION,  0, EX_LATENCY
00:C945 4C4154454E4359  	     1M      asciiz   "LATENCY"
00:C94C 00
00:C94D 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:C94E 00              	     3M      dfb      0
00:C94F 9DB8            	     4M      word     EX_LATENCY
                        	  1850: ;
                        	  1851: ;      procedures
                        	  1852: ;
                        	  1853:   makePasLibraryFunction "ASSERT",       SYMBOL_LIBRARY_PROCEDURE, 1, EX_ASSERT
00:C951 415353455254    	     1M      asciiz   "ASSERT"
00:C957 00
00:C958 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C959 01              	     3M      dfb      1
00:C95A F0B8            	     4M      word     EX_ASSERT
                        	  1854:   makePasLibraryFunction "DELAY",        SYMBOL_LIBRARY_PROCEDURE, 1, EX_DELAY
00:C95C 44454C4159      	     1M      asciiz   "DELAY"
00:C961 00
00:C962 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C963 01              	     3M      dfb      1
00:C964 ACB8            	     4M      word     EX_DELAY
                        	  1855:   makePasLibraryFunction "DIGITALWRITE", SYMBOL_LIBRARY_PROCEDURE, 2, EX_DIGITALWRITE
00:C966 4449474954414C57	     1M      asciiz   "DIGITALWRITE"
00:C96E 52495445
00:C972 00
00:C973 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C974 02              	     3M      dfb      2
00:C975 DBB8            	     4M      word     EX_DIGITALWRITE
                        	  1856:   makePasLibraryFunction "LCDCLEAR",     SYMBOL_LIBRARY_PROCEDURE, 0, EX_LCDCLEAR
00:C977 4C4344434C454152	     1M      asciiz   "LCDCLEAR"
00:C97F 00
00:C980 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C981 00              	     3M      dfb      0
00:C982 D5B7            	     4M      word     EX_LCDCLEAR
                        	  1857:   makePasLibraryFunction "LCDHOME",      SYMBOL_LIBRARY_PROCEDURE, 0, EX_LCDHOME
00:C984 4C4344484F4D45  	     1M      asciiz   "LCDHOME"
00:C98B 00
00:C98C 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C98D 00              	     3M      dfb      0
00:C98E CFB7            	     4M      word     EX_LCDHOME
                        	  1858:   makePasLibraryFunction "LCDPOS",       SYMBOL_LIBRARY_PROCEDURE, 2, EX_LCDPOS
00:C990 4C4344504F53    	     1M      asciiz   "LCDPOS"
00:C996 00
00:C997 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C998 02              	     3M      dfb      2
00:C999 71B8            	     4M      word     EX_LCDPOS
                        	  1859:   makePasLibraryFunction "PINMODE",      SYMBOL_LIBRARY_PROCEDURE, 2, EX_PINMODE
00:C99B 50494E4D4F4445  	     1M      asciiz   "PINMODE"
00:C9A2 00
00:C9A3 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C9A4 02              	     3M      dfb      2
00:C9A5 CCB8            	     4M      word     EX_PINMODE
                        	  1860:   makePasLibraryFunction "RANDOMSEED",   SYMBOL_LIBRARY_PROCEDURE, 1, EX_RANDOMSEED
00:C9A7 52414E444F4D5345	     1M      asciiz   "RANDOMSEED"
00:C9AF 4544
00:C9B1 00
00:C9B2 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C9B3 01              	     3M      dfb      1
00:C9B4 BCB8            	     4M      word     EX_RANDOMSEED
00:C9B6 00              	  1861:   dfb 0   ; end of table
                        	  1862: 
                        	  1863: add_pascal_library_functions:
00:C9B7 A917            	  1864:   lda #<pascal_library_functions_table
00:C9B9 8500            	  1865:   sta REG
00:C9BB A9C9            	  1866:   lda #>pascal_library_functions_table
00:C9BD 8501            	  1867:   sta REG+1
                        	  1868: add_pascal_library_functions_loop:
00:C9BF A000            	  1869:   ldy #0
00:C9C1 B100            	  1870:   lda (REG),Y
00:C9C3 F04B            	  1871:   beq add_pascal_library_functions_done
00:C9C5 A500            	  1872:   lda REG
00:C9C7 8590            	  1873:   sta token_address
00:C9C9 A501            	  1874:   lda REG+1
00:C9CB 8591            	  1875:   sta token_address+1
00:C9CD 6492            	  1876:   stz token_length
                        	  1877: ;
                        	  1878: ;  find name length
                        	  1879: ;
                        	  1880: add_pascal_library_functions_name_loop
00:C9CF C8              	  1881:   iny
00:C9D0 E692            	  1882:   inc token_length
00:C9D2 B100            	  1883:   lda (REG),Y
00:C9D4 D0F9            	  1884:   bne add_pascal_library_functions_name_loop
00:C9D6 5A              	  1885:   phy
00:C9D7 A943            	  1886:   lda #SYMBOL_CONSTANT  ; add the symbol as a constant for now
00:C9D9 208FBC          	  1887:   jsr ADDSYM
00:C9DC 7A              	  1888:   ply
                        	  1889: 
00:C9DD C8              	  1890:   iny             ; get past the 0x00
00:C9DE B100            	  1891:   lda (REG),Y     ; get symbol type
00:C9E0 5A              	  1892:   phy
00:C9E1 A003            	  1893:   ldy #SYMTYP
00:C9E3 9140            	  1894:   sta (SYMITM),Y  ; change symbol type to be correct
00:C9E5 7A              	  1895:   ply
                        	  1896: 
00:C9E6 C8              	  1897:   iny             ; get next byte
00:C9E7 B100            	  1898:   lda (REG),Y     ; get number of arguments
00:C9E9 5A              	  1899:   phy
00:C9EA A006            	  1900:   ldy #SYMARG
00:C9EC 9140            	  1901:   sta (SYMITM),Y  ; save number of arguments
00:C9EE 7A              	  1902:   ply
                        	  1903: 
00:C9EF C8              	  1904:   iny             ; get next byte
00:C9F0 B100            	  1905:   lda (REG),Y     ; get function address low-byte
00:C9F2 5A              	  1906:   phy
00:C9F3 A004            	  1907:   ldy #SYMDSP
00:C9F5 9140            	  1908:   sta (SYMITM),Y  ; save function address low-byte
00:C9F7 7A              	  1909:   ply
                        	  1910: 
00:C9F8 C8              	  1911:   iny             ; get next byte
00:C9F9 B100            	  1912:   lda (REG),Y     ; get function address high-byte
00:C9FB 5A              	  1913:   phy
00:C9FC A005            	  1914:   ldy #SYMDSP+1
00:C9FE 9140            	  1915:   sta (SYMITM),Y  ; save function address high-byte
00:CA00 7A              	  1916:   ply
                        	  1917: 
00:CA01 C8              	  1918:   iny         ; get past that last byte
00:CA02 98              	  1919:   tya         ; move REG onto next entry
00:CA03 18              	  1920:   clc
00:CA04 6500            	  1921:   adc REG
00:CA06 8500            	  1922:   sta REG
00:CA08 A900            	  1923:   lda #0
00:CA0A 6501            	  1924:   adc REG+1
00:CA0C 8501            	  1925:   sta REG+1
00:CA0E 80AF            	  1926:   bra add_pascal_library_functions_loop
                        	  1927: 
                        	  1928: add_pascal_library_functions_done:
00:CA10 60              	  1929:   rts
                        	  1930: 
                        	  1931: 
                        	  1932: library_function_call:
                        	  1933: 
00:CA11 A900            	  1934:   lda  #0
00:CA13 854B            	  1935:   sta  COUNT1      ; number of arguments
00:CA15 A006            	  1936:   ldy  #SYMARG
00:CA17 B140            	  1937:   lda  (SYMITM),Y
00:CA19 F032            	  1938:   beq  library_function_call_1
                        	  1939: 
                        	  1940: ;
                        	  1941: ;  here if it has arguments - push them on the stack
                        	  1942: ;
                        	  1943: 
00:CA1B 2097BD          	  1944:   jsr  CHKLHP
                        	  1945: library_function_call_2
00:CA1E A54B            	  1946:   lda  COUNT1    ; save on stack in case the expression calls functions
00:CA20 48              	  1947:   pha
00:CA21 2001BE          	  1948:   jsr  SYMWRK
00:CA24 204395          	  1949:   jsr  PSHWRK
00:CA27 2055BE          	  1950:   jsr  GETEXPR
00:CA2A 205695          	  1951:   jsr  PULWRK
00:CA2D 200CBE          	  1952:   jsr  WRKSYM
00:CA30 68              	  1953:   pla            ; get number of arguments back
00:CA31 854B            	  1954:   sta  COUNT1
00:CA33 E64B            	  1955:   inc  COUNT1    ; add 1 for the one we just processed
00:CA35 A593            	  1956:   lda  token_type
00:CA37 C92C            	  1957:   cmp  #','
00:CA39 F0E3            	  1958:   beq  library_function_call_2
                        	  1959: 
00:CA3B A54B            	  1960:   lda  COUNT1
00:CA3D A006            	  1961:   ldy  #SYMARG
00:CA3F D140            	  1962:   cmp  (SYMITM),Y   ; check we got the right number of arguments
00:CA41 F005            	  1963:   beq  library_function_call_3
                        	  1964: 
00:CA43 A223            	  1965:   ldx  #35     ; ERROR: Parameters mismatched
00:CA45 4C4F9A          	  1966:   jmp  ERROR
                        	  1967: library_function_call_3:
00:CA48 209EBD          	  1968:   jsr  CHKRHP
00:CA4B 8003            	  1969:   bra  library_function_call_5
                        	  1970: 
                        	  1971: ;
                        	  1972: ;  here for no arguments
                        	  1973: ;
                        	  1974: 
                        	  1975: library_function_call_1:
00:CA4D 203DD2          	  1976:   jsr  pas_get_token      ; one token look-ahead
                        	  1977: 
                        	  1978: library_function_call_5:
00:CA50 A004            	  1979:   ldy  #SYMDSP
00:CA52 B140            	  1980:   lda  (SYMITM),Y
00:CA54 852B            	  1981:   sta  OPND
00:CA56 C8              	  1982:   iny
00:CA57 B140            	  1983:   lda  (SYMITM),Y
00:CA59 852C            	  1984:   sta  OPND+1
00:CA5B A903            	  1985:   lda  #PCODE_LIB_CALL
00:CA5D 20EACA          	  1986:   jsr  GENJMP
00:CA60 60              	  1987:   rts
                        	  1988: 
                        	  1989: 
                        	  1990: ;***********************************************
                        	  1991: ; GENERATE P-CODES - NO OPERANDS
                        	  1992: ;***********************************************
                        	  1993: GENNOP   =  *
00:CA61 A442            	  1994:          LDY  SYNTAX
00:CA63 D011            	  1995:          BNE  GEN1      ; no storing/displaying if syntax-only compile
00:CA65 9123            	  1996:          STA  (PCODE),Y
00:CA67 48              	  1997:          PHA
00:CA68 202795          	  1998:          JSR  DISPAD
00:CA6B 68              	  1999:          PLA
00:CA6C A62E            	  2000:          LDX  DCODE
00:CA6E F006            	  2001:          BEQ  GEN1
00:CA70 202195          	  2002:          JSR  DISHX
00:CA73 200C95          	  2003:          JSR  CROUT
                        	  2004: GEN1     =  *
00:CA76 A901            	  2005:          LDA  #1      ; 1-byte P-code
00:CA78 D035            	  2006:          BNE  GEN2_B
                        	  2007: ;***********************************************
                        	  2008: ; GENERATE P-CODES - WITH ADDRESS (3-bytes stored in DISPL (1)/OFFSET(2))
                        	  2009: ;***********************************************
                        	  2010: GENADR   =  *
00:CA7A A442            	  2011:          LDY  SYNTAX
00:CA7C D02F            	  2012:          BNE  GEN2    ; no storing/displaying if syntax-only compile
00:CA7E 9123            	  2013:          STA  (PCODE),Y
00:CA80 48              	  2014:          PHA
00:CA81 A527            	  2015:          LDA  DISPL
00:CA83 C8              	  2016:          INY
00:CA84 9123            	  2017:          STA  (PCODE),Y
00:CA86 A529            	  2018:          LDA  OFFSET
00:CA88 C8              	  2019:          INY
00:CA89 9123            	  2020:          STA  (PCODE),Y
00:CA8B A52A            	  2021:          LDA  OFFSET+1
00:CA8D C8              	  2022:          INY
00:CA8E 9123            	  2023:          STA  (PCODE),Y
00:CA90 202795          	  2024:          JSR  DISPAD
00:CA93 68              	  2025:          PLA
00:CA94 A62E            	  2026:          LDX  DCODE
00:CA96 F015            	  2027:          BEQ  GEN2
00:CA98 202195          	  2028:          JSR  DISHX
00:CA9B A527            	  2029:          LDA  DISPL
00:CA9D 202195          	  2030:          JSR  DISHX
00:CAA0 A529            	  2031:          LDA  OFFSET
00:CAA2 202195          	  2032:          JSR  DISHX
00:CAA5 A52A            	  2033:          LDA  OFFSET+1
00:CAA7 202195          	  2034:          JSR  DISHX
00:CAAA 200C95          	  2035:          JSR  CROUT
                        	  2036: GEN2     =  *
00:CAAD A904            	  2037:          LDA  #4      ; 4-byte P-code
                        	  2038: GEN2_B   =  *
00:CAAF 18              	  2039:          CLC
00:CAB0 6523            	  2040:          ADC  PCODE
00:CAB2 8523            	  2041:          STA  PCODE
00:CAB4 9002            	  2042:          BCC  GEN2_A
00:CAB6 E624            	  2043:          INC  PCODE+1
                        	  2044: GEN2_A   =  *
00:CAB8 A542            	  2045:          LDA  SYNTAX
00:CABA D013            	  2046:          BNE  GEN2_C      ; no storing/displaying if syntax-only compile
00:CABC A524            	  2047:          LDA  PCODE+1     ; see if P-codes full
00:CABE C532            	  2048:          CMP  ENDSYM+1   ; in other words, have we hit the symbol table?
00:CAC0 900D            	  2049:          BCC  GEN2_C      ; less than
00:CAC2 D006            	  2050:          BNE  GEN_FULL
00:CAC4 A523            	  2051:          LDA  PCODE
00:CAC6 C531            	  2052:          CMP  ENDSYM   ; TODO - what?
00:CAC8 9005            	  2053:          BCC  GEN2_C
00:CACA A201            	  2054: GEN_FULL LDX  #1         ; MEM FULL
00:CACC 4C4F9A          	  2055:          jmp  ERROR
                        	  2056: GEN2_C   =  *
00:CACF 60              	  2057: DISP9    RTS
                        	  2058: ;***********************************************
                        	  2059: ; GENERATE P-CODES - JUMP ADDRESS (relative to current P-code address in OPND)
                        	  2060: ;***********************************************
                        	  2061: GENRJMP  =  *
00:CAD0 48              	  2062:          PHA
00:CAD1 A52B            	  2063:          LDA  OPND
00:CAD3 38              	  2064:          SEC
00:CAD4 E523            	  2065:          SBC  PCODE
00:CAD6 852B            	  2066:          STA  OPND      ; subtract P-code address to find difference
00:CAD8 A52C            	  2067:          LDA  OPND+1
00:CADA E524            	  2068:          SBC  PCODE+1
00:CADC 852C            	  2069:          STA  OPND+1
00:CADE 68              	  2070:          PLA
00:CADF 4CEACA          	  2071:          JMP  GENJMP
                        	  2072: ;
                        	  2073: GENNJP   =  *
00:CAE2 A93C            	  2074:          LDA  #PCODE_JMP       ; JMP
                        	  2075: 
                        	  2076: ; Generate jump, P-code is in "A" register (eg. PCODE_JMZ, PCODE_JM1)
                        	  2077: ;
                        	  2078: ;  Note: the destination here is 0000, however FIXAD will be called later to fix up
                        	  2079: ;        the jump, once we know what the destination will be (ie. further down the code)
                        	  2080: ;
00:CAE4 A200            	  2081: GENNJM   LDX  #0
00:CAE6 862B            	  2082:          STX  OPND
00:CAE8 862C            	  2083:          STX  OPND+1
                        	  2084: ;
                        	  2085: ;***********************************************
                        	  2086: ; GENERATE P-CODES - JUMP ADDRESS (absolute address in OPND)
                        	  2087: ;   also used in other places, like increment stack address
                        	  2088: ;***********************************************
                        	  2089: GENJMP   =  *
00:CAEA A442            	  2090:          LDY  SYNTAX
00:CAEC D025            	  2091:          BNE  GEN3     ; no storing/displaying if syntax-only compile
00:CAEE 9123            	  2092:          STA  (PCODE),Y
00:CAF0 48              	  2093:          PHA
00:CAF1 A52B            	  2094:          LDA  OPND
00:CAF3 C8              	  2095:          INY
00:CAF4 9123            	  2096:          STA  (PCODE),Y
00:CAF6 A52C            	  2097:          LDA  OPND+1
00:CAF8 C8              	  2098:          INY
00:CAF9 9123            	  2099:          STA  (PCODE),Y
00:CAFB 202795          	  2100:          JSR  DISPAD
00:CAFE 68              	  2101:          PLA
00:CAFF A62E            	  2102:          LDX  DCODE
00:CB01 F010            	  2103:          BEQ  GEN3
00:CB03 202195          	  2104:          JSR  DISHX
00:CB06 A52B            	  2105:          LDA  OPND
00:CB08 202195          	  2106:          JSR  DISHX
00:CB0B A52C            	  2107:          LDA  OPND+1
00:CB0D 202195          	  2108:          JSR  DISHX
00:CB10 200C95          	  2109:          JSR  CROUT
                        	  2110: GEN3     =  *
00:CB13 A903            	  2111:          LDA  #3        ; 3-byte P-code
00:CB15 4CAFCA          	  2112:          JMP  GEN2_B
                        	  2113: 
                        	  2114: ;***********************************************
                        	  2115: ; FIXUP ADDRESSES
                        	  2116: ;***********************************************
                        	  2117: FIXAD    =  *
00:CB18 A442            	  2118:          LDY  SYNTAX
00:CB1A D039            	  2119:          BNE  FIXAD1
00:CB1C A001            	  2120:          LDY  #1
00:CB1E A523            	  2121:          LDA  PCODE
00:CB20 38              	  2122:          SEC
00:CB21 E537            	  2123:          SBC  WORK
00:CB23 9137            	  2124:          STA  (WORK),Y
00:CB25 C8              	  2125:          INY
00:CB26 A524            	  2126:          LDA  PCODE+1
00:CB28 E538            	  2127:          SBC  WORK+1
00:CB2A 9137            	  2128:          STA  (WORK),Y
00:CB2C A52E            	  2129:          LDA  DCODE
00:CB2E F025            	  2130:          BEQ  FIXAD1
00:CB30 A956            	  2131:          LDA  #<FIXM1
00:CB32 A2CB            	  2132:          LDX  #>FIXM1
00:CB34 202682          	  2133:          JSR  print
00:CB37 A538            	  2134:          LDA  WORK+1
00:CB39 208195          	  2135:          JSR  PRBYTE
00:CB3C A537            	  2136:          LDA  WORK
00:CB3E 202195          	  2137:          JSR  DISHX
00:CB41 A95F            	  2138:          LDA  #<FIXM2
00:CB43 A2CB            	  2139:          LDX  #>FIXM2
00:CB45 202682          	  2140:          JSR  print
00:CB48 A524            	  2141:          LDA  PCODE+1
00:CB4A 208195          	  2142:          JSR  PRBYTE
00:CB4D A523            	  2143:          LDA  PCODE
00:CB4F 202195          	  2144:          JSR  DISHX
00:CB52 4C0C95          	  2145:          JMP  CROUT
00:CB55 60              	  2146: FIXAD1    rts
                        	  2147: 
00:CB56 4A756D7020617420	  2148: FIXM1    asciiz  'Jump at '
00:CB5E 00
00:CB5F 6368616E67656420	  2149: FIXM2    asciiz  'changed to '   ; changed to
00:CB67 746F20
00:CB6A 00
                        	  2150: 
                        	  2151: 

Source: "gpascal.asm"
                        	   188:   .include "hardware.inc"

Source: "hardware.inc"
                        	     1: 
                        	     2: ; VIA - Versatile Interface Adapter (W65C22) hardware
                        	     3: 
                        	     4: VIA_PORTB   = $7FF0   ; input/output register "B"
                        	     5: VIA_PORTA   = $7FF1   ; input/output register "A"
                        	     6: VIA_DDRB    = $7FF2   ; data direction register "B"
                        	     7: VIA_DDRA    = $7FF3   ; data direction register "A"
                        	     8: VIA_T1C_L   = $7FF4   ; T1 write: latch (L), read: counter (L)
                        	     9: VIA_T1C_H   = $7FF5   ; T1 high_order counter
                        	    10: VIA_T1L_L   = $7FF6   ; T1 low_order latches
                        	    11: VIA_T1L_H   = $7FF7   ; T1 high_order latches
                        	    12: VIA_T2C_L   = $7FF8   ; T2 write: latch (L), read: counter (L)
                        	    13: VIA_T2C_H   = $7FF9   ; T2 high_order counter
                        	    14: VIA_SR      = $7FFA   ; shift register
                        	    15: VIA_ACR     = $7FFB   ; auxilliary control register
                        	    16: VIA_PCR     = $7FFC   ; peripheral control register
                        	    17: VIA_IFR     = $7FFD   ; interrupt flag register
                        	    18: VIA_IER     = $7FFE   ; interrupt enable register
                        	    19: 
                        	    20: VIA_FLAG_ENABLE   = %10000000 ; high-order bit set enables the flag
                        	    21: VIA_FLAG_DISABLE  = %00000000 ; high-order bit clear disables the flag
                        	    22: VIA_FLAG_TIMER1   = %01000000
                        	    23: VIA_FLAG_TIMER2   = %00100000
                        	    24: VIA_FLAG_CB1      = %00010000
                        	    25: VIA_FLAG_CB2      = %00001000
                        	    26: VIA_FLAG_SHIFT    = %00000100
                        	    27: VIA_FLAG_CA1      = %00000010
                        	    28: VIA_FLAG_CA2      = %00000001
                        	    29: 
                        	    30: ;
                        	    31: ; VIA Port A pin masks
                        	    32: ;
                        	    33: 
                        	    34: SERIAL_IN_MASK     = %00000001   ; serial in on PA0 (also connect to CB2) (to FTDI TxD pin - pin 4)
                        	    35: SERIAL_OUT_MASK    = %00000010   ; serial out on PA1 (to FTDI RxD pin - pin 5)
                        	    36: SERIAL_DEBUG1_MASK = %00000100   ; serial debugging on PA2
                        	    37: SERIAL_DEBUG2_MASK = %00001000   ; serial debugging on PA3
                        	    38: SERIAL_SPARE2_MASK = %00010000   ; spare VIA pins (PA4)
                        	    39: 
                        	    40: 
                        	    41: ;***********************************************
                        	    42: ;  Functions added for Ben's Board
                        	    43: ;***********************************************
                        	    44: 
                        	    45: ;
                        	    46: ;  Converts a pin number in the range 0 to 15 to a mask
                        	    47: ;  eg. 00000001, 00000010, 00000100 and so on
                        	    48: ;
                        	    49: ;  Returns mask in Y
                        	    50: ;
                        	    51: ;  Returns with Z set if the range was 0 to 7 an
                        	    52: ;  and Z clear if the range was 8 to 15
                        	    53: ;
                        	    54: pin_number_to_mask = *
00:CB6B 48              	    55:   pha         ; save for a moment
00:CB6C 2907            	    56:   and #$7     ; make in range 0 to 7
00:CB6E A8              	    57:   tay
00:CB6F A901            	    58:   lda #1      ; initial mask
                        	    59: pin_number_to_mask_loop:
00:CB71 C000            	    60:   cpy #0
00:CB73 F004            	    61:   beq pin_number_to_mask_done
00:CB75 0A              	    62:   asl A
00:CB76 88              	    63:   dey
00:CB77 80F8            	    64:   bra pin_number_to_mask_loop
                        	    65: pin_number_to_mask_done:
00:CB79 A8              	    66:   tay         ; save mask in Y
00:CB7A 68              	    67:   pla
00:CB7B 2908            	    68:   and #$8     ; DDRA or DDRB ?
00:CB7D 60              	    69:   rts
                        	    70: 
                        	    71: ;
                        	    72: ;  pin in A, mode in X
                        	    73: ;
                        	    74: pinmode:
00:CB7E 868C            	    75:   stx hardware_work ; input or output
00:CB80 206BCB          	    76:   jsr pin_number_to_mask  ; convert to appropriate mask bit
00:CB83 D00A            	    77:   bne pinmode_B        ; Z is clear if it is DDRB
00:CB85 A9F3            	    78:   lda #<VIA_DDRA
00:CB87 8500            	    79:   sta REG
00:CB89 A97F            	    80:   lda #>VIA_DDRA
00:CB8B 8501            	    81:   sta REG+1
00:CB8D 8008            	    82:   bra pinmode_C
                        	    83: pinmode_B:
00:CB8F A9F2            	    84:   lda #<VIA_DDRB
00:CB91 8500            	    85:   sta REG
00:CB93 A97F            	    86:   lda #>VIA_DDRB
00:CB95 8501            	    87:   sta REG+1
                        	    88: ;
                        	    89: ;  The DDR register is now in REG
                        	    90: ;
                        	    91: pinmode_C:
00:CB97 A58C            	    92:   lda hardware_work     ; input or output?
00:CB99 D00A            	    93:   bne pinmode_OUTPUT
                        	    94: ;
                        	    95: ;  here to set input mode
                        	    96: ;
00:CB9B 98              	    97:   tya       ; get the mask back
00:CB9C A000            	    98:   ldy #0
00:CB9E 49FF            	    99:   eor #$FF  ; negate the mask
00:CBA0 3100            	   100:   and (REG),y
00:CBA2 9100            	   101:   sta (REG),y
00:CBA4 60              	   102:   rts       ; done
                        	   103: ;
                        	   104: ;  here to set output mode
                        	   105: ;
                        	   106: pinmode_OUTPUT:
00:CBA5 98              	   107:   tya          ; get the mask back
00:CBA6 A000            	   108:   ldy #0
00:CBA8 1100            	   109:   ora (REG),y  ; or in with the existing DDR register
00:CBAA 9100            	   110:   sta (REG),y  ; and write it back
00:CBAC 60              	   111:   rts          ; done
                        	   112: 
                        	   113: 
                        	   114: ;
                        	   115: ;  DIGITALWRITE (pin, value) pin:0 to 15; value: 0 or 1 : pin in A, mode in X
                        	   116: ;
                        	   117: digitalwrite = *
00:CBAD 868C            	   118:   stx hardware_work ; save what to write (0 or 1)
00:CBAF 206BCB          	   119:   jsr pin_number_to_mask  ; convert to appropriate mask bit
00:CBB2 D00A            	   120:   bne digitalwrite_B        ; Z is clear if it is PORTB
00:CBB4 A9F1            	   121:   lda #<VIA_PORTA
00:CBB6 8500            	   122:   sta REG
00:CBB8 A97F            	   123:   lda #>VIA_PORTA
00:CBBA 8501            	   124:   sta REG+1
00:CBBC 8008            	   125:   bra digitalwrite_C
                        	   126: digitalwrite_B:
00:CBBE A9F0            	   127:   lda #<VIA_PORTB
00:CBC0 8500            	   128:   sta REG
00:CBC2 A97F            	   129:   lda #>VIA_PORTB
00:CBC4 8501            	   130:   sta REG+1
                        	   131: ;
                        	   132: ;  The PORT register is now in REG
                        	   133: ;
                        	   134: digitalwrite_C:
00:CBC6 A58C            	   135:   lda hardware_work
00:CBC8 D00A            	   136:   bne digitalwrite_ONE  ; any non-zero value is writing a 1
                        	   137: ;
                        	   138: ;  here to write a zero
                        	   139: ;
00:CBCA 98              	   140:   tya
00:CBCB A000            	   141:   ldy #0
00:CBCD 49FF            	   142:   eor #$FF  ; negate the mask
00:CBCF 3100            	   143:   and (REG),y
00:CBD1 9100            	   144:   sta (REG),y
00:CBD3 60              	   145:   rts       ; done
                        	   146: 
                        	   147: ;
                        	   148: ;  here to write a one
                        	   149: ;
                        	   150: digitalwrite_ONE:
00:CBD4 98              	   151:   tya          ; get the mask back
00:CBD5 A000            	   152:   ldy #0
00:CBD7 1100            	   153:   ora (REG),y  ; or in with the existing DDR register
00:CBD9 9100            	   154:   sta (REG),y  ; and write it back
00:CBDB 60              	   155:   rts          ; done
                        	   156: 
                        	   157: 
                        	   158: ;
                        	   159: ;  DIGITALREAD (pin) pin:0 to 15; Pin to read is in in A. returns or non-zero in A.
                        	   160: ;
                        	   161: digitalread = *
00:CBDC 206BCB          	   162:   jsr pin_number_to_mask  ; convert to appropriate mask bit
00:CBDF D00A            	   163:   bne digitalread_B        ; Z is clear if it is PORTB
00:CBE1 A9F1            	   164:   lda #<VIA_PORTA
00:CBE3 8500            	   165:   sta REG
00:CBE5 A97F            	   166:   lda #>VIA_PORTA
00:CBE7 8501            	   167:   sta REG+1
00:CBE9 8008            	   168:   bra digitalread_C
                        	   169: digitalread_B:
00:CBEB A9F0            	   170:   lda #<VIA_PORTB
00:CBED 8500            	   171:   sta REG
00:CBEF A97F            	   172:   lda #>VIA_PORTB
00:CBF1 8501            	   173:   sta REG+1
                        	   174: ;
                        	   175: ;  The PORT register is now in REG
                        	   176: ;
                        	   177: digitalread_C:
00:CBF3 98              	   178:   tya         ; get the mask back
00:CBF4 A000            	   179:   ldy #0
00:CBF6 3100            	   180:   and (REG),y ; get that bit
00:CBF8 60              	   181:   rts
                        	   182: 
                        	   183: 
                        	   184: 
                        	   185: ;
                        	   186: ;  Functions to change where writing is done
                        	   187: ;
                        	   188: write_to_serial:
00:CBF9 48              	   189:   pha
00:CBFA A959            	   190:   lda  #<write_char
00:CBFC 8517            	   191:   sta  write_function
00:CBFE A9CC            	   192:   lda  #>write_char
00:CC00 8518            	   193:   sta  write_function+1
00:CC02 68              	   194:   pla
00:CC03 60              	   195:   rts
                        	   196: 
                        	   197: write_to_lcd:
00:CC04 48              	   198:   pha
00:CC05 A9B5            	   199:   lda  #<lcd_print_char
00:CC07 8517            	   200:   sta  write_function
00:CC09 A9BB            	   201:   lda  #>lcd_print_char
00:CC0B 8518            	   202:   sta  write_function+1
00:CC0D 68              	   203:   pla
00:CC0E 60              	   204:   rts
                        	   205: 
                        	   206: 
                        	   207: 
                        	   208: ; ---------------------------
                        	   209: ; Simulate kernel interfaces
                        	   210: ; ---------------------------
                        	   211: ; We interface by reading/writing to special
                        	   212: ; RAM that is implemented in the emulator
                        	   213: 
                        	   214: 
                        	   215: 
                        	   216:     .if EMULATOR
                        	   217: 
                        	   218: ;
                        	   219: ;  Emulator testing
                        	   220: ;
                        	   221: CHRIN    =  *
                        	   222:          lda  $7F22
                        	   223:          rts
                        	   224: 
                        	   225: write_char   =  *
                        	   226:          sta  $7F23
                        	   227:          rts
                        	   228: 
                        	   229: 
                        	   230: GETIN    =  *
                        	   231:          lda  $7F29
                        	   232:          rts
                        	   233: 
                        	   234: hardware_init rts
                        	   235: 
                        	   236: ;
                        	   237: ;  put debug number in A
                        	   238: ;
                        	   239: EMULATOR_DEBUG = *
                        	   240:          sta $7F46
                        	   241:          rts
                        	   242: 
                        	   243: START_TRACE = *
                        	   244:          sta $7F47
                        	   245:          rts
                        	   246: 
                        	   247: STOP_TRACE = *
                        	   248:          sta $7F48
                        	   249:          rts
                        	   250: ;
                        	   251: ;  not applicable in emulator
                        	   252: ;
                        	   253: lcd_print_message   rts
                        	   254: lcd_clear_display   rts
                        	   255: lcd_print_char      rts
                        	   256: lcd_second_line     rts
                        	   257: lcd_instruction     rts
                        	   258: lcd_get_address     rts
                        	   259: lcd_wait            rts
                        	   260: lcd_home            rts
                        	   261: lcd_initialise      rts
                        	   262: serial_available    rts
                        	   263: serial_print_message rts
                        	   264: 
                        	   265:   .else
                        	   266: 
                        	   267: ;
                        	   268: ;  Ben's Board
                        	   269: ;
                        	   270: 
                        	   271: ;
                        	   272: ;  typing_latency could be used as a seed for the random number generator
                        	   273: ;    - the exact time between keypresses would be somewhat unpredictable
                        	   274: ;
                        	   275: CHRIN  = *
                        	   276: GETIN    =  *
00:CC0F E60D            	   277:          inc typing_latency
00:CC11 D006            	   278:          bne GETIN1
00:CC13 E60E            	   279:          inc typing_latency+1
00:CC15 D002            	   280:          bne GETIN1
00:CC17 E60F            	   281:          inc typing_latency+2
                        	   282: GETIN1:
00:CC19 A58B            	   283:          lda serial_in_byte_received
00:CC1B F0F2            	   284:          beq GETIN    ; nothing yet
00:CC1D 648B            	   285:          stz serial_in_byte_received
00:CC1F 60              	   286:          rts
                        	   287: 
                        	   288: serial_available = *
00:CC20 A58B            	   289:          lda serial_in_byte_received
00:CC22 60              	   290:          rts
                        	   291: 
                        	   292: 
00:CC23 60              	   293: EMULATOR_DEBUG rts
00:CC24 60              	   294: START_TRACE rts
00:CC25 60              	   295: STOP_TRACE rts
                        	   296: 
                        	   297: 
                        	   298: ;
                        	   299: ;  set up serial hardware
                        	   300: ;
                        	   301: 
                        	   302: hardware_init:
                        	   303: 
00:CC26 A902            	   304:   lda #SERIAL_OUT_MASK  ; set 1 bit (idle serial comms), and others to zero
00:CC28 8DF17F          	   305:   sta VIA_PORTA
                        	   306: 
                        	   307:   ; set output enable bits
00:CC2B A91E            	   308:   lda #(SERIAL_OUT_MASK | SERIAL_DEBUG1_MASK | SERIAL_DEBUG2_MASK | SERIAL_SPARE2_MASK)
00:CC2D 8DF37F          	   309:   sta VIA_DDRA
                        	   310: 
00:CC30 A940            	   311:   lda #%01000000      ; continuous interrupts on T1
00:CC32 8DFB7F          	   312:   sta VIA_ACR
                        	   313: 
00:CC35 A900            	   314:   lda #0              ; Input-negative active edge
00:CC37 8DFC7F          	   315:   sta VIA_PCR
                        	   316: 
00:CC3A A9D0            	   317:   lda #<BIT_INTERVAL  ; ie. baud rate interval
00:CC3C 8DF47F          	   318:   sta VIA_T1C_L       ; for sending bits
00:CC3F A900            	   319:   lda #>BIT_INTERVAL
00:CC41 8DF57F          	   320:   sta VIA_T1C_H       ; this starts the counter
                        	   321: 
                        	   322:   ; set up for serial input
                        	   323: 
00:CC44 A988            	   324:   lda #VIA_FLAG_ENABLE | VIA_FLAG_CB2  ; interrupt on CB2 falling edge
00:CC46 8DFE7F          	   325:   sta VIA_IER
                        	   326: 
00:CC49 A9FF            	   327:   lda #$FF         ; clear all interrupt flags
00:CC4B 8DFD7F          	   328:   sta VIA_IFR
                        	   329: 
                        	   330:   .if LCD_SUPPORT
00:CC4E 20A6BA          	   331:   jsr lcd_initialise
                        	   332:   .endif
                        	   333: 
00:CC51 648A            	   334:   stz serial_in_byte    ; non-zero means an interrupt put in incoming byte there
00:CC53 6489            	   335:   stz serial_out_bit
00:CC55 6468            	   336:   stz spi_mode          ; default to SPI mode zero
                        	   337: 
00:CC57 58              	   338:   cli         ; enable interrupts
00:CC58 60              	   339:   rts
                        	   340: 
                        	   341: 
                        	   342: ;
                        	   343: ;  Write a character (in A) to the serial port.
                        	   344: ;   Interrupts MUST be enabled for this to work!
                        	   345: ;
                        	   346: write_char:
00:CC59 48              	   347:   pha                   ; save original character
00:CC5A 0A              	   348:   asl a                 ; shift in a zero which will be the start bit
00:CC5B 8587            	   349:   sta serial_out_byte
00:CC5D A9FF            	   350:   lda #0xff             ; will become the stop bit(s)
00:CC5F 2A              	   351:   rol a                 ; rotate in the high-order bit from the data byte
00:CC60 8588            	   352:   sta serial_out_byte+1
00:CC62 A90B            	   353:   lda #11               ; 8 data bits, one start bit, two stop bits
00:CC64 8589            	   354:   sta serial_out_bit    ; number of bits to shift out
00:CC66 A9D0            	   355:   lda #<BIT_INTERVAL    ; ie. baud rate interval
00:CC68 8DF47F          	   356:   sta VIA_T1C_L         ; for sending bits
00:CC6B A900            	   357:   lda #>BIT_INTERVAL
00:CC6D 8DF57F          	   358:   sta VIA_T1C_H         ; this starts the counter
00:CC70 A9C0            	   359:   lda #VIA_FLAG_ENABLE | VIA_FLAG_TIMER1  ; interrupt on T1 timeout
00:CC72 8DFE7F          	   360:   sta VIA_IER
                        	   361: 
                        	   362: ;
                        	   363: ; wait for this byte to finish - otherwise it might interfere with many things
                        	   364: ;
                        	   365: 
                        	   366: write_char_loop:
00:CC75 ADFE7F          	   367:   lda VIA_IER
00:CC78 2940            	   368:   and #VIA_FLAG_TIMER1  ; are T1 interrupts enabled?
00:CC7A D0F9            	   369:   bne write_char_loop   ; loop until this character sent
00:CC7C 68              	   370:   pla                   ; get character back
00:CC7D 60              	   371:   rts
                        	   372: 
                        	   373: 
                        	   374: ;
                        	   375: ;  sends null-terminated message to serial port, message in A (lo) and X (hi)
                        	   376: ;  returns the length of the message in Y
                        	   377: ;
                        	   378: serial_print_message:
00:CC7E 8503            	   379:   sta REG2
00:CC80 8604            	   380:   stx REG2+1
00:CC82 A000            	   381:   ldy #0
                        	   382: serial_print:
00:CC84 B103            	   383:   lda (REG2),y
00:CC86 F006            	   384:   beq serial_print_done
00:CC88 2059CC          	   385:   jsr write_char
00:CC8B C8              	   386:   iny
00:CC8C 80F6            	   387:   bra serial_print
                        	   388: 
00:CC8E 60              	   389: serial_print_done rts
                        	   390: 
                        	   391:   .endif  ; not EMULATOR
                        	   392: 
                        	   393: 

Source: "gpascal.asm"
                        	   189:   .include "gtoken.inc"

Source: "gtoken.inc"
                        	     1: ;
                        	     2: ;  get_token
                        	     3: ;
                        	     4: ;  Gets a lexical token from the specified address.
                        	     5: ;
                        	     6: ;  - Start parsing at token_start (this should be the first character of the token)
                        	     7: ;  - The first found character (after spaces, comments, newlines) is in token_address
                        	     8: ;      - this is mainly used for knowing what the identifier is so we can put it in the symbol table
                        	     9: ;      - strings are put into INBUF after processing, so token_address is not as useful in that case
                        	    10: ;  - The length is in token_length (in the case of strings, this is the processed length)
                        	    11: ;  - The type is in token_type - zero would mean end of file
                        	    12: ;
                        	    13: ;  The types are one of the token codes below
                        	    14: ;
                        	    15: ;  Tokens which start with a letter and are possibly followed by letters, numbers, and
                        	    16: ;    the underscore character become TOKEN_IDENTIFIER.
                        	    17: ;
                        	    18: ;  Tokens starting with a number (TOKEN_NUMBER) are parsed for the value which is placed into token_value.
                        	    19: ;
                        	    20: ;  Tokens starting with a single or double quote are parsed for the internal string (TOKEN_STRING)
                        	    21: ;  which is placed in INBUF. The internal string has internal double-quotes turned
                        	    22: ;  into single quotes, and sequences like \n or \x42 turned into their appropriate characters.
                        	    23: ;
                        	    24: ;  String tokens which are up to 3 bytes long also have the 3 bytes placed into token_value.
                        	    25: ;
                        	    26: ;  Hex and binary tokens are parsed for their value which is placed into token_value.
                        	    27: ;
                        	    28: ;  Various 2-character tokens are given their own code (eg. <> == != := << >> and so on).
                        	    29: ;
                        	    30: ;  Spaces and comments are skipped, however Pascal directives inside comments are processed
                        	    31: ;
                        	    32: ;  Newlines are skipped in Pascal but returned as a token in assembler (ASSEMBLING == true)
                        	    33: ;  If newlines are skipped then token_line is called to handle listing the line (the line
                        	    34: ;   we are about to process, not the previous line)
                        	    35: ;
                        	    36: ; Rewritten in February 2022 to be easier to read and have well-defined work variables (zero-page variables)
                        	    37: 
                        	    38: ; multi-byte token codes (single byte tokens are themselves)
                        	    39: 
                        	    40: TOKEN_ASSIGN     = 'A'   ; :=
                        	    41: TOKEN_IDENTIFIER = 'I'   ; alpha-numeric identifiers
                        	    42: TOKEN_NUMBER     = 'N'   ; numbers
                        	    43: TOKEN_STRING     = '"'   ; string literal
                        	    44: TOKEN_LEQ        = $80   ; <=
                        	    45: TOKEN_GEQ        = $81   ; >=
                        	    46: TOKEN_NEQ        = 'U'   ; <>
                        	    47: 
                        	    48: ;
                        	    49: ;  the ones below are used in the assembler
                        	    50: ;
                        	    51: TOKEN_EQUALITY    = 'E'     ; ==
                        	    52: TOKEN_SHIFT_LEFT  = 'L'     ; <<
                        	    53: TOKEN_SHIFT_RIGHT = 'R'     ; >>
                        	    54: TOKEN_UNARY_MINUS = 'M'     ; -
                        	    55: TOKEN_LOW_BYTE    = 'V'     ; eg. lda #<foo
                        	    56: TOKEN_HIGH_BYTE   = 'W'     ; eg. lda #>foo
                        	    57: TOKEN_LOGICAL_AND = 'X'     ; &&
                        	    58: TOKEN_LOGICAL_OR  = 'Y'     ; ||
                        	    59: TOKEN_INEQUALITY  = 'Z'     ; !=
                        	    60: 
                        	    61: 
                        	    62: get_token:
00:CC8F A593            	    63:   lda token_type      ; remember previous token for checking if + or - stand on their own
00:CC91 8598            	    64:   sta token_work
                        	    65: get_token_loop:
00:CC93 A000            	    66:   ldy #0              ; offset into the token address
00:CC95 8497            	    67:   sty token_sign      ; Y is zero at this point
00:CC97 8494            	    68:   sty token_value     ; no value yet
00:CC99 8495            	    69:   sty token_value+1
00:CC9B 8496            	    70:   sty token_value+2
                        	    71: 
                        	    72: gc_skip_spaces:
00:CC9D B18E            	    73:   lda (token_start),y
00:CC9F F034            	    74:   beq gc_done         ; 0x00 means end, so return it WITHOUT incrementing the pointer
00:CCA1 C90A            	    75:   cmp #NL             ; newline need special handling
00:CCA3 F00D            	    76:   beq gc_newline
00:CCA5 204A81          	    77:   jsr isspace
00:CCA8 9043            	    78:   bcc gc_not_space
00:CCAA E68E            	    79:   inc token_start     ; increment pointer because spaces can be any length
00:CCAC D0EF            	    80:   bne gc_skip_spaces
00:CCAE E68F            	    81:   inc token_start+1
00:CCB0 80EB            	    82:   bra gc_skip_spaces
                        	    83: 
                        	    84: ;
                        	    85: ;  got a newline - if assembling, return that so we know where lines end
                        	    86: ;  otherwise just call token_line to display the next line and press on looking
                        	    87: ;  for tokens.
                        	    88: ;
                        	    89: gc_newline:
00:CCB2 A902            	    90:   lda #FLAG_ASSEMBLING
00:CCB4 25BE            	    91:   and system_flags
00:CCB6 D014            	    92:   bne gc_newline_assembling    ; return the newline as a token
00:CCB8 C8              	    93:   iny              ; length in Y (ie. one)
00:CCB9 E68E            	    94:   inc token_start
00:CCBB D002            	    95:   bne gc_newline1
00:CCBD E68F            	    96:   inc token_start+1
                        	    97: gc_newline1:
00:CCBF A58E            	    98:   lda token_start
00:CCC1 859C            	    99:   sta token_line_start
00:CCC3 A58F            	   100:   lda token_start+1
00:CCC5 859D            	   101:   sta token_line_start+1
00:CCC7 202FCD          	   102:   jsr token_line        ; list the next line
00:CCCA 80C7            	   103:   bra get_token_loop    ; look for another token
                        	   104: 
                        	   105: gc_newline_assembling:
00:CCCC A90A            	   106:   lda #NL       ; get the newline back
00:CCCE 4CD3CC          	   107:   jmp gc_single_byte_token
                        	   108: 
                        	   109: ;
                        	   110: ;  wrap up getting a token:
                        	   111: ;
                        	   112: ;   - save the type
                        	   113: ;   - save the current address as token_address
                        	   114: ;   - add the length to token_start ready for next time
                        	   115: ;
                        	   116: gc_single_byte_already_known:
00:CCD1 A593            	   117:   lda token_type        ; get back saved token type
                        	   118: gc_single_byte_token:
00:CCD3 A001            	   119:   ldy #1
                        	   120: gc_done:
00:CCD5 8492            	   121:   sty token_length      ; Y has our length
00:CCD7 8593            	   122:   sta token_type        ; A has our type
00:CCD9 18              	   123:   clc
00:CCDA A58E            	   124:   lda token_start
00:CCDC 8590            	   125:   sta token_address     ; save the starting address of the token
00:CCDE 6592            	   126:   adc token_length      ; now add its length
00:CCE0 858E            	   127:   sta token_start       ; that gives the ending address
                        	   128: 
00:CCE2 A58F            	   129:   lda token_start+1     ; repeat for high-order byte
00:CCE4 8591            	   130:   sta token_address+1
00:CCE6 6900            	   131:   adc #0
00:CCE8 858F            	   132:   sta token_start+1
                        	   133: 
00:CCEA A593            	   134:   lda token_type        ; get token type back into A
00:CCEC 60              	   135:   rts
                        	   136: 
                        	   137: ;
                        	   138: ;  not a space (or newline) so this must be the actual start of it
                        	   139: ;
                        	   140: 
                        	   141: gc_not_space:
                        	   142: 
                        	   143: ;
                        	   144: ;  first look for classes of characters (ie. alpha, numeric)
                        	   145: ;
00:CCED 202681          	   146:   jsr isalpha
00:CCF0 9026            	   147:   bcc gc_not_alpha
                        	   148: 
                        	   149: ;
                        	   150: ;  find end of identifier
                        	   151: ;
                        	   152: gc_alpha_loop:
00:CCF2 C8              	   153:   iny
00:CCF3 D005            	   154:   bne gc_alpha_ok   ; if it becomes zero now, we have 256+ long identifier
00:CCF5 A20C            	   155:   ldx #12       ; ERROR: Illegal Identifier (too long)
00:CCF7 4C4F9A          	   156:   jmp ERROR
                        	   157: 
                        	   158: gc_alpha_ok:
00:CCFA A940            	   159:   lda #FLAG_ONLY_ALPHA
00:CCFC 24BE            	   160:   bit system_flags
00:CCFE D00F            	   161:   bne gc_alpha_alpha_only
00:CD00 B18E            	   162:   lda (token_start),y
00:CD02 206281          	   163:   jsr isalnum
00:CD05 B0EB            	   164:   bcs gc_alpha_loop
00:CD07 C95F            	   165:   cmp #'_'
00:CD09 F0E7            	   166:   beq gc_alpha_loop
                        	   167: 
                        	   168: ;
                        	   169: ; end of identifier
                        	   170: ;
                        	   171: gc_alpha_done:
00:CD0B A949            	   172:   lda #TOKEN_IDENTIFIER
00:CD0D 80C6            	   173:   bra gc_done
                        	   174: 
                        	   175: 
                        	   176: gc_alpha_alpha_only:
00:CD0F B18E            	   177:   lda (token_start),y
00:CD11 202681          	   178:   jsr isalpha
00:CD14 B0DC            	   179:   bcs gc_alpha_loop
00:CD16 80F3            	   180:   bra gc_alpha_done
                        	   181: 
                        	   182: ;
                        	   183: ; now see if it is a digit
                        	   184: ;
                        	   185: gc_not_alpha:
00:CD18 203281          	   186:   jsr isdigit
00:CD1B 9007            	   187:   bcc gc_not_digit
                        	   188: 
00:CD1D 207ECD          	   189:   jsr atoi
00:CD20 A94E            	   190:   lda  #TOKEN_NUMBER
00:CD22 80B1            	   191:   bra  gc_done
                        	   192: 
                        	   193: ;
                        	   194: ;  not alpha and not digit - so let's consider:
                        	   195: ;   * prefixes: $ for hex and % for binary
                        	   196: ;   *  + or - in front of numbers or on their own
                        	   197: ;   * single character tokens, eg. =, (, ) and so on
                        	   198: ;   * double-character tokens, eg. ==, >= << and so on
                        	   199: ;   * strings, eg. "foo"
                        	   200: ;
                        	   201: ;  we'll do a jump on the first character
                        	   202: ;
                        	   203: gc_not_digit:
00:CD24 8593            	   204:   sta token_type            ; remember it in case of possible two-byte sequences
00:CD26 A20C            	   205:   ldx #<gtoken_table
00:CD28 A0CE            	   206:   ldy #>gtoken_table
00:CD2A 207692          	   207:   jsr TKNJMP
00:CD2D 80A2            	   208:   bra gc_single_byte_already_known  ; it is what it is
                        	   209: 
                        	   210: ;
                        	   211: ;  here when get_token discovers a newline - print the next line if wanted
                        	   212: ;
                        	   213: 
                        	   214: token_line:
                        	   215: ;
                        	   216: ;  count lines
                        	   217: ;
00:CD2F E6A2            	   218:   inc current_line
00:CD31 D002            	   219:   bne token_line1
00:CD33 E6A3            	   220:   inc current_line+1
                        	   221: token_line1:
                        	   222: ;
                        	   223: ;  compiling or assembling?
                        	   224: ;
00:CD35 A901            	   225:   lda #FLAG_COMPILING
00:CD37 0902            	   226:   ora #FLAG_ASSEMBLING
00:CD39 25BE            	   227:   and system_flags
00:CD3B F040            	   228:   beq token_line_done ; no - no listing
                        	   229: ;
                        	   230: ;  listing wanted?
                        	   231: ;
00:CD3D A904            	   232:   lda #FLAG_LIST_SOURCE
00:CD3F 25BE            	   233:   and system_flags
00:CD41 D00D            	   234:   bne token_line_listing ; yes
                        	   235: 
                        	   236: ;
                        	   237: ;  no listing - show an asterisk every 15 lines
                        	   238: ;
00:CD43 A5A2            	   239:   lda current_line
00:CD45 290F            	   240:   and #$0F
00:CD47 D034            	   241:   bne token_line_done
00:CD49 A92A            	   242:   lda #'*'
00:CD4B 209A96          	   243:   jsr COUT
00:CD4E 802D            	   244:   bra token_line_done
                        	   245: 
                        	   246: token_line_listing:
00:CD50 A52E            	   247:   lda DCODE
00:CD52 48              	   248:   pha
00:CD53 A901            	   249:   lda #1
00:CD55 852E            	   250:   sta DCODE
00:CD57 202795          	   251:   jsr DISPAD
00:CD5A 68              	   252:   pla
00:CD5B 852E            	   253:   sta DCODE
00:CD5D 20478C          	   254:   jsr show_current_line_number
                        	   255: 
00:CD60 A59C            	   256:   lda token_line_start
00:CD62 8598            	   257:   sta token_work
00:CD64 A59D            	   258:   lda token_line_start+1
00:CD66 8599            	   259:   sta token_work+1
                        	   260: 
                        	   261: token_line_loop:
00:CD68 A000            	   262:   ldy #0
00:CD6A B198            	   263:   lda (token_work),Y
00:CD6C F00F            	   264:   beq token_line_done
00:CD6E 48              	   265:   pha
00:CD6F 209A96          	   266:   jsr COUT
00:CD72 E698            	   267:   inc token_work
00:CD74 D002            	   268:   bne token_line_loop1
00:CD76 E699            	   269:   inc token_work+1
                        	   270: token_line_loop1:
00:CD78 68              	   271:   pla
00:CD79 C90A            	   272:   cmp #NL
00:CD7B D0EB            	   273:   bne token_line_loop
                        	   274: 
                        	   275: token_line_done:
00:CD7D 60              	   276:   rts
                        	   277: 
                        	   278: 
                        	   279: ;
                        	   280: ;  atoi
                        	   281: ;
                        	   282: ; get a decimal number - returns carry flag set if bad number and running
                        	   283: ;   (if compiling and a bad number gives an error)
                        	   284: ;
                        	   285: ;  token_start : the start address of the number
                        	   286: ;  Y : offset into token_start
                        	   287: ;  token_sign : non-zero if negative
                        	   288: ;
                        	   289: ;  returns: token_value  and carry clear (if no error)
                        	   290: ;           carry set if error (for use at runtime)
                        	   291: ;           Y at offset of first non-numeric character
                        	   292: 
                        	   293: atoi:
00:CD7E 38              	   294:   sec
00:CD7F E930            	   295:   sbc  #'0'   ;  ; subtract out ASCII stuff, save first digit
00:CD81 8594            	   296:   sta  token_value
00:CD83 6495            	   297:   stz  token_value+1
00:CD85 6496            	   298:   stz  token_value+2
                        	   299: atoi_loop    =  *
00:CD87 C8              	   300:   iny
00:CD88 B18E            	   301:   lda  (token_start),y
00:CD8A 203281          	   302:   jsr  isdigit
00:CD8D B009            	   303:   bcs  atoi_more      ; more digits
                        	   304: ;
                        	   305: ; end of number - make negative if we got a sign earlier
                        	   306: ;
00:CD8F A597            	   307:   lda  token_sign
00:CD91 F003            	   308:   beq  atoi_positive    ; not signed
                        	   309: ;
                        	   310: ;  make negative
                        	   311: ;
00:CD93 20F8CD          	   312:   jsr negate_token_value
                        	   313: ;
                        	   314: ;  done! clear carry and return
                        	   315: ;
                        	   316: atoi_positive:
00:CD96 18              	   317:   clc                   ; indicate no error for numeric conversion
00:CD97 60              	   318:   rts
                        	   319: ;
                        	   320: ;  Multiply previous value by 10, add in new digit
                        	   321: ;
                        	   322: atoi_more    =  *
00:CD98 38              	   323:   sec
00:CD99 E930            	   324:   sbc  #'0'
00:CD9B 859B            	   325:   sta  token_digit
00:CD9D 0694            	   326:   asl  token_value         ; multiply token_value by 2
00:CD9F 2695            	   327:   rol  token_value+1
00:CDA1 2696            	   328:   rol  token_value+2
00:CDA3 3048            	   329:   bmi  atoi_error
                        	   330: 
00:CDA5 A594            	   331:   lda  token_value         ; save token_value*2 in token_work
00:CDA7 8598            	   332:   sta  token_work
00:CDA9 A595            	   333:   lda  token_value+1
00:CDAB 8599            	   334:   sta  token_work+1
00:CDAD A596            	   335:   lda  token_value+2
00:CDAF 859A            	   336:   sta  token_work+2
                        	   337: 
00:CDB1 0694            	   338:   asl  token_value         ; now token_value is multiplied by 4
00:CDB3 2695            	   339:   rol  token_value+1
00:CDB5 2696            	   340:   rol  token_value+2
00:CDB7 3034            	   341:   bmi  atoi_error
                        	   342: 
00:CDB9 0694            	   343:   asl  token_value         ; now token_value is multiplied by 8
00:CDBB 2695            	   344:   rol  token_value+1
00:CDBD 2696            	   345:   rol  token_value+2
00:CDBF 302C            	   346:   bmi  atoi_error
                        	   347: 
00:CDC1 A598            	   348:   lda  token_work          ; now add back in token_value*2 (giving token_value*10)
00:CDC3 6594            	   349:   adc  token_value
00:CDC5 8594            	   350:   sta  token_value
00:CDC7 A599            	   351:   lda  token_work+1
00:CDC9 6595            	   352:   adc  token_value+1
00:CDCB 8595            	   353:   sta  token_value+1
00:CDCD A59A            	   354:   lda  token_work+2
00:CDCF 6596            	   355:   adc  token_value+2
00:CDD1 8596            	   356:   sta  token_value+2
00:CDD3 3018            	   357:   bmi  atoi_error      ; if negative, the number was too big
00:CDD5 18              	   358:   clc
00:CDD6 A594            	   359:   lda  token_value     ; now take the value and add in our new digit
00:CDD8 659B            	   360:   adc  token_digit
00:CDDA 8594            	   361:   sta  token_value
00:CDDC A900            	   362:   lda #0
00:CDDE 6595            	   363:   adc  token_value+1   ; increment next byte if necessary
00:CDE0 8595            	   364:   sta  token_value+1
00:CDE2 A900            	   365:   lda #0
00:CDE4 6596            	   366:   adc  token_value+2
00:CDE6 8596            	   367:   sta  token_value+2
00:CDE8 3003            	   368:   bmi  atoi_error
00:CDEA 4C87CD          	   369:   jmp  atoi_loop     ; onwards for next digit
                        	   370: 
                        	   371: atoi_error    =  *
00:CDED A53F            	   372:   lda  RUNNING
00:CDEF 1002            	   373:   bpl  atoi_not_running
00:CDF1 38              	   374:   sec             ; otherwise set carry and return
00:CDF2 60              	   375:   rts
                        	   376: atoi_not_running  =  *
00:CDF3 A21E            	   377:   ldx  #30       ; ERROR: Number out of Range
00:CDF5 4C4F9A          	   378:   jmp  ERROR
                        	   379: 
                        	   380: ;
                        	   381: ;  for negative numbers, subtract token_value from zero
                        	   382: ;
                        	   383: negate_token_value:
00:CDF8 38              	   384:   sec
00:CDF9 A900            	   385:   lda  #0
00:CDFB E594            	   386:   sbc  token_value
00:CDFD 8594            	   387:   sta  token_value
00:CDFF A900            	   388:   lda  #0
00:CE01 E595            	   389:   sbc  token_value+1
00:CE03 8595            	   390:   sta  token_value+1
00:CE05 A900            	   391:   lda  #0
00:CE07 E596            	   392:   sbc  token_value+2
00:CE09 8596            	   393:   sta  token_value+2
00:CE0B 60              	   394:   rts
                        	   395: 
                        	   396: 
                        	   397: gtoken_table:
                        	   398:   tknjmpItem '(',gc_lh_paren
00:CE0C 28              	     1M    dfb   '('
00:CE0D 54CE            	     2M    word  gc_lh_paren
                        	   399:   tknjmpItem '{',gc_lh_brace
00:CE0F 7B              	     1M    dfb   '{'
00:CE10 50CE            	     2M    word  gc_lh_brace
                        	   400:   tknjmpItem '"',gc_quote
00:CE12 22              	     1M    dfb   '"'
00:CE13 43CF            	     2M    word  gc_quote
                        	   401:   tknjmpItem SINGLE_QUOTE,gc_quote
00:CE15 27              	     1M    dfb   SINGLE_QUOTE
00:CE16 43CF            	     2M    word  gc_quote
                        	   402:   tknjmpItem '$',gc_dollar
00:CE18 24              	     1M    dfb   '$'
00:CE19 11D0            	     2M    word  gc_dollar
                        	   403:   tknjmpItem '%',gc_percent
00:CE1B 25              	     1M    dfb   '%'
00:CE1C 6BD0            	     2M    word  gc_percent
                        	   404:   tknjmpItem ':',gc_colon
00:CE1E 3A              	     1M    dfb   ':'
00:CE1F 95D0            	     2M    word  gc_colon
                        	   405:   tknjmpItem '<',gc_less_than
00:CE21 3C              	     1M    dfb   '<'
00:CE22 A6D0            	     2M    word  gc_less_than
                        	   406:   tknjmpItem '>',gc_greater_than
00:CE24 3E              	     1M    dfb   '>'
00:CE25 C9D0            	     2M    word  gc_greater_than
                        	   407:   tknjmpItem '-',gc_minus
00:CE27 2D              	     1M    dfb   '-'
00:CE28 E3D0            	     2M    word  gc_minus
                        	   408:   tknjmpItem '+',gc_plus
00:CE2A 2B              	     1M    dfb   '+'
00:CE2B E5D0            	     2M    word  gc_plus
                        	   409:   tknjmpItem '&',gc_ampersand
00:CE2D 26              	     1M    dfb   '&'
00:CE2E 04D1            	     2M    word  gc_ampersand
                        	   410:   tknjmpItem '|',gc_bar
00:CE30 7C              	     1M    dfb   '|'
00:CE31 15D1            	     2M    word  gc_bar
                        	   411:   tknjmpItem '=',gc_equals
00:CE33 3D              	     1M    dfb   '='
00:CE34 26D1            	     2M    word  gc_equals
                        	   412:   tknjmpItem '!',gc_bang
00:CE36 21              	     1M    dfb   '!'
00:CE37 37D1            	     2M    word  gc_bang
                        	   413:   tknjmpItem ';',gc_semicolon
00:CE39 3B              	     1M    dfb   ';'
00:CE3A 0ACF            	     2M    word  gc_semicolon
00:CE3C 00              	   414:   dfb        0   ; end of table
                        	   415: 
                        	   416: gtoken_directive_table:
                        	   417:   tknjmpItem 'S',gc_directive_symbols
00:CE3D 53              	     1M    dfb   'S'
00:CE3E BCCE            	     2M    word  gc_directive_symbols
                        	   418:   tknjmpItem 'L',gc_directive_list
00:CE40 4C              	     1M    dfb   'L'
00:CE41 F4CE            	     2M    word  gc_directive_list
                        	   419:   tknjmpItem 'P',gc_directive_pcodes
00:CE43 50              	     1M    dfb   'P'
00:CE44 FBCE            	     2M    word  gc_directive_pcodes
                        	   420:   tknjmpItem 'N',gc_directive_nolist
00:CE46 4E              	     1M    dfb   'N'
00:CE47 01CF            	     2M    word  gc_directive_nolist
00:CE49 00              	   421:   dfb        0
                        	   422: 
                        	   423: ; single byte token, in A
00:CE4A 4CD3CC          	   424: gc_single_byte_tokenJ jmp gc_single_byte_token
                        	   425: ; single byte token in token_type
00:CE4D 4CD1CC          	   426: gc_single_byte_already_knownJ jmp gc_single_byte_already_known
                        	   427: 
                        	   428: gc_lh_brace:
00:CE50 A000            	   429:   ldy #0
00:CE52 800E            	   430:   bra gc_pascal_comment
                        	   431: gc_lh_paren:
00:CE54 A902            	   432:   lda #FLAG_ASSEMBLING
00:CE56 25BE            	   433:   and system_flags
00:CE58 D0F3            	   434:   bne gc_single_byte_already_knownJ
00:CE5A A001            	   435:   ldy #1
00:CE5C B18E            	   436:   lda (token_start),Y
00:CE5E C92A            	   437:   cmp #'*'      ; was it: (* ?
00:CE60 D0EB            	   438:   bne gc_single_byte_already_knownJ  ; nope
                        	   439: 
                        	   440: ;
                        	   441: ;  Y will be 0 or 1 depending on the sort of starting comment
                        	   442: ;  first look for % which indicates a compiler directive
                        	   443: ;
                        	   444: gc_pascal_comment:
00:CE62 C8              	   445:   iny
00:CE63 B18E            	   446:   lda (token_start),Y
00:CE65 C925            	   447:   cmp #'%'   ; directive?
00:CE67 D018            	   448:   bne gc_pascal_comment_find_end
00:CE69 C8              	   449:   iny
00:CE6A B18E            	   450:   lda (token_start),Y ; get the directive: S, L, P or N
00:CE6C 48              	   451:   pha   ; save the directive for now
00:CE6D 98              	   452:   tya
                        	   453: ;
                        	   454: ;  make token_start point to where we are up to, so we can skip the comment, even if it is long
                        	   455: ;
00:CE6E 38              	   456:   sec               ; I actually want to be one past where the directive letter is
00:CE6F 658E            	   457:   adc token_start
00:CE71 858E            	   458:   sta token_start
00:CE73 A900            	   459:   lda #0
00:CE75 658F            	   460:   adc token_start+1
00:CE77 858F            	   461:   sta token_start+1
00:CE79 68              	   462:   pla   ; get the directive back
00:CE7A A23D            	   463:   ldx #<gtoken_directive_table
00:CE7C A0CE            	   464:   ldy #>gtoken_directive_table
00:CE7E 207692          	   465:   jsr TKNJMP  ; do the directive handler
                        	   466: ;
                        	   467: ;  fall through if not found and just find the end of the comment
                        	   468: ;
                        	   469: 
                        	   470: gc_pascal_comment_find_end:
00:CE81 A000            	   471:   ldy #0    ; we normalised token_start to be where we want to start
00:CE83 B18E            	   472:   lda (token_start),Y
00:CE85 D005            	   473:   bne gc_comment_not_eof
00:CE87 A207            	   474:   ldx  #7           ; NO } FOUND
00:CE89 4C4F9A          	   475:   jmp  ERROR
                        	   476: gc_comment_not_eof:
00:CE8C C90A            	   477:   cmp #NL
00:CE8E D005            	   478:   bne gc_comment_not_newline
00:CE90 202FCD          	   479:   jsr token_line    ; handle the newline (we can't be assembling or we wouldn't be here)
00:CE93 800F            	   480:   bra gc_comment_keep_looking
                        	   481: gc_comment_not_newline:
00:CE95 C97D            	   482:   cmp #'}'
00:CE97 F013            	   483:   beq gc_comment_found_end
00:CE99 C92A            	   484:   cmp #'*'
00:CE9B D007            	   485:   bne gc_comment_keep_looking
00:CE9D C8              	   486:   iny
00:CE9E B18E            	   487:   lda (token_start),Y
00:CEA0 C929            	   488:   cmp #')'
00:CEA2 F008            	   489:   beq gc_comment_found_end
                        	   490: 
                        	   491: ;
                        	   492: ;  skip this byte and keep looking for the end of comment
                        	   493: ;
                        	   494: gc_comment_keep_looking:
00:CEA4 E68E            	   495:   inc token_start
00:CEA6 D0D9            	   496:   bne gc_pascal_comment_find_end
00:CEA8 E68F            	   497:   inc token_start+1
00:CEAA 80D5            	   498:   bra gc_pascal_comment_find_end
                        	   499: 
                        	   500: ;
                        	   501: ;  found end of comment, so move token_start to this character
                        	   502: ;   (the one past the end of the comment) and try again for a token
                        	   503: ;
                        	   504: gc_comment_found_end:
00:CEAC C8              	   505:   iny   ; get past end of comment
00:CEAD 98              	   506:   tya
00:CEAE 18              	   507:   clc
00:CEAF 658E            	   508:   adc token_start
00:CEB1 858E            	   509:   sta token_start
00:CEB3 A900            	   510:   lda #0
00:CEB5 658F            	   511:   adc token_start+1
00:CEB7 858F            	   512:   sta token_start+1
00:CEB9 4C93CC          	   513:   jmp get_token_loop
                        	   514: 
                        	   515: ;
                        	   516: ;  {%S $nnnn}
                        	   517: ;  symbol table relocation
                        	   518: ;
                        	   519: gc_directive_symbols:
00:CEBC 2093CC          	   520:    jsr  get_token_loop     ; re-call get_token to find the address
00:CEBF C94E            	   521:    cmp  #TOKEN_NUMBER ; number?
00:CEC1 F005            	   522:    beq  gc_directive_symbols_ok      ; yes
00:CEC3 A202            	   523:    ldx  #2
00:CEC5 4C4F9A          	   524:    jmp  ERROR      ; 'Constant expected'
                        	   525: 
                        	   526: gc_directive_symbols_ok:
                        	   527:   ;
                        	   528:   ;  check we haven't generated any code
                        	   529:   ;
00:CEC8 A523            	   530:   lda PCODE
00:CECA C525            	   531:   cmp ACT_PCDA
00:CECC D021            	   532:   bne gc_directive_symbols_too_late
00:CECE A524            	   533:   lda PCODE+1
00:CED0 C526            	   534:   cmp ACT_PCDA+1
00:CED2 D01B            	   535:   bne gc_directive_symbols_too_late
                        	   536: 
00:CED4 A594            	   537:   lda  token_value
00:CED6 8531            	   538:   sta  ENDSYM
00:CED8 852F            	   539:   sta  STARTSYM
00:CEDA 852B            	   540:   sta  OPND
00:CEDC A595            	   541:   lda  token_value+1
00:CEDE 8532            	   542:   sta  ENDSYM+1        ; store symbol table address
00:CEE0 8530            	   543:   sta  STARTSYM+1
00:CEE2 852C            	   544:   sta  OPND+1
00:CEE4 A901            	   545:   lda  #PCODE_STACK    ; change runtime stack
00:CEE6 20EACA          	   546:   jsr  GENJMP
                        	   547: ;
                        	   548: ;  put the library functions back
                        	   549: ;
00:CEE9 20B7C9          	   550:   jsr  add_pascal_library_functions
                        	   551: 
00:CEEC 4C81CE          	   552:   jmp  gc_pascal_comment_find_end     ; go back and find the end of the comment
                        	   553: ;
                        	   554: 
                        	   555: gc_directive_symbols_too_late:
00:CEEF A233            	   556:   ldx #51        ; code already generated
00:CEF1 4C4F9A          	   557:   JMP  ERROR
                        	   558: 
                        	   559: 
                        	   560: ;
                        	   561: ;  {%L} - list source
                        	   562: ;
                        	   563: gc_directive_list:
00:CEF4 A904            	   564:   lda #FLAG_LIST_SOURCE
00:CEF6 04BE            	   565:   tsb system_flags
00:CEF8 4C81CE          	   566:   jmp gc_pascal_comment_find_end
                        	   567: 
                        	   568: ;
                        	   569: ;  {%P} - list source and P-codes
                        	   570: ;
                        	   571: gc_directive_pcodes:
00:CEFB A901            	   572:   lda #1
00:CEFD 852E            	   573:   sta DCODE
00:CEFF 80F3            	   574:   bra gc_directive_list   ; also list source
                        	   575: ;
                        	   576: ;  {%N} - do not list source or P-codes
                        	   577: ;
                        	   578: gc_directive_nolist:
00:CF01 A904            	   579:   lda #FLAG_LIST_SOURCE
00:CF03 14BE            	   580:   trb system_flags    ; clear both of the above flags
00:CF05 642E            	   581:   stz DCODE
00:CF07 4C81CE          	   582:   jmp gc_pascal_comment_find_end
                        	   583: 
                        	   584: ;
                        	   585: ;  semicolons start comments in the assembler
                        	   586: ;
                        	   587: gc_semicolon:
00:CF0A A902            	   588:   lda #FLAG_ASSEMBLING
00:CF0C 25BE            	   589:   and system_flags
00:CF0E D003            	   590:   bne gc_assembler_comment_find_end
00:CF10 4CD1CC          	   591:   jmp gc_single_byte_already_known
                        	   592: 
                        	   593: gc_assembler_comment_find_end:
00:CF13 A000            	   594:   ldy #0
00:CF15 B18E            	   595:   lda (token_start),Y
00:CF17 D005            	   596:   bne gc_assembler_comment_not_eof
00:CF19 A90A            	   597:   lda #NL
00:CF1B 8593            	   598:   sta token_type
00:CF1D 60              	   599:   rts     ; exit without incrementing token_start
                        	   600: 
                        	   601: gc_assembler_comment_not_eof:
00:CF1E C90A            	   602:   cmp #NL
00:CF20 D003            	   603:   bne gc_assembler_comment_keep_looking
00:CF22 4CD3CC          	   604:   jmp gc_single_byte_token
                        	   605: ;
                        	   606: ;  skip this byte and keep looking for the newline at the end of comment
                        	   607: ;
                        	   608: gc_assembler_comment_keep_looking:
00:CF25 E68E            	   609:   inc token_start
00:CF27 D0EA            	   610:   bne gc_assembler_comment_find_end
00:CF29 E68F            	   611:   inc token_start+1
00:CF2B 80E6            	   612:   bra gc_assembler_comment_find_end
                        	   613: 
                        	   614: 
                        	   615: gc_backslash_tokens:
00:CF2D 41              	   616:          DFB  'A',$07  ; bell ($07)
00:CF2E 07
00:CF2F 42              	   617:          DFB  'B',$08  ; backspace ($08)
00:CF30 08
00:CF31 45              	   618:          DFB  'E',$1B  ; escape  (0x1B)
00:CF32 1B
00:CF33 46              	   619:          DFB  'F',$0C  ; formfeed ($0C)
00:CF34 0C
00:CF35 4E              	   620:          DFB  'N',$0A  ; newline  (0x0A)
00:CF36 0A
00:CF37 52              	   621:          DFB  'R',$0D  ; carriage return (0x0D)
00:CF38 0D
00:CF39 54              	   622:          DFB  'T',$09  ; horizontal tab (0x09)
00:CF3A 09
00:CF3B 56              	   623:          DFB  'V',$0B  ; vertical tab (0x0B)
00:CF3C 0B
00:CF3D 5C              	   624:          DFB  $5C,$5C  ; backslash
00:CF3E 5C
00:CF3F 22              	   625:          DFB  '"','"'  ; double quote
00:CF40 22
00:CF41 27              	   626:          DFB  SINGLE_QUOTE,SINGLE_QUOTE  ; single quote
00:CF42 27
                        	   627: gc_backslash_tokens_end = *
                        	   628: gc_backslash_tokens_length = gc_backslash_tokens_end - gc_backslash_tokens
                        	   629: 
                        	   630: ;
                        	   631: ;  quoted string
                        	   632: ;
                        	   633: ;  resolve double quotes and backslash sequences and store it in INBUF
                        	   634: ;
                        	   635: ;
                        	   636: gc_quote:
00:CF43 8598            	   637:   sta token_work    ; remember which sort
00:CF45 A000            	   638:   ldy #0            ; back to the start
00:CF47 6492            	   639:   stz token_length  ; zero-length string so far
00:CF49 A58E            	   640:   lda token_start
00:CF4B 8590            	   641:   sta token_address   ; save the starting address of the token (not that it matters too much)
00:CF4D A58F            	   642:   lda token_start+1   ; repeat for high-order byte
00:CF4F 8591            	   643:   sta token_address+1
                        	   644: 
                        	   645: gc_quote_loop:
00:CF51 C8              	   646:   iny                 ; onto next character
00:CF52 B18E            	   647:   lda (token_start),Y ; get the next character in the string
00:CF54 F004            	   648:   beq gc_quote_bad
00:CF56 C90A            	   649:   cmp  #NL
00:CF58 D005            	   650:   bne  gc_quote_loop_not_end_of_line
                        	   651: 
                        	   652: gc_quote_bad:
00:CF5A A208            	   653:   ldx  #8         ; MISSING QUOTE: Incorrect string
00:CF5C 4C4F9A          	   654:   jmp  ERROR
                        	   655: 
                        	   656: gc_quote_loop_not_end_of_line:
00:CF5F C598            	   657:   cmp  token_work  ; same as start quote?
00:CF61 D037            	   658:   bne  gc_quote_not_finished       ; no
00:CF63 C8              	   659:   iny
00:CF64 B18E            	   660:   lda (token_start),Y ; see if another quote follows
00:CF66 C598            	   661:   cmp  token_work
00:CF68 F05A            	   662:   beq  gc_quote_not_backslash      ; embedded quote (ie. two quotes in a row)? Store a single quote symbol
                        	   663:   ;
                        	   664:   ;  here at end of quoted string
                        	   665:   ;
00:CF6A 8498            	   666:   sty  token_work  ; remember how far through our input we are
00:CF6C A003            	   667:   ldy  #3          ; OK, we have the final quote, so is the string <= 3 characters long?
00:CF6E C492            	   668:   cpy  token_length
00:CF70 9002            	   669:   bcc  gc_quote_long_string   ; BLT - no
00:CF72 A492            	   670:   ldy  token_length           ; yes - load its actual length into Y (ie. 0, 1, 2, 3)
                        	   671: gc_quote_long_string:
00:CF74 88              	   672:   dey      ; zero-relative
00:CF75 3008            	   673:   bmi  gc_quote_copied_value   ; keep going into the length done
00:CF77 B90002          	   674:   lda  INBUF,Y   ; store the (up to) 3 bytes into VALUE as the token value
00:CF7A 999400          	   675:   sta  token_value,Y
00:CF7D D0F5            	   676:   bne  gc_quote_long_string   ; keep going until we hit the 0x00 at the end
                        	   677: 
                        	   678: gc_quote_copied_value:
00:CF7F A592            	   679:   lda  token_length    ; now see how long it is?
00:CF81 D005            	   680:   bne  gc_quote_done     ; don't allow zero length strings
00:CF83 A20E            	   681:   ldx  #14        ; BAD STRING: literal string of zero length
00:CF85 4C4F9A          	   682:   jmp  ERROR
                        	   683: 
                        	   684: gc_quote_done:
00:CF88 18              	   685:   clc
00:CF89 A58E            	   686:   lda token_start       ; bump up our token_start address to past the quoted string
00:CF8B 6598            	   687:   adc token_work        ; now add its (actual) length, not the length afer mucking around
00:CF8D 858E            	   688:   sta token_start       ; that gives the ending address
00:CF8F A58F            	   689:   lda token_start+1   ; repeat for high-order byte
00:CF91 6900            	   690:   adc #0
00:CF93 858F            	   691:   sta token_start+1
00:CF95 A922            	   692:   lda  #TOKEN_STRING   ; it's a string token
00:CF97 8593            	   693:   sta  token_type
00:CF99 60              	   694:   rts
                        	   695: 
                        	   696: 
                        	   697: gc_quote_not_finished:
00:CF9A C95C            	   698:   cmp #$5C    ; backslash?
00:CF9C D026            	   699:   bne  gc_quote_not_backslash
                        	   700: ;
                        	   701: ;  backslash - see what follows
                        	   702: ;
00:CF9E C8              	   703:   iny
00:CF9F B18E            	   704:   lda (token_start),Y ; the character after the backslash
00:CFA1 F0B7            	   705:   beq gc_quote_bad    ; nothing? bad
00:CFA3 20A892          	   706:   jsr MAKE_UPPER
00:CFA6 C958            	   707:   cmp #'X'
00:CFA8 F038            	   708:   beq gc_quote_hex_character
00:CFAA A200            	   709:   ldx #0
                        	   710: gc_quote_backslash_loop:
00:CFAC DD2DCF          	   711:   cmp gc_backslash_tokens,X
00:CFAF F00F            	   712:   beq gc_quote_found_backslash_character   ; good match
00:CFB1 E8              	   713:   inx
00:CFB2 E8              	   714:   inx
00:CFB3 E016            	   715:   cpx #gc_backslash_tokens_length
00:CFB5 90F5            	   716:   bcc gc_quote_backslash_loop
                        	   717: gc_quote_bad_string:
00:CFB7 A208            	   718:   ldx #8
00:CFB9 4C4F9A          	   719:   jmp ERROR   ; ERROR: Incorrect string
                        	   720: 
                        	   721: gc_quote_hex_character_done:
00:CFBC A594            	   722:   lda token_value
00:CFBE 8004            	   723:   bra gc_quote_not_backslash
                        	   724: 
                        	   725: gc_quote_found_backslash_character:
00:CFC0 E8              	   726:   inx
00:CFC1 BD2DCF          	   727:   lda gc_backslash_tokens,X  ; get its replacement
                        	   728: 
                        	   729: gc_quote_not_backslash:
00:CFC4 A692            	   730:   ldx  token_length
00:CFC6 9D0002          	   731:   sta  INBUF,x           ; store it in INBUF
00:CFC9 E692            	   732:   inc  token_length
00:CFCB F003            	   733:   beq  gc_quote_too_long
00:CFCD 4C51CF          	   734:   jmp  gc_quote_loop     ; keep adding to string
                        	   735: 
                        	   736: 
                        	   737: gc_quote_too_long:
                        	   738:   ;            string over 255 characters long - error!
00:CFD0 A21D            	   739:   ldx   #29  ; ERROR: string literal too big
00:CFD2 4C4F9A          	   740:   jmp  ERROR
                        	   741: 
                        	   742: ;
                        	   743: ;  "fix" a hex digit by making it upper-case, then subtracting 7 if it is A-F
                        	   744: ;   then subtracting '0' so we get a number in the range 0x00 to 0x0F in A
                        	   745: ;
                        	   746: gc_fix_hex:
00:CFD5 20A892          	   747:   jsr  MAKE_UPPER
00:CFD8 C941            	   748:   cmp  #'A'
00:CFDA 9002            	   749:   bcc  gc_fix_hex_not_a_to_f
00:CFDC E907            	   750:   sbc  #7
                        	   751: gc_fix_hex_not_a_to_f:
00:CFDE 38              	   752:   sec
00:CFDF E930            	   753:   sbc  #'0'
00:CFE1 60              	   754:   rts
                        	   755: 
                        	   756: gc_quote_hex_character:
00:CFE2 C8              	   757:   iny
00:CFE3 F0EB            	   758:   beq  gc_quote_too_long
00:CFE5 B18E            	   759:   lda  (token_start),Y ; the character after the backslash
00:CFE7 203E81          	   760:   jsr  isxdigit
00:CFEA 90CB            	   761:   bcc  gc_quote_bad_string  ; what? should be hex
00:CFEC 20D5CF          	   762:   jsr  gc_fix_hex
00:CFEF 8594            	   763:   sta  token_value  ; first nibble
00:CFF1 C8              	   764:   iny
00:CFF2 F0DC            	   765:   beq  gc_quote_too_long
00:CFF4 B18E            	   766:   lda  (token_start),Y ; a second hex character?
00:CFF6 F0BF            	   767:   beq  gc_quote_bad_string
00:CFF8 203E81          	   768:   jsr  isxdigit
00:CFFB 9011            	   769:   bcc  gc_quote_hex_character_one_only
00:CFFD 20D5CF          	   770:   jsr  gc_fix_hex
00:D000 0694            	   771:   asl  token_value    ; shift existing value 4 bits left
00:D002 0694            	   772:   asl  token_value
00:D004 0694            	   773:   asl  token_value
00:D006 0694            	   774:   asl  token_value
00:D008 0594            	   775:   ora  token_value
00:D00A 8594            	   776:   sta  token_value
00:D00C 80AE            	   777:   bra  gc_quote_hex_character_done
                        	   778: 
                        	   779: gc_quote_hex_character_one_only:
00:D00E 88              	   780:   dey         ; undo add since we didn't find another hex character
00:D00F 80AB            	   781:   bra gc_quote_hex_character_done
                        	   782: 
                        	   783: ;
                        	   784: ;  $nnnnnn where nnnnnn is one or more hex digits
                        	   785: ;    if no hex digits, then it is the token '$'
                        	   786: ;
                        	   787: gc_dollar:
00:D011 A001            	   788:   ldy  #1    ; start with the character after the dollar
00:D013 B18E            	   789:   lda  (token_start),Y ; followed by a hex character?
00:D015 203E81          	   790:   jsr  isxdigit
00:D018 B003            	   791:   bcs  gc_hex_literal
00:D01A 4CD1CC          	   792:   jmp  gc_single_byte_already_known
                        	   793: 
                        	   794: gc_hex_literal:
00:D01D 20D5CF          	   795:   jsr gc_fix_hex
00:D020 8594            	   796:   sta token_value       ; store the first digit
00:D022 6495            	   797:   stz token_value+1
00:D024 6496            	   798:   stz token_value+2
                        	   799: gc_hex_loop:
00:D026 C8              	   800:   iny
00:D027 B18E            	   801:   lda (token_start),Y ; followed by another hex character?
00:D029 203E81          	   802:   jsr isxdigit
00:D02C 9033            	   803:   bcc gc_hex_done
00:D02E 20D5CF          	   804:   jsr gc_fix_hex
                        	   805: ;
                        	   806: ;  shift the existing value left 4 bits to make room for the new nibble
                        	   807: ;
00:D031 0694            	   808:   asl  token_value        ; token_value shifted left 1 bit
00:D033 2695            	   809:   rol  token_value+1
00:D035 2696            	   810:   rol  token_value+2
00:D037 B02D            	   811:   bcs  gc_hex_too_big
00:D039 0694            	   812:   asl  token_value        ; token_value shifted left 2 bits
00:D03B 2695            	   813:   rol  token_value+1
00:D03D 2696            	   814:   rol  token_value+2
00:D03F B025            	   815:   bcs  gc_hex_too_big
00:D041 0694            	   816:   asl  token_value        ; token_value shifted left 3 bits
00:D043 2695            	   817:   rol  token_value+1
00:D045 2696            	   818:   rol  token_value+2
00:D047 B01D            	   819:   bcs  gc_hex_too_big
00:D049 0694            	   820:   asl  token_value        ; token_value shifted left 4 bits
00:D04B 2695            	   821:   rol  token_value+1
00:D04D 2696            	   822:   rol  token_value+2
00:D04F B015            	   823:   bcs  gc_hex_too_big
00:D051 6594            	   824:   adc  token_value        ; now add in this last digit (carry will be clear)
00:D053 8594            	   825:   sta  token_value        ; store the new result
00:D055 90CF            	   826:   bcc  gc_hex_loop
00:D057 E695            	   827:   inc  token_value+1
00:D059 90CB            	   828:   bcc  gc_hex_loop
00:D05B E695            	   829:   inc  token_value+1
00:D05D B007            	   830:   bcs  gc_hex_too_big
00:D05F 80C5            	   831:   bra  gc_hex_loop
                        	   832: 
                        	   833: gc_hex_done:
00:D061 A94E            	   834:   lda #TOKEN_NUMBER
00:D063 4CD5CC          	   835:   jmp gc_done
                        	   836: 
                        	   837: gc_hex_too_big:
00:D066 A21E            	   838:   ldx  #30       ; ERROR: Number out of Range
00:D068 4C4F9A          	   839:   jmp  ERROR
                        	   840: 
                        	   841: ;
                        	   842: ;  %nnnnnn where nnnnnn is one or more binary digits
                        	   843: ;    if no binary digits, then it is the token '%'
                        	   844: ;
                        	   845: 
                        	   846: gc_percent:
00:D06B A001            	   847:   ldy  #1    ; start with the character after the %
00:D06D B18E            	   848:   lda  (token_start),Y ; followed by a binary character?
00:D06F 206E81          	   849:   jsr  isbinary
00:D072 B003            	   850:   bcs  gc_binary_literal
00:D074 4CD1CC          	   851:   jmp  gc_single_byte_already_known
                        	   852: 
                        	   853: gc_binary_literal:
00:D077 E930            	   854:   sbc #'0'              ; we know carry is set
00:D079 8594            	   855:   sta token_value       ; store the first digit
00:D07B 6495            	   856:   stz token_value+1
00:D07D 6496            	   857:   stz token_value+2
                        	   858: gc_binary_loop:
00:D07F C8              	   859:   iny
00:D080 B18E            	   860:   lda (token_start),Y ; followed by another binary character?
00:D082 206E81          	   861:   jsr isbinary
00:D085 90DA            	   862:   bcc gc_hex_done
00:D087 E930            	   863:   sbc #'0'              ; we know carry is set
                        	   864: 
00:D089 6A              	   865:   ror A   ; get the new bit into Carry
00:D08A 2694            	   866:   rol token_value
00:D08C 2695            	   867:   rol token_value+1
00:D08E 2696            	   868:   rol token_value+2
00:D090 90ED            	   869:   bcc gc_binary_loop
00:D092 4C66D0          	   870:   jmp gc_hex_too_big   ; number too large
                        	   871: 
                        	   872: ;
                        	   873: ;  token : might be :=
                        	   874: ;
                        	   875: gc_colon:
00:D095 A001            	   876:   ldy  #1               ; get the next character
00:D097 B18E            	   877:   lda  (token_start),Y  ; followed by = ?
00:D099 C93D            	   878:   cmp  #'='
00:D09B F003            	   879:   beq  gc_assign
00:D09D 4CD1CC          	   880:   jmp  gc_single_byte_already_known
                        	   881: 
                        	   882: gc_assign:
00:D0A0 A941            	   883:   lda #TOKEN_ASSIGN
00:D0A2 C8              	   884:   iny
00:D0A3 4CD5CC          	   885:   jmp gc_done
                        	   886: 
                        	   887: ;
                        	   888: ;  token: < might be <=, <>, <<
                        	   889: ;
                        	   890: gc_less_than:
00:D0A6 A001            	   891:   ldy  #1               ; get the next character
00:D0A8 B18E            	   892:   lda  (token_start),Y  ; followed by = ?
00:D0AA C8              	   893:   iny                   ; make it a 2-byte token
00:D0AB C93D            	   894:   cmp  #'='
00:D0AD F00B            	   895:   beq  gc_leq
00:D0AF C93E            	   896:   cmp  #'>'
00:D0B1 F00C            	   897:   beq  gc_neq
00:D0B3 C93C            	   898:   cmp  #'<'
00:D0B5 F00D            	   899:   beq  gc_shift_left
00:D0B7 4CD1CC          	   900:   jmp  gc_single_byte_already_known
                        	   901: 
                        	   902: gc_leq:
00:D0BA A980            	   903:   lda #TOKEN_LEQ
00:D0BC 4CD5CC          	   904:   jmp gc_done
                        	   905: 
                        	   906: gc_neq:
00:D0BF A955            	   907:   lda #TOKEN_NEQ
00:D0C1 4CD5CC          	   908:   jmp gc_done
                        	   909: 
                        	   910: gc_shift_left:
00:D0C4 A94C            	   911:   lda #TOKEN_SHIFT_LEFT
00:D0C6 4CD5CC          	   912:   jmp gc_done
                        	   913: 
                        	   914: ;
                        	   915: ;  token: > might be <>=, >>
                        	   916: ;
                        	   917: gc_greater_than:
00:D0C9 A001            	   918:   ldy  #1               ; get the next character
00:D0CB B18E            	   919:   lda  (token_start),Y  ; followed by = ?
00:D0CD C8              	   920:   iny                   ; make it a 2-byte token
00:D0CE C93D            	   921:   cmp  #'='
00:D0D0 F007            	   922:   beq  gc_geq
00:D0D2 C93E            	   923:   cmp  #'>'
00:D0D4 F008            	   924:   beq  gc_shift_right
                        	   925: 
                        	   926: gc_single_byte_already_knownJ2:
00:D0D6 4CD1CC          	   927:   jmp  gc_single_byte_already_known
                        	   928: 
                        	   929: gc_geq:
00:D0D9 A981            	   930:   lda #TOKEN_GEQ
00:D0DB 4CD5CC          	   931:   jmp gc_done
                        	   932: 
                        	   933: gc_shift_right:
00:D0DE A952            	   934:   lda #TOKEN_SHIFT_RIGHT
00:D0E0 4CD5CC          	   935:   jmp gc_done
                        	   936: 
                        	   937: 
                        	   938: ;
                        	   939: ;  minus and plus sign
                        	   940: ;
                        	   941: 
                        	   942: gc_minus:
00:D0E3 8597            	   943:   sta token_sign
                        	   944: gc_plus:
                        	   945: 
                        	   946: ;
                        	   947: ;  new stuff - treat a sign as a token on its own if the previous token was one of:
                        	   948: ;    a) a number
                        	   949: ;    b) an identifier
                        	   950: ;    c) a RH bracket
                        	   951: ;
                        	   952: ;  So, for example: 2+3 is three tokens, but 2+-5 is also three, as the -5 becomes one token
                        	   953: ;
00:D0E5 A598            	   954:   lda  token_work            ; saved previous token on entry to get_token
00:D0E7 C94E            	   955:   cmp  #TOKEN_NUMBER
00:D0E9 F0EB            	   956:   beq  gc_single_byte_already_knownJ2
00:D0EB C949            	   957:   cmp  #TOKEN_IDENTIFIER
00:D0ED F0E7            	   958:   beq  gc_single_byte_already_knownJ2
00:D0EF C929            	   959:   cmp  #')'
00:D0F1 F0E3            	   960:   beq  gc_single_byte_already_knownJ2
                        	   961: ;
                        	   962: ;  if not, see if this is a signed number (ie. it is directly followed by a digit)
                        	   963: ;
00:D0F3 A001            	   964:   ldy  #1               ; get the next character
00:D0F5 B18E            	   965:   lda  (token_start),Y  ; followed by a digit?
00:D0F7 203281          	   966:   jsr  isdigit
00:D0FA 90DA            	   967:   bcc  gc_single_byte_already_knownJ2
00:D0FC 207ECD          	   968:   jsr atoi
00:D0FF A94E            	   969:   lda  #TOKEN_NUMBER
00:D101 4CD5CC          	   970:   jmp  gc_done
                        	   971: 
                        	   972: 
                        	   973: ;
                        	   974: ;  token: & might be &&
                        	   975: ;
                        	   976: gc_ampersand:
00:D104 A001            	   977:   ldy  #1               ; get the next character
00:D106 B18E            	   978:   lda  (token_start),Y  ; followed by & ?
00:D108 C926            	   979:   cmp  #'&'
00:D10A F003            	   980:   beq  gc_logical_and
00:D10C 4CD1CC          	   981:   jmp  gc_single_byte_already_known
                        	   982: 
                        	   983: gc_logical_and:
00:D10F A958            	   984:   lda #TOKEN_LOGICAL_AND
00:D111 C8              	   985:   iny
00:D112 4CD5CC          	   986:   jmp gc_done
                        	   987: 
                        	   988: ;
                        	   989: ;  token: | might be ||
                        	   990: ;
                        	   991: gc_bar:
00:D115 A001            	   992:   ldy  #1               ; get the next character
00:D117 B18E            	   993:   lda  (token_start),Y  ; followed by | ?
00:D119 C97C            	   994:   cmp  #'|'
00:D11B F003            	   995:   beq  gc_logical_or
00:D11D 4CD1CC          	   996:   jmp  gc_single_byte_already_known
                        	   997: 
                        	   998: gc_logical_or:
00:D120 A959            	   999:   lda #TOKEN_LOGICAL_OR
00:D122 C8              	  1000:   iny
00:D123 4CD5CC          	  1001:   jmp gc_done
                        	  1002: 
                        	  1003: ;
                        	  1004: ;  token: = might be ==
                        	  1005: ;
                        	  1006: gc_equals:
00:D126 A001            	  1007:   ldy  #1               ; get the next character
00:D128 B18E            	  1008:   lda  (token_start),Y  ; followed by = ?
00:D12A C93D            	  1009:   cmp  #'='
00:D12C F003            	  1010:   beq  gc_equality
00:D12E 4CD1CC          	  1011:   jmp  gc_single_byte_already_known
                        	  1012: 
                        	  1013: gc_equality:
00:D131 A945            	  1014:   lda #TOKEN_EQUALITY
00:D133 C8              	  1015:   iny
00:D134 4CD5CC          	  1016:   jmp gc_done
                        	  1017: 
                        	  1018: ;
                        	  1019: ;  token: ! might be !=
                        	  1020: ;
                        	  1021: gc_bang:
00:D137 A001            	  1022:   ldy  #1               ; get the next character
00:D139 B18E            	  1023:   lda  (token_start),Y  ; followed by = ?
00:D13B C93D            	  1024:   cmp  #'='
00:D13D F003            	  1025:   beq  gc_inequality
00:D13F 4CD1CC          	  1026:   jmp  gc_single_byte_already_known
                        	  1027: 
                        	  1028: gc_inequality:
00:D142 A95A            	  1029:   lda #TOKEN_INEQUALITY
00:D144 C8              	  1030:   iny
00:D145 4CD5CC          	  1031:   jmp gc_done
                        	  1032: 
                        	  1033: 
                        	  1034: 
                        	  1035: ; Pascal tokens
                        	  1036: 
                        	  1037: TOKEN_CONST     = $82
                        	  1038: TOKEN_VAR       = $83
                        	  1039: TOKEN_ARRAY     = $84
                        	  1040: TOKEN_OF        = $85
                        	  1041: TOKEN_PROCEDURE = $86
                        	  1042: TOKEN_FUNCTION  = $87
                        	  1043: TOKEN_BEGIN     = $88
                        	  1044: TOKEN_END       = $89
                        	  1045: TOKEN_OR        = $8A
                        	  1046: TOKEN_DIV       = $8B
                        	  1047: TOKEN_MOD       = $8C
                        	  1048: TOKEN_AND       = $8D
                        	  1049: TOKEN_SHL       = $8E
                        	  1050: TOKEN_SHR       = $8F
                        	  1051: TOKEN_NOT       = $90
                        	  1052: TOKEN_MEM       = $91
                        	  1053: TOKEN_IF        = $92
                        	  1054: TOKEN_THEN      = $93
                        	  1055: TOKEN_ELSE      = $94
                        	  1056: TOKEN_CASE      = $95
                        	  1057: TOKEN_WHILE     = $96
                        	  1058: TOKEN_DO        = $97
                        	  1059: TOKEN_REPEAT    = $98
                        	  1060: TOKEN_UNTIL     = $99
                        	  1061: TOKEN_FOR       = $9A
                        	  1062: TOKEN_TO        = $9B
                        	  1063: TOKEN_DOWNTO    = $9C
                        	  1064: TOKEN_WRITE     = $9D
                        	  1065: TOKEN_READ      = $9E
                        	  1066: TOKEN_CALL      = $9F
                        	  1067: TOKEN_CHAR      = $A1
                        	  1068: TOKEN_MEMC      = $A2
                        	  1069: TOKEN_XOR       = $A4
                        	  1070: TOKEN_ADDRESS   = $A9
                        	  1071: TOKEN_CHR       = $AB
                        	  1072: TOKEN_HEX       = $AC
                        	  1073: ; $B0 to $DE used by message tokens
                        	  1074: TOKEN_LCDWRITE  = $F1
                        	  1075: TOKEN_INTEGER   = $FE
                        	  1076: TOKEN_WRITELN   = $FF
                        	  1077: 
                        	  1078: 
                        	  1079: 
                        	  1080: ; RESERVED WORD TABLE
                        	  1081: ;
                        	  1082: ;***********************************************
                        	  1083:          .macro makeToken  ; MACRO DEFINITION FOR TOKENS: Length, token number, token name
                        	  1084:          DFB  \1
                        	  1085:          DFB  \2
                        	  1086:          text  \3
                        	  1087:          .endmacro           ; END OF MACRO
                        	  1088: 
                        	  1089: ;
                        	  1090: ; Reserved words are identified internally by their code (eg. $86 for PROCEDURE)
                        	  1091: ;
                        	  1092: ;  They are also stored "tokenised" and expanded out when you list the source
                        	  1093: ;
                        	  1094: ; Other tokens are:
                        	  1095: ;  * Punctuation (eg. "<", ">", "=", ".", "(", ")", "$", "+", "-"
                        	  1096: ;  * Identifiers: "I"        (eg. MY_VARIABLE)
                        	  1097: ;  * Constant numbers: "N"   (eg. -1234 and $1234)
                        	  1098: ;  * Literal strings:  '"' (quote symbol)  (eg. "Nick")
                        	  1099: ;  * Double-character punctuation:
                        	  1100: ;       <= : $80
                        	  1101: ;       >= : $81
                        	  1102: ;       Unequal (<>) : "U"
                        	  1103: ;       Assignment (:=) : "A"
                        	  1104: ;
                        	  1105: ; Comments are skipped: (* some comment *)
                        	  1106: ;
                        	  1107: ;
                        	  1108: ; However comments can have compiler directives embedded, eg. (*%A $4000) - put P-codes at $4000
                        	  1109: ;    (*%L*) - list during compile
                        	  1110: ;    (*%N*) - stop listing during compile (cancels %L and %P)
                        	  1111: ;    (*%P*) - show P-codes during compile
                        	  1112: ;    (*%A  $nnnn *) - put P-codes at address $nnnn - must be at START of program
                        	  1113: ;
                        	  1114: ;
                        	  1115: 
                        	  1116: ;              Length   Code             Name
                        	  1117: ;                  --   --------------- ---------------
                        	  1118: RSVWRD   =  *
                        	  1119:    makeToken   5, TOKEN_CONST     ,"CONST"
00:D148 05              	     1M          DFB  5
00:D149 82              	     2M          DFB  TOKEN_CONST     
00:D14A 434F4E5354      	     3M          text  "CONST"
                        	  1120:    makeToken   3, TOKEN_VAR       ,"VAR"
00:D14F 03              	     1M          DFB  3
00:D150 83              	     2M          DFB  TOKEN_VAR       
00:D151 564152          	     3M          text  "VAR"
                        	  1121:    makeToken   5, TOKEN_ARRAY     ,"ARRAY"
00:D154 05              	     1M          DFB  5
00:D155 84              	     2M          DFB  TOKEN_ARRAY     
00:D156 4152524159      	     3M          text  "ARRAY"
                        	  1122:    makeToken   2, TOKEN_OF        ,"OF"
00:D15B 02              	     1M          DFB  2
00:D15C 85              	     2M          DFB  TOKEN_OF        
00:D15D 4F46            	     3M          text  "OF"
                        	  1123:    makeToken   9, TOKEN_PROCEDURE ,"PROCEDURE"
00:D15F 09              	     1M          DFB  9
00:D160 86              	     2M          DFB  TOKEN_PROCEDURE 
00:D161 50524F4345445552	     3M          text  "PROCEDURE"
00:D169 45
                        	  1124:    makeToken   8, TOKEN_FUNCTION  ,"FUNCTION"
00:D16A 08              	     1M          DFB  8
00:D16B 87              	     2M          DFB  TOKEN_FUNCTION  
00:D16C 46554E4354494F4E	     3M          text  "FUNCTION"
                        	  1125:    makeToken   5, TOKEN_BEGIN     ,"BEGIN"
00:D174 05              	     1M          DFB  5
00:D175 88              	     2M          DFB  TOKEN_BEGIN     
00:D176 424547494E      	     3M          text  "BEGIN"
                        	  1126:    makeToken   3, TOKEN_END       ,"END"
00:D17B 03              	     1M          DFB  3
00:D17C 89              	     2M          DFB  TOKEN_END       
00:D17D 454E44          	     3M          text  "END"
                        	  1127:    makeToken   2, TOKEN_OR        ,"OR"
00:D180 02              	     1M          DFB  2
00:D181 8A              	     2M          DFB  TOKEN_OR        
00:D182 4F52            	     3M          text  "OR"
                        	  1128:    makeToken   3, TOKEN_DIV       ,"DIV"
00:D184 03              	     1M          DFB  3
00:D185 8B              	     2M          DFB  TOKEN_DIV       
00:D186 444956          	     3M          text  "DIV"
                        	  1129:    makeToken   3, TOKEN_MOD       ,"MOD"
00:D189 03              	     1M          DFB  3
00:D18A 8C              	     2M          DFB  TOKEN_MOD       
00:D18B 4D4F44          	     3M          text  "MOD"
                        	  1130:    makeToken   3, TOKEN_AND       ,"AND"
00:D18E 03              	     1M          DFB  3
00:D18F 8D              	     2M          DFB  TOKEN_AND       
00:D190 414E44          	     3M          text  "AND"
                        	  1131:    makeToken   3, TOKEN_SHL       ,"SHL"
00:D193 03              	     1M          DFB  3
00:D194 8E              	     2M          DFB  TOKEN_SHL       
00:D195 53484C          	     3M          text  "SHL"
                        	  1132:    makeToken   3, TOKEN_SHR       ,"SHR"
00:D198 03              	     1M          DFB  3
00:D199 8F              	     2M          DFB  TOKEN_SHR       
00:D19A 534852          	     3M          text  "SHR"
                        	  1133:    makeToken   3, TOKEN_NOT       ,"NOT"
00:D19D 03              	     1M          DFB  3
00:D19E 90              	     2M          DFB  TOKEN_NOT       
00:D19F 4E4F54          	     3M          text  "NOT"
                        	  1134:    makeToken   3, TOKEN_MEM       ,"MEM"
00:D1A2 03              	     1M          DFB  3
00:D1A3 91              	     2M          DFB  TOKEN_MEM       
00:D1A4 4D454D          	     3M          text  "MEM"
                        	  1135:    makeToken   2, TOKEN_IF        ,"IF"
00:D1A7 02              	     1M          DFB  2
00:D1A8 92              	     2M          DFB  TOKEN_IF        
00:D1A9 4946            	     3M          text  "IF"
                        	  1136:    makeToken   4, TOKEN_THEN      ,"THEN"
00:D1AB 04              	     1M          DFB  4
00:D1AC 93              	     2M          DFB  TOKEN_THEN      
00:D1AD 5448454E        	     3M          text  "THEN"
                        	  1137:    makeToken   4, TOKEN_ELSE      ,"ELSE"
00:D1B1 04              	     1M          DFB  4
00:D1B2 94              	     2M          DFB  TOKEN_ELSE      
00:D1B3 454C5345        	     3M          text  "ELSE"
                        	  1138:    makeToken   4, TOKEN_CASE      ,"CASE"
00:D1B7 04              	     1M          DFB  4
00:D1B8 95              	     2M          DFB  TOKEN_CASE      
00:D1B9 43415345        	     3M          text  "CASE"
                        	  1139:    makeToken   5, TOKEN_WHILE     ,"WHILE"
00:D1BD 05              	     1M          DFB  5
00:D1BE 96              	     2M          DFB  TOKEN_WHILE     
00:D1BF 5748494C45      	     3M          text  "WHILE"
                        	  1140:    makeToken   2, TOKEN_DO        ,"DO"
00:D1C4 02              	     1M          DFB  2
00:D1C5 97              	     2M          DFB  TOKEN_DO        
00:D1C6 444F            	     3M          text  "DO"
                        	  1141:    makeToken   6, TOKEN_REPEAT    ,"REPEAT"
00:D1C8 06              	     1M          DFB  6
00:D1C9 98              	     2M          DFB  TOKEN_REPEAT    
00:D1CA 524550454154    	     3M          text  "REPEAT"
                        	  1142:    makeToken   5, TOKEN_UNTIL     ,"UNTIL"
00:D1D0 05              	     1M          DFB  5
00:D1D1 99              	     2M          DFB  TOKEN_UNTIL     
00:D1D2 554E54494C      	     3M          text  "UNTIL"
                        	  1143:    makeToken   3, TOKEN_FOR       ,"FOR"
00:D1D7 03              	     1M          DFB  3
00:D1D8 9A              	     2M          DFB  TOKEN_FOR       
00:D1D9 464F52          	     3M          text  "FOR"
                        	  1144:    makeToken   2, TOKEN_TO        ,"TO"
00:D1DC 02              	     1M          DFB  2
00:D1DD 9B              	     2M          DFB  TOKEN_TO        
00:D1DE 544F            	     3M          text  "TO"
                        	  1145:    makeToken   6, TOKEN_DOWNTO    ,"DOWNTO"
00:D1E0 06              	     1M          DFB  6
00:D1E1 9C              	     2M          DFB  TOKEN_DOWNTO    
00:D1E2 444F574E544F    	     3M          text  "DOWNTO"
                        	  1146:    makeToken   5, TOKEN_WRITE     ,"WRITE"
00:D1E8 05              	     1M          DFB  5
00:D1E9 9D              	     2M          DFB  TOKEN_WRITE     
00:D1EA 5752495445      	     3M          text  "WRITE"
                        	  1147:    makeToken   4, TOKEN_READ      ,"READ"
00:D1EF 04              	     1M          DFB  4
00:D1F0 9E              	     2M          DFB  TOKEN_READ      
00:D1F1 52454144        	     3M          text  "READ"
                        	  1148:    makeToken   4, TOKEN_CALL      ,"CALL"
00:D1F5 04              	     1M          DFB  4
00:D1F6 9F              	     2M          DFB  TOKEN_CALL      
00:D1F7 43414C4C        	     3M          text  "CALL"
                        	  1149:    makeToken   4, TOKEN_CHAR      ,"CHAR"
00:D1FB 04              	     1M          DFB  4
00:D1FC A1              	     2M          DFB  TOKEN_CHAR      
00:D1FD 43484152        	     3M          text  "CHAR"
                        	  1150:    makeToken   4, TOKEN_MEMC      ,"MEMC"
00:D201 04              	     1M          DFB  4
00:D202 A2              	     2M          DFB  TOKEN_MEMC      
00:D203 4D454D43        	     3M          text  "MEMC"
                        	  1151:    makeToken   3, TOKEN_XOR       ,"XOR"
00:D207 03              	     1M          DFB  3
00:D208 A4              	     2M          DFB  TOKEN_XOR       
00:D209 584F52          	     3M          text  "XOR"
                        	  1152:    makeToken   7, TOKEN_ADDRESS   ,"ADDRESS"
00:D20C 07              	     1M          DFB  7
00:D20D A9              	     2M          DFB  TOKEN_ADDRESS   
00:D20E 41444452455353  	     3M          text  "ADDRESS"
                        	  1153:    makeToken   3, TOKEN_CHR       ,"CHR"
00:D215 03              	     1M          DFB  3
00:D216 AB              	     2M          DFB  TOKEN_CHR       
00:D217 434852          	     3M          text  "CHR"
                        	  1154:    makeToken   3, TOKEN_HEX       ,"HEX"
00:D21A 03              	     1M          DFB  3
00:D21B AC              	     2M          DFB  TOKEN_HEX       
00:D21C 484558          	     3M          text  "HEX"
                        	  1155:    makeToken   7, TOKEN_INTEGER   ,"INTEGER"
00:D21F 07              	     1M          DFB  7
00:D220 FE              	     2M          DFB  TOKEN_INTEGER   
00:D221 494E5445474552  	     3M          text  "INTEGER"
                        	  1156:    makeToken   7, TOKEN_WRITELN   ,"WRITELN"
00:D228 07              	     1M          DFB  7
00:D229 FF              	     2M          DFB  TOKEN_WRITELN   
00:D22A 57524954454C4E  	     3M          text  "WRITELN"
                        	  1157:    makeToken   8, TOKEN_LCDWRITE  ,"LCDWRITE"
00:D231 08              	     1M          DFB  8
00:D232 F1              	     2M          DFB  TOKEN_LCDWRITE  
00:D233 4C43445752495445	     3M          text  "LCDWRITE"
                        	  1158: 
                        	  1159: 
00:D23B 00              	  1160: RSVEND   DFB  0,0        ; END OF TABLE
00:D23C 00
                        	  1161: ;
                        	  1162: 
                        	  1163: ;
                        	  1164: ;  Pascal get_token
                        	  1165: ;
                        	  1166: ;  Used in the Pascal section. Does a get_token, and then if an identifier is found tries to look
                        	  1167: ;  it up.
                        	  1168: ;
                        	  1169: pas_get_token:
00:D23D 208FCC          	  1170:   jsr get_token
00:D240 F004            	  1171:   beq pas_get_token_eof   ; branch to make sure Z flag stays set
00:D242 C949            	  1172:   cmp #TOKEN_IDENTIFIER
00:D244 F001            	  1173:   beq pas_gc_identifier
                        	  1174: pas_get_token_eof:
00:D246 60              	  1175:   rts
                        	  1176: ;
                        	  1177: ;  here if get_token got an identifier
                        	  1178: ;
                        	  1179: pas_gc_identifier:
00:D247 A948            	  1180:   lda  #<RSVWRD
00:D249 8598            	  1181:   sta  token_work
00:D24B A9D1            	  1182:   lda  #>RSVWRD
00:D24D 8599            	  1183:   sta  token_work+1
                        	  1184: pas_gc_loop:
00:D24F A000            	  1185:   ldy  #0
00:D251 B198            	  1186:   lda  (token_work),Y
00:D253 D003            	  1187:   bne  pas_gc_more        ; MORE TO GO
00:D255 A949            	  1188:   lda  #TOKEN_IDENTIFIER
00:D257 60              	  1189:   rts
                        	  1190: ;
                        	  1191: ; SEARCH for RESERVED WORD
                        	  1192: ;
                        	  1193: pas_gc_more:
00:D258 B198            	  1194:   lda  (token_work),Y     ; length of word in table
00:D25A C592            	  1195:   cmp  token_length       ; same?
00:D25C D022            	  1196:   bne  pas_gc_no_match    ; no - can't be it then
00:D25E A8              	  1197:   tay                     ; length
00:D25F A590            	  1198:   lda  token_address      ; put token start address into SRCE
00:D261 8500            	  1199:   sta  SRCE
00:D263 A591            	  1200:   lda  token_address+1
00:D265 8501            	  1201:   sta  SRCE+1
00:D267 A598            	  1202:   lda  token_work         ; put current token_work+2 into DEST
00:D269 18              	  1203:   clc
00:D26A 6902            	  1204:   adc  #2
00:D26C 8503            	  1205:   sta  DEST
00:D26E A599            	  1206:   lda  token_work+1
00:D270 6900            	  1207:   adc  #0
00:D272 8504            	  1208:   sta  DEST+1
00:D274 200182          	  1209:   jsr  str_ic_compare
00:D277 D007            	  1210:   bne  pas_gc_no_match      ; NOT FOUND
00:D279 A001            	  1211:   ldy  #1
00:D27B B198            	  1212:   lda  (token_work),Y
00:D27D 8593            	  1213:   sta  token_type
00:D27F 60              	  1214:   rts
                        	  1215: pas_gc_no_match    =  *
00:D280 A000            	  1216:   ldy  #0
00:D282 B198            	  1217:   lda  (token_work),Y     ; token_work points to reserved word entry
00:D284 18              	  1218:   clc
00:D285 6902            	  1219:   adc  #2         ; add 2 to bypass length and code
00:D287 6598            	  1220:   adc  token_work
00:D289 8598            	  1221:   sta  token_work         ; put it back
00:D28B 90C2            	  1222:   bcc  pas_gc_loop
00:D28D E699            	  1223:   inc  token_work+1       ; handle overflow
00:D28F 80BE            	  1224:   bra  pas_gc_loop     ; try for another
                        	  1225: 
                        	  1226: 
                        	  1227: 
                        	  1228: ;***********************************************
                        	  1229: ; GET A TOKEN - CHECK THAT IT
                        	  1230: ; IS THE SAME AS IN "A", IF NOT
                        	  1231: ; CALL ERROR "X"
                        	  1232: ;***********************************************
                        	  1233: GETCHK:
00:D291 DA              	  1234:   phx   ; save error number
00:D292 48              	  1235:   pha   ; save wanted token type
00:D293 203DD2          	  1236:   jsr pas_get_token
00:D296 68              	  1237:   pla   ; get it back
00:D297 C593            	  1238:   cmp token_type
00:D299 F004            	  1239:   beq CHKOK
00:D29B FA              	  1240:   plx   ; get error number back
                        	  1241: CHKNOK   =  *
00:D29C 4C4F9A          	  1242:   jmp ERROR
                        	  1243: CHKOK    =  *
00:D29F FA              	  1244:   plx   ; get error number back
00:D2A0 60              	  1245:   rts
                        	  1246: 
                        	  1247: ;***********************************************
                        	  1248: ; CHECK TOKEN AGREES WITH "A",
                        	  1249: ; IF NOT, GIVE ERROR "X"
                        	  1250: ;***********************************************
                        	  1251: CHKTKN:
00:D2A1 C593            	  1252:   cmp  token_type
00:D2A3 D0F7            	  1253:   bne  CHKNOK
00:D2A5 60              	  1254:   rts
                        	  1255: 
                        	  1256: ;***********************************************
                        	  1257: ;
                        	  1258: ; GET NEXT TOKEN - MUST BE IDENTIFIER
                        	  1259: ; THEN LOOK IT UP IN SYMBOL TABLE
                        	  1260: ;***********************************************
                        	  1261: 
                        	  1262: GET_LOOK:
00:D2A6 A949            	  1263:   lda  #TOKEN_IDENTIFIER
00:D2A8 A204            	  1264:   ldx  #4      ; ERROR: Identifier expected
00:D2AA 2091D2          	  1265:   jsr  GETCHK
00:D2AD 4C2BBD          	  1266:   jmp  LOOKUP
                        	  1267: 

Source: "gpascal.asm"
                        	   190:   .include "i2c.inc"

Source: "i2c.inc"
                        	     1: ;
                        	     2: ;  I2C interface routines
                        	     3: ;
                        	     4: ; Author: Nick Gammon
                        	     5: ; Date: 2 March 2022
                        	     6: 
                        	     7: ; PROTOCOL
                        	     8: ;
                        	     9: ;  BUS NOT BUSY: Both data and clock lines remain HIGH.
                        	    10: ;
                        	    11: ;  START DATA TRANSFER: A change in the state of the data line, from HIGH to LOW, while the clock is
                        	    12: ;  HIGH, defines a START condition.
                        	    13: ;
                        	    14: ;  STOP DATA TRANSFER: A change in the state of the data line, from LOW to HIGH, while the clock line
                        	    15: ;  is HIGH, defines the STOP condition.
                        	    16: ;
                        	    17: ;  DATA VALID: The state of the data line represents valid data when, after a START condition, the data
                        	    18: ;  line is stable for the duration of the HIGH period of the clock signal. The data on the line must be
                        	    19: ;  changed during the LOW period of the clock signal. There is one clock pulse per bit of data.
                        	    20: ;  Each data transfer is initiated with a START co ndition and terminated with a STOP condition. The
                        	    21: ;  number of data bytes transferred between START and STOP conditions is not limited, and is
                        	    22: ;  determined by the master device. The information is transferred byte-wise and each receiver
                        	    23: ;  acknowledges with a ninth bit.
                        	    24: ;
                        	    25: ;  CLOCK STRETCHING
                        	    26: ;
                        	    27: ;  If a slave wants us to wait, or another master is attempting to take over the bus, SCL will not go
                        	    28: ;  high immediately after we set it to input (high impedance) so we therefore wait until SCL is in
                        	    29: ;  fact high before proceeding.
                        	    30: ;
                        	    31: ;  ARBITRATION
                        	    32: ;
                        	    33: ;  If two masters are attempting to write to the bus we can detect that as soon as one of them writes
                        	    34: ;  a one, but reads back a zero. This indicates that another master wrote the zero. The master that
                        	    35: ;  read back the one then abandons its attempt to write (to try again later).
                        	    36: ;
                        	    37: ;  Since, up to this point, both have read back what they wrote, the bus is not corrupted.
                        	    38: ;
                        	    39: 
                        	    40: 
                        	    41: ; Configuration of which VIA ports are used by SCL and SDA
                        	    42: 
                        	    43: I2C_SCL     = %00000100   ; SCL (serial clock) - PA2
                        	    44: I2C_SDA     = %00001000   ; SDA (serial data)  - PA3
                        	    45: 
                        	    46: I2C_PORT    = VIA_PORTA   ; PORT A
                        	    47: I2C_DDR     = VIA_DDRA    ; DDR  A
                        	    48: 
                        	    49: ;
                        	    50: ;  Initialise hardware for I2C comms.
                        	    51: ;
                        	    52: ;  Set SCL and SDA to high, however make the ports input for now
                        	    53: ;
                        	    54: i2c_init:
                        	    55: 
                        	    56: ;
                        	    57: ;  Set ports to low
                        	    58: ;
00:D2B0 A90C            	    59:   lda #I2C_SCL | I2C_SDA
00:D2B2 1CF17F          	    60:   trb I2C_PORT
                        	    61: 
                        	    62: ;
                        	    63: ;  Set ports to input
                        	    64: ;
                        	    65: 
00:D2B5 A90C            	    66:   lda #I2C_SCL | I2C_SDA
00:D2B7 1CF37F          	    67:   trb I2C_DDR
                        	    68: 
                        	    69: 
00:D2BA 60              	    70:   rts
                        	    71: 
                        	    72: ;---------------------------------------------
                        	    73: ;  delay between clock bits - could make shorter if using a 1 MHz clock
                        	    74: ;---------------------------------------------
                        	    75: i2c_delay:
00:D2BB EA              	    76:     nop
00:D2BC EA              	    77:     nop
00:D2BD EA              	    78:     nop
00:D2BE 60              	    79:     rts
                        	    80: 
                        	    81: ;---------------------------------------------
                        	    82: ;  toggle the SCL line from low to high and back again
                        	    83: ;---------------------------------------------
                        	    84: i2c_toggle_clock:
00:D2BF A904            	    85:   lda #I2C_SCL
00:D2C1 1CF37F          	    86:   trb I2C_DDR      ; SCL high
00:D2C4 20BBD2          	    87:   jsr i2c_delay
                        	    88: ;
                        	    89: ;  check if the slave wants us to wait by pulling the clock low
                        	    90: ;
                        	    91: i2c_toggle_clock_wait:
00:D2C7 ADF17F          	    92:   lda I2C_PORT
00:D2CA 2904            	    93:   and #I2C_SCL
00:D2CC F0F9            	    94:   beq i2c_toggle_clock_wait   ; should be high, but is low
                        	    95: ;
                        	    96: ;  we let the clock go high, and it actually IS high, so we can proceed
                        	    97: ;
00:D2CE 0CF37F          	    98:   tsb I2C_DDR       ; SCL low
00:D2D1 A908            	    99:   lda #I2C_SDA      ; immediately set SDA to low
00:D2D3 1CF37F          	   100:   trb I2C_DDR
00:D2D6 20BBD2          	   101:   jsr i2c_delay
00:D2D9 60              	   102:   rts
                        	   103: 
                        	   104: ;---------------------------------------------
                        	   105: ;
                        	   106: ;  Begin transmission: send a start condition
                        	   107: ;
                        	   108: ;  Slave address in A, read/write bit in low-order bit
                        	   109: ;    0 = write, 1 = read
                        	   110: ;
                        	   111: ;  Sets carry if OK
                        	   112: ;
                        	   113: ;  START CONDITION:
                        	   114: ;
                        	   115: ;  A change in the state of the data line, from HIGH to LOW, while the clock is HIGH
                        	   116: ;---------------------------------------------
                        	   117: 
                        	   118: i2c_begin_transmission:
                        	   119: 
00:D2DA 48              	   120:   pha             ; save address
                        	   121: 
00:D2DB 20B0D2          	   122:   jsr i2c_init    ; set ports to low, and ports to input
                        	   123: 
                        	   124: ;
                        	   125: ;  Check if SDA or SCL are in use (low) - if so, wait until they are not
                        	   126: ;
                        	   127: i2c_begin_transmission_loop:
00:D2DE A908            	   128:   lda #I2C_SDA
00:D2E0 2DF17F          	   129:   and I2C_PORT
00:D2E3 F0F9            	   130:   beq i2c_begin_transmission_loop
00:D2E5 A904            	   131:   lda #I2C_SCL
00:D2E7 2DF17F          	   132:   and I2C_PORT
00:D2EA F0F2            	   133:   beq i2c_begin_transmission_loop
                        	   134: 
                        	   135: ;
                        	   136: ;  The start condition pulls SDA low but SCL stays high
                        	   137: ;
                        	   138: 
00:D2EC A908            	   139:   lda #I2C_SDA
00:D2EE 0CF37F          	   140:   tsb I2C_DDR
00:D2F1 20BBD2          	   141:   jsr i2c_delay
                        	   142: 
                        	   143: ;
                        	   144: ;  But now we pull SCL low ready for clocking out bits
                        	   145: ;
                        	   146: 
00:D2F4 A904            	   147:   lda #I2C_SCL
00:D2F6 0CF37F          	   148:   tsb I2C_DDR
00:D2F9 20BBD2          	   149:   jsr i2c_delay
                        	   150: 
00:D2FC 68              	   151:   pla   ; get address back
                        	   152: 
00:D2FD 2001D3          	   153:   jsr i2c_write
                        	   154: 
00:D300 60              	   155:   rts
                        	   156: 
                        	   157: ;---------------------------------------------
                        	   158: ;
                        	   159: ;  I2C write: send 8 data bits, wait for acknowledge
                        	   160: ;
                        	   161: ;---------------------------------------------
                        	   162: 
                        	   163: i2c_write:
00:D301 A208            	   164:   ldx #8  ; count of bits
00:D303 A8              	   165:   tay
                        	   166: 
                        	   167: i2c_write_loop:
00:D304 98              	   168:   tya
00:D305 2A              	   169:   rol a   ; get bit to write into carry
00:D306 A8              	   170:   tay
                        	   171: 
00:D307 B007            	   172:   bcs i2c_write_one
                        	   173: ;
                        	   174: ;  write a zero by setting SDA to output
                        	   175: ;
00:D309 A908            	   176:   lda #I2C_SDA
00:D30B 0CF37F          	   177:   tsb I2C_DDR
00:D30E 800B            	   178:   bra i2c_write_clock
                        	   179: ;
                        	   180: ;  write a one by setting SDA to input
                        	   181: ;
                        	   182: i2c_write_one:
00:D310 A908            	   183:   lda #I2C_SDA
00:D312 1CF37F          	   184:   trb I2C_DDR
                        	   185: ;
                        	   186: ;  if SDA is not high, another master has taken control of the bus, abandon this write
                        	   187: ;
00:D315 EA              	   188:   nop
00:D316 2DF17F          	   189:   and I2C_PORT
00:D319 F028            	   190:   beq i2c_write_lost_arbitration   ; error return, give up
                        	   191: 
                        	   192: ;---------------------------------------------
                        	   193: ;
                        	   194: ;  toggle clock
                        	   195: ;
                        	   196: ;---------------------------------------------
                        	   197: i2c_write_clock:
00:D31B 20BFD2          	   198:   jsr i2c_toggle_clock
                        	   199: ;
                        	   200: ;  back for another bit?
                        	   201: ;
00:D31E CA              	   202:   dex
00:D31F D0E3            	   203:   bne i2c_write_loop
                        	   204: 
                        	   205:   ;---------------------------------------------
                        	   206:   ;  wait for acknowledge bit
                        	   207:   ;---------------------------------------------
                        	   208: 
                        	   209:   ;
                        	   210:   ;  make SDA input and see if it is pulled low
                        	   211:   ;
                        	   212: 
00:D321 A908            	   213:   lda #I2C_SDA
00:D323 1CF37F          	   214:   trb I2C_DDR         ; SDA to input
                        	   215: 
00:D326 A904            	   216:   lda #I2C_SCL        ; clock high
00:D328 1CF37F          	   217:   trb I2C_DDR
                        	   218: 
                        	   219: ;
                        	   220: ;  check if the slave wants us to wait by pulling the clock low
                        	   221: ;
                        	   222: i2c_write_clock_wait:
00:D32B ADF17F          	   223:   lda I2C_PORT
00:D32E 2904            	   224:   and #I2C_SCL
00:D330 F0F9            	   225:   beq i2c_write_clock_wait   ; should be high, but is low
                        	   226: 
00:D332 20BBD2          	   227:   jsr i2c_delay       ; give it time to respond
                        	   228: 
00:D335 A908            	   229:   lda #I2C_SDA
00:D337 2DF17F          	   230:   and I2C_PORT        ; read SDA
                        	   231: 
00:D33A AA              	   232:   tax                 ; save result for a moment
00:D33B A904            	   233:   lda #I2C_SCL        ; clock low
00:D33D 0CF37F          	   234:   tsb I2C_DDR
                        	   235: 
00:D340 8A              	   236:   txa             ; get ack/nak bit back
                        	   237: 
00:D341 F002            	   238:   beq i2c_write_got_ack
                        	   239: 
                        	   240: i2c_write_lost_arbitration:
00:D343 18              	   241:   clc   ; error return
00:D344 60              	   242:   rts
                        	   243: 
                        	   244: i2c_write_got_ack:
00:D345 38              	   245:   sec   ; carry means OK
00:D346 60              	   246:   rts
                        	   247: 
                        	   248: 
                        	   249: ;---------------------------------------------
                        	   250: ;
                        	   251: ;  I2C read: receive 8 data bits, then acknowledge unless hardware_work is zero
                        	   252: ;    hardware_work will be the count of outstanding bytes to be sent
                        	   253: ;    on the last bit we NAK it to tell the sender not to send any more
                        	   254: ;
                        	   255: ;---------------------------------------------
                        	   256: 
                        	   257: i2c_read:
00:D347 A208            	   258:   ldx #8  ; count of bits
00:D349 A000            	   259:   ldy #0  ; current result
                        	   260: 
00:D34B A908            	   261:   lda #I2C_SDA
00:D34D 1CF37F          	   262:   trb I2C_DDR         ; SDA to input
                        	   263: 
                        	   264: i2c_read_loop:
                        	   265: 
00:D350 A904            	   266:   lda #I2C_SCL        ; clock high
00:D352 1CF37F          	   267:   trb I2C_DDR
00:D355 20BBD2          	   268:   jsr i2c_delay       ; give it time to respond
                        	   269: 
00:D358 A908            	   270:   lda #I2C_SDA
00:D35A 2DF17F          	   271:   and I2C_PORT        ; read SDA
00:D35D F006            	   272:   beq i2c_read_zero
                        	   273: ;
                        	   274: ;  read a 1
                        	   275: ;
00:D35F 98              	   276:   tya       ; get previous result
00:D360 38              	   277:   sec
00:D361 2A              	   278:   rol a     ; rotate in a one-bit
00:D362 A8              	   279:   tay       ; keep for later
00:D363 8004            	   280:   bra i2c_read_next
                        	   281: 
                        	   282: ;
                        	   283: ;  read a 0
                        	   284: ;
                        	   285: i2c_read_zero:
00:D365 98              	   286:   tya       ; get previous result
00:D366 18              	   287:   clc
00:D367 2A              	   288:   rol a     ; rotate in a zero-bit
00:D368 A8              	   289:   tay       ; keep for later
                        	   290: 
                        	   291: i2c_read_next:
                        	   292: 
00:D369 A904            	   293:   lda #I2C_SCL        ; clock low
00:D36B 0CF37F          	   294:   tsb I2C_DDR
00:D36E 20BBD2          	   295:   jsr i2c_delay       ; give it time to respond
                        	   296: 
                        	   297: ;
                        	   298: ;  back for another bit?
                        	   299: ;
00:D371 CA              	   300:   dex
00:D372 D0DC            	   301:   bne i2c_read_loop
                        	   302: 
00:D374 A58C            	   303:   lda hardware_work   ; NAK on last read so they stop sending
00:D376 F007            	   304:   beq i2c_read_nak
                        	   305: 
00:D378 A908            	   306:   lda #I2C_SDA
00:D37A 0CF37F          	   307:   tsb I2C_DDR         ; pull SDA low to ACK the byte
00:D37D 8005            	   308:   bra i2c_read_ack_or_nak
                        	   309: 
                        	   310: i2c_read_nak:
00:D37F A908            	   311:   lda #I2C_SDA
00:D381 1CF37F          	   312:   trb I2C_DDR         ; pull SDA high to NAK the final byte
                        	   313: 
                        	   314: i2c_read_ack_or_nak:
                        	   315: 
00:D384 A904            	   316:   lda #I2C_SCL        ; clock high
00:D386 1CF37F          	   317:   trb I2C_DDR
                        	   318: 
                        	   319: ;
                        	   320: ;  check if the slave wants us to wait by pulling the clock low
                        	   321: ;   (clock stretching)
                        	   322: ;
                        	   323: 
                        	   324: i2c_read_ack_or_nak_wait:
00:D389 ADF17F          	   325:   lda I2C_PORT
00:D38C 2904            	   326:   and #I2C_SCL
00:D38E F0F9            	   327:   beq i2c_read_ack_or_nak_wait   ; should be high, but is low
                        	   328: 
00:D390 20BBD2          	   329:   jsr i2c_delay       ; give it time to respond
                        	   330: 
00:D393 A904            	   331:   lda #I2C_SCL        ; clock low
00:D395 0CF37F          	   332:   tsb I2C_DDR
00:D398 20BBD2          	   333:   jsr i2c_delay
                        	   334: 
                        	   335: i2c_read_done:
                        	   336: 
00:D39B 98              	   337:   tya                 ; result in A
00:D39C 60              	   338:   rts
                        	   339: 
                        	   340: 
                        	   341: ;---------------------------------------------
                        	   342: ;  end transmission - send stop condition
                        	   343: ;
                        	   344: ;  STOP CONDITION:
                        	   345: ;
                        	   346: ;  A change in the state of the data line, from LOW to HIGH, while the clock is HIGH
                        	   347: ;---------------------------------------------
                        	   348: 
                        	   349: i2c_end_transmission:
                        	   350: 
                        	   351: ;
                        	   352: ;  make sure SDA is low, otherwise it can't transition low to high
                        	   353: ;
00:D39D A908            	   354:   lda #I2C_SDA
00:D39F 0CF37F          	   355:   tsb I2C_DDR
                        	   356: 
00:D3A2 20BBD2          	   357:   jsr i2c_delay
                        	   358: 
                        	   359: ;
                        	   360: ;  Set SCL to input so it floats high
                        	   361: ;
00:D3A5 A904            	   362:   lda #I2C_SCL
00:D3A7 1CF37F          	   363:   trb I2C_DDR
                        	   364: 
00:D3AA 20BBD2          	   365:   jsr i2c_delay
                        	   366: 
                        	   367: ;
                        	   368: ;  Now with SCL high, set SDA to input so it also floats high
                        	   369: ;
00:D3AD A908            	   370:   lda #I2C_SDA
00:D3AF 1CF37F          	   371:   trb I2C_DDR
                        	   372: 
00:D3B2 20BBD2          	   373:   jsr i2c_delay
                        	   374: 
                        	   375: ;
                        	   376: ;  Both SDA and SCL are now high (by the pull-up resistors) so we are done
                        	   377: ;
00:D3B5 60              	   378:   rts
                        	   379: 
                        	   380: ;---------------------------------------------
                        	   381: ;
                        	   382: ;  Send a message, address in A (excluding write bit)
                        	   383: ;  Message in (VALUE)
                        	   384: ;  Length in Y
                        	   385: ;  Returns carry set on success, carry clear on failure
                        	   386: ;
                        	   387: ;---------------------------------------------
                        	   388: i2c_send:
00:D3B6 848C            	   389:   sty hardware_work
00:D3B8 0A              	   390:   asl A     ; move zero into write bit
00:D3B9 20DAD2          	   391:   jsr i2c_begin_transmission
00:D3BC 901C            	   392:   bcc i2c_send_fail
                        	   393: 
                        	   394: ;
                        	   395: ;  send each byte
                        	   396: ;
                        	   397: i2c_send_loop:
00:D3BE A58C            	   398:   lda hardware_work           ; number of bytes to go
00:D3C0 F013            	   399:   beq i2c_send_done
00:D3C2 C68C            	   400:   dec hardware_work
00:D3C4 A000            	   401:   ldy #0
00:D3C6 B100            	   402:   lda (VALUE),Y
00:D3C8 2001D3          	   403:   jsr i2c_write
00:D3CB 900D            	   404:   bcc i2c_send_fail
00:D3CD E600            	   405:   inc VALUE
00:D3CF D0ED            	   406:   bne i2c_send_loop
00:D3D1 E601            	   407:   inc VALUE+1
00:D3D3 80E9            	   408:   bra i2c_send_loop
                        	   409: ;
                        	   410: ;  sending done
                        	   411: ;
                        	   412: i2c_send_done:
00:D3D5 209DD3          	   413:   jsr i2c_end_transmission
00:D3D8 38              	   414:   sec
00:D3D9 60              	   415:   rts
                        	   416: ;
                        	   417: ;  sending failure
                        	   418: ;
                        	   419: i2c_send_fail:
00:D3DA 209DD3          	   420:   jsr i2c_end_transmission
00:D3DD 18              	   421:   clc
00:D3DE 60              	   422:   rts
                        	   423: 
                        	   424: ;---------------------------------------------
                        	   425: ;
                        	   426: ;  Receive messave, slave address in A (excluding write bit)
                        	   427: ;  Message in (VALUE)
                        	   428: ;  Length in Y
                        	   429: ;---------------------------------------------
                        	   430: 
                        	   431: i2c_receive:
00:D3DF 848C            	   432:   sty hardware_work
00:D3E1 38              	   433:   sec
00:D3E2 2A              	   434:   rol A   ; move one into write bit (so it is read mode)
00:D3E3 20DAD2          	   435:   jsr i2c_begin_transmission
00:D3E6 901F            	   436:   bcc i2c_receive_fail
                        	   437: 
                        	   438: ;
                        	   439: ;  put serial data (SDA) into input mode so we can read from it
                        	   440: ;
00:D3E8 A908            	   441:   lda #I2C_SDA
00:D3EA 1CF37F          	   442:   trb I2C_DDR
                        	   443: 
                        	   444: ;
                        	   445: ;  receive each byte
                        	   446: ;
                        	   447: i2c_receive_loop:
00:D3ED A58C            	   448:   lda hardware_work           ; number of bytes to go
00:D3EF F011            	   449:   beq i2c_receive_done
00:D3F1 C68C            	   450:   dec hardware_work
00:D3F3 2047D3          	   451:   jsr i2c_read
00:D3F6 A000            	   452:   ldy #0
00:D3F8 9100            	   453:   sta (VALUE),Y
00:D3FA E600            	   454:   inc VALUE
00:D3FC D0EF            	   455:   bne i2c_receive_loop
00:D3FE E601            	   456:   inc VALUE+1
00:D400 80EB            	   457:   bra i2c_receive_loop
                        	   458: ;
                        	   459: ;  receiving done
                        	   460: ;
                        	   461: i2c_receive_done:
00:D402 209DD3          	   462:   jsr i2c_end_transmission
00:D405 38              	   463:   sec
00:D406 60              	   464:   rts
                        	   465: ;
                        	   466: ;  receiving failure
                        	   467: ;
                        	   468: i2c_receive_fail:
00:D407 209DD3          	   469:   jsr i2c_end_transmission
00:D40A 18              	   470:   clc
00:D40B 60              	   471:   rts
                        	   472: 
                        	   473: 

Source: "gpascal.asm"
                        	   191:   .include "spi.inc"

Source: "spi.inc"
                        	     1: ;
                        	     2: ;  SPI interface routines
                        	     3: ;
                        	     4: ; Author: Nick Gammon
                        	     5: ; Date: 6 March 2022
                        	     6: ;
                        	     7: 
                        	     8: ; Configuration of which VIA ports are used by SS, MOSI, MISO, SCK
                        	     9: 
                        	    10: SPI_SS    = %00000001   ; SS   (slave select) - PB0
                        	    11: SPI_MOSI  = %00000010   ; MOSI (master out, slave in) - PB1
                        	    12: SPI_MISO  = %00000100   ; MISO (master in, slave out) - PB2
                        	    13: SPI_SCK   = %00001000   ; SCK  (serial clock) - PB3
                        	    14: 
                        	    15: SPI_PORT    = VIA_PORTB   ; PORT B
                        	    16: SPI_DDR     = VIA_DDRB    ; DDR  B
                        	    17: 
                        	    18: ;---------------------------------------------
                        	    19: ;  Initialise hardware for SPI comms.
                        	    20: ;
                        	    21: ;  SPI mode in A, as follows:
                        	    22: 
                        	    23: ;   Mode 0 - clock is normally low,  the data is sampled on the transition from low to high (leading edge)
                        	    24: ;   Mode 1 - clock is normally low,  the data is sampled on the transition from high to low (trailing edge)
                        	    25: ;   Mode 2 - clock is normally high, the data is sampled on the transition from high to low (leading edge)
                        	    26: ;   Mode 3 - clock is normally high, the data is sampled on the transition from low to high (trailing edge)
                        	    27: ;
                        	    28: ;  Set SS, MOSI and SCK to outputs. Set MISO to input.
                        	    29: ;---------------------------------------------
                        	    30: spi_init:
                        	    31: 
00:D40C 8568            	    32:   sta spi_mode
                        	    33: 
                        	    34: ;
                        	    35: ;  Set MISO to input
                        	    36: ;
                        	    37: 
00:D40E A904            	    38:   lda #SPI_MISO
00:D410 1CF27F          	    39:   trb SPI_DDR
                        	    40: 
                        	    41: ;
                        	    42: ;  Set SS to high (it is active low)
                        	    43: ;
00:D413 A901            	    44:   lda #SPI_SS
00:D415 0CF07F          	    45:   tsb SPI_PORT
                        	    46: 
                        	    47: ;
                        	    48: ; In modes 0 and 1, the clock is normally low
                        	    49: ;
00:D418 A568            	    50:   lda spi_mode
00:D41A 2902            	    51:   and #2
00:D41C D007            	    52:   bne spi_init_clock_high
                        	    53: 
00:D41E A908            	    54:   lda #SPI_SCK
00:D420 1CF07F          	    55:   trb SPI_PORT
00:D423 8005            	    56:   bra spi_init2
                        	    57: 
                        	    58: ;
                        	    59: ; In modes 2 and 3, the clock is normally high
                        	    60: ;
                        	    61: spi_init_clock_high:
00:D425 A908            	    62:   lda #SPI_SCK
00:D427 0CF07F          	    63:   tsb SPI_PORT
                        	    64: ;
                        	    65: ;  Now set up MOSI
                        	    66: ;
                        	    67: 
                        	    68: spi_init2:
                        	    69: 
00:D42A A568            	    70:   lda spi_mode
00:D42C 2901            	    71:   and #1
00:D42E D007            	    72:   bne spi_init_mosi_low
                        	    73: 
                        	    74: ;
                        	    75: ;  In modes 0 and 2, MOSI idles high
                        	    76: ;
00:D430 A902            	    77:   lda #SPI_MOSI
00:D432 0CF07F          	    78:   tsb SPI_PORT
00:D435 8005            	    79:   bra spi_init3
                        	    80: 
                        	    81: ;
                        	    82: ;  In modes 1 and 3, MOSI idles low
                        	    83: ;
                        	    84: 
                        	    85: spi_init_mosi_low:
00:D437 A902            	    86:   lda #SPI_MOSI
00:D439 1CF07F          	    87:   trb SPI_PORT
                        	    88: 
                        	    89: ;
                        	    90: ;   Set SS, MOSI and SCK to outputs
                        	    91: ;
                        	    92: 
                        	    93: spi_init3:
00:D43C A90B            	    94:   lda #SPI_SS | SPI_MOSI | SPI_SCK
00:D43E 0CF27F          	    95:   tsb SPI_DDR
                        	    96: 
00:D441 60              	    97:   rts
                        	    98: 
                        	    99: ;---------------------------------------------
                        	   100: ;  Transfer one byte.
                        	   101: ;    Byte to be sent in A.
                        	   102: ;    Returns received byte in A.
                        	   103: ;    Preserves X and Y
                        	   104: ;
                        	   105: ;   Mode 0 - clock is normally low,  the data is sampled on the transition from low to high (leading edge)
                        	   106: ;   Mode 1 - clock is normally low,  the data is sampled on the transition from high to low (trailing edge)
                        	   107: ;   Mode 2 - clock is normally high, the data is sampled on the transition from high to low (leading edge)
                        	   108: ;   Mode 3 - clock is normally high, the data is sampled on the transition from low to high (trailing edge)
                        	   109: ;---------------------------------------------
                        	   110: 
                        	   111: spi_transfer:
00:D442 DA              	   112:   phx
00:D443 5A              	   113:   phy
00:D444 A208            	   114:   ldx  #8               ; count of bits
00:D446 A8              	   115:   tay                   ; save the byte we are sending
                        	   116: spi_transfer_loop:
00:D447 98              	   117:   tya                   ; get the byte we are sending back
                        	   118: ;
                        	   119: ;  set up MOSI, ready to be sampled on the clock transition
                        	   120: ;
00:D448 2A              	   121:   rol A                 ; get MSB into carry
00:D449 A8              	   122:   tay                   ; save the byte which we shifted left
00:D44A 9007            	   123:   bcc spi_send_zero     ; if no carry, we are sending a zero
                        	   124: 
                        	   125: ;
                        	   126: ; here to send a one bit
                        	   127: ;
00:D44C A902            	   128:   lda #SPI_MOSI
00:D44E 0CF07F          	   129:   tsb SPI_PORT    ; set MOSI to high
00:D451 8005            	   130:   bra spi_send_clock_pulse_1
                        	   131: 
                        	   132: ;
                        	   133: ; here to send a zero bit
                        	   134: ;
                        	   135: spi_send_zero:
00:D453 A902            	   136:   lda #SPI_MOSI
00:D455 1CF07F          	   137:   trb SPI_PORT    ; set MOSI to low
                        	   138: 
                        	   139: ;
                        	   140: ; transition clock
                        	   141: ;
                        	   142: spi_send_clock_pulse_1:
                        	   143: 
                        	   144: ;
                        	   145: ; In modes 0 and 1, the clock is normally low, so we need to make it high
                        	   146: ;
00:D458 A568            	   147:   lda spi_mode
00:D45A 2902            	   148:   and #2
00:D45C D007            	   149:   bne spi_send_clock_high_low
                        	   150: 
                        	   151: ;
                        	   152: ; Make SCK high
                        	   153: ;
00:D45E A908            	   154:   lda #SPI_SCK
00:D460 0CF07F          	   155:   tsb SPI_PORT
00:D463 8005            	   156:   bra spi_send2
                        	   157: 
                        	   158: ;
                        	   159: ; Otherwise we need to make it low
                        	   160: ;
                        	   161: spi_send_clock_high_low:
                        	   162: ;
                        	   163: ;  Make SCK low
                        	   164: ;
00:D465 A908            	   165:   lda #SPI_SCK
00:D467 1CF07F          	   166:   trb SPI_PORT
                        	   167: 
                        	   168: ;
                        	   169: ;  We have done the leading edge of SCK
                        	   170: ;
                        	   171: spi_send2:
                        	   172: 
                        	   173: ;
                        	   174: ;  In modes 1 and 3 we sample on the trailing edge, so do nothing here
                        	   175: ;
00:D46A A568            	   176:   lda spi_mode
00:D46C 2901            	   177:   and #1
00:D46E D00B            	   178:   bne spi_send3
                        	   179: 
                        	   180: ;
                        	   181: ;  sample incoming data on leading edge
                        	   182: ;
00:D470 18              	   183:   clc
00:D471 A904            	   184:   lda #SPI_MISO
00:D473 2DF07F          	   185:   and SPI_PORT
00:D476 F001            	   186:   beq spi_read_02_done
00:D478 38              	   187:   sec
                        	   188: spi_read_02_done:
00:D479 268C            	   189:   rol hardware_work   ; rotate in zero or one from carry
                        	   190: 
                        	   191: spi_send3:
                        	   192: 
                        	   193: ;
                        	   194: ;  transition clock again to give the trailing edge
                        	   195: ;
                        	   196: 
                        	   197: ;
                        	   198: ; In modes 0 and 1, the clock is normally low, so we need to make it low again
                        	   199: ;
00:D47B A568            	   200:   lda spi_mode
00:D47D 2902            	   201:   and #2
00:D47F D007            	   202:   bne spi_send_clock_low_high
                        	   203: 
00:D481 A908            	   204:   lda #SPI_SCK
00:D483 1CF07F          	   205:   trb SPI_PORT
00:D486 8005            	   206:   bra spi_send4
                        	   207: 
                        	   208: spi_send_clock_low_high:
00:D488 A908            	   209:   lda #SPI_SCK
00:D48A 0CF07F          	   210:   tsb SPI_PORT
                        	   211: 
                        	   212: spi_send4:
                        	   213: 
                        	   214: ;
                        	   215: ;  In modes 1 and 3 we sample on the trailing edge
                        	   216: ;
00:D48D A568            	   217:   lda spi_mode
00:D48F 2901            	   218:   and #1
00:D491 F00B            	   219:   beq spi_send_bit_done
                        	   220: 
                        	   221: ;
                        	   222: ;  sample incoming data on trailing edge
                        	   223: ;
00:D493 18              	   224:   clc
00:D494 A904            	   225:   lda #SPI_MISO
00:D496 2DF07F          	   226:   and SPI_PORT
00:D499 F001            	   227:   beq spi_read_13_done
00:D49B 38              	   228:   sec
                        	   229: spi_read_13_done:
00:D49C 268C            	   230:   rol hardware_work   ; rotate in zero or one from carry
                        	   231: 
                        	   232: spi_send_bit_done:
00:D49E CA              	   233:   dex
00:D49F D0A6            	   234:   bne spi_transfer_loop
                        	   235: 
                        	   236: ;
                        	   237: ;  get incoming byte back into A
                        	   238: ;
00:D4A1 7A              	   239:   ply
00:D4A2 FA              	   240:   plx
00:D4A3 A58C            	   241:   lda hardware_work
00:D4A5 60              	   242:   rts
                        	   243: 
                        	   244: 
                        	   245: ;---------------------------------------------
                        	   246: ; Select the slave (send SS low) - preserves all registers
                        	   247: ;---------------------------------------------
                        	   248: spi_ss_low:
00:D4A6 48              	   249:   pha
00:D4A7 A901            	   250:   lda #SPI_SS
00:D4A9 1CF07F          	   251:   trb SPI_PORT
00:D4AC 68              	   252:   pla
00:D4AD 60              	   253:   rts
                        	   254: 
                        	   255: ;---------------------------------------------
                        	   256: ; Deselect the slave (send SS high) - preserves all registers
                        	   257: ;---------------------------------------------
                        	   258: spi_ss_high:
00:D4AE 48              	   259:   pha
00:D4AF A901            	   260:   lda #SPI_SS
00:D4B1 0CF07F          	   261:   tsb SPI_PORT
00:D4B4 68              	   262:   pla
00:D4B5 60              	   263:   rts
                        	   264: 
                        	   265: ;---------------------------------------------
                        	   266: ;  send two bytes: first in A, second in X
                        	   267: ;   preserves all registers
                        	   268: ;---------------------------------------------
                        	   269: spi_send_two_bytes:
00:D4B6 48              	   270:   pha
00:D4B7 20A6D4          	   271:   jsr spi_ss_low    ; SS low
00:D4BA 2042D4          	   272:   jsr spi_transfer  ; send first byte
00:D4BD 8A              	   273:   txa               ; get second byte
00:D4BE 2042D4          	   274:   jsr spi_transfer  ; send second byte
00:D4C1 20AED4          	   275:   jsr spi_ss_high   ; SS high again
00:D4C4 68              	   276:   pla
00:D4C5 60              	   277:   rts
                        	   278: 
                        	   279: 

Source: "gpascal.asm"
                        	   192: 
                        	   193:   .if USE_CP437_FONT
                        	   194:     .include "cp437_font.inc"

Source: "cp437_font.inc"
                        	     1: ; bit patterns for the CP437 font
                        	     2: 
                        	     3: cp437_font:
                        	     4: 
00:D4C6 00              	     5:   dfb $00,$00,$00,$00,$00,$00,$00,$00 ; $00
00:D4C7 00
00:D4C8 00
00:D4C9 00
00:D4CA 00
00:D4CB 00
00:D4CC 00
00:D4CD 00
00:D4CE 7E              	     6:   dfb $7E,$81,$A5,$81,$BD,$99,$81,$7E ; $01
00:D4CF 81
00:D4D0 A5
00:D4D1 81
00:D4D2 BD
00:D4D3 99
00:D4D4 81
00:D4D5 7E
00:D4D6 7E              	     7:   dfb $7E,$FF,$DB,$FF,$C3,$E7,$FF,$7E ; $02
00:D4D7 FF
00:D4D8 DB
00:D4D9 FF
00:D4DA C3
00:D4DB E7
00:D4DC FF
00:D4DD 7E
00:D4DE 6C              	     8:   dfb $6C,$FE,$FE,$FE,$7C,$38,$10,$00 ; $03
00:D4DF FE
00:D4E0 FE
00:D4E1 FE
00:D4E2 7C
00:D4E3 38
00:D4E4 10
00:D4E5 00
00:D4E6 10              	     9:   dfb $10,$38,$7C,$FE,$7C,$38,$10,$00 ; $04
00:D4E7 38
00:D4E8 7C
00:D4E9 FE
00:D4EA 7C
00:D4EB 38
00:D4EC 10
00:D4ED 00
00:D4EE 38              	    10:   dfb $38,$7C,$38,$FE,$FE,$7C,$38,$7C ; $05
00:D4EF 7C
00:D4F0 38
00:D4F1 FE
00:D4F2 FE
00:D4F3 7C
00:D4F4 38
00:D4F5 7C
00:D4F6 10              	    11:   dfb $10,$10,$38,$7C,$FE,$7C,$38,$7C ; $06
00:D4F7 10
00:D4F8 38
00:D4F9 7C
00:D4FA FE
00:D4FB 7C
00:D4FC 38
00:D4FD 7C
00:D4FE 00              	    12:   dfb $00,$00,$18,$3C,$3C,$18,$00,$00 ; $07
00:D4FF 00
00:D500 18
00:D501 3C
00:D502 3C
00:D503 18
00:D504 00
00:D505 00
00:D506 FF              	    13:   dfb $FF,$FF,$E7,$C3,$C3,$E7,$FF,$FF ; $08
00:D507 FF
00:D508 E7
00:D509 C3
00:D50A C3
00:D50B E7
00:D50C FF
00:D50D FF
00:D50E 00              	    14:   dfb $00,$3C,$66,$42,$42,$66,$3C,$00 ; $09
00:D50F 3C
00:D510 66
00:D511 42
00:D512 42
00:D513 66
00:D514 3C
00:D515 00
00:D516 FF              	    15:   dfb $FF,$C3,$99,$BD,$BD,$99,$C3,$FF ; $0A
00:D517 C3
00:D518 99
00:D519 BD
00:D51A BD
00:D51B 99
00:D51C C3
00:D51D FF
00:D51E 0F              	    16:   dfb $0F,$07,$0F,$7D,$CC,$CC,$CC,$78 ; $0B
00:D51F 07
00:D520 0F
00:D521 7D
00:D522 CC
00:D523 CC
00:D524 CC
00:D525 78
00:D526 3C              	    17:   dfb $3C,$66,$66,$66,$3C,$18,$7E,$18 ; $0C
00:D527 66
00:D528 66
00:D529 66
00:D52A 3C
00:D52B 18
00:D52C 7E
00:D52D 18
00:D52E 3F              	    18:   dfb $3F,$33,$3F,$30,$30,$70,$F0,$E0 ; $0D
00:D52F 33
00:D530 3F
00:D531 30
00:D532 30
00:D533 70
00:D534 F0
00:D535 E0
00:D536 7F              	    19:   dfb $7F,$63,$7F,$63,$63,$67,$E6,$C0 ; $0E
00:D537 63
00:D538 7F
00:D539 63
00:D53A 63
00:D53B 67
00:D53C E6
00:D53D C0
00:D53E 99              	    20:   dfb $99,$5A,$3C,$E7,$E7,$3C,$5A,$99 ; $0F
00:D53F 5A
00:D540 3C
00:D541 E7
00:D542 E7
00:D543 3C
00:D544 5A
00:D545 99
00:D546 80              	    21:   dfb $80,$E0,$F8,$FE,$F8,$E0,$80,$00 ; $10
00:D547 E0
00:D548 F8
00:D549 FE
00:D54A F8
00:D54B E0
00:D54C 80
00:D54D 00
00:D54E 02              	    22:   dfb $02,$0E,$3E,$FE,$3E,$0E,$02,$00 ; $11
00:D54F 0E
00:D550 3E
00:D551 FE
00:D552 3E
00:D553 0E
00:D554 02
00:D555 00
00:D556 18              	    23:   dfb $18,$3C,$7E,$18,$18,$7E,$3C,$18 ; $12
00:D557 3C
00:D558 7E
00:D559 18
00:D55A 18
00:D55B 7E
00:D55C 3C
00:D55D 18
00:D55E 66              	    24:   dfb $66,$66,$66,$66,$66,$00,$66,$00 ; $13
00:D55F 66
00:D560 66
00:D561 66
00:D562 66
00:D563 00
00:D564 66
00:D565 00
00:D566 7F              	    25:   dfb $7F,$DB,$DB,$7B,$1B,$1B,$1B,$00 ; $14
00:D567 DB
00:D568 DB
00:D569 7B
00:D56A 1B
00:D56B 1B
00:D56C 1B
00:D56D 00
00:D56E 3E              	    26:   dfb $3E,$63,$38,$6C,$6C,$38,$CC,$78 ; $15
00:D56F 63
00:D570 38
00:D571 6C
00:D572 6C
00:D573 38
00:D574 CC
00:D575 78
00:D576 00              	    27:   dfb $00,$00,$00,$00,$7E,$7E,$7E,$00 ; $16
00:D577 00
00:D578 00
00:D579 00
00:D57A 7E
00:D57B 7E
00:D57C 7E
00:D57D 00
00:D57E 18              	    28:   dfb $18,$3C,$7E,$18,$7E,$3C,$18,$FF ; $17
00:D57F 3C
00:D580 7E
00:D581 18
00:D582 7E
00:D583 3C
00:D584 18
00:D585 FF
00:D586 18              	    29:   dfb $18,$3C,$7E,$18,$18,$18,$18,$00 ; $18
00:D587 3C
00:D588 7E
00:D589 18
00:D58A 18
00:D58B 18
00:D58C 18
00:D58D 00
00:D58E 18              	    30:   dfb $18,$18,$18,$18,$7E,$3C,$18,$00 ; $19
00:D58F 18
00:D590 18
00:D591 18
00:D592 7E
00:D593 3C
00:D594 18
00:D595 00
00:D596 00              	    31:   dfb $00,$18,$0C,$FE,$0C,$18,$00,$00 ; $1A
00:D597 18
00:D598 0C
00:D599 FE
00:D59A 0C
00:D59B 18
00:D59C 00
00:D59D 00
00:D59E 00              	    32:   dfb $00,$30,$60,$FE,$60,$30,$00,$00 ; $1B
00:D59F 30
00:D5A0 60
00:D5A1 FE
00:D5A2 60
00:D5A3 30
00:D5A4 00
00:D5A5 00
00:D5A6 00              	    33:   dfb $00,$00,$C0,$C0,$C0,$FE,$00,$00 ; $1C
00:D5A7 00
00:D5A8 C0
00:D5A9 C0
00:D5AA C0
00:D5AB FE
00:D5AC 00
00:D5AD 00
00:D5AE 00              	    34:   dfb $00,$24,$66,$FF,$66,$24,$00,$00 ; $1D
00:D5AF 24
00:D5B0 66
00:D5B1 FF
00:D5B2 66
00:D5B3 24
00:D5B4 00
00:D5B5 00
00:D5B6 00              	    35:   dfb $00,$18,$3C,$7E,$FF,$FF,$00,$00 ; $1E
00:D5B7 18
00:D5B8 3C
00:D5B9 7E
00:D5BA FF
00:D5BB FF
00:D5BC 00
00:D5BD 00
00:D5BE 00              	    36:   dfb $00,$FF,$FF,$7E,$3C,$18,$00,$00 ; $1F
00:D5BF FF
00:D5C0 FF
00:D5C1 7E
00:D5C2 3C
00:D5C3 18
00:D5C4 00
00:D5C5 00
00:D5C6 00              	    37:   dfb $00,$00,$00,$00,$00,$00,$00,$00 ; ' '
00:D5C7 00
00:D5C8 00
00:D5C9 00
00:D5CA 00
00:D5CB 00
00:D5CC 00
00:D5CD 00
00:D5CE 30              	    38:   dfb $30,$78,$78,$30,$30,$00,$30,$00 ; '!'
00:D5CF 78
00:D5D0 78
00:D5D1 30
00:D5D2 30
00:D5D3 00
00:D5D4 30
00:D5D5 00
00:D5D6 6C              	    39:   dfb $6C,$6C,$6C,$00,$00,$00,$00,$00 ; '"'
00:D5D7 6C
00:D5D8 6C
00:D5D9 00
00:D5DA 00
00:D5DB 00
00:D5DC 00
00:D5DD 00
00:D5DE 6C              	    40:   dfb $6C,$6C,$FE,$6C,$FE,$6C,$6C,$00 ; '#'
00:D5DF 6C
00:D5E0 FE
00:D5E1 6C
00:D5E2 FE
00:D5E3 6C
00:D5E4 6C
00:D5E5 00
00:D5E6 30              	    41:   dfb $30,$7C,$C0,$78,$0C,$F8,$30,$00 ; '$'
00:D5E7 7C
00:D5E8 C0
00:D5E9 78
00:D5EA 0C
00:D5EB F8
00:D5EC 30
00:D5ED 00
00:D5EE 00              	    42:   dfb $00,$C6,$CC,$18,$30,$66,$C6,$00 ; '%'
00:D5EF C6
00:D5F0 CC
00:D5F1 18
00:D5F2 30
00:D5F3 66
00:D5F4 C6
00:D5F5 00
00:D5F6 38              	    43:   dfb $38,$6C,$38,$76,$DC,$CC,$76,$00 ; '&'
00:D5F7 6C
00:D5F8 38
00:D5F9 76
00:D5FA DC
00:D5FB CC
00:D5FC 76
00:D5FD 00
00:D5FE 60              	    44:   dfb $60,$60,$C0,$00,$00,$00,$00,$00 ; '''
00:D5FF 60
00:D600 C0
00:D601 00
00:D602 00
00:D603 00
00:D604 00
00:D605 00
00:D606 18              	    45:   dfb $18,$30,$60,$60,$60,$30,$18,$00 ; '('
00:D607 30
00:D608 60
00:D609 60
00:D60A 60
00:D60B 30
00:D60C 18
00:D60D 00
00:D60E 60              	    46:   dfb $60,$30,$18,$18,$18,$30,$60,$00 ; ')'
00:D60F 30
00:D610 18
00:D611 18
00:D612 18
00:D613 30
00:D614 60
00:D615 00
00:D616 00              	    47:   dfb $00,$66,$3C,$FF,$3C,$66,$00,$00 ; '*'
00:D617 66
00:D618 3C
00:D619 FF
00:D61A 3C
00:D61B 66
00:D61C 00
00:D61D 00
00:D61E 00              	    48:   dfb $00,$30,$30,$FC,$30,$30,$00,$00 ; '+'
00:D61F 30
00:D620 30
00:D621 FC
00:D622 30
00:D623 30
00:D624 00
00:D625 00
00:D626 00              	    49:   dfb $00,$00,$00,$00,$00,$30,$30,$60 ; ','
00:D627 00
00:D628 00
00:D629 00
00:D62A 00
00:D62B 30
00:D62C 30
00:D62D 60
00:D62E 00              	    50:   dfb $00,$00,$00,$FC,$00,$00,$00,$00 ; '-'
00:D62F 00
00:D630 00
00:D631 FC
00:D632 00
00:D633 00
00:D634 00
00:D635 00
00:D636 00              	    51:   dfb $00,$00,$00,$00,$00,$30,$30,$00 ; '.'
00:D637 00
00:D638 00
00:D639 00
00:D63A 00
00:D63B 30
00:D63C 30
00:D63D 00
00:D63E 06              	    52:   dfb $06,$0C,$18,$30,$60,$C0,$80,$00 ; '/'
00:D63F 0C
00:D640 18
00:D641 30
00:D642 60
00:D643 C0
00:D644 80
00:D645 00
00:D646 7C              	    53:   dfb $7C,$C6,$CE,$DE,$F6,$E6,$7C,$00 ; '0'
00:D647 C6
00:D648 CE
00:D649 DE
00:D64A F6
00:D64B E6
00:D64C 7C
00:D64D 00
00:D64E 30              	    54:   dfb $30,$70,$30,$30,$30,$30,$FC,$00 ; '1'
00:D64F 70
00:D650 30
00:D651 30
00:D652 30
00:D653 30
00:D654 FC
00:D655 00
00:D656 78              	    55:   dfb $78,$CC,$0C,$38,$60,$CC,$FC,$00 ; '2'
00:D657 CC
00:D658 0C
00:D659 38
00:D65A 60
00:D65B CC
00:D65C FC
00:D65D 00
00:D65E 78              	    56:   dfb $78,$CC,$0C,$38,$0C,$CC,$78,$00 ; '3'
00:D65F CC
00:D660 0C
00:D661 38
00:D662 0C
00:D663 CC
00:D664 78
00:D665 00
00:D666 1C              	    57:   dfb $1C,$3C,$6C,$CC,$FE,$0C,$1E,$00 ; '4'
00:D667 3C
00:D668 6C
00:D669 CC
00:D66A FE
00:D66B 0C
00:D66C 1E
00:D66D 00
00:D66E FC              	    58:   dfb $FC,$C0,$F8,$0C,$0C,$CC,$78,$00 ; '5'
00:D66F C0
00:D670 F8
00:D671 0C
00:D672 0C
00:D673 CC
00:D674 78
00:D675 00
00:D676 38              	    59:   dfb $38,$60,$C0,$F8,$CC,$CC,$78,$00 ; '6'
00:D677 60
00:D678 C0
00:D679 F8
00:D67A CC
00:D67B CC
00:D67C 78
00:D67D 00
00:D67E FC              	    60:   dfb $FC,$CC,$0C,$18,$30,$30,$30,$00 ; '7'
00:D67F CC
00:D680 0C
00:D681 18
00:D682 30
00:D683 30
00:D684 30
00:D685 00
00:D686 78              	    61:   dfb $78,$CC,$CC,$78,$CC,$CC,$78,$00 ; '8'
00:D687 CC
00:D688 CC
00:D689 78
00:D68A CC
00:D68B CC
00:D68C 78
00:D68D 00
00:D68E 78              	    62:   dfb $78,$CC,$CC,$7C,$0C,$18,$70,$00 ; '9'
00:D68F CC
00:D690 CC
00:D691 7C
00:D692 0C
00:D693 18
00:D694 70
00:D695 00
00:D696 00              	    63:   dfb $00,$30,$30,$00,$00,$30,$30,$00 ; ':'
00:D697 30
00:D698 30
00:D699 00
00:D69A 00
00:D69B 30
00:D69C 30
00:D69D 00
00:D69E 00              	    64:   dfb $00,$30,$30,$00,$00,$30,$30,$60 ; ';'
00:D69F 30
00:D6A0 30
00:D6A1 00
00:D6A2 00
00:D6A3 30
00:D6A4 30
00:D6A5 60
00:D6A6 18              	    65:   dfb $18,$30,$60,$C0,$60,$30,$18,$00 ; '<'
00:D6A7 30
00:D6A8 60
00:D6A9 C0
00:D6AA 60
00:D6AB 30
00:D6AC 18
00:D6AD 00
00:D6AE 00              	    66:   dfb $00,$00,$FC,$00,$00,$FC,$00,$00 ; '='
00:D6AF 00
00:D6B0 FC
00:D6B1 00
00:D6B2 00
00:D6B3 FC
00:D6B4 00
00:D6B5 00
00:D6B6 60              	    67:   dfb $60,$30,$18,$0C,$18,$30,$60,$00 ; '>'
00:D6B7 30
00:D6B8 18
00:D6B9 0C
00:D6BA 18
00:D6BB 30
00:D6BC 60
00:D6BD 00
00:D6BE 78              	    68:   dfb $78,$CC,$0C,$18,$30,$00,$30,$00 ; '?'
00:D6BF CC
00:D6C0 0C
00:D6C1 18
00:D6C2 30
00:D6C3 00
00:D6C4 30
00:D6C5 00
00:D6C6 7C              	    69:   dfb $7C,$C6,$DE,$DE,$DE,$C0,$78,$00 ; '@'
00:D6C7 C6
00:D6C8 DE
00:D6C9 DE
00:D6CA DE
00:D6CB C0
00:D6CC 78
00:D6CD 00
00:D6CE 30              	    70:   dfb $30,$78,$CC,$CC,$FC,$CC,$CC,$00 ; 'A'
00:D6CF 78
00:D6D0 CC
00:D6D1 CC
00:D6D2 FC
00:D6D3 CC
00:D6D4 CC
00:D6D5 00
00:D6D6 FC              	    71:   dfb $FC,$66,$66,$7C,$66,$66,$FC,$00 ; 'B'
00:D6D7 66
00:D6D8 66
00:D6D9 7C
00:D6DA 66
00:D6DB 66
00:D6DC FC
00:D6DD 00
00:D6DE 3C              	    72:   dfb $3C,$66,$C0,$C0,$C0,$66,$3C,$00 ; 'C'
00:D6DF 66
00:D6E0 C0
00:D6E1 C0
00:D6E2 C0
00:D6E3 66
00:D6E4 3C
00:D6E5 00
00:D6E6 F8              	    73:   dfb $F8,$6C,$66,$66,$66,$6C,$F8,$00 ; 'D'
00:D6E7 6C
00:D6E8 66
00:D6E9 66
00:D6EA 66
00:D6EB 6C
00:D6EC F8
00:D6ED 00
00:D6EE FE              	    74:   dfb $FE,$62,$68,$78,$68,$62,$FE,$00 ; 'E'
00:D6EF 62
00:D6F0 68
00:D6F1 78
00:D6F2 68
00:D6F3 62
00:D6F4 FE
00:D6F5 00
00:D6F6 FE              	    75:   dfb $FE,$62,$68,$78,$68,$60,$F0,$00 ; 'F'
00:D6F7 62
00:D6F8 68
00:D6F9 78
00:D6FA 68
00:D6FB 60
00:D6FC F0
00:D6FD 00
00:D6FE 3C              	    76:   dfb $3C,$66,$C0,$C0,$CE,$66,$3E,$00 ; 'G'
00:D6FF 66
00:D700 C0
00:D701 C0
00:D702 CE
00:D703 66
00:D704 3E
00:D705 00
00:D706 CC              	    77:   dfb $CC,$CC,$CC,$FC,$CC,$CC,$CC,$00 ; 'H'
00:D707 CC
00:D708 CC
00:D709 FC
00:D70A CC
00:D70B CC
00:D70C CC
00:D70D 00
00:D70E 78              	    78:   dfb $78,$30,$30,$30,$30,$30,$78,$00 ; 'I'
00:D70F 30
00:D710 30
00:D711 30
00:D712 30
00:D713 30
00:D714 78
00:D715 00
00:D716 1E              	    79:   dfb $1E,$0C,$0C,$0C,$CC,$CC,$78,$00 ; 'J'
00:D717 0C
00:D718 0C
00:D719 0C
00:D71A CC
00:D71B CC
00:D71C 78
00:D71D 00
00:D71E E6              	    80:   dfb $E6,$66,$6C,$78,$6C,$66,$E6,$00 ; 'K'
00:D71F 66
00:D720 6C
00:D721 78
00:D722 6C
00:D723 66
00:D724 E6
00:D725 00
00:D726 F0              	    81:   dfb $F0,$60,$60,$60,$62,$66,$FE,$00 ; 'L'
00:D727 60
00:D728 60
00:D729 60
00:D72A 62
00:D72B 66
00:D72C FE
00:D72D 00
00:D72E C6              	    82:   dfb $C6,$EE,$FE,$FE,$D6,$C6,$C6,$00 ; 'M'
00:D72F EE
00:D730 FE
00:D731 FE
00:D732 D6
00:D733 C6
00:D734 C6
00:D735 00
00:D736 C6              	    83:   dfb $C6,$E6,$F6,$DE,$CE,$C6,$C6,$00 ; 'N'
00:D737 E6
00:D738 F6
00:D739 DE
00:D73A CE
00:D73B C6
00:D73C C6
00:D73D 00
00:D73E 38              	    84:   dfb $38,$6C,$C6,$C6,$C6,$6C,$38,$00 ; 'O'
00:D73F 6C
00:D740 C6
00:D741 C6
00:D742 C6
00:D743 6C
00:D744 38
00:D745 00
00:D746 FC              	    85:   dfb $FC,$66,$66,$7C,$60,$60,$F0,$00 ; 'P'
00:D747 66
00:D748 66
00:D749 7C
00:D74A 60
00:D74B 60
00:D74C F0
00:D74D 00
00:D74E 78              	    86:   dfb $78,$CC,$CC,$CC,$DC,$78,$1C,$00 ; 'Q'
00:D74F CC
00:D750 CC
00:D751 CC
00:D752 DC
00:D753 78
00:D754 1C
00:D755 00
00:D756 FC              	    87:   dfb $FC,$66,$66,$7C,$6C,$66,$E6,$00 ; 'R'
00:D757 66
00:D758 66
00:D759 7C
00:D75A 6C
00:D75B 66
00:D75C E6
00:D75D 00
00:D75E 78              	    88:   dfb $78,$CC,$E0,$70,$1C,$CC,$78,$00 ; 'S'
00:D75F CC
00:D760 E0
00:D761 70
00:D762 1C
00:D763 CC
00:D764 78
00:D765 00
00:D766 FC              	    89:   dfb $FC,$B4,$30,$30,$30,$30,$78,$00 ; 'T'
00:D767 B4
00:D768 30
00:D769 30
00:D76A 30
00:D76B 30
00:D76C 78
00:D76D 00
00:D76E CC              	    90:   dfb $CC,$CC,$CC,$CC,$CC,$CC,$FC,$00 ; 'U'
00:D76F CC
00:D770 CC
00:D771 CC
00:D772 CC
00:D773 CC
00:D774 FC
00:D775 00
00:D776 CC              	    91:   dfb $CC,$CC,$CC,$CC,$CC,$78,$30,$00 ; 'V'
00:D777 CC
00:D778 CC
00:D779 CC
00:D77A CC
00:D77B 78
00:D77C 30
00:D77D 00
00:D77E C6              	    92:   dfb $C6,$C6,$C6,$D6,$FE,$EE,$C6,$00 ; 'W'
00:D77F C6
00:D780 C6
00:D781 D6
00:D782 FE
00:D783 EE
00:D784 C6
00:D785 00
00:D786 C6              	    93:   dfb $C6,$C6,$6C,$38,$38,$6C,$C6,$00 ; 'X'
00:D787 C6
00:D788 6C
00:D789 38
00:D78A 38
00:D78B 6C
00:D78C C6
00:D78D 00
00:D78E CC              	    94:   dfb $CC,$CC,$CC,$78,$30,$30,$78,$00 ; 'Y'
00:D78F CC
00:D790 CC
00:D791 78
00:D792 30
00:D793 30
00:D794 78
00:D795 00
00:D796 FE              	    95:   dfb $FE,$C6,$8C,$18,$32,$66,$FE,$00 ; 'Z'
00:D797 C6
00:D798 8C
00:D799 18
00:D79A 32
00:D79B 66
00:D79C FE
00:D79D 00
00:D79E 78              	    96:   dfb $78,$60,$60,$60,$60,$60,$78,$00 ; '['
00:D79F 60
00:D7A0 60
00:D7A1 60
00:D7A2 60
00:D7A3 60
00:D7A4 78
00:D7A5 00
00:D7A6 C0              	    97:   dfb $C0,$60,$30,$18,$0C,$06,$02,$00 ; back
00:D7A7 60
00:D7A8 30
00:D7A9 18
00:D7AA 0C
00:D7AB 06
00:D7AC 02
00:D7AD 00
00:D7AE 78              	    98:   dfb $78,$18,$18,$18,$18,$18,$78,$00 ; ']'
00:D7AF 18
00:D7B0 18
00:D7B1 18
00:D7B2 18
00:D7B3 18
00:D7B4 78
00:D7B5 00
00:D7B6 10              	    99:   dfb $10,$38,$6C,$C6,$00,$00,$00,$00 ; '^'
00:D7B7 38
00:D7B8 6C
00:D7B9 C6
00:D7BA 00
00:D7BB 00
00:D7BC 00
00:D7BD 00
00:D7BE 00              	   100:   dfb $00,$00,$00,$00,$00,$00,$00,$FF ; '_'
00:D7BF 00
00:D7C0 00
00:D7C1 00
00:D7C2 00
00:D7C3 00
00:D7C4 00
00:D7C5 FF
00:D7C6 30              	   101:   dfb $30,$30,$18,$00,$00,$00,$00,$00 ; '`'
00:D7C7 30
00:D7C8 18
00:D7C9 00
00:D7CA 00
00:D7CB 00
00:D7CC 00
00:D7CD 00
00:D7CE 00              	   102:   dfb $00,$00,$78,$0C,$7C,$CC,$76,$00 ; 'a'
00:D7CF 00
00:D7D0 78
00:D7D1 0C
00:D7D2 7C
00:D7D3 CC
00:D7D4 76
00:D7D5 00
00:D7D6 E0              	   103:   dfb $E0,$60,$60,$7C,$66,$66,$DC,$00 ; 'b'
00:D7D7 60
00:D7D8 60
00:D7D9 7C
00:D7DA 66
00:D7DB 66
00:D7DC DC
00:D7DD 00
00:D7DE 00              	   104:   dfb $00,$00,$78,$CC,$C0,$CC,$78,$00 ; 'c'
00:D7DF 00
00:D7E0 78
00:D7E1 CC
00:D7E2 C0
00:D7E3 CC
00:D7E4 78
00:D7E5 00
00:D7E6 1C              	   105:   dfb $1C,$0C,$0C,$7C,$CC,$CC,$76,$00 ; 'd'
00:D7E7 0C
00:D7E8 0C
00:D7E9 7C
00:D7EA CC
00:D7EB CC
00:D7EC 76
00:D7ED 00
00:D7EE 00              	   106:   dfb $00,$00,$78,$CC,$FC,$C0,$78,$00 ; 'e'
00:D7EF 00
00:D7F0 78
00:D7F1 CC
00:D7F2 FC
00:D7F3 C0
00:D7F4 78
00:D7F5 00
00:D7F6 38              	   107:   dfb $38,$6C,$60,$F0,$60,$60,$F0,$00 ; 'f'
00:D7F7 6C
00:D7F8 60
00:D7F9 F0
00:D7FA 60
00:D7FB 60
00:D7FC F0
00:D7FD 00
00:D7FE 00              	   108:   dfb $00,$00,$76,$CC,$CC,$7C,$0C,$F8 ; 'g'
00:D7FF 00
00:D800 76
00:D801 CC
00:D802 CC
00:D803 7C
00:D804 0C
00:D805 F8
00:D806 E0              	   109:   dfb $E0,$60,$6C,$76,$66,$66,$E6,$00 ; 'h'
00:D807 60
00:D808 6C
00:D809 76
00:D80A 66
00:D80B 66
00:D80C E6
00:D80D 00
00:D80E 30              	   110:   dfb $30,$00,$70,$30,$30,$30,$78,$00 ; 'i'
00:D80F 00
00:D810 70
00:D811 30
00:D812 30
00:D813 30
00:D814 78
00:D815 00
00:D816 0C              	   111:   dfb $0C,$00,$0C,$0C,$0C,$CC,$CC,$78 ; 'j'
00:D817 00
00:D818 0C
00:D819 0C
00:D81A 0C
00:D81B CC
00:D81C CC
00:D81D 78
00:D81E E0              	   112:   dfb $E0,$60,$66,$6C,$78,$6C,$E6,$00 ; 'k'
00:D81F 60
00:D820 66
00:D821 6C
00:D822 78
00:D823 6C
00:D824 E6
00:D825 00
00:D826 70              	   113:   dfb $70,$30,$30,$30,$30,$30,$78,$00 ; 'l'
00:D827 30
00:D828 30
00:D829 30
00:D82A 30
00:D82B 30
00:D82C 78
00:D82D 00
00:D82E 00              	   114:   dfb $00,$00,$CC,$FE,$FE,$D6,$C6,$00 ; 'm'
00:D82F 00
00:D830 CC
00:D831 FE
00:D832 FE
00:D833 D6
00:D834 C6
00:D835 00
00:D836 00              	   115:   dfb $00,$00,$F8,$CC,$CC,$CC,$CC,$00 ; 'n'
00:D837 00
00:D838 F8
00:D839 CC
00:D83A CC
00:D83B CC
00:D83C CC
00:D83D 00
00:D83E 00              	   116:   dfb $00,$00,$78,$CC,$CC,$CC,$78,$00 ; 'o'
00:D83F 00
00:D840 78
00:D841 CC
00:D842 CC
00:D843 CC
00:D844 78
00:D845 00
00:D846 00              	   117:   dfb $00,$00,$DC,$66,$66,$7C,$60,$F0 ; 'p'
00:D847 00
00:D848 DC
00:D849 66
00:D84A 66
00:D84B 7C
00:D84C 60
00:D84D F0
00:D84E 00              	   118:   dfb $00,$00,$76,$CC,$CC,$7C,$0C,$1E ; 'q'
00:D84F 00
00:D850 76
00:D851 CC
00:D852 CC
00:D853 7C
00:D854 0C
00:D855 1E
00:D856 00              	   119:   dfb $00,$00,$DC,$76,$66,$60,$F0,$00 ; 'r'
00:D857 00
00:D858 DC
00:D859 76
00:D85A 66
00:D85B 60
00:D85C F0
00:D85D 00
00:D85E 00              	   120:   dfb $00,$00,$7C,$C0,$78,$0C,$F8,$00 ; 's'
00:D85F 00
00:D860 7C
00:D861 C0
00:D862 78
00:D863 0C
00:D864 F8
00:D865 00
00:D866 10              	   121:   dfb $10,$30,$7C,$30,$30,$34,$18,$00 ; 't'
00:D867 30
00:D868 7C
00:D869 30
00:D86A 30
00:D86B 34
00:D86C 18
00:D86D 00
00:D86E 00              	   122:   dfb $00,$00,$CC,$CC,$CC,$CC,$76,$00 ; 'u'
00:D86F 00
00:D870 CC
00:D871 CC
00:D872 CC
00:D873 CC
00:D874 76
00:D875 00
00:D876 00              	   123:   dfb $00,$00,$CC,$CC,$CC,$78,$30,$00 ; 'v'
00:D877 00
00:D878 CC
00:D879 CC
00:D87A CC
00:D87B 78
00:D87C 30
00:D87D 00
00:D87E 00              	   124:   dfb $00,$00,$C6,$D6,$FE,$FE,$6C,$00 ; 'w'
00:D87F 00
00:D880 C6
00:D881 D6
00:D882 FE
00:D883 FE
00:D884 6C
00:D885 00
00:D886 00              	   125:   dfb $00,$00,$C6,$6C,$38,$6C,$C6,$00 ; 'x'
00:D887 00
00:D888 C6
00:D889 6C
00:D88A 38
00:D88B 6C
00:D88C C6
00:D88D 00
00:D88E 00              	   126:   dfb $00,$00,$CC,$CC,$CC,$7C,$0C,$F8 ; 'y'
00:D88F 00
00:D890 CC
00:D891 CC
00:D892 CC
00:D893 7C
00:D894 0C
00:D895 F8
00:D896 00              	   127:   dfb $00,$00,$FC,$98,$30,$64,$FC,$00 ; 'z'
00:D897 00
00:D898 FC
00:D899 98
00:D89A 30
00:D89B 64
00:D89C FC
00:D89D 00
00:D89E 1C              	   128:   dfb $1C,$30,$30,$E0,$30,$30,$1C,$00 ; '{'
00:D89F 30
00:D8A0 30
00:D8A1 E0
00:D8A2 30
00:D8A3 30
00:D8A4 1C
00:D8A5 00
00:D8A6 18              	   129:   dfb $18,$18,$18,$00,$18,$18,$18,$00 ; '|'
00:D8A7 18
00:D8A8 18
00:D8A9 00
00:D8AA 18
00:D8AB 18
00:D8AC 18
00:D8AD 00
00:D8AE E0              	   130:   dfb $E0,$30,$30,$1C,$30,$30,$E0,$00 ; '}'
00:D8AF 30
00:D8B0 30
00:D8B1 1C
00:D8B2 30
00:D8B3 30
00:D8B4 E0
00:D8B5 00
00:D8B6 76              	   131:   dfb $76,$DC,$00,$00,$00,$00,$00,$00 ; '~'
00:D8B7 DC
00:D8B8 00
00:D8B9 00
00:D8BA 00
00:D8BB 00
00:D8BC 00
00:D8BD 00
00:D8BE 00              	   132:   dfb $00,$10,$38,$6C,$C6,$C6,$FE,$00 ; $7F
00:D8BF 10
00:D8C0 38
00:D8C1 6C
00:D8C2 C6
00:D8C3 C6
00:D8C4 FE
00:D8C5 00
00:D8C6 78              	   133:   dfb $78,$CC,$C0,$CC,$78,$18,$0C,$78 ; $80
00:D8C7 CC
00:D8C8 C0
00:D8C9 CC
00:D8CA 78
00:D8CB 18
00:D8CC 0C
00:D8CD 78
00:D8CE 00              	   134:   dfb $00,$CC,$00,$CC,$CC,$CC,$7E,$00 ; $81
00:D8CF CC
00:D8D0 00
00:D8D1 CC
00:D8D2 CC
00:D8D3 CC
00:D8D4 7E
00:D8D5 00
00:D8D6 1C              	   135:   dfb $1C,$00,$78,$CC,$FC,$C0,$78,$00 ; $82
00:D8D7 00
00:D8D8 78
00:D8D9 CC
00:D8DA FC
00:D8DB C0
00:D8DC 78
00:D8DD 00
00:D8DE 7E              	   136:   dfb $7E,$C3,$3C,$06,$3E,$66,$3F,$00 ; $83
00:D8DF C3
00:D8E0 3C
00:D8E1 06
00:D8E2 3E
00:D8E3 66
00:D8E4 3F
00:D8E5 00
00:D8E6 CC              	   137:   dfb $CC,$00,$78,$0C,$7C,$CC,$7E,$00 ; $84
00:D8E7 00
00:D8E8 78
00:D8E9 0C
00:D8EA 7C
00:D8EB CC
00:D8EC 7E
00:D8ED 00
00:D8EE E0              	   138:   dfb $E0,$00,$78,$0C,$7C,$CC,$7E,$00 ; $85
00:D8EF 00
00:D8F0 78
00:D8F1 0C
00:D8F2 7C
00:D8F3 CC
00:D8F4 7E
00:D8F5 00
00:D8F6 30              	   139:   dfb $30,$30,$78,$0C,$7C,$CC,$7E,$00 ; $86
00:D8F7 30
00:D8F8 78
00:D8F9 0C
00:D8FA 7C
00:D8FB CC
00:D8FC 7E
00:D8FD 00
00:D8FE 00              	   140:   dfb $00,$00,$78,$C0,$C0,$78,$0C,$38 ; $87
00:D8FF 00
00:D900 78
00:D901 C0
00:D902 C0
00:D903 78
00:D904 0C
00:D905 38
00:D906 7E              	   141:   dfb $7E,$C3,$3C,$66,$7E,$60,$3C,$00 ; $88
00:D907 C3
00:D908 3C
00:D909 66
00:D90A 7E
00:D90B 60
00:D90C 3C
00:D90D 00
00:D90E CC              	   142:   dfb $CC,$00,$78,$CC,$FC,$C0,$78,$00 ; $89
00:D90F 00
00:D910 78
00:D911 CC
00:D912 FC
00:D913 C0
00:D914 78
00:D915 00
00:D916 E0              	   143:   dfb $E0,$00,$78,$CC,$FC,$C0,$78,$00 ; $8A
00:D917 00
00:D918 78
00:D919 CC
00:D91A FC
00:D91B C0
00:D91C 78
00:D91D 00
00:D91E CC              	   144:   dfb $CC,$00,$70,$30,$30,$30,$78,$00 ; $8B
00:D91F 00
00:D920 70
00:D921 30
00:D922 30
00:D923 30
00:D924 78
00:D925 00
00:D926 7C              	   145:   dfb $7C,$C6,$38,$18,$18,$18,$3C,$00 ; $8C
00:D927 C6
00:D928 38
00:D929 18
00:D92A 18
00:D92B 18
00:D92C 3C
00:D92D 00
00:D92E E0              	   146:   dfb $E0,$00,$70,$30,$30,$30,$78,$00 ; $8D
00:D92F 00
00:D930 70
00:D931 30
00:D932 30
00:D933 30
00:D934 78
00:D935 00
00:D936 C6              	   147:   dfb $C6,$38,$6C,$C6,$FE,$C6,$C6,$00 ; $8E
00:D937 38
00:D938 6C
00:D939 C6
00:D93A FE
00:D93B C6
00:D93C C6
00:D93D 00
00:D93E 30              	   148:   dfb $30,$30,$00,$78,$CC,$FC,$CC,$00 ; $8F
00:D93F 30
00:D940 00
00:D941 78
00:D942 CC
00:D943 FC
00:D944 CC
00:D945 00
00:D946 1C              	   149:   dfb $1C,$00,$FC,$60,$78,$60,$FC,$00 ; $90
00:D947 00
00:D948 FC
00:D949 60
00:D94A 78
00:D94B 60
00:D94C FC
00:D94D 00
00:D94E 00              	   150:   dfb $00,$00,$7F,$0C,$7F,$CC,$7F,$00 ; $91
00:D94F 00
00:D950 7F
00:D951 0C
00:D952 7F
00:D953 CC
00:D954 7F
00:D955 00
00:D956 3E              	   151:   dfb $3E,$6C,$CC,$FE,$CC,$CC,$CE,$00 ; $92
00:D957 6C
00:D958 CC
00:D959 FE
00:D95A CC
00:D95B CC
00:D95C CE
00:D95D 00
00:D95E 78              	   152:   dfb $78,$CC,$00,$78,$CC,$CC,$78,$00 ; $93
00:D95F CC
00:D960 00
00:D961 78
00:D962 CC
00:D963 CC
00:D964 78
00:D965 00
00:D966 00              	   153:   dfb $00,$CC,$00,$78,$CC,$CC,$78,$00 ; $94
00:D967 CC
00:D968 00
00:D969 78
00:D96A CC
00:D96B CC
00:D96C 78
00:D96D 00
00:D96E 00              	   154:   dfb $00,$E0,$00,$78,$CC,$CC,$78,$00 ; $95
00:D96F E0
00:D970 00
00:D971 78
00:D972 CC
00:D973 CC
00:D974 78
00:D975 00
00:D976 78              	   155:   dfb $78,$CC,$00,$CC,$CC,$CC,$7E,$00 ; $96
00:D977 CC
00:D978 00
00:D979 CC
00:D97A CC
00:D97B CC
00:D97C 7E
00:D97D 00
00:D97E 00              	   156:   dfb $00,$E0,$00,$CC,$CC,$CC,$7E,$00 ; $97
00:D97F E0
00:D980 00
00:D981 CC
00:D982 CC
00:D983 CC
00:D984 7E
00:D985 00
00:D986 00              	   157:   dfb $00,$CC,$00,$CC,$CC,$7C,$0C,$F8 ; $98
00:D987 CC
00:D988 00
00:D989 CC
00:D98A CC
00:D98B 7C
00:D98C 0C
00:D98D F8
00:D98E C3              	   158:   dfb $C3,$18,$3C,$66,$66,$3C,$18,$00 ; $99
00:D98F 18
00:D990 3C
00:D991 66
00:D992 66
00:D993 3C
00:D994 18
00:D995 00
00:D996 CC              	   159:   dfb $CC,$00,$CC,$CC,$CC,$CC,$78,$00 ; $9A
00:D997 00
00:D998 CC
00:D999 CC
00:D99A CC
00:D99B CC
00:D99C 78
00:D99D 00
00:D99E 18              	   160:   dfb $18,$18,$7E,$C0,$C0,$7E,$18,$18 ; $9B
00:D99F 18
00:D9A0 7E
00:D9A1 C0
00:D9A2 C0
00:D9A3 7E
00:D9A4 18
00:D9A5 18
00:D9A6 38              	   161:   dfb $38,$6C,$64,$F0,$60,$E6,$FC,$00 ; $9C
00:D9A7 6C
00:D9A8 64
00:D9A9 F0
00:D9AA 60
00:D9AB E6
00:D9AC FC
00:D9AD 00
00:D9AE CC              	   162:   dfb $CC,$CC,$78,$FC,$30,$FC,$30,$30 ; $9D
00:D9AF CC
00:D9B0 78
00:D9B1 FC
00:D9B2 30
00:D9B3 FC
00:D9B4 30
00:D9B5 30
00:D9B6 F8              	   163:   dfb $F8,$CC,$CC,$FA,$C6,$CF,$C6,$C7 ; $9E
00:D9B7 CC
00:D9B8 CC
00:D9B9 FA
00:D9BA C6
00:D9BB CF
00:D9BC C6
00:D9BD C7
00:D9BE 0E              	   164:   dfb $0E,$1B,$18,$3C,$18,$18,$D8,$70 ; $9F
00:D9BF 1B
00:D9C0 18
00:D9C1 3C
00:D9C2 18
00:D9C3 18
00:D9C4 D8
00:D9C5 70
00:D9C6 1C              	   165:   dfb $1C,$00,$78,$0C,$7C,$CC,$7E,$00 ; $A0
00:D9C7 00
00:D9C8 78
00:D9C9 0C
00:D9CA 7C
00:D9CB CC
00:D9CC 7E
00:D9CD 00
00:D9CE 38              	   166:   dfb $38,$00,$70,$30,$30,$30,$78,$00 ; $A1
00:D9CF 00
00:D9D0 70
00:D9D1 30
00:D9D2 30
00:D9D3 30
00:D9D4 78
00:D9D5 00
00:D9D6 00              	   167:   dfb $00,$1C,$00,$78,$CC,$CC,$78,$00 ; $A2
00:D9D7 1C
00:D9D8 00
00:D9D9 78
00:D9DA CC
00:D9DB CC
00:D9DC 78
00:D9DD 00
00:D9DE 00              	   168:   dfb $00,$1C,$00,$CC,$CC,$CC,$7E,$00 ; $A3
00:D9DF 1C
00:D9E0 00
00:D9E1 CC
00:D9E2 CC
00:D9E3 CC
00:D9E4 7E
00:D9E5 00
00:D9E6 00              	   169:   dfb $00,$F8,$00,$F8,$CC,$CC,$CC,$00 ; $A4
00:D9E7 F8
00:D9E8 00
00:D9E9 F8
00:D9EA CC
00:D9EB CC
00:D9EC CC
00:D9ED 00
00:D9EE FC              	   170:   dfb $FC,$00,$CC,$EC,$FC,$DC,$CC,$00 ; $A5
00:D9EF 00
00:D9F0 CC
00:D9F1 EC
00:D9F2 FC
00:D9F3 DC
00:D9F4 CC
00:D9F5 00
00:D9F6 3C              	   171:   dfb $3C,$6C,$6C,$3E,$00,$7E,$00,$00 ; $A6
00:D9F7 6C
00:D9F8 6C
00:D9F9 3E
00:D9FA 00
00:D9FB 7E
00:D9FC 00
00:D9FD 00
00:D9FE 38              	   172:   dfb $38,$6C,$6C,$38,$00,$7C,$00,$00 ; $A7
00:D9FF 6C
00:DA00 6C
00:DA01 38
00:DA02 00
00:DA03 7C
00:DA04 00
00:DA05 00
00:DA06 30              	   173:   dfb $30,$00,$30,$60,$C0,$CC,$78,$00 ; $A8
00:DA07 00
00:DA08 30
00:DA09 60
00:DA0A C0
00:DA0B CC
00:DA0C 78
00:DA0D 00
00:DA0E 00              	   174:   dfb $00,$00,$00,$FC,$C0,$C0,$00,$00 ; $A9
00:DA0F 00
00:DA10 00
00:DA11 FC
00:DA12 C0
00:DA13 C0
00:DA14 00
00:DA15 00
00:DA16 00              	   175:   dfb $00,$00,$00,$FC,$0C,$0C,$00,$00 ; $AA
00:DA17 00
00:DA18 00
00:DA19 FC
00:DA1A 0C
00:DA1B 0C
00:DA1C 00
00:DA1D 00
00:DA1E C3              	   176:   dfb $C3,$C6,$CC,$DE,$33,$66,$CC,$0F ; $AB
00:DA1F C6
00:DA20 CC
00:DA21 DE
00:DA22 33
00:DA23 66
00:DA24 CC
00:DA25 0F
00:DA26 C3              	   177:   dfb $C3,$C6,$CC,$DB,$37,$6F,$CF,$03 ; $AC
00:DA27 C6
00:DA28 CC
00:DA29 DB
00:DA2A 37
00:DA2B 6F
00:DA2C CF
00:DA2D 03
00:DA2E 18              	   178:   dfb $18,$18,$00,$18,$18,$18,$18,$00 ; $AD
00:DA2F 18
00:DA30 00
00:DA31 18
00:DA32 18
00:DA33 18
00:DA34 18
00:DA35 00
00:DA36 00              	   179:   dfb $00,$33,$66,$CC,$66,$33,$00,$00 ; $AE
00:DA37 33
00:DA38 66
00:DA39 CC
00:DA3A 66
00:DA3B 33
00:DA3C 00
00:DA3D 00
00:DA3E 00              	   180:   dfb $00,$CC,$66,$33,$66,$CC,$00,$00 ; $AF
00:DA3F CC
00:DA40 66
00:DA41 33
00:DA42 66
00:DA43 CC
00:DA44 00
00:DA45 00
00:DA46 22              	   181:   dfb $22,$88,$22,$88,$22,$88,$22,$88 ; $B0
00:DA47 88
00:DA48 22
00:DA49 88
00:DA4A 22
00:DA4B 88
00:DA4C 22
00:DA4D 88
00:DA4E 55              	   182:   dfb $55,$AA,$55,$AA,$55,$AA,$55,$AA ; $B1
00:DA4F AA
00:DA50 55
00:DA51 AA
00:DA52 55
00:DA53 AA
00:DA54 55
00:DA55 AA
00:DA56 DB              	   183:   dfb $DB,$77,$DB,$EE,$DB,$77,$DB,$EE ; $B2
00:DA57 77
00:DA58 DB
00:DA59 EE
00:DA5A DB
00:DA5B 77
00:DA5C DB
00:DA5D EE
00:DA5E 18              	   184:   dfb $18,$18,$18,$18,$18,$18,$18,$18 ; $B3
00:DA5F 18
00:DA60 18
00:DA61 18
00:DA62 18
00:DA63 18
00:DA64 18
00:DA65 18
00:DA66 18              	   185:   dfb $18,$18,$18,$18,$F8,$18,$18,$18 ; $B4
00:DA67 18
00:DA68 18
00:DA69 18
00:DA6A F8
00:DA6B 18
00:DA6C 18
00:DA6D 18
00:DA6E 18              	   186:   dfb $18,$18,$F8,$18,$F8,$18,$18,$18 ; $B5
00:DA6F 18
00:DA70 F8
00:DA71 18
00:DA72 F8
00:DA73 18
00:DA74 18
00:DA75 18
00:DA76 36              	   187:   dfb $36,$36,$36,$36,$F6,$36,$36,$36 ; $B6
00:DA77 36
00:DA78 36
00:DA79 36
00:DA7A F6
00:DA7B 36
00:DA7C 36
00:DA7D 36
00:DA7E 00              	   188:   dfb $00,$00,$00,$00,$FE,$36,$36,$36 ; $B7
00:DA7F 00
00:DA80 00
00:DA81 00
00:DA82 FE
00:DA83 36
00:DA84 36
00:DA85 36
00:DA86 00              	   189:   dfb $00,$00,$F8,$18,$F8,$18,$18,$18 ; $B8
00:DA87 00
00:DA88 F8
00:DA89 18
00:DA8A F8
00:DA8B 18
00:DA8C 18
00:DA8D 18
00:DA8E 36              	   190:   dfb $36,$36,$F6,$06,$F6,$36,$36,$36 ; $B9
00:DA8F 36
00:DA90 F6
00:DA91 06
00:DA92 F6
00:DA93 36
00:DA94 36
00:DA95 36
00:DA96 36              	   191:   dfb $36,$36,$36,$36,$36,$36,$36,$36 ; $BA
00:DA97 36
00:DA98 36
00:DA99 36
00:DA9A 36
00:DA9B 36
00:DA9C 36
00:DA9D 36
00:DA9E 00              	   192:   dfb $00,$00,$FE,$06,$F6,$36,$36,$36 ; $BB
00:DA9F 00
00:DAA0 FE
00:DAA1 06
00:DAA2 F6
00:DAA3 36
00:DAA4 36
00:DAA5 36
00:DAA6 36              	   193:   dfb $36,$36,$F6,$06,$FE,$00,$00,$00 ; $BC
00:DAA7 36
00:DAA8 F6
00:DAA9 06
00:DAAA FE
00:DAAB 00
00:DAAC 00
00:DAAD 00
00:DAAE 36              	   194:   dfb $36,$36,$36,$36,$FE,$00,$00,$00 ; $BD
00:DAAF 36
00:DAB0 36
00:DAB1 36
00:DAB2 FE
00:DAB3 00
00:DAB4 00
00:DAB5 00
00:DAB6 18              	   195:   dfb $18,$18,$F8,$18,$F8,$00,$00,$00 ; $BE
00:DAB7 18
00:DAB8 F8
00:DAB9 18
00:DABA F8
00:DABB 00
00:DABC 00
00:DABD 00
00:DABE 00              	   196:   dfb $00,$00,$00,$00,$F8,$18,$18,$18 ; $BF
00:DABF 00
00:DAC0 00
00:DAC1 00
00:DAC2 F8
00:DAC3 18
00:DAC4 18
00:DAC5 18
00:DAC6 18              	   197:   dfb $18,$18,$18,$18,$1F,$00,$00,$00 ; $C0
00:DAC7 18
00:DAC8 18
00:DAC9 18
00:DACA 1F
00:DACB 00
00:DACC 00
00:DACD 00
00:DACE 18              	   198:   dfb $18,$18,$18,$18,$FF,$00,$00,$00 ; $C1
00:DACF 18
00:DAD0 18
00:DAD1 18
00:DAD2 FF
00:DAD3 00
00:DAD4 00
00:DAD5 00
00:DAD6 00              	   199:   dfb $00,$00,$00,$00,$FF,$18,$18,$18 ; $C2
00:DAD7 00
00:DAD8 00
00:DAD9 00
00:DADA FF
00:DADB 18
00:DADC 18
00:DADD 18
00:DADE 18              	   200:   dfb $18,$18,$18,$18,$1F,$18,$18,$18 ; $C3
00:DADF 18
00:DAE0 18
00:DAE1 18
00:DAE2 1F
00:DAE3 18
00:DAE4 18
00:DAE5 18
00:DAE6 00              	   201:   dfb $00,$00,$00,$00,$FF,$00,$00,$00 ; $C4
00:DAE7 00
00:DAE8 00
00:DAE9 00
00:DAEA FF
00:DAEB 00
00:DAEC 00
00:DAED 00
00:DAEE 18              	   202:   dfb $18,$18,$18,$18,$FF,$18,$18,$18 ; $C5
00:DAEF 18
00:DAF0 18
00:DAF1 18
00:DAF2 FF
00:DAF3 18
00:DAF4 18
00:DAF5 18
00:DAF6 18              	   203:   dfb $18,$18,$1F,$18,$1F,$18,$18,$18 ; $C6
00:DAF7 18
00:DAF8 1F
00:DAF9 18
00:DAFA 1F
00:DAFB 18
00:DAFC 18
00:DAFD 18
00:DAFE 36              	   204:   dfb $36,$36,$36,$36,$37,$36,$36,$36 ; $C7
00:DAFF 36
00:DB00 36
00:DB01 36
00:DB02 37
00:DB03 36
00:DB04 36
00:DB05 36
00:DB06 36              	   205:   dfb $36,$36,$37,$30,$3F,$00,$00,$00 ; $C8
00:DB07 36
00:DB08 37
00:DB09 30
00:DB0A 3F
00:DB0B 00
00:DB0C 00
00:DB0D 00
00:DB0E 00              	   206:   dfb $00,$00,$3F,$30,$37,$36,$36,$36 ; $C9
00:DB0F 00
00:DB10 3F
00:DB11 30
00:DB12 37
00:DB13 36
00:DB14 36
00:DB15 36
00:DB16 36              	   207:   dfb $36,$36,$F7,$00,$FF,$00,$00,$00 ; $CA
00:DB17 36
00:DB18 F7
00:DB19 00
00:DB1A FF
00:DB1B 00
00:DB1C 00
00:DB1D 00
00:DB1E 00              	   208:   dfb $00,$00,$FF,$00,$F7,$36,$36,$36 ; $CB
00:DB1F 00
00:DB20 FF
00:DB21 00
00:DB22 F7
00:DB23 36
00:DB24 36
00:DB25 36
00:DB26 36              	   209:   dfb $36,$36,$37,$30,$37,$36,$36,$36 ; $CC
00:DB27 36
00:DB28 37
00:DB29 30
00:DB2A 37
00:DB2B 36
00:DB2C 36
00:DB2D 36
00:DB2E 00              	   210:   dfb $00,$00,$FF,$00,$FF,$00,$00,$00 ; $CD
00:DB2F 00
00:DB30 FF
00:DB31 00
00:DB32 FF
00:DB33 00
00:DB34 00
00:DB35 00
00:DB36 36              	   211:   dfb $36,$36,$F7,$00,$F7,$36,$36,$36 ; $CE
00:DB37 36
00:DB38 F7
00:DB39 00
00:DB3A F7
00:DB3B 36
00:DB3C 36
00:DB3D 36
00:DB3E 18              	   212:   dfb $18,$18,$FF,$00,$FF,$00,$00,$00 ; $CF
00:DB3F 18
00:DB40 FF
00:DB41 00
00:DB42 FF
00:DB43 00
00:DB44 00
00:DB45 00
00:DB46 36              	   213:   dfb $36,$36,$36,$36,$FF,$00,$00,$00 ; $D0
00:DB47 36
00:DB48 36
00:DB49 36
00:DB4A FF
00:DB4B 00
00:DB4C 00
00:DB4D 00
00:DB4E 00              	   214:   dfb $00,$00,$FF,$00,$FF,$18,$18,$18 ; $D1
00:DB4F 00
00:DB50 FF
00:DB51 00
00:DB52 FF
00:DB53 18
00:DB54 18
00:DB55 18
00:DB56 00              	   215:   dfb $00,$00,$00,$00,$FF,$36,$36,$36 ; $D2
00:DB57 00
00:DB58 00
00:DB59 00
00:DB5A FF
00:DB5B 36
00:DB5C 36
00:DB5D 36
00:DB5E 36              	   216:   dfb $36,$36,$36,$36,$3F,$00,$00,$00 ; $D3
00:DB5F 36
00:DB60 36
00:DB61 36
00:DB62 3F
00:DB63 00
00:DB64 00
00:DB65 00
00:DB66 18              	   217:   dfb $18,$18,$1F,$18,$1F,$00,$00,$00 ; $D4
00:DB67 18
00:DB68 1F
00:DB69 18
00:DB6A 1F
00:DB6B 00
00:DB6C 00
00:DB6D 00
00:DB6E 00              	   218:   dfb $00,$00,$1F,$18,$1F,$18,$18,$18 ; $D5
00:DB6F 00
00:DB70 1F
00:DB71 18
00:DB72 1F
00:DB73 18
00:DB74 18
00:DB75 18
00:DB76 00              	   219:   dfb $00,$00,$00,$00,$3F,$36,$36,$36 ; $D6
00:DB77 00
00:DB78 00
00:DB79 00
00:DB7A 3F
00:DB7B 36
00:DB7C 36
00:DB7D 36
00:DB7E 36              	   220:   dfb $36,$36,$36,$36,$FF,$36,$36,$36 ; $D7
00:DB7F 36
00:DB80 36
00:DB81 36
00:DB82 FF
00:DB83 36
00:DB84 36
00:DB85 36
00:DB86 18              	   221:   dfb $18,$18,$FF,$18,$FF,$18,$18,$18 ; $D8
00:DB87 18
00:DB88 FF
00:DB89 18
00:DB8A FF
00:DB8B 18
00:DB8C 18
00:DB8D 18
00:DB8E 18              	   222:   dfb $18,$18,$18,$18,$F8,$00,$00,$00 ; $D9
00:DB8F 18
00:DB90 18
00:DB91 18
00:DB92 F8
00:DB93 00
00:DB94 00
00:DB95 00
00:DB96 00              	   223:   dfb $00,$00,$00,$00,$1F,$18,$18,$18 ; $DA
00:DB97 00
00:DB98 00
00:DB99 00
00:DB9A 1F
00:DB9B 18
00:DB9C 18
00:DB9D 18
00:DB9E FF              	   224:   dfb $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF ; $DB
00:DB9F FF
00:DBA0 FF
00:DBA1 FF
00:DBA2 FF
00:DBA3 FF
00:DBA4 FF
00:DBA5 FF
00:DBA6 00              	   225:   dfb $00,$00,$00,$00,$FF,$FF,$FF,$FF ; $DC
00:DBA7 00
00:DBA8 00
00:DBA9 00
00:DBAA FF
00:DBAB FF
00:DBAC FF
00:DBAD FF
00:DBAE F0              	   226:   dfb $F0,$F0,$F0,$F0,$F0,$F0,$F0,$F0 ; $DD
00:DBAF F0
00:DBB0 F0
00:DBB1 F0
00:DBB2 F0
00:DBB3 F0
00:DBB4 F0
00:DBB5 F0
00:DBB6 0F              	   227:   dfb $0F,$0F,$0F,$0F,$0F,$0F,$0F,$0F ; $DE
00:DBB7 0F
00:DBB8 0F
00:DBB9 0F
00:DBBA 0F
00:DBBB 0F
00:DBBC 0F
00:DBBD 0F
00:DBBE FF              	   228:   dfb $FF,$FF,$FF,$FF,$00,$00,$00,$00 ; $DF
00:DBBF FF
00:DBC0 FF
00:DBC1 FF
00:DBC2 00
00:DBC3 00
00:DBC4 00
00:DBC5 00
00:DBC6 00              	   229:   dfb $00,$00,$76,$DC,$C8,$DC,$76,$00 ; $E0
00:DBC7 00
00:DBC8 76
00:DBC9 DC
00:DBCA C8
00:DBCB DC
00:DBCC 76
00:DBCD 00
00:DBCE 00              	   230:   dfb $00,$78,$CC,$F8,$CC,$F8,$C0,$C0 ; $E1
00:DBCF 78
00:DBD0 CC
00:DBD1 F8
00:DBD2 CC
00:DBD3 F8
00:DBD4 C0
00:DBD5 C0
00:DBD6 00              	   231:   dfb $00,$FC,$CC,$C0,$C0,$C0,$C0,$00 ; $E2
00:DBD7 FC
00:DBD8 CC
00:DBD9 C0
00:DBDA C0
00:DBDB C0
00:DBDC C0
00:DBDD 00
00:DBDE 00              	   232:   dfb $00,$FE,$6C,$6C,$6C,$6C,$6C,$00 ; $E3
00:DBDF FE
00:DBE0 6C
00:DBE1 6C
00:DBE2 6C
00:DBE3 6C
00:DBE4 6C
00:DBE5 00
00:DBE6 FC              	   233:   dfb $FC,$CC,$60,$30,$60,$CC,$FC,$00 ; $E4
00:DBE7 CC
00:DBE8 60
00:DBE9 30
00:DBEA 60
00:DBEB CC
00:DBEC FC
00:DBED 00
00:DBEE 00              	   234:   dfb $00,$00,$7E,$D8,$D8,$D8,$70,$00 ; $E5
00:DBEF 00
00:DBF0 7E
00:DBF1 D8
00:DBF2 D8
00:DBF3 D8
00:DBF4 70
00:DBF5 00
00:DBF6 00              	   235:   dfb $00,$66,$66,$66,$66,$7C,$60,$C0 ; $E6
00:DBF7 66
00:DBF8 66
00:DBF9 66
00:DBFA 66
00:DBFB 7C
00:DBFC 60
00:DBFD C0
00:DBFE 00              	   236:   dfb $00,$76,$DC,$18,$18,$18,$18,$00 ; $E7
00:DBFF 76
00:DC00 DC
00:DC01 18
00:DC02 18
00:DC03 18
00:DC04 18
00:DC05 00
00:DC06 FC              	   237:   dfb $FC,$30,$78,$CC,$CC,$78,$30,$FC ; $E8
00:DC07 30
00:DC08 78
00:DC09 CC
00:DC0A CC
00:DC0B 78
00:DC0C 30
00:DC0D FC
00:DC0E 38              	   238:   dfb $38,$6C,$C6,$FE,$C6,$6C,$38,$00 ; $E9
00:DC0F 6C
00:DC10 C6
00:DC11 FE
00:DC12 C6
00:DC13 6C
00:DC14 38
00:DC15 00
00:DC16 38              	   239:   dfb $38,$6C,$C6,$C6,$6C,$6C,$EE,$00 ; $EA
00:DC17 6C
00:DC18 C6
00:DC19 C6
00:DC1A 6C
00:DC1B 6C
00:DC1C EE
00:DC1D 00
00:DC1E 1C              	   240:   dfb $1C,$30,$18,$7C,$CC,$CC,$78,$00 ; $EB
00:DC1F 30
00:DC20 18
00:DC21 7C
00:DC22 CC
00:DC23 CC
00:DC24 78
00:DC25 00
00:DC26 00              	   241:   dfb $00,$00,$7E,$DB,$DB,$7E,$00,$00 ; $EC
00:DC27 00
00:DC28 7E
00:DC29 DB
00:DC2A DB
00:DC2B 7E
00:DC2C 00
00:DC2D 00
00:DC2E 06              	   242:   dfb $06,$0C,$7E,$DB,$DB,$7E,$60,$C0 ; $ED
00:DC2F 0C
00:DC30 7E
00:DC31 DB
00:DC32 DB
00:DC33 7E
00:DC34 60
00:DC35 C0
00:DC36 38              	   243:   dfb $38,$60,$C0,$F8,$C0,$60,$38,$00 ; $EE
00:DC37 60
00:DC38 C0
00:DC39 F8
00:DC3A C0
00:DC3B 60
00:DC3C 38
00:DC3D 00
00:DC3E 78              	   244:   dfb $78,$CC,$CC,$CC,$CC,$CC,$CC,$00 ; $EF
00:DC3F CC
00:DC40 CC
00:DC41 CC
00:DC42 CC
00:DC43 CC
00:DC44 CC
00:DC45 00
00:DC46 00              	   245:   dfb $00,$FC,$00,$FC,$00,$FC,$00,$00 ; $F0
00:DC47 FC
00:DC48 00
00:DC49 FC
00:DC4A 00
00:DC4B FC
00:DC4C 00
00:DC4D 00
00:DC4E 30              	   246:   dfb $30,$30,$FC,$30,$30,$00,$FC,$00 ; $F1
00:DC4F 30
00:DC50 FC
00:DC51 30
00:DC52 30
00:DC53 00
00:DC54 FC
00:DC55 00
00:DC56 60              	   247:   dfb $60,$30,$18,$30,$60,$00,$FC,$00 ; $F2
00:DC57 30
00:DC58 18
00:DC59 30
00:DC5A 60
00:DC5B 00
00:DC5C FC
00:DC5D 00
00:DC5E 18              	   248:   dfb $18,$30,$60,$30,$18,$00,$FC,$00 ; $F3
00:DC5F 30
00:DC60 60
00:DC61 30
00:DC62 18
00:DC63 00
00:DC64 FC
00:DC65 00
00:DC66 0E              	   249:   dfb $0E,$1B,$1B,$18,$18,$18,$18,$18 ; $F4
00:DC67 1B
00:DC68 1B
00:DC69 18
00:DC6A 18
00:DC6B 18
00:DC6C 18
00:DC6D 18
00:DC6E 18              	   250:   dfb $18,$18,$18,$18,$18,$D8,$D8,$70 ; $F5
00:DC6F 18
00:DC70 18
00:DC71 18
00:DC72 18
00:DC73 D8
00:DC74 D8
00:DC75 70
00:DC76 30              	   251:   dfb $30,$30,$00,$FC,$00,$30,$30,$00 ; $F6
00:DC77 30
00:DC78 00
00:DC79 FC
00:DC7A 00
00:DC7B 30
00:DC7C 30
00:DC7D 00
00:DC7E 00              	   252:   dfb $00,$76,$DC,$00,$76,$DC,$00,$00 ; $F7
00:DC7F 76
00:DC80 DC
00:DC81 00
00:DC82 76
00:DC83 DC
00:DC84 00
00:DC85 00
00:DC86 38              	   253:   dfb $38,$6C,$6C,$38,$00,$00,$00,$00 ; $F8
00:DC87 6C
00:DC88 6C
00:DC89 38
00:DC8A 00
00:DC8B 00
00:DC8C 00
00:DC8D 00
00:DC8E 00              	   254:   dfb $00,$00,$00,$18,$18,$00,$00,$00 ; $F9
00:DC8F 00
00:DC90 00
00:DC91 18
00:DC92 18
00:DC93 00
00:DC94 00
00:DC95 00
00:DC96 00              	   255:   dfb $00,$00,$00,$00,$18,$00,$00,$00 ; $FA
00:DC97 00
00:DC98 00
00:DC99 00
00:DC9A 18
00:DC9B 00
00:DC9C 00
00:DC9D 00
00:DC9E 0F              	   256:   dfb $0F,$0C,$0C,$0C,$EC,$6C,$3C,$1C ; $FB
00:DC9F 0C
00:DCA0 0C
00:DCA1 0C
00:DCA2 EC
00:DCA3 6C
00:DCA4 3C
00:DCA5 1C
00:DCA6 78              	   257:   dfb $78,$6C,$6C,$6C,$6C,$00,$00,$00 ; $FC
00:DCA7 6C
00:DCA8 6C
00:DCA9 6C
00:DCAA 6C
00:DCAB 00
00:DCAC 00
00:DCAD 00
00:DCAE 70              	   258:   dfb $70,$18,$30,$60,$78,$00,$00,$00 ; $FD
00:DCAF 18
00:DCB0 30
00:DCB1 60
00:DCB2 78
00:DCB3 00
00:DCB4 00
00:DCB5 00
00:DCB6 00              	   259:   dfb $00,$00,$3C,$3C,$3C,$3C,$00,$00 ; $FE
00:DCB7 00
00:DCB8 3C
00:DCB9 3C
00:DCBA 3C
00:DCBB 3C
00:DCBC 00
00:DCBD 00
00:DCBE 00              	   260:   dfb $00,$00,$00,$00,$00,$00,$00,$00 ; $FF
00:DCBF 00
00:DCC0 00
00:DCC1 00
00:DCC2 00
00:DCC3 00
00:DCC4 00
00:DCC5 00
                        	   261: 

Source: "gpascal.asm"
                        	   195:   .endif
                        	   196: 
00:DCC6 472D50617363616C	   197: introduction asc    "G-Pascal compiler, version 4.04.\n"
00:DCCE 20636F6D70696C65
00:DCD6 722C207665727369
00:DCDE 6F6E20342E30342E
00:DCE6 0A
00:DCE7 5772697474656E20	   198:              asciiz "Written by Nick Gammon.\nType H for help.\n"
00:DCEF 6279204E69636B20
00:DCF7 47616D6D6F6E2E0A
00:DCFF 5479706520482066
00:DD07 6F722068656C702E
00:DD0F 0A
00:DD10 00
                        	   199: 
                        	   200:   .if LCD_SUPPORT
00:DD11 4E69636B27732047	   201: LCD_welcome asciiz "Nick's G-Pascal\nCompiler v4.04"
00:DD19 2D50617363616C0A
00:DD21 436F6D70696C6572
00:DD29 2076342E3034
00:DD2F 00
                        	   202:   .endif
                        	   203: 
                        	   204: ;
                        	   205: ; here for cold start - clear text file to null etc. etc.
                        	   206: ;
                        	   207: START    =  *
00:DD30 D8              	   208:   cld             ; cancel decimal mode
00:DD31 78              	   209:   sei             ; no interrupts yet
00:DD32 A9FF            	   210:   lda #$FF
00:DD34 8509            	   211:   sta random      ; initialise random numbers
00:DD36 850A            	   212:   sta random+1
00:DD38 850B            	   213:   sta random+2
00:DD3A 850C            	   214:   sta random+3
                        	   215: ;
                        	   216: ;  Put 0x00 at start of source
                        	   217: ;
00:DD3C A900            	   218:   lda  #<TEXT_START
00:DD3E 8500            	   219:   sta  REG
00:DD40 A903            	   220:   lda  #>TEXT_START
00:DD42 8501            	   221:   sta  REG+1
00:DD44 A900            	   222:   lda  #0
00:DD46 A8              	   223:   tay
00:DD47 9100            	   224:   sta  (REG),Y     ; null edit file
00:DD49 84BE            	   225:   sty  system_flags
00:DD4B AA              	   226:   tax
                        	   227: ;
                        	   228: ;  now do rest of initialization
                        	   229: ;
                        	   230: RESTART  =  *
00:DD4C A2FF            	   231:   ldx  #NEW_STK
00:DD4E 9A              	   232:   txs             ; reset stack
00:DD4F 58              	   233:   cli             ; allow interrupts after a NMI
00:DD50 D8              	   234:   cld             ; cancel decimal mode
00:DD51 2026CC          	   235:   jsr hardware_init
                        	   236: 
                        	   237: ;
                        	   238: REST1    =  *
                        	   239:   .if LCD_SUPPORT
                        	   240:     ;
                        	   241:     ;  put message on the LCD screen to prove it is working
                        	   242:     ;
00:DD54 A911            	   243:     lda  #<LCD_welcome  ; G-pascal compiler
00:DD56 A2DD            	   244:     ldx  #>LCD_welcome
00:DD58 20FFBB          	   245:     jsr lcd_print_message
                        	   246:   .endif
                        	   247: 
                        	   248: ;
                        	   249: ;  now direct output to the serial port
                        	   250: ;
00:DD5B 20F9CB          	   251:   jsr  write_to_serial   ; set up outputting function
00:DD5E A900            	   252:   lda  #0
00:DD60 853F            	   253:   sta  RUNNING
00:DD62 4C6B82          	   254:   jmp  main_start    ; go to "shell"
                        	   255: 
                        	   256: 
                        	   257: ;
                        	   258: ;  processor hardware vectors
                        	   259: ;
                        	   260:   .org $FFFA
01:FFFA 4CDD            	   261:   .word RESTART   ; non-maskable interrupt (NMI)
01:FFFC 30DD            	   262:   .word START     ; reset vector
01:FFFE 1EBA            	   263:   .word irq       ; maskable interrupt (IRQ)
                        	   264: 


Symbols by name:
ACT_PCDA                         S:0025
ADD1                             E:BCEB
ADD4                             E:BD0E
ADD9                             E:BD2A
ADDSYM                           E:BC8F
ADDSYM_NOT_FULL                  A:BCC4
ASS1                             A:C15C
ASS2                             A:C1A4
ASSARR                           A:C183
ASSEMBLE                         A:9B2D
ASSEMBLE_PASS                    A:9B3F
ASSEMBLE_SECOND_PASS             A:9B3A
ASSIGN                           A:C159
ASSTB1                           A:C168
ASSVAR                           A:C195
ASS_COUNT                        S:0072
ASS_EMIT_COUNT                   S:006F
ASS_OPCODE_WORK                  S:0070
ASS_OPERAND                      S:006B
ASS_OPERAND_ABSOLUTE             E:0001
ASS_OPERAND_ABSOLUTE_INDEXED_IN  E:0002
ASS_OPERAND_ABSOLUTE_INDEXED_WI  E:0003
ASS_OPERAND_ABSOLUTE_INDEXED_WI  E:0004
ASS_OPERAND_ABSOLUTE_INDIRECT    E:0005
ASS_OPERAND_ACCUMULATOR_A        E:0006
ASS_OPERAND_IMMEDIATE            E:0007
ASS_OPERAND_IMPLIED              E:0008
ASS_OPERAND_STRING               E:0011
ASS_OPERAND_ZERO_PAGE            E:000B
ASS_OPERAND_ZERO_PAGE_AND_ABSOL  E:0012
ASS_OPERAND_ZERO_PAGE_INDEXED_I  E:000C
ASS_OPERAND_ZERO_PAGE_INDEXED_W  E:000D
ASS_OPERAND_ZERO_PAGE_INDEXED_W  E:000E
ASS_OPERAND_ZERO_PAGE_INDIRECT   E:000F
ASS_OPERAND_ZERO_PAGE_INDIRECT_  E:0010
ASS_PASS                         S:0076
ASS_VALUE                        S:0073
BACKSPACE                        E:0008
BAD_INP                          A:B60F
BASE                             S:003B
BAUD_RATE                        E:12C0
BEG                              A:C409
BELL1                            E:B1C7
BIT_INTERVAL                     E:00D0
BLCKT1                           A:C62A
BLCKT2                           A:C62D
BLCKT3                           A:C630
BLK1                             A:C665
BLK1A                            A:C651
BLK2                             A:C66D
BLK4                             A:C677
BLKB1                            A:C8CD
BLKB2                            A:C8E9
BLKB3                            A:C8C7
BLKB4                            A:C905
BLKB5                            A:C8F6
BLKB6                            A:C914
BLKBEG                           A:C8BD
BLKCN1                           A:C684
BLKCNS                           A:C681
BLKFNC                           A:C7F5
BLKPR1                           A:C817
BLKPR2                           A:C849
BLKPR3                           A:C833
BLKPR4                           A:C891
BLKPR5                           E:C86A
BLKPR6                           A:C840
BLKPRC                           A:C7D5
BLKV10                           E:C6CB
BLKV10_A                         E:C6E7
BLKV10_B                         E:C6EE
BLKV11                           A:C755
BLKV12                           A:C75C
BLKV13                           A:C716
BLKVAR                           A:C698
BLKVR1                           A:C69C
BLKVR2                           A:C6FD
BLKVR3                           A:C7BD
BLKVR4                           A:C71B
BLKVR5                           E:C77B
BLKVR6                           A:C69F
BLKVR7                           A:C6A9
BLKVR8                           A:C6C8
BLKVR9                           E:C762
BLOCK                            A:C63A
BSAVE                            S:0036
CALL                             S:0047
CALLSB                           A:C335
CASE                             A:C475
CASE1                            A:C4AE
CASE2                            E:C487
CASE3                            A:C4C4
CASE4                            A:C4BA
CASE5                            A:C4F7
CASE6                            A:C515
CASE7                            A:C483
CASE8                            A:C52A
CASE9                            A:C520
CHKDUP                           A:BD36
CHKGET                           E:C603
CHKLHB                           E:BDB1
CHKLHP                           E:BD97
CHKNOK                           E:D29C
CHKOK                            E:D29F
CHKRHB                           E:BDBB
CHKRHP                           E:BD9E
CHKTKN                           A:D2A1
CHK_KBD                          E:B21B
CHK_NOTD                         A:B243
CHK_NOTN                         A:B227
CHK_NOTT                         A:B235
CHK_RUN                          A:964F
CHK_STAK                         E:BEBD
CHK_VAL                          E:963C
CHK_VAL9                         E:964E
CHRIN                            E:CC0F
CLOCK_RATE                       E:4240
COMPIL                           A:BD46
COMS8                            A:951E
COMS9                            A:951D
COMSTL                           E:9511
CONDEC                           E:BDD6
CONST                            E:BEC9
CONST1                           A:BEE0
CONST2                           A:BEEA
CONST3                           E:BEE5
CONST9                           A:BEEE
COUNT1                           S:004B
COUNT2                           S:004C
COUT                             A:969A
COUT_CALL                        A:96A4
CR                               E:000D
CROUT                            E:950C
DATA                             S:003D
DATTYP                           S:004A
DB11                             A:B0E0
DBGFLG                           S:0049
DCODE                            S:002E
DEBUG                            E:B0E0
DEBUG_DONE                       A:B148
DEST                             E:0003
DIRECTIVES                       E:A2AC
DIS5                             A:B1B0
DIS5_A                           E:B1BA
DISHX                            A:9521
DISP9                            A:CACF
DISPAD                           E:9527
DISPAD2                          A:9542
DISPL                            S:0027
DIVBY0                           A:B3C5
DM1                              A:B0C5
DM2                              A:B0CE
DM5                              A:B16F
DM6                              A:B184
DM7                              A:B18F
DUP9                             A:BD45
EFLAG_ALLOW_ZERO_FROM            E:0002
EFLAG_FIND                       E:0010
EFLAG_LOAD                       E:0004
EFLAG_NO_LINE_NUMBERS            E:0080
EFLAG_REPLACE                    E:0020
EFLAG_SAVE                       E:0008
EFLAG_SHOW_LINE                  E:0001
EFLAG_SUPPRESS_NEWLINE           E:0040
EMULATOR                         E:0000
EMULATOR_DEBUG                   A:CC23
ENDSYM                           S:0031
END_CMP                          E:BD94
END_EDITOR_INPUT                 E:001B
END_PCD                          S:0043
END_WRK                          E:C61F
ERR1                             E:9A62
ERR3                             E:9A76
ERR5                             E:9A86
ERR6                             E:9A8C
ERR7                             E:9A58
ERRLIT                           A:9A43
ERRNO                            S:0035
ERROR                            A:9A4F
EXPR1                            A:C0E5
EXPR2                            A:C107
EXPR3                            A:C10D
EXPR4                            A:C111
EXPR5                            A:C115
EXPR6                            A:C119
EXPR7                            A:C11D
EXPR8                            A:C109
EXPRES                           A:C0C2
EXPTB1                           A:C0D2
EXPTB3                           A:C0F4
EX_ABS                           A:B3E9
EX_ABSCLL                        E:B67E
EX_ADD                           A:B385
EX_ADRAC                         E:B85D
EX_ADRAN                         E:B857
EX_ADRN2                         E:B84C
EX_ADRNC                         E:B839
EX_ADRNC2                        E:B83C
EX_ADRNN                         E:B849
EX_AND                           A:B457
EX_ASSERT                        A:B8F0
EX_ASSERT_OK                     A:B905
EX_CLA                           A:B714
EX_CLL                           E:B685
EX_CLL2                          E:B6AF
EX_CLL3                          E:B6D0
EX_CLL4                          E:B6AB
EX_CLL5                          E:B711
EX_CLL_A                         E:B68D
EX_CLL_JMP                       A:B731
EX_DEC                           A:B499
EX_DELAY                         E:B8AC
EX_DIGITALREAD                   E:B863
EX_DIGITALREAD_ONE               A:B86E
EX_DIGITALWRITE                  E:B8DB
EX_DIV                           A:B3D5
EX_DIVIDE_BY_ZERO                A:B3BE
EX_EOR                           A:B460
EX_EQL                           A:B3F2
EX_FINISHD                       E:B1E5
EX_GEQ                           A:B42D
EX_GETKEY                        E:B3A3
EX_GTR                           A:B421
EX_INC                           A:B481
EX_INP                           E:B5D7
EX_INPC                          A:B79F
EX_INPC_OK                       A:B7A9
EX_INP_OK                        A:B5E8
EX_INS                           E:B7DB
EX_INS1                          E:B7FE
EX_INS2                          E:B807
EX_INS3                          E:B7E5
EX_INS4                          E:B811
EX_INT                           A:B734
EX_INVINS                        E:B298
EX_JM1                           A:B794
EX_JMP                           A:B770
EX_JMZ                           A:B783
EX_LATENCY                       A:B89D
EX_LCDCLEAR                      A:B7D5
EX_LCDHOME                       A:B7CF
EX_LCDPOS                        E:B871
EX_LCDPOS_1                      A:B881
EX_LCD_WRITE_CHR                 A:B7BE
EX_LCD_WRITE_HEX                 A:B630
EX_LCD_WRITE_NUM                 A:B61C
EX_LCD_WRITE_STR                 A:B650
EX_LDA                           A:B4F5
EX_LDAC                          A:B4EA
EX_LDI                           A:B530
EX_LDIC                          A:B52A
EX_LEQ                           A:B439
EX_LIB_CALL                      A:B8EA
EX_LIT                           A:B36A
EX_LOD                           A:B4D4
EX_LOD2                          A:B4D7
EX_LOD3                          A:B4C5
EX_LOD3_A                        A:B4C7
EX_LODC                          A:B4C2
EX_LSS                           A:B415
EX_MOD                           A:B3AA
EX_MOV                           A:B4B1
EX_MUL                           A:B39A
EX_NEG                           A:B37C
EX_NEQ                           A:B40C
EX_NEW_STACK                     A:B75E
EX_NOJUMP                        A:B78E
EX_ORR                           A:B44E
EX_OUH                           A:B62B
EX_OUH_COMMON                    A:B633
EX_OUS                           E:B64B
EX_OUS1                          A:B66F
EX_OUS_COMMON                    A:B653
EX_OUT                           A:B617
EX_OUTC                          A:B7B9
EX_OUTCR                         E:B245
EX_OUTC_COMMON                   A:B7C1
EX_PINMODE                       E:B8CC
EX_RANDOM                        A:B88B
EX_RANDOMSEED                    E:B8BC
EX_RTN                           A:B59E
EX_SHL                           A:B469
EX_SHR                           A:B475
EX_STA                           A:B556
EX_STA5                          A:B567
EX_STAC                          A:B56C
EX_STI                           A:B583
EX_STIC                          A:B575
EX_STO                           A:B543
EX_STO2                          A:B549
EX_STO5                          A:B53E
EX_STOC                          A:B536
EX_SUB                           A:B38E
EX_XOR                           A:B445
FACAD1                           A:C010
FACAD2                           A:C02E
FACADR                           E:C058
FACERR1                          A:C071
FACM2                            A:C08C
FACMEM                           A:C082
FACMMC                           A:C088
FACNOT                           A:C098
FACNUM                           E:C076
FACRND1                          A:C0A3
FACSTR                           A:C06B
FACTB1                           A:C0A9
FACTOR                           A:BFC1
FACTQT1                          A:C0AF
FALSE                            A:B408
FFLAG_GLOBAL                     E:0002
FFLAG_IGNORE_CASE                E:0001
FFLAG_QUIET                      E:0004
FIN_MSG                          A:B1FC
FIXAD                            E:CB18
FIXAD1                           A:CB55
FIXM1                            A:CB56
FIXM2                            A:CB5F
FLAG_ASSEMBLING                  E:0002
FLAG_BRK_REACHED                 E:0080
FLAG_COMPILING                   E:0001
FLAG_LIST_SOURCE                 E:0004
FLAG_ONLY_ALPHA                  E:0040
FLAG_VALID_ASSEMBLE              E:0010
FLAG_VALID_COMPILE               E:0008
FNC1                             A:C37F
FNC2                             A:C34F
FNC3                             A:C379
FNC4                             A:C3C3
FNC5                             A:C382
FNC5A                            A:C39F
FNC5B                            A:C3A1
FNC6                             A:C3C4
FNCPRC                           A:C342
FOR                              A:C530
FOR1                             A:C53A
FOR2                             A:C547
FOR3                             A:C560
FOR4                             A:C591
FOR5                             A:C5D4
FOR6                             A:C5F6
FRAME                            S:0020
FROM                             E:0040
GEN1                             E:CA76
GEN2                             E:CAAD
GEN2_A                           E:CAB8
GEN2_B                           E:CAAF
GEN2_C                           E:CACF
GEN3                             E:CB13
GENADR                           E:CA7A
GENJMP                           E:CAEA
GENNJM                           A:CAE4
GENNJP                           E:CAE2
GENNOP                           E:CA61
GENNOP1                          A:C0A0
GENNOP2                          A:C30D
GENRJMP                          E:CAD0
GEN_FULL                         A:CACA
GET1                             A:9674
GET1_A                           E:B2EF
GET2                             E:B2B3
GET3                             A:9691
GETADR                           A:B2A9
GETADR1                          E:B2D4
GETCHK                           A:D291
GETEXPR                          E:BE55
GETID2                           A:B51C
GETIDC                           A:B4FF
GETIDX                           E:B508
GETIN                            E:CC0F
GETIN1                           A:CC19
GETLIT                           E:B353
GETLN1                           E:9672
GETLN_OVERFLOW                   A:9697
GETO_1                           E:BE46
GETO_2                           E:BE53
GETSUB                           E:BDA8
GET_COMM                         E:BE87
GET_DAT                          E:BDCF
GET_END                          A:B369
GET_ITEM                         E:BE8E
GET_LEV                          E:BDC5
GET_LINE                         E:9672
GET_LOOK                         A:D2A6
GET_OFF                          E:BE2A
HIGHEST_RAM                      E:3FFF
I2C_DDR                          E:7FF3
I2C_PORT                         E:7FF1
I2C_SCL                          E:0004
I2C_SDA                          E:0008
IDENT                            A:BFD2
IDENT1                           A:BFD5
IDENT1A                          A:BFDD
IDENT2                           A:BFE2
IDENT2A                          A:BFFB
IDENT3                           A:C002
IDENT4                           A:C036
IDENT4_A                         A:C038
IDENT5                           A:C018
IDENT5_A                         A:C01A
IDENT6                           A:C025
IDENT7                           A:C02B
IF                               A:C3C9
IF1                              A:C3EE
IF2                              A:C3E7
INBUF                            S:0200
INBUF_SIZE                       E:0100
INIT                             E:94BE
INIT9                            A:950B
INIT_SECOND_PASS                 A:94CA
INP3                             A:B5FF
INTERP                           E:B149
INT_ERR                          E:B74B
INT_ERRM                         A:B752
JMP1                             E:927E
JMP2                             E:9286
JMP3                             E:929B
KEY_ABORT                        E:0003
KEY_DEBUG                        E:0004
KEY_STOP_TRACE                   E:000E
KEY_TRACE                        E:0014
LASTP                            S:004D
LCD_E                            E:0080
LCD_RS                           E:0020
LCD_RW                           E:0040
LCD_SUPPORT                      E:0001
LCD_welcome                      A:DD11
LEVEL                            S:0022
LINE_CNT                         S:0019
LIST                             S:001D
LIT1                             A:B379
LOOK1                            A:BD35
LOOKUP                           E:BD2B
LOWLIT                           A:B24B
LOWLIT1                          A:B251
MAIN                             A:B25A
MAINP                            A:B257
MAIN_1                           E:B289
MAIN_2                           E:B261
MAIN_NOT_ABORT                   E:B26C
MAIN_OK                          E:B26F
MAKE_LOWER                       E:92B3
MAKE_LOWER_DONE                  E:92BD
MAKE_UPPER                       E:92A8
MAKE_UPPER_DONE                  E:92B2
MAX_STK                          E:0020
MEM                              A:C31A
MEM2                             A:C322
MEMC                             A:C31F
NEW_STK                          E:00FF
NL                               E:000A
NOSCE                            A:94AD
NOTIM1                           E:B29C
OFFSET                           S:0029
ONE_OP                           A:C306
ONE_OP2                          A:C303
OPCODE                           S:006C
OPCODE_3_CHAR_BRANCH             E:A370
OPCODE_3_CHAR_IMPLIED            E:A395
OPCODE_4_CHAR_BRANCH             E:A31F
OPCODE_4_CHAR_ZERO_PAGE          E:A412
OPCODE_ASS_OPERAND_ABSOLUTE      E:A463
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A4CF
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A4D4
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A519
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A51C
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A541
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A55D
OPCODE_ASS_OPERAND_ABSOLUTE_TOK  E:A4CC
OPCODE_ASS_OPERAND_ACCUMULATOR_  E:A544
OPCODE_ASS_OPERAND_IMMEDIATE     E:A562
OPCODE_ASS_OPERAND_IMMEDIATE_TO  E:A593
OPCODE_ASS_OPERAND_ZERO_PAGE     E:A596
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A5FA
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A61B
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A61E
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A667
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A66A
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A673
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A697
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A6B8
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A694
OPCODE_ASS_OPERAND_ZERO_PAGE_TO  E:A5F7
OPCODE_LEN                       S:006E
OPCODE_LOOKUP_HANDLER            E:0004
OPCODE_LOOKUP_OPCODE_LENGTH      E:0000
OPCODE_LOOKUP_OPCODE_TABLE       E:0002
OPCODE_LOOKUP_OPERAND_TYPE       E:0001
OPCODE_LOOKUP_TABLE              E:A209
OPCODE_LOOKUP_TABLE_SIZE         E:0006
OPND                             S:002B
OUT_COMMON                       A:B61F
PAREN                            A:C07C
PCD_WRKD                         E:BE5B
PCODE                            S:0023
PCODE_ABSCLL                     E:0038
PCODE_ADD                        E:0004
PCODE_ADRAN                      E:000E
PCODE_ADRNN                      E:000C
PCODE_AND                        E:001B
PCODE_CLA                        E:002B
PCODE_CLL                        E:0027
PCODE_DEC                        E:0028
PCODE_DIV                        E:000A
PCODE_EOR                        E:0020
PCODE_EQL                        E:0010
PCODE_FINISHD                    E:0011
PCODE_GEQ                        E:0016
PCODE_GTR                        E:0018
PCODE_INC                        E:0026
PCODE_INP                        E:001C
PCODE_INS                        E:0025
PCODE_INT                        E:003B
PCODE_JM1                        E:003E
PCODE_JMP                        E:003C
PCODE_JMZ                        E:003D
PCODE_LAST                       E:0045
PCODE_LCD_WRITE_CHR              E:0045
PCODE_LCD_WRITE_HEX              E:0044
PCODE_LCD_WRITE_NUM              E:0042
PCODE_LCD_WRITE_STR              E:0043
PCODE_LDA                        E:002E
PCODE_LDI                        E:0030
PCODE_LEQ                        E:0019
PCODE_LIB_CALL                   E:0003
PCODE_LIT                        E:0000
PCODE_LOD                        E:002C
PCODE_LSS                        E:0014
PCODE_MOD                        E:000B
PCODE_MOV                        E:002A
PCODE_MUL                        E:0008
PCODE_NEG                        E:0002
PCODE_NEQ                        E:0012
PCODE_ORR                        E:001A
PCODE_OUH                        E:0021
PCODE_OUS                        E:0023
PCODE_OUT                        E:001E
PCODE_OUTC                       E:001F
PCODE_OUTCR                      E:0040
PCODE_RTN                        E:0029
PCODE_SHL                        E:0022
PCODE_SHR                        E:0024
PCODE_STA                        E:0034
PCODE_STACK                      E:0001
PCODE_STI                        E:0036
PCODE_STO                        E:0032
PCODE_SUB                        E:0006
PCODE_XOR                        E:003A
PRBYTE                           A:9581
PRBYTECR                         E:9636
PRCHAR                           E:9569
PRCITM                           S:0039
PRHEX                            A:958A
PRHEX1                           A:9594
PRHEXZ                           A:958C
PSH1                             E:B342
PSH9                             A:9555
PSHPCODE                         E:BE17
PSHTOP                           E:B337
PSHWRK                           E:9543
PT                               A:959B
PT6                              A:95A3
PUL2_END                         E:B330
PULBOTH                          A:B312
PULTOP                           E:B2F0
PULTOP2                          E:B315
PULWRK                           E:9556
PUL_END                          E:B30B
PUTSP                            E:9597
READ                             A:C271
READ11                           A:C291
READ2                            A:C277
READ3                            A:C2C0
READ3_A                          A:C2EF
READ3_B                          A:C2D4
READ7                            A:C2B0
READ7_A                          A:C2B6
READ8                            A:C274
READ9                            A:C28E
REG                              E:0000
REG2                             E:0003
REG2B                            E:0005
REGB                             E:0002
REMAIN                           S:0006
REP1                             A:C422
REPEAT                           A:C41F
RES                              S:0052
RESTART                          E:DD4C
RMNDR                            S:005B
RSVEND                           A:D23B
RSVWRD                           E:D148
RUNERR                           A:B1D1
RUNNING                          S:003F
RUNNING_STACK_TOP                E:00CF
SEA1                             E:BC26
SEA2                             E:BC33
SEA3                             E:BC87
SEA4                             E:BC7C
SEA5                             E:BC84
SEARCH                           E:BC13
SEA_NEXT                         E:BC1B
SERIAL_DEBUG1_MASK               E:0004
SERIAL_DEBUG2_MASK               E:0008
SERIAL_DEBUGGING                 E:0000
SERIAL_DELAY1                    E:0030
SERIAL_DELAY2                    E:0023
SERIAL_OUT_MASK                  E:0002
SERIAL_SPARE2_MASK               E:0010
SIM1                             A:BF0B
SIM2                             A:BF53
SIM3                             A:BF1C
SIM4                             A:BF2F
SIM5                             A:BF4B
SIM6                             A:BF4F
SIM7                             A:BF45
SIM8                             A:BF59
SIMEXP                           E:BF01
SINGLE_QUOTE                     E:0027
SPI_DDR                          E:7FF2
SPI_MISO                         E:0004
SPI_MOSI                         E:0002
SPI_PORT                         E:7FF0
SPI_SCK                          E:0008
SPI_SS                           E:0001
SRCE                             E:0000
START                            E:DD30
STARTSYM                         S:002F
START_OF_ROM                     E:8000
START_TRACE                      A:CC24
STK_ERR                          A:BEC4
STK_FULL                         E:BEC4
STMNT                            A:C121
STMNT1                           A:C12E
STMNT_WRITE_LCD                  A:C220
STOP_TRACE                       A:CC25
ST_SYMTBL_LIST_CHECK             E:8DDC
ST_SYMTBL_LIST_DONE              E:8E71
ST_SYMTBL_LIST_LINE              E:8DEB
ST_SYMTBL_LIST_NAME              E:8E60
ST_SYMTBL_LIST_NEXT              E:8DD1
SYMARG                           E:0006
SYMBOL_ARRAY                     E:0041
SYMBOL_CONSTANT                  E:0043
SYMBOL_FUNCTION                  E:0046
SYMBOL_FUNCTION_RETURN           E:0059
SYMBOL_LIBRARY_FUNCTION          E:0052
SYMBOL_LIBRARY_PROCEDURE         E:0051
SYMBOL_PROCEDURE                 E:0050
SYMBOL_TABLE_START               E:3FFF
SYMBOL_VARIABLE                  E:0056
SYMDAT                           E:0008
SYMDSP                           E:0004
SYMITM                           S:0040
SYMLEN                           E:0009
SYMLIB                           E:0002
SYMLVL                           E:0002
SYMNAM                           E:000A
SYMPRV                           E:0000
SYMSUB                           E:0006
SYMTYP                           E:0003
SYMWRK                           E:BE01
SYM_FULL                         A:BC8A
SYNTAX                           S:0042
T                                E:0031
TEMP                             S:0045
TERM                             A:BF73
TERM1                            A:BF80
TERM2                            A:BF76
TERM3                            A:BF91
TERM4                            A:BF8F
TERM5                            A:BF97
TERM6                            A:BF9B
TERM7                            A:BF9F
TERM8                            A:BFA3
TERM9                            A:BFA7
TERMT1                           A:BF5D
TERMT3                           A:BFAB
TEXT_START                       E:0300
TKNJMP                           E:9276
TKNWRK                           E:95AD
TOKEN_ADDRESS                    E:00A9
TOKEN_AND                        E:008D
TOKEN_ARRAY                      E:0084
TOKEN_ASSIGN                     E:0041
TOKEN_BEGIN                      E:0088
TOKEN_CALL                       E:009F
TOKEN_CASE                       E:0095
TOKEN_CHAR                       E:00A1
TOKEN_CHR                        E:00AB
TOKEN_CONST                      E:0082
TOKEN_DIV                        E:008B
TOKEN_DO                         E:0097
TOKEN_DOWNTO                     E:009C
TOKEN_ELSE                       E:0094
TOKEN_END                        E:0089
TOKEN_EQUALITY                   E:0045
TOKEN_FOR                        E:009A
TOKEN_FUNCTION                   E:0087
TOKEN_GEQ                        E:0081
TOKEN_HEX                        E:00AC
TOKEN_HIGH_BYTE                  E:0057
TOKEN_IDENTIFIER                 E:0049
TOKEN_IF                         E:0092
TOKEN_INEQUALITY                 E:005A
TOKEN_INTEGER                    E:00FE
TOKEN_LCDWRITE                   E:00F1
TOKEN_LEQ                        E:0080
TOKEN_LOGICAL_AND                E:0058
TOKEN_LOGICAL_OR                 E:0059
TOKEN_LOW_BYTE                   E:0056
TOKEN_MEM                        E:0091
TOKEN_MEMC                       E:00A2
TOKEN_MOD                        E:008C
TOKEN_NEQ                        E:0055
TOKEN_NOT                        E:0090
TOKEN_NUMBER                     E:004E
TOKEN_OF                         E:0085
TOKEN_OR                         E:008A
TOKEN_PROCEDURE                  E:0086
TOKEN_READ                       E:009E
TOKEN_REPEAT                     E:0098
TOKEN_SHIFT_LEFT                 E:004C
TOKEN_SHIFT_RIGHT                E:0052
TOKEN_SHL                        E:008E
TOKEN_SHR                        E:008F
TOKEN_STRING                     E:0022
TOKEN_THEN                       E:0093
TOKEN_TO                         E:009B
TOKEN_UNARY_MINUS                E:004D
TOKEN_UNTIL                      E:0099
TOKEN_VAR                        E:0083
TOKEN_WHILE                      E:0096
TOKEN_WRITE                      E:009D
TOKEN_WRITELN                    E:00FF
TOKEN_XOR                        E:00A4
TRUE                             A:B3FB
TRUE2                            A:B3FD
TWO_OP                           A:C2FD
USE_CP437_FONT                   E:0001
VALUE                            S:0000
VALUE2                           S:0003
VAL_1                            E:BE9D
VAL_2                            E:BEA2
VAL_3                            E:BEAB
VAL_5                            E:BEB4
VAL_MOVE                         E:BE94
VAL_WRK                          E:C614
VARDEC                           A:BEEF
VIA_ACR                          E:7FFB
VIA_DDRA                         E:7FF3
VIA_DDRB                         E:7FF2
VIA_FLAG_CB2                     E:0008
VIA_FLAG_DISABLE                 E:0000
VIA_FLAG_ENABLE                  E:0080
VIA_FLAG_TIMER1                  E:0040
VIA_IER                          E:7FFE
VIA_IFR                          E:7FFD
VIA_PCR                          E:7FFC
VIA_PORTA                        E:7FF1
VIA_PORTB                        E:7FF0
VIA_T1C_H                        E:7FF5
VIA_T1C_L                        E:7FF4
WAIT_1                           A:C310
WHILE                            A:C443
WORK                             S:0037
WORKD                            S:0033
WRIT1                            E:C1FB
WRIT10                           A:C1EE
WRIT2                            A:C1EB
WRIT5                            A:C20B
WRIT9                            A:C1D2
WRITE                            A:C1CF
WRITELN                          A:C1C0
WRITELN9                         E:C1CA
WRITE_LCD1                       E:C24C
WRITE_LCD2                       A:C23C
WRITE_LCD5                       A:C25C
WRITE_LCD9                       A:C223
WRITE_LCD_STRING                 E:C232
WRITE_LDC_CHR                    E:C265
WRITE_LDC_CHR1                   E:C267
WRITE_LDC_HEX                    E:C26D
WRKD_WRK                         E:BE71
WRKSYM                           E:BE0C
WRKTKN                           E:95B8
WRK_OPND                         E:BE66
WRK_VAL                          E:C609
WRK_WRKD                         E:BE7C
W_CHR                            E:C214
W_CHR1                           E:C216
W_HEX                            E:C21C
W_STRING                         E:C1E1
ZERRES                           A:AF5B
a_equals_message                 A:B923
add_assembler_library_functions  A:AD71
add_assembler_library_functions  A:ADC1
add_assembler_library_functions  A:AD79
add_assembler_library_functions  A:AD89
add_pascal_library_functions     A:C9B7
add_pascal_library_functions_do  A:CA10
add_pascal_library_functions_lo  A:C9BF
add_pascal_library_functions_na  A:C9CF
asm_do_asc                       E:A720
asm_do_asc_loop                  A:A72D
asm_do_asc_next                  A:A736
asm_do_asc_ok                    A:A72B
asm_do_assert                    A:A6BB
asm_do_assert_failed             A:A6CA
asm_do_blk                       A:A7F2
asm_do_blk_done                  A:A80F
asm_do_blk_loop                  A:A802
asm_do_constant_expected         A:A767
asm_do_constant_expectedJ        A:A6CF
asm_do_constant_expectedJ2       A:A828
asm_do_dfb                       A:A775
asm_do_dfb_multiple              A:A783
asm_do_dfb_multiple_done         A:A7A1
asm_do_dfb_multiple_loop         A:A790
asm_do_dfb_too_big               A:A7A2
asm_do_dfw                       A:A7B5
asm_do_dfw_multiple              A:A7C3
asm_do_dfw_multiple_done         A:A7E2
asm_do_dfw_multiple_loop         A:A7D1
asm_do_equ                       A:A744
asm_do_equ_have_label            A:A755
asm_do_list                      E:A6D2
asm_do_list1                     A:A710
asm_do_list_first_pass           A:A71F
asm_do_list_no_operand           A:A6F2
asm_do_list_not                  A:A70C
asm_do_list_ok                   A:A6F6
asm_do_nolist                    A:A6E1
asm_do_nolist_ok                 A:A6EC
asm_do_org                       A:A761
asm_do_org_ok                    A:A76C
asm_do_reserve                   A:A810
asm_do_string                    A:A73B
asm_do_sym                       A:A82B
asm_do_sym_done                  A:A844
asm_emit_one_byte                A:A7A7
asm_emit_two_bytes               A:A7E3
ass_absolute_another_value       A:9DB0
ass_added_symbol                 A:9BED
ass_already_emitted              A:A17A
ass_bad_identifier               A:9BA2
ass_bad_indirect                 A:9D17
ass_bad_zp_indirect_indexed      A:9D51
ass_branch_backwards             A:A1C5
ass_branch_ok                    A:A1C9
ass_branch_out_of_range          A:A1CF
ass_check_label_changed          A:9C57
ass_check_no_more_tokens         A:9EAB
ass_check_no_more_tokens_ok      A:9EB6
ass_check_we_have_x_or_y         A:9D58
ass_check_we_have_x_or_y_ok      A:9D74
ass_current_label                S:0083
ass_done                         A:9E68
ass_done1                        A:9E8A
ass_done_jump                    A:9B64
ass_done_message                 A:9E8D
ass_done_second_pass             A:9E72
ass_emit                         A:A157
ass_emit1                        A:A192
ass_emit2                        A:A16B
ass_emit3                        A:A18C
ass_emit4                        A:A185
ass_emit_absolute                A:A1FE
ass_emit_bytes                   S:0077
ass_emit_immediate               A:A1EB
ass_emit_immediate_too_high      A:A1F9
ass_emit_zero_page               A:A1D8
ass_emit_zero_page_too_high      A:A1E6
ass_error                        A:A195
ass_error1                       A:A19C
ass_evaluate_operator            A:A130
ass_expression_apply_operator    A:A0EF
ass_expression_apply_operator_b  A:A12B
ass_expression_cannot_be_unary   A:A09B
ass_expression_found_value       A:A029
ass_expression_loop              A:9FDC
ass_expression_loop1             A:A00D
ass_expression_loop1a            A:9FF6
ass_expression_loop2             A:A03A
ass_expression_loop3             A:A049
ass_expression_loop3a            A:A058
ass_expression_loop3b            A:A04D
ass_expression_loop3c            A:A05D
ass_expression_loop4             A:A063
ass_expression_loop6             A:A0C1
ass_expression_loop7             A:A0AA
ass_expression_loopJ             A:A060
ass_expression_loop_initial      A:9FDF
ass_expression_not_small_string  A:A008
ass_expression_number            A:9FE3
ass_expression_unary             A:A118
ass_finish_line                  A:9B59
ass_finish_lineJ                 A:9C7D
ass_fixup_bbr_branch             A:A19F
ass_fixup_branch                 A:A1AC
ass_get_value                    A:9FC2
ass_identifier                   A:9BA7
ass_identifier_operand           A:9CBB
ass_illegal_opcode               A:9C0E
ass_immediate                    A:9C9F
ass_indexed                      A:9D89
ass_indexed_x                    A:9DA7
ass_indirect                     A:9CB2
ass_indirect_with_bracket        A:9D1C
ass_label_not_found_yet          A:A021
ass_line                         A:9B67
ass_line1                        A:9B76
ass_lookup_existing_label        A:9BD7
ass_lookup_loop                  A:A133
ass_lookup_save_address          A:9BE1
ass_not_colon                    A:9BFF
ass_not_colon2                   A:9C06
ass_not_unary_greater_than       A:A085
ass_not_unary_less_than          A:A07B
ass_not_unary_minus              A:A071
ass_not_x_or_y                   A:9D56
ass_opcode                       A:9C16
ass_opcode2                      A:9C6C
ass_opcode_found                 A:A151
ass_operand                      A:9C80
ass_operand_value                A:9CDC
ass_string                       A:9C92
ass_symbol_address_changed       A:9C67
ass_value_done                   A:9D80
ass_value_not_indirect           A:9D76
ass_value_not_indirectJ          A:9D14
ass_zp_indirect_indexed          A:9D30
assembler_library_functions_tab  A:A8B1
assertion_failed_message         A:9A09
assign_bad_identifier            A:C17E
atoi                             A:CD7E
atoi_error                       E:CDED
atoi_loop                        E:CD87
atoi_more                        E:CD98
atoi_not_running                 E:CDF3
atoi_positive                    A:CD96
bad_command                      A:8248
bad_delimiter_message            A:86C3
bad_flag_message                 A:882D
bcd_output_digit                 A:9454
bcd_positive                     A:9442
bcd_result                       S:0060
bcd_skip_zeroes                  A:9449
bcd_table                        E:93D6
bcd_unpack                       A:93C3
bcd_work                         S:005C
binary_to_decimal                A:945F
binary_to_decimal_loop           A:946A
binary_to_decimal_next           A:948F
break_message                    A:B908
brk_address                      S:0015
brk_executed                     A:B954
brk_executed1                    A:B9D2
brk_executed2                    A:B9DF
brk_executed3                    A:B9EF
brk_executed4                    A:BA09
brk_executedJ                    A:BA1B
brk_resumed                      A:8CD6
bytes_message                    A:935F
call_a                           S:0010
call_assembler                   A:9668
call_handler                     A:922E
call_p                           S:0013
call_s                           S:0014
call_x                           S:0011
call_y                           S:0012
cb2_interrupt                    A:BA43
character_types_table            E:8006
compile_finished_message         A:95D6
cp437_font                       A:D4C6
crc16                            E:92E1
crc16_loop                       E:92ED
crc16_next                       A:92FA
crc16_skip                       A:9300
crc_addr                         E:0000
crc_byte                         E:9309
crc_done                         A:9308
crc_helper1                      A:9339
crc_message                      A:933C
crc_num                          E:0003
crc_source                       E:9367
crc_val                          E:0006
current_line                     S:00A2
delay                            E:93B9
delay_1ms                        E:93AF
delay_1ms_loop                   A:93B2
digitalread                      E:CBDC
digitalread_B                    A:CBEB
digitalread_C                    A:CBF3
digitalwrite                     E:CBAD
digitalwrite_B                   A:CBBE
digitalwrite_C                   A:CBC6
digitalwrite_ONE                 A:CBD4
display_in_decimal               E:9436
display_x_characters             A:B1A9
edit_library_continue            A:91AF
editor_argument_check            A:8B87
editor_argument_check_failed     A:8B99
editor_argument_check_got_argum  A:8BA3
editor_argument_check_loop       A:8B89
editor_assemble                  A:8FD8
editor_bad_delimiter             A:86D2
editor_bad_number                A:8558
editor_bad_range                 A:8613
editor_bad_rangeJ                A:86AC
editor_check_no_more             A:8640
editor_check_no_more_failed      A:8652
editor_check_no_more_loop        A:8642
editor_check_no_more_ok          A:865C
editor_compile                   A:8F15
editor_debug                     A:8ED5
editor_debug_ok                  A:8EE8
editor_default_range             A:853A
editor_delete                    A:8BA4
editor_delete_line_count_done    A:8C12
editor_delete_line_count_loop    A:8BF2
editor_delete_line_count_not_do  A:8BFE
editor_delete_line_count_not_ne  A:8C0A
editor_do_replace                A:89A2
editor_do_replace_copy_done      A:89E7
editor_do_replace_smaller        A:89E4
editor_do_the_replace            A:8908
editor_done_message              A:8E9B
editor_easy_replace              A:8915
editor_easy_replace_done         A:8926
editor_easy_replace_loop         A:8919
editor_find                      A:8757
editor_find_bug                  A:8795
editor_find_case_sensitive       A:88C6
editor_find_found_it             A:88EA
editor_find_found_it1            A:88F0
editor_find_get_flags            A:87EF
editor_find_inner_loop           A:88AF
editor_find_loop                 A:88AB
editor_find_no_match             A:88D4
editor_find_or_replacing         A:88A7
editor_find_problem              A:86D6
editor_find_second_delimiter_lo  A:87A2
editor_find_skip_this            A:88D0
editor_find_test_character       A:88C7
editor_find_third_delimiter_loo  A:87C9
editor_flags                     S:00BC
editor_flags1                    A:880F
editor_flags2                    A:8819
editor_flags3                    A:8823
editor_flags_loop                A:87F1
editor_get_delimiter             A:8700
editor_get_number                A:8562
editor_get_number_done           A:85CA
editor_get_number_end            A:85CE
editor_get_number_none           A:85CC
editor_get_number_not_identifie  A:85A4
editor_get_number_ok             A:85BA
editor_get_range                 A:865D
editor_get_range_done            A:86AB
editor_get_range_hyphen          A:8693
editor_get_range_number          A:8698
editor_handlers                  A:82D6
editor_help                      A:851B
editor_help_done                 A:8537
editor_help_info                 A:838A
editor_help_loop                 A:8526
editor_info                      E:8F03
editor_insert                    A:8A16
editor_insert_at_start           A:8A30
editor_insert_backspace          A:8ACA
editor_insert_backspace_not_at_  A:8AD6
editor_insert_common             A:8A3E
editor_insert_done               A:8AEC
editor_insert_done_with_newline  A:8AFD
editor_insert_loop               A:8A81
editor_insert_loop1              A:8ABA
editor_insert_no_line_number     A:8A92
editor_insert_not_newline        A:8AB1
editor_jmp                       A:9141
editor_jmp_got_number            A:914B
editor_jmp_number_in_range       A:9152
editor_jsr                       A:9110
editor_jsr_got_number            A:911A
editor_jsr_got_number_execute    A:913E
editor_jsr_number_in_range       A:9121
editor_library                   A:9162
editor_library_done              A:91EB
editor_library_filter_loop       A:919B
editor_library_filter_reject     A:91A6
editor_library_filter_reject_lo  A:91A8
editor_library_loop              A:918D
editor_library_make_lower_loop   A:9179
editor_library_name_loop         A:91B1
editor_library_name_onto_next    A:91DA
editor_library_no_search         A:9185
editor_library_search            A:916E
editor_line_count_done           A:8FCA
editor_line_count_loop           A:8FB4
editor_line_count_not_newline    A:8FC2
editor_line_number_too_big       A:85FA
editor_list                      A:8763
editor_list_aborted              A:889A
editor_list_check_to_line        A:8956
editor_list_check_to_line_ok     A:8966
editor_list_completely_done      A:899F
editor_list_doing_find           A:8789
editor_list_done                 A:8982
editor_list_doneJ                A:886D
editor_list_fix_target_string    A:883B
editor_list_fixup_loop           A:8843
editor_list_get_on_with_it       A:8856
editor_list_got_from_point       A:87A0
editor_list_have_source          A:8867
editor_list_loop                 A:8873
editor_list_loopJ                A:897F
editor_list_no_line_number       A:8944
editor_list_no_line_numberJ      A:8870
editor_list_not_find             A:8853
editor_list_not_finding          A:8937
editor_list_not_newline          A:896E
editor_list_skip_newline         A:8979
editor_load                      A:8A12
editor_memory                    A:8CFC
editor_memory_aborted            A:8D6F
editor_memory_ascii              A:8D7A
editor_memory_done               A:8D6C
editor_memory_loop               A:8D16
editor_memory_loop1              A:8D37
editor_memory_loop2              A:8D49
editor_memory_loop3              A:8D5F
editor_memory_not_control        A:8D82
editor_memory_not_high           A:8D88
editor_memory_show_ascii         A:8D75
editor_memory_show_dot           A:8D86
editor_newline_processing        A:894C
editor_no_closing_delimiter      A:872E
editor_no_closing_delimiterJ     A:879D
editor_no_closing_delimiter_mes  A:8718
editor_no_find_string            A:8749
editor_no_lines                  A:8B30
editor_not_assembler             A:8EDE
editor_poke                      A:9053
editor_poke_another              A:90BA
editor_poke_bad_token            A:9074
editor_poke_failed               A:90ED
editor_poke_failed_message       A:90CC
editor_poke_got_all_numbers      A:908F
editor_poke_got_enough           A:909F
editor_poke_got_number           A:9077
editor_poke_loop                 A:905D
editor_poke_message              A:902B
editor_poke_not_first            A:9086
editor_poke_to_message           A:90E7
editor_poking_loop               A:90B2
editor_recover                   A:8E86
editor_recover_not_needed        A:8EA5
editor_replace                   A:874F
editor_replacement_loop          A:88A9
editor_resume                    A:8FFD
editor_resume_ok                 A:9010
editor_run                       A:8F29
editor_save                      A:875D
editor_syntax                    A:8F1F
editor_test                      A:8CEA
editor_too_full                  A:8B18
editor_too_full_loop             A:8B1F
editor_trace                     A:8EF1
error1                           A:9AA6
error_find_next                  A:9A9D
error_found                      A:9AC7
error_loop                       A:9A99
error_next                       A:9A98
error_not_found                  A:9AAF
error_not_found_message          A:9AD4
errors_table                     A:96A7
ex_input_aborted                 A:B832
execution_aborted_message        A:B81E
execution_address_table          E:B039
exp_abs_val                      A:AF2B
exp_abs_val2                     A:AF43
exp_abs_val2_done                A:AF5A
exp_abs_val_done                 A:AF42
exp_add                          A:ADC2
exp_bitwise_and                  A:AE65
exp_bitwise_or                   A:AE50
exp_bitwise_xor                  A:AE7A
exp_divide                       A:AFC9
exp_divide_loop                  A:AFE6
exp_divide_not_zero              A:AFD9
exp_divide_subtraction_negative  A:B00E
exp_divide_subtraction_positive  A:B00F
exp_done                         A:A0D2
exp_done_error                   A:A0D8
exp_done_ok                      A:A0DD
exp_eql                          A:ADFC
exp_evaluation_function          S:007F
exp_false                        A:ADF5
exp_falseJ                       A:AE92
exp_find_sign                    A:AF64
exp_fix_sign                     A:AF7C
exp_fix_sign_done                A:AF8F
exp_geq                          A:AE49
exp_get_operator                 A:9F2D
exp_get_operator_ok              A:9F36
exp_get_precedence               A:9F9B
exp_get_precedence_found         A:9FB1
exp_get_precedence_loop          A:9F9D
exp_greater_than                 A:AE2B
exp_high_byte                    A:AF22
exp_leq                          A:AE3A
exp_less_than                    A:AE24
exp_logical_and                  A:AEA4
exp_logical_or                   A:AE95
exp_low_byte                     A:AF1D
exp_modulo                       A:B029
exp_multiply                     A:AF90
exp_multiply_loop                A:AF95
exp_multiply_no_add              A:AFB6
exp_negate                       A:AEE8
exp_negate_val                   A:AF2F
exp_negate_val2                  A:AF47
exp_neq                          A:AE10
exp_no_operators_left            A:A0C9
exp_not                          A:AEFB
exp_operator                     S:007D
exp_operator_precedence          S:007E
exp_operator_stack_count         S:007C
exp_pop_operator                 A:9F1D
exp_pop_operator_ok              A:9F26
exp_pop_value                    E:9EE2
exp_pop_value_ok                 A:9EEB
exp_precedence_table             A:9F3B
exp_precedence_table_end         E:9F9B
exp_push_operator                A:9F0B
exp_push_operator_ok             A:9F16
exp_push_value                   E:9EB7
exp_push_value_memory_full       A:9EBD
exp_push_value_not_full          A:9ED1
exp_push_value_ok                A:9EC2
exp_shift_left                   A:AEB6
exp_shift_left_done              A:AECE
exp_shift_left_loop              A:AEC5
exp_shift_right                  A:AECF
exp_shift_right_done             A:AEE7
exp_shift_right_loop             A:AEDE
exp_subtract                     A:ADD6
exp_true                         A:ADEC
exp_trueJ                        A:AE8F
exp_unary_minus                  A:AF09
exp_unary_ok                     S:0081
exp_value_stack                  S:0079
exp_value_stack_count            S:007B
find_count                       S:00B9
find_delimiter                   S:00B4
find_flags                       S:00BD
find_from                        S:00B0
find_len                         S:00B3
find_line                        A:8C85
find_line_eof                    A:8CB8
find_line_loop                   A:8C93
find_line_next                   A:8CA2
find_line_same_line              A:8CB0
find_pos                         S:00B2
find_source_end                  A:8CB9
find_source_end_done             E:8CD5
find_source_end_loop             E:8CC1
find_source_end_wrap             E:8CCF
find_string_too_long             A:86FA
find_string_too_longJ            A:879A
find_string_too_long_message     A:86DC
find_to                          S:00B1
found_message                    A:86AF
found_this_line                  S:00BB
from_line                        S:009E
from_msg                         A:86B7
gc_alpha_alpha_only              A:CD0F
gc_alpha_done                    A:CD0B
gc_alpha_loop                    A:CCF2
gc_alpha_ok                      A:CCFA
gc_ampersand                     A:D104
gc_assembler_comment_find_end    A:CF13
gc_assembler_comment_keep_looki  A:CF25
gc_assembler_comment_not_eof     A:CF1E
gc_assign                        A:D0A0
gc_backslash_tokens              A:CF2D
gc_backslash_tokens_end          E:CF43
gc_backslash_tokens_length       E:0016
gc_bang                          A:D137
gc_bar                           A:D115
gc_binary_literal                A:D077
gc_binary_loop                   A:D07F
gc_colon                         A:D095
gc_comment_found_end             A:CEAC
gc_comment_keep_looking          A:CEA4
gc_comment_not_eof               A:CE8C
gc_comment_not_newline           A:CE95
gc_directive_list                A:CEF4
gc_directive_nolist              A:CF01
gc_directive_pcodes              A:CEFB
gc_directive_symbols             A:CEBC
gc_directive_symbols_ok          A:CEC8
gc_directive_symbols_too_late    A:CEEF
gc_dollar                        A:D011
gc_done                          A:CCD5
gc_equality                      A:D131
gc_equals                        A:D126
gc_fix_hex                       A:CFD5
gc_fix_hex_not_a_to_f            A:CFDE
gc_geq                           A:D0D9
gc_greater_than                  A:D0C9
gc_hex_done                      A:D061
gc_hex_literal                   A:D01D
gc_hex_loop                      A:D026
gc_hex_too_big                   A:D066
gc_inequality                    A:D142
gc_leq                           A:D0BA
gc_less_than                     A:D0A6
gc_lh_brace                      A:CE50
gc_lh_paren                      A:CE54
gc_logical_and                   A:D10F
gc_logical_or                    A:D120
gc_minus                         A:D0E3
gc_neq                           A:D0BF
gc_newline                       A:CCB2
gc_newline1                      A:CCBF
gc_newline_assembling            A:CCCC
gc_not_alpha                     A:CD18
gc_not_digit                     A:CD24
gc_not_space                     A:CCED
gc_pascal_comment                A:CE62
gc_pascal_comment_find_end       A:CE81
gc_percent                       A:D06B
gc_plus                          A:D0E5
gc_quote                         A:CF43
gc_quote_backslash_loop          A:CFAC
gc_quote_bad                     A:CF5A
gc_quote_bad_string              A:CFB7
gc_quote_copied_value            A:CF7F
gc_quote_done                    A:CF88
gc_quote_found_backslash_charac  A:CFC0
gc_quote_hex_character           A:CFE2
gc_quote_hex_character_done      A:CFBC
gc_quote_hex_character_one_only  A:D00E
gc_quote_long_string             A:CF74
gc_quote_loop                    A:CF51
gc_quote_loop_not_end_of_line    A:CF5F
gc_quote_not_backslash           A:CFC4
gc_quote_not_finished            A:CF9A
gc_quote_too_long                A:CFD0
gc_semicolon                     A:CF0A
gc_shift_left                    A:D0C4
gc_shift_right                   A:D0DE
gc_single_byte_already_known     A:CCD1
gc_single_byte_already_knownJ    A:CE4D
gc_single_byte_already_knownJ2   A:D0D6
gc_single_byte_token             A:CCD3
gc_single_byte_tokenJ            A:CE4A
gc_skip_spaces                   A:CC9D
gen_random                       A:92BE
gen_random1                      A:92E0
get_token                        A:CC8F
get_token_loop                   A:CC93
gtoken_directive_table           A:CE3D
gtoken_table                     A:CE0C
handlerLookup                    A:91EE
handler_find_length              A:91F6
handler_found_directive          A:921C
handler_found_length             A:91FF
handler_loop                     A:91F0
handler_next                     A:9203
handler_same_length              A:9213
handlers_done                    A:922C
hardware_init                    A:CC26
hardware_work                    S:008C
i2c_begin_transmission           A:D2DA
i2c_begin_transmission_loop      A:D2DE
i2c_delay                        A:D2BB
i2c_end_transmission             A:D39D
i2c_init                         A:D2B0
i2c_read                         A:D347
i2c_read_ack_or_nak              A:D384
i2c_read_ack_or_nak_wait         A:D389
i2c_read_done                    A:D39B
i2c_read_loop                    A:D350
i2c_read_nak                     A:D37F
i2c_read_next                    A:D369
i2c_read_zero                    A:D365
i2c_receive                      A:D3DF
i2c_receive_done                 A:D402
i2c_receive_fail                 A:D407
i2c_receive_loop                 A:D3ED
i2c_send                         A:D3B6
i2c_send_done                    A:D3D5
i2c_send_fail                    A:D3DA
i2c_send_loop                    A:D3BE
i2c_toggle_clock                 A:D2BF
i2c_toggle_clock_wait            A:D2C7
i2c_write                        A:D301
i2c_write_clock                  A:D31B
i2c_write_clock_wait             A:D32B
i2c_write_got_ack                A:D345
i2c_write_loop                   A:D304
i2c_write_lost_arbitration       A:D343
i2c_write_one                    A:D310
id_equals_message                A:B94B
info_message                     A:A845
insert_limit                     S:00A4
introduction                     A:DCC6
irq                              A:BA1E
irq1                             A:BA2B
irq_done                         A:BAA3
is_xxx_fail                      A:8106
is_xxx_pass                      A:810A
isalnum                          E:8162
isalpha                          E:8126
isbin                            A:8176
isbinary                         E:816E
iscntrl                          E:8156
isdigit                          E:8132
islower                          E:811A
isspace                          E:814A
isupper                          E:810E
isxdigit                         E:813E
lcd_clear_display                A:BBE7
lcd_clear_enable                 A:BB43
lcd_data_nibble                  A:BBA6
lcd_get_address                  A:BB73
lcd_home                         A:BBF7
lcd_initialise                   A:BAA6
lcd_instruction                  A:BB93
lcd_prepare_to_read_register     A:BAFF
lcd_prepare_to_write_data        A:BB12
lcd_prepare_to_write_instructio  A:BB27
lcd_print                        A:BC08
lcd_print_char                   A:BBB5
lcd_print_char_newline           A:BBD6
lcd_print_char_ok                A:BBD6
lcd_print_char_on_2nd_line       A:BBCF
lcd_print_done                   A:BC12
lcd_print_message                A:BBFF
lcd_print_not_newline            A:BBC0
lcd_read_instruction_nibble      A:BB4C
lcd_second_line                  A:BBEF
lcd_set_enable                   A:BB3A
lcd_wait                         A:BB58
lcd_wait_timeout                 A:BB6F
lcd_work                         S:0086
lcd_write_instruction_nibble     A:BB87
lcdbusy                          A:BB60
library_function_call            A:CA11
library_function_call_1          A:CA4D
library_function_call_2          A:CA1E
library_function_call_3          A:CA48
library_function_call_5          A:CA50
line_number_lt_1000              A:8C60
line_number_output_spaces        A:8C6F
lines_deleted_message            A:8C3C
list_symbols                     E:A850
list_symbols_check               E:A86A
list_symbols_done                E:A8B0
list_symbols_line                E:A879
list_symbols_name                E:A89F
list_symbols_next                E:A85F
list_symbols_user                A:A885
load_message                     A:89F0
m_alnum                          E:0080
m_alpha                          E:0004
m_cntrl                          E:0040
m_digit                          E:0008
m_lower                          E:0002
m_space                          E:0020
m_upper                          E:0001
m_xdigit                         E:0010
main_loop                        A:828C
main_loop_not_run                A:82B8
main_prompt                      A:8272
main_start                       A:826B
maths_work                       S:008D
mem_move_dest                    S:00A8
mem_move_len                     S:00AA
mem_move_src                     S:00A6
memory_filled_up                 A:8B5E
memory_full                      A:8B43
movedown                         A:817A
movedown1                        A:819D
movedown2                        A:8190
movedown_done                    A:819C
movedown_loop                    A:8186
moveup                           A:81A6
moveup3                          A:81D8
moveup_done                      A:81E4
moveup_loop                      A:81CE
moveup_next                      E:81E5
negate_token_value               A:CDF8
no_break_message                 A:8FDE
no_find_message                  A:8734
no_valid_compile_message         A:960C
not_assembler_message            A:8EAF
notbin                           A:8178
number_bad_range_message         A:8604
number_expected_message          A:8547
number_too_large_message         A:85DB
opcode_lookup                    A:9DBF
opcode_lookup_correct_length     A:9DEA
opcode_lookup_correct_operand    A:9E18
opcode_lookup_loop               A:9DD1
opcode_lookup_loop_done          A:9E2F
opcode_lookup_loop_unknown       A:9E64
opcode_lookup_next_table         A:9DDB
opcode_lookup_no_handler         A:9E2E
opcode_lookup_ok                 A:9E67
p_equals_message                 A:B93B
partial_handler_Lookup           A:9231
partial_handler_done             A:9275
partial_handler_found_directive  A:9261
partial_handler_next             A:924A
partial_handler_next_found_item  A:9251
partial_handler_next_item        A:9233
partial_handler_next_loop        A:923B
partial_handler_skipped_string   A:9268
pas_gc_identifier                A:D247
pas_gc_loop                      A:D24F
pas_gc_more                      A:D258
pas_gc_no_match                  E:D280
pas_get_token                    A:D23D
pas_get_token_eof                A:D246
pascal_library_functions_table   A:C917
pcodes_ended_message             A:95C3
pin_number_to_mask               E:CB6B
pin_number_to_mask_done          A:CB79
pin_number_to_mask_loop          A:CB71
pinmode                          A:CB7E
pinmode_B                        A:CB8F
pinmode_C                        A:CB97
pinmode_OUTPUT                   A:CBA5
prchar_not_control               A:957C
print                            A:8226
print_done                       A:823E
print_loop                       A:8234
prompt                           A:8245
random                           S:0009
recover_done                     A:8E74
recover_not_needed               A:8E7A
rep_diff                         S:00B7
rep_from                         S:00B5
rep_to                           S:00B6
run_assembler                    A:965B
running_message                  A:B0D7
s_equals_message                 A:B943
serial_available                 E:CC20
serial_in_byte                   S:008A
serial_in_byte_received          S:008B
serial_in_loop                   A:BA4F
serial_out_bit                   S:0089
serial_out_byte                  S:0087
serial_print                     A:CC84
serial_print_done                A:CC8E
serial_print_message             A:CC7E
serial_send_count_bits           A:BA94
show_current_line                A:9AE4
show_current_line_done           A:9B29
show_current_line_loop           A:9B06
show_current_line_loop_print_on  A:9B1E
show_current_line_number         A:8C47
show_current_line_number_done    A:8C7B
show_source_end                  A:8F5A
show_source_lines                A:8FA4
show_source_start                A:8F82
show_symbol_table_end            A:8F35
show_symbols                     S:0082
source_ended_message             A:8F47
source_length_message            A:934F
source_line_count                A:8F94
source_starts_message            A:8F6F
spi_init                         A:D40C
spi_init2                        A:D42A
spi_init3                        A:D43C
spi_init_clock_high              A:D425
spi_init_mosi_low                A:D437
spi_mode                         S:0068
spi_read_02_done                 A:D479
spi_read_13_done                 A:D49C
spi_send2                        A:D46A
spi_send3                        A:D47B
spi_send4                        A:D48D
spi_send_bit_done                A:D49E
spi_send_clock_high_low          A:D465
spi_send_clock_low_high          A:D488
spi_send_clock_pulse_1           A:D458
spi_send_two_bytes               A:D4B6
spi_send_zero                    A:D453
spi_ss_high                      A:D4AE
spi_ss_low                       A:D4A6
spi_transfer                     A:D442
spi_transfer_loop                A:D447
stack_message                    A:BA13
str_compare                      A:81F0
str_compare_done                 A:81FE
str_ic_compare                   A:8201
str_ic_compare_done              A:8223
str_ic_compare_fixed_dest        A:821E
str_ic_compare_fixed_srce        A:8210
str_work                         S:0085
symbol_table_ended_message       A:95F4
symbol_table_message             A:8D9F
system_flags                     S:00BE
this_line                        S:00AC
this_line_addr                   S:00AE
timer1_interrupt                 A:BA74
to_line                          S:00A0
to_msg                           A:86BE
token_address                    S:0090
token_digit                      S:009B
token_length                     S:0092
token_line                       A:CD2F
token_line1                      A:CD35
token_line_done                  A:CD7D
token_line_listing               A:CD50
token_line_loop                  A:CD68
token_line_loop1                 A:CD78
token_line_start                 S:009C
token_sign                       S:0097
token_start                      S:008E
token_type                       S:0093
token_value                      S:0094
token_work                       S:0098
too_much_on_line                 A:861D
typing_latency                   S:000D
write_char                       A:CC59
write_char_loop                  A:CC75
write_function                   S:0017
write_to_lcd                     A:CC04
write_to_serial                  A:CBF9
write_zero                       A:BA8F
wtf_loop                         A:9E53
x_equals_message                 A:B92B
y_equals_message                 A:B933

Symbols by value:
0000 EMULATOR
0000 OPCODE_LOOKUP_OPCODE_LENGTH
0000 PCODE_LIT
0000 REG
0000 SERIAL_DEBUGGING
0000 SRCE
0000 SYMPRV
0000 VALUE
0000 VIA_FLAG_DISABLE
0000 crc_addr
0001 ASS_OPERAND_ABSOLUTE
0001 EFLAG_SHOW_LINE
0001 FFLAG_IGNORE_CASE
0001 FLAG_COMPILING
0001 LCD_SUPPORT
0001 OPCODE_LOOKUP_OPERAND_TYPE
0001 PCODE_STACK
0001 SPI_SS
0001 USE_CP437_FONT
0001 m_upper
0002 ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
0002 EFLAG_ALLOW_ZERO_FROM
0002 FFLAG_GLOBAL
0002 FLAG_ASSEMBLING
0002 OPCODE_LOOKUP_OPCODE_TABLE
0002 PCODE_NEG
0002 REGB
0002 SERIAL_OUT_MASK
0002 SPI_MOSI
0002 SYMLIB
0002 SYMLVL
0002 m_lower
0003 ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
0003 DEST
0003 KEY_ABORT
0003 PCODE_LIB_CALL
0003 REG2
0003 SYMTYP
0003 VALUE2
0003 crc_num
0004 ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
0004 EFLAG_LOAD
0004 FFLAG_QUIET
0004 FLAG_LIST_SOURCE
0004 I2C_SCL
0004 KEY_DEBUG
0004 OPCODE_LOOKUP_HANDLER
0004 PCODE_ADD
0004 SERIAL_DEBUG1_MASK
0004 SPI_MISO
0004 SYMDSP
0004 m_alpha
0005 ASS_OPERAND_ABSOLUTE_INDIRECT
0005 REG2B
0006 ASS_OPERAND_ACCUMULATOR_A
0006 OPCODE_LOOKUP_TABLE_SIZE
0006 PCODE_SUB
0006 REMAIN
0006 SYMARG
0006 SYMSUB
0006 crc_val
0007 ASS_OPERAND_IMMEDIATE
0008 ASS_OPERAND_IMPLIED
0008 BACKSPACE
0008 EFLAG_SAVE
0008 FLAG_VALID_COMPILE
0008 I2C_SDA
0008 PCODE_MUL
0008 SERIAL_DEBUG2_MASK
0008 SPI_SCK
0008 SYMDAT
0008 VIA_FLAG_CB2
0008 m_digit
0009 SYMLEN
0009 random
000A NL
000A PCODE_DIV
000A SYMNAM
000B ASS_OPERAND_ZERO_PAGE
000B PCODE_MOD
000C ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
000C PCODE_ADRNN
000D ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
000D CR
000D typing_latency
000E ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
000E KEY_STOP_TRACE
000E PCODE_ADRAN
000F ASS_OPERAND_ZERO_PAGE_INDIRECT
0010 ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
0010 EFLAG_FIND
0010 FLAG_VALID_ASSEMBLE
0010 PCODE_EQL
0010 SERIAL_SPARE2_MASK
0010 call_a
0010 m_xdigit
0011 ASS_OPERAND_STRING
0011 PCODE_FINISHD
0011 call_x
0012 ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE
0012 PCODE_NEQ
0012 call_y
0013 call_p
0014 KEY_TRACE
0014 PCODE_LSS
0014 call_s
0015 brk_address
0016 PCODE_GEQ
0016 gc_backslash_tokens_length
0017 write_function
0018 PCODE_GTR
0019 LINE_CNT
0019 PCODE_LEQ
001A PCODE_ORR
001B END_EDITOR_INPUT
001B PCODE_AND
001C PCODE_INP
001D LIST
001E PCODE_OUT
001F PCODE_OUTC
0020 EFLAG_REPLACE
0020 FRAME
0020 LCD_RS
0020 MAX_STK
0020 PCODE_EOR
0020 m_space
0021 PCODE_OUH
0022 LEVEL
0022 PCODE_SHL
0022 TOKEN_STRING
0023 PCODE
0023 PCODE_OUS
0023 SERIAL_DELAY2
0024 PCODE_SHR
0025 ACT_PCDA
0025 PCODE_INS
0026 PCODE_INC
0027 DISPL
0027 PCODE_CLL
0027 SINGLE_QUOTE
0028 PCODE_DEC
0029 OFFSET
0029 PCODE_RTN
002A PCODE_MOV
002B OPND
002B PCODE_CLA
002C PCODE_LOD
002E DCODE
002E PCODE_LDA
002F STARTSYM
0030 PCODE_LDI
0030 SERIAL_DELAY1
0031 ENDSYM
0031 T
0032 PCODE_STO
0033 WORKD
0034 PCODE_STA
0035 ERRNO
0036 BSAVE
0036 PCODE_STI
0037 WORK
0038 PCODE_ABSCLL
0039 PRCITM
003A PCODE_XOR
003B BASE
003B PCODE_INT
003C PCODE_JMP
003D DATA
003D PCODE_JMZ
003E PCODE_JM1
003F RUNNING
0040 EFLAG_SUPPRESS_NEWLINE
0040 FLAG_ONLY_ALPHA
0040 FROM
0040 LCD_RW
0040 PCODE_OUTCR
0040 SYMITM
0040 VIA_FLAG_TIMER1
0040 m_cntrl
0041 SYMBOL_ARRAY
0041 TOKEN_ASSIGN
0042 PCODE_LCD_WRITE_NUM
0042 SYNTAX
0043 END_PCD
0043 PCODE_LCD_WRITE_STR
0043 SYMBOL_CONSTANT
0044 PCODE_LCD_WRITE_HEX
0045 PCODE_LAST
0045 PCODE_LCD_WRITE_CHR
0045 TEMP
0045 TOKEN_EQUALITY
0046 SYMBOL_FUNCTION
0047 CALL
0049 DBGFLG
0049 TOKEN_IDENTIFIER
004A DATTYP
004B COUNT1
004C COUNT2
004C TOKEN_SHIFT_LEFT
004D LASTP
004D TOKEN_UNARY_MINUS
004E TOKEN_NUMBER
0050 SYMBOL_PROCEDURE
0051 SYMBOL_LIBRARY_PROCEDURE
0052 RES
0052 SYMBOL_LIBRARY_FUNCTION
0052 TOKEN_SHIFT_RIGHT
0055 TOKEN_NEQ
0056 SYMBOL_VARIABLE
0056 TOKEN_LOW_BYTE
0057 TOKEN_HIGH_BYTE
0058 TOKEN_LOGICAL_AND
0059 SYMBOL_FUNCTION_RETURN
0059 TOKEN_LOGICAL_OR
005A TOKEN_INEQUALITY
005B RMNDR
005C bcd_work
0060 bcd_result
0068 spi_mode
006B ASS_OPERAND
006C OPCODE
006E OPCODE_LEN
006F ASS_EMIT_COUNT
0070 ASS_OPCODE_WORK
0072 ASS_COUNT
0073 ASS_VALUE
0076 ASS_PASS
0077 ass_emit_bytes
0079 exp_value_stack
007B exp_value_stack_count
007C exp_operator_stack_count
007D exp_operator
007E exp_operator_precedence
007F exp_evaluation_function
0080 EFLAG_NO_LINE_NUMBERS
0080 FLAG_BRK_REACHED
0080 LCD_E
0080 TOKEN_LEQ
0080 VIA_FLAG_ENABLE
0080 m_alnum
0081 TOKEN_GEQ
0081 exp_unary_ok
0082 TOKEN_CONST
0082 show_symbols
0083 TOKEN_VAR
0083 ass_current_label
0084 TOKEN_ARRAY
0085 TOKEN_OF
0085 str_work
0086 TOKEN_PROCEDURE
0086 lcd_work
0087 TOKEN_FUNCTION
0087 serial_out_byte
0088 TOKEN_BEGIN
0089 TOKEN_END
0089 serial_out_bit
008A TOKEN_OR
008A serial_in_byte
008B TOKEN_DIV
008B serial_in_byte_received
008C TOKEN_MOD
008C hardware_work
008D TOKEN_AND
008D maths_work
008E TOKEN_SHL
008E token_start
008F TOKEN_SHR
0090 TOKEN_NOT
0090 token_address
0091 TOKEN_MEM
0092 TOKEN_IF
0092 token_length
0093 TOKEN_THEN
0093 token_type
0094 TOKEN_ELSE
0094 token_value
0095 TOKEN_CASE
0096 TOKEN_WHILE
0097 TOKEN_DO
0097 token_sign
0098 TOKEN_REPEAT
0098 token_work
0099 TOKEN_UNTIL
009A TOKEN_FOR
009B TOKEN_TO
009B token_digit
009C TOKEN_DOWNTO
009C token_line_start
009D TOKEN_WRITE
009E TOKEN_READ
009E from_line
009F TOKEN_CALL
00A0 to_line
00A1 TOKEN_CHAR
00A2 TOKEN_MEMC
00A2 current_line
00A4 TOKEN_XOR
00A4 insert_limit
00A6 mem_move_src
00A8 mem_move_dest
00A9 TOKEN_ADDRESS
00AA mem_move_len
00AB TOKEN_CHR
00AC TOKEN_HEX
00AC this_line
00AE this_line_addr
00B0 find_from
00B1 find_to
00B2 find_pos
00B3 find_len
00B4 find_delimiter
00B5 rep_from
00B6 rep_to
00B7 rep_diff
00B9 find_count
00BB found_this_line
00BC editor_flags
00BD find_flags
00BE system_flags
00CF RUNNING_STACK_TOP
00D0 BIT_INTERVAL
00F1 TOKEN_LCDWRITE
00FE TOKEN_INTEGER
00FF NEW_STK
00FF TOKEN_WRITELN
0100 INBUF_SIZE
0200 INBUF
0300 TEXT_START
12C0 BAUD_RATE
3FFF HIGHEST_RAM
3FFF SYMBOL_TABLE_START
7FF0 SPI_PORT
7FF0 VIA_PORTB
7FF1 I2C_PORT
7FF1 VIA_PORTA
7FF2 SPI_DDR
7FF2 VIA_DDRB
7FF3 I2C_DDR
7FF3 VIA_DDRA
7FF4 VIA_T1C_L
7FF5 VIA_T1C_H
7FFB VIA_ACR
7FFC VIA_PCR
7FFD VIA_IFR
7FFE VIA_IER
8000 START_OF_ROM
8006 character_types_table
8106 is_xxx_fail
810A is_xxx_pass
810E isupper
811A islower
8126 isalpha
8132 isdigit
813E isxdigit
814A isspace
8156 iscntrl
8162 isalnum
816E isbinary
8176 isbin
8178 notbin
817A movedown
8186 movedown_loop
8190 movedown2
819C movedown_done
819D movedown1
81A6 moveup
81CE moveup_loop
81D8 moveup3
81E4 moveup_done
81E5 moveup_next
81F0 str_compare
81FE str_compare_done
8201 str_ic_compare
8210 str_ic_compare_fixed_srce
821E str_ic_compare_fixed_dest
8223 str_ic_compare_done
8226 print
8234 print_loop
823E print_done
8245 prompt
8248 bad_command
826B main_start
8272 main_prompt
828C main_loop
82B8 main_loop_not_run
82D6 editor_handlers
838A editor_help_info
851B editor_help
8526 editor_help_loop
8537 editor_help_done
853A editor_default_range
8547 number_expected_message
8558 editor_bad_number
8562 editor_get_number
85A4 editor_get_number_not_identifier
85BA editor_get_number_ok
85CA editor_get_number_done
85CC editor_get_number_none
85CE editor_get_number_end
85DB number_too_large_message
85FA editor_line_number_too_big
8604 number_bad_range_message
8613 editor_bad_range
861D too_much_on_line
8640 editor_check_no_more
8642 editor_check_no_more_loop
8652 editor_check_no_more_failed
865C editor_check_no_more_ok
865D editor_get_range
8693 editor_get_range_hyphen
8698 editor_get_range_number
86AB editor_get_range_done
86AC editor_bad_rangeJ
86AF found_message
86B7 from_msg
86BE to_msg
86C3 bad_delimiter_message
86D2 editor_bad_delimiter
86D6 editor_find_problem
86DC find_string_too_long_message
86FA find_string_too_long
8700 editor_get_delimiter
8718 editor_no_closing_delimiter_message
872E editor_no_closing_delimiter
8734 no_find_message
8749 editor_no_find_string
874F editor_replace
8757 editor_find
875D editor_save
8763 editor_list
8789 editor_list_doing_find
8795 editor_find_bug
879A find_string_too_longJ
879D editor_no_closing_delimiterJ
87A0 editor_list_got_from_point
87A2 editor_find_second_delimiter_loop
87C9 editor_find_third_delimiter_loop
87EF editor_find_get_flags
87F1 editor_flags_loop
880F editor_flags1
8819 editor_flags2
8823 editor_flags3
882D bad_flag_message
883B editor_list_fix_target_string
8843 editor_list_fixup_loop
8853 editor_list_not_find
8856 editor_list_get_on_with_it
8867 editor_list_have_source
886D editor_list_doneJ
8870 editor_list_no_line_numberJ
8873 editor_list_loop
889A editor_list_aborted
88A7 editor_find_or_replacing
88A9 editor_replacement_loop
88AB editor_find_loop
88AF editor_find_inner_loop
88C6 editor_find_case_sensitive
88C7 editor_find_test_character
88D0 editor_find_skip_this
88D4 editor_find_no_match
88EA editor_find_found_it
88F0 editor_find_found_it1
8908 editor_do_the_replace
8915 editor_easy_replace
8919 editor_easy_replace_loop
8926 editor_easy_replace_done
8937 editor_list_not_finding
8944 editor_list_no_line_number
894C editor_newline_processing
8956 editor_list_check_to_line
8966 editor_list_check_to_line_ok
896E editor_list_not_newline
8979 editor_list_skip_newline
897F editor_list_loopJ
8982 editor_list_done
899F editor_list_completely_done
89A2 editor_do_replace
89E4 editor_do_replace_smaller
89E7 editor_do_replace_copy_done
89F0 load_message
8A12 editor_load
8A16 editor_insert
8A30 editor_insert_at_start
8A3E editor_insert_common
8A81 editor_insert_loop
8A92 editor_insert_no_line_number
8AB1 editor_insert_not_newline
8ABA editor_insert_loop1
8ACA editor_insert_backspace
8AD6 editor_insert_backspace_not_at_start
8AEC editor_insert_done
8AFD editor_insert_done_with_newline
8B18 editor_too_full
8B1F editor_too_full_loop
8B30 editor_no_lines
8B43 memory_full
8B5E memory_filled_up
8B87 editor_argument_check
8B89 editor_argument_check_loop
8B99 editor_argument_check_failed
8BA3 editor_argument_check_got_argument
8BA4 editor_delete
8BF2 editor_delete_line_count_loop
8BFE editor_delete_line_count_not_done
8C0A editor_delete_line_count_not_newline
8C12 editor_delete_line_count_done
8C3C lines_deleted_message
8C47 show_current_line_number
8C60 line_number_lt_1000
8C6F line_number_output_spaces
8C7B show_current_line_number_done
8C85 find_line
8C93 find_line_loop
8CA2 find_line_next
8CB0 find_line_same_line
8CB8 find_line_eof
8CB9 find_source_end
8CC1 find_source_end_loop
8CCF find_source_end_wrap
8CD5 find_source_end_done
8CD6 brk_resumed
8CEA editor_test
8CFC editor_memory
8D16 editor_memory_loop
8D37 editor_memory_loop1
8D49 editor_memory_loop2
8D5F editor_memory_loop3
8D6C editor_memory_done
8D6F editor_memory_aborted
8D75 editor_memory_show_ascii
8D7A editor_memory_ascii
8D82 editor_memory_not_control
8D86 editor_memory_show_dot
8D88 editor_memory_not_high
8D9F symbol_table_message
8DD1 ST_SYMTBL_LIST_NEXT
8DDC ST_SYMTBL_LIST_CHECK
8DEB ST_SYMTBL_LIST_LINE
8E60 ST_SYMTBL_LIST_NAME
8E71 ST_SYMTBL_LIST_DONE
8E74 recover_done
8E7A recover_not_needed
8E86 editor_recover
8E9B editor_done_message
8EA5 editor_recover_not_needed
8EAF not_assembler_message
8ED5 editor_debug
8EDE editor_not_assembler
8EE8 editor_debug_ok
8EF1 editor_trace
8F03 editor_info
8F15 editor_compile
8F1F editor_syntax
8F29 editor_run
8F35 show_symbol_table_end
8F47 source_ended_message
8F5A show_source_end
8F6F source_starts_message
8F82 show_source_start
8F94 source_line_count
8FA4 show_source_lines
8FB4 editor_line_count_loop
8FC2 editor_line_count_not_newline
8FCA editor_line_count_done
8FD8 editor_assemble
8FDE no_break_message
8FFD editor_resume
9010 editor_resume_ok
902B editor_poke_message
9053 editor_poke
905D editor_poke_loop
9074 editor_poke_bad_token
9077 editor_poke_got_number
9086 editor_poke_not_first
908F editor_poke_got_all_numbers
909F editor_poke_got_enough
90B2 editor_poking_loop
90BA editor_poke_another
90CC editor_poke_failed_message
90E7 editor_poke_to_message
90ED editor_poke_failed
9110 editor_jsr
911A editor_jsr_got_number
9121 editor_jsr_number_in_range
913E editor_jsr_got_number_execute
9141 editor_jmp
914B editor_jmp_got_number
9152 editor_jmp_number_in_range
9162 editor_library
916E editor_library_search
9179 editor_library_make_lower_loop
9185 editor_library_no_search
918D editor_library_loop
919B editor_library_filter_loop
91A6 editor_library_filter_reject
91A8 editor_library_filter_reject_loop
91AF edit_library_continue
91B1 editor_library_name_loop
91DA editor_library_name_onto_next
91EB editor_library_done
91EE handlerLookup
91F0 handler_loop
91F6 handler_find_length
91FF handler_found_length
9203 handler_next
9213 handler_same_length
921C handler_found_directive
922C handlers_done
922E call_handler
9231 partial_handler_Lookup
9233 partial_handler_next_item
923B partial_handler_next_loop
924A partial_handler_next
9251 partial_handler_next_found_item_length
9261 partial_handler_found_directive
9268 partial_handler_skipped_string
9275 partial_handler_done
9276 TKNJMP
927E JMP1
9286 JMP2
929B JMP3
92A8 MAKE_UPPER
92B2 MAKE_UPPER_DONE
92B3 MAKE_LOWER
92BD MAKE_LOWER_DONE
92BE gen_random
92E0 gen_random1
92E1 crc16
92ED crc16_loop
92FA crc16_next
9300 crc16_skip
9308 crc_done
9309 crc_byte
9339 crc_helper1
933C crc_message
934F source_length_message
935F bytes_message
9367 crc_source
93AF delay_1ms
93B2 delay_1ms_loop
93B9 delay
93C3 bcd_unpack
93D6 bcd_table
9436 display_in_decimal
9442 bcd_positive
9449 bcd_skip_zeroes
9454 bcd_output_digit
945F binary_to_decimal
946A binary_to_decimal_loop
948F binary_to_decimal_next
94AD NOSCE
94BE INIT
94CA INIT_SECOND_PASS
950B INIT9
950C CROUT
9511 COMSTL
951D COMS9
951E COMS8
9521 DISHX
9527 DISPAD
9542 DISPAD2
9543 PSHWRK
9555 PSH9
9556 PULWRK
9569 PRCHAR
957C prchar_not_control
9581 PRBYTE
958A PRHEX
958C PRHEXZ
9594 PRHEX1
9597 PUTSP
959B PT
95A3 PT6
95AD TKNWRK
95B8 WRKTKN
95C3 pcodes_ended_message
95D6 compile_finished_message
95F4 symbol_table_ended_message
960C no_valid_compile_message
9636 PRBYTECR
963C CHK_VAL
964E CHK_VAL9
964F CHK_RUN
965B run_assembler
9668 call_assembler
9672 GETLN1
9672 GET_LINE
9674 GET1
9691 GET3
9697 GETLN_OVERFLOW
969A COUT
96A4 COUT_CALL
96A7 errors_table
9A09 assertion_failed_message
9A43 ERRLIT
9A4F ERROR
9A58 ERR7
9A62 ERR1
9A76 ERR3
9A86 ERR5
9A8C ERR6
9A98 error_next
9A99 error_loop
9A9D error_find_next
9AA6 error1
9AAF error_not_found
9AC7 error_found
9AD4 error_not_found_message
9AE4 show_current_line
9B06 show_current_line_loop
9B1E show_current_line_loop_print_one_character
9B29 show_current_line_done
9B2D ASSEMBLE
9B3A ASSEMBLE_SECOND_PASS
9B3F ASSEMBLE_PASS
9B59 ass_finish_line
9B64 ass_done_jump
9B67 ass_line
9B76 ass_line1
9BA2 ass_bad_identifier
9BA7 ass_identifier
9BD7 ass_lookup_existing_label
9BE1 ass_lookup_save_address
9BED ass_added_symbol
9BFF ass_not_colon
9C06 ass_not_colon2
9C0E ass_illegal_opcode
9C16 ass_opcode
9C57 ass_check_label_changed
9C67 ass_symbol_address_changed
9C6C ass_opcode2
9C7D ass_finish_lineJ
9C80 ass_operand
9C92 ass_string
9C9F ass_immediate
9CB2 ass_indirect
9CBB ass_identifier_operand
9CDC ass_operand_value
9D14 ass_value_not_indirectJ
9D17 ass_bad_indirect
9D1C ass_indirect_with_bracket
9D30 ass_zp_indirect_indexed
9D51 ass_bad_zp_indirect_indexed
9D56 ass_not_x_or_y
9D58 ass_check_we_have_x_or_y
9D74 ass_check_we_have_x_or_y_ok
9D76 ass_value_not_indirect
9D80 ass_value_done
9D89 ass_indexed
9DA7 ass_indexed_x
9DB0 ass_absolute_another_value
9DBF opcode_lookup
9DD1 opcode_lookup_loop
9DDB opcode_lookup_next_table
9DEA opcode_lookup_correct_length
9E18 opcode_lookup_correct_operand
9E2E opcode_lookup_no_handler
9E2F opcode_lookup_loop_done
9E53 wtf_loop
9E64 opcode_lookup_loop_unknown
9E67 opcode_lookup_ok
9E68 ass_done
9E72 ass_done_second_pass
9E8A ass_done1
9E8D ass_done_message
9EAB ass_check_no_more_tokens
9EB6 ass_check_no_more_tokens_ok
9EB7 exp_push_value
9EBD exp_push_value_memory_full
9EC2 exp_push_value_ok
9ED1 exp_push_value_not_full
9EE2 exp_pop_value
9EEB exp_pop_value_ok
9F0B exp_push_operator
9F16 exp_push_operator_ok
9F1D exp_pop_operator
9F26 exp_pop_operator_ok
9F2D exp_get_operator
9F36 exp_get_operator_ok
9F3B exp_precedence_table
9F9B exp_get_precedence
9F9B exp_precedence_table_end
9F9D exp_get_precedence_loop
9FB1 exp_get_precedence_found
9FC2 ass_get_value
9FDC ass_expression_loop
9FDF ass_expression_loop_initial
9FE3 ass_expression_number
9FF6 ass_expression_loop1a
A008 ass_expression_not_small_string
A00D ass_expression_loop1
A021 ass_label_not_found_yet
A029 ass_expression_found_value
A03A ass_expression_loop2
A049 ass_expression_loop3
A04D ass_expression_loop3b
A058 ass_expression_loop3a
A05D ass_expression_loop3c
A060 ass_expression_loopJ
A063 ass_expression_loop4
A071 ass_not_unary_minus
A07B ass_not_unary_less_than
A085 ass_not_unary_greater_than
A09B ass_expression_cannot_be_unary
A0AA ass_expression_loop7
A0C1 ass_expression_loop6
A0C9 exp_no_operators_left
A0D2 exp_done
A0D8 exp_done_error
A0DD exp_done_ok
A0EF ass_expression_apply_operator
A118 ass_expression_unary
A12B ass_expression_apply_operator_bug
A130 ass_evaluate_operator
A133 ass_lookup_loop
A151 ass_opcode_found
A157 ass_emit
A16B ass_emit2
A17A ass_already_emitted
A185 ass_emit4
A18C ass_emit3
A192 ass_emit1
A195 ass_error
A19C ass_error1
A19F ass_fixup_bbr_branch
A1AC ass_fixup_branch
A1C5 ass_branch_backwards
A1C9 ass_branch_ok
A1CF ass_branch_out_of_range
A1D8 ass_emit_zero_page
A1E6 ass_emit_zero_page_too_high
A1EB ass_emit_immediate
A1F9 ass_emit_immediate_too_high
A1FE ass_emit_absolute
A209 OPCODE_LOOKUP_TABLE
A2AC DIRECTIVES
A31F OPCODE_4_CHAR_BRANCH
A370 OPCODE_3_CHAR_BRANCH
A395 OPCODE_3_CHAR_IMPLIED
A412 OPCODE_4_CHAR_ZERO_PAGE
A463 OPCODE_ASS_OPERAND_ABSOLUTE
A4CC OPCODE_ASS_OPERAND_ABSOLUTE_TOKENISED
A4CF OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
A4D4 OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
A519 OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X_TOKENISED
A51C OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
A541 OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y_TOKENISED
A544 OPCODE_ASS_OPERAND_ACCUMULATOR_A
A55D OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT
A562 OPCODE_ASS_OPERAND_IMMEDIATE
A593 OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED
A596 OPCODE_ASS_OPERAND_ZERO_PAGE
A5F7 OPCODE_ASS_OPERAND_ZERO_PAGE_TOKENISED
A5FA OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
A61B OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT_TOKENISED
A61E OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
A667 OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X_TOKENISED
A66A OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
A673 OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT
A694 OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_TOKENISED
A697 OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
A6B8 OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y_TOKENISED
A6BB asm_do_assert
A6CA asm_do_assert_failed
A6CF asm_do_constant_expectedJ
A6D2 asm_do_list
A6E1 asm_do_nolist
A6EC asm_do_nolist_ok
A6F2 asm_do_list_no_operand
A6F6 asm_do_list_ok
A70C asm_do_list_not
A710 asm_do_list1
A71F asm_do_list_first_pass
A720 asm_do_asc
A72B asm_do_asc_ok
A72D asm_do_asc_loop
A736 asm_do_asc_next
A73B asm_do_string
A744 asm_do_equ
A755 asm_do_equ_have_label
A761 asm_do_org
A767 asm_do_constant_expected
A76C asm_do_org_ok
A775 asm_do_dfb
A783 asm_do_dfb_multiple
A790 asm_do_dfb_multiple_loop
A7A1 asm_do_dfb_multiple_done
A7A2 asm_do_dfb_too_big
A7A7 asm_emit_one_byte
A7B5 asm_do_dfw
A7C3 asm_do_dfw_multiple
A7D1 asm_do_dfw_multiple_loop
A7E2 asm_do_dfw_multiple_done
A7E3 asm_emit_two_bytes
A7F2 asm_do_blk
A802 asm_do_blk_loop
A80F asm_do_blk_done
A810 asm_do_reserve
A828 asm_do_constant_expectedJ2
A82B asm_do_sym
A844 asm_do_sym_done
A845 info_message
A850 list_symbols
A85F list_symbols_next
A86A list_symbols_check
A879 list_symbols_line
A885 list_symbols_user
A89F list_symbols_name
A8B0 list_symbols_done
A8B1 assembler_library_functions_table
AD71 add_assembler_library_functions
AD79 add_assembler_library_functions_loop
AD89 add_assembler_library_functions_name_loop
ADC1 add_assembler_library_functions_done
ADC2 exp_add
ADD6 exp_subtract
ADEC exp_true
ADF5 exp_false
ADFC exp_eql
AE10 exp_neq
AE24 exp_less_than
AE2B exp_greater_than
AE3A exp_leq
AE49 exp_geq
AE50 exp_bitwise_or
AE65 exp_bitwise_and
AE7A exp_bitwise_xor
AE8F exp_trueJ
AE92 exp_falseJ
AE95 exp_logical_or
AEA4 exp_logical_and
AEB6 exp_shift_left
AEC5 exp_shift_left_loop
AECE exp_shift_left_done
AECF exp_shift_right
AEDE exp_shift_right_loop
AEE7 exp_shift_right_done
AEE8 exp_negate
AEFB exp_not
AF09 exp_unary_minus
AF1D exp_low_byte
AF22 exp_high_byte
AF2B exp_abs_val
AF2F exp_negate_val
AF42 exp_abs_val_done
AF43 exp_abs_val2
AF47 exp_negate_val2
AF5A exp_abs_val2_done
AF5B ZERRES
AF64 exp_find_sign
AF7C exp_fix_sign
AF8F exp_fix_sign_done
AF90 exp_multiply
AF95 exp_multiply_loop
AFB6 exp_multiply_no_add
AFC9 exp_divide
AFD9 exp_divide_not_zero
AFE6 exp_divide_loop
B00E exp_divide_subtraction_negative
B00F exp_divide_subtraction_positive
B029 exp_modulo
B039 execution_address_table
B0C5 DM1
B0CE DM2
B0D7 running_message
B0E0 DB11
B0E0 DEBUG
B148 DEBUG_DONE
B149 INTERP
B16F DM5
B184 DM6
B18F DM7
B1A9 display_x_characters
B1B0 DIS5
B1BA DIS5_A
B1C7 BELL1
B1D1 RUNERR
B1E5 EX_FINISHD
B1FC FIN_MSG
B21B CHK_KBD
B227 CHK_NOTN
B235 CHK_NOTT
B243 CHK_NOTD
B245 EX_OUTCR
B24B LOWLIT
B251 LOWLIT1
B257 MAINP
B25A MAIN
B261 MAIN_2
B26C MAIN_NOT_ABORT
B26F MAIN_OK
B289 MAIN_1
B298 EX_INVINS
B29C NOTIM1
B2A9 GETADR
B2B3 GET2
B2D4 GETADR1
B2EF GET1_A
B2F0 PULTOP
B30B PUL_END
B312 PULBOTH
B315 PULTOP2
B330 PUL2_END
B337 PSHTOP
B342 PSH1
B353 GETLIT
B369 GET_END
B36A EX_LIT
B379 LIT1
B37C EX_NEG
B385 EX_ADD
B38E EX_SUB
B39A EX_MUL
B3A3 EX_GETKEY
B3AA EX_MOD
B3BE EX_DIVIDE_BY_ZERO
B3C5 DIVBY0
B3D5 EX_DIV
B3E9 EX_ABS
B3F2 EX_EQL
B3FB TRUE
B3FD TRUE2
B408 FALSE
B40C EX_NEQ
B415 EX_LSS
B421 EX_GTR
B42D EX_GEQ
B439 EX_LEQ
B445 EX_XOR
B44E EX_ORR
B457 EX_AND
B460 EX_EOR
B469 EX_SHL
B475 EX_SHR
B481 EX_INC
B499 EX_DEC
B4B1 EX_MOV
B4C2 EX_LODC
B4C5 EX_LOD3
B4C7 EX_LOD3_A
B4D4 EX_LOD
B4D7 EX_LOD2
B4EA EX_LDAC
B4F5 EX_LDA
B4FF GETIDC
B508 GETIDX
B51C GETID2
B52A EX_LDIC
B530 EX_LDI
B536 EX_STOC
B53E EX_STO5
B543 EX_STO
B549 EX_STO2
B556 EX_STA
B567 EX_STA5
B56C EX_STAC
B575 EX_STIC
B583 EX_STI
B59E EX_RTN
B5D7 EX_INP
B5E8 EX_INP_OK
B5FF INP3
B60F BAD_INP
B617 EX_OUT
B61C EX_LCD_WRITE_NUM
B61F OUT_COMMON
B62B EX_OUH
B630 EX_LCD_WRITE_HEX
B633 EX_OUH_COMMON
B64B EX_OUS
B650 EX_LCD_WRITE_STR
B653 EX_OUS_COMMON
B66F EX_OUS1
B67E EX_ABSCLL
B685 EX_CLL
B68D EX_CLL_A
B6AB EX_CLL4
B6AF EX_CLL2
B6D0 EX_CLL3
B711 EX_CLL5
B714 EX_CLA
B731 EX_CLL_JMP
B734 EX_INT
B74B INT_ERR
B752 INT_ERRM
B75E EX_NEW_STACK
B770 EX_JMP
B783 EX_JMZ
B78E EX_NOJUMP
B794 EX_JM1
B79F EX_INPC
B7A9 EX_INPC_OK
B7B9 EX_OUTC
B7BE EX_LCD_WRITE_CHR
B7C1 EX_OUTC_COMMON
B7CF EX_LCDHOME
B7D5 EX_LCDCLEAR
B7DB EX_INS
B7E5 EX_INS3
B7FE EX_INS1
B807 EX_INS2
B811 EX_INS4
B81E execution_aborted_message
B832 ex_input_aborted
B839 EX_ADRNC
B83C EX_ADRNC2
B849 EX_ADRNN
B84C EX_ADRN2
B857 EX_ADRAN
B85D EX_ADRAC
B863 EX_DIGITALREAD
B86E EX_DIGITALREAD_ONE
B871 EX_LCDPOS
B881 EX_LCDPOS_1
B88B EX_RANDOM
B89D EX_LATENCY
B8AC EX_DELAY
B8BC EX_RANDOMSEED
B8CC EX_PINMODE
B8DB EX_DIGITALWRITE
B8EA EX_LIB_CALL
B8F0 EX_ASSERT
B905 EX_ASSERT_OK
B908 break_message
B923 a_equals_message
B92B x_equals_message
B933 y_equals_message
B93B p_equals_message
B943 s_equals_message
B94B id_equals_message
B954 brk_executed
B9D2 brk_executed1
B9DF brk_executed2
B9EF brk_executed3
BA09 brk_executed4
BA13 stack_message
BA1B brk_executedJ
BA1E irq
BA2B irq1
BA43 cb2_interrupt
BA4F serial_in_loop
BA74 timer1_interrupt
BA8F write_zero
BA94 serial_send_count_bits
BAA3 irq_done
BAA6 lcd_initialise
BAFF lcd_prepare_to_read_register
BB12 lcd_prepare_to_write_data
BB27 lcd_prepare_to_write_instruction
BB3A lcd_set_enable
BB43 lcd_clear_enable
BB4C lcd_read_instruction_nibble
BB58 lcd_wait
BB60 lcdbusy
BB6F lcd_wait_timeout
BB73 lcd_get_address
BB87 lcd_write_instruction_nibble
BB93 lcd_instruction
BBA6 lcd_data_nibble
BBB5 lcd_print_char
BBC0 lcd_print_not_newline
BBCF lcd_print_char_on_2nd_line
BBD6 lcd_print_char_newline
BBD6 lcd_print_char_ok
BBE7 lcd_clear_display
BBEF lcd_second_line
BBF7 lcd_home
BBFF lcd_print_message
BC08 lcd_print
BC12 lcd_print_done
BC13 SEARCH
BC1B SEA_NEXT
BC26 SEA1
BC33 SEA2
BC7C SEA4
BC84 SEA5
BC87 SEA3
BC8A SYM_FULL
BC8F ADDSYM
BCC4 ADDSYM_NOT_FULL
BCEB ADD1
BD0E ADD4
BD2A ADD9
BD2B LOOKUP
BD35 LOOK1
BD36 CHKDUP
BD45 DUP9
BD46 COMPIL
BD94 END_CMP
BD97 CHKLHP
BD9E CHKRHP
BDA8 GETSUB
BDB1 CHKLHB
BDBB CHKRHB
BDC5 GET_LEV
BDCF GET_DAT
BDD6 CONDEC
BE01 SYMWRK
BE0C WRKSYM
BE17 PSHPCODE
BE2A GET_OFF
BE46 GETO_1
BE53 GETO_2
BE55 GETEXPR
BE5B PCD_WRKD
BE66 WRK_OPND
BE71 WRKD_WRK
BE7C WRK_WRKD
BE87 GET_COMM
BE8E GET_ITEM
BE94 VAL_MOVE
BE9D VAL_1
BEA2 VAL_2
BEAB VAL_3
BEB4 VAL_5
BEBD CHK_STAK
BEC4 STK_ERR
BEC4 STK_FULL
BEC9 CONST
BEE0 CONST1
BEE5 CONST3
BEEA CONST2
BEEE CONST9
BEEF VARDEC
BF01 SIMEXP
BF0B SIM1
BF1C SIM3
BF2F SIM4
BF45 SIM7
BF4B SIM5
BF4F SIM6
BF53 SIM2
BF59 SIM8
BF5D TERMT1
BF73 TERM
BF76 TERM2
BF80 TERM1
BF8F TERM4
BF91 TERM3
BF97 TERM5
BF9B TERM6
BF9F TERM7
BFA3 TERM8
BFA7 TERM9
BFAB TERMT3
BFC1 FACTOR
BFD2 IDENT
BFD5 IDENT1
BFDD IDENT1A
BFE2 IDENT2
BFFB IDENT2A
C002 IDENT3
C010 FACAD1
C018 IDENT5
C01A IDENT5_A
C025 IDENT6
C02B IDENT7
C02E FACAD2
C036 IDENT4
C038 IDENT4_A
C058 FACADR
C06B FACSTR
C071 FACERR1
C076 FACNUM
C07C PAREN
C082 FACMEM
C088 FACMMC
C08C FACM2
C098 FACNOT
C0A0 GENNOP1
C0A3 FACRND1
C0A9 FACTB1
C0AF FACTQT1
C0C2 EXPRES
C0D2 EXPTB1
C0E5 EXPR1
C0F4 EXPTB3
C107 EXPR2
C109 EXPR8
C10D EXPR3
C111 EXPR4
C115 EXPR5
C119 EXPR6
C11D EXPR7
C121 STMNT
C12E STMNT1
C159 ASSIGN
C15C ASS1
C168 ASSTB1
C17E assign_bad_identifier
C183 ASSARR
C195 ASSVAR
C1A4 ASS2
C1C0 WRITELN
C1CA WRITELN9
C1CF WRITE
C1D2 WRIT9
C1E1 W_STRING
C1EB WRIT2
C1EE WRIT10
C1FB WRIT1
C20B WRIT5
C214 W_CHR
C216 W_CHR1
C21C W_HEX
C220 STMNT_WRITE_LCD
C223 WRITE_LCD9
C232 WRITE_LCD_STRING
C23C WRITE_LCD2
C24C WRITE_LCD1
C25C WRITE_LCD5
C265 WRITE_LDC_CHR
C267 WRITE_LDC_CHR1
C26D WRITE_LDC_HEX
C271 READ
C274 READ8
C277 READ2
C28E READ9
C291 READ11
C2B0 READ7
C2B6 READ7_A
C2C0 READ3
C2D4 READ3_B
C2EF READ3_A
C2FD TWO_OP
C303 ONE_OP2
C306 ONE_OP
C30D GENNOP2
C310 WAIT_1
C31A MEM
C31F MEMC
C322 MEM2
C335 CALLSB
C342 FNCPRC
C34F FNC2
C379 FNC3
C37F FNC1
C382 FNC5
C39F FNC5A
C3A1 FNC5B
C3C3 FNC4
C3C4 FNC6
C3C9 IF
C3E7 IF2
C3EE IF1
C409 BEG
C41F REPEAT
C422 REP1
C443 WHILE
C475 CASE
C483 CASE7
C487 CASE2
C4AE CASE1
C4BA CASE4
C4C4 CASE3
C4F7 CASE5
C515 CASE6
C520 CASE9
C52A CASE8
C530 FOR
C53A FOR1
C547 FOR2
C560 FOR3
C591 FOR4
C5D4 FOR5
C5F6 FOR6
C603 CHKGET
C609 WRK_VAL
C614 VAL_WRK
C61F END_WRK
C62A BLCKT1
C62D BLCKT2
C630 BLCKT3
C63A BLOCK
C651 BLK1A
C665 BLK1
C66D BLK2
C677 BLK4
C681 BLKCNS
C684 BLKCN1
C698 BLKVAR
C69C BLKVR1
C69F BLKVR6
C6A9 BLKVR7
C6C8 BLKVR8
C6CB BLKV10
C6E7 BLKV10_A
C6EE BLKV10_B
C6FD BLKVR2
C716 BLKV13
C71B BLKVR4
C755 BLKV11
C75C BLKV12
C762 BLKVR9
C77B BLKVR5
C7BD BLKVR3
C7D5 BLKPRC
C7F5 BLKFNC
C817 BLKPR1
C833 BLKPR3
C840 BLKPR6
C849 BLKPR2
C86A BLKPR5
C891 BLKPR4
C8BD BLKBEG
C8C7 BLKB3
C8CD BLKB1
C8E9 BLKB2
C8F6 BLKB5
C905 BLKB4
C914 BLKB6
C917 pascal_library_functions_table
C9B7 add_pascal_library_functions
C9BF add_pascal_library_functions_loop
C9CF add_pascal_library_functions_name_loop
CA10 add_pascal_library_functions_done
CA11 library_function_call
CA1E library_function_call_2
CA48 library_function_call_3
CA4D library_function_call_1
CA50 library_function_call_5
CA61 GENNOP
CA76 GEN1
CA7A GENADR
CAAD GEN2
CAAF GEN2_B
CAB8 GEN2_A
CACA GEN_FULL
CACF DISP9
CACF GEN2_C
CAD0 GENRJMP
CAE2 GENNJP
CAE4 GENNJM
CAEA GENJMP
CB13 GEN3
CB18 FIXAD
CB55 FIXAD1
CB56 FIXM1
CB5F FIXM2
CB6B pin_number_to_mask
CB71 pin_number_to_mask_loop
CB79 pin_number_to_mask_done
CB7E pinmode
CB8F pinmode_B
CB97 pinmode_C
CBA5 pinmode_OUTPUT
CBAD digitalwrite
CBBE digitalwrite_B
CBC6 digitalwrite_C
CBD4 digitalwrite_ONE
CBDC digitalread
CBEB digitalread_B
CBF3 digitalread_C
CBF9 write_to_serial
CC04 write_to_lcd
CC0F CHRIN
CC0F GETIN
CC19 GETIN1
CC20 serial_available
CC23 EMULATOR_DEBUG
CC24 START_TRACE
CC25 STOP_TRACE
CC26 hardware_init
CC59 write_char
CC75 write_char_loop
CC7E serial_print_message
CC84 serial_print
CC8E serial_print_done
CC8F get_token
CC93 get_token_loop
CC9D gc_skip_spaces
CCB2 gc_newline
CCBF gc_newline1
CCCC gc_newline_assembling
CCD1 gc_single_byte_already_known
CCD3 gc_single_byte_token
CCD5 gc_done
CCED gc_not_space
CCF2 gc_alpha_loop
CCFA gc_alpha_ok
CD0B gc_alpha_done
CD0F gc_alpha_alpha_only
CD18 gc_not_alpha
CD24 gc_not_digit
CD2F token_line
CD35 token_line1
CD50 token_line_listing
CD68 token_line_loop
CD78 token_line_loop1
CD7D token_line_done
CD7E atoi
CD87 atoi_loop
CD96 atoi_positive
CD98 atoi_more
CDED atoi_error
CDF3 atoi_not_running
CDF8 negate_token_value
CE0C gtoken_table
CE3D gtoken_directive_table
CE4A gc_single_byte_tokenJ
CE4D gc_single_byte_already_knownJ
CE50 gc_lh_brace
CE54 gc_lh_paren
CE62 gc_pascal_comment
CE81 gc_pascal_comment_find_end
CE8C gc_comment_not_eof
CE95 gc_comment_not_newline
CEA4 gc_comment_keep_looking
CEAC gc_comment_found_end
CEBC gc_directive_symbols
CEC8 gc_directive_symbols_ok
CEEF gc_directive_symbols_too_late
CEF4 gc_directive_list
CEFB gc_directive_pcodes
CF01 gc_directive_nolist
CF0A gc_semicolon
CF13 gc_assembler_comment_find_end
CF1E gc_assembler_comment_not_eof
CF25 gc_assembler_comment_keep_looking
CF2D gc_backslash_tokens
CF43 gc_backslash_tokens_end
CF43 gc_quote
CF51 gc_quote_loop
CF5A gc_quote_bad
CF5F gc_quote_loop_not_end_of_line
CF74 gc_quote_long_string
CF7F gc_quote_copied_value
CF88 gc_quote_done
CF9A gc_quote_not_finished
CFAC gc_quote_backslash_loop
CFB7 gc_quote_bad_string
CFBC gc_quote_hex_character_done
CFC0 gc_quote_found_backslash_character
CFC4 gc_quote_not_backslash
CFD0 gc_quote_too_long
CFD5 gc_fix_hex
CFDE gc_fix_hex_not_a_to_f
CFE2 gc_quote_hex_character
D00E gc_quote_hex_character_one_only
D011 gc_dollar
D01D gc_hex_literal
D026 gc_hex_loop
D061 gc_hex_done
D066 gc_hex_too_big
D06B gc_percent
D077 gc_binary_literal
D07F gc_binary_loop
D095 gc_colon
D0A0 gc_assign
D0A6 gc_less_than
D0BA gc_leq
D0BF gc_neq
D0C4 gc_shift_left
D0C9 gc_greater_than
D0D6 gc_single_byte_already_knownJ2
D0D9 gc_geq
D0DE gc_shift_right
D0E3 gc_minus
D0E5 gc_plus
D104 gc_ampersand
D10F gc_logical_and
D115 gc_bar
D120 gc_logical_or
D126 gc_equals
D131 gc_equality
D137 gc_bang
D142 gc_inequality
D148 RSVWRD
D23B RSVEND
D23D pas_get_token
D246 pas_get_token_eof
D247 pas_gc_identifier
D24F pas_gc_loop
D258 pas_gc_more
D280 pas_gc_no_match
D291 GETCHK
D29C CHKNOK
D29F CHKOK
D2A1 CHKTKN
D2A6 GET_LOOK
D2B0 i2c_init
D2BB i2c_delay
D2BF i2c_toggle_clock
D2C7 i2c_toggle_clock_wait
D2DA i2c_begin_transmission
D2DE i2c_begin_transmission_loop
D301 i2c_write
D304 i2c_write_loop
D310 i2c_write_one
D31B i2c_write_clock
D32B i2c_write_clock_wait
D343 i2c_write_lost_arbitration
D345 i2c_write_got_ack
D347 i2c_read
D350 i2c_read_loop
D365 i2c_read_zero
D369 i2c_read_next
D37F i2c_read_nak
D384 i2c_read_ack_or_nak
D389 i2c_read_ack_or_nak_wait
D39B i2c_read_done
D39D i2c_end_transmission
D3B6 i2c_send
D3BE i2c_send_loop
D3D5 i2c_send_done
D3DA i2c_send_fail
D3DF i2c_receive
D3ED i2c_receive_loop
D402 i2c_receive_done
D407 i2c_receive_fail
D40C spi_init
D425 spi_init_clock_high
D42A spi_init2
D437 spi_init_mosi_low
D43C spi_init3
D442 spi_transfer
D447 spi_transfer_loop
D453 spi_send_zero
D458 spi_send_clock_pulse_1
D465 spi_send_clock_high_low
D46A spi_send2
D479 spi_read_02_done
D47B spi_send3
D488 spi_send_clock_low_high
D48D spi_send4
D49C spi_read_13_done
D49E spi_send_bit_done
D4A6 spi_ss_low
D4AE spi_ss_high
D4B6 spi_send_two_bytes
D4C6 cp437_font
DCC6 introduction
DD11 LCD_welcome
DD30 START
DD4C RESTART
4240 CLOCK_RATE
