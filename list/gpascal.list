Sections:
00: "seg8000" (8000-DCA9)
01: "segfffa" (FFFA-0)


Source: "gpascal.asm"
                        	     1: ;***********************************************
                        	     2: ; G-PASCAL COMPILER
                        	     3: ; for Ben Eater's breadboard computer
                        	     4: ;
                        	     5: ; Author: Nick Gammon
                        	     6: ; Date: 20 January 2022
                        	     7: ;
                        	     8: ; To compile:
                        	     9: ;
                        	    10: ;  vasm6502_oldstyle gpascal.asm -wdc02 -esc -Fbin -o gpascal.bin -dotdir -L gpascal.list
                        	    11: ;
                        	    12: ; To program EEPROM:
                        	    13: ;
                        	    14: ;  minipro -p AT28C256 -w gpascal.bin
                        	    15: ;
                        	    16: ;
                        	    17: ;
                        	    18: ; To communicate, I suggest: miniterm /dev/ttyUSB0 4800 -e
                        	    19: ;
                        	    20: ;   Miniterm: Ctrl+]        : to exit.
                        	    21: ;             Ctrl+T Ctrl+H : help
                        	    22: ;             Ctrl+T Ctrl+E : toggle local echo
                        	    23: ;
                        	    24: ;
                        	    25: ;  Copyright 2022 by Nick Gammon
                        	    26: ;
                        	    27: ;  Permission is hereby granted, free of charge, to any person obtaining a copy
                        	    28: ;  of this software and associated documentation files (the "Software"), to deal
                        	    29: ;  in the Software without restriction, including without limitation the rights
                        	    30: ;  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                        	    31: ;  copies of the Software, and to permit persons to whom the Software is
                        	    32: ;  furnished to do so, subject to the following conditions:
                        	    33: ;
                        	    34: ;  The above copyright notice and this permission notice shall be included in all
                        	    35: ;  copies or substantial portions of the Software.
                        	    36: ;
                        	    37: ;  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                        	    38: ;  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                        	    39: ;  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                        	    40: ;  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                        	    41: ;  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                        	    42: ;  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
                        	    43: ;  SOFTWARE.
                        	    44: ;
                        	    45: ;***********************************************
                        	    46: ;
                        	    47: 
                        	    48: ; Note: BCC == BLT and BCS == BGE
                        	    49: ;
                        	    50: 
                        	    51: ;
                        	    52: ;  CONDITIONAL COMPILES
                        	    53: 
                        	    54: EMULATOR = 0          ; for testing on a PC running an emulator
                        	    55: LCD_SUPPORT = 1       ; 1 = support LCD, 0 = not. Unset if you have removed the LCD.
                        	    56: SERIAL_DEBUGGING = 0  ; if set, toggle VIA PA2 when reading a bit, and PA3 when writing a bit
                        	    57:                       ;  DO NOT USE I2C if this is on, as I2C functions use these two pins
                        	    58: USE_CP437_FONT = 1    ; include the symbols for the CP437 font for use with MAX7219 chip
                        	    59: 
                        	    60: ;
                        	    61: ;  CONFIGURATION
                        	    62: ;
                        	    63: CLOCK_RATE   = 1000000   ; 1 Mhz
                        	    64: START_OF_ROM = $8000     ; where the ROM chip starts
                        	    65: HIGHEST_RAM  = $3FFF      ; original board hardware
                        	    66: ;HIGHEST_RAM  = $5FFF    ; with suggested additional AND gate
                        	    67: 
                        	    68: RUNNING_STACK_TOP = $C0   ; top of stack when running assembler code
                        	    69: 
                        	    70: ;
                        	    71: ;  serial output
                        	    72: ;
                        	    73: BAUD_RATE    = 4800         ; baud
                        	    74: BIT_INTERVAL = CLOCK_RATE / BAUD_RATE ; time between bits in Âµs
                        	    75: 
                        	    76: ;
                        	    77: ;  serial input - input commences on the interrupt generated by the falling edge
                        	    78: ;    of the start bit. Bits are then clocked in with a timed loop.
                        	    79: ;  - these delays can be tweaked if you believe the serial input is not being
                        	    80: ;    sampled at the right moment, confirm by turning SERIAL_DEBUGGING on
                        	    81: ;    and checking the debugging pulses compared to the middle of the bit times
                        	    82: ;    with an oscilloscope or logic analyser
                        	    83: ;
                        	    84: SERIAL_DELAY1 = 48    ; initial delay (count) - higher because it is 1.5 bit times
                        	    85: SERIAL_DELAY2 = 35    ; subsequent delays between bits (count)
                        	    86: 
                        	    87: SYMBOL_TABLE_START = HIGHEST_RAM  ; symbol table pointer (ENDSYM) is decremented before being used
                        	    88: 
                        	    89: STACK            =  $100  ; hardware stack address
                        	    90: SPACE            =  $20   ; uh-huh
                        	    91: SINGLE_QUOTE     =  $27
                        	    92: NL               =  $0A   ; newline
                        	    93: CR               =  $0D   ; carriage-return
                        	    94: BACKSPACE        =  $08   ; backspace
                        	    95: 
                        	    96: MAX_STK          =  32
                        	    97: NEW_STK          =  $FF
                        	    98: 
                        	    99:     .if EMULATOR
                        	   100: END_EDITOR_INPUT =  '`'   ; backtick terminates input
                        	   101:     .else
                        	   102: END_EDITOR_INPUT =  $1B   ; Esc terminates editor input
                        	   103:     .endif
                        	   104: 
                        	   105: KEY_DEBUG      = 'D'-$40   ; Ctrl+D start debugging
                        	   106: KEY_TRACE      = 'T'-$40   ; Ctrl+T start tracing
                        	   107: KEY_STOP_TRACE = 'N'-$40   ; Ctrl+N stop tracing
                        	   108: KEY_ABORT      = 'C'-$40   ; Ctrl+C abort execution
                        	   109: 
                        	   110: 
                        	   111:   .if LCD_SUPPORT
                        	   112: ;
                        	   113: ;  Pins connected from the VIA to the LCD
                        	   114: ;
                        	   115: LCD_RS             = %00100000  ; PA 5 - 0 = instruction, 1 = data
                        	   116: LCD_RW             = %01000000  ; PA 6 - 0 = write, 1 = read
                        	   117: LCD_E              = %10000000  ; PA 7 - toggle (0 -> 1 -> 0) to clock out a command or data
                        	   118:   .endif
                        	   119: 
                        	   120:   .include "zp_variables.inc"

Source: "zp_variables.inc"
                        	     1: ;***********************************************
                        	     2: ;
                        	     3: ; Zero-page variables (currently 64 (decimal) bytes are free for your use).
                        	     4: ;  I suggest using the high ones and working down in case there is a change to the code.
                        	     5: ;  For example, start with 0xFF, then 0xFE and so on.
                        	     6: ;
                        	     7: ;***********************************************
                        	     8: 
                        	     9:   .dsect
                        	    10: 
                        	    11: 
                        	    12: ;
                        	    13: ;  General work-areas for arithmetic routines (eg. add, subtract, divide, multiply)
                        	    14: ;   3-byte signed numbers: -8388608 to +8388607
                        	    15: ;
00:0000 00              	    16: VALUE    reserve 3    ; the current value of the token (ie. if a number)
00:0001 *
00:0003 00              	    17: VALUE2   reserve 3    ; used by the assembler expression evaluator
00:0004 *
                        	    18: 
                        	    19: ; SRCE and DEST used in compiler and editor, particularly for string comparisons
                        	    20: ;   (re-using VALUE and VALUE2)
                        	    21: 
                        	    22: SRCE     =  VALUE
                        	    23: DEST     =  VALUE2
                        	    24: 
00:0006 00              	    25: REMAIN   reserve 3    ; division remainder
00:0007 *
                        	    26: 
                        	    27: ;
                        	    28: ;  work "register" - re-using VALUE and VALUE2 again
                        	    29: ;
                        	    30: REG   = VALUE
                        	    31: REGB  = VALUE+2
                        	    32: REG2  = VALUE2
                        	    33: REG2B = VALUE2+2
                        	    34: 
                        	    35: ;
                        	    36: ;  re-using above for CRC-16 calculations
                        	    37: ;
                        	    38: crc_addr = VALUE      ; the address to take a CRC of (2 bytes)
                        	    39: crc_num  = VALUE2     ; the number of bytes to take a CRC of (2 bytes)
                        	    40: crc_val  = REMAIN     ; the current CRC value (2 bytes)
                        	    41: 
                        	    42: ;
                        	    43: ;  current random number - change this to reseed it
                        	    44: ;
00:0009 00              	    45: random         reserve 4 ; 32-bit random number
00:000A *
00:000D 00              	    46: typing_latency reserve 3 ; incremented while waiting for input
00:000E *
                        	    47: 
                        	    48: ;
                        	    49: ;  Used for seeding registers when calling machine code from Pascal
                        	    50: ;
00:0010 00              	    51: call_a reserve 1      ; used when doing a machine code call:  A register
00:0011 00              	    52: call_x reserve 1      ;  ditto: X register
00:0012 00              	    53: call_y reserve 1      ;  ditto: Y register
00:0013 00              	    54: call_p reserve 1      ;  ditto: status register
00:0014 00              	    55: call_s reserve 1      ; stack register, used by BRK
00:0015 00              	    56: brk_address reserve 2 ; BRK address
00:0016 *
                        	    57: 
                        	    58: ;
                        	    59: ;  address of write function (2 bytes)
                        	    60: ;
                        	    61: ;  This is called by "character out" function COUT. It writes the character in "A" to
                        	    62: ;   serial port or LCD. You could conceivably put another function address here if
                        	    63: ;   you wanted to capture output (eg. from calling DISP_BIN) and putting it somewhere else
                        	    64: ;   like into a series of memory locations, or to output to SPI.
                        	    65: ;  The functions write_to_serial and write_to_lcd
                        	    66: ;   put the appropriate outputting functions into this location.
                        	    67: ;
00:0017 00              	    68: write_function reserve 2  ; address of function to write to serial or LCD
00:0018 *
                        	    69: 
                        	    70: 
00:0019 00              	    71: LINE_CNT  reserve 2   ; line counter during compile
00:001A *
                        	    72: LINE_NO  =  LINE_CNT
                        	    73: 
00:001B 00              	    74: WX       reserve 2    ; 2-byte address used during compilation (reserved word lookup)
00:001C *
00:001D 00              	    75: LIST     reserve 1    ; 0 = no listing, 1 = list source during compile
00:001E 00              	    76: DIGIT    reserve 1    ; used only in GET_NUM to process a decimal number
00:001F 00              	    77: SIGN     reserve 1    ; used in compiling and inputting a number - is there a minus sign?
                        	    78: 
00:0020 00              	    79: FRAME    reserve 2    ; stack frame number - not totally certain but it used for procedure calls at runtime
00:0021 *
00:0022 00              	    80: LEVEL    reserve 1    ; current nested procedure/function level (how far we are nested)
00:0023 00              	    81: PCODE    reserve 2    ; current P-code address (increments during compile and running)
00:0024 *
                        	    82: PNTR     =  PCODE     ; 2-byte work pointer used in editor (eg. in find/replace etc.)
00:0025 00              	    83: ACT_PCDA reserve 2    ; start of P-codes (after source) - does not increment
00:0026 *
00:0027 00              	    84: DISPL    reserve 2    ; level? ahhh ... I don't know
00:0028 *
00:0029 00              	    85: OFFSET   reserve 2    ; variable offset? maybe just a work area
00:002A *
00:002B 00              	    86: OPND     reserve 3    ; jump operand ... not sure
00:002C *
00:002E 00              	    87: DCODE    reserve 1     ; 0 = no display, 1 = display P-codes during compile
00:002F 00              	    88: STARTSYM reserve 2    ; start of symbol table
00:0030 *
00:0031 00              	    89: ENDSYM   reserve 2    ; end of symbol table - used for reverse searching symbols
00:0032 *
                        	    90: T        =  ENDSYM     ; stack pointer 2 bytes
00:0033 00              	    91: WORKD    reserve 2    ; work area for holding P-code address
00:0034 *
00:0035 00              	    92: ERRNO    reserve 1    ; current error number, if ERROR called
00:0036 00              	    93: BSAVE    reserve 1    ; seems to be used to save "A" register, lol
00:0037 00              	    94: WORK     reserve 2    ; work area, used for pushing 2-bytes onto the (processor) stack
00:0038 *
00:0039 00              	    95: PRCITM   reserve 2    ; seems to hold the current procedure/function symbol
00:003A *
00:003B 00              	    96: BASE     reserve 2    ; the base interpreter stack frame (for this procedure)
00:003C *
                        	    97: TO       =  BASE      ; Used in editor (from/to list ranges, and copying text)
00:003D 00              	    98: DATA     reserve 2    ; 2-byte address work-area for calculating the address of a variable at runtime
00:003E *
00:003F 00              	    99: RUNNING  reserve 1    ; 0x40 - in editor, 0x80 - executing - affects stuff like numeric conversion
00:0040 00              	   100: SYMITM   reserve 2    ; current symbol table item (found by searching)
00:0041 *
                        	   101: FROM     =  SYMITM    ; Used in editor (from/to list ranges, and copying text)
00:0042 00              	   102: SYNTAX   reserve 1    ; 0 = full compile, 1 = syntax-only compile (no writing to memory)
00:0043 00              	   103: END_PCD  reserve 2    ; where the P-codes ended after a compile
00:0044 *
00:0045 00              	   104: TEMP     reserve 2    ; temporary work area?
00:0046 *
00:0047 00              	   105: CALL     reserve 2    ; the procedure address we are calling
00:0048 *
00:0049 00              	   106: DBGFLG   reserve 1    ; 0 = not debugging, 1 = debugging, $80 = tracing
00:004A 00              	   107: DATTYP   reserve 1    ; 0 for integers and 1 for characters
00:004B 00              	   108: COUNT1   reserve 1    ; work counter
00:004C 00              	   109: COUNT2   reserve 1    ; and another
00:004D 00              	   110: LASTP    reserve 2    ; 2-byte last P-code address executed at runtime (start of this P-code)
00:004E *
00:004F 00              	   111: IO_A     reserve 1    ; dunno
00:0050 00              	   112: IO_Y     reserve 1    ; seems to be used to save and restore Y
00:0051 00              	   113: IO_X     reserve 1    ;  ditto for X
00:0052 00              	   114: RES      reserve 3    ; multiplication result
00:0053 *
00:0055 00              	   115: DIVISOR  reserve 3      ; divisor for division
00:0056 *
00:0058 00              	   116: DVDN     reserve 3    ; dividend
00:0059 *
00:005B 00              	   117: RMNDR    reserve 1    ; for division, 0 if positive, 0x80 if negative
00:005C 00              	   118: bcd_work    reserve 4    ; work area for converting binary to decimal (packed)
00:005D *
00:0060 00              	   119: bcd_result  reserve 8    ; work area for turning numbers into printable (unpacked)
00:0061 *
00:0068 00              	   120: spi_mode   reserve 1   ; SPI mode: 0 to 3
00:0069 00              	   121: QUOT_SYM reserve 1     ; current quote symbol
00:006A 00              	   122: QT_SIZE  reserve 1    ; number of characters in reserved words
00:006B 00              	   123: ASS_OPERAND reserve 1 ; assembler operand type = see defines below
00:006C 00              	   124: OPCODE   reserve 2    ; address of opcode in assembler
00:006D *
00:006E 00              	   125: OPCODE_LEN reserve 1  ; length of opcode
00:006F 00              	   126: ASS_EMIT_COUNT reserve 1 ; number of bytes emitted on this line
00:0070 00              	   127: ASS_OPCODE_WORK reserve 2; for opcode lookups
00:0071 *
00:0072 00              	   128: ASS_COUNT reserve 1 ; for counting opcode matches
00:0073 00              	   129: ASS_VALUE reserve 3 ; the assembler operand (address or immediate) will be here
00:0074 *
00:0076 00              	   130: ASS_PASS  reserve 1 ; which assembler pass we are up to
00:0077 00              	   131: ass_emit_bytes reserve 2 ; how many bytes the assembler emitted altogether
00:0078 *
00:0079 00              	   132: exp_value_stack reserve 2  ; address of assembler value stack
00:007A *
00:007B 00              	   133: exp_value_stack_count reserve 1 ; how far through value stack we are (0 = empty)
00:007C 00              	   134: exp_operator_stack_count reserve 1 ;  how far through operator stack we are (0 = empty)
00:007D 00              	   135: exp_operator reserve 1  ; current operator for expression evaluation
00:007E 00              	   136: exp_operator_precedence reserve 1 ; current operator precedence
00:007F 00              	   137: exp_evaluation_function reserve 2 ; function to evaluate an expression
00:0080 *
00:0081 00              	   138: exp_unary_ok reserve 1  ; true if the next token can be a unary operator (like: - < >)
00:0082 00              	   139: show_symbols reserve 1  ; true to list the symbol table after an assemble
00:0083 00              	   140: ass_current_label reserve 2 ; current symbol table address of the label on this line
00:0084 *
00:0085 00              	   141: str_work reserve 1      ; work byte for string compares
                        	   142:   .if LCD_SUPPORT
00:0086 00              	   143: lcd_work  reserve 1 ; used by the LCD routines
                        	   144:   .endif
                        	   145: 
                        	   146: ;
                        	   147: ;  serial work
                        	   148: ;
00:0087 00              	   149: serial_out_byte reserve 2 ; current byte we are sending
00:0088 *
00:0089 00              	   150: serial_out_bit  reserve 1 ; current bit count
00:008A 00              	   151: serial_in_byte  reserve 1 ; current byte we are receiving
00:008B 00              	   152: serial_in_byte_received  reserve 1 ; last received byte
                        	   153: 
                        	   154: ;
                        	   155: ; hardware
                        	   156: ;
00:008C 00              	   157: hardware_work  reserve 1  ; work for use during interpreting
                        	   158: 
                        	   159: ;
                        	   160: ; maths
                        	   161: ;
00:008D 00              	   162: maths_work  reserve 1 ; work for multiply/divide
                        	   163: ;
                        	   164: ;  for get_token
                        	   165: ;
00:008E 00              	   166: token_start      reserve 2  ; where to start looking for a token
00:008F *
00:0090 00              	   167: token_address    reserve 2  ; where the token actually started
00:0091 *
00:0092 00              	   168: token_length     reserve 1  ; length of the token
00:0093 00              	   169: token_type       reserve 1  ; what type of token it is
00:0094 00              	   170: token_value      reserve 3  ; the value of numeric tokens
00:0095 *
00:0097 00              	   171: token_sign       reserve 1  ; non-zero if negative value
00:0098 00              	   172: token_work       reserve 3  ; temporary work area - also used by handlerLookup
00:0099 *
00:009B 00              	   173: token_digit      reserve 1  ; used by get_token
00:009C 00              	   174: token_line_start reserve 2  ; where the current line starts
00:009D *
                        	   175: 
                        	   176: ;
                        	   177: ;  for editor
                        	   178: ;
00:009E 00              	   179: from_line       reserve 2     ; list, delete, modify: FROM line number
00:009F *
00:00A0 00              	   180: to_line         reserve 2     ; list, delete, modify: TO line number
00:00A1 *
00:00A2 00              	   181: current_line    reserve 2     ; current editor line number
00:00A3 *
00:00A4 00              	   182: insert_limit    reserve 2     ; maximum we can input to
00:00A5 *
00:00A6 00              	   183: mem_move_src    reserve 2     ; for copying memory - source of move
00:00A7 *
00:00A8 00              	   184: mem_move_dest   reserve 2     ; for copying memory - destination of move
00:00A9 *
00:00AA 00              	   185: mem_move_len    reserve 2     ; for copying memory - length of move
00:00AB *
00:00AC 00              	   186: this_line       reserve 2     ; which line we are searching for
00:00AD *
00:00AE 00              	   187: this_line_addr  reserve 2     ; address of the "this" line
00:00AF *
00:00B0 00              	   188: find_from       reserve 1     ; editor find: from offset in INBUF (start of target string)
00:00B1 00              	   189: find_to         reserve 1     ; editor find: to offset in INBUF (end of target string)
00:00B2 00              	   190: find_pos        reserve 1     ; which offset in the current line we are currently searching from
00:00B3 00              	   191: find_len        reserve 1     ; the length of the find text
00:00B4 00              	   192: find_delimiter  reserve 1     ; the find/replace delimiter
00:00B5 00              	   193: rep_from        reserve 1     ; editor replace: start of replacement string
00:00B6 00              	   194: rep_to          reserve 1     ; editor replace: end of replacement string
00:00B7 00              	   195: rep_diff        reserve 2     ; difference in find/replace string lengths (signed 2 bytes)
00:00B8 *
00:00B9 00              	   196: find_count      reserve 2     ; count of find/replace
00:00BA *
00:00BB 00              	   197: found_this_line reserve 1     ; did we find something on this line?
                        	   198: insert_last_char = find_from  ; the last character we inserted in INSERT/LOAD mode
                        	   199: 
00:00BC 00              	   200: editor_flags    reserve 1     ; various flags, see below
                        	   201: 
                        	   202: EFLAG_SHOW_LINE        = %00000001    ; set after receiving a newline, so we display the next line
                        	   203: EFLAG_ALLOW_ZERO_FROM  = %00000010    ; for use with MEMORY, allow them to start from $0000
                        	   204: EFLAG_LOAD             = %00000100    ; doing a LOAD, do not show line numbers when inserting
                        	   205: EFLAG_SAVE             = %00001000    ; doing a SAVE, do not show line numbers
                        	   206: EFLAG_FIND             = %00010000    ; doing a FIND
                        	   207: EFLAG_REPLACE          = %00100000    ; doing a REPLACE
                        	   208: EFLAG_SUPPRESS_NEWLINE = %01000000    ; don't show newlines
                        	   209: EFLAG_NO_LINE_NUMBERS  = %10000000    ; don't show line numbers
                        	   210: 
00:00BD 00              	   211: find_flags     reserve 1      ; find/replace flags, see below
                        	   212: 
                        	   213: FFLAG_IGNORE_CASE = %00000001
                        	   214: FFLAG_GLOBAL      = %00000010
                        	   215: FFLAG_QUIET       = %00000100
                        	   216: 
                        	   217: ;
                        	   218: ;  system flags
                        	   219: ;
                        	   220: 
00:00BE 00              	   221: system_flags    reserve 1    ; general flags
                        	   222: 
                        	   223: FLAG_COMPILING      = %00000001
                        	   224: FLAG_ASSEMBLING     = %00000010
                        	   225: FLAG_LIST_SOURCE    = %00000100
                        	   226: FLAG_VALID_COMPILE  = %00001000
                        	   227: FLAG_VALID_ASSEMBLE = %00010000
                        	   228: FLAG_RUNNING        = %00100000
                        	   229: FLAG_ONLY_ALPHA     = %01000000   ; for editor, so you can L5 to do LIST 5
                        	   230: FLAG_BRK_REACHED    = %10000000   ; Breakpoint encountered during run
                        	   231: 

Source: "gpascal.asm"
                        	   121: 
                        	   122: ;
                        	   123: ;  A general work-buffer is allocated from $200 to $2FF for use during keyboard input, and also
                        	   124: ;  for converting strings during tokenisation (eg. two quotes in a row to one quote, and handling
                        	   125: ;  string escape sequences). It is also used during assembly as a 256-byte operator stack.
                        	   126: ;
                        	   127:   .org $200
                        	   128: INBUF_SIZE = 256          ; we use this for string storage during tokenisation
01:0200 00              	   129: INBUF  reserve INBUF_SIZE ; and also for preprocessing string literals (eg. backslash expansion)
01:0201 *
                        	   130: TEXT_START = *            ; where source goes in memory (currently $300)
                        	   131:   .dend
                        	   132: 
                        	   133: 
                        	   134: 
                        	   135: ;------------------------------------------
                        	   136: ;  Macros
                        	   137: ;------------------------------------------
                        	   138: 
                        	   139:  .macro tknjmpItem ; tknjmp entry: token, handler
                        	   140:    dfb   \1
                        	   141:    word  \2
                        	   142:  .endmacro
                        	   143: 
                        	   144:  .macro makeHandler ; table of words and handlers: word, handler
                        	   145:    asciiz   \1
                        	   146:    word  \2
                        	   147:  .endmacro
                        	   148: 
                        	   149: ;
                        	   150: ; makePasLibraryFunction NAME (SYMNAM), TYPE (SYMTYP), ARG_COUNT (SYMARG), EXECUTION_ADDRESS (SYMDSP)
                        	   151: ;
                        	   152: ;   TYPE = SYMBOL_LIBRARY_PROCEDURE or SYMBOL_LIBRARY_FUNCTION
                        	   153:    .macro makePasLibraryFunction
                        	   154:      asciiz   \1
                        	   155:      dfb      \2
                        	   156:      dfb      \3
                        	   157:      word     \4
                        	   158:    .endmacro
                        	   159: 
                        	   160: ;
                        	   161: ; makeAsmLibraryFunction NAME (SYMNAM), EXECUTION_ADDRESS (SYMDSP)
                        	   162: ;
                        	   163:    .macro makeAsmLibraryFunction
                        	   164:      asciiz   \1
                        	   165:      word     \2
                        	   166:    .endmacro
                        	   167: 
                        	   168:   ORG  START_OF_ROM   ; normally $8000 in the case of Ben Eater's board
                        	   169: 
00:8000 4C74DC          	   170:   JMP  START   ; where RESET takes us - a cold start
00:8003 4C90DC          	   171:   JMP  RESTART ; where NMI takes us - a warm start
                        	   172: 
                        	   173: ;***********************************************
                        	   174: ; INCLUDES
                        	   175: ;***********************************************
                        	   176: 
                        	   177:   .include "memory.inc"

Source: "memory.inc"
                        	     1: ;---------------------------
                        	     2: ; standard library stuff
                        	     3: ;---------------------------
                        	     4: 
                        	     5: ;
                        	     6: ;  character type masks
                        	     7: ;
                        	     8: m_upper   = %00000001    ; $01
                        	     9: m_lower   = %00000010    ; $02
                        	    10: m_alpha   = %00000100    ; $04
                        	    11: m_digit   = %00001000    ; $08
                        	    12: m_xdigit  = %00010000    ; $10
                        	    13: m_space   = %00100000    ; $20
                        	    14: m_cntrl   = %01000000    ; $40
                        	    15: m_alnum   = %10000000    ; $80
                        	    16: 
                        	    17: ;
                        	    18: ;  for fast checks which corrupt registers
                        	    19: ;
                        	    20: ;    ldx THE_CHARACTER_TO_BE_TESTED
                        	    21: ;    lda character_types_table,X
                        	    22: ;    bne IS_IN_THAT_CLASS
                        	    23: ;
                        	    24: 
                        	    25: character_types_table = *
00:8006 40              	    26:   dfb $40,$40,$40,$40,$40,$40,$40,$40    ; 0x00
00:8007 40
00:8008 40
00:8009 40
00:800A 40
00:800B 40
00:800C 40
00:800D 40
00:800E 40              	    27:   dfb $40,$60,$60,$60,$60,$60,$40,$40    ; 0x08
00:800F 60
00:8010 60
00:8011 60
00:8012 60
00:8013 60
00:8014 40
00:8015 40
00:8016 40              	    28:   dfb $40,$40,$40,$40,$40,$40,$40,$40    ; 0x10
00:8017 40
00:8018 40
00:8019 40
00:801A 40
00:801B 40
00:801C 40
00:801D 40
00:801E 40              	    29:   dfb $40,$40,$40,$40,$40,$40,$40,$40    ; 0x18
00:801F 40
00:8020 40
00:8021 40
00:8022 40
00:8023 40
00:8024 40
00:8025 40
00:8026 20              	    30:   dfb $20,$00,$00,$00,$00,$00,$00,$00    ; 0x20   !"#$%&'
00:8027 00
00:8028 00
00:8029 00
00:802A 00
00:802B 00
00:802C 00
00:802D 00
00:802E 00              	    31:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x28  ()*+,-./
00:802F 00
00:8030 00
00:8031 00
00:8032 00
00:8033 00
00:8034 00
00:8035 00
00:8036 98              	    32:   dfb $98,$98,$98,$98,$98,$98,$98,$98    ; 0x30  01234567
00:8037 98
00:8038 98
00:8039 98
00:803A 98
00:803B 98
00:803C 98
00:803D 98
00:803E 98              	    33:   dfb $98,$98,$00,$00,$00,$00,$00,$00    ; 0x38  89:;<=>?
00:803F 98
00:8040 00
00:8041 00
00:8042 00
00:8043 00
00:8044 00
00:8045 00
00:8046 00              	    34:   dfb $00,$95,$95,$95,$95,$95,$95,$85    ; 0x40  @ABCDEFG
00:8047 95
00:8048 95
00:8049 95
00:804A 95
00:804B 95
00:804C 95
00:804D 85
00:804E 85              	    35:   dfb $85,$85,$85,$85,$85,$85,$85,$85    ; 0x48  HIJKLMNO
00:804F 85
00:8050 85
00:8051 85
00:8052 85
00:8053 85
00:8054 85
00:8055 85
00:8056 85              	    36:   dfb $85,$85,$85,$85,$85,$85,$85,$85    ; 0x50  PQRSTUVW
00:8057 85
00:8058 85
00:8059 85
00:805A 85
00:805B 85
00:805C 85
00:805D 85
00:805E 85              	    37:   dfb $85,$85,$85,$00,$00,$00,$00,$00    ; 0x58  XYZ[\]^_
00:805F 85
00:8060 85
00:8061 00
00:8062 00
00:8063 00
00:8064 00
00:8065 00
00:8066 00              	    38:   dfb $00,$96,$96,$96,$96,$96,$96,$86    ; 0x60  `abcdefg
00:8067 96
00:8068 96
00:8069 96
00:806A 96
00:806B 96
00:806C 96
00:806D 86
00:806E 86              	    39:   dfb $86,$86,$86,$86,$86,$86,$86,$86    ; 0x68  hijklmno
00:806F 86
00:8070 86
00:8071 86
00:8072 86
00:8073 86
00:8074 86
00:8075 86
00:8076 86              	    40:   dfb $86,$86,$86,$86,$86,$86,$86,$86    ; 0x70  pqrstuvw
00:8077 86
00:8078 86
00:8079 86
00:807A 86
00:807B 86
00:807C 86
00:807D 86
00:807E 86              	    41:   dfb $86,$86,$86,$00,$00,$00,$00,$40    ; 0x78  xyz{|}~
00:807F 86
00:8080 86
00:8081 00
00:8082 00
00:8083 00
00:8084 00
00:8085 40
00:8086 00              	    42:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x80
00:8087 00
00:8088 00
00:8089 00
00:808A 00
00:808B 00
00:808C 00
00:808D 00
00:808E 00              	    43:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x88
00:808F 00
00:8090 00
00:8091 00
00:8092 00
00:8093 00
00:8094 00
00:8095 00
00:8096 00              	    44:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x90
00:8097 00
00:8098 00
00:8099 00
00:809A 00
00:809B 00
00:809C 00
00:809D 00
00:809E 00              	    45:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x98
00:809F 00
00:80A0 00
00:80A1 00
00:80A2 00
00:80A3 00
00:80A4 00
00:80A5 00
00:80A6 00              	    46:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xA0
00:80A7 00
00:80A8 00
00:80A9 00
00:80AA 00
00:80AB 00
00:80AC 00
00:80AD 00
00:80AE 00              	    47:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xA8
00:80AF 00
00:80B0 00
00:80B1 00
00:80B2 00
00:80B3 00
00:80B4 00
00:80B5 00
00:80B6 00              	    48:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xB0
00:80B7 00
00:80B8 00
00:80B9 00
00:80BA 00
00:80BB 00
00:80BC 00
00:80BD 00
00:80BE 00              	    49:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xB8
00:80BF 00
00:80C0 00
00:80C1 00
00:80C2 00
00:80C3 00
00:80C4 00
00:80C5 00
00:80C6 00              	    50:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xC0
00:80C7 00
00:80C8 00
00:80C9 00
00:80CA 00
00:80CB 00
00:80CC 00
00:80CD 00
00:80CE 00              	    51:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xC8
00:80CF 00
00:80D0 00
00:80D1 00
00:80D2 00
00:80D3 00
00:80D4 00
00:80D5 00
00:80D6 00              	    52:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xD0
00:80D7 00
00:80D8 00
00:80D9 00
00:80DA 00
00:80DB 00
00:80DC 00
00:80DD 00
00:80DE 00              	    53:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xD8
00:80DF 00
00:80E0 00
00:80E1 00
00:80E2 00
00:80E3 00
00:80E4 00
00:80E5 00
00:80E6 00              	    54:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xE0
00:80E7 00
00:80E8 00
00:80E9 00
00:80EA 00
00:80EB 00
00:80EC 00
00:80ED 00
00:80EE 00              	    55:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xE8
00:80EF 00
00:80F0 00
00:80F1 00
00:80F2 00
00:80F3 00
00:80F4 00
00:80F5 00
00:80F6 00              	    56:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xF0
00:80F7 00
00:80F8 00
00:80F9 00
00:80FA 00
00:80FB 00
00:80FC 00
00:80FD 00
00:80FE 00              	    57:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xF8
00:80FF 00
00:8100 00
00:8101 00
00:8102 00
00:8103 00
00:8104 00
00:8105 00
                        	    58: 
                        	    59: ;
                        	    60: ;  character type tests: test character in A, Carry set if true, carry clear if false
                        	    61: ;    -no registers changed
                        	    62: ;
                        	    63: is_xxx_fail:
00:8106 FA              	    64:   plx
00:8107 68              	    65:   pla
00:8108 18              	    66:   clc
00:8109 60              	    67:   rts
                        	    68: 
                        	    69: is_xxx_pass:
00:810A FA              	    70:   plx
00:810B 68              	    71:   pla
00:810C 38              	    72:   sec
00:810D 60              	    73:   rts
                        	    74: 
                        	    75:   .macro isXXX
                        	    76: \1 = *
                        	    77:   pha
                        	    78:   phx
                        	    79:   tax
                        	    80:   lda character_types_table,x
                        	    81:   and #\2
                        	    82:   beq is_xxx_fail
                        	    83:   bra is_xxx_pass
                        	    84:   .endmacro
                        	    85: 
                        	    86: ;
                        	    87: ;  generate the various character type tests - done by fast table lookup
                        	    88: ;
                        	    89:   isXXX isupper,  m_upper
                        	     1M isupper = *
00:810E 48              	     2M   pha
00:810F DA              	     3M   phx
00:8110 AA              	     4M   tax
00:8111 BD0680          	     5M   lda character_types_table,x
00:8114 2901            	     6M   and #m_upper
00:8116 F0EE            	     7M   beq is_xxx_fail
00:8118 80F0            	     8M   bra is_xxx_pass
                        	    90:   isXXX islower,  m_lower
                        	     1M islower = *
00:811A 48              	     2M   pha
00:811B DA              	     3M   phx
00:811C AA              	     4M   tax
00:811D BD0680          	     5M   lda character_types_table,x
00:8120 2902            	     6M   and #m_lower
00:8122 F0E2            	     7M   beq is_xxx_fail
00:8124 80E4            	     8M   bra is_xxx_pass
                        	    91:   isXXX isalpha,  m_alpha
                        	     1M isalpha = *
00:8126 48              	     2M   pha
00:8127 DA              	     3M   phx
00:8128 AA              	     4M   tax
00:8129 BD0680          	     5M   lda character_types_table,x
00:812C 2904            	     6M   and #m_alpha
00:812E F0D6            	     7M   beq is_xxx_fail
00:8130 80D8            	     8M   bra is_xxx_pass
                        	    92:   isXXX isdigit,  m_digit
                        	     1M isdigit = *
00:8132 48              	     2M   pha
00:8133 DA              	     3M   phx
00:8134 AA              	     4M   tax
00:8135 BD0680          	     5M   lda character_types_table,x
00:8138 2908            	     6M   and #m_digit
00:813A F0CA            	     7M   beq is_xxx_fail
00:813C 80CC            	     8M   bra is_xxx_pass
                        	    93:   isXXX isxdigit, m_xdigit
                        	     1M isxdigit = *
00:813E 48              	     2M   pha
00:813F DA              	     3M   phx
00:8140 AA              	     4M   tax
00:8141 BD0680          	     5M   lda character_types_table,x
00:8144 2910            	     6M   and #m_xdigit
00:8146 F0BE            	     7M   beq is_xxx_fail
00:8148 80C0            	     8M   bra is_xxx_pass
                        	    94:   isXXX isspace,  m_space
                        	     1M isspace = *
00:814A 48              	     2M   pha
00:814B DA              	     3M   phx
00:814C AA              	     4M   tax
00:814D BD0680          	     5M   lda character_types_table,x
00:8150 2920            	     6M   and #m_space
00:8152 F0B2            	     7M   beq is_xxx_fail
00:8154 80B4            	     8M   bra is_xxx_pass
                        	    95:   isXXX iscntrl,  m_cntrl
                        	     1M iscntrl = *
00:8156 48              	     2M   pha
00:8157 DA              	     3M   phx
00:8158 AA              	     4M   tax
00:8159 BD0680          	     5M   lda character_types_table,x
00:815C 2940            	     6M   and #m_cntrl
00:815E F0A6            	     7M   beq is_xxx_fail
00:8160 80A8            	     8M   bra is_xxx_pass
                        	    96:   isXXX isalnum,  m_alnum
                        	     1M isalnum = *
00:8162 48              	     2M   pha
00:8163 DA              	     3M   phx
00:8164 AA              	     4M   tax
00:8165 BD0680          	     5M   lda character_types_table,x
00:8168 2980            	     6M   and #m_alnum
00:816A F09A            	     7M   beq is_xxx_fail
00:816C 809C            	     8M   bra is_xxx_pass
                        	    97: 
                        	    98: ;
                        	    99: ;  ran out of bits so implemented this one manually
                        	   100: ;
                        	   101: isbinary   =  *
00:816E C930            	   102:          cmp  #'0'
00:8170 F004            	   103:          beq  isbin
00:8172 C931            	   104:          cmp  #'1'
00:8174 D002            	   105:          bne  notbin
                        	   106: isbin:
00:8176 38              	   107:          sec
00:8177 60              	   108:          rts
                        	   109: notbin:
00:8178 18              	   110:          clc
00:8179 60              	   111:          rts
                        	   112: 
                        	   113: ;
                        	   114: ; Move memory down  (mem_move_dest is < mem_move_src)
                        	   115: ;
                        	   116: ;  Copies first byte first, working upwards
                        	   117: ;
                        	   118: ; mem_move_src = source start address
                        	   119: ; mem_move_dest = destination start address
                        	   120: ; mem_move_len = number of bytes mem_move_dest move
                        	   121: ;
                        	   122: movedown:
00:817A A5AA            	   123:   lda mem_move_len
00:817C 05AB            	   124:   ora mem_move_len+1
00:817E F01C            	   125:   beq movedown_done
00:8180 A000            	   126:   ldy #0
00:8182 8498            	   127:   sty  token_work      ; counter
00:8184 8499            	   128:   sty  token_work+1
                        	   129: ;
                        	   130: ;  copy one byte, increment counter
                        	   131: ;
                        	   132: movedown_loop:
00:8186 B1A6            	   133:   lda (mem_move_src),Y
00:8188 91A8            	   134:   sta (mem_move_dest),Y
00:818A E698            	   135:   inc token_work
00:818C D002            	   136:   bne movedown2
00:818E E699            	   137:   inc token_work+1
                        	   138: ;
                        	   139: ;  see if length reached
                        	   140: ;
                        	   141: movedown2:
                        	   142: 
00:8190 A598            	   143:   lda  token_work
00:8192 C5AA            	   144:   cmp  mem_move_len
00:8194 D007            	   145:   bne  movedown1
00:8196 A599            	   146:   lda  token_work+1
00:8198 C5AB            	   147:   cmp  mem_move_len+1
00:819A D001            	   148:   bne  movedown1
                        	   149: movedown_done:
00:819C 60              	   150:   rts
                        	   151: 
                        	   152: ;
                        	   153: ; increment Y, and increment high-order address bytes if necessary
                        	   154: ;
                        	   155: movedown1:
00:819D C8              	   156:   iny
00:819E D0E6            	   157:   bne  movedown_loop
00:81A0 E6A7            	   158:   inc  mem_move_src+1
00:81A2 E6A9            	   159:   inc  mem_move_dest+1
00:81A4 80E0            	   160:   bra  movedown_loop
                        	   161: 
                        	   162: ; Move memory up (mem_move_dest is > mem_move_src)
                        	   163: ;
                        	   164: ;   Copies last byte first, moving downwards
                        	   165: ;
                        	   166: ; mem_move_src = source start address
                        	   167: ; mem_move_dest = destination start address
                        	   168: ; mem_move_len = number of bytes mem_move_dest move
                        	   169: ;
                        	   170: moveup:
00:81A6 A5AA            	   171:   lda mem_move_len
00:81A8 05AB            	   172:   ora mem_move_len+1
00:81AA F038            	   173:   beq moveup_done
00:81AC A000            	   174:   ldy #0
00:81AE 8498            	   175:   sty  token_work      ; counter
00:81B0 8499            	   176:   sty  token_work+1
                        	   177:   ;
                        	   178:   ;  calculate final address of source
                        	   179:   ;
00:81B2 18              	   180:   clc
00:81B3 A5A6            	   181:   lda mem_move_src
00:81B5 65AA            	   182:   adc mem_move_len
00:81B7 85A6            	   183:   sta mem_move_src
00:81B9 A5A7            	   184:   lda mem_move_src+1
00:81BB 65AB            	   185:   adc mem_move_len+1
00:81BD 85A7            	   186:   sta mem_move_src+1
                        	   187:   ;
                        	   188:   ;  calculate final address of destination
                        	   189:   ;
00:81BF 18              	   190:   clc
00:81C0 A5A8            	   191:   lda mem_move_dest
00:81C2 65AA            	   192:   adc mem_move_len
00:81C4 85A8            	   193:   sta mem_move_dest
00:81C6 A5A9            	   194:   lda mem_move_dest+1
00:81C8 65AB            	   195:   adc mem_move_len+1
00:81CA 85A9            	   196:   sta mem_move_dest+1
00:81CC 8017            	   197:   bra moveup_next   ; have to decrement first
                        	   198: ;
                        	   199: ; move one byte, count moves
                        	   200: ;
                        	   201: moveup_loop:
00:81CE B1A6            	   202:   lda (mem_move_src),Y
00:81D0 91A8            	   203:   sta (mem_move_dest),Y
00:81D2 E698            	   204:   inc token_work
00:81D4 D002            	   205:   bne moveup3
00:81D6 E699            	   206:   inc token_work+1
                        	   207: moveup3:
                        	   208: ;
                        	   209: ;  see if length reached
                        	   210: ;
00:81D8 A598            	   211:   lda token_work
00:81DA C5AA            	   212:   cmp mem_move_len
00:81DC D007            	   213:   bne moveup_next
00:81DE A599            	   214:   lda token_work+1
00:81E0 C5AB            	   215:   cmp mem_move_len+1
00:81E2 D001            	   216:   bne moveup_next
                        	   217: moveup_done:
00:81E4 60              	   218:   rts
                        	   219: ;
                        	   220: ;  decrement Y, and decrement high-order address bytes if necessary
                        	   221: ;
                        	   222: moveup_next   =  *
00:81E5 88              	   223:   dey
00:81E6 C0FF            	   224:   cpy #$FF
00:81E8 D0E4            	   225:   bne moveup_loop
00:81EA C6A7            	   226:   dec mem_move_src+1
00:81EC C6A9            	   227:   dec mem_move_dest+1
00:81EE 80DE            	   228:   bra moveup_loop
                        	   229: 
                        	   230: ;
                        	   231: ;
                        	   232: ; String compare - case significant (max 128 byte strings)
                        	   233: ;
                        	   234: ; SRCE = source start address
                        	   235: ; DEST = destination start address
                        	   236: ; Y    = length of both strings (range 1 to 128)
                        	   237: ;
                        	   238: ;  returns Z set if strings are equal
                        	   239: ;
                        	   240: 
                        	   241: str_compare:
00:81F0 88              	   242:   dey             ; make zero-relative
00:81F1 300B            	   243:   bmi str_compare_done
00:81F3 B100            	   244:   lda (SRCE),y
00:81F5 8585            	   245:   sta str_work
00:81F7 B103            	   246:   lda (DEST),y
00:81F9 C585            	   247:   cmp str_work
00:81FB F0F3            	   248:   beq str_compare
00:81FD 60              	   249:   rts   ; no match, zero flag not set
                        	   250: str_compare_done:
00:81FE A900            	   251:   lda #0    ; set Z flag
00:8200 60              	   252:   rts
                        	   253: 
                        	   254: ;
                        	   255: ; String compare - case NOT significant (max 128 byte strings)
                        	   256: ;
                        	   257: ; SRCE = source start address
                        	   258: ; DEST = destination start address
                        	   259: ; Y    = length of both strings (range 1 to 128)
                        	   260: ;
                        	   261: ;  returns Z set if strings are equal
                        	   262: ;
                        	   263: 
                        	   264: str_ic_compare:
00:8201 88              	   265:   dey
00:8202 301F            	   266:   bmi str_ic_compare_done
00:8204 B100            	   267:   lda (SRCE),y
00:8206 C97B            	   268:   cmp #'z'+1
00:8208 B006            	   269:   bcs str_ic_compare_fixed_srce  ; BGE
00:820A C961            	   270:   cmp #'a'
00:820C 9002            	   271:   bcc str_ic_compare_fixed_srce  ; BLT
00:820E E920            	   272:   sbc #$20    ; make upper-case
                        	   273: str_ic_compare_fixed_srce:
00:8210 8585            	   274:   sta str_work
00:8212 B103            	   275:   lda (DEST),y
00:8214 C97B            	   276:   cmp #'z'+1
00:8216 B006            	   277:   bcs str_ic_compare_fixed_dest  ; BGE
00:8218 C961            	   278:   cmp #'a'
00:821A 9002            	   279:   bcc str_ic_compare_fixed_dest  ; BLT
00:821C E920            	   280:   sbc #$20    ; make upper-case
                        	   281: str_ic_compare_fixed_dest:
00:821E C585            	   282:   cmp str_work
00:8220 F0DF            	   283:   beq str_ic_compare
00:8222 60              	   284:   rts       ; no match, zero flag not set
                        	   285: str_ic_compare_done:
00:8223 A900            	   286:   lda #0    ; set Z flag
00:8225 60              	   287:   rts
                        	   288: 
                        	   289: 

Source: "gpascal.asm"
                        	   178:   .include "editor.inc"

Source: "editor.inc"
                        	     1: ;-------------------------------------------------
                        	     2: ;
                        	     3: ;  Shell, and text editor
                        	     4: ;
                        	     5: ;-------------------------------------------------
                        	     6: 
                        	     7: 
                        	     8: ;-------------------------------------------------
                        	     9: ;  print null-terminated message, message in A (lo) and X (hi)
                        	    10: ;  returns the length of the message in Y
                        	    11: ;-------------------------------------------------
                        	    12: print:
00:8226 A8              	    13:   tay   ; save A
00:8227 A503            	    14:   lda REG2 ; save REG2
00:8229 48              	    15:   pha
00:822A A504            	    16:   lda REG2+1  ; save REG2+1
00:822C 48              	    17:   pha
00:822D 98              	    18:   tya   ; get original A back
00:822E 8503            	    19:   sta REG2
00:8230 8604            	    20:   stx REG2+1
00:8232 A000            	    21:   ldy #0
                        	    22: print_loop:
00:8234 B103            	    23:   lda (REG2),y
00:8236 F006            	    24:   beq print_done
00:8238 20F695          	    25:   jsr COUT
00:823B C8              	    26:   iny
00:823C D0F6            	    27:   bne print_loop  ; give up if we overflow
                        	    28: print_done:
                        	    29: ;  stz serial_in_byte_received   ; TODO: Not sure about this
                        	    30: ;
                        	    31: ;  get REG2 back
                        	    32: ;
00:823E 68              	    33:   pla
00:823F 8504            	    34:   sta REG2+1
00:8241 68              	    35:   pla
00:8242 8503            	    36:   sta REG2
00:8244 60              	    37:   rts
                        	    38: 
00:8245 3A20            	    39: prompt       asciiz ": "
00:8247 00
00:8248 556E6B6E6F776E20	    40: bad_command  asciiz "Unknown command, type H for help.\n"
00:8250 636F6D6D616E642C
00:8258 2074797065204820
00:8260 666F722068656C70
00:8268 2E0A
00:826A 00
                        	    41: 
                        	    42: ;-------------------------------------------------
                        	    43: ; Start here after Reset or NMI - show introduction
                        	    44: ;-------------------------------------------------
                        	    45: 
                        	    46: main_start:
00:826B A90A            	    47:   lda #<introduction
00:826D A2DC            	    48:   ldx #>introduction
00:826F 202682          	    49:   jsr print
                        	    50: 
                        	    51: main_prompt:
00:8272 A2FF            	    52:   ldx  #NEW_STK
00:8274 9A              	    53:   txs
00:8275 D8              	    54:   cld
                        	    55: 
00:8276 A945            	    56:   lda #<prompt
00:8278 A282            	    57:   ldx #>prompt
00:827A 202682          	    58:   jsr print
                        	    59: 
00:827D 20CE95          	    60:   jsr  GET_LINE
                        	    61: 
00:8280 A900            	    62:   lda #<INBUF
00:8282 858E            	    63:   sta token_start
00:8284 A902            	    64:   lda #>INBUF
00:8286 858F            	    65:   sta token_start+1
                        	    66: 
00:8288 A901            	    67:   lda #1
00:828A 853F            	    68:   sta RUNNING
                        	    69: 
                        	    70: ;-------------------------------------------------
                        	    71: ; EDITOR (SHELL) MAIN LOOP
                        	    72: ;-------------------------------------------------
                        	    73: 
                        	    74: main_loop:
00:828C 64BC            	    75:   stz editor_flags  ; no flags yet
00:828E 64BD            	    76:   stz find_flags    ;  ditto
00:8290 A901            	    77:   lda #FLAG_COMPILING
00:8292 0902            	    78:   ora #FLAG_ASSEMBLING
00:8294 14BE            	    79:   trb system_flags  ; not compiling or assembling now
                        	    80: 
00:8296 A940            	    81:   lda #FLAG_ONLY_ALPHA
00:8298 04BE            	    82:   tsb system_flags  ; we only want alpha commands, thus we can enter L1 and be the same as List 1
                        	    83: 
00:829A 20D3CB          	    84:   jsr get_token
00:829D F0D3            	    85:   beq main_prompt   ; no input
                        	    86: 
                        	    87: ;
                        	    88: ;  Shortcut: If the input is "R" or "r" followed directly by a newline, assume they want to Run
                        	    89: ;
00:829F C949            	    90:   cmp #TOKEN_IDENTIFIER
00:82A1 D015            	    91:   bne main_loop_not_run
                        	    92: 
00:82A3 A000            	    93:   ldy #0
00:82A5 B190            	    94:   lda (token_address),y
00:82A7 200492          	    95:   jsr MAKE_UPPER
00:82AA C952            	    96:   cmp #'R'
00:82AC D00A            	    97:   bne main_loop_not_run
00:82AE C8              	    98:   iny
00:82AF B190            	    99:   lda (token_address),y
00:82B1 C90A            	   100:   cmp #NL
00:82B3 D003            	   101:   bne main_loop_not_run
00:82B5 4C178F          	   102:   jmp editor_run
                        	   103: 
                        	   104: ;
                        	   105: ;  Not a RUN shortcut, look up the command in our table
                        	   106: ;
                        	   107: main_loop_not_run:
                        	   108: ;
                        	   109: ;  set up our input line as where to find tokens
                        	   110: ;
00:82B8 A590            	   111:   lda token_address
00:82BA 8500            	   112:   sta SRCE
00:82BC A591            	   113:   lda token_address+1
00:82BE 8501            	   114:   sta SRCE+1
                        	   115: 
                        	   116: ;
                        	   117: ;  get editor handlers
                        	   118: ;
00:82C0 A9D6            	   119:   lda #<editor_handlers
00:82C2 8503            	   120:   sta DEST
00:82C4 A982            	   121:   lda #>editor_handlers
00:82C6 8504            	   122:   sta DEST+1
                        	   123: 
                        	   124: ;
                        	   125: ;  get the token length and look up the handler
                        	   126: ;
00:82C8 A592            	   127:   lda token_length
00:82CA 208D91          	   128:   jsr partial_handler_Lookup
                        	   129: 
                        	   130: ;
                        	   131: ;  if we returned, unknown command
                        	   132: ;
00:82CD A948            	   133:   lda #<bad_command
00:82CF A282            	   134:   ldx #>bad_command
00:82D1 202682          	   135:   jsr print
00:82D4 809C            	   136:   bra  main_prompt
                        	   137: 
                        	   138: 
                        	   139: editor_handlers:
                        	   140:   makeHandler "LIST",    editor_list
00:82D6 4C495354        	     1M    asciiz   "LIST"
00:82DA 00
00:82DB 5187            	     2M    word  editor_list
                        	   141:   makeHandler "INSERT",  editor_insert
00:82DD 494E53455254    	     1M    asciiz   "INSERT"
00:82E3 00
00:82E4 048A            	     2M    word  editor_insert
                        	   142:   makeHandler "LOAD",    editor_load
00:82E6 4C4F4144        	     1M    asciiz   "LOAD"
00:82EA 00
00:82EB 008A            	     2M    word  editor_load
                        	   143:   makeHandler "DELETE",  editor_delete
00:82ED 44454C455445    	     1M    asciiz   "DELETE"
00:82F3 00
00:82F4 928B            	     2M    word  editor_delete
                        	   144:   makeHandler "HELP",    editor_help
00:82F6 48454C50        	     1M    asciiz   "HELP"
00:82FA 00
00:82FB 0985            	     2M    word  editor_help
                        	   145:   makeHandler "COMPILE" ,editor_compile
00:82FD 434F4D50494C45  	     1M    asciiz   "COMPILE" 
00:8304 00
00:8305 038F            	     2M    word  editor_compile
                        	   146:   makeHandler "SYNTAX",  editor_syntax
00:8307 53594E544158    	     1M    asciiz   "SYNTAX"
00:830D 00
00:830E 0D8F            	     2M    word  editor_syntax
                        	   147:   makeHandler "SAVE",    editor_save
00:8310 53415645        	     1M    asciiz   "SAVE"
00:8314 00
00:8315 4B87            	     2M    word  editor_save
                        	   148: ;  makeHandler "TEST",    editor_test
                        	   149:   makeHandler "MEMORY",  editor_memory
00:8317 4D454D4F5259    	     1M    asciiz   "MEMORY"
00:831D 00
00:831E EA8C            	     2M    word  editor_memory
                        	   150:  ; makeHandler "SYMTBL", editor_symbol_table_list
                        	   151:   makeHandler "INFO",    editor_info
00:8320 494E464F        	     1M    asciiz   "INFO"
00:8324 00
00:8325 F18E            	     2M    word  editor_info
                        	   152:   makeHandler "TRACE",   editor_trace
00:8327 5452414345      	     1M    asciiz   "TRACE"
00:832C 00
00:832D DF8E            	     2M    word  editor_trace
                        	   153:   makeHandler "DEBUG",   editor_debug
00:832F 4445425547      	     1M    asciiz   "DEBUG"
00:8334 00
00:8335 C38E            	     2M    word  editor_debug
                        	   154:   makeHandler "ASSEMBLE",editor_assemble
00:8337 415353454D424C45	     1M    asciiz   "ASSEMBLE"
00:833F 00
00:8340 C68F            	     2M    word  editor_assemble
                        	   155:   makeHandler "FIND",    editor_find
00:8342 46494E44        	     1M    asciiz   "FIND"
00:8346 00
00:8347 4587            	     2M    word  editor_find
                        	   156:   makeHandler "REPLACE", editor_replace
00:8349 5245504C414345  	     1M    asciiz   "REPLACE"
00:8350 00
00:8351 3D87            	     2M    word  editor_replace
                        	   157:   makeHandler "RUN",     editor_run
00:8353 52554E          	     1M    asciiz   "RUN"
00:8356 00
00:8357 178F            	     2M    word  editor_run
                        	   158:   makeHandler "RESUME",  editor_resume
00:8359 524553554D45    	     1M    asciiz   "RESUME"
00:835F 00
00:8360 EB8F            	     2M    word  editor_resume
                        	   159:   makeHandler "RECOVER", editor_recover
00:8362 5245434F564552  	     1M    asciiz   "RECOVER"
00:8369 00
00:836A 748E            	     2M    word  editor_recover
                        	   160:   makeHandler "POKE",    editor_poke
00:836C 504F4B45        	     1M    asciiz   "POKE"
00:8370 00
00:8371 4190            	     2M    word  editor_poke
                        	   161:   makeHandler "JSR",     editor_jsr
00:8373 4A5352          	     1M    asciiz   "JSR"
00:8376 00
00:8377 FE90            	     2M    word  editor_jsr
                        	   162:   makeHandler "JMP",     editor_jmp
00:8379 4A4D50          	     1M    asciiz   "JMP"
00:837C 00
00:837D 2C91            	     2M    word  editor_jmp
00:837F 00              	   163:   dfb 0
                        	   164: 
                        	   165: editor_help_info:
00:8380 417661696C61626C	   166:   asc "Available actions:\n\n"
00:8388 6520616374696F6E
00:8390 733A0A0A
00:8394 4C6973742F534176	   167:   asc "List/SAve   line_number_range\n"
00:839C 652020206C696E65
00:83A4 5F6E756D6265725F
00:83AC 72616E67650A
00:83B2 44656C6574652020	   168:   asc "Delete      line_number_range\n"
00:83BA 202020206C696E65
00:83C2 5F6E756D6265725F
00:83CA 72616E67650A
00:83D0 496E736572742F4C	   169:   asc "Insert/LOad after_line\n"
00:83D8 4F61642061667465
00:83E0 725F6C696E650A
00:83E7 46696E6420202020	   170:   asc "Find        line_number_range /target/flags\n"
00:83EF 202020206C696E65
00:83F7 5F6E756D6265725F
00:83FF 72616E6765202F74
00:8407 61726765742F666C
00:840F 6167730A
00:8413 5265706C61636520	   171:   asc "Replace     line_number_range /target/replacement/flags\n"
00:841B 202020206C696E65
00:8423 5F6E756D6265725F
00:842B 72616E6765202F74
00:8433 61726765742F7265
00:843B 706C6163656D656E
00:8443 742F666C6167730A
00:844B 0A              	   172:   asc "\n"
00:844C 48656C700A      	   173:   asc "Help\n"
00:8451 494E666F0A      	   174:   asc "INfo\n"
00:8456 4D656D6F72792020	   175:   asc "Memory      first_address last_address\n"
00:845E 2020202066697273
00:8466 745F616464726573
00:846E 73206C6173745F61
00:8476 6464726573730A
00:847D 436F6D70696C652F	   176:   asc "Compile/Syntax/Assemble\n"
00:8485 53796E7461782F41
00:848D 7373656D626C650A
00:8495 52556E2F44454275	   177:   asc "RUn/DEBug/Trace/RESume\n"
00:849D 672F54726163652F
00:84A5 524553756D650A
00:84AC 506F6B652F4A7372	   178:   asc "Poke/Jsr/JMp\n"
00:84B4 2F4A4D700A
00:84B9 5245436F7665720A	   179:   asc "RECover\n"
00:84C1 28416374696F6E73	   180:   asc "(Actions may be abbreviated)\n"
00:84C9 206D617920626520
00:84D1 6162627265766961
00:84D9 746564290A
00:84DE 28466C6167733A20	   181:   asc "(Flags: 'I'gnore case, 'G'lobal, 'Q'uiet)\n"
00:84E6 274927676E6F7265
00:84EE 20636173652C2027
00:84F6 47276C6F62616C2C
00:84FE 2027512775696574
00:8506 290A
00:8508 00              	   182:   dfb 0
                        	   183: 
                        	   184: 
                        	   185: ;--------------------------------------------
                        	   186: ;  HELP
                        	   187: ;--------------------------------------------
                        	   188: editor_help:
00:8509 202E86          	   189:   jsr editor_check_no_more
00:850C A980            	   190:   lda #<editor_help_info
00:850E 8500            	   191:   sta REG
00:8510 A983            	   192:   lda #>editor_help_info
00:8512 8501            	   193:   sta REG+1
                        	   194: editor_help_loop:
00:8514 A000            	   195:   ldy #0
00:8516 B100            	   196:   lda (REG),Y
00:8518 F00B            	   197:   beq editor_help_done
00:851A 20F695          	   198:   jsr COUT
00:851D E600            	   199:   inc REG
00:851F D0F3            	   200:   bne editor_help_loop
00:8521 E601            	   201:   inc REG+1
00:8523 80EF            	   202:   bra editor_help_loop
                        	   203: editor_help_done:
00:8525 4C7282          	   204:   jmp main_prompt
                        	   205: 
                        	   206: ;
                        	   207: ;  Sets default range from 1 to 65535
                        	   208: ;
                        	   209: editor_default_range:
                        	   210: ;
                        	   211: ;  default to all lines
                        	   212: ;
00:8528 A901            	   213:   lda #1
00:852A 859E            	   214:   sta from_line
00:852C 649F            	   215:   stz from_line+1
00:852E A9FF            	   216:   lda #$FF
00:8530 85A0            	   217:   sta to_line
00:8532 85A1            	   218:   sta to_line+1
00:8534 60              	   219:   rts
                        	   220: 
                        	   221: number_expected_message:
00:8535 4E756D6265722065	   222:   asciiz "Number expected\n"
00:853D 787065637465640A
00:8545 00
                        	   223: 
                        	   224: editor_bad_number:
00:8546 A935            	   225:   lda #<number_expected_message
00:8548 A285            	   226:   ldx #>number_expected_message
00:854A 202682          	   227:   jsr print
00:854D 4C7282          	   228:   jmp main_prompt
                        	   229: 
                        	   230: ;
                        	   231: ;  get a number for the editor: accepts eof or newline as "no number"
                        	   232: ;  otherwise must be a number and in the range 0x0001 to 0xFFFF
                        	   233: ;  returns carry set if a number (in token_value) and carry clear if
                        	   234: ;  no number. Raises an error otherwise
                        	   235: ;
                        	   236: editor_get_number:
00:8550 2081D1          	   237:   jsr pas_get_token   ; use this to find END as a token
00:8553 F065            	   238:   beq editor_get_number_none ; no token? return with carry set
00:8555 C90A            	   239:   cmp #NL
00:8557 F061            	   240:   beq editor_get_number_none ; newline counts as no token
00:8559 C94E            	   241:   cmp #TOKEN_NUMBER
00:855B F04B            	   242:   beq editor_get_number_ok
00:855D C989            	   243:   cmp #TOKEN_END
00:855F F05B            	   244:   beq editor_get_number_end
00:8561 C949            	   245:   cmp #TOKEN_IDENTIFIER
00:8563 D02D            	   246:   bne editor_get_number_not_identifier
00:8565 A592            	   247:   lda token_length
00:8567 C903            	   248:   cmp #3
00:8569 D0DB            	   249:   bne editor_bad_number
00:856B A000            	   250:   ldy #0
00:856D B190            	   251:   lda (token_address),y
00:856F 200492          	   252:   jsr MAKE_UPPER
00:8572 C941            	   253:   cmp #'A'
00:8574 D0D0            	   254:   bne editor_bad_number
00:8576 C8              	   255:   iny
00:8577 B190            	   256:   lda (token_address),y
00:8579 200492          	   257:   jsr MAKE_UPPER
00:857C C94C            	   258:   cmp #'L'
00:857E D0C6            	   259:   bne editor_bad_number
00:8580 C8              	   260:   iny
00:8581 B190            	   261:   lda (token_address),y
00:8583 200492          	   262:   jsr MAKE_UPPER
00:8586 C94C            	   263:   cmp #'L'
00:8588 D0BC            	   264:   bne editor_bad_number
00:858A 202885          	   265:   jsr editor_default_range
00:858D 202E86          	   266:   jsr editor_check_no_more ; can't have ALL - something
00:8590 8028            	   267:   bra editor_get_number_none
                        	   268: ;
                        	   269: ;  find / replace can go straight to the delimiter
                        	   270: ;
                        	   271: editor_get_number_not_identifier:
00:8592 A910            	   272:   lda #EFLAG_FIND
00:8594 0920            	   273:   ora #EFLAG_REPLACE
00:8596 25BC            	   274:   and editor_flags
00:8598 F0AC            	   275:   beq editor_bad_number
00:859A A592            	   276:   lda token_length
00:859C C901            	   277:   cmp #1
00:859E D0A6            	   278:   bne editor_bad_number
                        	   279: ;
                        	   280: ;  go back one character, we need get_token to find this again later
                        	   281: ;
00:85A0 C68E            	   282:   dec token_start
00:85A2 D016            	   283:   bne editor_get_number_none
00:85A4 C68F            	   284:   dec token_start+1
00:85A6 8012            	   285:   bra editor_get_number_none
                        	   286: 
                        	   287: editor_get_number_ok:
00:85A8 A596            	   288:   lda token_value+2         ; must be a number
00:85AA D03C            	   289:   bne editor_line_number_too_big
00:85AC A5BC            	   290:   lda editor_flags
00:85AE 2902            	   291:   and #EFLAG_ALLOW_ZERO_FROM
00:85B0 D006            	   292:   bne editor_get_number_done
00:85B2 A594            	   293:   lda token_value
00:85B4 0595            	   294:   ora token_value+1
00:85B6 F030            	   295:   beq editor_line_number_too_big  ; too small actually
                        	   296: editor_get_number_done:
00:85B8 38              	   297:   sec
00:85B9 60              	   298:   rts
                        	   299: 
                        	   300: editor_get_number_none:
00:85BA 18              	   301:   clc
00:85BB 60              	   302:   rts
                        	   303: 
                        	   304: ;
                        	   305: ;  the word "END" will count as the highest possible line number
                        	   306: ;
                        	   307: editor_get_number_end:
00:85BC A9FF            	   308:   lda #$FF
00:85BE 8594            	   309:   sta token_value
00:85C0 8595            	   310:   sta token_value+1
00:85C2 6496            	   311:   stz token_value+2
00:85C4 202E86          	   312:   jsr editor_check_no_more ; can't have END - something
00:85C7 38              	   313:   sec
00:85C8 60              	   314:   rts
                        	   315: 
                        	   316: number_too_large_message:
00:85C9 4E756D6265722074	   317:   asciiz "Number too large or too small\n"
00:85D1 6F6F206C61726765
00:85D9 206F7220746F6F20
00:85E1 736D616C6C0A
00:85E7 00
                        	   318: 
                        	   319: editor_line_number_too_big:
00:85E8 A9C9            	   320:   lda #<number_too_large_message
00:85EA A285            	   321:   ldx #>number_too_large_message
00:85EC 202682          	   322:   jsr print
00:85EF 4C7282          	   323:   jmp main_prompt
                        	   324: 
                        	   325: number_bad_range_message:
00:85F2 52616E676520696E	   326:   asciiz "Range invalid\n"
00:85FA 76616C69640A
00:8600 00
                        	   327: 
                        	   328: editor_bad_range:
00:8601 A9F2            	   329:   lda #<number_bad_range_message
00:8603 A285            	   330:   ldx #>number_bad_range_message
00:8605 202682          	   331:   jsr print
00:8608 4C7282          	   332:   jmp main_prompt
                        	   333: 
                        	   334: too_much_on_line:
00:860B 556E657870656374	   335:   asciiz "Unexpected trailing input on line\n"
00:8613 656420747261696C
00:861B 696E6720696E7075
00:8623 74206F6E206C696E
00:862B 650A
00:862D 00
                        	   336: 
                        	   337: ;
                        	   338: ;  check that all is left on the line is spaces
                        	   339: ;
                        	   340: editor_check_no_more:
00:862E A000            	   341:   ldy #0
                        	   342: editor_check_no_more_loop:
00:8630 B18E            	   343:   lda (token_start),y
00:8632 F016            	   344:   beq editor_check_no_more_ok   ; end of file
00:8634 C90A            	   345:   cmp #NL
00:8636 F012            	   346:   beq editor_check_no_more_ok   ; newline is OK
00:8638 204A81          	   347:   jsr isspace
00:863B 9003            	   348:   bcc editor_check_no_more_failed ; not spaces is bad
00:863D C8              	   349:   iny
00:863E D0F0            	   350:   bne editor_check_no_more_loop   ; skip spaces
                        	   351: 
                        	   352: editor_check_no_more_failed:
00:8640 A90B            	   353:   lda #<too_much_on_line
00:8642 A286            	   354:   ldx #>too_much_on_line
00:8644 202682          	   355:   jsr print
00:8647 4C7282          	   356:   jmp main_prompt
                        	   357: editor_check_no_more_ok:
00:864A 60              	   358:   rts
                        	   359: 
                        	   360: 
                        	   361: 
                        	   362: ;--------------------------------------------
                        	   363: ;  get a range of line numbers (eg. L 1,10; D 4; M 6,10 )
                        	   364: ;--------------------------------------------
                        	   365: 
                        	   366: editor_get_range:
                        	   367: 
                        	   368: 
                        	   369: ;
                        	   370: ;  get the first line number (if any)
                        	   371: ;
00:864B 205085          	   372:   jsr editor_get_number
00:864E 9049            	   373:   bcc editor_get_range_done ; no token? take defaults
                        	   374: ;
                        	   375: ;  store the from line
                        	   376: ;
00:8650 A594            	   377:   lda token_value
00:8652 859E            	   378:   sta from_line
00:8654 85A0            	   379:   sta to_line
00:8656 A595            	   380:   lda token_value+1
00:8658 859F            	   381:   sta from_line+1
00:865A 85A1            	   382:   sta to_line+1
                        	   383: 
                        	   384: ;
                        	   385: ;  comma or hyphen?
                        	   386: ;
00:865C 20D3CB          	   387:   jsr get_token
00:865F F038            	   388:   beq editor_get_range_done   ; line done, just the single line wanted
                        	   389: 
00:8661 C92D            	   390:   cmp #'-'
00:8663 F01C            	   391:   beq editor_get_range_hyphen
00:8665 C94E            	   392:   cmp #TOKEN_NUMBER
00:8667 F01D            	   393:   beq editor_get_range_number
00:8669 C989            	   394:   cmp #TOKEN_END
00:866B F019            	   395:   beq editor_get_range_number
00:866D C92C            	   396:   cmp #','
00:866F F010            	   397:   beq editor_get_range_hyphen
                        	   398: ;
                        	   399: ;  find and replace may have another character after the first line number
                        	   400: ;  which isn't a second line number or a hyphen/comma
                        	   401: ;
00:8671 A910            	   402:   lda #EFLAG_FIND
00:8673 0920            	   403:   ora #EFLAG_REPLACE
00:8675 25BC            	   404:   and editor_flags
00:8677 F088            	   405:   beq editor_bad_range
                        	   406: 
                        	   407: ;
                        	   408: ;  go back one character, we need get_token to find this again later
                        	   409: ;
00:8679 C68E            	   410:   dec token_start
00:867B D01C            	   411:   bne editor_get_range_done
00:867D C68F            	   412:   dec token_start+1
00:867F 8018            	   413:   bra editor_get_range_done
                        	   414: 
                        	   415: editor_get_range_hyphen:
                        	   416: ;
                        	   417: ;  get the second line number
                        	   418: ;
00:8681 205085          	   419:   jsr editor_get_number
00:8684 9014            	   420:   bcc editor_bad_rangeJ
                        	   421: 
                        	   422: editor_get_range_number:
00:8686 A594            	   423:   lda token_value
00:8688 85A0            	   424:   sta to_line
00:868A A595            	   425:   lda token_value+1
00:868C 85A1            	   426:   sta to_line+1
                        	   427: 
                        	   428: ;
                        	   429: ;  make sure range ascends
                        	   430: ;
00:868E 38              	   431:   sec
00:868F A5A0            	   432:   lda to_line
00:8691 E59E            	   433:   sbc from_line
00:8693 A5A1            	   434:   lda to_line+1
00:8695 E59F            	   435:   sbc from_line+1
00:8697 9001            	   436:   bcc editor_bad_rangeJ    ; <sigh> because of the way SBC works
                        	   437: 
                        	   438: editor_get_range_done:
00:8699 60              	   439:   rts
                        	   440: 
00:869A 4C0186          	   441: editor_bad_rangeJ jmp editor_bad_range
                        	   442: 
                        	   443: ;
                        	   444: 
00:869D 20666F756E640A  	   445: found_message asciiz  ' found\n'
00:86A4 00
                        	   446: 
                        	   447: 
                        	   448: 
00:86A5 46726F6D3A20    	   449: from_msg: asciiz "From: "
00:86AB 00
00:86AC 20746F20        	   450: to_msg:   asciiz " to "
00:86B0 00
                        	   451: 
00:86B1 4261642064656C69	   452: bad_delimiter_message asciiz "Bad delimiter\n"
00:86B9 6D697465720A
00:86BF 00
                        	   453: 
                        	   454: editor_bad_delimiter:
00:86C0 A9B1            	   455:   lda #<bad_delimiter_message
00:86C2 A286            	   456:   ldx #>bad_delimiter_message
                        	   457: editor_find_problem:
00:86C4 202682          	   458:   jsr print
00:86C7 4C7282          	   459:   jmp main_prompt
                        	   460: 
00:86CA 46696E642F726570	   461: find_string_too_long_message asciiz "Find/replace string too long\n"
00:86D2 6C61636520737472
00:86DA 696E6720746F6F20
00:86E2 6C6F6E670A
00:86E7 00
                        	   462: 
                        	   463: find_string_too_long:
00:86E8 A9CA            	   464:   lda #<find_string_too_long_message
00:86EA A286            	   465:   ldx #>find_string_too_long_message
00:86EC 80D6            	   466:   bra editor_find_problem
                        	   467: 
                        	   468: editor_get_delimiter:
00:86EE 20D3CB          	   469:   jsr get_token
00:86F1 C949            	   470:   cmp #TOKEN_IDENTIFIER
00:86F3 F0CB            	   471:   beq editor_bad_delimiter
00:86F5 C94E            	   472:   cmp #TOKEN_NUMBER
00:86F7 F0C7            	   473:   beq editor_bad_delimiter
00:86F9 C922            	   474:   cmp #TOKEN_STRING
00:86FB F0C3            	   475:   beq editor_bad_delimiter
00:86FD A692            	   476:   ldx token_length
00:86FF E001            	   477:   cpx #1
00:8701 D0BD            	   478:   bne editor_bad_delimiter
00:8703 85B4            	   479:   sta find_delimiter
00:8705 60              	   480:   rts
                        	   481: 
00:8706 4E6F20636C6F7369	   482: editor_no_closing_delimiter_message asciiz "No closing delimiter\n"
00:870E 6E672064656C696D
00:8716 697465720A
00:871B 00
                        	   483: 
                        	   484: editor_no_closing_delimiter:
00:871C A906            	   485:   lda #<editor_no_closing_delimiter_message
00:871E A287            	   486:   ldx #>editor_no_closing_delimiter_message
00:8720 80A2            	   487:   bra editor_find_problem
                        	   488: 
00:8722 5461726765742073	   489: no_find_message asciiz "Target string empty\n"
00:872A 7472696E6720656D
00:8732 7074790A
00:8736 00
                        	   490: 
                        	   491: editor_no_find_string:
00:8737 A922            	   492:   lda #<no_find_message
00:8739 A287            	   493:   ldx #>no_find_message
00:873B 8087            	   494:   bra editor_find_problem
                        	   495: 
                        	   496: ;--------------------------------------------
                        	   497: ;  LIST / SAVE / FIND / REPLACE / MODIFY
                        	   498: ;
                        	   499: ;  This rather complex routine lists the source between from_line and to_line
                        	   500: ;   In the process it can show or omit line numbers  (omit for SAVE)
                        	   501: ;  Also, it can find the target text, and optionally replace it with the replacement text
                        	   502: ;  In find/replace mode the lines are not shown unless they had something found (unless
                        	   503: ;   the Quiet flag is set)
                        	   504: ;
                        	   505: ;--------------------------------------------
                        	   506: 
                        	   507: editor_replace:
00:873D A920            	   508:   lda #EFLAG_REPLACE
00:873F 0910            	   509:   ora #EFLAG_FIND   ; makes things simpler later on
00:8741 85BC            	   510:   sta editor_flags
00:8743 800C            	   511:   bra editor_list
                        	   512: 
                        	   513: editor_find:
                        	   514: 
00:8745 A910            	   515:   lda #EFLAG_FIND
00:8747 85BC            	   516:   sta editor_flags
00:8749 8006            	   517:   bra editor_list
                        	   518: 
                        	   519: editor_save
                        	   520: 
00:874B A980            	   521:   lda #EFLAG_NO_LINE_NUMBERS
00:874D 0908            	   522:   ora #EFLAG_SAVE
00:874F 85BC            	   523:   sta editor_flags
                        	   524: 
                        	   525: ;
                        	   526: ;  main entry point - get the from and to lines
                        	   527: ;
                        	   528: editor_list:
00:8751 202885          	   529:   jsr editor_default_range
00:8754 204B86          	   530:   jsr editor_get_range
                        	   531: 
                        	   532: ;
                        	   533: ;  turn the from_line into an address and put it into PCODE
                        	   534: ;
00:8757 A59E            	   535:   lda from_line
00:8759 85AC            	   536:   sta this_line
00:875B A59F            	   537:   lda from_line+1
00:875D 85AD            	   538:   sta this_line+1
00:875F 20738C          	   539:   jsr find_line    ; find the "from" line address (this_line in fact)
00:8762 A5AE            	   540:   lda this_line_addr
00:8764 8523            	   541:   sta PCODE
00:8766 A5AF            	   542:   lda this_line_addr+1
00:8768 8524            	   543:   sta PCODE+1
00:876A 64B9            	   544:   stz find_count
00:876C 64BA            	   545:   stz find_count+1
                        	   546: 
                        	   547: ;
                        	   548: ;  for FIND and REPLACE, get the first delimiter
                        	   549: ;
00:876E A5BC            	   550:   lda editor_flags
00:8770 2910            	   551:   and #EFLAG_FIND
00:8772 D003            	   552:   bne editor_list_doing_find
00:8774 4C4188          	   553:   jmp editor_list_not_find
                        	   554: 
                        	   555: editor_list_doing_find:
00:8777 20EE86          	   556:   jsr editor_get_delimiter
                        	   557: ;
                        	   558: ;  token_next should now be the start of what we are searching for
                        	   559: ;
00:877A 38              	   560:   sec
00:877B A58E            	   561:   lda token_start
00:877D E900            	   562:   sbc #<INBUF
00:877F 85B0            	   563:   sta find_from
00:8781 B00B            	   564:   bcs editor_list_got_from_point ; delimiter should be a single byte
                        	   565: 
                        	   566: editor_find_bug:
00:8783 A214            	   567:   ldx #20  ; ERROR: bug
00:8785 4CAB99          	   568:   jmp ERROR
                        	   569: 
00:8788 4CE886          	   570: find_string_too_longJ         jmp find_string_too_long
00:878B 4C1C87          	   571: editor_no_closing_delimiterJ  jmp editor_no_closing_delimiter
                        	   572: 
                        	   573: editor_list_got_from_point:
                        	   574: 
                        	   575: ;
                        	   576: ;  Now find closing delimiter by a simple scan as we will pass who-knows-what on the way
                        	   577: ;
00:878E A6B0            	   578:   ldx find_from
                        	   579: editor_find_second_delimiter_loop:
00:8790 E8              	   580:   inx
00:8791 BD0002          	   581:   lda INBUF,x
00:8794 F0F5            	   582:   beq editor_no_closing_delimiterJ
00:8796 C90A            	   583:   cmp #NL
00:8798 F0F1            	   584:   beq editor_no_closing_delimiterJ
00:879A C5B4            	   585:   cmp find_delimiter
00:879C D0F2            	   586:   bne editor_find_second_delimiter_loop
                        	   587: 
                        	   588: ;
                        	   589: ;  found the closing delimiter
                        	   590: ;
00:879E 86B1            	   591:   stx find_to
00:87A0 E4B0            	   592:   cpx find_from
00:87A2 F093            	   593:   beq editor_no_find_string
                        	   594: ;
                        	   595: ;  maximum 127 byte find string
                        	   596: ;
00:87A4 38              	   597:   sec
00:87A5 A5B1            	   598:   lda find_to
00:87A7 E5B0            	   599:   sbc find_from
00:87A9 30DD            	   600:   bmi find_string_too_longJ
00:87AB 85B3            	   601:   sta find_len    ; save for later memory move calculations
                        	   602: 
00:87AD A920            	   603:   lda #EFLAG_REPLACE
00:87AF 25BC            	   604:   and editor_flags
00:87B1 F02A            	   605:   beq editor_find_get_flags
                        	   606: 
                        	   607: ;
                        	   608: ;  doing a replace - find second delimiter
                        	   609: ;
                        	   610: 
00:87B3 86B5            	   611:   stx rep_from
00:87B5 E6B5            	   612:   inc rep_from    ; get past the delimiter
                        	   613: 
                        	   614: editor_find_third_delimiter_loop:
00:87B7 E8              	   615:   inx
00:87B8 BD0002          	   616:   lda INBUF,x
00:87BB F0CE            	   617:   beq editor_no_closing_delimiterJ
00:87BD C90A            	   618:   cmp #NL
00:87BF F0CA            	   619:   beq editor_no_closing_delimiterJ
00:87C1 C5B4            	   620:   cmp find_delimiter
00:87C3 D0F2            	   621:   bne editor_find_third_delimiter_loop
                        	   622: 
                        	   623: ;
                        	   624: ;  found the replacement closing delimiter
00:87C5 86B6            	   625:   stx rep_to
                        	   626: 
                        	   627: ;
                        	   628: ;  maximum 127 byte replacement string
                        	   629: ;
00:87C7 38              	   630:   sec
00:87C8 A5B6            	   631:   lda rep_to
00:87CA E5B5            	   632:   sbc rep_from
00:87CC 30BA            	   633:   bmi find_string_too_longJ
                        	   634: 
                        	   635: ;
                        	   636: ;  now find the signed difference between the find and replace strings
                        	   637: ;  namely: (rep_to - rep_from) - find_len
                        	   638: ;
00:87CE 64B8            	   639:   stz rep_diff+1
00:87D0 38              	   640:   sec
00:87D1 A5B6            	   641:   lda rep_to
00:87D3 E5B5            	   642:   sbc rep_from
00:87D5 E5B3            	   643:   sbc find_len
00:87D7 85B7            	   644:   sta rep_diff
00:87D9 1002            	   645:   bpl editor_find_get_flags
00:87DB C6B8            	   646:   dec rep_diff+1   ; make that $ff
                        	   647: 
                        	   648: ;
                        	   649: ; get any find/replace flags
                        	   650: ;
                        	   651: editor_find_get_flags:
00:87DD 64BD            	   652:   stz find_flags
                        	   653: 
                        	   654: editor_flags_loop:
00:87DF E8              	   655:   inx
00:87E0 BD0002          	   656:   lda INBUF,X
00:87E3 C90A            	   657:   cmp #NL
00:87E5 F042            	   658:   beq editor_list_fix_target_string
00:87E7 204A81          	   659:   jsr isspace
00:87EA B0F3            	   660:   bcs editor_flags_loop
00:87EC 200492          	   661:   jsr MAKE_UPPER
00:87EF C951            	   662:   cmp #'Q'
00:87F1 D00A            	   663:   bne editor_flags1
00:87F3 A904            	   664:   lda #FFLAG_QUIET
00:87F5 04BD            	   665:   tsb find_flags
00:87F7 A980            	   666:   lda #EFLAG_NO_LINE_NUMBERS
00:87F9 04BC            	   667:   tsb editor_flags
00:87FB 80E2            	   668:   bra editor_flags_loop
                        	   669: editor_flags1:
00:87FD C947            	   670:   cmp #'G'
00:87FF D006            	   671:   bne editor_flags2
00:8801 A902            	   672:   lda #FFLAG_GLOBAL
00:8803 04BD            	   673:   tsb find_flags
00:8805 80D8            	   674:   bra editor_flags_loop
                        	   675: editor_flags2:
00:8807 C949            	   676:   cmp #'I'
00:8809 D006            	   677:   bne editor_flags3
00:880B A901            	   678:   lda #FFLAG_IGNORE_CASE
00:880D 04BD            	   679:   tsb find_flags
00:880F 80CE            	   680:   bra editor_flags_loop
                        	   681: editor_flags3:
00:8811 A91B            	   682:   lda #<bad_flag_message
00:8813 A288            	   683:   ldx #>bad_flag_message
00:8815 202682          	   684:   jsr print
00:8818 4C7282          	   685:   jmp main_prompt
                        	   686: 
00:881B 556E6B6E6F776E20	   687: bad_flag_message: asciiz "Unknown flag\n"
00:8823 666C61670A
00:8828 00
                        	   688: 
                        	   689: editor_list_fix_target_string:
                        	   690: 
00:8829 A901            	   691:   lda #FFLAG_IGNORE_CASE
00:882B 25BD            	   692:   and find_flags
00:882D F015            	   693:   beq editor_list_get_on_with_it
                        	   694: 
                        	   695: ;
                        	   696: ;  for case insensitive compare force target to be upper case
                        	   697: ;
00:882F A6B0            	   698:   ldx find_from
                        	   699: editor_list_fixup_loop:
00:8831 E4B1            	   700:   cpx find_to
00:8833 F00F            	   701:   beq editor_list_get_on_with_it
00:8835 BD0002          	   702:   lda INBUF,X
00:8838 200492          	   703:   jsr MAKE_UPPER
00:883B 9D0002          	   704:   sta INBUF,X
00:883E E8              	   705:   inx
00:883F 80F0            	   706:   bra editor_list_fixup_loop
                        	   707: 
                        	   708: 
                        	   709: editor_list_not_find:
                        	   710: ;
                        	   711: ;  we should have no more tokens now
                        	   712: ;
00:8841 202E86          	   713:   jsr editor_check_no_more
                        	   714: 
                        	   715: editor_list_get_on_with_it:
                        	   716: ;
                        	   717: ;  make sure current_line is correct
                        	   718: ;
00:8844 A59E            	   719:   lda from_line
00:8846 85A2            	   720:   sta current_line
00:8848 A59F            	   721:   lda from_line+1
00:884A 85A3            	   722:   sta current_line+1
                        	   723: 
                        	   724: ;
                        	   725: ;  exit immediately if no source from here on
                        	   726: ;
00:884C A000            	   727:   ldy #0
00:884E B123            	   728:   lda (PCODE),Y
00:8850 D003            	   729:   bne editor_list_have_source
00:8852 4C7089          	   730:   jmp editor_list_done
                        	   731: 
                        	   732: editor_list_have_source:
00:8855 A901            	   733:   lda #EFLAG_SHOW_LINE
00:8857 04BC            	   734:   tsb editor_flags
00:8859 8006            	   735:   bra editor_list_loop
                        	   736: 
00:885B 4C7089          	   737: editor_list_doneJ jmp editor_list_done
00:885E 4C3289          	   738: editor_list_no_line_numberJ jmp editor_list_no_line_number
                        	   739: 
                        	   740: editor_list_loop:
00:8861 A58B            	   741:   lda serial_in_byte_received
00:8863 C903            	   742:   cmp  #KEY_ABORT
00:8865 F021            	   743:   beq  editor_list_aborted
00:8867 64BB            	   744:   stz  found_this_line
00:8869 A000            	   745:   ldy #0
00:886B B123            	   746:   lda (PCODE),Y
00:886D F0EC            	   747:   beq editor_list_doneJ
00:886F A5BC            	   748:   lda editor_flags
00:8871 2901            	   749:   and #EFLAG_SHOW_LINE
00:8873 F0E9            	   750:   beq  editor_list_no_line_numberJ
00:8875 A5BC            	   751:   lda editor_flags
00:8877 2908            	   752:   and #EFLAG_SAVE
00:8879 D0E3            	   753:   bne editor_list_no_line_numberJ
                        	   754: ;
                        	   755: ;  At this exact point we know we are at the start of a line
                        	   756: ;  and we aren't doing a Save. Now, if we are doing a Find then
                        	   757: ;  we need to know if this line (from here to the next newline)
                        	   758: ;  matches our find string, and if not, to skip it
                        	   759: 
00:887B A940            	   760:   lda #EFLAG_SUPPRESS_NEWLINE
00:887D 14BC            	   761:   trb editor_flags              ; we can show newlines now
                        	   762: 
00:887F A5BC            	   763:   lda editor_flags
00:8881 2910            	   764:   and #EFLAG_FIND
00:8883 D010            	   765:   bne editor_find_or_replacing
                        	   766: 
00:8885 4C2589          	   767:   jmp  editor_list_not_finding
                        	   768: 
                        	   769: ;
                        	   770: ;  Here when Ctrl+C pressed
                        	   771: ;
                        	   772: editor_list_aborted:
00:8888 A232            	   773:   ldx #50
00:888A A000            	   774:   ldy #0
00:888C 201593          	   775:   jsr delay   ; 50 ms delay to allow serial to settle
00:888F 206894          	   776:   jsr CROUT
00:8892 4C7089          	   777:   jmp editor_list_done
                        	   778: 
                        	   779: editor_find_or_replacing:
                        	   780: 
                        	   781: ;
                        	   782: ;  here if finding or replacing
                        	   783: ;
                        	   784: 
00:8895 A900            	   785:   lda #0
                        	   786: 
                        	   787: ;
                        	   788: ;  we come back here for multiple replacements with a new starting pos
                        	   789: ;
                        	   790: editor_replacement_loop:
00:8897 85B2            	   791:   sta find_pos    ; searching line from beginning (or not, if doing a multiple replace)
                        	   792: 
                        	   793: editor_find_loop:
00:8899 A6B0            	   794:   ldx find_from   ; out target string position in INBUF
00:889B A4B2            	   795:   ldy find_pos    ; where we are on the line
                        	   796: editor_find_inner_loop:
00:889D E4B1            	   797:   cpx find_to     ; reached end of target, found the string!
00:889F F037            	   798:   beq editor_find_found_it
00:88A1 B123            	   799:   lda (PCODE),Y
00:88A3 C90A            	   800:   cmp #NL
00:88A5 F01B            	   801:   beq editor_find_no_match ; hit end of line without matching
                        	   802: 
                        	   803: ;
                        	   804: ;  force to upper-case if required
                        	   805: ;
00:88A7 48              	   806:   pha
00:88A8 A901            	   807:   lda #FFLAG_IGNORE_CASE
00:88AA 25BD            	   808:   and find_flags
00:88AC F006            	   809:   beq editor_find_case_sensitive
00:88AE 68              	   810:   pla
00:88AF 200492          	   811:   jsr MAKE_UPPER
00:88B2 8001            	   812:   bra editor_find_test_character
                        	   813: editor_find_case_sensitive:
00:88B4 68              	   814:   pla
                        	   815: editor_find_test_character:
00:88B5 DD0002          	   816:   cmp INBUF,X     ; does source byte match target byte?
00:88B8 D004            	   817:   bne editor_find_skip_this
00:88BA C8              	   818:   iny
00:88BB E8              	   819:   inx
00:88BC 80DF            	   820:   bra editor_find_inner_loop
                        	   821: 
                        	   822: editor_find_skip_this:
00:88BE E6B2            	   823:   inc find_pos
00:88C0 D0D7            	   824:   bne editor_find_loop  ; if it wraps, give up
                        	   825: 
                        	   826: ;
                        	   827: ;  we are at the newline without a match, increment PCODE to match
                        	   828: ;  where we are and go onto newline processing
                        	   829: ;
                        	   830: editor_find_no_match:
00:88C2 A5BB            	   831:    lda found_this_line
00:88C4 D05F            	   832:    bne editor_list_not_finding
00:88C6 18              	   833:    clc
00:88C7 98              	   834:    tya
00:88C8 6523            	   835:    adc PCODE
00:88CA 8523            	   836:    sta PCODE
00:88CC A900            	   837:    lda #0
00:88CE 6524            	   838:    adc PCODE+1
00:88D0 8524            	   839:    sta PCODE+1
00:88D2 A940            	   840:    lda #EFLAG_SUPPRESS_NEWLINE
00:88D4 04BC            	   841:    tsb editor_flags
00:88D6 8062            	   842:    bra editor_newline_processing
                        	   843: 
                        	   844: ;
                        	   845: ;  here when find succeeded
                        	   846: ;
                        	   847: editor_find_found_it:
00:88D8 E6B9            	   848:   inc find_count
00:88DA D002            	   849:   bne editor_find_found_it1
00:88DC E6BA            	   850:   inc find_count+1
                        	   851: editor_find_found_it1:
00:88DE A901            	   852:   lda #1
00:88E0 85BB            	   853:   sta found_this_line
00:88E2 A920            	   854:   lda #EFLAG_REPLACE
00:88E4 25BC            	   855:   and editor_flags
00:88E6 D00E            	   856:   bne editor_do_the_replace
                        	   857: 
00:88E8 A902            	   858:   lda #FFLAG_GLOBAL
00:88EA 25BD            	   859:   and find_flags
00:88EC F037            	   860:   beq editor_list_not_finding   ; one replace is enough
                        	   861: 
                        	   862: ;
                        	   863: ;  add the find length to Y (moving past what we just found)
                        	   864: ;
                        	   865: ;
00:88EE 18              	   866:   clc
00:88EF A5B2            	   867:   lda find_pos
00:88F1 65B3            	   868:   adc find_len
00:88F3 4C9788          	   869:   jmp editor_replacement_loop
                        	   870: 
                        	   871: ;
                        	   872: ;  here when replacing
                        	   873: ;
                        	   874: editor_do_the_replace:
00:88F6 A908            	   875:   lda #FLAG_VALID_COMPILE   ; compile or assemble no longer valid
00:88F8 0910            	   876:   ora #FLAG_VALID_ASSEMBLE
00:88FA 14BE            	   877:   trb system_flags
                        	   878: 
00:88FC A5B7            	   879:   lda rep_diff ; same length?
00:88FE F003            	   880:   beq editor_easy_replace
00:8900 4C9089          	   881:   jmp editor_do_replace
                        	   882: 
                        	   883: editor_easy_replace:
00:8903 A4B2            	   884:   ldy find_pos
00:8905 A6B5            	   885:   ldx rep_from
                        	   886: editor_easy_replace_loop:
00:8907 E4B6            	   887:   cpx rep_to
00:8909 F009            	   888:   beq editor_easy_replace_done
00:890B BD0002          	   889:   lda INBUF,x
00:890E 9123            	   890:   sta (PCODE),y
00:8910 C8              	   891:   iny
00:8911 E8              	   892:   inx
00:8912 D0F3            	   893:   bne editor_easy_replace_loop  ; keep replacing
                        	   894: 
                        	   895: editor_easy_replace_done:
00:8914 A902            	   896:   lda #FFLAG_GLOBAL
00:8916 25BD            	   897:   and find_flags
00:8918 F00B            	   898:   beq editor_list_not_finding   ; one replace is enough
                        	   899: 
                        	   900: ;
                        	   901: ;  add the replacement length to Y (moving past what we just replaced)
                        	   902: ;   the replacement length is rep_to - rep_from
                        	   903: ;
00:891A 18              	   904:   clc
00:891B A5B2            	   905:   lda find_pos
00:891D 65B6            	   906:   adc rep_to
00:891F 38              	   907:   sec
00:8920 E5B5            	   908:   sbc rep_from
00:8922 4C9788          	   909:   jmp editor_replacement_loop
                        	   910: 
                        	   911: ;
                        	   912: ;
                        	   913: ;  display the line number
                        	   914: ;
                        	   915: editor_list_not_finding:
00:8925 A901            	   916:   lda #EFLAG_SHOW_LINE
00:8927 14BC            	   917:   trb editor_flags      ; cancel flag until next newline
00:8929 A980            	   918:   lda #EFLAG_NO_LINE_NUMBERS
00:892B 25BC            	   919:   and editor_flags
00:892D D003            	   920:   bne editor_list_no_line_number
00:892F 20358C          	   921:   jsr show_current_line_number
                        	   922: 
                        	   923: editor_list_no_line_number:
00:8932 A000            	   924:   ldy  #0
00:8934 B123            	   925:   lda  (PCODE),Y
00:8936 C90A            	   926:   cmp  #NL
00:8938 D022            	   927:   bne  editor_list_not_newline
                        	   928: 
                        	   929: editor_newline_processing:
00:893A A901            	   930:   lda  #EFLAG_SHOW_LINE
00:893C 04BC            	   931:   tsb  editor_flags
00:893E E6A2            	   932:   inc  current_line
00:8940 D002            	   933:   bne  editor_list_check_to_line
00:8942 E6A3            	   934:   inc  current_line+1
                        	   935: 
                        	   936: ;
                        	   937: ;  see if we hit the wanted "to" line
                        	   938: ;
                        	   939: editor_list_check_to_line:
00:8944 A5A3            	   940:   lda  current_line+1
00:8946 C5A1            	   941:   cmp  to_line+1
00:8948 900A            	   942:   bcc  editor_list_check_to_line_ok
00:894A D024            	   943:   bne  editor_list_done
00:894C A5A2            	   944:   lda  current_line
00:894E C5A0            	   945:   cmp  to_line
00:8950 9002            	   946:   bcc  editor_list_check_to_line_ok
00:8952 D01C            	   947:   bne  editor_list_done
                        	   948: 
                        	   949: editor_list_check_to_line_ok:
                        	   950: 
00:8954 A940            	   951:   lda #EFLAG_SUPPRESS_NEWLINE
00:8956 25BC            	   952:   and editor_flags
00:8958 D00D            	   953:   bne editor_list_skip_newline
00:895A A90A            	   954:   lda #NL   ; put the newline back
                        	   955: 
                        	   956: ;
                        	   957: ;  just echo the character, and increment the memory address
                        	   958: ;
                        	   959: editor_list_not_newline:
00:895C AA              	   960:   tax
00:895D A904            	   961:   lda #FFLAG_QUIET
00:895F 25BD            	   962:   and find_flags
00:8961 D004            	   963:   bne editor_list_skip_newline
00:8963 8A              	   964:   txa
00:8964 20C594          	   965:   jsr PRCHAR
                        	   966: 
                        	   967: editor_list_skip_newline:
00:8967 E623            	   968:   inc PCODE
00:8969 D002            	   969:   bne editor_list_loopJ
00:896B E624            	   970:   inc PCODE+1
                        	   971: 
                        	   972: editor_list_loopJ:
00:896D 4C6188          	   973:   jmp editor_list_loop
                        	   974: 
                        	   975: editor_list_done:
00:8970 206894          	   976:   jsr CROUT
                        	   977: 
00:8973 A5B9            	   978:   lda find_count
00:8975 05BA            	   979:   ora find_count+1
00:8977 F014            	   980:   beq  editor_list_completely_done
00:8979 A5B9            	   981:   lda find_count
00:897B 8500            	   982:   sta REG
00:897D A5BA            	   983:   lda find_count+1
00:897F 8501            	   984:   sta REG+1
00:8981 6402            	   985:   stz REGB
00:8983 209293          	   986:   jsr display_in_decimal
00:8986 A99D            	   987:   lda #<found_message
00:8988 A286            	   988:   ldx #>found_message
00:898A 202682          	   989:   jsr print
                        	   990: 
                        	   991: editor_list_completely_done:
00:898D 4C7282          	   992:   jmp main_prompt
                        	   993: 
                        	   994: ;
                        	   995: ;  This if for replacing when the lengths differ
                        	   996: ;
                        	   997: editor_do_replace:
                        	   998: ;
                        	   999: ; add our current find_pos to PCODE to get where we are in memory
                        	  1000: ;
00:8990 18              	  1001:   clc
00:8991 A523            	  1002:   lda  PCODE
00:8993 48              	  1003:   pha   ; save where we currently are
00:8994 65B2            	  1004:   adc  find_pos
00:8996 85A6            	  1005:   sta  mem_move_src
00:8998 A524            	  1006:   lda  PCODE+1
00:899A 48              	  1007:   pha
00:899B 6900            	  1008:   adc  #0
00:899D 85A7            	  1009:   sta  mem_move_src+1
                        	  1010: 
                        	  1011: ;
                        	  1012: ;  add the source string length as we don't need to copy that
                        	  1013: ;
00:899F 18              	  1014:   clc
00:89A0 A5A6            	  1015:   lda mem_move_src
00:89A2 65B3            	  1016:   adc find_len
00:89A4 85A6            	  1017:   sta mem_move_src
00:89A6 A5A7            	  1018:   lda mem_move_src+1
00:89A8 6900            	  1019:   adc #0
00:89AA 85A7            	  1020:   sta mem_move_src+1
                        	  1021: 
                        	  1022: ;
                        	  1023: ;  the move destination is the source plus the replacement length
                        	  1024: ;   (ie. a gap of the difference in bytes)
                        	  1025: 
00:89AC 18              	  1026:   clc
00:89AD A5A6            	  1027:   lda mem_move_src
00:89AF 65B7            	  1028:   adc rep_diff
00:89B1 85A8            	  1029:   sta mem_move_dest
00:89B3 A5A7            	  1030:   lda mem_move_src+1
00:89B5 65B8            	  1031:   adc rep_diff+1
00:89B7 85A9            	  1032:   sta mem_move_dest+1
                        	  1033: 
                        	  1034: 
00:89B9 20A78C          	  1035:   jsr find_source_end   ; goes into PCODE
                        	  1036: ;
                        	  1037: ;  the length to move will be (the end of the source) - (the start of the move)
                        	  1038: ;
00:89BC 38              	  1039:   sec
00:89BD A523            	  1040:   lda PCODE
00:89BF E5A6            	  1041:   sbc mem_move_src
00:89C1 85AA            	  1042:   sta mem_move_len
00:89C3 A524            	  1043:   lda PCODE+1
00:89C5 E5A7            	  1044:   sbc mem_move_src+1
00:89C7 85AB            	  1045:   sta mem_move_len+1
                        	  1046: 
00:89C9 A5B8            	  1047:   lda rep_diff+1
00:89CB 3005            	  1048:   bmi editor_do_replace_smaller
00:89CD 20A681          	  1049:   jsr moveup      ; replacing with larger string
00:89D0 8003            	  1050:   bra editor_do_replace_copy_done
                        	  1051: 
                        	  1052: editor_do_replace_smaller:
00:89D2 207A81          	  1053:   jsr movedown    ; replacing with smaller string
                        	  1054: 
                        	  1055: editor_do_replace_copy_done:
                        	  1056: ;
                        	  1057: ;  get the current source address back
                        	  1058: ;
00:89D5 68              	  1059:   pla
00:89D6 8524            	  1060:   sta  PCODE+1
00:89D8 68              	  1061:   pla
00:89D9 8523            	  1062:   sta  PCODE
00:89DB 4C0389          	  1063:   jmp  editor_easy_replace    ; now move in new string
                        	  1064: 
                        	  1065: 
00:89DE 456E74657220736F	  1066: load_message asciiz "Enter source, terminate with Esc\n"
00:89E6 757263652C207465
00:89EE 726D696E61746520
00:89F6 7769746820457363
00:89FE 0A
00:89FF 00
                        	  1067: 
                        	  1068: ;--------------------------------------------
                        	  1069: ;  INSERT / LOAD
                        	  1070: ;--------------------------------------------
                        	  1071: editor_load:
                        	  1072: 
00:8A00 A904            	  1073:   lda #EFLAG_LOAD
00:8A02 85BC            	  1074:   sta editor_flags
                        	  1075: 
                        	  1076: editor_insert:
00:8A04 205085          	  1077:   jsr editor_get_number
00:8A07 9015            	  1078:   bcc editor_insert_at_start
                        	  1079: 
                        	  1080:   ;
                        	  1081:   ; I really want to insert AFTER this line so I'll add 1 to whatever line number they gave
                        	  1082:   ; To insert at the start use Insert without a line number
                        	  1083:   ;
00:8A09 18              	  1084:   clc
00:8A0A A594            	  1085:   lda token_value
00:8A0C 6901            	  1086:   adc #1
00:8A0E 85AC            	  1087:   sta this_line
00:8A10 A595            	  1088:   lda token_value+1
00:8A12 6900            	  1089:   adc #0
00:8A14 85AD            	  1090:   sta this_line+1
                        	  1091: 
00:8A16 202E86          	  1092:   jsr editor_check_no_more
00:8A19 20738C          	  1093:   jsr find_line    ; find the "from" line address
00:8A1C 800E            	  1094:   bra editor_insert_common
                        	  1095: 
                        	  1096: editor_insert_at_start:
00:8A1E A900            	  1097:   lda #<TEXT_START
00:8A20 85AE            	  1098:   sta this_line_addr
00:8A22 A903            	  1099:   lda #>TEXT_START
00:8A24 85AF            	  1100:   sta this_line_addr+1
00:8A26 A901            	  1101:   lda #1
00:8A28 85A2            	  1102:   sta current_line    ; current line number (1)
00:8A2A 64A3            	  1103:   stz current_line+1
                        	  1104: 
                        	  1105: editor_insert_common:
00:8A2C 20A78C          	  1106:   jsr find_source_end
                        	  1107: 
                        	  1108: ;
                        	  1109: ;  move existing source to end of RAM
                        	  1110: ;
00:8A2F 38              	  1111:   sec
00:8A30 A523            	  1112:   lda PCODE
00:8A32 E5AE            	  1113:   sbc this_line_addr
00:8A34 85AA            	  1114:   sta mem_move_len
00:8A36 A524            	  1115:   lda PCODE+1
00:8A38 E5AF            	  1116:   sbc this_line_addr+1
00:8A3A 85AB            	  1117:   sta mem_move_len+1
                        	  1118: 
                        	  1119: ;
                        	  1120: ;  find where to move to
                        	  1121: ;
00:8A3C 38              	  1122:   sec
00:8A3D A9FF            	  1123:   lda #<HIGHEST_RAM
00:8A3F E5AA            	  1124:   sbc mem_move_len
00:8A41 85A8            	  1125:   sta mem_move_dest
00:8A43 85A4            	  1126:   sta insert_limit
00:8A45 A93F            	  1127:   lda #>HIGHEST_RAM
00:8A47 E5AB            	  1128:   sbc mem_move_len+1
00:8A49 85A9            	  1129:   sta mem_move_dest+1
00:8A4B 85A5            	  1130:   sta insert_limit+1
                        	  1131: 
                        	  1132: ;
                        	  1133: ;  the source of the move
                        	  1134: ;
00:8A4D A5AE            	  1135:   lda this_line_addr
00:8A4F 85A6            	  1136:   sta mem_move_src
00:8A51 A5AF            	  1137:   lda this_line_addr+1
00:8A53 85A7            	  1138:   sta mem_move_src+1
                        	  1139: 
00:8A55 20A681          	  1140:   jsr moveup
                        	  1141: 
                        	  1142: ;
                        	  1143: ;  put input at from_line_addr
                        	  1144: ;
                        	  1145: 
00:8A58 A5AE            	  1146:   lda this_line_addr
00:8A5A 8523            	  1147:   sta PCODE
00:8A5C A5AF            	  1148:   lda this_line_addr+1
00:8A5E 8524            	  1149:   sta PCODE+1
                        	  1150: 
00:8A60 A9DE            	  1151:   lda  #<load_message
00:8A62 A289            	  1152:   ldx  #>load_message
00:8A64 202682          	  1153:   jsr  print
                        	  1154: 
                        	  1155: ;
                        	  1156: ;  show the first line number
                        	  1157: ;
                        	  1158: 
00:8A67 A901            	  1159:   lda #EFLAG_SHOW_LINE
00:8A69 04BC            	  1160:   tsb editor_flags
00:8A6B A000            	  1161:   ldy #0    ; offset from PCODE for inserting (should always be zero)
00:8A6D A200            	  1162:   ldx #0    ; last character we inserted
                        	  1163: 
                        	  1164: editor_insert_loop:
00:8A6F A904            	  1165:   lda #EFLAG_LOAD         ; no line numbers on load
00:8A71 25BC            	  1166:   and editor_flags
00:8A73 D00B            	  1167:   bne editor_insert_no_line_number
                        	  1168: 
00:8A75 A5BC            	  1169:   lda editor_flags
00:8A77 2901            	  1170:   and #EFLAG_SHOW_LINE
00:8A79 F005            	  1171:   beq  editor_insert_no_line_number
                        	  1172: ;
                        	  1173: ;  display the line number
                        	  1174: ;
                        	  1175: 
00:8A7B 64BC            	  1176:   stz editor_flags      ; cancel flag until next newline
00:8A7D 20358C          	  1177:   jsr show_current_line_number
                        	  1178: 
                        	  1179: editor_insert_no_line_number:
00:8A80 2053CB          	  1180:   jsr  CHRIN
00:8A83 C90D            	  1181:   cmp  #CR                          ; carriage-return?
00:8A85 F0F9            	  1182:   beq  editor_insert_no_line_number ; yes, ignore
00:8A87 C91B            	  1183:   cmp  #END_EDITOR_INPUT            ; Esc?
00:8A89 F04F            	  1184:   beq  editor_insert_done
00:8A8B C908            	  1185:   cmp  #BACKSPACE
00:8A8D F029            	  1186:   beq  editor_insert_backspace
00:8A8F C90A            	  1187:   cmp  #NL
00:8A91 D00C            	  1188:   bne  editor_insert_not_newline
00:8A93 A901            	  1189:   lda  #EFLAG_SHOW_LINE
00:8A95 04BC            	  1190:   tsb  editor_flags
00:8A97 A90A            	  1191:   lda  #NL            ; get the newline back
00:8A99 E6A2            	  1192:   inc  current_line
00:8A9B D002            	  1193:   bne  editor_insert_not_newline
00:8A9D E6A3            	  1194:   inc  current_line+1
                        	  1195: editor_insert_not_newline:
00:8A9F 9123            	  1196:   sta  (PCODE),y
00:8AA1 AA              	  1197:   tax                ; for detecting final newline
00:8AA2 E623            	  1198:   inc  PCODE
00:8AA4 D002            	  1199:   bne  editor_insert_loop1
00:8AA6 E624            	  1200:   inc  PCODE+1
                        	  1201: 
                        	  1202: editor_insert_loop1:
00:8AA8 A5A5            	  1203:   lda  insert_limit+1
00:8AAA C524            	  1204:   cmp  PCODE+1
00:8AAC B0C1            	  1205:   bcs  editor_insert_loop   ; carry is SET if we didn't borrow
00:8AAE D056            	  1206:   bne  editor_too_full
00:8AB0 A5A4            	  1207:   lda  insert_limit
00:8AB2 C523            	  1208:   cmp  PCODE
00:8AB4 F050            	  1209:   beq  editor_too_full
00:8AB6 80B7            	  1210:   bra  editor_insert_loop
                        	  1211: 
                        	  1212: ;
                        	  1213: ;  backspace reduces our pointer by one, unless we are at the start
                        	  1214: ;
                        	  1215: editor_insert_backspace:
00:8AB8 A523            	  1216:   lda PCODE
00:8ABA C5AE            	  1217:   cmp this_line_addr
00:8ABC D006            	  1218:   bne editor_insert_backspace_not_at_start
00:8ABE A524            	  1219:   lda PCODE+1
00:8AC0 C5AF            	  1220:   cmp this_line_addr+1
00:8AC2 F0AB            	  1221:   beq editor_insert_loop    ; at start, ignore backspace
                        	  1222: 
                        	  1223: editor_insert_backspace_not_at_start:
00:8AC4 38              	  1224:   sec                       ; move source pointer back one
00:8AC5 A523            	  1225:   lda PCODE
00:8AC7 E901            	  1226:   sbc #1
00:8AC9 8523            	  1227:   sta PCODE
00:8ACB A524            	  1228:   lda PCODE+1
00:8ACD E900            	  1229:   sbc #0
00:8ACF 8524            	  1230:   sta PCODE+1
00:8AD1 B123            	  1231:   lda (PCODE),y
00:8AD3 AA              	  1232:   tax                      ; this is now the last character we inserted
                        	  1233: ;
                        	  1234: ;  however we don't want them backspacing over a previous line, so if we detect a newline
                        	  1235: ;  just go back up and put it back (and increment PCODE back to where it was)
                        	  1236: ;
00:8AD4 C90A            	  1237:   cmp #NL
00:8AD6 F0C7            	  1238:   beq editor_insert_not_newline
00:8AD8 8095            	  1239:   bra editor_insert_loop
                        	  1240: 
                        	  1241: editor_insert_done:
00:8ADA 8A              	  1242:   txa
00:8ADB F00E            	  1243:   beq editor_insert_done_with_newline   ; nothing got inserted at all
00:8ADD C90A            	  1244:   cmp #NL
00:8ADF F00A            	  1245:   beq editor_insert_done_with_newline  ; skip inserting a newline if we just got a newline
                        	  1246: ;
                        	  1247: ;  They finished inserting, but without a newline ... add one
                        	  1248: ;
00:8AE1 A90A            	  1249:   lda #NL
00:8AE3 9123            	  1250:   sta (PCODE),y
00:8AE5 E623            	  1251:   inc PCODE
00:8AE7 D002            	  1252:   bne editor_insert_done_with_newline
00:8AE9 E624            	  1253:   inc PCODE+1
                        	  1254: 
                        	  1255: ;
                        	  1256: ;  they are done - copy the rest back to the end of where they just inserted
                        	  1257: ;
                        	  1258: editor_insert_done_with_newline:
                        	  1259: 
00:8AEB 64BE            	  1260:   stz system_flags     ; compile is not valid any more
                        	  1261: 
00:8AED A523            	  1262:   lda PCODE
00:8AEF 85A8            	  1263:   sta mem_move_dest
00:8AF1 A524            	  1264:   lda PCODE+1
00:8AF3 85A9            	  1265:   sta mem_move_dest+1
                        	  1266: 
00:8AF5 A5A4            	  1267:   lda insert_limit
00:8AF7 85A6            	  1268:   sta mem_move_src
00:8AF9 A5A5            	  1269:   lda insert_limit+1
00:8AFB 85A7            	  1270:   sta mem_move_src+1
                        	  1271: 
00:8AFD 207A81          	  1272:   jsr movedown
                        	  1273: 
00:8B00 206894          	  1274:   jsr CROUT   ; put a newline after the ESC character
00:8B03 4C7282          	  1275:   jmp main_prompt
                        	  1276: 
                        	  1277: editor_too_full:
00:8B06 A931            	  1278:   lda #<memory_full
00:8B08 A28B            	  1279:   ldx #>memory_full
00:8B0A 202682          	  1280:   jsr print
                        	  1281: ;
                        	  1282: ;  consume input so it isn't mistaken for a command
                        	  1283: ;
                        	  1284: editor_too_full_loop:
00:8B0D 2053CB          	  1285:   jsr CHRIN
00:8B10 C91B            	  1286:   cmp #END_EDITOR_INPUT
00:8B12 D0F9            	  1287:   bne editor_too_full_loop
                        	  1288: ;
                        	  1289: ;  another message, they may miss the first one during a bulk load
                        	  1290: ;
00:8B14 A94C            	  1291:   lda #<memory_filled_up
00:8B16 A28B            	  1292:   ldx #>memory_filled_up
00:8B18 202682          	  1293:   jsr print
00:8B1B 4CDA8A          	  1294:   jmp editor_insert_done
                        	  1295: 
00:8B1E 4E6F2072616E6765	  1296: editor_no_lines  asciiz "No range supplied\n"
00:8B26 20737570706C6965
00:8B2E 640A
00:8B30 00
00:8B31 0A0A4D656D6F7279	  1297: memory_full      asciiz "\n\nMemory full - press Esc\n"
00:8B39 2066756C6C202D20
00:8B41 7072657373204573
00:8B49 630A
00:8B4B 00
00:8B4C 0A0A4E6F20726F6F	  1298: memory_filled_up asciiz "\n\nNo room for source during load/input\n\n"
00:8B54 6D20666F7220736F
00:8B5C 7572636520647572
00:8B64 696E67206C6F6164
00:8B6C 2F696E7075740A0A
00:8B74 00
                        	  1299: 
                        	  1300: ;
                        	  1301: ;  subroutine to check we got a range for certain actions
                        	  1302: ;
                        	  1303: editor_argument_check:
00:8B75 A000            	  1304:   ldy #0
                        	  1305: ;
                        	  1306: ;  skip spaces to make sure we got a range
                        	  1307: ;
                        	  1308: editor_argument_check_loop:
00:8B77 B18E            	  1309:   lda (token_start),y
00:8B79 F00C            	  1310:   beq editor_argument_check_failed
00:8B7B C90A            	  1311:   cmp #NL
00:8B7D F008            	  1312:   beq editor_argument_check_failed
00:8B7F 204A81          	  1313:   jsr isspace
00:8B82 900D            	  1314:   bcc editor_argument_check_got_argument
00:8B84 C8              	  1315:   iny
00:8B85 D0F0            	  1316:   bne editor_argument_check_loop
                        	  1317: 
                        	  1318: ;
                        	  1319: ;  only found spaces, not good enough
                        	  1320: ;
                        	  1321: editor_argument_check_failed:
00:8B87 A91E            	  1322:   lda #<editor_no_lines
00:8B89 A28B            	  1323:   ldx #>editor_no_lines
00:8B8B 202682          	  1324:   jsr print
00:8B8E 4C7282          	  1325:   jmp  main_prompt
                        	  1326: 
                        	  1327: editor_argument_check_got_argument:
00:8B91 60              	  1328:   rts
                        	  1329: 
                        	  1330: 
                        	  1331: ;--------------------------------------------
                        	  1332: ;  DELETE
                        	  1333: ;--------------------------------------------
                        	  1334: editor_delete:
                        	  1335: ;
                        	  1336: ;  default to no lines
                        	  1337: ;
00:8B92 649E            	  1338:   stz from_line
00:8B94 649F            	  1339:   stz from_line+1
00:8B96 64A0            	  1340:   stz to_line
00:8B98 64A1            	  1341:   stz to_line+1
                        	  1342: 
00:8B9A 64B9            	  1343:   stz find_count      ; delete count in this case
00:8B9C 64BA            	  1344:   stz find_count+1
00:8B9E 20758B          	  1345:   jsr editor_argument_check ; cannot get away with no arguments
                        	  1346: 
00:8BA1 204B86          	  1347:   jsr editor_get_range
00:8BA4 202E86          	  1348:   jsr editor_check_no_more
                        	  1349: 
00:8BA7 A59E            	  1350:   lda from_line
00:8BA9 85AC            	  1351:   sta this_line
00:8BAB A59F            	  1352:   lda from_line+1
00:8BAD 85AD            	  1353:   sta this_line+1
00:8BAF 20738C          	  1354:   jsr find_line       ; find the "from" line address
00:8BB2 A5AE            	  1355:   lda this_line_addr  ; that becomes the destination of the move
00:8BB4 85A8            	  1356:   sta mem_move_dest
00:8BB6 A5AF            	  1357:   lda this_line_addr+1
00:8BB8 85A9            	  1358:   sta mem_move_dest+1
00:8BBA 64AA            	  1359:   stz mem_move_len
00:8BBC 64AB            	  1360:   stz mem_move_len+1
                        	  1361: ;
                        	  1362: ;  now we'll work our way up until we get to the to_line, however we'll
                        	  1363: ;  add one because we want the final address to actually be the start of
                        	  1364: ;  the NEXT line
                        	  1365: ;
00:8BBE 18              	  1366:   clc
00:8BBF A5A0            	  1367:   lda to_line
00:8BC1 6901            	  1368:   adc #1
00:8BC3 85AC            	  1369:   sta this_line
00:8BC5 A5A1            	  1370:   lda to_line+1
00:8BC7 6900            	  1371:   adc #0
00:8BC9 85AD            	  1372:   sta this_line+1
00:8BCB 20818C          	  1373:   jsr find_line_loop    ; find the "to" line address
00:8BCE A5AE            	  1374:   lda this_line_addr  ; that becomes the destination of the move
00:8BD0 85A6            	  1375:   sta mem_move_src
00:8BD2 A5AF            	  1376:   lda this_line_addr+1
00:8BD4 85A7            	  1377:   sta mem_move_src+1
                        	  1378: 
                        	  1379: ;
                        	  1380: ;  count how many lines we delete by counting newlines from
                        	  1381: ;   mem_move_dest to mem_move_src
                        	  1382: ;
                        	  1383: 
00:8BD6 A5A8            	  1384:   lda mem_move_dest
00:8BD8 8523            	  1385:   sta PCODE
00:8BDA A5A9            	  1386:   lda mem_move_dest+1
00:8BDC 8524            	  1387:   sta PCODE+1
00:8BDE A000            	  1388:   ldy #0
                        	  1389: 
                        	  1390: editor_delete_line_count_loop:
00:8BE0 A523            	  1391:   lda PCODE
00:8BE2 C5A6            	  1392:   cmp mem_move_src
00:8BE4 D006            	  1393:   bne editor_delete_line_count_not_done
00:8BE6 A524            	  1394:   lda PCODE+1
00:8BE8 C5A7            	  1395:   cmp mem_move_src+1
00:8BEA F014            	  1396:   beq editor_delete_line_count_done
                        	  1397: 
                        	  1398: editor_delete_line_count_not_done:
00:8BEC B123            	  1399:   lda (PCODE),y
00:8BEE C90A            	  1400:   cmp #NL
00:8BF0 D006            	  1401:   bne editor_delete_line_count_not_newline
00:8BF2 E6B9            	  1402:   inc find_count
00:8BF4 D002            	  1403:   bne editor_delete_line_count_not_newline
00:8BF6 E6BA            	  1404:   inc find_count+1
                        	  1405: editor_delete_line_count_not_newline:
00:8BF8 E623            	  1406:   inc PCODE
00:8BFA D0E4            	  1407:   bne editor_delete_line_count_loop
00:8BFC E624            	  1408:   inc PCODE+1
00:8BFE 80E0            	  1409:   bra editor_delete_line_count_loop
                        	  1410: 
                        	  1411: ;
                        	  1412: ;  now find where the source ends
                        	  1413: ;  PCODE will now be at the first line to not be deleted
                        	  1414: ;
                        	  1415: editor_delete_line_count_done:
                        	  1416: 
00:8C00 20AF8C          	  1417:   jsr find_source_end_loop
00:8C03 38              	  1418:   sec
00:8C04 A523            	  1419:   lda PCODE
00:8C06 E5AE            	  1420:   sbc this_line_addr
00:8C08 85AA            	  1421:   sta mem_move_len
00:8C0A A524            	  1422:   lda PCODE+1
00:8C0C E5AF            	  1423:   sbc this_line_addr+1
00:8C0E 85AB            	  1424:   sta mem_move_len+1
00:8C10 207A81          	  1425:   jsr movedown  ; that should do it
                        	  1426: 
00:8C13 A5B9            	  1427:   lda find_count
00:8C15 8500            	  1428:   sta REG
00:8C17 A5BA            	  1429:   lda find_count+1
00:8C19 8501            	  1430:   sta REG+1
00:8C1B 6402            	  1431:   stz REGB
00:8C1D 209293          	  1432:   jsr display_in_decimal
00:8C20 A92A            	  1433:   lda #<lines_deleted_message
00:8C22 A28C            	  1434:   ldx #>lines_deleted_message
00:8C24 202682          	  1435:   jsr print
00:8C27 4C7282          	  1436:   jmp main_prompt
                        	  1437: 
00:8C2A 2064656C65746564	  1438: lines_deleted_message asciiz " deleted.\n"
00:8C32 2E0A
00:8C34 00
                        	  1439: 
                        	  1440: ;--------------------------------------------
                        	  1441: ;  show current line number with leading spaces
                        	  1442: ;--------------------------------------------
                        	  1443: show_current_line_number:
00:8C35 48              	  1444:   pha
00:8C36 DA              	  1445:   phx
00:8C37 5A              	  1446:   phy
                        	  1447: ;
                        	  1448: ;  get the line number into REG ready for printing
                        	  1449: ;
00:8C38 A5A2            	  1450:   lda current_line
00:8C3A 8500            	  1451:   sta REG
00:8C3C A6A3            	  1452:   ldx current_line+1
00:8C3E 8601            	  1453:   stx REG+1
00:8C40 A000            	  1454:   ldy #0        ; count of leading spaces
00:8C42 8402            	  1455:   sty REGB
00:8C44 E003            	  1456:   cpx #>1000    ; if the number is >= 1000 don't print any spaces
00:8C46 9006            	  1457:   bcc line_number_lt_1000
00:8C48 D013            	  1458:   bne line_number_output_spaces
00:8C4A C9E8            	  1459:   cmp #<1000
00:8C4C B00F            	  1460:   bcs line_number_output_spaces
                        	  1461: line_number_lt_1000:
00:8C4E C8              	  1462:   iny           ; output one space
00:8C4F E000            	  1463:   cpx  #0       ; if line number > 255 then one space is all we need
00:8C51 D00A            	  1464:   bne  line_number_output_spaces
00:8C53 C964            	  1465:   cmp  #100     ; if line number >= 100 then one space is all we need
00:8C55 B006            	  1466:   bcs  line_number_output_spaces
00:8C57 C8              	  1467:   iny           ; output two spaces
00:8C58 C90A            	  1468:   cmp  #10      ; if line number >= 10 then two spaces are all we need
00:8C5A B001            	  1469:   bcs  line_number_output_spaces
00:8C5C C8              	  1470:   iny           ; output three spaces
                        	  1471: line_number_output_spaces:
00:8C5D C000            	  1472:   cpy #0            ; leading spaces in front of line number
00:8C5F F008            	  1473:   beq  show_current_line_number_done
00:8C61 5A              	  1474:   phy
00:8C62 20F394          	  1475:   jsr  PUTSP      ; output the space
00:8C65 7A              	  1476:   ply
00:8C66 88              	  1477:   dey             ; count them
00:8C67 D0F4            	  1478:   bne  line_number_output_spaces  ; more spaces to go
                        	  1479: show_current_line_number_done:
00:8C69 209293          	  1480:   jsr  display_in_decimal    ; now the actual number
00:8C6C 20F394          	  1481:   jsr  PUTSP      ; and a space after it
00:8C6F 7A              	  1482:   ply
00:8C70 FA              	  1483:   plx
00:8C71 68              	  1484:   pla
00:8C72 60              	  1485:   rts
                        	  1486: 
                        	  1487: ;--------------------------------------------
                        	  1488: ;  find_line
                        	  1489: ;
                        	  1490: ;  finds address of this_line in memory - returns in this_line_addr
                        	  1491: ;--------------------------------------------
                        	  1492: find_line:
00:8C73 A901            	  1493:   lda #1
00:8C75 85A2            	  1494:   sta current_line    ; current line number (1)
00:8C77 64A3            	  1495:   stz current_line+1
00:8C79 A900            	  1496:   lda #<TEXT_START   ; start at start of source
00:8C7B 85AE            	  1497:   sta this_line_addr
00:8C7D A903            	  1498:   lda #>TEXT_START
00:8C7F 85AF            	  1499:   sta this_line_addr+1
                        	  1500: find_line_loop:
00:8C81 A000            	  1501:   ldy #0
00:8C83 A5A2            	  1502:   lda current_line
00:8C85 C5AC            	  1503:   cmp this_line
00:8C87 D007            	  1504:   bne find_line_next
00:8C89 A5A3            	  1505:   lda current_line+1
00:8C8B C5AD            	  1506:   cmp this_line+1
00:8C8D D001            	  1507:   bne find_line_next
00:8C8F 60              	  1508:   rts
                        	  1509: find_line_next:
00:8C90 B1AE            	  1510:   lda (this_line_addr),Y
00:8C92 F012            	  1511:   beq find_line_eof
00:8C94 C90A            	  1512:   cmp #NL
00:8C96 D006            	  1513:   bne find_line_same_line
00:8C98 E6A2            	  1514:   inc current_line       ; add 1 to our line number counter
00:8C9A D002            	  1515:   bne find_line_same_line
00:8C9C E6A3            	  1516:   inc current_line+1
                        	  1517: find_line_same_line:
00:8C9E E6AE            	  1518:   inc this_line_addr     ; onto next address - which means that a newline
00:8CA0 D0DF            	  1519:   bne find_line_loop     ; will actually end up being the start of the new
00:8CA2 E6AF            	  1520:   inc this_line_addr+1   ; line, which is what we want
00:8CA4 80DB            	  1521:   bra find_line_loop
                        	  1522: find_line_eof:           ; we are pointing to 0x00 - make that the address
00:8CA6 60              	  1523:   rts
                        	  1524: 
                        	  1525: 
                        	  1526: 
                        	  1527: ;***********************************************
                        	  1528: ; Find text end
                        	  1529: ;***********************************************
                        	  1530: find_source_end:
00:8CA7 A900            	  1531:   lda  #<TEXT_START        ; start at start of source
00:8CA9 8523            	  1532:   sta  PCODE
00:8CAB A903            	  1533:   lda  #>TEXT_START
00:8CAD 8524            	  1534:   sta  PCODE+1
                        	  1535: find_source_end_loop =  *
00:8CAF A000            	  1536:   ldy  #0
00:8CB1 B123            	  1537:   lda  (PCODE),Y             ; keep going until 0x00 indicates end of source
00:8CB3 F008            	  1538:   beq  find_source_end_wrap
00:8CB5 E623            	  1539:   inc  PCODE
00:8CB7 D0F6            	  1540:   bne  find_source_end_loop
00:8CB9 E624            	  1541:   inc  PCODE+1
00:8CBB 80F2            	  1542:   bra  find_source_end_loop
                        	  1543: ;
                        	  1544: ;  include final 0x00
                        	  1545: ;
                        	  1546: find_source_end_wrap =  *
00:8CBD E623            	  1547:   inc  PCODE
00:8CBF D002            	  1548:   bne  find_source_end_done
00:8CC1 E624            	  1549:   inc  PCODE+1
                        	  1550: find_source_end_done =  *
00:8CC3 60              	  1551:   rts
                        	  1552: 
                        	  1553: ;
                        	  1554: ;  testing BRK handling
                        	  1555: ;
00:8CC4 0A526573756D6564	  1556: brk_resumed asciiz "\nResumed after BRK\n"
00:8CCC 2061667465722042
00:8CD4 524B0A
00:8CD7 00
                        	  1557: 
                        	  1558: editor_test:
00:8CD8 A912            	  1559:   lda #$12
00:8CDA A223            	  1560:   ldx #$23
00:8CDC A042            	  1561:   ldy #$42
00:8CDE C912            	  1562:   cmp #$12
00:8CE0 00              	  1563:   brk
00:8CE1 99              	  1564:   dfb $99   ; break number
00:8CE2 A9C4            	  1565:   lda #<brk_resumed
00:8CE4 A28C            	  1566:   ldx #>brk_resumed
00:8CE6 202682          	  1567:   jsr print
00:8CE9 60              	  1568:   rts
                        	  1569: 
                        	  1570: ;
                        	  1571: ;  memory dump
                        	  1572: ;
                        	  1573: editor_memory:
00:8CEA 20758B          	  1574:   jsr editor_argument_check  ; check they supplied some sort of range
00:8CED 202885          	  1575:   jsr editor_default_range
00:8CF0 A902            	  1576:   lda #EFLAG_ALLOW_ZERO_FROM
00:8CF2 85BC            	  1577:   sta editor_flags
00:8CF4 204B86          	  1578:   jsr editor_get_range
00:8CF7 202E86          	  1579:   jsr editor_check_no_more
00:8CFA 64A2            	  1580:   stz current_line      ; count of bytes shown
00:8CFC A59E            	  1581:   lda from_line
00:8CFE 85AE            	  1582:   sta this_line_addr
00:8D00 A59F            	  1583:   lda from_line+1
00:8D02 85AF            	  1584:   sta this_line_addr+1
                        	  1585: 
                        	  1586: editor_memory_loop:
00:8D04 A58B            	  1587:   lda serial_in_byte_received
00:8D06 C903            	  1588:   cmp  #KEY_ABORT
00:8D08 F053            	  1589:   beq  editor_memory_aborted
                        	  1590: 
00:8D0A A5A2            	  1591:   lda current_line
00:8D0C D017            	  1592:   bne editor_memory_loop1
                        	  1593: ;
                        	  1594: ;  show address
                        	  1595: ;
00:8D0E A924            	  1596:   lda #'$'
00:8D10 20F695          	  1597:   jsr COUT
00:8D13 A59F            	  1598:   lda from_line+1
00:8D15 20DD94          	  1599:   jsr PRBYTE
00:8D18 A59E            	  1600:   lda from_line
00:8D1A 20DD94          	  1601:   jsr PRBYTE
00:8D1D A93A            	  1602:   lda #':'
00:8D1F 20F695          	  1603:   jsr COUT
00:8D22 20F394          	  1604:   jsr PUTSP
                        	  1605: editor_memory_loop1:
00:8D25 A000            	  1606:   ldy #0
00:8D27 B19E            	  1607:   lda (from_line),Y
00:8D29 20DD94          	  1608:   jsr PRBYTE
00:8D2C 20F394          	  1609:   jsr PUTSP
00:8D2F E6A2            	  1610:   inc current_line
00:8D31 E69E            	  1611:   inc from_line
00:8D33 D002            	  1612:   bne editor_memory_loop2
00:8D35 E69F            	  1613:   inc from_line+1
                        	  1614: editor_memory_loop2:
                        	  1615: ;
                        	  1616: ;  if we wrap around back to zero, stop
                        	  1617: ;
00:8D37 A59E            	  1618:   lda from_line
00:8D39 059F            	  1619:   ora from_line+1
00:8D3B F01D            	  1620:   beq editor_memory_done
00:8D3D A59F            	  1621:   lda from_line+1
00:8D3F C5A1            	  1622:   cmp to_line+1
00:8D41 900A            	  1623:   bcc editor_memory_loop3   ; less than
00:8D43 D015            	  1624:   bne editor_memory_done    ; greater than
00:8D45 A59E            	  1625:   lda from_line             ; equal, so try low-order byte
00:8D47 C5A0            	  1626:   cmp to_line
00:8D49 9002            	  1627:   bcc editor_memory_loop3   ; less than
00:8D4B D00D            	  1628:   bne editor_memory_done    ; greater than
                        	  1629: editor_memory_loop3:
00:8D4D A5A2            	  1630:   lda current_line
00:8D4F C910            	  1631:   cmp #16
00:8D51 90B1            	  1632:   bcc editor_memory_loop
00:8D53 20638D          	  1633:   jsr editor_memory_show_ascii
00:8D56 64A2            	  1634:   stz current_line      ; count of bytes shown
00:8D58 80AA            	  1635:   bra editor_memory_loop
                        	  1636: 
                        	  1637: editor_memory_done:
00:8D5A 20638D          	  1638:   jsr editor_memory_show_ascii
                        	  1639: editor_memory_aborted:
00:8D5D 206894          	  1640:   jsr CROUT
00:8D60 4C7282          	  1641:   jmp  main_prompt
                        	  1642: 
                        	  1643: editor_memory_show_ascii:
                        	  1644: ;
                        	  1645: ;  now the ASCII equivalents
                        	  1646: ;
00:8D63 20F394          	  1647:   jsr PUTSP
00:8D66 A000            	  1648:   ldy #0
                        	  1649: editor_memory_ascii:
00:8D68 B1AE            	  1650:   lda (this_line_addr),Y
00:8D6A C920            	  1651:   cmp #$20
00:8D6C B002            	  1652:   bcs editor_memory_not_control
00:8D6E 8004            	  1653:   bra editor_memory_show_dot
                        	  1654: editor_memory_not_control:
00:8D70 C97F            	  1655:   cmp #$7F
00:8D72 9002            	  1656:   bcc editor_memory_not_high
                        	  1657: editor_memory_show_dot
00:8D74 A92E            	  1658:   lda #'.'
                        	  1659: editor_memory_not_high:
00:8D76 20F695          	  1660:   jsr COUT
00:8D79 20F394          	  1661:   jsr PUTSP
00:8D7C C8              	  1662:   iny
00:8D7D C6A2            	  1663:   dec current_line
00:8D7F D0E7            	  1664:   bne editor_memory_ascii
                        	  1665: ;
                        	  1666: ;  adjust the ASCII printing address
                        	  1667: ;
00:8D81 A59E            	  1668:   lda from_line
00:8D83 85AE            	  1669:   sta this_line_addr
00:8D85 A59F            	  1670:   lda from_line+1
00:8D87 85AF            	  1671:   sta this_line_addr+1
                        	  1672: 
00:8D89 206894          	  1673:   jsr CROUT
00:8D8C 60              	  1674:   rts
                        	  1675: 
                        	  1676: 
                        	  1677: 
                        	  1678: 
00:8D8D 4164647220507265	  1679: symbol_table_message asciiz "Addr Prev L  T Dsp  Ar Da Ln Name\n"
00:8D95 76204C2020542044
00:8D9D 7370202041722044
00:8DA5 61204C6E204E616D
00:8DAD 650A
00:8DAF 00
                        	  1680: 
                        	  1681: editor_symbol_table_list  = *
00:8DB0 A98D            	  1682:   lda #<symbol_table_message
00:8DB2 A28D            	  1683:   ldx #>symbol_table_message
00:8DB4 202682          	  1684:   jsr print
                        	  1685: 
00:8DB7 A532            	  1686:   lda  ENDSYM+1    ; get the end of the symbol table
00:8DB9 8541            	  1687:   sta  SYMITM+1    ; make it the current symbol
00:8DBB A531            	  1688:   lda  ENDSYM
00:8DBD 800B            	  1689:   bra  ST_SYMTBL_LIST_CHECK
                        	  1690: 
                        	  1691: ST_SYMTBL_LIST_NEXT =  *
00:8DBF A000            	  1692:   ldy  #SYMPRV
00:8DC1 B140            	  1693:   lda  (SYMITM),Y
00:8DC3 AA              	  1694:   tax
00:8DC4 C8              	  1695:   iny
00:8DC5 B140            	  1696:   lda  (SYMITM),Y
00:8DC7 8541            	  1697:   sta  SYMITM+1   ; previous link
00:8DC9 8A              	  1698:   txa
                        	  1699: ;
                        	  1700: ;  go to the previous symbol table item
                        	  1701: ;
                        	  1702: ST_SYMTBL_LIST_CHECK     =  *
00:8DCA 8540            	  1703:   sta  SYMITM
00:8DCC C9FF            	  1704:   cmp  #<SYMBOL_TABLE_START
00:8DCE D009            	  1705:   bne  ST_SYMTBL_LIST_LINE
00:8DD0 A541            	  1706:   lda  SYMITM+1
00:8DD2 C93F            	  1707:   cmp  #>SYMBOL_TABLE_START
00:8DD4 D003            	  1708:   bne  ST_SYMTBL_LIST_LINE       ; more to go
00:8DD6 4C5F8E          	  1709:   jmp  ST_SYMTBL_LIST_DONE       ; finished if symitm and symitm+1 are both zero
                        	  1710: 
                        	  1711: ST_SYMTBL_LIST_LINE = *
00:8DD9 A541            	  1712:   lda  SYMITM+1
00:8DDB 20DD94          	  1713:   jsr  PRBYTE
00:8DDE A540            	  1714:   lda  SYMITM
00:8DE0 20DD94          	  1715:   jsr  PRBYTE
00:8DE3 A920            	  1716:   lda  #' '
00:8DE5 20C594          	  1717:   jsr  PRCHAR
00:8DE8 A001            	  1718:   ldy  #SYMPRV+1
00:8DEA B140            	  1719:   lda  (SYMITM),Y
00:8DEC 20DD94          	  1720:   jsr  PRBYTE
00:8DEF 88              	  1721:   dey
00:8DF0 B140            	  1722:   lda  (SYMITM),Y
00:8DF2 20DD94          	  1723:   jsr  PRBYTE
00:8DF5 A920            	  1724:   lda  #' '
00:8DF7 20C594          	  1725:   jsr  PRCHAR
00:8DFA A002            	  1726:   ldy  #SYMLVL
00:8DFC B140            	  1727:   lda  (SYMITM),Y  ; level
00:8DFE 20DD94          	  1728:   jsr  PRBYTE
00:8E01 A920            	  1729:   lda  #' '
00:8E03 20C594          	  1730:   jsr  PRCHAR
00:8E06 A003            	  1731:   ldy  #SYMTYP
00:8E08 B140            	  1732:   lda  (SYMITM),Y  ; type
00:8E0A 20C594          	  1733:   jsr  PRCHAR
00:8E0D A920            	  1734:   lda  #' '
00:8E0F 20C594          	  1735:   jsr  PRCHAR
00:8E12 A004            	  1736:   ldy  #SYMDSP
00:8E14 C8              	  1737:   iny
00:8E15 B140            	  1738:   lda  (SYMITM),Y  ; displacement
00:8E17 20DD94          	  1739:   jsr  PRBYTE
00:8E1A 88              	  1740:   dey
00:8E1B B140            	  1741:   lda  (SYMITM),Y  ; displacement
00:8E1D 20DD94          	  1742:   jsr  PRBYTE
00:8E20 A920            	  1743:   lda  #' '
00:8E22 20C594          	  1744:   jsr  PRCHAR
00:8E25 A006            	  1745:   ldy  #SYMARG
00:8E27 B140            	  1746:   lda  (SYMITM),Y  ; argument count
00:8E29 20DD94          	  1747:   jsr  PRBYTE
00:8E2C A920            	  1748:   lda  #' '
00:8E2E 20C594          	  1749:   jsr  PRCHAR
00:8E31 A008            	  1750:   ldy  #SYMDAT
00:8E33 B140            	  1751:   lda  (SYMITM),Y  ; data type
00:8E35 20DD94          	  1752:   jsr  PRBYTE
00:8E38 A920            	  1753:   lda  #' '
00:8E3A 20C594          	  1754:   jsr  PRCHAR
00:8E3D A009            	  1755:   ldy  #SYMLEN
00:8E3F B140            	  1756:   lda  (SYMITM),Y  ; length
00:8E41 48              	  1757:   pha
00:8E42 20DD94          	  1758:   jsr  PRBYTE
00:8E45 A920            	  1759:   lda  #' '
00:8E47 20C594          	  1760:   jsr  PRCHAR
00:8E4A A00A            	  1761:   ldy  #SYMNAM
00:8E4C 68              	  1762:   pla
00:8E4D AA              	  1763:   tax
                        	  1764: ST_SYMTBL_LIST_NAME = *
00:8E4E B140            	  1765:   lda  (SYMITM),Y  ; name
00:8E50 5A              	  1766:   phy
00:8E51 20C594          	  1767:   jsr  PRCHAR
00:8E54 7A              	  1768:   ply
00:8E55 C8              	  1769:   iny
00:8E56 CA              	  1770:   dex
00:8E57 D0F5            	  1771:   bne ST_SYMTBL_LIST_NAME
00:8E59 206894          	  1772:   jsr CROUT
00:8E5C 4CBF8D          	  1773:   jmp ST_SYMTBL_LIST_NEXT
                        	  1774: 
                        	  1775: ST_SYMTBL_LIST_DONE = *
                        	  1776: 
00:8E5F 4C7282          	  1777:   jmp main_prompt
                        	  1778: 
                        	  1779: 
00:8E62 446F6E650A      	  1780: recover_done asciiz "Done\n"
00:8E67 00
00:8E68 4E6F74206E656564	  1781: recover_not_needed asciiz "Not needed\n"
00:8E70 65640A
00:8E73 00
                        	  1782: 
                        	  1783: ;
                        	  1784: ; Recover: if the first byte of the source is 0x00, change it to a space
                        	  1785: ;
                        	  1786: editor_recover:
00:8E74 202E86          	  1787:   jsr editor_check_no_more
00:8E77 A900            	  1788:   lda  #<TEXT_START
00:8E79 8540            	  1789:   sta  FROM
00:8E7B A903            	  1790:   lda  #>TEXT_START
00:8E7D 8541            	  1791:   sta  FROM+1
00:8E7F A000            	  1792:   ldy  #0
00:8E81 B140            	  1793:   lda  (FROM),Y
00:8E83 D00E            	  1794:   bne  editor_recover_not_needed
00:8E85 A920            	  1795:   lda  #' '
00:8E87 9140            	  1796:   sta  (FROM),Y
                        	  1797: editor_done_message:
00:8E89 A962            	  1798:   lda #<recover_done
00:8E8B A28E            	  1799:   ldx #>recover_done
00:8E8D 202682          	  1800:   jsr print
00:8E90 4C7282          	  1801:   jmp main_prompt
                        	  1802: 
                        	  1803: editor_recover_not_needed:
00:8E93 A968            	  1804:   lda #<recover_not_needed
00:8E95 A28E            	  1805:   ldx #>recover_not_needed
00:8E97 202682          	  1806:   jsr print
00:8E9A 4C7282          	  1807:   jmp main_prompt
                        	  1808: 
00:8E9D 43616E6E6F742074	  1809: not_assembler_message asciiz "Cannot trace or debug assembler code\n"
00:8EA5 72616365206F7220
00:8EAD 6465627567206173
00:8EB5 73656D626C657220
00:8EBD 636F64650A
00:8EC2 00
                        	  1810: 
                        	  1811: editor_debug:
00:8EC3 202E86          	  1812:   jsr editor_check_no_more
00:8EC6 A910            	  1813:   lda  #FLAG_VALID_ASSEMBLE
00:8EC8 25BE            	  1814:   and  system_flags
00:8ECA F00A            	  1815:   beq editor_debug_ok
                        	  1816: 
                        	  1817: editor_not_assembler:
00:8ECC A99D            	  1818:   lda #<not_assembler_message
00:8ECE A28E            	  1819:   ldx #>not_assembler_message
00:8ED0 202682          	  1820:   jsr print
00:8ED3 4C7282          	  1821:   jmp main_prompt
                        	  1822: 
                        	  1823: editor_debug_ok:
00:8ED6 A901            	  1824:   lda #1
00:8ED8 8549            	  1825:   sta  DBGFLG
00:8EDA 852E            	  1826:   sta  DCODE
00:8EDC 4CAB95          	  1827:   jmp  CHK_RUN
                        	  1828: 
                        	  1829: editor_trace:
00:8EDF 202E86          	  1830:   jsr editor_check_no_more
00:8EE2 A910            	  1831:   lda  #FLAG_VALID_ASSEMBLE
00:8EE4 25BE            	  1832:   and  system_flags
00:8EE6 D0E4            	  1833:   bne  editor_not_assembler
00:8EE8 A980            	  1834:   lda  #$80
00:8EEA 8549            	  1835:   sta  DBGFLG
00:8EEC 852E            	  1836:   sta  DCODE
00:8EEE 4CAB95          	  1837:   jmp  CHK_RUN
                        	  1838: 
                        	  1839: 
                        	  1840: editor_info  = *
00:8EF1 202E86          	  1841:   jsr editor_check_no_more
00:8EF4 20708F          	  1842:   jsr show_source_start
00:8EF7 20488F          	  1843:   jsr show_source_end
00:8EFA 20928F          	  1844:   jsr show_source_lines
00:8EFD 20C392          	  1845:   jsr crc_source
00:8F00 4C7282          	  1846:   jmp main_prompt
                        	  1847: 
                        	  1848: editor_compile:
00:8F03 202E86          	  1849:   jsr editor_check_no_more
00:8F06 A900            	  1850:   lda  #0
00:8F08 8542            	  1851:   sta  SYNTAX
00:8F0A 4C8ABC          	  1852:   jmp  COMPIL
                        	  1853: 
                        	  1854: editor_syntax:
00:8F0D 202E86          	  1855:   jsr editor_check_no_more
00:8F10 A901            	  1856:   lda #1
00:8F12 8542            	  1857:   sta  SYNTAX
00:8F14 4C8ABC          	  1858:   jmp  COMPIL
                        	  1859: 
                        	  1860: editor_run:
00:8F17 202E86          	  1861:   jsr editor_check_no_more
00:8F1A A900            	  1862:   lda  #0
00:8F1C 8549            	  1863:   sta  DBGFLG
00:8F1E 852E            	  1864:   sta  DCODE
00:8F20 4CAB95          	  1865:   jmp  CHK_RUN
                        	  1866: 
                        	  1867:   ;
                        	  1868: show_symbol_table_end:
00:8F23 A950            	  1869:   lda  #<symbol_table_ended_message    ; Symbol table ended at
00:8F25 A295            	  1870:   ldx  #>symbol_table_ended_message
00:8F27 202682          	  1871:   jsr  print
00:8F2A A532            	  1872:   lda  ENDSYM+1
00:8F2C 20DD94          	  1873:   jsr  PRBYTE
00:8F2F A531            	  1874:   lda  ENDSYM
00:8F31 209295          	  1875:   jsr  PRBYTECR
00:8F34 60              	  1876:   rts
                        	  1877: 
                        	  1878: 
00:8F35 536F757263652065	  1879: source_ended_message asciiz "Source ends   at $"
00:8F3D 6E64732020206174
00:8F45 2024
00:8F47 00
                        	  1880: show_source_end:
00:8F48 A935            	  1881:   lda #<source_ended_message
00:8F4A A28F            	  1882:   ldx #>source_ended_message
00:8F4C 202682          	  1883:   jsr print
00:8F4F 20A78C          	  1884:   jsr find_source_end
00:8F52 A524            	  1885:   lda PCODE+1
00:8F54 20DD94          	  1886:   jsr PRBYTE
00:8F57 A523            	  1887:   lda PCODE
00:8F59 209295          	  1888:   jsr PRBYTECR
00:8F5C 60              	  1889:   rts
                        	  1890: 
00:8F5D 536F757263652073	  1891: source_starts_message asciiz "Source starts at $"    ; source starts at
00:8F65 7461727473206174
00:8F6D 2024
00:8F6F 00
                        	  1892: show_source_start:
00:8F70 A95D            	  1893:   lda #<source_starts_message
00:8F72 A28F            	  1894:   ldx #>source_starts_message
00:8F74 202682          	  1895:   jsr print
00:8F77 A903            	  1896:   lda #>TEXT_START
00:8F79 20DD94          	  1897:   jsr PRBYTE
00:8F7C A900            	  1898:   lda #<TEXT_START
00:8F7E 209295          	  1899:   jsr PRBYTECR
00:8F81 60              	  1900:   rts
                        	  1901: 
                        	  1902: ;--------------------------------------------
                        	  1903: ;  show_source_lines - show count of number of source lines
                        	  1904: ;--------------------------------------------
00:8F82 536F75726365206C	  1905: source_line_count asciiz "Source lines:  "    ; count of lines
00:8F8A 696E65733A2020
00:8F91 00
                        	  1906: show_source_lines:
00:8F92 6400            	  1907:   stz VALUE      ; line count in this case
00:8F94 6401            	  1908:   stz VALUE+1
00:8F96 6402            	  1909:   stz VALUE+2
                        	  1910: 
00:8F98 A900            	  1911:   lda #<TEXT_START
00:8F9A 8523            	  1912:   sta PCODE
00:8F9C A903            	  1913:   lda #>TEXT_START
00:8F9E 8524            	  1914:   sta PCODE+1
00:8FA0 A000            	  1915:   ldy #0
                        	  1916: 
                        	  1917: editor_line_count_loop:
00:8FA2 B123            	  1918:   lda (PCODE),y
00:8FA4 F012            	  1919:   beq editor_line_count_done    ; 0x00 means end of source
00:8FA6 C90A            	  1920:   cmp #NL                       ; newline?
00:8FA8 D006            	  1921:   bne editor_line_count_not_newline
00:8FAA E600            	  1922:   inc VALUE
00:8FAC D002            	  1923:   bne editor_line_count_not_newline
00:8FAE E601            	  1924:   inc VALUE+1
                        	  1925: ;
                        	  1926: ;  increment pointer
                        	  1927: ;
                        	  1928: editor_line_count_not_newline:
00:8FB0 E623            	  1929:   inc PCODE
00:8FB2 D0EE            	  1930:   bne editor_line_count_loop
00:8FB4 E624            	  1931:   inc PCODE+1
00:8FB6 80EA            	  1932:   bra editor_line_count_loop
                        	  1933: 
                        	  1934: editor_line_count_done:
00:8FB8 A982            	  1935:   lda #<source_line_count
00:8FBA A28F            	  1936:   ldx #>source_line_count
00:8FBC 202682          	  1937:   jsr print
00:8FBF 209293          	  1938:   jsr display_in_decimal
00:8FC2 206894          	  1939:   jsr CROUT
00:8FC5 60              	  1940:   rts
                        	  1941: 
                        	  1942: editor_assemble:
00:8FC6 202E86          	  1943:   jsr editor_check_no_more
00:8FC9 4C899A          	  1944:   jmp ASSEMBLE
                        	  1945: 
00:8FCC 4E6F2042524B2070	  1946: no_break_message asciiz "No BRK previously encountered\n"
00:8FD4 726576696F75736C
00:8FDC 7920656E636F756E
00:8FE4 74657265640A
00:8FEA 00
                        	  1947: 
                        	  1948: ;--------------------------------------------
                        	  1949: ;  editor_resume - resume after a breakpoint
                        	  1950: ;--------------------------------------------
                        	  1951: editor_resume:
00:8FEB 209895          	  1952:   jsr CHK_VAL     ; check we had a valid compile/assemble
00:8FEE A5BE            	  1953:   lda system_flags
00:8FF0 2980            	  1954:   and #FLAG_BRK_REACHED    ; BRK reached yet?
00:8FF2 D00A            	  1955:   bne editor_resume_ok
00:8FF4 A9CC            	  1956:   lda #<no_break_message
00:8FF6 A28F            	  1957:   ldx #>no_break_message
00:8FF8 202682          	  1958:   jsr print
00:8FFB 4C7282          	  1959:   jmp main_prompt
                        	  1960: editor_resume_ok:
00:8FFE A980            	  1961:   lda #FLAG_BRK_REACHED    ; no BRK reached yet
00:9000 14BE            	  1962:   trb system_flags
                        	  1963: ;
                        	  1964: ;  put the stack back to what it was and push the
                        	  1965: ;   processor flags and breakpoint address
                        	  1966: ;
00:9002 18              	  1967:   clc
00:9003 A514            	  1968:   lda call_s
00:9005 6905            	  1969:   adc #5      ; undo effect of pushing X and Y, and the 3 pushes the processor did
00:9007 AA              	  1970:   tax
00:9008 9A              	  1971:   txs         ; switch back to what the stack pointer was
00:9009 A516            	  1972:   lda brk_address+1   ; put stuff back ready for rti
00:900B 48              	  1973:   pha
00:900C A515            	  1974:   lda brk_address
00:900E 48              	  1975:   pha
00:900F A513            	  1976:   lda call_p
00:9011 48              	  1977:   pha         ; processor flags
00:9012 A510            	  1978:   lda call_a  ; get registers back
00:9014 A412            	  1979:   ldy call_y
00:9016 A611            	  1980:   ldx call_x
00:9018 40              	  1981:   rti
                        	  1982: 
                        	  1983: 
00:9019 4E65656420616E20	  1984: editor_poke_message asciiz "Need an address and at least one value\n"
00:9021 6164647265737320
00:9029 616E64206174206C
00:9031 65617374206F6E65
00:9039 2076616C75650A
00:9040 00
                        	  1985: 
                        	  1986: ;--------------------------------------------
                        	  1987: ;  editor_poke - put stuff into memory
                        	  1988: ;--------------------------------------------
                        	  1989: editor_poke:
                        	  1990: ;
                        	  1991: ;  first check how many numbers are on the input line
                        	  1992: ;
00:9041 64B9            	  1993:   stz find_count
00:9043 A58E            	  1994:   lda token_start
00:9045 859E            	  1995:   sta from_line
00:9047 A58F            	  1996:   lda token_start+1
00:9049 859F            	  1997:   sta from_line+1
                        	  1998: 
                        	  1999: editor_poke_loop:
00:904B 20D3CB          	  2000:   jsr get_token
00:904E F02D            	  2001:   beq editor_poke_got_all_numbers
00:9050 C94E            	  2002:   cmp #TOKEN_NUMBER
00:9052 F011            	  2003:   beq editor_poke_got_number
00:9054 C922            	  2004:   cmp #TOKEN_STRING           ; a one-byte string is OK, eg. poke $1000 'a'
00:9056 D00A            	  2005:   bne editor_poke_bad_token
00:9058 A5B9            	  2006:   lda find_count
00:905A F006            	  2007:   beq editor_poke_bad_token   ; however not for the address
00:905C A592            	  2008:   lda token_length
00:905E C901            	  2009:   cmp #1
00:9060 F003            	  2010:   beq editor_poke_got_number
                        	  2011: ;
                        	  2012: ;  here when we got neither a number or a single-byte string
                        	  2013: ;
                        	  2014: editor_poke_bad_token:
00:9062 4C4685          	  2015:   jmp editor_bad_number
                        	  2016: editor_poke_got_number:
00:9065 E6B9            	  2017:   inc find_count
00:9067 A5B9            	  2018:   lda find_count
00:9069 C901            	  2019:   cmp #1
00:906B D007            	  2020:   bne editor_poke_not_first
                        	  2021: ;
                        	  2022: ;  here for first number - must be in range 0x0000 to 0xffff
                        	  2023: ;
00:906D A596            	  2024:   lda token_value+2
00:906F F0DA            	  2025:   beq editor_poke_loop
00:9071 4CE885          	  2026:   jmp editor_line_number_too_big
                        	  2027: editor_poke_not_first:
                        	  2028: ;
                        	  2029: ;  here for subsequent numbers - must be in range 0x00 to 0xff
                        	  2030: ;
00:9074 A595            	  2031:   lda token_value+1
00:9076 0596            	  2032:   ora token_value+2
00:9078 F0D1            	  2033:   beq editor_poke_loop
00:907A 4CE885          	  2034:   jmp editor_line_number_too_big
                        	  2035: 
                        	  2036: ;
                        	  2037: ;  must have at least two numbers
                        	  2038: ;
                        	  2039: editor_poke_got_all_numbers:
00:907D A5B9            	  2040:   lda find_count
00:907F C902            	  2041:   cmp #2
00:9081 B00A            	  2042:   bcs editor_poke_got_enough
00:9083 A919            	  2043:   lda #<editor_poke_message
00:9085 A290            	  2044:   ldx #>editor_poke_message
00:9087 202682          	  2045:   jsr print
00:908A 4C7282          	  2046:   jmp main_prompt
                        	  2047: 
                        	  2048: editor_poke_got_enough:
                        	  2049: ;
                        	  2050: ;  reset for get_token to do its stuff again
                        	  2051: ;
00:908D A59E            	  2052:   lda from_line
00:908F 858E            	  2053:   sta token_start
00:9091 A59F            	  2054:   lda from_line+1
00:9093 858F            	  2055:   sta token_start+1
                        	  2056: ;
                        	  2057: ;  get address again - we know it is valid since we checked above
                        	  2058: ;
00:9095 20D3CB          	  2059:   jsr get_token
                        	  2060: ;
                        	  2061: ;  where to put stuff
                        	  2062: ;
00:9098 A594            	  2063:   lda token_value
00:909A 859E            	  2064:   sta from_line
00:909C A595            	  2065:   lda token_value+1
00:909E 859F            	  2066:   sta from_line+1
                        	  2067: 
                        	  2068: editor_poking_loop:
00:90A0 20D3CB          	  2069:   jsr get_token
00:90A3 D003            	  2070:   bne editor_poke_another
00:90A5 4C898E          	  2071:   jmp editor_done_message
                        	  2072: 
                        	  2073: editor_poke_another:
00:90A8 A000            	  2074:   ldy #0
00:90AA A594            	  2075:   lda token_value
00:90AC 919E            	  2076:   sta (from_line),y
                        	  2077: ;
                        	  2078: ;  check change was successful - if not, probably trying to change ROM
                        	  2079: ;
00:90AE D19E            	  2080:   cmp (from_line),y
00:90B0 D029            	  2081:   bne editor_poke_failed
00:90B2 E69E            	  2082:   inc from_line
00:90B4 D0EA            	  2083:   bne editor_poking_loop
00:90B6 E69F            	  2084:   inc from_line+1
00:90B8 80E6            	  2085:   bra editor_poking_loop
                        	  2086: 
00:90BA 4661696C65642074	  2087: editor_poke_failed_message asciiz "Failed to change address $"
00:90C2 6F206368616E6765
00:90CA 2061646472657373
00:90D2 2024
00:90D4 00
00:90D5 20746F2024      	  2088: editor_poke_to_message     asciiz " to $"
00:90DA 00
                        	  2089: 
                        	  2090: editor_poke_failed:
00:90DB A9BA            	  2091:   lda #<editor_poke_failed_message
00:90DD A290            	  2092:   ldx #>editor_poke_failed_message
00:90DF 202682          	  2093:   jsr print
00:90E2 A59F            	  2094:   lda from_line+1
00:90E4 20DD94          	  2095:   jsr PRBYTE
00:90E7 A59E            	  2096:   lda from_line
00:90E9 20DD94          	  2097:   jsr PRBYTE
00:90EC A9D5            	  2098:   lda #<editor_poke_to_message
00:90EE A290            	  2099:   ldx #>editor_poke_to_message
00:90F0 202682          	  2100:   jsr print
00:90F3 A594            	  2101:   lda token_value
00:90F5 20DD94          	  2102:   jsr PRBYTE
00:90F8 206894          	  2103:   jsr CROUT
00:90FB 4C7282          	  2104:   jmp main_prompt
                        	  2105: 
                        	  2106: ;--------------------------------------------
                        	  2107: ;  editor_jsr - jump to subroutine
                        	  2108: ;--------------------------------------------
                        	  2109: editor_jsr:
00:90FE 20D3CB          	  2110:   jsr get_token
00:9101 C94E            	  2111:   cmp #TOKEN_NUMBER
00:9103 F003            	  2112:   beq editor_jsr_got_number
00:9105 4C4685          	  2113:   jmp editor_bad_number
                        	  2114: ;
                        	  2115: ;  check in range 0x0000 to 0xFFFF
                        	  2116: ;
                        	  2117: editor_jsr_got_number:
00:9108 A596            	  2118:   lda token_value+2
00:910A F003            	  2119:   beq editor_jsr_number_in_range
00:910C 4CE885          	  2120:   jmp editor_line_number_too_big
                        	  2121: 
                        	  2122: editor_jsr_number_in_range:
00:910F A513            	  2123:   lda  call_p      ; status register
00:9111 48              	  2124:   pha
00:9112 A510            	  2125:   lda  call_a      ; A register
00:9114 A611            	  2126:   ldx  call_x      ; X register
00:9116 A412            	  2127:   ldy  call_y      ; Y register
00:9118 28              	  2128:   plp              ; get status register back
00:9119 202991          	  2129:   jsr  editor_jsr_got_number_execute  ; call the subroutine
00:911C 08              	  2130:   php              ; save the status register
00:911D 8510            	  2131:   sta  call_a      ; store the A/X/Y register
00:911F 8611            	  2132:   stx  call_x
00:9121 8412            	  2133:   sty  call_y
00:9123 68              	  2134:   pla              ; get status register back
00:9124 8513            	  2135:   sta  call_p      ; save it
00:9126 4C7282          	  2136:   jmp main_prompt
                        	  2137: 
00:9129 6C9400          	  2138: editor_jsr_got_number_execute  jmp  (token_value)
                        	  2139: 
                        	  2140: 
                        	  2141: ;--------------------------------------------
                        	  2142: ;  editor_jmp - jump to address
                        	  2143: ;--------------------------------------------
                        	  2144: editor_jmp:
00:912C 20D3CB          	  2145:   jsr get_token
00:912F C94E            	  2146:   cmp #TOKEN_NUMBER
00:9131 F003            	  2147:   beq editor_jmp_got_number
00:9133 4C4685          	  2148:   jmp editor_bad_number
                        	  2149: ;
                        	  2150: ;  check in range 0x0000 to 0xFFFF
                        	  2151: ;
                        	  2152: editor_jmp_got_number:
00:9136 A596            	  2153:   lda token_value+2
00:9138 F003            	  2154:   beq editor_jmp_number_in_range
00:913A 4CE885          	  2155:   jmp editor_line_number_too_big
                        	  2156: 
                        	  2157: editor_jmp_number_in_range:
00:913D A513            	  2158:   lda  call_p      ; status register
00:913F 48              	  2159:   pha
00:9140 A510            	  2160:   lda  call_a      ; A register
00:9142 A611            	  2161:   ldx  call_x      ; X register
00:9144 A412            	  2162:   ldy  call_y      ; Y register
00:9146 28              	  2163:   plp              ; get status register back
00:9147 6C9400          	  2164:   jmp  (token_value)
                        	  2165: 
                        	  2166: 
                        	  2167: ;16-bit number comparison...
                        	  2168: ;
                        	  2169: ;         lda #>x               ; MSB of 1st number
                        	  2170: ;         cmp #>y               ; MSB of 2nd number
                        	  2171: ;         bcc islower           ; X < Y
                        	  2172: ;
                        	  2173: ;         bne ishigher          ; X > Y
                        	  2174: ;
                        	  2175: ;         lda #<x               ; LSB of 1st number
                        	  2176: ;         cmp #<y               ; LSB of 2nd number
                        	  2177: ;         bcc islower           ; X < Y
                        	  2178: ;
                        	  2179: ;         beq issame            ; X = Y
                        	  2180: ;
                        	  2181: ;         bne ishigher          ; X > Y
                        	  2182: ;
                        	  2183: ;
                        	  2184: 

Source: "gpascal.asm"
                        	   179:   .include "utilities.inc"

Source: "utilities.inc"
                        	     1: ;
                        	     2: ;  function to look up a handler for a word (eg. assembler directive)
                        	     3: ;
                        	     4: ;  word in SRCE
                        	     5: ;
                        	     6: ;  table of words/handlers in DEST
                        	     7: ;
                        	     8: ;  length of word in A
                        	     9: ;
                        	    10: ;  see makeHandler for making the table
                        	    11: ;
                        	    12: ;  Basically:
                        	    13: ;    asciiz "foo"
                        	    14: ;    word   foo_handler
                        	    15: ;
                        	    16: ;  In other words:
                        	    17: ;    makeHandler "foo",foo_handler
                        	    18: ;
                        	    19: ;  Returns with carry set if no match, otherwise calls the handler which should clear carry
                        	    20: ;
                        	    21: 
                        	    22: handlerLookup:
00:914A 8598            	    23:   sta token_work    ; save length
                        	    24: 
                        	    25: ;
                        	    26: ;  find the length of the word
                        	    27: ;
                        	    28: handler_loop:
00:914C A000            	    29:   ldy #0
00:914E B103            	    30:   lda (DEST),y
00:9150 F036            	    31:   beq handlers_done
                        	    32: handler_find_length:
00:9152 B103            	    33:   lda (DEST),y
00:9154 F005            	    34:   beq handler_found_length
00:9156 C8              	    35:   iny
00:9157 F02F            	    36:   beq handlers_done   ; sanity clause
00:9159 80F7            	    37:   bra handler_find_length
                        	    38: handler_found_length:
                        	    39: 
                        	    40: ;  lda #'i'
                        	    41: ;  jsr ass_debug_point
                        	    42: 
00:915B C498            	    43:   cpy token_work
00:915D F010            	    44:   beq handler_same_length
                        	    45: ;
                        	    46: ;  not the same length, or no match on the string
                        	    47: ;
                        	    48: handler_next:
00:915F 98              	    49:   tya
00:9160 18              	    50:   clc
00:9161 6903            	    51:   adc #3  ; skip the 0x00 and the execution address
00:9163 6503            	    52:   adc DEST
00:9165 8503            	    53:   sta DEST
00:9167 A504            	    54:   lda DEST+1
00:9169 6900            	    55:   adc #0
00:916B 8504            	    56:   sta DEST+1
00:916D 80DD            	    57:   bra handler_loop
                        	    58: 
                        	    59: handler_same_length:
                        	    60: 
                        	    61: ;  lda #'j'
                        	    62: ;  jsr ass_debug_point
                        	    63: 
00:916F 5A              	    64:   phy  ; save the length
00:9170 206D94          	    65:   jsr COMSTL
00:9173 F003            	    66:   beq  handler_found_directive
00:9175 7A              	    67:   ply
00:9176 80E7            	    68:   bra handler_next
                        	    69: handler_found_directive:
00:9178 7A              	    70:   ply  ; get the length back
00:9179 C8              	    71:   iny  ; skip past the 0x00 byte
00:917A B103            	    72:   lda (DEST),y
00:917C 8599            	    73:   sta token_work+1
00:917E C8              	    74:   iny
00:917F B103            	    75:   lda (DEST),y
00:9181 859A            	    76:   sta token_work+2
00:9183 208A91          	    77:   jsr call_handler
00:9186 18              	    78:   clc
00:9187 60              	    79:   rts
                        	    80: 
                        	    81: handlers_done:
                        	    82: ;  lda #'h'
                        	    83: ;  jsr ass_debug_point
00:9188 38              	    84:   sec     ; error flag
00:9189 60              	    85:   rts
                        	    86: 
                        	    87: call_handler:
                        	    88: ;  lda #'g'
                        	    89: ;  jsr ass_debug_point
                        	    90: 
00:918A 6C9900          	    91:   jmp (token_work+1)   ; do handler - it will RTS for us
                        	    92: 
                        	    93: 
                        	    94: ;
                        	    95: ;  function to look up a handler for a word on a partial match (eg. editor command)
                        	    96: ;
                        	    97: ;  word in SRCE
                        	    98: ;
                        	    99: ;  table of words/handlers in DEST - in UPPER CASE
                        	   100: ;
                        	   101: ;  length of word in A
                        	   102: ;
                        	   103: ;  see makeHandler for making the table
                        	   104: ;
                        	   105: ;  Basically:
                        	   106: ;    asciiz "FOO"
                        	   107: ;    word   foo_handler
                        	   108: ;
                        	   109: ;  In other words:
                        	   110: ;    makeHandler "FOO",foo_handler
                        	   111: ;
                        	   112: ;  Returns if no match, otherwise jumps to the handler and thus doesn't return
                        	   113: ;
                        	   114: 
                        	   115: partial_handler_Lookup:
00:918D 8598            	   116:   sta token_work    ; save length
                        	   117: ;
                        	   118: ;  here for a new table item
                        	   119: ;
                        	   120: partial_handler_next_item:
00:918F A000            	   121:   ldy #0
00:9191 B103            	   122:   lda (DEST),y
00:9193 F03C            	   123:   beq partial_handler_done
00:9195 A698            	   124:   ldx token_work        ; source length
                        	   125: partial_handler_next_loop:
                        	   126: ;
                        	   127: ;  ensure the nth character matches until the source runs out
                        	   128: ;
00:9197 B100            	   129:   lda (SRCE),y
00:9199 200492          	   130:   jsr MAKE_UPPER
00:919C D103            	   131:   cmp (DEST),y
00:919E D006            	   132:   bne partial_handler_next
00:91A0 C8              	   133:   iny
00:91A1 CA              	   134:   dex     ; one less count
00:91A2 F019            	   135:   beq partial_handler_found_directive ; source has finished and we found the directive
00:91A4 80F1            	   136:   bra partial_handler_next_loop       ; try matching the next one
                        	   137: ;
                        	   138: ;  no match on the string - advance Y to the end of the destination string
                        	   139: ;
                        	   140: partial_handler_next:
00:91A6 B103            	   141:   lda (DEST),y
00:91A8 F003            	   142:   beq partial_handler_next_found_item_length
00:91AA C8              	   143:   iny
00:91AB 80F9            	   144:   bra partial_handler_next
                        	   145: partial_handler_next_found_item_length:
00:91AD 98              	   146:   tya     ; length of the word in the table
00:91AE 18              	   147:   clc
00:91AF 6903            	   148:   adc #3  ; skip the 0x00 and the execution address
00:91B1 6503            	   149:   adc DEST
00:91B3 8503            	   150:   sta DEST
00:91B5 A504            	   151:   lda DEST+1
00:91B7 6900            	   152:   adc #0
00:91B9 8504            	   153:   sta DEST+1
00:91BB 80D2            	   154:   bra partial_handler_next_item
                        	   155: 
                        	   156: partial_handler_found_directive:
00:91BD B103            	   157:   lda (DEST),y
00:91BF F003            	   158:   beq partial_handler_skipped_string
00:91C1 C8              	   159:   iny
00:91C2 80F9            	   160:   bra partial_handler_found_directive
                        	   161: partial_handler_skipped_string:
00:91C4 C8              	   162:   iny  ; skip past the 0x00 byte
00:91C5 B103            	   163:   lda (DEST),y
00:91C7 8599            	   164:   sta token_work+1
00:91C9 C8              	   165:   iny
00:91CA B103            	   166:   lda (DEST),y
00:91CC 859A            	   167:   sta token_work+2
00:91CE 6C9900          	   168:   jmp (token_work+1)   ; do partial_partial_handler_ - it will RTS for us
                        	   169: 
                        	   170: partial_handler_done:
00:91D1 60              	   171:   rts
                        	   172: 
                        	   173: ;***********************************************
                        	   174: ; JUMP ON TOKEN
                        	   175: ; X/Y = START OF TABLE
                        	   176: ; END OF TABLE IS A NULL
                        	   177: ; A = TOKEN
                        	   178: ;***********************************************
                        	   179: TKNJMP   =  *
00:91D2 8600            	   180:          stx  REG     ; save table address
00:91D4 8401            	   181:          sty  REG+1
                        	   182: 
00:91D6 200492          	   183:          jsr MAKE_UPPER
00:91D9 AA              	   184:          tax          ; save the token
                        	   185: JMP1     =  *
00:91DA A000            	   186:          ldy  #0
00:91DC B100            	   187:          lda  (REG),Y
00:91DE D002            	   188:          bne  JMP2
                        	   189: ; failed to find the token
00:91E0 8A              	   190:          txa          ; retore the token
00:91E1 60              	   191:          rts
                        	   192: JMP2     =  *
00:91E2 8A              	   193:          txa          ; get token back
00:91E3 D100            	   194:          cmp  (REG),Y
00:91E5 D010            	   195:          bne  JMP3    ; branch if not found
00:91E7 68              	   196:          pla
00:91E8 68              	   197:          pla          ; remove return address for TKNJMP call
00:91E9 C8              	   198:          iny          ; move Y on to routine address
00:91EA B100            	   199:          lda  (REG),Y ; get low order byte of routine
00:91EC 8503            	   200:          sta  REG2
00:91EE C8              	   201:          iny          ; next byte
00:91EF B100            	   202:          lda  (REG),Y ; get high order byte
00:91F1 8504            	   203:          sta  REG2+1
00:91F3 8A              	   204:          txa          ; get token back
00:91F4 6C0300          	   205:          jmp  (REG2)  ; go to routine
                        	   206: JMP3     =  *
00:91F7 A500            	   207:          lda  REG     ; skip this token sequence
00:91F9 18              	   208:          clc
00:91FA 6903            	   209:          adc  #3
00:91FC 8500            	   210:          sta  REG
00:91FE 90DA            	   211:          bcc  JMP1
00:9200 E601            	   212:          inc  REG+1
00:9202 80D6            	   213:          bra  JMP1    ; try again
                        	   214: 
                        	   215: ;
                        	   216: 
                        	   217: 
                        	   218: ;***********************************************
                        	   219: ;
                        	   220: ; Case conversion
                        	   221: ;
                        	   222: ;***********************************************
                        	   223: 
                        	   224: 
                        	   225: MAKE_UPPER = *
00:9204 C97B            	   226:          CMP  #('z'+1)
00:9206 B006            	   227:          BCS  MAKE_UPPER_DONE
00:9208 C961            	   228:          CMP  #'a'
00:920A 9002            	   229:          BCC  MAKE_UPPER_DONE
00:920C E920            	   230:          SBC  #$20  ; make upper-case - we want carry set so there is no borrow
                        	   231: MAKE_UPPER_DONE = *
00:920E 60              	   232:          RTS
                        	   233: 
                        	   234: MAKE_LOWER = *
00:920F C941            	   235:          CMP  #'A'
00:9211 9006            	   236:          BCC  MAKE_LOWER_DONE
00:9213 C95B            	   237:          CMP  #('Z'+1)
00:9215 B002            	   238:          BCS  MAKE_LOWER_DONE
00:9217 6920            	   239:          ADC  #$20  ; make upper-case - we want carry clear so there is no carry
                        	   240: MAKE_LOWER_DONE = *
00:9219 60              	   241:          RTS
                        	   242: 
                        	   243: 
                        	   244: ;
                        	   245: ;  generate the next random number
                        	   246: ;
                        	   247: gen_random:
00:921A 0609            	   248:     asl random
00:921C 260A            	   249:     rol random+1
00:921E 260B            	   250:     rol random+2
00:9220 260C            	   251:     rol random+3
00:9222 9018            	   252:     bcc gen_random1
00:9224 A509            	   253:     lda random
00:9226 49B7            	   254:     eor #$B7
00:9228 8509            	   255:     sta random
00:922A A50A            	   256:     lda random+1
00:922C 491D            	   257:     eor #$1D
00:922E 850A            	   258:     sta random+1
00:9230 A50B            	   259:     lda random+2
00:9232 49C1            	   260:     eor #$C1
00:9234 850B            	   261:     sta random+2
00:9236 A50C            	   262:     lda random+3
00:9238 4904            	   263:     eor #$04
00:923A 850C            	   264:     sta random+3
                        	   265: gen_random1:
00:923C 60              	   266:     rts
                        	   267: 
                        	   268: 
                        	   269: 
                        	   270: ;
                        	   271: ;  From: http://www.6502.org/source/integers/crc-more.html
                        	   272: ;
                        	   273: ;   jacksum  -a crc:16,1021,FFFF,false,false,0 -X SOME_FILE
                        	   274: ;
                        	   275: ;   https://jacksum.net/en/index.html
                        	   276: ;
                        	   277: ;   With a starting CRC of $FFFF, the binary string $01 $02 $03 $04 should evaluate to $89C3.
                        	   278: ;
                        	   279: ;   Start at crc_addr, for crc_num bytes
                        	   280: ;
                        	   281: crc16 = *
                        	   282: ;
                        	   283: ;  initialise CRC
                        	   284: ;
00:923D A9FF            	   285:   lda #$FF
00:923F 8506            	   286:   sta crc_val
00:9241 8507            	   287:   sta crc_val+1
00:9243 A503            	   288:   lda crc_num
00:9245 0504            	   289:   ora crc_num+1
00:9247 F01B            	   290:   beq crc_done
                        	   291: 
                        	   292: ;
                        	   293: ;  here for each byte
                        	   294: ;
                        	   295: crc16_loop  = *
00:9249 A000            	   296:   ldy #0
00:924B B100            	   297:   lda (crc_addr),y  ; get next byte
00:924D 206592          	   298:   jsr crc_byte
                        	   299:   ;
                        	   300:   ;  onto next address
                        	   301:   ;
00:9250 E600            	   302:   inc crc_addr
00:9252 D002            	   303:   bne crc16_next
00:9254 E601            	   304:   inc crc_addr+1       ; Step to next byte
                        	   305: crc16_next:
                        	   306:   ;
                        	   307:   ; now do a 16-bit decrement
                        	   308:   ;
00:9256 A503            	   309:   LDA crc_num
00:9258 D002            	   310:   BNE crc16_skip    ; decrement the high-order byte if we are about to wrap
00:925A C604            	   311:   DEC crc_num+1
                        	   312: crc16_skip:
00:925C C603            	   313:   DEC crc_num       ; decrement the low-order byte
00:925E D0E9            	   314:   BNE crc16_loop    ; not zero, keep going
00:9260 A504            	   315:   LDA crc_num+1     ; are we zero here too?
00:9262 D0E5            	   316:   BNE crc16_loop    ; not yet
                        	   317: 
                        	   318: crc_done:
00:9264 60              	   319:   rts
                        	   320: 
                        	   321: ;
                        	   322: ;  do a CRC of one byte (in A) updating crc_val
                        	   323: ;
                        	   324: crc_byte = *
00:9265 4507            	   325:   eor crc_val+1     ; A contained the data
00:9267 8507            	   326:   sta crc_val+1     ; XOR it into high byte
00:9269 4A              	   327:   lsr               ; right shift A 4 bits
00:926A 4A              	   328:   lsr               ; to make top of x^12 term
00:926B 4A              	   329:   lsr               ; ($1...)
00:926C 4A              	   330:   lsr
00:926D AA              	   331:   tax               ; save it
00:926E 0A              	   332:   asl               ; then make top of x^5 term
00:926F 4506            	   333:   eor crc_val       ; and XOR that with low byte
00:9271 8506            	   334:   sta crc_val       ; and save
00:9273 8A              	   335:   txa               ; restore partial term
00:9274 4507            	   336:   eor crc_val+1     ; and update high byte
00:9276 8507            	   337:   sta crc_val+1     ; and save
00:9278 0A              	   338:   asl               ; left shift three
00:9279 0A              	   339:   asl               ; the rest of the terms
00:927A 0A              	   340:   asl               ; have feedback from x^12
00:927B AA              	   341:   tax               ; save bottom of x^12
00:927C 0A              	   342:   asl               ; left shift two more
00:927D 0A              	   343:   asl               ; watch the carry flag
00:927E 4507            	   344:   eor crc_val+1     ; bottom of x^5 ($..2.)
00:9280 A8              	   345:   tay               ; save high byte
00:9281 8A              	   346:   txa               ; fetch temp value
00:9282 2A              	   347:   rol               ; bottom of x^12, middle of x^5!
00:9283 4506            	   348:   eor crc_val       ; finally update low byte
00:9285 8507            	   349:   sta crc_val+1     ; then swap high and low bytes
00:9287 8406            	   350:   sty crc_val
00:9289 60              	   351:   rts
                        	   352: 
                        	   353: 
                        	   354: crc_helper = *
00:928A 5A              	   355:   phy
00:928B DA              	   356:   phx
00:928C 206592          	   357:   jsr crc_byte
00:928F E603            	   358:   inc crc_num
00:9291 D002            	   359:   bne crc_helper1
00:9293 E604            	   360:   inc crc_num+1
                        	   361: crc_helper1:
00:9295 FA              	   362:   plx
00:9296 7A              	   363:   ply
00:9297 60              	   364:   rts
                        	   365: 
00:9298 536F757263652043	   366: crc_message asciiz "Source CRC       $"               ; source CRC
00:92A0 5243202020202020
00:92A8 2024
00:92AA 00
00:92AB 536F75726365206C	   367: source_length_message asciiz "Source length: "    ; source length
00:92B3 656E6774683A20
00:92BA 00
00:92BB 2062797465730A  	   368: bytes_message asciiz " bytes\n"
00:92C2 00
                        	   369: 
                        	   370: crc_source = *
00:92C3 20A78C          	   371:   jsr find_source_end
                        	   372: 
                        	   373: ;
                        	   374: ;  move existing source to end of RAM
                        	   375: ;
00:92C6 18              	   376:   clc             ; don't count the final 0x00 byte
00:92C7 A523            	   377:   lda PCODE
00:92C9 E900            	   378:   sbc #<TEXT_START
00:92CB 8503            	   379:   sta crc_num
00:92CD A524            	   380:   lda PCODE+1
00:92CF E903            	   381:   sbc #>TEXT_START
00:92D1 8504            	   382:   sta crc_num+1
                        	   383: ;
                        	   384: ;  Show the length of the source
                        	   385: ;
00:92D3 A9AB            	   386:   lda #<source_length_message
00:92D5 A292            	   387:   ldx #>source_length_message
00:92D7 202682          	   388:   jsr print
00:92DA A503            	   389:   lda crc_num
00:92DC 8500            	   390:   sta REG
00:92DE A504            	   391:   lda crc_num+1
00:92E0 8501            	   392:   sta REG+1
00:92E2 6402            	   393:   stz REGB
00:92E4 209293          	   394:   jsr display_in_decimal
00:92E7 A9BB            	   395:   lda #<bytes_message
00:92E9 A292            	   396:   ldx #>bytes_message
00:92EB 202682          	   397:   jsr print
                        	   398: 
                        	   399: ;
                        	   400: ;  now the CRC
                        	   401: ;
00:92EE A900            	   402:   lda #<TEXT_START
00:92F0 8500            	   403:   sta crc_addr
00:92F2 A903            	   404:   lda #>TEXT_START
00:92F4 8501            	   405:   sta crc_addr+1
00:92F6 203D92          	   406:   jsr crc16
00:92F9 A998            	   407:   lda  #<crc_message            ;  source CRC
00:92FB A292            	   408:   ldx  #>crc_message            ;
00:92FD 202682          	   409:   jsr  print
00:9300 A507            	   410:   lda crc_val+1
00:9302 20DD94          	   411:   jsr PRBYTE
00:9305 A506            	   412:   lda crc_val
00:9307 209295          	   413:   jsr PRBYTECR
00:930A 60              	   414:   rts
                        	   415: 
                        	   416: 
                        	   417: ;
                        	   418: ;  delays for roughly 1 ms - changes no registers
                        	   419: ;
                        	   420: delay_1ms = *
00:930B DA              	   421:          phx
00:930C A26C            	   422:          ldx #108
                        	   423: delay_1ms_loop:
00:930E EA              	   424:          nop
00:930F EA              	   425:          nop
00:9310 CA              	   426:          dex
00:9311 D0FB            	   427:          bne delay_1ms_loop
00:9313 FA              	   428:          plx
00:9314 60              	   429:          rts
                        	   430: 
                        	   431: ;
                        	   432: ; delay for YYXX ms (Y = high-order byte, X = lo-order byte)
                        	   433: ;  maximum delay 0x7FFF, that is 32767 ms
                        	   434: ;  Changes X and Y
                        	   435: ;
                        	   436: delay = *
00:9315 200B93          	   437:   jsr delay_1ms
00:9318 CA              	   438:   dex
00:9319 D0FA            	   439:   bne delay
00:931B 88              	   440:   dey
00:931C 10F7            	   441:   bpl delay
00:931E 60              	   442:   rts
                        	   443: 
                        	   444: 
                        	   445: ;--------------------------------------------------------------------------
                        	   446: ;
                        	   447: ;  BINARY TO DECIMAL CONVERSION
                        	   448: ;
                        	   449: ;  This works as follows:
                        	   450: ;
                        	   451: ;  1. First the number is checked if it is negative (sign bit set).
                        	   452: ;  2. If so, a "-" is output and the number subtracted from zero to make it positive.
                        	   453: ;  3. Our next step is to set a BCD (binary coded decimal) output area to all zeroes.
                        	   454: ;      In BCD, the number 1234 is actually stored as 0x1234.
                        	   455: ;      With BCD mode turned on in the processor, doing adds results in an early carry
                        	   456: ;      so that numbers add "the decimal way" rather than the binary way.
                        	   457: ;  4. Then we a loop of 24 iterations (one for each bit) which adds the appropriate number from bcd_table
                        	   458: ;      if that bit was set in the original value.
                        	   459: ;  5. The function bcd_unpack is then called to convert the BCD format into ASCII format. It takes each
                        	   460: ;     nibble and adds 0x30 ('0') to it, and saves that in bcd_result.
                        	   461: ;  6. At this stage bcd_result has a 8-digit ASCII number in it.
                        	   462: ;  7. We then skip leading zeroes in bcd_result.
                        	   463: ;  8. Finally the remaining digits in bcd_result are output.
                        	   464: ;
                        	   465: ;
                        	   466: ;   I'm not sure where the idea for this came from. There was no Internet when this was written in 1979
                        	   467: ;   so it is possibly (probably) my own.
                        	   468: ;   My original implementation, although similar, was more complex than this one, which I found at:
                        	   469: ;              http://www.6502.org/source/integers/hex2dec.htm
                        	   470: ;
                        	   471: ;   Other suggestions for binary to decimal conversion I found recently do not employ this method. One
                        	   472: ;   technique (as described by Ben Eater here: https://www.youtube.com/watch?v=v3-a-zqKfgA ) is to
                        	   473: ;   repeatedly divide by 10 and use the remainder as the digit. This has to be done until the result of
                        	   474: ;   the division is zero. Dividing a 3-byte number by 10 on an 8-bit machine is not particularly fast,
                        	   475: ;   as it involves an inner loop of 24 iterations (one for each bit) and this would have to be done for
                        	   476: ;   each digit, so the number of loops of 24 iterations would increase for each digit. Therefore an
                        	   477: ;   8-digit number (like 80000000) would take 144 iterations in the divide loop. Then the digits have to
                        	   478: ;   be reversed because the remainder gives you the low-order decimal digit first.
                        	   479: ;
                        	   480: ;   Another technique is the "Double dabble" routine.
                        	   481: ;
                        	   482: ;     https://en.wikipedia.org/wiki/Double_dabble
                        	   483: ;
                        	   484: ;   The method below seems fairly efficient, as the inner loop only does anything substantial if a
                        	   485: ;     1-bit is detected. Thus large numbers can be produced quite efficiently, however it would be a
                        	   486: ;     bit slower if the input number had a lot of 1-bits set.
                        	   487: ;
                        	   488: ;   Considering that this is only used when outputting to serial, itself a slow process, speed is not
                        	   489: ;   really the issue here.
                        	   490: ;
                        	   491: ;   - Nick Gammon
                        	   492: ;
                        	   493: ;
                        	   494: ;--------------------------------------------------------------------------
                        	   495: ;
                        	   496: ; Converts BCD to ASCII
                        	   497: ;
                        	   498: bcd_unpack:
00:931F 48              	   499:   pha  ; save the number for later
                        	   500: ;
                        	   501: ;  shift right 4 bits
                        	   502: ;
00:9320 4A              	   503:   lsr A
00:9321 4A              	   504:   lsr A
00:9322 4A              	   505:   lsr A
00:9323 4A              	   506:   lsr A
00:9324 0930            	   507:   ora #'0'          ; make printable
00:9326 9560            	   508:   sta bcd_result,X  ; save in bcd_result
00:9328 E8              	   509:   inx
00:9329 68              	   510:   pla               ; get the original character back
00:932A 290F            	   511:   and #$0F          ; take low-order bits and make printable
00:932C 0930            	   512:   ora #'0'
00:932E 9560            	   513:   sta bcd_result,X  ; save in bcd_result
00:9330 E8              	   514:   inx
00:9331 60              	   515:   rts               ; done!
                        	   516: 
                        	   517: ;
                        	   518: ;
                        	   519: ; Table for adding into the BCD result.
                        	   520: ;
                        	   521: bcd_table  =  *
00:9332 00              	   522:   dfb $00,$00,$00,$01   ; 0000001
00:9333 00
00:9334 00
00:9335 01
00:9336 00              	   523:   dfb $00,$00,$00,$02   ; 0000002
00:9337 00
00:9338 00
00:9339 02
00:933A 00              	   524:   dfb $00,$00,$00,$04   ; 0000004
00:933B 00
00:933C 00
00:933D 04
00:933E 00              	   525:   dfb $00,$00,$00,$08   ; 0000008
00:933F 00
00:9340 00
00:9341 08
00:9342 00              	   526:   dfb $00,$00,$00,$16   ; 0000016
00:9343 00
00:9344 00
00:9345 16
00:9346 00              	   527:   dfb $00,$00,$00,$32   ; 0000032
00:9347 00
00:9348 00
00:9349 32
00:934A 00              	   528:   dfb $00,$00,$00,$64   ; 0000064
00:934B 00
00:934C 00
00:934D 64
00:934E 00              	   529:   dfb $00,$00,$01,$28   ; 0000128
00:934F 00
00:9350 01
00:9351 28
00:9352 00              	   530:   dfb $00,$00,$02,$56   ; 0000256
00:9353 00
00:9354 02
00:9355 56
00:9356 00              	   531:   dfb $00,$00,$05,$12   ; 0000512
00:9357 00
00:9358 05
00:9359 12
00:935A 00              	   532:   dfb $00,$00,$10,$24   ; 0001024
00:935B 00
00:935C 10
00:935D 24
00:935E 00              	   533:   dfb $00,$00,$20,$48   ; 0002048
00:935F 00
00:9360 20
00:9361 48
00:9362 00              	   534:   dfb $00,$00,$40,$96   ; 0004096
00:9363 00
00:9364 40
00:9365 96
00:9366 00              	   535:   dfb $00,$00,$81,$92   ; 0008192
00:9367 00
00:9368 81
00:9369 92
00:936A 00              	   536:   dfb $00,$01,$63,$84   ; 0016384
00:936B 01
00:936C 63
00:936D 84
00:936E 00              	   537:   dfb $00,$03,$27,$68   ; 0032768
00:936F 03
00:9370 27
00:9371 68
00:9372 00              	   538:   dfb $00,$06,$55,$36   ; 0065536
00:9373 06
00:9374 55
00:9375 36
00:9376 00              	   539:   dfb $00,$13,$10,$72   ; 0131072
00:9377 13
00:9378 10
00:9379 72
00:937A 00              	   540:   dfb $00,$26,$21,$44   ; 0262144
00:937B 26
00:937C 21
00:937D 44
00:937E 00              	   541:   dfb $00,$52,$42,$88   ; 0524288
00:937F 52
00:9380 42
00:9381 88
00:9382 01              	   542:   dfb $01,$04,$85,$76   ; 1048576
00:9383 04
00:9384 85
00:9385 76
00:9386 02              	   543:   dfb $02,$09,$71,$52   ; 2097152
00:9387 09
00:9388 71
00:9389 52
00:938A 04              	   544:   dfb $04,$19,$43,$04   ; 4194304
00:938B 19
00:938C 43
00:938D 04
00:938E 08              	   545:   dfb $08,$38,$86,$08   ; 8388608
00:938F 38
00:9390 86
00:9391 08
                        	   546: 
                        	   547: ;--------------------------------------------------------------------------
                        	   548: ; display_in_decimal - start here - VALUE will be zero after this is executed
                        	   549: ;--------------------------------------------------------------------------
                        	   550: 
                        	   551: display_in_decimal  =  *
00:9392 A502            	   552:   lda  VALUE+2
00:9394 1008            	   553:   bpl  bcd_positive
                        	   554: ;
                        	   555: ;  if the number is negative, output a minus sign and make it positive
                        	   556: ;
00:9396 A92D            	   557:   lda  #'-'
00:9398 20F695          	   558:   jsr  COUT
00:939B 204DAE          	   559:   jsr  exp_unary_minus
                        	   560: ;
                        	   561: ;  number is now positive
                        	   562: ;
                        	   563: bcd_positive:
                        	   564: 
00:939E 20BB93          	   565:   jsr binary_to_decimal   ; do the conversion
                        	   566: 
00:93A1 A207            	   567:   ldx  #7         ; zero suppress count (always keep the last zero)
00:93A3 A000            	   568:   ldy  #0
                        	   569: ;
                        	   570: ;  this is skipping the leading zeroes
                        	   571: ;
                        	   572: bcd_skip_zeroes:
00:93A5 B96000          	   573:   lda  bcd_result,Y
00:93A8 C930            	   574:   cmp  #'0'
00:93AA D004            	   575:   bne  bcd_output_digit
00:93AC C8              	   576:   iny
00:93AD CA              	   577:   dex
00:93AE D0F5            	   578:   bne  bcd_skip_zeroes
                        	   579: ;
                        	   580: ;  now we have a non-zero, start outputting them
                        	   581: ;
                        	   582: ;  Y points to how far we are through bcd_result
                        	   583: ;  X is how many digits to go
                        	   584: ;
                        	   585: bcd_output_digit:
00:93B0 B96000          	   586:   lda  bcd_result,Y
00:93B3 20F695          	   587:   jsr  COUT
00:93B6 C8              	   588:   iny
00:93B7 CA              	   589:   dex
00:93B8 10F6            	   590:   bpl  bcd_output_digit
                        	   591: ;
                        	   592: ;  done!
                        	   593: ;
00:93BA 60              	   594:   rts
                        	   595: 
                        	   596: ;--------------------------------------------------------------------------
                        	   597: ;
                        	   598: ;  Binary to decimal routine: Converts VALUE into bcd_result (8 digits)
                        	   599: ;
                        	   600: ;  See: http://www.6502.org/source/integers/hex2dec.htm
                        	   601: ;
                        	   602: ;  - VALUE will be zero after this is executed
                        	   603: ;
                        	   604: ;--------------------------------------------------------------------------
                        	   605: binary_to_decimal:
00:93BB F8              	   606:   sed                 ; decimal mode for adds below
00:93BC 645C            	   607:   stz  bcd_work       ; zero our result area (4 bytes = 8 digits)
00:93BE 645D            	   608:   stz  bcd_work+1
00:93C0 645E            	   609:   stz  bcd_work+2
00:93C2 645F            	   610:   stz  bcd_work+3
                        	   611: 
00:93C4 A25C            	   612:   ldx  #(4*23)        ; X points to the start of the highest entry
                        	   613: 
                        	   614: binary_to_decimal_loop:
00:93C6 0600            	   615:   asl VALUE      ;  shift out high-order bit into Carry
00:93C8 2601            	   616:   rol VALUE+1
00:93CA 2602            	   617:   rol VALUE+2
00:93CC 901D            	   618:   bcc binary_to_decimal_next  ; if carry clear, no add needs to be done
                        	   619: ;
                        	   620: ;  that bit was set, so add the appropriate BCD number from the table (eg. 1, 2, 4, 8, 16 and so on)
                        	   621: ;
00:93CE 18              	   622:   clc
00:93CF A55C            	   623:   lda bcd_work
00:93D1 7D3593          	   624:   adc bcd_table+3,X
00:93D4 855C            	   625:   sta bcd_work
00:93D6 A55D            	   626:   lda bcd_work+1
00:93D8 7D3493          	   627:   adc bcd_table+2,X
00:93DB 855D            	   628:   sta bcd_work+1
00:93DD A55E            	   629:   lda bcd_work+2
00:93DF 7D3393          	   630:   adc bcd_table+1,X
00:93E2 855E            	   631:   sta bcd_work+2
00:93E4 A55F            	   632:   lda bcd_work+3
00:93E6 7D3293          	   633:   adc bcd_table,X
00:93E9 855F            	   634:   sta bcd_work+3
                        	   635: 
                        	   636: binary_to_decimal_next:
00:93EB CA              	   637:   dex      ; back to the previous table item
00:93EC CA              	   638:   dex
00:93ED CA              	   639:   dex
00:93EE CA              	   640:   dex
00:93EF 10D5            	   641:   bpl binary_to_decimal_loop
00:93F1 D8              	   642:   cld     ; decimal mode off
                        	   643: 
                        	   644: 
                        	   645: ;
                        	   646: ;  convert BCD to ASCII - note that UNPACK increments x by two each time
                        	   647: ;    - the results are in bcd_result - an 8-character field
                        	   648: ;
                        	   649: ;  We unpack the high-order bytes first, naturally
                        	   650: ;
00:93F2 A200            	   651:   ldx  #0
00:93F4 A55F            	   652:   lda  bcd_work+3
00:93F6 201F93          	   653:   jsr  bcd_unpack
00:93F9 A55E            	   654:   lda  bcd_work+2
00:93FB 201F93          	   655:   jsr  bcd_unpack
00:93FE A55D            	   656:   lda  bcd_work+1
00:9400 201F93          	   657:   jsr  bcd_unpack
00:9403 A55C            	   658:   lda  bcd_work
00:9405 201F93          	   659:   jsr  bcd_unpack
00:9408 60              	   660:   rts
                        	   661: 
00:9409 4E6F20736F757263	   662: NOSCE    asciiz  'No source file.\n'   ; No source file
00:9411 652066696C652E0A
00:9419 00
                        	   663: 
                        	   664: ;***********************************************
                        	   665: ;
                        	   666: ; Initialize a compile or assembly
                        	   667: ;
                        	   668: ;***********************************************
                        	   669: 
                        	   670: 
                        	   671: INIT     =  *
                        	   672: ;
                        	   673: ;  set up symbol table pointer
                        	   674: ;
                        	   675: 
00:941A A93F            	   676:   lda  #>SYMBOL_TABLE_START
00:941C 8532            	   677:   sta  ENDSYM+1
00:941E 8530            	   678:   sta  STARTSYM+1
00:9420 A9FF            	   679:   lda  #<SYMBOL_TABLE_START
00:9422 8531            	   680:   sta  ENDSYM
00:9424 852F            	   681:   sta  STARTSYM
                        	   682: 
                        	   683: INIT_SECOND_PASS:   ; for assembler
                        	   684: 
00:9426 A900            	   685:   lda  #0
00:9428 851D            	   686:   sta  LIST            ; not listing
00:942A 8522            	   687:   sta  LEVEL           ; variable level zero
00:942C 852E            	   688:   sta  DCODE
00:942E 853F            	   689:   sta  RUNNING         ; not running
00:9430 8539            	   690:   sta  PRCITM
00:9432 853A            	   691:   sta  PRCITM+1
00:9434 8502            	   692:   sta  REGB
00:9436 8593            	   693:   sta  token_type
00:9438 64BE            	   694:   stz  system_flags
00:943A A901            	   695:   lda #1
00:943C 85A2            	   696:   sta  current_line        ; we are currently on line 1
00:943E 64A3            	   697:   stz  current_line+1
                        	   698: 
                        	   699: ;
                        	   700: ;  set up for reading first byte of source
                        	   701: ;
00:9440 A900            	   702:   lda  #<TEXT_START
00:9442 858E            	   703:   sta  token_start
00:9444 859C            	   704:   sta  token_line_start
00:9446 A903            	   705:   lda  #>TEXT_START
00:9448 858F            	   706:   sta  token_start+1
00:944A 859D            	   707:   sta  token_line_start+1
00:944C 20A78C          	   708:   jsr  find_source_end
00:944F A523            	   709:   lda  PCODE
00:9451 8525            	   710:   sta  ACT_PCDA
00:9453 A524            	   711:   lda  PCODE+1
00:9455 8526            	   712:   sta  ACT_PCDA+1
00:9457 A000            	   713:   ldy  #0
00:9459 B18E            	   714:   lda  (token_start),y
00:945B D00A            	   715:   bne  INIT9
00:945D A909            	   716:   lda  #<NOSCE
00:945F A294            	   717:   ldx  #>NOSCE
00:9461 202682          	   718:   jsr  print                      ; No source file
00:9464 4C7282          	   719:   jmp  main_prompt
00:9467 60              	   720: INIT9    rts
                        	   721: 
                        	   722: 
                        	   723: 
                        	   724: 
                        	   725: ;
                        	   726: CROUT    =  *             ; show a newline
00:9468 A90A            	   727:   lda  #NL         ; was a carriage-return in legacy, now is newline
00:946A 4CF695          	   728:   jmp  COUT
                        	   729: ;
                        	   730: ;***********************************************
                        	   731: ; COMPARE STRING - compare SRCE to DEST, assumes DEST is upper-case
                        	   732: ;                - length in Y (therefore max 255 characters)
                        	   733: ;                - zero flag set if match (therefore do a BEQ to see if strings match)
                        	   734: ;***********************************************
                        	   735: COMSTL   =  *
00:946D 88              	   736:          dey
00:946E 300A            	   737:          bmi  COMS8
00:9470 B100            	   738:          lda  (SRCE),Y
00:9472 200492          	   739:          jsr MAKE_UPPER
00:9475 D103            	   740:          cmp  (DEST),Y
00:9477 F0F4            	   741:          beq  COMSTL
00:9479 60              	   742: COMS9    rts             ; NOT EQUAL
00:947A A900            	   743: COMS8    lda  #0
00:947C 60              	   744:          rts             ; EQUAL
                        	   745: 
                        	   746: ;***********************************************
                        	   747: ; DISPLAY A LINE
                        	   748: ;
                        	   749: 
                        	   750: ;
                        	   751: ; DISPLAY IN HEX
                        	   752: ;
00:947D 20DD94          	   753: DISHX    jsr  PRBYTE
00:9480 4CF394          	   754:          jmp  PUTSP
                        	   755: ;
                        	   756: 
                        	   757: ;***********************************************
                        	   758: ; DISPLAY PCODE ADDRESS
                        	   759: ;***********************************************
                        	   760: DISPAD   =  *
00:9483 A52E            	   761:          lda  DCODE
00:9485 F017            	   762:          beq  DISPAD2
                        	   763: DISPAD1  =  *
00:9487 A928            	   764:          lda  #'('
00:9489 20F695          	   765:          jsr  COUT
00:948C A524            	   766:          lda  PCODE+1
00:948E 20DD94          	   767:          jsr  PRBYTE
00:9491 A523            	   768:          lda  PCODE
00:9493 20DD94          	   769:          jsr  PRBYTE
00:9496 A929            	   770:          lda  #')'
00:9498 20F695          	   771:          jsr  COUT
00:949B 4CF394          	   772:          jmp  PUTSP
00:949E 60              	   773: DISPAD2  rts
                        	   774: ;
                        	   775: 
                        	   776: ;***********************************************
                        	   777: ; PUSH 'WORK' ONTO STACK
                        	   778: ;***********************************************
                        	   779: PSHWRK   =  *
00:949F 8536            	   780:          sta  BSAVE
00:94A1 68              	   781:          pla
00:94A2 AA              	   782:          tax
00:94A3 68              	   783:          pla
00:94A4 A8              	   784:          tay
00:94A5 A538            	   785:          lda  WORK+1
00:94A7 48              	   786:          pha
00:94A8 A537            	   787:          lda  WORK
00:94AA 48              	   788:          pha
00:94AB 98              	   789:          tya
00:94AC 48              	   790:          pha
00:94AD 8A              	   791:          txa
00:94AE 48              	   792:          pha
00:94AF A536            	   793:          lda  BSAVE
00:94B1 60              	   794: PSH9     rts
                        	   795: ;
                        	   796: ;***********************************************
                        	   797: ; PULL 'WORK' FROM STACK
                        	   798: ;***********************************************
                        	   799: PULWRK   =  *
00:94B2 8536            	   800:          sta  BSAVE
00:94B4 68              	   801:          pla
00:94B5 AA              	   802:          tax
00:94B6 68              	   803:          pla
00:94B7 A8              	   804:          tay
00:94B8 68              	   805:          pla
00:94B9 8537            	   806:          sta  WORK
00:94BB 68              	   807:          pla
00:94BC 8538            	   808:          sta  WORK+1
00:94BE 98              	   809:          tya
00:94BF 48              	   810:          pha
00:94C0 8A              	   811:          txa
00:94C1 48              	   812:          pha
00:94C2 A536            	   813:          lda  BSAVE
00:94C4 60              	   814:          rts
                        	   815: ;
                        	   816: ;***********************************************
                        	   817: ; PRINTING SUBROUTINES
                        	   818: ; Control characters print with a ^ in front of them, eg. ^A
                        	   819: ;***********************************************
                        	   820: PRCHAR   =  *
00:94C5 48              	   821:   pha
00:94C6 C90A            	   822:   cmp #NL
00:94C8 F00E            	   823:   beq prchar_not_control
00:94CA C920            	   824:   cmp #$20
00:94CC B00A            	   825:   bcs prchar_not_control
00:94CE 48              	   826:   pha
00:94CF A95E            	   827:   lda #'^'
00:94D1 20F695          	   828:   jsr COUT
00:94D4 68              	   829:   pla
00:94D5 18              	   830:   clc
00:94D6 6940            	   831:   adc #$40  ; make 0x01 print as ^A
                        	   832: prchar_not_control:
00:94D8 20F695          	   833:   jsr  COUT
00:94DB 68              	   834:   pla
00:94DC 60              	   835:   rts
                        	   836: ;
                        	   837: ; Prints A in hex
                        	   838: ;
                        	   839: PRBYTE:
00:94DD 48              	   840:   pha
00:94DE 4A              	   841:   lsr
00:94DF 4A              	   842:   lsr
00:94E0 4A              	   843:   lsr
00:94E1 4A              	   844:   lsr
00:94E2 20E894          	   845:   jsr  PRHEXZ    ; first nibble
00:94E5 68              	   846:   pla            ; now do other nibble
                        	   847: PRHEX:
00:94E6 290F            	   848:   and  #$0F
                        	   849: PRHEXZ:
00:94E8 0930            	   850:   ora  #'0'
00:94EA C93A            	   851:   cmp  #'0' + $0A
00:94EC 9002            	   852:   bcc  PRHEX1
00:94EE 6926            	   853:   adc  #$26  ; (carry is set: adding 7 to make 0x0a become 'a')
                        	   854: PRHEX1:
00:94F0 4CC594          	   855:   jmp  PRCHAR
                        	   856: ;
                        	   857: PUTSP    =  *
00:94F3 A920            	   858:   lda  #' '
00:94F5 80F9            	   859:   bra  PRHEX1
                        	   860: ;
                        	   861: ;
                        	   862: ;  PT - put text
                        	   863: ;   Low-order address in A, high-order address in X, count in Y
                        	   864: ;
                        	   865: ;
                        	   866: PT:
00:94F7 8503            	   867:   sta  REG2
00:94F9 8604            	   868:   stx  REG2+1
00:94FB 98              	   869:   tya    ; count of bytes to print
00:94FC AA              	   870:   tax    ; put that into X
00:94FD A000            	   871:   ldy  #0
                        	   872: PT6:
00:94FF B103            	   873:   lda  (REG2),Y    ; next character
00:9501 20F695          	   874:   jsr COUT         ; show it
00:9504 C8              	   875:   iny
00:9505 CA              	   876:   dex
00:9506 D0F7            	   877:   bne  PT6
00:9508 60              	   878:   rts
                        	   879: ;
                        	   880: ;
                        	   881: ;
                        	   882: ;---- token_address --> WORK
                        	   883: ;
                        	   884: TKNWRK   =  *
00:9509 48              	   885:          PHA
00:950A A590            	   886:          LDA  token_address
00:950C 8537            	   887:          STA  WORK
00:950E A591            	   888:          LDA  token_address+1
00:9510 8538            	   889:          STA  WORK+1
00:9512 68              	   890:          PLA
00:9513 60              	   891:          RTS
                        	   892: ;
                        	   893: ;---- WORK --> token_address
                        	   894: ;
                        	   895: WRKTKN   =  *
00:9514 48              	   896:          PHA
00:9515 A537            	   897:          LDA  WORK
00:9517 8590            	   898:          STA  token_address
00:9519 A538            	   899:          LDA  WORK+1
00:951B 8591            	   900:          STA  token_address+1
00:951D 68              	   901:          PLA
00:951E 60              	   902:          RTS
                        	   903: ;
                        	   904: 
                        	   905: 
                        	   906: ;***********************************************
                        	   907: ; MENU, FILE HANDLING
                        	   908: ;***********************************************
                        	   909: ;
00:951F 502D636F64657320	   910: pcodes_ended_message        asciiz  "P-codes ended at $"
00:9527 656E646564206174
00:952F 2024
00:9531 00
00:9532 436F6D70696C6520	   911: compile_finished_message    asciiz  "Compile finished: No errors.\n"
00:953A 66696E6973686564
00:9542 3A204E6F20657272
00:954A 6F72732E0A
00:954F 00
00:9550 53796D626F6C2074	   912: symbol_table_ended_message  asciiz "Symbol table ended at $"
00:9558 61626C6520656E64
00:9560 65642061742024
00:9567 00
00:9568 4E6F2076616C6964	   913: no_valid_compile_message    asciiz  'No valid compile or assemble done before\n'
00:9570 20636F6D70696C65
00:9578 206F722061737365
00:9580 6D626C6520646F6E
00:9588 65206265666F7265
00:9590 0A
00:9591 00
                        	   914: ;
                        	   915: PRBYTECR =  *
00:9592 20DD94          	   916:          JSR  PRBYTE
00:9595 4C6894          	   917:          JMP  CROUT
                        	   918: ;
                        	   919: ;
                        	   920: ;
                        	   921: CHK_VAL  =  *
00:9598 A908            	   922:          lda  #FLAG_VALID_COMPILE
00:959A 0910            	   923:          ora  #FLAG_VALID_ASSEMBLE
00:959C 25BE            	   924:          and  system_flags
00:959E D00A            	   925:          bne  CHK_VAL9
00:95A0 A968            	   926:          lda  #<no_valid_compile_message    ; No valid Compile or Assemble done before
00:95A2 A295            	   927:          ldx  #>no_valid_compile_message
00:95A4 202682          	   928:          jsr  print
00:95A7 4C7282          	   929:          jmp  main_prompt
                        	   930: CHK_VAL9 =  *
                        	   931: BELL1X   =  *          ; no bell yet
00:95AA 60              	   932:          rts
                        	   933: ;
00:95AB 209895          	   934: CHK_RUN  jsr  CHK_VAL
00:95AE A910            	   935:          lda  #FLAG_VALID_ASSEMBLE
00:95B0 25BE            	   936:          and  system_flags
00:95B2 D003            	   937:          bne  run_assembler
00:95B4 4C8DB0          	   938:          jmp  INTERP
                        	   939: run_assembler:
00:95B7 A2C0            	   940:          ldx #RUNNING_STACK_TOP           ; don't use all of stack
00:95B9 9A              	   941:          txs
00:95BA A980            	   942:          lda #FLAG_BRK_REACHED    ; no BRK reached yet
00:95BC 14BE            	   943:          trb system_flags
00:95BE 20C495          	   944:          jsr call_assembler
00:95C1 4C29B1          	   945:          jmp  EX_FINISHD
                        	   946: ;
                        	   947: ;  let's assume they put a RTS at the end of their code
                        	   948: ;
                        	   949: call_assembler:
00:95C4 A91B            	   950:          lda  #<running_message   ; Running
00:95C6 A2B0            	   951:          ldx  #>running_message
00:95C8 202682          	   952:          jsr  print
00:95CB 6C2500          	   953:          jmp (ACT_PCDA)
                        	   954: 
                        	   955: ;
                        	   956: 
                        	   957: ;
                        	   958: ; Get a line, read byte by byte until we get a newline, store in INBUF
                        	   959: ;   returns length in Y - handles backspace, ignores carriage-return
                        	   960: ;
                        	   961: GET_LINE =  *
                        	   962: GETLN1   =  *
00:95CE A000            	   963:   ldy  #0
                        	   964: GET1:
00:95D0 2053CB          	   965:   jsr  CHRIN
00:95D3 C90D            	   966:   cmp  #CR       ; carriage-return?
00:95D5 F0F9            	   967:   beq  GET1       ; ignore it
00:95D7 990002          	   968:   sta  INBUF,Y    ; SAVE IN BUFFER
00:95DA C8              	   969:   iny
00:95DB F016            	   970:   beq  GETLN_OVERFLOW       ; overflow
00:95DD C90A            	   971:   cmp  #NL        ; END OF LINE?
00:95DF F00C            	   972:   beq  GET3       ; yes
00:95E1 C908            	   973:   cmp  #BACKSPACE ; backspace?
00:95E3 D0EB            	   974:   bne  GET1       ; no - keep adding to buffer
                        	   975: ;
                        	   976: ;  here for backspace
                        	   977: ;
00:95E5 88              	   978:   dey  ; get rid of backspace
00:95E6 88              	   979:   dey  ; get rid of character we backspaced over
00:95E7 C0FF            	   980:   cpy  #$FF
00:95E9 F0E3            	   981:   beq  GETLN1   ; if Y underflowed, go back to zero
00:95EB 80E3            	   982:   bra GET1
                        	   983: 
                        	   984: GET3:
00:95ED A900            	   985:   lda  #0
00:95EF 990002          	   986:   sta  INBUF,Y    ; turn newline into 0x00
00:95F2 60              	   987:   rts             ; RETURN
                        	   988: ;
                        	   989: ;  here on INBUF overflow
                        	   990: ;
                        	   991: GETLN_OVERFLOW:
00:95F3 88              	   992:   dey           ; get back to 255 (last byte)
00:95F4 80F7            	   993:   bra  GET3     ; store a zero there
                        	   994: 
                        	   995: 
                        	   996: ;
                        	   997: ;  output a character - saves all registers
                        	   998: ;
                        	   999: COUT:
00:95F6 48              	  1000:   pha
00:95F7 DA              	  1001:   phx
00:95F8 5A              	  1002:   phy
00:95F9 200096          	  1003:   jsr COUT_CALL   ; call the current outputting routine
00:95FC 7A              	  1004:   ply
00:95FD FA              	  1005:   plx
00:95FE 68              	  1006:   pla
00:95FF 60              	  1007:   rts
                        	  1008: 
                        	  1009: 
                        	  1010: COUT_CALL:
00:9600 6C1700          	  1011:   jmp (write_function)
                        	  1012: 
                        	  1013: 

Source: "gpascal.asm"
                        	   180:   .include "errors.inc"

Source: "errors.inc"
                        	     1: 
                        	     2: errors_table:
00:9603 4D656D6F72792066	     3:   asciiz "Memory full"                               ;  1
00:960B 756C6C
00:960E 00
00:960F 436F6E7374616E74	     4:   asciiz "Constant expected"                         ;  2
00:9617 2065787065637465
00:961F 64
00:9620 00
00:9621 3D20657870656374	     5:   asciiz "= expected"                                ;  3
00:9629 6564
00:962B 00
00:962C 4964656E74696669	     6:   asciiz "Identifier expected"                       ;  4
00:9634 6572206578706563
00:963C 746564
00:963F 00
00:9640 2C206F72203A2065	     7:   asciiz ", or : expected"                           ;  5
00:9648 78706563746564
00:964F 00
00:9650 427567          	     8:   asciiz "Bug"                                       ;  6
00:9653 00
00:9654 2A29206F72207D20	     9:   asciiz "*) or } expected"                          ;  7
00:965C 6578706563746564
00:9664 00
00:9665 496E636F72726563	    10:   asciiz "Incorrect string"                          ;  8
00:966D 7420737472696E67
00:9675 00
00:9676 2E20657870656374	    11:   asciiz ". expected"                                ;  9
00:967E 6564
00:9680 00
00:9681 3B20657870656374	    12:   asciiz "; expected"                                ; 10
00:9689 6564
00:968B 00
00:968C 556E6465636C6172	    13:   asciiz "Undeclared identifier"                     ; 11
00:9694 6564206964656E74
00:969C 6966696572
00:96A1 00
00:96A2 496C6C6567616C20	    14:   asciiz "Illegal identifier"                        ; 12
00:96AA 6964656E74696669
00:96B2 6572
00:96B4 00
00:96B5 3A3D206578706563	    15:   asciiz ":= expected"                               ; 13
00:96BD 746564
00:96C0 00
00:96C1 4C69746572616C20	    16:   asciiz "Literal string of zero length"             ; 14
00:96C9 737472696E67206F
00:96D1 66207A65726F206C
00:96D9 656E677468
00:96DE 00
00:96DF 436F6D70696C6572	    17:   asciiz "Compiler limits exceeded"                  ; 15
00:96E7 206C696D69747320
00:96EF 6578636565646564
00:96F7 00
00:96F8 5448454E20657870	    18:   asciiz "THEN expected"                             ; 16
00:9700 6563746564
00:9705 00
00:9706 3B206F7220454E44	    19:   asciiz "; or END expected"                         ; 17
00:970E 2065787065637465
00:9716 64
00:9717 00
00:9718 444F206578706563	    20:   asciiz "DO expected"                               ; 18
00:9720 746564
00:9723 00
00:9724 496E636F72726563	    21:   asciiz "Incorrect symbol"                          ; 19
00:972C 742073796D626F6C
00:9734 00
00:9735 427567          	    22:   asciiz "Bug"                                       ; 20
00:9738 00
00:9739 557365206F662070	    23:   asciiz "Use of procedure identifier in expression" ; 21
00:9741 726F636564757265
00:9749 206964656E746966
00:9751 69657220696E2065
00:9759 787072657373696F
00:9761 6E
00:9762 00
00:9763 2920657870656374	    24:   asciiz ") expected"                                ; 22
00:976B 6564
00:976D 00
00:976E 496C6C6567616C20	    25:   asciiz "Illegal factor"                            ; 23
00:9776 666163746F72
00:977C 00
00:977D 54797065206D6973	    26:   asciiz "Type mismatch"                             ; 24
00:9785 6D61746368
00:978A 00
00:978B 424547494E206578	    27:   asciiz "BEGIN expected"                            ; 25
00:9793 706563746564
00:9799 00
00:979A 4F46206578706563	    28:   asciiz "OF expected"                               ; 26
00:97A2 746564
00:97A5 00
00:97A6 537461636B206675	    29:   asciiz "Stack full"                                ; 27
00:97AE 6C6C
00:97B0 00
00:97B1 544F206F7220444F	    30:   asciiz "TO or DOWNTO expected"                     ; 28
00:97B9 574E544F20657870
00:97C1 6563746564
00:97C6 00
00:97C7 537472696E67206C	    31:   asciiz "String literal too big"                    ; 29
00:97CF 69746572616C2074
00:97D7 6F6F20626967
00:97DD 00
00:97DE 4E756D626572206F	    32:   asciiz "Number out of range"                       ; 30
00:97E6 7574206F66207261
00:97EE 6E6765
00:97F1 00
00:97F2 2820657870656374	    33:   asciiz "( expected"                                ; 31
00:97FA 6564
00:97FC 00
00:97FD 2C20657870656374	    34:   asciiz ", expected"                                ; 32
00:9805 6564
00:9807 00
00:9808 5B20657870656374	    35:   asciiz "[ expected"                                ; 33
00:9810 6564
00:9812 00
00:9813 5D20657870656374	    36:   asciiz "] expected"                                ; 34
00:981B 6564
00:981D 00
00:981E 506172616D657465	    37:   asciiz "Parameters mismatched"                     ; 35
00:9826 7273206D69736D61
00:982E 7463686564
00:9833 00
00:9834 4461746120747970	    38:   asciiz "Data type not recognised"                  ; 36
00:983C 65206E6F74207265
00:9844 636F676E69736564
00:984C 00
00:984D 53796D626F6C2074	    39:   asciiz "Symbol table full"                         ; 37
00:9855 61626C652066756C
00:985D 6C
00:985E 00
00:985F 4475706C69636174	    40:   asciiz "Duplicate identifier"                      ; 38
00:9867 65206964656E7469
00:986F 66696572
00:9873 00
00:9874 56616C7565206578	    41:   asciiz "Value expected"                            ; 39
00:987C 706563746564
00:9882 00
00:9883 496C6C6567616C20	    42:   asciiz "Illegal opcode"                            ; 40
00:988B 6F70636F6465
00:9891 00
00:9892 496C6C6567616C20	    43:   asciiz "Illegal addressing mode"                   ; 41
00:989A 6164647265737369
00:98A2 6E67206D6F6465
00:98A9 00
00:98AA 4272616E6368206F	    44:   asciiz "Branch out of range"                       ; 42
00:98B2 7574206F66207261
00:98BA 6E6765
00:98BD 00
00:98BE 4E656564207A6572	    45:   asciiz "Need zero page address"                    ; 43
00:98C6 6F20706167652061
00:98CE 646472657373
00:98D4 00
00:98D5 4F706572616E6420	    46:   asciiz "Operand too large"                         ; 44
00:98DD 746F6F206C617267
00:98E5 65
00:98E6 00
00:98E7 53796D626F6C2061	    47:   asciiz "Symbol address changed"                    ; 45
00:98EF 6464726573732063
00:98F7 68616E676564
00:98FD 00
00:98FE 4578707265737369	    48:   asciiz "Expression too complex"                    ; 46
00:9906 6F6E20746F6F2063
00:990E 6F6D706C6578
00:9914 00
00:9915 4469766964652062	    49:   asciiz "Divide by zero"                            ; 47
00:991D 79207A65726F
00:9923 00
00:9924 4C6162656C207265	    50:   asciiz "Label required"                            ; 48
00:992C 717569726564
00:9932 00
00:9933 53796D626F6C2074	    51:   asciiz "Symbol table in use"                       ; 49
00:993B 61626C6520696E20
00:9943 757365
00:9946 00
00:9947 4E6F204C4344    	    52:   asciiz "No LCD"                                    ; 50
00:994D 00
00:994E 436F646520616C72	    53:   asciiz "Code already generated"                    ; 51
00:9956 656164792067656E
00:995E 657261746564
00:9964 00
                        	    54: assertion_failed_message:   ; used by Pascal assert function
00:9965 417373657274696F	    55:   asciiz "Assertion failed"                          ; 52
00:996D 6E206661696C6564
00:9975 00
00:9976 557365206F662066	    56:   asciiz "Use of function identifier in statement"   ; 53
00:997E 756E6374696F6E20
00:9986 6964656E74696669
00:998E 657220696E207374
00:9996 6174656D656E74
00:999D 00
00:999E 00              	    57:   dfb 0
                        	    58: 
                        	    59: ;***********************************************
                        	    60: ; DISPLAY ERROR - this does not return to the caller
                        	    61: ;  but to main_prompt
                        	    62: ;  Error number in X
                        	    63: ;***********************************************
00:999F 2A2A2A204572726F	    64: ERRLIT   asciiz  '*** Error: '
00:99A7 723A20
00:99AA 00
                        	    65: 
00:99AB 8635            	    66: ERROR    stx  ERRNO
00:99AD A53F            	    67:          lda  RUNNING
00:99AF F003            	    68:          beq  ERR7
00:99B1 4CE899          	    69:          jmp  ERR6
                        	    70: ERR7     =  *
00:99B4 A51D            	    71:          lda  LIST
00:99B6 D006            	    72:          bne  ERR1
00:99B8 206894          	    73:          jsr  CROUT
00:99BB 20409A          	    74:          jsr  show_current_line
                        	    75: ERR1     =  *
00:99BE A590            	    76:          lda  token_address
00:99C0 38              	    77:          sec
00:99C1 E59C            	    78:          sbc  token_line_start  ; TODO: what about high-order byte?
00:99C3 48              	    79:          pha             ; CHARS UP TO ERROR POINT
00:99C4 A99F            	    80:          lda  #<ERRLIT   ; *** Error
00:99C6 A299            	    81:          ldx  #>ERRLIT
00:99C8 202682          	    82:          jsr  print
00:99CB 68              	    83:          pla
00:99CC 18              	    84:          clc
00:99CD 6901            	    85:          adc   #1
00:99CF 8545            	    86:          sta  TEMP       ; BYTES TO ERROR POINT
00:99D1 AA              	    87:          tax
                        	    88: ERR3     =  *
00:99D2 20F394          	    89:          jsr  PUTSP
00:99D5 CA              	    90:          dex
00:99D6 D0FA            	    91:          bne  ERR3
00:99D8 A95E            	    92:          lda  #'^'
00:99DA 20F695          	    93:          jsr  COUT
00:99DD 206894          	    94:          jsr  CROUT
00:99E0 A209            	    95:          ldx  #9
                        	    96: ERR5     =  *
00:99E2 20F394          	    97:          jsr  PUTSP
00:99E5 CA              	    98:          dex
00:99E6 D0FA            	    99:          bne  ERR5
                        	   100: ERR6     =  *
00:99E8 A903            	   101:   lda #<errors_table
00:99EA 8500            	   102:   sta REG
00:99EC A996            	   103:   lda #>errors_table
00:99EE 8501            	   104:   sta REG+1
00:99F0 A200            	   105:   ldx #0
00:99F2 A000            	   106:   ldy #0
                        	   107: error_next:
00:99F4 E8              	   108:   inx
                        	   109: error_loop:
00:99F5 E435            	   110:   cpx ERRNO
00:99F7 F02A            	   111:   beq error_found
                        	   112: error_find_next:
00:99F9 B100            	   113:   lda (REG),Y
00:99FB 48              	   114:   pha
00:99FC E600            	   115:   inc REG
00:99FE D002            	   116:   bne error1
00:9A00 E601            	   117:   inc REG+1
                        	   118: error1:
00:9A02 68              	   119:   pla           ; get the previous byte
00:9A03 D0F4            	   120:   bne error_find_next
00:9A05 B100            	   121:   lda (REG),Y   ; a null after a null?
00:9A07 F002            	   122:   beq error_not_found
00:9A09 80E9            	   123:   bra error_next  ; we got a null, so add 1 to our current error number (X)
                        	   124: 
                        	   125: error_not_found:
00:9A0B A930            	   126:   lda #<error_not_found_message
00:9A0D A29A            	   127:   ldx #>error_not_found_message
00:9A0F 202682          	   128:   jsr print
00:9A12 A535            	   129:   lda ERRNO
00:9A14 8500            	   130:   sta REG
00:9A16 6401            	   131:   stz REG+1
00:9A18 6402            	   132:   stz REGB
00:9A1A 209293          	   133:   jsr display_in_decimal
00:9A1D 206894          	   134:   jsr CROUT
00:9A20 4C7282          	   135:   jmp main_prompt
                        	   136: 
                        	   137: error_found:
00:9A23 A500            	   138:   lda REG
00:9A25 A601            	   139:   ldx REG+1
00:9A27 202682          	   140:   jsr print
00:9A2A 206894          	   141:   jsr CROUT
00:9A2D 4C7282          	   142:   jmp  main_prompt
                        	   143: 
00:9A30 556E6B6E6F776E20	   144: error_not_found_message asciiz "Unknown error: "
00:9A38 6572726F723A20
00:9A3F 00
                        	   145: 
                        	   146: show_current_line:
00:9A40 A928            	   147:   lda #'('
00:9A42 20F695          	   148:   jsr COUT
00:9A45 A524            	   149:   lda PCODE+1
00:9A47 20DD94          	   150:   jsr PRBYTE
00:9A4A A523            	   151:   lda PCODE
00:9A4C 20DD94          	   152:   jsr PRBYTE
00:9A4F A929            	   153:   lda #')'
00:9A51 20F695          	   154:   jsr COUT
00:9A54 20F394          	   155:   jsr PUTSP
00:9A57 20358C          	   156:   jsr show_current_line_number
00:9A5A A59C            	   157:   lda token_line_start
00:9A5C 85A6            	   158:   sta mem_move_src
00:9A5E A59D            	   159:   lda token_line_start+1
00:9A60 85A7            	   160:   sta mem_move_src+1
                        	   161: 
                        	   162: show_current_line_loop:
00:9A62 A000            	   163:   ldy #0
00:9A64 B1A6            	   164:   lda (mem_move_src),Y
00:9A66 F01D            	   165:   beq show_current_line_done
00:9A68 C90A            	   166:   cmp #NL
00:9A6A F019            	   167:   beq show_current_line_done
00:9A6C C920            	   168:   cmp #$20
00:9A6E B00A            	   169:   bcs show_current_line_loop_print_one_character
00:9A70 48              	   170:   pha
00:9A71 A95E            	   171:   lda #'^'
00:9A73 20F695          	   172:   jsr COUT
00:9A76 68              	   173:   pla
00:9A77 18              	   174:   clc
00:9A78 6940            	   175:   adc #$40  ; make 0x01 print as ^A
                        	   176: show_current_line_loop_print_one_character:
00:9A7A 20F695          	   177:   jsr COUT    ; show that byte
00:9A7D E6A6            	   178:   inc mem_move_src
00:9A7F D0E1            	   179:   bne show_current_line_loop
00:9A81 E6A7            	   180:   inc mem_move_src+1
00:9A83 80DD            	   181:   bra show_current_line_loop
                        	   182: 
                        	   183: show_current_line_done:
00:9A85 206894          	   184:   jsr CROUT
00:9A88 60              	   185:   rts
                        	   186: 

Source: "gpascal.asm"
                        	   181:   .include "assembler.inc"

Source: "assembler.inc"
                        	     1: ;***********************************************
                        	     2: ;
                        	     3: ; Assembler
                        	     4: ;
                        	     5: ;***********************************************
                        	     6: 
                        	     7: ;***********************************************
                        	     8: ; Assembler operand types
                        	     9: ;***********************************************
                        	    10: 
                        	    11: ASS_OPERAND_ABSOLUTE                           =  1      ; a
                        	    12: ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT          =  2      ; (a,x)
                        	    13: ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X            =  3      ; a,x
                        	    14: ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y            =  4      ; a,y
                        	    15: ASS_OPERAND_ABSOLUTE_INDIRECT                  =  5      ; (a)
                        	    16: ASS_OPERAND_ACCUMULATOR_A                      =  6      ; A
                        	    17: ASS_OPERAND_IMMEDIATE                          =  7      ; #
                        	    18: ASS_OPERAND_IMPLIED                            =  8      ; i
                        	    19: ASS_OPERAND_PROGRAM_COUNTER_RELATIVE           =  9      ; r
                        	    20: ASS_OPERAND_STACK                              = 10      ; s
                        	    21: ASS_OPERAND_ZERO_PAGE                          = 11      ; zp
                        	    22: ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT         = 12      ; (zp,x)
                        	    23: ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X           = 13      ; zp,x
                        	    24: ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y           = 14      ; zp,y
                        	    25: ASS_OPERAND_ZERO_PAGE_INDIRECT                 = 15      ; (zp)
                        	    26: ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y  = 16      ; (zp),y
                        	    27: ASS_OPERAND_STRING                             = 17      ; "But does it get goat's blood out?"
                        	    28: ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE             = 18      ; zp,r
                        	    29: 
                        	    30: ;
                        	    31: ;  Entry point for assembler
                        	    32: ;
                        	    33: ASSEMBLE:
                        	    34: 
00:9A89 A2FF            	    35:    ldx  #NEW_STK
00:9A8B 9A              	    36:    txs    ; set stack back to 0xFF
00:9A8C 6476            	    37:    stz  ASS_PASS  ; first pass
00:9A8E 201A94          	    38:    jsr  INIT       ; sets up pointers, calls LINE
00:9A91 20BBAC          	    39:    jsr  add_assembler_library_functions  ; add our inbuilt functions to the symbol table
00:9A94 8005            	    40:    bra  ASSEMBLE_PASS
                        	    41: 
                        	    42: ASSEMBLE_SECOND_PASS:
00:9A96 E676            	    43:    inc  ASS_PASS
00:9A98 202694          	    44:    jsr  INIT_SECOND_PASS    ; don't re-initialise the symbol table
                        	    45: ASSEMBLE_PASS:
00:9A9B 64A2            	    46:    stz  current_line  ; we'll got for zero, not one
                        	    47: 
00:9A9D A902            	    48:    lda  #FLAG_ASSEMBLING
00:9A9F 04BE            	    49:    tsb  system_flags
                        	    50: 
                        	    51: ;
                        	    52: ;  no listing yet
                        	    53: ;
00:9AA1 642E            	    54:    stz  DCODE
00:9AA3 641D            	    55:    stz  LIST
00:9AA5 6442            	    56:    stz  SYNTAX
00:9AA7 6482            	    57:    stz  show_symbols
                        	    58: ;
                        	    59: ; zero line count
                        	    60: ;
00:9AA9 6419            	    61:    stz  LINE_CNT
00:9AAB 641A            	    62:    stz  LINE_CNT+1
                        	    63: 
                        	    64: ;
                        	    65: ;  and emitted bytes count
                        	    66: ;
00:9AAD 6477            	    67:    stz ass_emit_bytes
00:9AAF 6478            	    68:    stz ass_emit_bytes+1
                        	    69: 
                        	    70: ;
                        	    71: ; no previous token
                        	    72: ;
00:9AB1 6493            	    73:    stz  token_type
00:9AB3 800E            	    74:    bra ass_line
                        	    75: 
                        	    76: ass_finish_line:
00:9AB5 A593            	    77:    lda token_type
00:9AB7 C90A            	    78:    cmp #NL
00:9AB9 F008            	    79:    beq ass_line
00:9ABB A213            	    80:    ldx #19    ; Incorrect Symbol
00:9ABD 4CEBA0          	    81:    jmp ass_error
                        	    82: 
                        	    83: ass_done_jump:
00:9AC0 4CBE9D          	    84:    jmp ass_done
                        	    85: ;
                        	    86: ;  here for the start of a line
                        	    87: ;
                        	    88: ass_line:
00:9AC3 A576            	    89:   lda ASS_PASS    ; only showing codes on 2nd pass
00:9AC5 F00B            	    90:   beq ass_line1
00:9AC7 A56F            	    91:   lda ASS_EMIT_COUNT  ; only need a newline if we actually output a code
00:9AC9 F007            	    92:   beq ass_line1
00:9ACB A52E            	    93:   lda DCODE           ; is showing codes on?
00:9ACD F003            	    94:   beq ass_line1
00:9ACF 206894          	    95:   jsr CROUT
                        	    96: ass_line1:
00:9AD2 A000            	    97:   ldy #0
00:9AD4 B18E            	    98:   lda (token_start),y ; quick test so we don't list a non-existent line
00:9AD6 F0E8            	    99:   beq ass_done_jump
                        	   100: 
00:9AD8 A58E            	   101:   lda token_start
00:9ADA 859C            	   102:   sta token_line_start
00:9ADC A58F            	   103:   lda token_start+1
00:9ADE 859D            	   104:   sta token_line_start+1
00:9AE0 2073CC          	   105:   jsr token_line        ; list the next line
                        	   106: 
00:9AE3 646B            	   107:   stz ASS_OPERAND   ; no operand yet
00:9AE5 646F            	   108:   stz ASS_EMIT_COUNT
00:9AE7 6483            	   109:   stz ass_current_label
00:9AE9 6484            	   110:   stz ass_current_label+1
                        	   111: 
00:9AEB 20D3CB          	   112:   jsr get_token
                        	   113: 
00:9AEE C949            	   114:   cmp #TOKEN_IDENTIFIER  ; could be a label if in column 1
00:9AF0 F011            	   115:   beq ass_identifier
00:9AF2 C93D            	   116:   cmp #'='               ; = directive is OK
00:9AF4 F00D            	   117:   beq ass_identifier
                        	   118: 
00:9AF6 C90A            	   119:   cmp #NL
00:9AF8 F0C9            	   120:   beq ass_line
                        	   121: 
00:9AFA C900            	   122:   cmp #0
00:9AFC F0C2            	   123:   beq ass_done_jump
                        	   124: 
                        	   125: ass_bad_identifier:
00:9AFE A204            	   126:   ldx #4      ; Identifier expected
00:9B00 4CEBA0          	   127:   JMP ass_error
                        	   128: 
                        	   129: ass_identifier:
                        	   130: 
                        	   131: ;
                        	   132: ;  if the identifier is at the start of the line, it is a label, not an opcode
                        	   133: ;
00:9B03 A590            	   134:   lda token_address
00:9B05 C59C            	   135:   cmp token_line_start
00:9B07 D063            	   136:   bne ass_opcode
00:9B09 A591            	   137:   lda token_address+1
00:9B0B C59D            	   138:   cmp token_line_start+1
00:9B0D D05D            	   139:   bne ass_opcode
                        	   140: 
00:9B0F A593            	   141:   lda token_type         ; can't have = as an identifier
00:9B11 C93D            	   142:   cmp #'='               ; or "="
00:9B13 F0E9            	   143:   beq ass_bad_identifier
                        	   144: 
                        	   145: ;
                        	   146: ;  here for label - on the first pass, add it to the symbol table, on the second pass look it up
                        	   147: ;
00:9B15 A576            	   148:   lda ASS_PASS
00:9B17 D014            	   149:   bne ass_lookup_existing_label
                        	   150: ;
                        	   151: ;  here for first pass
                        	   152: ;
00:9B19 207ABC          	   153:   jsr CHKDUP
                        	   154: ;
                        	   155: ; not a duplicate - add it
                        	   156: ;
00:9B1C A523            	   157:   lda PCODE
00:9B1E 8594            	   158:   sta token_value
00:9B20 A524            	   159:   lda PCODE+1
00:9B22 8595            	   160:   sta token_value+1
00:9B24 6496            	   161:   stz token_value+2
00:9B26 A943            	   162:   lda #SYMBOL_CONSTANT
00:9B28 20D3BB          	   163:   jsr ADDSYM
00:9B2B 8016            	   164:   bra ass_added_symbol
                        	   165: 
                        	   166: ;
                        	   167: ;  here for second pass
                        	   168: ;
                        	   169: ass_lookup_existing_label:
00:9B2D 2057BB          	   170:   jsr SEARCH  ; look it up
00:9B30 D005            	   171:   bne ass_lookup_save_address  ; it should be!
00:9B32 A206            	   172:   ldx #6  ; ERROR: bug
00:9B34 4CEBA0          	   173:   jmp ass_error
                        	   174: 
                        	   175: ass_lookup_save_address:
00:9B37 A594            	   176:   lda token_value
00:9B39 8573            	   177:   sta ASS_VALUE
00:9B3B A595            	   178:   lda token_value+1
00:9B3D 8574            	   179:   sta ASS_VALUE+1
00:9B3F A596            	   180:   lda token_value+2
00:9B41 8575            	   181:   sta ASS_VALUE+2
                        	   182: 
                        	   183: ;
                        	   184: ;  the symbol has either been added, or looked up to make sure it is still there
                        	   185: ;
                        	   186: ass_added_symbol:
                        	   187: 
                        	   188: ;
                        	   189: ;  remember its address in case we have an EQU directive
                        	   190: ;
00:9B43 A540            	   191:   lda SYMITM
00:9B45 8583            	   192:   sta ass_current_label
00:9B47 A541            	   193:   lda SYMITM+1
00:9B49 8584            	   194:   sta ass_current_label+1
                        	   195: 
                        	   196: ;
                        	   197: ;  get whatever is after the label
                        	   198: ;
00:9B4B 20D3CB          	   199:   jsr get_token
00:9B4E C93A            	   200:   cmp #':'
00:9B50 D003            	   201:   bne ass_not_colon
00:9B52 20D3CB          	   202:   jsr get_token  ; skip the colon
                        	   203: ass_not_colon:
00:9B55 C90A            	   204:   cmp #NL     ; newline means this is just a label line
00:9B57 D003            	   205:   bne ass_not_colon2
00:9B59 4CB59A          	   206:   jmp ass_finish_line
                        	   207: 
                        	   208: ass_not_colon2:
00:9B5C C949            	   209:   cmp #TOKEN_IDENTIFIER  ; should be an opcode now
00:9B5E F00C            	   210:   beq ass_opcode
00:9B60 C93D            	   211:   cmp #'='               ; = directive is OK
00:9B62 F008            	   212:   beq ass_opcode
                        	   213: 
                        	   214: ass_illegal_opcode:
00:9B64 20DD94          	   215:   jsr PRBYTE
00:9B67 A228            	   216:   ldx #40      ; ERROR: illegal opcode
00:9B69 4CEBA0          	   217:   JMP ass_error
                        	   218: 
                        	   219: ass_opcode:
                        	   220: 
                        	   221: ;
                        	   222: ;  this will be our assembler mnemonic or directive so save its start point and length
                        	   223: ;
                        	   224: 
00:9B6C A690            	   225:   ldx token_address
00:9B6E 866C            	   226:   stx OPCODE
00:9B70 A691            	   227:   ldx token_address+1
00:9B72 866D            	   228:   stx OPCODE+1
00:9B74 A692            	   229:   ldx token_length
00:9B76 866E            	   230:   stx OPCODE_LEN
                        	   231: 
                        	   232: ;
                        	   233: ;  if we had a label on the line, check its address hasn't changed (on the second pass)
                        	   234: ;   UNLESS it is an EQU directive in which case it probably did change
                        	   235: ;
00:9B78 A576            	   236:   lda ASS_PASS
00:9B7A F046            	   237:   beq ass_opcode2
00:9B7C A583            	   238:   lda ass_current_label
00:9B7E 0584            	   239:   ora ass_current_label+1   ; was there a label?
00:9B80 F040            	   240:   beq ass_opcode2    ; nope
00:9B82 A593            	   241:   lda token_type
00:9B84 C93D            	   242:   cmp #'='
00:9B86 F03A            	   243:   beq ass_opcode2   ; don't check on "=" directive
00:9B88 A592            	   244:   lda token_length
00:9B8A C903            	   245:   cmp #3
00:9B8C D034            	   246:   bne ass_opcode2   ; can't be EQU
                        	   247: ;
                        	   248: ; this is truly crap, but I am feeling lazy
                        	   249: ;
00:9B8E A000            	   250:   ldy #0
00:9B90 B190            	   251:   lda (token_address),y
00:9B92 200492          	   252:   jsr MAKE_UPPER
00:9B95 C945            	   253:   cmp #'E'
00:9B97 D014            	   254:   bne ass_check_label_changed
00:9B99 C8              	   255:   iny
00:9B9A B190            	   256:   lda (token_address),y
00:9B9C 200492          	   257:   jsr MAKE_UPPER
00:9B9F C951            	   258:   cmp #'Q'
00:9BA1 D00A            	   259:   bne ass_check_label_changed
00:9BA3 C8              	   260:   iny
00:9BA4 B190            	   261:   lda (token_address),y
00:9BA6 200492          	   262:   jsr MAKE_UPPER
00:9BA9 C955            	   263:   cmp #'U'
00:9BAB F015            	   264:   beq ass_opcode2
                        	   265: 
                        	   266: ;
                        	   267: ;  we looked up the label earlier, when it was the current token,
                        	   268: ;   and we saved its value in ASS_VALUE
                        	   269: ;
                        	   270: 
                        	   271: ass_check_label_changed:
00:9BAD A523            	   272:   lda PCODE
00:9BAF C573            	   273:   cmp ASS_VALUE
00:9BB1 D00A            	   274:   bne ass_symbol_address_changed
00:9BB3 A524            	   275:   lda PCODE+1
00:9BB5 C574            	   276:   cmp ASS_VALUE+1
00:9BB7 D004            	   277:   bne ass_symbol_address_changed
00:9BB9 A575            	   278:   lda ASS_VALUE+2   ; 3rd byte should be zero
00:9BBB F005            	   279:   beq ass_opcode2
                        	   280: 
                        	   281: ass_symbol_address_changed:
00:9BBD A22D            	   282:   ldx #45     ; ERROR: Symbol address changed
00:9BBF 4CEBA0          	   283:   jmp ass_error
                        	   284: 
                        	   285: 
                        	   286: 
                        	   287: ass_opcode2:
                        	   288: ;
                        	   289: ;  look up operand
                        	   290: ;
                        	   291: 
00:9BC2 20D3CB          	   292:   jsr get_token
00:9BC5 C90A            	   293:   cmp #NL           ; or end of line?
00:9BC7 D00D            	   294:   bne ass_operand
                        	   295: 
                        	   296: ;
                        	   297: ;  here when the opcode is followed by (spaces) or a newline
                        	   298: ;
00:9BC9 A908            	   299:   lda #ASS_OPERAND_IMPLIED
00:9BCB 856B            	   300:   sta ASS_OPERAND
00:9BCD 20159D          	   301:   jsr opcode_lookup
00:9BD0 20019E          	   302:   jsr ass_check_no_more_tokens
                        	   303: ass_finish_lineJ:
00:9BD3 4CB59A          	   304:   jmp ass_finish_line
                        	   305: 
                        	   306: ass_operand:
00:9BD6 C923            	   307:   cmp #'#'  ; immediate?
00:9BD8 F01B            	   308:   beq ass_immediate
00:9BDA C928            	   309:   cmp #'('  ; indirect?
00:9BDC F02A            	   310:   beq ass_indirect
00:9BDE C949            	   311:   cmp #TOKEN_IDENTIFIER
00:9BE0 F02F            	   312:   beq ass_identifier_operand
00:9BE2 C922            	   313:   cmp #TOKEN_STRING
00:9BE4 F002            	   314:   beq ass_string
                        	   315: ;
                        	   316: ;  here for some kind of numeric address
                        	   317: ;
00:9BE6 804A            	   318:   bra ass_operand_value
                        	   319: 
                        	   320: ;
                        	   321: ;  Here for a string as an operand, should be a compiler directive, eg.  ASC "Hello, world"
                        	   322: ;
                        	   323: ass_string:
00:9BE8 A911            	   324:   lda #ASS_OPERAND_STRING
00:9BEA 856B            	   325:   sta ASS_OPERAND
00:9BEC 20159D          	   326:   jsr opcode_lookup
00:9BEF 20D3CB          	   327:   jsr get_token  ; NOW get the next token
00:9BF2 4CB59A          	   328:   jmp ass_finish_line
                        	   329: 
                        	   330: ;
                        	   331: ;  immediate, that is:  #<expression>
                        	   332: ;
                        	   333: ass_immediate:
00:9BF5 A907            	   334:   lda #ASS_OPERAND_IMMEDIATE
00:9BF7 856B            	   335:   sta ASS_OPERAND
00:9BF9 20D3CB          	   336:   jsr get_token
00:9BFC 20189F          	   337:   jsr ass_get_value
00:9BFF 20019E          	   338:   jsr ass_check_no_more_tokens
00:9C02 20159D          	   339:   jsr opcode_lookup
00:9C05 4CB59A          	   340:   jmp ass_finish_line
                        	   341: 
                        	   342: ;
                        	   343: ;  indirect, that is: (expression) OR (expression,X) OR (expression),Y
                        	   344: ;
                        	   345: ass_indirect:
00:9C08 A905            	   346:   lda #ASS_OPERAND_ABSOLUTE_INDIRECT  ; first guess
00:9C0A 856B            	   347:   sta ASS_OPERAND
00:9C0C 20D3CB          	   348:   jsr get_token    ; skip the bracket
00:9C0F 8021            	   349:   bra ass_operand_value
                        	   350: 
                        	   351: ;
                        	   352: ;  some sort of identifier, possibly the start of an expression or maybe just "A"
                        	   353: ;
                        	   354: ass_identifier_operand:
                        	   355: 
                        	   356: ;
                        	   357: ;  see if the operand is just the letter "A"
                        	   358: ;
00:9C11 A592            	   359:   lda token_length
00:9C13 C901            	   360:   cmp #1
00:9C15 D01B            	   361:   bne ass_operand_value
00:9C17 A000            	   362:   ldy #0
00:9C19 B190            	   363:   lda (token_address),Y
00:9C1B 200492          	   364:   jsr MAKE_UPPER
00:9C1E C941            	   365:   cmp #'A'
00:9C20 D010            	   366:   bne ass_operand_value
00:9C22 A906            	   367:   lda #ASS_OPERAND_ACCUMULATOR_A
00:9C24 856B            	   368:   sta ASS_OPERAND
00:9C26 20D3CB          	   369:   jsr get_token  ; skip past A
00:9C29 20019E          	   370:   jsr ass_check_no_more_tokens
00:9C2C 20159D          	   371:   jsr opcode_lookup
00:9C2F 4CB59A          	   372:   jmp ass_finish_line
                        	   373: 
                        	   374: ;
                        	   375: ;  a number or identifier - evaluate as an expression
                        	   376: ;
                        	   377: ass_operand_value:
                        	   378: 
00:9C32 A593            	   379:   lda token_type ; get token back
00:9C34 20189F          	   380:   jsr ass_get_value  ; should have some sort of address now in VALUE
                        	   381: ;
                        	   382: ;  we come back with the first non-value token loaded in TOKEN
                        	   383: ;  now see if we originally had a bracket, so this must be one of those indirect things
                        	   384: ;
00:9C37 A56B            	   385:   lda ASS_OPERAND
00:9C39 C905            	   386:   cmp #ASS_OPERAND_ABSOLUTE_INDIRECT
00:9C3B D02D            	   387:   bne ass_value_not_indirectJ
00:9C3D A593            	   388:   lda token_type   ; now we should have a comma or a bracket
00:9C3F C929            	   389:   cmp #')'
00:9C41 F02F            	   390:   beq ass_indirect_with_bracket
                        	   391: ;
                        	   392: ;  We had an opening bracket but not a closing bracket. Must be a comma then
                        	   393: ;
                        	   394: 
00:9C43 A92C            	   395:   lda #','
00:9C45 A220            	   396:   ldx #32  ; ERROR: , expected
00:9C47 20E5D1          	   397:   jsr CHKTKN
                        	   398: ;
                        	   399: ;  now we must have X
                        	   400: ;
00:9C4A 20AE9C          	   401:   jsr ass_check_we_have_x_or_y
00:9C4D 901E            	   402:   bcc ass_bad_indirect
00:9C4F C958            	   403:   cmp #'X'
00:9C51 D01A            	   404:   bne ass_bad_indirect
00:9C53 A902            	   405:   lda #ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
00:9C55 856B            	   406:   sta ASS_OPERAND
00:9C57 A929            	   407:   lda #')'
00:9C59 A216            	   408:   ldx #22  ; ERROR: ) expected
00:9C5B 20D5D1          	   409:   jsr GETCHK
00:9C5E 20D3CB          	   410:   jsr get_token
00:9C61 20019E          	   411:   jsr ass_check_no_more_tokens
00:9C64 20159D          	   412:   jsr opcode_lookup
00:9C67 4CB59A          	   413:   jmp ass_finish_line
                        	   414: 
00:9C6A 4CCC9C          	   415: ass_value_not_indirectJ jmp ass_value_not_indirect
                        	   416: 
                        	   417: ass_bad_indirect:
00:9C6D A229            	   418:   ldx #41  ; ERROR: illegal addressing mode
00:9C6F 4CEBA0          	   419:   jmp ass_error
                        	   420: 
                        	   421: 
                        	   422: ;
                        	   423: ;  we have some sort of indirect expression followed by a bracket, so see if there is ",Y" after it
                        	   424: ;
                        	   425: ass_indirect_with_bracket:
                        	   426: ;
                        	   427: ;  can only be (a), (zp) or (zp),y
                        	   428: ;
00:9C72 20D3CB          	   429:   jsr get_token
00:9C75 C92C            	   430:   cmp #','
00:9C77 F00D            	   431:   beq ass_zp_indirect_indexed
00:9C79 20019E          	   432:   jsr ass_check_no_more_tokens
00:9C7C A905            	   433:   lda #ASS_OPERAND_ABSOLUTE_INDIRECT
00:9C7E 856B            	   434:   sta ASS_OPERAND
00:9C80 20159D          	   435:   jsr opcode_lookup
00:9C83 4CB59A          	   436:   jmp ass_finish_line
                        	   437: 
                        	   438: 
                        	   439: ;
                        	   440: ;  For indirect followed by a comma, we must have Y and nothing else
                        	   441: ;  Also, the operand must be a zero-page address
                        	   442: ;
                        	   443: ass_zp_indirect_indexed:
00:9C86 20AE9C          	   444:   jsr ass_check_we_have_x_or_y
00:9C89 90E2            	   445:   bcc ass_bad_indirect
00:9C8B C959            	   446:   cmp #'Y'
00:9C8D D0DE            	   447:   bne ass_bad_indirect
00:9C8F A574            	   448:   lda ASS_VALUE+1
00:9C91 D014            	   449:   bne ass_bad_zp_indirect_indexed
00:9C93 A575            	   450:   lda ASS_VALUE+2
00:9C95 D010            	   451:   bne ass_bad_zp_indirect_indexed
00:9C97 A910            	   452:   lda #ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
00:9C99 856B            	   453:   sta ASS_OPERAND
00:9C9B 20D3CB          	   454:   jsr get_token  ; skip the Y
00:9C9E 20019E          	   455:   jsr ass_check_no_more_tokens
00:9CA1 20159D          	   456:   jsr opcode_lookup
00:9CA4 4CB59A          	   457:   jmp ass_finish_line
                        	   458: 
                        	   459: ass_bad_zp_indirect_indexed:
00:9CA7 A22B            	   460:   ldx #43
00:9CA9 4CEBA0          	   461:   jmp ass_error
                        	   462: 
                        	   463: ass_not_x_or_y:
00:9CAC 18              	   464:   clc
00:9CAD 60              	   465:   rts
                        	   466: 
                        	   467: ;
                        	   468: ;  we had (<expression>),<something> so check that <something> is X or Y
                        	   469: ;   sets carry if it is
                        	   470: ;
                        	   471: ass_check_we_have_x_or_y:
00:9CAE 20D3CB          	   472:   jsr get_token
00:9CB1 C949            	   473:   cmp #TOKEN_IDENTIFIER
00:9CB3 D0F7            	   474:   bne ass_not_x_or_y
00:9CB5 A592            	   475:   lda token_length
00:9CB7 C901            	   476:   cmp #1
00:9CB9 D0F1            	   477:   bne ass_not_x_or_y
00:9CBB A000            	   478:   ldy #0
00:9CBD B190            	   479:   lda (token_address),y
00:9CBF 200492          	   480:   jsr MAKE_UPPER
00:9CC2 C959            	   481:   cmp #'Y'
00:9CC4 F004            	   482:   beq ass_check_we_have_x_or_y_ok
00:9CC6 C958            	   483:   cmp #'X'
00:9CC8 D0E2            	   484:   bne ass_not_x_or_y
                        	   485: ass_check_we_have_x_or_y_ok:
00:9CCA 38              	   486:   sec
00:9CCB 60              	   487:   rts
                        	   488: 
                        	   489: ;
                        	   490: ;  we had a non-indirect expression, so was it followed by a comma?
                        	   491: ;
                        	   492: 
                        	   493: ass_value_not_indirect:
00:9CCC A593            	   494:   lda token_type
00:9CCE C92C            	   495:   cmp #','
00:9CD0 F00D            	   496:   beq ass_indexed
00:9CD2 A901            	   497:   lda #ASS_OPERAND_ABSOLUTE
00:9CD4 856B            	   498:   sta ASS_OPERAND
                        	   499: ass_value_done:
00:9CD6 20019E          	   500:   jsr ass_check_no_more_tokens
00:9CD9 20159D          	   501:   jsr opcode_lookup
00:9CDC 4CB59A          	   502:   jmp ass_finish_line
                        	   503: 
                        	   504: ;
                        	   505: ;  <expression>,X or <expression>,Y is what we are expecting here
                        	   506: ;
                        	   507: ;  OR: in the case of BBR0 ... BBR7 and BBS0 ... BBS7 : another expression
                        	   508: ;
                        	   509: 
                        	   510: ass_indexed:
                        	   511: ;
                        	   512: ;  save the value in case we find a second one
                        	   513: ;
                        	   514: ;  checking for another one may change VALUE so we do this now
                        	   515: ;
00:9CDF A500            	   516:   lda VALUE
00:9CE1 8506            	   517:   sta REMAIN
00:9CE3 A501            	   518:   lda VALUE+1
00:9CE5 8507            	   519:   sta REMAIN+1
00:9CE7 A502            	   520:   lda VALUE+2
00:9CE9 8508            	   521:   sta REMAIN+2
00:9CEB 20AE9C          	   522:   jsr ass_check_we_have_x_or_y
00:9CEE 9016            	   523:   bcc ass_absolute_another_value
00:9CF0 C958            	   524:   cmp #'X'
00:9CF2 F009            	   525:   beq ass_indexed_x
00:9CF4 A904            	   526:   lda #ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
00:9CF6 856B            	   527:   sta ASS_OPERAND
00:9CF8 20D3CB          	   528:   jsr get_token ; skip the Y
00:9CFB 80D9            	   529:   bra ass_value_done
                        	   530: ass_indexed_x:
00:9CFD A903            	   531:   lda #ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
00:9CFF 856B            	   532:   sta ASS_OPERAND
00:9D01 20D3CB          	   533:   jsr get_token ; skip the X
00:9D04 80D0            	   534:   bra ass_value_done
                        	   535: 
                        	   536: ;
                        	   537: ;  this is hopefully something like BBR0 $42,foo
                        	   538: ;   so we need to evaluate foo
                        	   539: ;
                        	   540: ass_absolute_another_value:
00:9D06 A593            	   541:   lda token_type ; get token back
00:9D08 20189F          	   542:   jsr ass_get_value  ; should have some sort of address now in VALUE
                        	   543: ;  jsr ass_check_no_more_tokens
00:9D0B A912            	   544:   lda #ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE
00:9D0D 856B            	   545:   sta ASS_OPERAND
00:9D0F 20159D          	   546:   jsr opcode_lookup
00:9D12 4CB59A          	   547:   jmp ass_finish_line
                        	   548: 
                        	   549: 
                        	   550: ;
                        	   551: ;  look up opcode
                        	   552: ;
                        	   553: opcode_lookup:
                        	   554:   ; the opcode we are looking up
00:9D15 A56C            	   555:   lda OPCODE
00:9D17 8500            	   556:   sta SRCE
00:9D19 A56D            	   557:   lda OPCODE+1
00:9D1B 8501            	   558:   sta SRCE+1
00:9D1D 6472            	   559:   stz ASS_COUNT   ; count of matches
                        	   560: ;
                        	   561: ;  get the address of our table of tables
                        	   562: ;
00:9D1F A95F            	   563:   lda #<OPCODE_LOOKUP_TABLE
00:9D21 8570            	   564:   sta ASS_OPCODE_WORK
00:9D23 A9A1            	   565:   lda #>OPCODE_LOOKUP_TABLE
00:9D25 8571            	   566:   sta ASS_OPCODE_WORK+1
                        	   567: opcode_lookup_loop:
00:9D27 A000            	   568:   ldy #OPCODE_LOOKUP_OPCODE_LENGTH
00:9D29 B170            	   569:   lda (ASS_OPCODE_WORK),Y       ; get opcode length
00:9D2B F058            	   570:   beq opcode_lookup_loop_done   ; end of table
00:9D2D C56E            	   571:   cmp OPCODE_LEN                ; right length?
00:9D2F F00F            	   572:   beq opcode_lookup_correct_length ; yes
                        	   573: ;
                        	   574: ; no, try the next table item
                        	   575: ;
                        	   576: opcode_lookup_next_table:
00:9D31 18              	   577:   clc
00:9D32 A570            	   578:   lda ASS_OPCODE_WORK
00:9D34 6906            	   579:   adc #OPCODE_LOOKUP_TABLE_SIZE  ; onto next item
00:9D36 8570            	   580:   sta ASS_OPCODE_WORK
00:9D38 A571            	   581:   lda ASS_OPCODE_WORK+1
00:9D3A 6900            	   582:   adc #0
00:9D3C 8571            	   583:   sta ASS_OPCODE_WORK+1
00:9D3E 80E7            	   584:   bra opcode_lookup_loop
                        	   585: opcode_lookup_correct_length:
00:9D40 A002            	   586:   ldy #OPCODE_LOOKUP_OPCODE_TABLE
00:9D42 B170            	   587:   lda (ASS_OPCODE_WORK),Y ; get table address low-order byte
00:9D44 8503            	   588:   sta DEST
00:9D46 C8              	   589:   iny
00:9D47 B170            	   590:   lda (ASS_OPCODE_WORK),Y ; get table address high-order byte
00:9D49 8504            	   591:   sta DEST+1
00:9D4B 2089A0          	   592:   jsr ass_lookup_loop
00:9D4E 90E1            	   593:   bcc opcode_lookup_next_table  ; not found
00:9D50 AA              	   594:   tax   ; save the machine code byte
00:9D51 E672            	   595:   inc ASS_COUNT
00:9D53 A001            	   596:   ldy #OPCODE_LOOKUP_OPERAND_TYPE
00:9D55 A56B            	   597:   lda ASS_OPERAND         ; get wanted type of operand?
00:9D57 D170            	   598:   cmp (ASS_OPCODE_WORK),Y ; compare to operand type in table
00:9D59 F013            	   599:   beq opcode_lookup_correct_operand  ; yes
00:9D5B C906            	   600:   cmp #ASS_OPERAND_ACCUMULATOR_A  ; see if in range 1 to 5
00:9D5D B0D2            	   601:   bcs opcode_lookup_next_table
                        	   602: ;
                        	   603: ;  so if we have a so-called ASS_OPERAND_ABSOLUTE (with various indexing modes)
                        	   604: ;  see if we can match on ASS_OPERAND_ZERO_PAGE by adding 10 to the operand type
                        	   605: ;  - also applies to all the absolute modes (1 to 5)
                        	   606: ;
00:9D5F 18              	   607:   clc
00:9D60 690A            	   608:   adc #10
00:9D62 D170            	   609:   cmp (ASS_OPCODE_WORK),Y
00:9D64 D0CB            	   610:   bne opcode_lookup_next_table
                        	   611: ;
                        	   612: ;  plus, the operand has to be in the zero page
                        	   613: ;
00:9D66 A574            	   614:   lda ASS_VALUE+1
00:9D68 D0C7            	   615:   bne opcode_lookup_next_table
00:9D6A A575            	   616:   lda ASS_VALUE+2
00:9D6C D0C3            	   617:   bne opcode_lookup_next_table
                        	   618: opcode_lookup_correct_operand:
00:9D6E 8A              	   619:   txa   ; get the byte to emit back
                        	   620: 
                        	   621: ;
                        	   622: ; we have a match! emit the opcode
                        	   623: ;
00:9D6F 20ADA0          	   624:   jsr ass_emit            ; emit it
00:9D72 A004            	   625:   ldy #OPCODE_LOOKUP_HANDLER  ; offset of handler
00:9D74 B170            	   626:   lda (ASS_OPCODE_WORK),Y ; get opcode handler address low-order byte
00:9D76 AA              	   627:   tax
00:9D77 C8              	   628:   iny
00:9D78 B170            	   629:   lda (ASS_OPCODE_WORK),Y ; get opcode handler address high-order byte
00:9D7A F008            	   630:   beq opcode_lookup_no_handler
00:9D7C 8571            	   631:   sta ASS_OPCODE_WORK+1
00:9D7E 8A              	   632:   txa
00:9D7F 8570            	   633:   sta ASS_OPCODE_WORK
00:9D81 6C7000          	   634:   jmp (ASS_OPCODE_WORK)   ; do handler - it will RTS for us
                        	   635: 
                        	   636: opcode_lookup_no_handler:
                        	   637: ; put nothing here as it won't be done if there is a handler
00:9D84 60              	   638:   rts    ; done!
                        	   639: 
                        	   640: opcode_lookup_loop_done:
                        	   641: ;
                        	   642: ;  look for assembler directives
                        	   643: ;
00:9D85 A902            	   644:   lda #<DIRECTIVES
00:9D87 8503            	   645:   sta DEST
00:9D89 A9A2            	   646:   lda #>DIRECTIVES
00:9D8B 8504            	   647:   sta DEST+1
00:9D8D A56E            	   648:   lda OPCODE_LEN
                        	   649: 
                        	   650: ;  pha
                        	   651: ;   lda #'c'
                        	   652: ;   jsr ass_debug_point
                        	   653: ;   pla
                        	   654: 
00:9D8F 204A91          	   655:   jsr handlerLookup
00:9D92 9029            	   656:   bcc opcode_lookup_ok
                        	   657: 
                        	   658: ;   lda #'d'
                        	   659: ;   jsr ass_debug_point
                        	   660: 
                        	   661: ;
                        	   662: ;  here for unknown opcode
                        	   663: ;
00:9D94 A56C            	   664:   lda OPCODE
00:9D96 8590            	   665:   sta token_address
00:9D98 A56D            	   666:   lda OPCODE+1
00:9D9A 8591            	   667:   sta token_address+1
00:9D9C A56E            	   668:   lda OPCODE_LEN
00:9D9E 8592            	   669:   sta token_length
                        	   670: 
                        	   671: ;
                        	   672: ;  if we NEVER found a match, this is an illegal opcode
                        	   673: ;
00:9DA0 A921            	   674:   lda #'!'
00:9DA2 20F695          	   675:   jsr COUT
00:9DA5 A66E            	   676:   ldx OPCODE_LEN
00:9DA7 A000            	   677:   ldy #0
                        	   678: wtf_loop:
00:9DA9 B16C            	   679:    lda (OPCODE),Y
00:9DAB 20F695          	   680:    jsr COUT
00:9DAE C8              	   681:    iny
00:9DAF CA              	   682:    dex
00:9DB0 D0F7            	   683:    bne wtf_loop
                        	   684: 
                        	   685: 
00:9DB2 A228            	   686:   ldx  #40    ; illegal opcode
00:9DB4 A572            	   687:   lda ASS_COUNT
00:9DB6 F002            	   688:   beq opcode_lookup_loop_unknown
                        	   689: ;
                        	   690: ;  if we found a match, but not for this addressing mode, they used an illegal mode
                        	   691: ;
00:9DB8 A229            	   692:   ldx  #41   ; illegal addressing mode
                        	   693: opcode_lookup_loop_unknown:
00:9DBA 4CEBA0          	   694:   JMP  ass_error
                        	   695: 
                        	   696: opcode_lookup_ok:
                        	   697: 
                        	   698: ;   lda #'e'
                        	   699: ; jsr ass_debug_point
                        	   700: 
00:9DBD 60              	   701:   rts
                        	   702: 
                        	   703: ass_done:
00:9DBE 206894          	   704:   jsr  CROUT
00:9DC1 A576            	   705:   LDA  ASS_PASS
00:9DC3 D003            	   706:   bne  ass_done_second_pass
00:9DC5 4C969A          	   707:   jmp  ASSEMBLE_SECOND_PASS
                        	   708: ass_done_second_pass:
00:9DC8 A9E3            	   709:   LDA  #<ass_done_message  ; Assemble finished: No Errors
00:9DCA A29D            	   710:   LDX  #>ass_done_message
00:9DCC 202682          	   711:   JSR  print
00:9DCF A910            	   712:   lda  #FLAG_VALID_ASSEMBLE
00:9DD1 04BE            	   713:   tsb  system_flags
00:9DD3 20238F          	   714:   jsr  show_symbol_table_end
00:9DD6 20488F          	   715:   jsr  show_source_end
00:9DD9 A582            	   716:   lda  show_symbols
00:9DDB F003            	   717:   beq  ass_done1
00:9DDD 20A6A7          	   718:   jsr  list_symbols
                        	   719: ass_done1:
00:9DE0 4C7282          	   720:   JMP  main_prompt
                        	   721: 
00:9DE3 417373656D626C65	   722: ass_done_message asciiz "Assemble finished: No errors\n"
00:9DEB 2066696E69736865
00:9DF3 643A204E6F206572
00:9DFB 726F72730A
00:9E00 00
                        	   723: 
                        	   724: ass_check_no_more_tokens:
00:9E01 A593            	   725:   lda token_type
00:9E03 C90A            	   726:   cmp #NL           ; or end of line?
00:9E05 F005            	   727:   beq ass_check_no_more_tokens_ok
00:9E07 A213            	   728:   ldx #19    ; ERROR: incorrect symbol
00:9E09 4CEBA0          	   729:   jmp ass_error
                        	   730: 
                        	   731: ass_check_no_more_tokens_ok:
00:9E0C 60              	   732:   rts
                        	   733: 
                        	   734: ;
                        	   735: ;  push a 3-byte value (in VALUE) onto the evaluation stack
                        	   736: ;    changes A and Y
                        	   737: ;
                        	   738: exp_push_value = *
00:9E0D A57B            	   739:   lda exp_value_stack_count
00:9E0F C9FF            	   740:   cmp #$FF
00:9E11 D005            	   741:   bne exp_push_value_ok
                        	   742: exp_push_value_memory_full:
00:9E13 A22E            	   743:   ldx #46   ; ERROR: Expression too complex
00:9E15 4CEBA0          	   744:   jmp ass_error
                        	   745: exp_push_value_ok:
00:9E18 E67B            	   746:   inc exp_value_stack_count
00:9E1A 38              	   747:   sec
00:9E1B A579            	   748:   lda exp_value_stack
00:9E1D E903            	   749:   sbc #3
00:9E1F 8579            	   750:   sta exp_value_stack
00:9E21 A57A            	   751:   lda exp_value_stack+1
00:9E23 E900            	   752:   sbc #0
00:9E25 857A            	   753:   sta exp_value_stack+1
                        	   754: ;
                        	   755: ;  has our expression value fallen down into our P-codes?
                        	   756: ;
                        	   757: ;  This doesn't work if the output (PCODE) has been relocated to above
                        	   758: ;  the symbol table and I can't think of an easy solution, so let's ignore
                        	   759: ;  it and hope it doesn't happen.
                        	   760: ;
                        	   761: ;
                        	   762: ; lda  PCODE+1               ; see if P-codes full
                        	   763: ; cmp  exp_value_stack+1     ; in other words, have we hit the symbol table?
                        	   764: ; bcc  exp_push_value_not_full      ; less than
                        	   765: ; bne  exp_push_value_memory_full   ; greater than
                        	   766: ; lda  PCODE
                        	   767: ; cmp  exp_value_stack
                        	   768: ; bcs  exp_push_value_memory_full   ; BGE
                        	   769: 
                        	   770: exp_push_value_not_full:
00:9E27 A000            	   771:   ldy #0
00:9E29 A500            	   772:   lda VALUE
00:9E2B 9179            	   773:   sta (exp_value_stack),y
00:9E2D C8              	   774:   iny
00:9E2E A501            	   775:   lda VALUE+1
00:9E30 9179            	   776:   sta (exp_value_stack),y
00:9E32 C8              	   777:   iny
00:9E33 A502            	   778:   lda VALUE+2
00:9E35 9179            	   779:   sta (exp_value_stack),y
00:9E37 60              	   780:   rts
                        	   781: 
                        	   782: ;
                        	   783: ;  pop a 3-byte value (into VALUE) from the evaluation stack
                        	   784: ;    changes A and Y
                        	   785: ;
                        	   786: exp_pop_value = *
00:9E38 A57B            	   787:   lda exp_value_stack_count
00:9E3A D005            	   788:   bne exp_pop_value_ok
00:9E3C A217            	   789:   ldx #23    ; ERROR: illegal factor
00:9E3E 4CEBA0          	   790:   jmp ass_error
                        	   791: exp_pop_value_ok:
00:9E41 C67B            	   792:   dec exp_value_stack_count
00:9E43 A000            	   793:   ldy #0
00:9E45 B179            	   794:   lda (exp_value_stack),y
00:9E47 8500            	   795:   sta VALUE
00:9E49 C8              	   796:   iny
00:9E4A B179            	   797:   lda (exp_value_stack),y
00:9E4C 8501            	   798:   sta VALUE+1
00:9E4E C8              	   799:   iny
00:9E4F B179            	   800:   lda (exp_value_stack),y
00:9E51 8502            	   801:   sta VALUE+2
00:9E53 18              	   802:   clc
00:9E54 A579            	   803:   lda exp_value_stack
00:9E56 6903            	   804:   adc #3
00:9E58 8579            	   805:   sta exp_value_stack
00:9E5A A57A            	   806:   lda exp_value_stack+1
00:9E5C 6900            	   807:   adc #0
00:9E5E 857A            	   808:   sta exp_value_stack+1
00:9E60 60              	   809:   rts
                        	   810: 
                        	   811: ;
                        	   812: ;  I needed a work area for operators, and initially used INBUF however that got
                        	   813: ;  repurposed for managing strings (in particular handling \Xnn and double quotes)
                        	   814: ;  so now I am using the memory at the current PCODE address as a work area.
                        	   815: ;  It is only needed during expression evaluation, and should hopefully be available.
                        	   816: ;
                        	   817: ;
                        	   818: ;  push an operator (A) onto the operator stack
                        	   819: ;   changes X and Y
                        	   820: ;
                        	   821: exp_push_operator:
00:9E61 A67C            	   822:   ldx exp_operator_stack_count
00:9E63 E0FA            	   823:   cpx #250  ; make sure we don't overflow our operator stack
00:9E65 9005            	   824:   bcc exp_push_operator_ok
00:9E67 A22E            	   825:   ldx #46   ; ERROR: Expression too complex
00:9E69 4CEBA0          	   826:   jmp ass_error
                        	   827: exp_push_operator_ok:
00:9E6C E67C            	   828:   inc exp_operator_stack_count  ; add, then store
00:9E6E A47C            	   829:   ldy exp_operator_stack_count
00:9E70 9123            	   830:   sta (PCODE),Y
00:9E72 60              	   831:   rts
                        	   832: 
                        	   833: ;
                        	   834: ;  pop an operator (into A) from the operator stack
                        	   835: ;   changes X and Y
                        	   836: ;
                        	   837: exp_pop_operator:
00:9E73 A67C            	   838:   ldx exp_operator_stack_count
00:9E75 D005            	   839:   bne exp_pop_operator_ok
00:9E77 A217            	   840:   ldx #23   ; ERROR: Illegal factor
00:9E79 4CEBA0          	   841:   jmp ass_error
                        	   842: exp_pop_operator_ok:
00:9E7C A47C            	   843:   ldy exp_operator_stack_count  ; retrieve, then decrement
00:9E7E B123            	   844:   lda (PCODE),Y
00:9E80 C67C            	   845:   dec exp_operator_stack_count
00:9E82 60              	   846:   rts
                        	   847: 
                        	   848: ;
                        	   849: ;  get an operator (into A) from the operator stack (without removing it)
                        	   850: ;   changes X and Y
                        	   851: ;
                        	   852: exp_get_operator:
00:9E83 A67C            	   853:   ldx exp_operator_stack_count
00:9E85 D005            	   854:   bne exp_get_operator_ok
00:9E87 A217            	   855:   ldx #23   ; ERROR: Illegal factor
00:9E89 4CEBA0          	   856:   jmp ass_error
                        	   857: exp_get_operator_ok:
00:9E8C A47C            	   858:   ldy exp_operator_stack_count
00:9E8E B123            	   859:   lda (PCODE),Y
00:9E90 60              	   860:   rts
                        	   861: 
                        	   862:  .macro makePrecedenceTable ; table of operators, precedence, handler
                        	   863:    dfb   \1
                        	   864:    dfb   \2
                        	   865:    word  \3
                        	   866:  .endmacro
                        	   867: 
                        	   868: ; cannot have more than 64 entries because we index into this with X
                        	   869: exp_precedence_table:
                        	   870:   makePrecedenceTable '~', 1, exp_negate
00:9E91 7E              	     1M    dfb   '~'
00:9E92 01              	     2M    dfb   1
00:9E93 2CAE            	     3M    word  exp_negate
                        	   871:   makePrecedenceTable '!', 1, exp_not
00:9E95 21              	     1M    dfb   '!'
00:9E96 01              	     2M    dfb   1
00:9E97 3FAE            	     3M    word  exp_not
                        	   872:   makePrecedenceTable TOKEN_UNARY_MINUS, 1, exp_unary_minus
00:9E99 4D              	     1M    dfb   TOKEN_UNARY_MINUS
00:9E9A 01              	     2M    dfb   1
00:9E9B 4DAE            	     3M    word  exp_unary_minus
                        	   873:   makePrecedenceTable TOKEN_LOW_BYTE, 1, exp_low_byte
00:9E9D 56              	     1M    dfb   TOKEN_LOW_BYTE
00:9E9E 01              	     2M    dfb   1
00:9E9F 61AE            	     3M    word  exp_low_byte
                        	   874:   makePrecedenceTable TOKEN_HIGH_BYTE, 1, exp_high_byte
00:9EA1 57              	     1M    dfb   TOKEN_HIGH_BYTE
00:9EA2 01              	     2M    dfb   1
00:9EA3 66AE            	     3M    word  exp_high_byte
                        	   875:   makePrecedenceTable TOKEN_SHIFT_LEFT, 2, exp_shift_left
00:9EA5 4C              	     1M    dfb   TOKEN_SHIFT_LEFT
00:9EA6 02              	     2M    dfb   2
00:9EA7 FAAD            	     3M    word  exp_shift_left
                        	   876:   makePrecedenceTable TOKEN_SHIFT_RIGHT, 2, exp_shift_right
00:9EA9 52              	     1M    dfb   TOKEN_SHIFT_RIGHT
00:9EAA 02              	     2M    dfb   2
00:9EAB 13AE            	     3M    word  exp_shift_right
                        	   877:   makePrecedenceTable '&', 3, exp_bitwise_and
00:9EAD 26              	     1M    dfb   '&'
00:9EAE 03              	     2M    dfb   3
00:9EAF A9AD            	     3M    word  exp_bitwise_and
                        	   878:   makePrecedenceTable '^', 4, exp_bitwise_xor
00:9EB1 5E              	     1M    dfb   '^'
00:9EB2 04              	     2M    dfb   4
00:9EB3 BEAD            	     3M    word  exp_bitwise_xor
                        	   879:   makePrecedenceTable '|', 5, exp_bitwise_or
00:9EB5 7C              	     1M    dfb   '|'
00:9EB6 05              	     2M    dfb   5
00:9EB7 94AD            	     3M    word  exp_bitwise_or
                        	   880:   makePrecedenceTable '*', 6, exp_multiply
00:9EB9 2A              	     1M    dfb   '*'
00:9EBA 06              	     2M    dfb   6
00:9EBB D4AE            	     3M    word  exp_multiply
                        	   881:   makePrecedenceTable '/', 6, exp_divide
00:9EBD 2F              	     1M    dfb   '/'
00:9EBE 06              	     2M    dfb   6
00:9EBF 0DAF            	     3M    word  exp_divide
                        	   882:   makePrecedenceTable '%', 6, exp_modulo
00:9EC1 25              	     1M    dfb   '%'
00:9EC2 06              	     2M    dfb   6
00:9EC3 6DAF            	     3M    word  exp_modulo
                        	   883:   makePrecedenceTable '+', 7, exp_add
00:9EC5 2B              	     1M    dfb   '+'
00:9EC6 07              	     2M    dfb   7
00:9EC7 06AD            	     3M    word  exp_add
                        	   884:   makePrecedenceTable '-', 7, exp_subtract
00:9EC9 2D              	     1M    dfb   '-'
00:9ECA 07              	     2M    dfb   7
00:9ECB 1AAD            	     3M    word  exp_subtract
                        	   885:   makePrecedenceTable '<', 8, exp_less_than
00:9ECD 3C              	     1M    dfb   '<'
00:9ECE 08              	     2M    dfb   8
00:9ECF 68AD            	     3M    word  exp_less_than
                        	   886:   makePrecedenceTable '>', 8, exp_greater_than
00:9ED1 3E              	     1M    dfb   '>'
00:9ED2 08              	     2M    dfb   8
00:9ED3 6FAD            	     3M    word  exp_greater_than
                        	   887:   makePrecedenceTable TOKEN_LEQ, 8, exp_leq
00:9ED5 80              	     1M    dfb   TOKEN_LEQ
00:9ED6 08              	     2M    dfb   8
00:9ED7 7EAD            	     3M    word  exp_leq
                        	   888:   makePrecedenceTable TOKEN_GEQ, 8, exp_geq
00:9ED9 81              	     1M    dfb   TOKEN_GEQ
00:9EDA 08              	     2M    dfb   8
00:9EDB 8DAD            	     3M    word  exp_geq
                        	   889:   makePrecedenceTable TOKEN_EQUALITY, 9, exp_eql
00:9EDD 45              	     1M    dfb   TOKEN_EQUALITY
00:9EDE 09              	     2M    dfb   9
00:9EDF 40AD            	     3M    word  exp_eql
                        	   890:   makePrecedenceTable TOKEN_NEQ, 9, exp_neq     ; <>
00:9EE1 55              	     1M    dfb   TOKEN_NEQ
00:9EE2 09              	     2M    dfb   9
00:9EE3 54AD            	     3M    word  exp_neq     
                        	   891:   makePrecedenceTable TOKEN_INEQUALITY, 9, exp_neq  ; !=
00:9EE5 5A              	     1M    dfb   TOKEN_INEQUALITY
00:9EE6 09              	     2M    dfb   9
00:9EE7 54AD            	     3M    word  exp_neq  
                        	   892:   makePrecedenceTable TOKEN_LOGICAL_AND, 10, exp_logical_and
00:9EE9 58              	     1M    dfb   TOKEN_LOGICAL_AND
00:9EEA 0A              	     2M    dfb   10
00:9EEB E8AD            	     3M    word  exp_logical_and
                        	   893:   makePrecedenceTable TOKEN_LOGICAL_OR, 11, exp_logical_or
00:9EED 59              	     1M    dfb   TOKEN_LOGICAL_OR
00:9EEE 0B              	     2M    dfb   11
00:9EEF D9AD            	     3M    word  exp_logical_or
                        	   894: 
                        	   895: exp_precedence_table_end = *
                        	   896: 
                        	   897: ;
                        	   898: ;  finds precedence of operator in A, returns it in Y (returns 0 if not found)
                        	   899: ;    changes X, A
                        	   900: ;  also stores the operator evaluation function (eg. exp_add) in exp_evaluation_function
                        	   901: ;
                        	   902: exp_get_precedence:
00:9EF1 A200            	   903:   ldx #0
                        	   904: exp_get_precedence_loop:
00:9EF3 DD919E          	   905:   cmp exp_precedence_table,x
00:9EF6 F00F            	   906:   beq exp_get_precedence_found
00:9EF8 E8              	   907:   inx   ; skip operator
00:9EF9 E8              	   908:   inx   ; skip precedence
00:9EFA E8              	   909:   inx   ; skip evaluation function
00:9EFB E8              	   910:   inx   ;  (2 bytes)
00:9EFC E060            	   911:   cpx #exp_precedence_table_end - exp_precedence_table
00:9EFE 90F3            	   912:   bcc exp_get_precedence_loop
00:9F00 A000            	   913:   ldy #0
00:9F02 647F            	   914:   stz exp_evaluation_function
00:9F04 6480            	   915:   stz exp_evaluation_function+1
00:9F06 60              	   916:   rts
                        	   917: exp_get_precedence_found:
00:9F07 E8              	   918:   inx
00:9F08 BC919E          	   919:   ldy exp_precedence_table,x
00:9F0B E8              	   920:   inx
00:9F0C BD919E          	   921:   lda exp_precedence_table,x
00:9F0F 857F            	   922:   sta exp_evaluation_function
00:9F11 E8              	   923:   inx
00:9F12 BD919E          	   924:   lda exp_precedence_table,x
00:9F15 8580            	   925:   sta exp_evaluation_function+1
00:9F17 60              	   926:   rts
                        	   927: 
                        	   928: ;
                        	   929: ;  Convert an expression into a value
                        	   930: ;
                        	   931: ;   Ideas from https://www.geeksforgeeks.org/expression-evaluation/
                        	   932: ;
                        	   933: ass_get_value:
                        	   934: ;
                        	   935: ;  set up expression evaluation stack
                        	   936: ;
00:9F18 647B            	   937:   stz exp_value_stack_count
00:9F1A 647C            	   938:   stz exp_operator_stack_count
00:9F1C A531            	   939:   lda ENDSYM
00:9F1E 8579            	   940:   sta exp_value_stack
00:9F20 A532            	   941:   lda ENDSYM+1
00:9F22 857A            	   942:   sta exp_value_stack+1
                        	   943: 
00:9F24 6473            	   944:   stz ASS_VALUE
00:9F26 6474            	   945:   stz ASS_VALUE+1
00:9F28 6475            	   946:   stz ASS_VALUE+2
00:9F2A A901            	   947:   lda #1
00:9F2C 8581            	   948:   sta exp_unary_ok  ; unary operators can appear at the start of the expression
00:9F2E A593            	   949:   lda token_type
                        	   950: ;  jsr START_TRACE
                        	   951: ;
                        	   952: ;  one token lookahead
                        	   953: ;
00:9F30 8003            	   954:   bra ass_expression_loop_initial
                        	   955: 
                        	   956: ;
                        	   957: ;  1.1 Get the next token
                        	   958: ;
                        	   959: ass_expression_loop:
00:9F32 20D3CB          	   960:   jsr get_token
                        	   961: ass_expression_loop_initial:
                        	   962: 
                        	   963: ;
                        	   964: ;  1.2.1 If it's a number, push onto the value stack
                        	   965: ;
00:9F35 C94E            	   966:   cmp #TOKEN_NUMBER
00:9F37 D013            	   967:   bne ass_expression_loop1a
                        	   968: ass_expression_number:
00:9F39 A594            	   969:   lda token_value
00:9F3B 8500            	   970:   sta VALUE
00:9F3D A595            	   971:   lda token_value+1
00:9F3F 8501            	   972:   sta VALUE+1
00:9F41 A596            	   973:   lda token_value+2
00:9F43 8502            	   974:   sta VALUE+2
00:9F45 200D9E          	   975:   jsr exp_push_value
00:9F48 6481            	   976:   stz exp_unary_ok          ; don't have unary operators after numbers
00:9F4A 80E6            	   977:   bra ass_expression_loop
                        	   978: ;
                        	   979: ;  if it's a string and only 1 or 2 bytes, consider as a number
                        	   980: ;
                        	   981: ass_expression_loop1a:
00:9F4C C922            	   982:   cmp #TOKEN_STRING
00:9F4E D013            	   983:   bne ass_expression_loop1
00:9F50 A592            	   984:   lda token_length
00:9F52 C903            	   985:   cmp #3
00:9F54 B008            	   986:   bcs ass_expression_not_small_string  ; too long?
                        	   987: ;
                        	   988: ;  one or two character string - is this an immediate operand?
                        	   989: ;
00:9F56 A56B            	   990:   lda ASS_OPERAND
00:9F58 C907            	   991:   cmp #ASS_OPERAND_IMMEDIATE
00:9F5A D002            	   992:   bne ass_expression_not_small_string
00:9F5C 80DB            	   993:   bra ass_expression_number   ; treat as a number (its value should be in VALUE)
                        	   994: 
                        	   995: ass_expression_not_small_string:
00:9F5E A21D            	   996:   ldx #29     ; string literal too big
00:9F60 4CEBA0          	   997:   jmp ass_error
                        	   998: 
                        	   999: ;
                        	  1000: ;  1.2.2 If it's an identifier, get its value and push onto the value stack
                        	  1001: ;
                        	  1002: ass_expression_loop1:
00:9F63 C949            	  1003:   cmp #TOKEN_IDENTIFIER
00:9F65 D029            	  1004:   bne ass_expression_loop2
00:9F67 6481            	  1005:   stz exp_unary_ok          ; don't have unary operators after identifiers
                        	  1006: 
00:9F69 2057BB          	  1007:   jsr SEARCH    ; should be in symbol table as a constant, and the value in VALUE
00:9F6C D011            	  1008:   bne ass_expression_found_value
00:9F6E A576            	  1009:   lda ASS_PASS
00:9F70 F005            	  1010:   beq ass_label_not_found_yet
                        	  1011: 
                        	  1012: ;
                        	  1013: ; it's an error if it isn't there on the second pass
                        	  1014: ;
00:9F72 A20B            	  1015:   ldx #11  ; ERROR: Undeclared Identifier
00:9F74 4CEBA0          	  1016:   jmp ass_error
                        	  1017: 
                        	  1018: ;
                        	  1019: ;  label not found on first pass, make the value 0x6666 for now
                        	  1020: ;   - we don't want a zero-page address assumption because that
                        	  1021: ;     will throw out opcode lengths (it might assume a zero page opcode
                        	  1022: ;     which is shorter and then change it to a longer one)
                        	  1023: ;
                        	  1024: ass_label_not_found_yet:
00:9F77 A966            	  1025:   lda #$66
00:9F79 8500            	  1026:   sta VALUE
00:9F7B 8501            	  1027:   sta VALUE+1
00:9F7D 6402            	  1028:   stz VALUE+2
                        	  1029: ass_expression_found_value:
00:9F7F A594            	  1030:   lda token_value
00:9F81 8500            	  1031:   sta VALUE
00:9F83 A595            	  1032:   lda token_value+1
00:9F85 8501            	  1033:   sta VALUE+1
00:9F87 A596            	  1034:   lda token_value+2
00:9F89 8502            	  1035:   sta VALUE+2
00:9F8B 200D9E          	  1036:   jsr exp_push_value
00:9F8E 80A2            	  1037:   bra ass_expression_loop
                        	  1038: 
                        	  1039: ;
                        	  1040: ; 1.2.3 If it's a left parenthesis: push it onto the operator stack.
                        	  1041: ;
                        	  1042: ass_expression_loop2:
00:9F90 C928            	  1043:   cmp #'('
00:9F92 D00B            	  1044:   bne ass_expression_loop3
00:9F94 48              	  1045:   pha
00:9F95 A901            	  1046:   lda  #1
00:9F97 8581            	  1047:   sta exp_unary_ok          ; unary operators can follow left parentheses
00:9F99 68              	  1048:   pla
                        	  1049: 
00:9F9A 20619E          	  1050:   jsr exp_push_operator
00:9F9D 8093            	  1051:   bra ass_expression_loop
                        	  1052: 
                        	  1053: ;
                        	  1054: ;  1.2.4 A right parenthesis:
                        	  1055: ;       1 While the thing on top of the operator stack is not a
                        	  1056: ;         left parenthesis,
                        	  1057: ;           1 Pop the operator from the operator stack.
                        	  1058: ;           2 Pop the value stack twice, getting two operands.
                        	  1059: ;           3 Apply the operator to the operands, in the correct order.
                        	  1060: ;           4 Push the result onto the value stack.
                        	  1061: ;        2 Pop the left parenthesis from the operator stack, and discard it.
                        	  1062: 
                        	  1063: 
                        	  1064: ass_expression_loop3:
00:9F9F C929            	  1065:   cmp #')'
00:9FA1 D016            	  1066:   bne ass_expression_loop4
                        	  1067: ass_expression_loop3b:
                        	  1068: ;
                        	  1069: ;  a RH parenthesis with an empty operator stack is probably the end of the expression, eg. ($1234),x
                        	  1070: ;  where the ")" belongs to the indexed operand stuff and not the expression
                        	  1071: ;
00:9FA3 A57C            	  1072:   lda exp_operator_stack_count
00:9FA5 F078            	  1073:   beq exp_no_operators_left
00:9FA7 20839E          	  1074:   jsr exp_get_operator
00:9FAA C928            	  1075:   cmp #'('
00:9FAC F005            	  1076:   beq ass_expression_loop3c
                        	  1077: ;
                        	  1078: ;  not a left parenthesis
                        	  1079: ;
                        	  1080: ass_expression_loop3a:
00:9FAE 2045A0          	  1081:   jsr ass_expression_apply_operator ; pop the operator and two values, apply the operator and push the result
00:9FB1 80F0            	  1082:   bra ass_expression_loop3b          ; keep going until we don't have a left parenthesis
                        	  1083: 
                        	  1084: ass_expression_loop3c:
00:9FB3 20739E          	  1085:   jsr exp_pop_operator              ;  2 Pop the left parenthesis from the operator stack, and discard it.
                        	  1086: ass_expression_loopJ:
00:9FB6 4C329F          	  1087:   jmp ass_expression_loop
                        	  1088: 
                        	  1089: ;       1.2.5 An operator (call it thisOp):
                        	  1090: ;         1 While the operator stack is not empty, and the top thing on the
                        	  1091: ;           operator stack has the same or greater precedence as thisOp,
                        	  1092: ;           1 Pop the operator from the operator stack.
                        	  1093: ;           2 Pop the value stack twice, getting two operands.
                        	  1094: ;           3 Apply the operator to the operands, in the correct order.
                        	  1095: ;           4 Push the result onto the value stack.
                        	  1096: ;         2 Push thisOp onto the operator stack.
                        	  1097: 
                        	  1098: ass_expression_loop4:
                        	  1099: ;
                        	  1100: ;  look for unary operators
                        	  1101: ;
00:9FB9 A681            	  1102:   ldx exp_unary_ok
00:9FBB F034            	  1103:   beq ass_expression_cannot_be_unary
00:9FBD C92D            	  1104:   cmp #'-'
00:9FBF D006            	  1105:   bne ass_not_unary_minus
00:9FC1 A94D            	  1106:   lda #TOKEN_UNARY_MINUS
00:9FC3 8593            	  1107:   sta token_type
00:9FC5 802A            	  1108:   bra ass_expression_cannot_be_unary
                        	  1109: ass_not_unary_minus:
00:9FC7 C93C            	  1110:   cmp #'<'
00:9FC9 D006            	  1111:   bne ass_not_unary_less_than
00:9FCB A956            	  1112:   lda #TOKEN_LOW_BYTE
00:9FCD 8593            	  1113:   sta token_type
00:9FCF 8020            	  1114:   bra ass_expression_cannot_be_unary
                        	  1115: ass_not_unary_less_than:
00:9FD1 C93E            	  1116:   cmp #'>'
00:9FD3 D006            	  1117:   bne ass_not_unary_greater_than
00:9FD5 A957            	  1118:   lda #TOKEN_HIGH_BYTE
00:9FD7 8593            	  1119:   sta token_type
00:9FD9 8000            	  1120:   bra ass_not_unary_greater_than
                        	  1121: ass_not_unary_greater_than:
00:9FDB C92A            	  1122:   cmp #'*'
00:9FDD D012            	  1123:   bne ass_expression_cannot_be_unary
                        	  1124: ;
                        	  1125: ;  A '*' where a unary expression is allowed will be the current emit address (eg. foo = *)
                        	  1126: ;
00:9FDF A523            	  1127:   lda PCODE
00:9FE1 8594            	  1128:   sta token_value
00:9FE3 A524            	  1129:   lda PCODE+1
00:9FE5 8595            	  1130:   sta token_value+1
00:9FE7 6496            	  1131:   stz token_value+2
00:9FE9 6481            	  1132:   stz exp_unary_ok          ; don't have unary operators after numbers
00:9FEB A94E            	  1133:   lda #TOKEN_NUMBER
00:9FED 8593            	  1134:   sta token_type            ; make get_token think a sign as a token on its own
00:9FEF 808E            	  1135:   bra ass_expression_found_value
                        	  1136: 
                        	  1137: ass_expression_cannot_be_unary:
00:9FF1 48              	  1138:   pha
00:9FF2 A901            	  1139:   lda #1
00:9FF4 8581            	  1140:   sta exp_unary_ok          ; can have unary operators after operators
00:9FF6 68              	  1141:   pla
                        	  1142: 
00:9FF7 20F19E          	  1143:   jsr exp_get_precedence
00:9FFA 847E            	  1144:   sty exp_operator_precedence ; thisOp's precedence
00:9FFC C000            	  1145:   cpy #0
00:9FFE F01F            	  1146:   beq exp_no_operators_left
                        	  1147: 
                        	  1148: ass_expression_loop7:         ; 1 While the operator stack is not empty
00:A000 A57C            	  1149:   lda exp_operator_stack_count
00:A002 F013            	  1150:   beq ass_expression_loop6    ; stack empty
00:A004 20839E          	  1151:   jsr exp_get_operator    ; find the top thing on the operator stack
00:A007 C928            	  1152:   cmp #'('                ; if a bracket, consider that low precedence
00:A009 F00C            	  1153:   beq ass_expression_loop6
00:A00B 20F19E          	  1154:   jsr exp_get_precedence  ; and its precedence
00:A00E C47E            	  1155:   cpy exp_operator_precedence
00:A010 B005            	  1156:   bcs ass_expression_loop6  ; thing on top has less precedence (a higher value) than thisOp
00:A012 2045A0          	  1157:   jsr ass_expression_apply_operator  ; pop the operator and two values, apply the operator and push the result
00:A015 80E9            	  1158:   bra ass_expression_loop7
                        	  1159: 
                        	  1160: ass_expression_loop6:
00:A017 A593            	  1161:   lda token_type       ; thisOp
00:A019 20619E          	  1162:   jsr exp_push_operator
00:A01C 4C329F          	  1163:   jmp ass_expression_loop
                        	  1164: 
                        	  1165: 
                        	  1166: ; 2. While the operator stack is not empty,
                        	  1167: ;     1 Pop the operator from the operator stack.
                        	  1168: ;     2 Pop the value stack twice, getting two operands.
                        	  1169: ;     3 Apply the operator to the operands, in the correct order.
                        	  1170: ;     4 Push the result onto the value stack.
                        	  1171: 
                        	  1172: 
                        	  1173: exp_no_operators_left:
00:A01F A57C            	  1174:     lda exp_operator_stack_count
00:A021 F005            	  1175:     beq exp_done
00:A023 2045A0          	  1176:     jsr ass_expression_apply_operator ; pop the operator and two values, apply the operator and push the result
00:A026 80F7            	  1177:     bra exp_no_operators_left
                        	  1178: 
                        	  1179: exp_done:
00:A028 A57B            	  1180:       lda exp_value_stack_count
00:A02A C901            	  1181:       cmp #1
00:A02C F005            	  1182:       beq exp_done_ok
                        	  1183: exp_done_error:
00:A02E A217            	  1184:       ldx #23       ; ERROR: Illegal factor
00:A030 4CEBA0          	  1185:       jmp ass_error
                        	  1186: 
                        	  1187: exp_done_ok:
00:A033 A57C            	  1188:       lda exp_operator_stack_count
00:A035 D0F7            	  1189:       bne exp_done_error
00:A037 20389E          	  1190:       jsr exp_pop_value   ; pop the finished value
00:A03A A500            	  1191:       lda VALUE
00:A03C 8573            	  1192:       sta ASS_VALUE
00:A03E A501            	  1193:       lda VALUE+1
00:A040 8574            	  1194:       sta ASS_VALUE+1
00:A042 6475            	  1195:       stz ASS_VALUE+2   ; make high-order byte zero just in case
00:A044 60              	  1196:       rts
                        	  1197: 
                        	  1198: ;
                        	  1199: ;
                        	  1200: ;     1 Pop the operator from the operator stack.
                        	  1201: ;     2 Pop the value stack twice, getting two operands.
                        	  1202: ;     3 Apply the operator to the operands, in the correct order.
                        	  1203: ;     4 Push the result onto the value stack.
                        	  1204: 
                        	  1205: ;
                        	  1206: ass_expression_apply_operator:
00:A045 20389E          	  1207:   jsr exp_pop_value         ; 2 Pop the value stack twice, getting two operands.
00:A048 20839E          	  1208:   jsr exp_get_operator
00:A04B C97E            	  1209:   cmp #'~'
00:A04D F01F            	  1210:   beq ass_expression_unary
00:A04F C921            	  1211:   cmp #'!'
00:A051 F01B            	  1212:   beq ass_expression_unary
00:A053 C94D            	  1213:   cmp #TOKEN_UNARY_MINUS
00:A055 F017            	  1214:   beq ass_expression_unary
00:A057 C956            	  1215:   cmp #TOKEN_LOW_BYTE
00:A059 F013            	  1216:   beq ass_expression_unary
00:A05B C957            	  1217:   cmp #TOKEN_HIGH_BYTE
00:A05D F00F            	  1218:   beq ass_expression_unary
                        	  1219: 
                        	  1220: ;
                        	  1221: ;  if a binary operator get the second value
                        	  1222: ;
00:A05F A500            	  1223:   lda VALUE                 ; copy top value to VALUE2
00:A061 8503            	  1224:   sta VALUE2
00:A063 A501            	  1225:   lda VALUE+1
00:A065 8504            	  1226:   sta VALUE2+1
00:A067 A502            	  1227:   lda VALUE+2
00:A069 8505            	  1228:   sta VALUE2+2
00:A06B 20389E          	  1229:   jsr exp_pop_value         ; second pop
                        	  1230: ass_expression_unary:
                        	  1231: 
                        	  1232: ;
                        	  1233: ;  now we have the top two values in VALUE (and VALUE2 in the case of binary operators)
                        	  1234: ;
00:A06E 20739E          	  1235:   jsr exp_pop_operator      ; 1 Pop the operator from the operator stack.
00:A071 857D            	  1236:   sta exp_operator
00:A073 20F19E          	  1237:   jsr exp_get_precedence    ; find the evaluation function
00:A076 C000            	  1238:   cpy #0
00:A078 F0CB            	  1239:   beq ass_expression_apply_operator ; should not be here if the operator isn't in the table
00:A07A 2086A0          	  1240:   jsr ass_evaluate_operator ; do the evaluation
00:A07D 200D9E          	  1241:   jsr exp_push_value        ; 4 Push the result onto the value stack.
00:A080 60              	  1242:   rts
                        	  1243: 
                        	  1244: ass_expression_apply_operator_bug:
00:A081 A206            	  1245:   ldx #6
00:A083 4CEBA0          	  1246:   jmp ass_error
                        	  1247: 
                        	  1248: ass_evaluate_operator:
00:A086 6C7F00          	  1249:   jmp (exp_evaluation_function)
                        	  1250: 
                        	  1251: 
                        	  1252: ;
                        	  1253: ;  look up opcodes in a table
                        	  1254: ;  returns carry set if found, carry clear if not found
                        	  1255: ;
                        	  1256: ass_lookup_loop:
00:A089 A46E            	  1257:   ldy OPCODE_LEN
00:A08B 206D94          	  1258:   jsr COMSTL
00:A08E F017            	  1259:   beq ass_opcode_found
                        	  1260: ;
                        	  1261: ;  add the opcode length, plus 1 to DEST
                        	  1262: ;
00:A090 18              	  1263:   clc
00:A091 A46E            	  1264:   ldy OPCODE_LEN
00:A093 C8              	  1265:   iny
00:A094 98              	  1266:   tya
00:A095 6503            	  1267:   adc DEST
00:A097 8503            	  1268:   sta DEST
00:A099 A504            	  1269:   lda DEST+1
00:A09B 6900            	  1270:   adc #0
00:A09D 8504            	  1271:   sta DEST+1
                        	  1272: ;
                        	  1273: ;  end of table?
                        	  1274: ;
00:A09F A000            	  1275:   ldy #0
00:A0A1 B103            	  1276:   lda (DEST),Y
00:A0A3 D0E4            	  1277:   bne ass_lookup_loop   ; not yet
00:A0A5 18              	  1278:   clc
00:A0A6 60              	  1279:   rts
                        	  1280: 
                        	  1281: 
                        	  1282: ass_opcode_found:
00:A0A7 A46E            	  1283:   ldy OPCODE_LEN
00:A0A9 B103            	  1284:   lda (DEST),Y
00:A0AB 38              	  1285:   sec   ; indicate found
00:A0AC 60              	  1286:   rts
                        	  1287: 
                        	  1288: ass_emit:
00:A0AD A476            	  1289:   ldy ASS_PASS
00:A0AF F031            	  1290:   beq ass_emit3  ; only emit codes on 2nd pass
                        	  1291:   ;
                        	  1292:   ;  first time for this line of code, indent by two spaces
                        	  1293:   ;
00:A0B1 A46F            	  1294:   ldy ASS_EMIT_COUNT
00:A0B3 D00C            	  1295:   bne ass_emit2
00:A0B5 A42E            	  1296:   ldy DCODE
00:A0B7 F008            	  1297:   beq ass_emit2
00:A0B9 48              	  1298:   pha
00:A0BA 20F394          	  1299:   jsr PUTSP
00:A0BD 20F394          	  1300:   jsr PUTSP
00:A0C0 68              	  1301:   pla
                        	  1302: ass_emit2:
                        	  1303: ;
                        	  1304: ;  if this is the *first* byte we emitted, then make that the start address
                        	  1305: ;  for running the code. That is, if you relocate the code, the first byte
                        	  1306: ;  actually emitted will be considered the runtime address.
                        	  1307: ;
                        	  1308: ;  this lets you relocate code (eg. to $4500) and have it run from there if
                        	  1309: ;  you happen to hit Run.
                        	  1310: ;
00:A0C1 48              	  1311:   pha
00:A0C2 A577            	  1312:   lda ass_emit_bytes
00:A0C4 0578            	  1313:   ora ass_emit_bytes+1
00:A0C6 D008            	  1314:   bne ass_already_emitted
00:A0C8 A523            	  1315:   lda PCODE
00:A0CA 8525            	  1316:   sta ACT_PCDA
00:A0CC A524            	  1317:   lda PCODE+1
00:A0CE 8526            	  1318:   sta ACT_PCDA+1
                        	  1319: ass_already_emitted:
00:A0D0 68              	  1320:   pla
                        	  1321: ;
                        	  1322: ;  write the byte to memory
                        	  1323: ;
00:A0D1 A000            	  1324:   ldy #0
00:A0D3 9123            	  1325:   sta (PCODE),Y
00:A0D5 E677            	  1326:   inc ass_emit_bytes
00:A0D7 D002            	  1327:   bne ass_emit4
00:A0D9 E678            	  1328:   inc ass_emit_bytes+1
                        	  1329: ass_emit4:
                        	  1330: 
                        	  1331: ;
                        	  1332: ;  if displaying codes, show the emitted byte
                        	  1333: ;
00:A0DB A42E            	  1334:   ldy DCODE
00:A0DD F003            	  1335:   beq ass_emit3
00:A0DF 207D94          	  1336:   jsr DISHX
                        	  1337: ;
                        	  1338: ;  increment the PCODE (output) address
                        	  1339: ;
                        	  1340: ass_emit3:
00:A0E2 E623            	  1341:   inc PCODE
00:A0E4 D002            	  1342:   bne ass_emit1
00:A0E6 E624            	  1343:   inc PCODE+1
                        	  1344: ass_emit1:
00:A0E8 E66F            	  1345:   inc ASS_EMIT_COUNT
00:A0EA 60              	  1346:   rts
                        	  1347: 
                        	  1348: ass_error:
00:A0EB A56F            	  1349:   lda ASS_EMIT_COUNT
00:A0ED F003            	  1350:   beq ass_error1
00:A0EF 206894          	  1351:   jsr CROUT
                        	  1352: ass_error1:
00:A0F2 4CAB99          	  1353:   jmp ERROR
                        	  1354: 
                        	  1355: ass_fixup_bbr_branch:
00:A0F5 A507            	  1356:   lda REMAIN+1
00:A0F7 D043            	  1357:   bne ass_emit_zero_page_too_high
00:A0F9 A508            	  1358:   lda REMAIN+2
00:A0FB D03F            	  1359:   bne ass_emit_zero_page_too_high
00:A0FD A506            	  1360:   lda REMAIN
00:A0FF 20ADA0          	  1361:   jsr ass_emit  ; output zero page address
                        	  1362: 
                        	  1363: ;
                        	  1364: ;  now fall down and emit the branch
                        	  1365: ;
                        	  1366: 
                        	  1367: ass_fixup_branch:
00:A102 18              	  1368:   clc         ; I want to subtract one more, so I CLEAR carry <sigh>
00:A103 A573            	  1369:   lda ASS_VALUE
00:A105 E523            	  1370:   sbc PCODE
00:A107 8573            	  1371:   sta ASS_VALUE
                        	  1372: 
00:A109 A574            	  1373:   lda ASS_VALUE+1
00:A10B E524            	  1374:   sbc PCODE+1
00:A10D C9FF            	  1375:   cmp #$FF  ; backwards branch
00:A10F F00A            	  1376:   beq ass_branch_backwards
00:A111 C900            	  1377:   cmp #0
00:A113 D010            	  1378:   bne ass_branch_out_of_range
00:A115 A573            	  1379:   lda ASS_VALUE ; must be 0x00 to 0x7F
00:A117 300C            	  1380:   bmi ass_branch_out_of_range
00:A119 8004            	  1381:   bra ass_branch_ok
                        	  1382: 
                        	  1383: ass_branch_backwards:
00:A11B A573            	  1384:   lda ASS_VALUE   ; must be 0x80 to 0xFF
00:A11D 1006            	  1385:   bpl ass_branch_out_of_range
                        	  1386: 
                        	  1387: ass_branch_ok:
00:A11F A573            	  1388:   lda ASS_VALUE
00:A121 20ADA0          	  1389:   jsr ass_emit  ; output relative address
00:A124 60              	  1390:   rts
                        	  1391: 
                        	  1392: ass_branch_out_of_range:
00:A125 A576            	  1393:   lda ASS_PASS
00:A127 F0F6            	  1394:   beq ass_branch_ok   ; out of range is OK on first pass, we don't know how far the branch is
00:A129 A22A            	  1395:   ldx #42
00:A12B 4CEBA0          	  1396:   jmp ass_error  ; branch out of range
                        	  1397: 
                        	  1398: ass_emit_zero_page:
00:A12E A574            	  1399:   lda ASS_VALUE+1
00:A130 D00A            	  1400:   bne ass_emit_zero_page_too_high
00:A132 A575            	  1401:   lda ASS_VALUE+2
00:A134 D006            	  1402:   bne ass_emit_zero_page_too_high
00:A136 A573            	  1403:   lda ASS_VALUE
00:A138 20ADA0          	  1404:   jsr ass_emit  ; output zero page address
00:A13B 60              	  1405:   rts
                        	  1406: 
                        	  1407: 
                        	  1408: ass_emit_zero_page_too_high:
00:A13C A22B            	  1409:   ldx #43       ; Need zero page address
00:A13E 4CEBA0          	  1410:   jmp ass_error
                        	  1411: 
                        	  1412: ass_emit_immediate:
00:A141 A574            	  1413:   lda ASS_VALUE+1
00:A143 D00A            	  1414:   bne ass_emit_immediate_too_high
00:A145 A575            	  1415:   lda ASS_VALUE+2
00:A147 D006            	  1416:   bne ass_emit_immediate_too_high
00:A149 A573            	  1417:   lda ASS_VALUE
00:A14B 20ADA0          	  1418:   jsr ass_emit  ; output immediate operand
00:A14E 60              	  1419:   rts
                        	  1420: 
                        	  1421: ass_emit_immediate_too_high:
00:A14F A22C            	  1422:   ldx #44
00:A151 4CEBA0          	  1423:   jmp ass_error
                        	  1424: 
                        	  1425: 
                        	  1426: ass_emit_absolute:
00:A154 A573            	  1427:   lda ASS_VALUE
00:A156 20ADA0          	  1428:   jsr ass_emit  ; output absolute address - low-order byte
00:A159 A574            	  1429:   lda ASS_VALUE+1
00:A15B 20ADA0          	  1430:   jsr ass_emit  ; output absolute address - high-order byte
00:A15E 60              	  1431:   rts
                        	  1432: 
                        	  1433: 
                        	  1434: ;------------------------------------
                        	  1435: ;  Opcode master table
                        	  1436: ;------------------------------------
                        	  1437: 
                        	  1438:    .macro makeOpcodeLookup ; table of opcodes, length of opcode, wanted operand type, special handler
                        	  1439:      dfb   \1
                        	  1440:      dfb   \2
                        	  1441:      word  \3
                        	  1442:      word   \4
                        	  1443:    .endmacro
                        	  1444: 
                        	  1445: ;
                        	  1446: ;  So, for an opcode to match, it has to:
                        	  1447: ;     a) be the right length (usually 3 or 4 characters)
                        	  1448: ;     b) have the right type of operand (eg. ASS_OPERAND_IMMEDIATE)
                        	  1449: ;     c) the opcode must match the name in the list
                        	  1450: ;
                        	  1451: ;   If those conditions are met we output the corresponding opcode,
                        	  1452: ;   return with the operand type in A
                        	  1453: ;
                        	  1454: ;   Otherwise, we return 0 in A
                        	  1455: ;
                        	  1456: 
                        	  1457: OPCODE_LOOKUP_OPCODE_LENGTH = 0
                        	  1458: OPCODE_LOOKUP_OPERAND_TYPE = 1
                        	  1459: OPCODE_LOOKUP_OPCODE_TABLE = 2    ; 2 bytes
                        	  1460: OPCODE_LOOKUP_HANDLER = 4         ; 2 bytes
                        	  1461: OPCODE_LOOKUP_TABLE_SIZE = 6      ; all of the above
                        	  1462: 
                        	  1463: OPCODE_LOOKUP_TABLE = *
                        	  1464: ;
                        	  1465: ;  zero-page opcodes go first as they are preferred if we are accessing a zero-page address
                        	  1466: ;
                        	  1467:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE, OPCODE_ASS_OPERAND_ZERO_PAGE, ass_emit_zero_page ; (11)
00:A15F 03              	     1M      dfb   3
00:A160 0B              	     2M      dfb   ASS_OPERAND_ZERO_PAGE
00:A161 ECA4            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE
00:A163 2EA1            	     4M      word   ass_emit_zero_page 
                        	  1468:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE, OPCODE_ASS_OPERAND_ZERO_PAGE_TOKENISED, ass_emit_zero_page ; (11)
00:A165 01              	     1M      dfb   1
00:A166 0B              	     2M      dfb   ASS_OPERAND_ZERO_PAGE
00:A167 4DA5            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_TOKENISED
00:A169 2EA1            	     4M      word   ass_emit_zero_page 
                        	  1469:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT, ass_em
00:A16B 03              	     1M      dfb   3
00:A16C 0C              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
00:A16D 50A5            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
00:A16F 2EA1            	     4M      word   ass_emit_zero_page 
                        	  1470:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT_TOKENIS
00:A171 01              	     1M      dfb   1
00:A172 0C              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
00:A173 71A5            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT_TOKENISED
00:A175 2EA1            	     4M      word   ass_emit_zero_page 
                        	  1471:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X, ass_emit_z
00:A177 03              	     1M      dfb   3
00:A178 0D              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
00:A179 74A5            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
00:A17B 2EA1            	     4M      word   ass_emit_zero_page 
                        	  1472:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X_TOKENISED, 
00:A17D 01              	     1M      dfb   1
00:A17E 0D              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
00:A17F BDA5            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X_TOKENISED
00:A181 2EA1            	     4M      word   ass_emit_zero_page 
                        	  1473:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y, ass_emit_z
00:A183 03              	     1M      dfb   3
00:A184 0E              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
00:A185 C0A5            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
00:A187 2EA1            	     4M      word   ass_emit_zero_page 
                        	  1474:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDIRECT, OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT, ass_emit_zero_page ; (
00:A189 03              	     1M      dfb   3
00:A18A 0F              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDIRECT
00:A18B C9A5            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT
00:A18D 2EA1            	     4M      word   ass_emit_zero_page 
                        	  1475:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE_INDIRECT, OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_TOKENISED, ass_emit_zer
00:A18F 01              	     1M      dfb   1
00:A190 0F              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDIRECT
00:A191 EAA5            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_TOKENISED
00:A193 2EA1            	     4M      word   ass_emit_zero_page 
                        	  1476:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_
00:A195 03              	     1M      dfb   3
00:A196 10              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
00:A197 EDA5            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
00:A199 2EA1            	     4M      word   ass_emit_zero_page 
                        	  1477:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_
00:A19B 01              	     1M      dfb   1
00:A19C 10              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
00:A19D 0EA6            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y_TOKENISED
00:A19F 2EA1            	     4M      word   ass_emit_zero_page 
                        	  1478: 
                        	  1479: ;
                        	  1480: ;  non zero-page opcodes
                        	  1481: ;
                        	  1482:     makeOpcodeLookup  4,  ASS_OPERAND_ABSOLUTE, OPCODE_4_CHAR_ZERO_PAGE,  ass_emit_zero_page  ; (11)
00:A1A1 04              	     1M      dfb   4
00:A1A2 01              	     2M      dfb   ASS_OPERAND_ABSOLUTE
00:A1A3 68A3            	     3M      word  OPCODE_4_CHAR_ZERO_PAGE
00:A1A5 2EA1            	     4M      word   ass_emit_zero_page  
                        	  1483:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE, OPCODE_ASS_OPERAND_ABSOLUTE,  ass_emit_absolute  ; (1)
00:A1A7 03              	     1M      dfb   3
00:A1A8 01              	     2M      dfb   ASS_OPERAND_ABSOLUTE
00:A1A9 B9A3            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE
00:A1AB 54A1            	     4M      word   ass_emit_absolute  
                        	  1484:     makeOpcodeLookup  1,  ASS_OPERAND_ABSOLUTE, OPCODE_ASS_OPERAND_ABSOLUTE_TOKENISED,  ass_emit_absolute  ; (1)
00:A1AD 01              	     1M      dfb   1
00:A1AE 01              	     2M      dfb   ASS_OPERAND_ABSOLUTE
00:A1AF 22A4            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_TOKENISED
00:A1B1 54A1            	     4M      word   ass_emit_absolute  
                        	  1485: 
                        	  1486:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT, ass_emit
00:A1B3 03              	     1M      dfb   3
00:A1B4 02              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
00:A1B5 25A4            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
00:A1B7 54A1            	     4M      word   ass_emit_absolute 
                        	  1487:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X, ass_emit_abs
00:A1B9 03              	     1M      dfb   3
00:A1BA 03              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
00:A1BB 2AA4            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
00:A1BD 54A1            	     4M      word   ass_emit_absolute 
                        	  1488:     makeOpcodeLookup  1,  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X_TOKENISED, as
00:A1BF 01              	     1M      dfb   1
00:A1C0 03              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
00:A1C1 6FA4            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X_TOKENISED
00:A1C3 54A1            	     4M      word   ass_emit_absolute 
                        	  1489:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y, ass_emit_abs
00:A1C5 03              	     1M      dfb   3
00:A1C6 04              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
00:A1C7 72A4            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
00:A1C9 54A1            	     4M      word   ass_emit_absolute 
                        	  1490:     makeOpcodeLookup  1,  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y_TOKENISED, as
00:A1CB 01              	     1M      dfb   1
00:A1CC 04              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
00:A1CD 97A4            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y_TOKENISED
00:A1CF 54A1            	     4M      word   ass_emit_absolute 
                        	  1491:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDIRECT, OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT, ass_emit_absolute ; (5)
00:A1D1 03              	     1M      dfb   3
00:A1D2 05              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDIRECT
00:A1D3 B3A4            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT
00:A1D5 54A1            	     4M      word   ass_emit_absolute 
                        	  1492:     makeOpcodeLookup  1,  ASS_OPERAND_ABSOLUTE_INDIRECT, OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED, ass_emit_absolute ; (5
00:A1D7 01              	     1M      dfb   1
00:A1D8 05              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDIRECT
00:A1D9 E9A4            	     3M      word  OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED
00:A1DB 54A1            	     4M      word   ass_emit_absolute 
                        	  1493:     makeOpcodeLookup  3,  ASS_OPERAND_ACCUMULATOR_A, OPCODE_ASS_OPERAND_ACCUMULATOR_A, 0 ; (6)
00:A1DD 03              	     1M      dfb   3
00:A1DE 06              	     2M      dfb   ASS_OPERAND_ACCUMULATOR_A
00:A1DF 9AA4            	     3M      word  OPCODE_ASS_OPERAND_ACCUMULATOR_A
00:A1E1 0000            	     4M      word   0 
                        	  1494:     makeOpcodeLookup  3,  ASS_OPERAND_IMMEDIATE, OPCODE_ASS_OPERAND_IMMEDIATE, ass_emit_immediate ; (7)
00:A1E3 03              	     1M      dfb   3
00:A1E4 07              	     2M      dfb   ASS_OPERAND_IMMEDIATE
00:A1E5 B8A4            	     3M      word  OPCODE_ASS_OPERAND_IMMEDIATE
00:A1E7 41A1            	     4M      word   ass_emit_immediate 
                        	  1495:     makeOpcodeLookup  1,  ASS_OPERAND_IMMEDIATE, OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED, ass_emit_immediate ; (7)
00:A1E9 01              	     1M      dfb   1
00:A1EA 07              	     2M      dfb   ASS_OPERAND_IMMEDIATE
00:A1EB E9A4            	     3M      word  OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED
00:A1ED 41A1            	     4M      word   ass_emit_immediate 
                        	  1496:     makeOpcodeLookup  3,  ASS_OPERAND_IMPLIED,  OPCODE_3_CHAR_IMPLIED,    0  ; (8) and (10)
00:A1EF 03              	     1M      dfb   3
00:A1F0 08              	     2M      dfb   ASS_OPERAND_IMPLIED
00:A1F1 EBA2            	     3M      word  OPCODE_3_CHAR_IMPLIED
00:A1F3 0000            	     4M      word   0  
                        	  1497:     makeOpcodeLookup  4,  ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE, OPCODE_4_CHAR_BRANCH,     ass_fixup_bbr_branch  ; (9)
00:A1F5 04              	     1M      dfb   4
00:A1F6 12              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE
00:A1F7 75A2            	     3M      word  OPCODE_4_CHAR_BRANCH
00:A1F9 F5A0            	     4M      word   ass_fixup_bbr_branch  
                        	  1498:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE, OPCODE_3_CHAR_BRANCH,     ass_fixup_branch  ; (9)
00:A1FB 03              	     1M      dfb   3
00:A1FC 01              	     2M      dfb   ASS_OPERAND_ABSOLUTE
00:A1FD C6A2            	     3M      word  OPCODE_3_CHAR_BRANCH
00:A1FF 02A1            	     4M      word   ass_fixup_branch  
00:A201 00              	  1499:     dfb 0
                        	  1500: 
                        	  1501: 
                        	  1502: ;------------------------------------
                        	  1503: ;  directives
                        	  1504: ;------------------------------------
                        	  1505: 
                        	  1506: 
                        	  1507: DIRECTIVES = *
                        	  1508:   makeHandler "ASSERT",   asm_do_assert
00:A202 415353455254    	     1M    asciiz   "ASSERT"
00:A208 00
00:A209 11A6            	     2M    word  asm_do_assert
                        	  1509:   makeHandler "LIST",     asm_do_list
00:A20B 4C495354        	     1M    asciiz   "LIST"
00:A20F 00
00:A210 28A6            	     2M    word  asm_do_list
                        	  1510:   makeHandler "NOLIST",   asm_do_nolist
00:A212 4E4F4C495354    	     1M    asciiz   "NOLIST"
00:A218 00
00:A219 37A6            	     2M    word  asm_do_nolist
                        	  1511:   makeHandler "ASC",      asm_do_asc
00:A21B 415343          	     1M    asciiz   "ASC"
00:A21E 00
00:A21F 76A6            	     2M    word  asm_do_asc
                        	  1512:   makeHandler "ASCII",    asm_do_asc
00:A221 4153434949      	     1M    asciiz   "ASCII"
00:A226 00
00:A227 76A6            	     2M    word  asm_do_asc
                        	  1513:   makeHandler "ASCIIZ",   asm_do_string
00:A229 41534349495A    	     1M    asciiz   "ASCIIZ"
00:A22F 00
00:A230 91A6            	     2M    word  asm_do_string
                        	  1514:   makeHandler "STRING",   asm_do_string
00:A232 535452494E47    	     1M    asciiz   "STRING"
00:A238 00
00:A239 91A6            	     2M    word  asm_do_string
                        	  1515:   makeHandler "EQU",      asm_do_equ
00:A23B 455155          	     1M    asciiz   "EQU"
00:A23E 00
00:A23F 9AA6            	     2M    word  asm_do_equ
                        	  1516:   makeHandler "=",        asm_do_equ
00:A241 3D              	     1M    asciiz   "="
00:A242 00
00:A243 9AA6            	     2M    word  asm_do_equ
                        	  1517:   makeHandler "ORG",      asm_do_org
00:A245 4F5247          	     1M    asciiz   "ORG"
00:A248 00
00:A249 B7A6            	     2M    word  asm_do_org
                        	  1518:   makeHandler "DFB",      asm_do_dfb
00:A24B 444642          	     1M    asciiz   "DFB"
00:A24E 00
00:A24F CBA6            	     2M    word  asm_do_dfb
                        	  1519:   makeHandler "DFW",      asm_do_dfw
00:A251 444657          	     1M    asciiz   "DFW"
00:A254 00
00:A255 0BA7            	     2M    word  asm_do_dfw
                        	  1520:   makeHandler "WORD",     asm_do_dfw
00:A257 574F5244        	     1M    asciiz   "WORD"
00:A25B 00
00:A25C 0BA7            	     2M    word  asm_do_dfw
                        	  1521:   makeHandler "BLK",      asm_do_blk
00:A25E 424C4B          	     1M    asciiz   "BLK"
00:A261 00
00:A262 48A7            	     2M    word  asm_do_blk
                        	  1522:   makeHandler "RESERVE",  asm_do_reserve
00:A264 52455345525645  	     1M    asciiz   "RESERVE"
00:A26B 00
00:A26C 66A7            	     2M    word  asm_do_reserve
                        	  1523:   makeHandler "SYM",      asm_do_sym
00:A26E 53594D          	     1M    asciiz   "SYM"
00:A271 00
00:A272 81A7            	     2M    word  asm_do_sym
                        	  1524: 
00:A274 00              	  1525:   dfb 0
                        	  1526: 
                        	  1527: ;------------------------------------
                        	  1528: ;  4-character branch opcodes
                        	  1529: ;------------------------------------
                        	  1530: 
                        	  1531: 
                        	  1532: OPCODE_4_CHAR_BRANCH = *
00:A275 42425230        	  1533:   asc "BBR0",$0F
00:A279 0F
00:A27A 42425231        	  1534:   asc "BBR1",$1F
00:A27E 1F
00:A27F 42425232        	  1535:   asc "BBR2",$2F
00:A283 2F
00:A284 42425233        	  1536:   asc "BBR3",$3F
00:A288 3F
00:A289 42425234        	  1537:   asc "BBR4",$4F
00:A28D 4F
00:A28E 42425235        	  1538:   asc "BBR5",$5F
00:A292 5F
00:A293 42425236        	  1539:   asc "BBR6",$6F
00:A297 6F
00:A298 42425237        	  1540:   asc "BBR7",$7F
00:A29C 7F
00:A29D 42425330        	  1541:   asc "BBS0",$8F
00:A2A1 8F
00:A2A2 42425331        	  1542:   asc "BBS1",$9F
00:A2A6 9F
00:A2A7 42425332        	  1543:   asc "BBS2",$AF
00:A2AB AF
00:A2AC 42425333        	  1544:   asc "BBS3",$BF
00:A2B0 BF
00:A2B1 42425334        	  1545:   asc "BBS4",$CF
00:A2B5 CF
00:A2B6 42425335        	  1546:   asc "BBS5",$DF
00:A2BA DF
00:A2BB 42425336        	  1547:   asc "BBS6",$EF
00:A2BF EF
00:A2C0 42425337        	  1548:   asc "BBS7",$FF
00:A2C4 FF
00:A2C5 00              	  1549:   dfb 0
                        	  1550: 
                        	  1551: ;------------------------------------
                        	  1552: ;  3-character branch opcodes
                        	  1553: ;------------------------------------
                        	  1554: 
                        	  1555: 
                        	  1556: OPCODE_3_CHAR_BRANCH = *
00:A2C6 424343          	  1557:   asc "BCC",$90
00:A2C9 90
00:A2CA 424353          	  1558:   asc "BCS",$B0
00:A2CD B0
00:A2CE 424551          	  1559:   asc "BEQ",$F0
00:A2D1 F0
00:A2D2 424D49          	  1560:   asc "BMI",$30
00:A2D5 30
00:A2D6 424E45          	  1561:   asc "BNE",$D0
00:A2D9 D0
00:A2DA 42504C          	  1562:   asc "BPL",$10
00:A2DD 10
00:A2DE 425241          	  1563:   asc "BRA",$80
00:A2E1 80
00:A2E2 425643          	  1564:   asc "BVC",$50
00:A2E5 50
00:A2E6 425653          	  1565:   asc "BVS",$70
00:A2E9 70
00:A2EA 00              	  1566:   dfb 0
                        	  1567: 
                        	  1568: 
                        	  1569: ;------------------------------------
                        	  1570: ;  3-character implied opcodes (no operand)
                        	  1571: ;------------------------------------
                        	  1572: 
                        	  1573: OPCODE_3_CHAR_IMPLIED = *
00:A2EB 42524B          	  1574:   asc "BRK",$00
00:A2EE 00
00:A2EF 434C43          	  1575:   asc "CLC",$18
00:A2F2 18
00:A2F3 434C44          	  1576:   asc "CLD",$D8
00:A2F6 D8
00:A2F7 434C49          	  1577:   asc "CLI",$58
00:A2FA 58
00:A2FB 434C56          	  1578:   asc "CLV",$B8
00:A2FE B8
00:A2FF 444558          	  1579:   asc "DEX",$CA
00:A302 CA
00:A303 444559          	  1580:   asc "DEY",$88
00:A306 88
00:A307 494E58          	  1581:   asc "INX",$E8
00:A30A E8
00:A30B 494E59          	  1582:   asc "INY",$C8
00:A30E C8
00:A30F 4E4F50          	  1583:   asc "NOP",$EA
00:A312 EA
00:A313 504841          	  1584:   asc "PHA",$48
00:A316 48
00:A317 504850          	  1585:   asc "PHP",$08
00:A31A 08
00:A31B 504858          	  1586:   asc "PHX",$DA
00:A31E DA
00:A31F 504859          	  1587:   asc "PHY",$5A
00:A322 5A
00:A323 504C41          	  1588:   asc "PLA",$68
00:A326 68
00:A327 504C50          	  1589:   asc "PLP",$28
00:A32A 28
00:A32B 504C58          	  1590:   asc "PLX",$FA
00:A32E FA
00:A32F 504C59          	  1591:   asc "PLY",$7A
00:A332 7A
00:A333 525449          	  1592:   asc "RTI",$40
00:A336 40
00:A337 525453          	  1593:   asc "RTS",$60
00:A33A 60
00:A33B 534543          	  1594:   asc "SEC",$38
00:A33E 38
00:A33F 534544          	  1595:   asc "SED",$F8
00:A342 F8
00:A343 534549          	  1596:   asc "SEI",$78
00:A346 78
00:A347 535450          	  1597:   asc "STP",$DB
00:A34A DB
00:A34B 544158          	  1598:   asc "TAX",$AA
00:A34E AA
00:A34F 544159          	  1599:   asc "TAY",$A8
00:A352 A8
00:A353 545358          	  1600:   asc "TSX",$BA
00:A356 BA
00:A357 545841          	  1601:   asc "TXA",$8A
00:A35A 8A
00:A35B 545853          	  1602:   asc "TXS",$9A
00:A35E 9A
00:A35F 545941          	  1603:   asc "TYA",$98
00:A362 98
00:A363 574149          	  1604:   asc "WAI",$CB
00:A366 CB
00:A367 00              	  1605:   dfb 0
                        	  1606: 
                        	  1607: ;------------------------------------
                        	  1608: ;  4-character zero page opcodes (operand must be zero-page address)
                        	  1609: ;------------------------------------
                        	  1610: OPCODE_4_CHAR_ZERO_PAGE = *
00:A368 534D4230        	  1611:   asc "SMB0",$87
00:A36C 87
00:A36D 534D4231        	  1612:   asc "SMB1",$97
00:A371 97
00:A372 534D4232        	  1613:   asc "SMB2",$A7
00:A376 A7
00:A377 534D4233        	  1614:   asc "SMB3",$B7
00:A37B B7
00:A37C 534D4234        	  1615:   asc "SMB4",$C7
00:A380 C7
00:A381 534D4235        	  1616:   asc "SMB5",$D7
00:A385 D7
00:A386 534D4236        	  1617:   asc "SMB6",$E7
00:A38A E7
00:A38B 534D4237        	  1618:   asc "SMB7",$F7
00:A38F F7
00:A390 524D4230        	  1619:   asc "RMB0",$07
00:A394 07
00:A395 524D4231        	  1620:   asc "RMB1",$17
00:A399 17
00:A39A 524D4232        	  1621:   asc "RMB2",$27
00:A39E 27
00:A39F 524D4233        	  1622:   asc "RMB3",$37
00:A3A3 37
00:A3A4 524D4234        	  1623:   asc "RMB4",$47
00:A3A8 47
00:A3A9 524D4235        	  1624:   asc "RMB5",$57
00:A3AD 57
00:A3AE 524D4236        	  1625:   asc "RMB6",$67
00:A3B2 67
00:A3B3 524D4237        	  1626:   asc "RMB7",$77
00:A3B7 77
00:A3B8 00              	  1627:   dfb 0
                        	  1628: 
                        	  1629: ;------------------------------------
                        	  1630: ;  ASS_OPERAND_ABSOLUTE
                        	  1631: ;------------------------------------
                        	  1632: OPCODE_ASS_OPERAND_ABSOLUTE = *
00:A3B9 414443          	  1633:   asc "ADC",$6D
00:A3BC 6D
00:A3BD 414E44          	  1634:   asc "AND",$2D
00:A3C0 2D
00:A3C1 41534C          	  1635:   asc "ASL",$0E
00:A3C4 0E
00:A3C5 424954          	  1636:   asc "BIT",$2C
00:A3C8 2C
00:A3C9 434D50          	  1637:   asc "CMP",$CD
00:A3CC CD
00:A3CD 435058          	  1638:   asc "CPX",$EC
00:A3D0 EC
00:A3D1 435059          	  1639:   asc "CPY",$CC
00:A3D4 CC
00:A3D5 444543          	  1640:   asc "DEC",$CE
00:A3D8 CE
00:A3D9 454F52          	  1641:   asc "EOR",$4D
00:A3DC 4D
00:A3DD 494E43          	  1642:   asc "INC",$EE
00:A3E0 EE
00:A3E1 4A4D50          	  1643:   asc "JMP",$4C
00:A3E4 4C
00:A3E5 4A5352          	  1644:   asc "JSR",$20
00:A3E8 20
00:A3E9 4C4441          	  1645:   asc "LDA",$AD
00:A3EC AD
00:A3ED 4C4458          	  1646:   asc "LDX",$AE
00:A3F0 AE
00:A3F1 4C4459          	  1647:   asc "LDY",$AC
00:A3F4 AC
00:A3F5 4C5352          	  1648:   asc "LSR",$4E
00:A3F8 4E
00:A3F9 4F5241          	  1649:   asc "ORA",$0D
00:A3FC 0D
00:A3FD 524F4C          	  1650:   asc "ROL",$2E
00:A400 2E
00:A401 524F52          	  1651:   asc "ROR",$6E
00:A404 6E
00:A405 534243          	  1652:   asc "SBC",$ED
00:A408 ED
00:A409 535441          	  1653:   asc "STA",$8D
00:A40C 8D
00:A40D 535458          	  1654:   asc "STX",$8E
00:A410 8E
00:A411 535459          	  1655:   asc "STY",$8C
00:A414 8C
00:A415 53545A          	  1656:   asc "STZ",$9C
00:A418 9C
00:A419 545242          	  1657:   asc "TRB",$1C
00:A41C 1C
00:A41D 545342          	  1658:   asc "TSB",$0C
00:A420 0C
00:A421 00              	  1659:   dfb 0
                        	  1660: 
                        	  1661: ;------------------------------------
                        	  1662: ;  ASS_OPERAND_ABSOLUTE - for tokenised opcodes like AND
                        	  1663: ;------------------------------------
                        	  1664: OPCODE_ASS_OPERAND_ABSOLUTE_TOKENISED = *
00:A422 8D              	  1665:   dfb TOKEN_AND,$2D
00:A423 2D
00:A424 00              	  1666:   dfb 0
                        	  1667: 
                        	  1668: 
                        	  1669: ;------------------------------------
                        	  1670: ;  ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
                        	  1671: ;------------------------------------
                        	  1672: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT = *
00:A425 4A4D50          	  1673:   asc "JMP",$7C
00:A428 7C
00:A429 00              	  1674:   dfb 0
                        	  1675: 
                        	  1676: ;------------------------------------
                        	  1677: ;  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
                        	  1678: ;------------------------------------
                        	  1679: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X = *
00:A42A 414443          	  1680:   asc "ADC",$7D
00:A42D 7D
00:A42E 414E44          	  1681:   asc "AND",$3D
00:A431 3D
00:A432 41534C          	  1682:   asc "ASL",$1E
00:A435 1E
00:A436 424954          	  1683:   asc "BIT",$3C
00:A439 3C
00:A43A 434D50          	  1684:   asc "CMP",$DD
00:A43D DD
00:A43E 444543          	  1685:   asc "DEC",$DE
00:A441 DE
00:A442 454F52          	  1686:   asc "EOR",$5D
00:A445 5D
00:A446 494E43          	  1687:   asc "INC",$FE
00:A449 FE
00:A44A 4C4441          	  1688:   asc "LDA",$BD
00:A44D BD
00:A44E 4C4459          	  1689:   asc "LDY",$BC
00:A451 BC
00:A452 4C5352          	  1690:   asc "LSR",$5E
00:A455 5E
00:A456 4F5241          	  1691:   asc "ORA",$1D
00:A459 1D
00:A45A 524F4C          	  1692:   asc "ROL",$3E
00:A45D 3E
00:A45E 524F52          	  1693:   asc "ROR",$7E
00:A461 7E
00:A462 534243          	  1694:   asc "SBC",$FD
00:A465 FD
00:A466 535441          	  1695:   asc "STA",$9D
00:A469 9D
00:A46A 53545A          	  1696:   asc "STZ",$9E
00:A46D 9E
00:A46E 00              	  1697:   dfb 0
                        	  1698: 
                        	  1699: ;------------------------------------
                        	  1700: ;  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X - for tokenised opcodes like AND
                        	  1701: ;------------------------------------
                        	  1702: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X_TOKENISED = *
00:A46F 8D              	  1703:   dfb TOKEN_AND,$3D
00:A470 3D
00:A471 00              	  1704:   dfb 0
                        	  1705: 
                        	  1706: ;------------------------------------
                        	  1707: ;  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
                        	  1708: ;------------------------------------
                        	  1709: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y = *
00:A472 414443          	  1710:   asc "ADC",$79
00:A475 79
00:A476 414E44          	  1711:   asc "AND",$39
00:A479 39
00:A47A 434D50          	  1712:   asc "CMP",$D9
00:A47D D9
00:A47E 454F52          	  1713:   asc "EOR",$59
00:A481 59
00:A482 4C4441          	  1714:   asc "LDA",$B9
00:A485 B9
00:A486 4C4458          	  1715:   asc "LDX",$BE
00:A489 BE
00:A48A 4F5241          	  1716:   asc "ORA",$19
00:A48D 19
00:A48E 534243          	  1717:   asc "SBC",$F9
00:A491 F9
00:A492 535441          	  1718:   asc "STA",$99
00:A495 99
00:A496 00              	  1719:   dfb 0
                        	  1720: 
                        	  1721: ;------------------------------------
                        	  1722: ;  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y - for tokenised opcodes like AND
                        	  1723: ;------------------------------------
                        	  1724: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y_TOKENISED = *
00:A497 8D              	  1725:   dfb TOKEN_AND,$39
00:A498 39
00:A499 00              	  1726:   dfb 0
                        	  1727: 
                        	  1728: ;------------------------------------
                        	  1729: ;  ASS_OPERAND_ACCUMULATOR_A
                        	  1730: ;------------------------------------
                        	  1731: OPCODE_ASS_OPERAND_ACCUMULATOR_A = *
00:A49A 41534C          	  1732:   asc "ASL",$0A
00:A49D 0A
00:A49E 444543          	  1733:   asc "DEC",$3A
00:A4A1 3A
00:A4A2 494E43          	  1734:   asc "INC",$1A
00:A4A5 1A
00:A4A6 4C5352          	  1735:   asc "LSR",$4A
00:A4A9 4A
00:A4AA 524F4C          	  1736:   asc "ROL",$2A
00:A4AD 2A
00:A4AE 524F52          	  1737:   asc "ROR",$6A
00:A4B1 6A
00:A4B2 00              	  1738:   dfb 0
                        	  1739: 
                        	  1740: ;------------------------------------
                        	  1741: ;  ASS_OPERAND_ABSOLUTE_INDIRECT
                        	  1742: ;------------------------------------
                        	  1743: OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT = *
00:A4B3 4A4D50          	  1744:   asc "JMP",$6C
00:A4B6 6C
00:A4B7 00              	  1745:   dfb 0
                        	  1746: 
                        	  1747: ;------------------------------------
                        	  1748: ;  ASS_OPERAND_IMMEDIATE
                        	  1749: ;------------------------------------
                        	  1750: OPCODE_ASS_OPERAND_IMMEDIATE = *
00:A4B8 414443          	  1751:   asc "ADC",$69
00:A4BB 69
00:A4BC 414E44          	  1752:   asc "AND",$29
00:A4BF 29
00:A4C0 424954          	  1753:   asc "BIT",$89
00:A4C3 89
00:A4C4 434D50          	  1754:   asc "CMP",$C9
00:A4C7 C9
00:A4C8 435058          	  1755:   asc "CPX",$E0
00:A4CB E0
00:A4CC 435059          	  1756:   asc "CPY",$C0
00:A4CF C0
00:A4D0 454F52          	  1757:   asc "EOR",$49
00:A4D3 49
00:A4D4 4C4441          	  1758:   asc "LDA",$A9
00:A4D7 A9
00:A4D8 4C4458          	  1759:   asc "LDX",$A2
00:A4DB A2
00:A4DC 4C4459          	  1760:   asc "LDY",$A0
00:A4DF A0
00:A4E0 4F5241          	  1761:   asc "ORA",$09
00:A4E3 09
00:A4E4 534243          	  1762:   asc "SBC",$E9
00:A4E7 E9
00:A4E8 00              	  1763:   dfb 0
                        	  1764: 
                        	  1765: ;------------------------------------
                        	  1766: ;  ASS_OPERAND_IMMEDIATE - for tokenised opcodes like AND
                        	  1767: ;------------------------------------
                        	  1768: OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED = *
00:A4E9 8D              	  1769:   dfb TOKEN_AND,$29
00:A4EA 29
00:A4EB 00              	  1770:   dfb 0
                        	  1771: 
                        	  1772: ;------------------------------------
                        	  1773: ;  ASS_OPERAND_ZERO_PAGE
                        	  1774: ;------------------------------------
                        	  1775: OPCODE_ASS_OPERAND_ZERO_PAGE = *
00:A4EC 414443          	  1776:   asc "ADC",$65
00:A4EF 65
00:A4F0 414E44          	  1777:   asc "AND",$25
00:A4F3 25
00:A4F4 41534C          	  1778:   asc "ASL",$06
00:A4F7 06
00:A4F8 424954          	  1779:   asc "BIT",$24
00:A4FB 24
00:A4FC 434D50          	  1780:   asc "CMP",$C5
00:A4FF C5
00:A500 435058          	  1781:   asc "CPX",$E4
00:A503 E4
00:A504 435059          	  1782:   asc "CPY",$C4
00:A507 C4
00:A508 444543          	  1783:   asc "DEC",$C6
00:A50B C6
00:A50C 454F52          	  1784:   asc "EOR",$45
00:A50F 45
00:A510 494E43          	  1785:   asc "INC",$E6
00:A513 E6
00:A514 4C4441          	  1786:   asc "LDA",$A5
00:A517 A5
00:A518 4C4458          	  1787:   asc "LDX",$A6
00:A51B A6
00:A51C 4C4459          	  1788:   asc "LDY",$A4
00:A51F A4
00:A520 4C5352          	  1789:   asc "LSR",$46
00:A523 46
00:A524 4F5241          	  1790:   asc "ORA",$05
00:A527 05
00:A528 524F4C          	  1791:   asc "ROL",$26
00:A52B 26
00:A52C 524F52          	  1792:   asc "ROR",$66
00:A52F 66
00:A530 534243          	  1793:   asc "SBC",$E5
00:A533 E5
00:A534 535441          	  1794:   asc "STA",$85
00:A537 85
00:A538 535458          	  1795:   asc "STX",$86
00:A53B 86
00:A53C 535459          	  1796:   asc "STY",$84
00:A53F 84
00:A540 53545A          	  1797:   asc "STZ",$64
00:A543 64
00:A544 545242          	  1798:   asc "TRB",$14
00:A547 14
00:A548 545342          	  1799:   asc "TSB",$04
00:A54B 04
00:A54C 00              	  1800:   dfb 0
                        	  1801: 
                        	  1802: ;------------------------------------
                        	  1803: ;  ASS_OPERAND_ZERO_PAGE  - for tokenised opcodes like AND
                        	  1804: ;------------------------------------
                        	  1805: OPCODE_ASS_OPERAND_ZERO_PAGE_TOKENISED = *
00:A54D 8D              	  1806:   dfb TOKEN_AND,$25
00:A54E 25
00:A54F 00              	  1807:   dfb 0
                        	  1808: 
                        	  1809: 
                        	  1810: ;------------------------------------
                        	  1811: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
                        	  1812: ;------------------------------------
                        	  1813: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT = *
00:A550 414443          	  1814:   asc "ADC",$61
00:A553 61
00:A554 414E44          	  1815:   asc "AND",$21
00:A557 21
00:A558 434D50          	  1816:   asc "CMP",$C1
00:A55B C1
00:A55C 454F52          	  1817:   asc "EOR",$41
00:A55F 41
00:A560 4C4441          	  1818:   asc "LDA",$A1
00:A563 A1
00:A564 4F5241          	  1819:   asc "ORA",$01
00:A567 01
00:A568 534243          	  1820:   asc "SBC",$E1
00:A56B E1
00:A56C 535441          	  1821:   asc "STA",$81
00:A56F 81
00:A570 00              	  1822:   dfb 0
                        	  1823: 
                        	  1824: ;------------------------------------
                        	  1825: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT  - for tokenised opcodes like AND
                        	  1826: ;------------------------------------
                        	  1827: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT_TOKENISED  = *
00:A571 8D              	  1828:   dfb TOKEN_AND,$21
00:A572 21
00:A573 00              	  1829:   dfb 0
                        	  1830: 
                        	  1831: 
                        	  1832: ;------------------------------------
                        	  1833: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
                        	  1834: ;------------------------------------
                        	  1835: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X = *
00:A574 414443          	  1836:   asc "ADC",$75
00:A577 75
00:A578 414E44          	  1837:   asc "AND",$35
00:A57B 35
00:A57C 41534C          	  1838:   asc "ASL",$16
00:A57F 16
00:A580 424954          	  1839:   asc "BIT",$34
00:A583 34
00:A584 434D50          	  1840:   asc "CMP",$D5
00:A587 D5
00:A588 444543          	  1841:   asc "DEC",$D6
00:A58B D6
00:A58C 454F52          	  1842:   asc "EOR",$55
00:A58F 55
00:A590 494E43          	  1843:   asc "INC",$F6
00:A593 F6
00:A594 4C4441          	  1844:   asc "LDA",$B5
00:A597 B5
00:A598 4C4459          	  1845:   asc "LDY",$B4
00:A59B B4
00:A59C 4C5352          	  1846:   asc "LSR",$56
00:A59F 56
00:A5A0 4F5241          	  1847:   asc "ORA",$15
00:A5A3 15
00:A5A4 524F4C          	  1848:   asc "ROL",$36
00:A5A7 36
00:A5A8 524F52          	  1849:   asc "ROR",$76
00:A5AB 76
00:A5AC 534243          	  1850:   asc "SBC",$F5
00:A5AF F5
00:A5B0 535441          	  1851:   asc "STA",$95
00:A5B3 95
00:A5B4 535459          	  1852:   asc "STY",$94
00:A5B7 94
00:A5B8 53545A          	  1853:   asc "STZ",$74
00:A5BB 74
00:A5BC 00              	  1854:   dfb 0
                        	  1855: 
                        	  1856: ;------------------------------------
                        	  1857: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X  - for tokenised opcodes like AND
                        	  1858: ;------------------------------------
                        	  1859: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X_TOKENISED = *
00:A5BD 8D              	  1860:   dfb TOKEN_AND,$35
00:A5BE 35
00:A5BF 00              	  1861:   dfb 0
                        	  1862: 
                        	  1863: ;------------------------------------
                        	  1864: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
                        	  1865: ;------------------------------------
                        	  1866: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y = *
00:A5C0 4C4458          	  1867:   asc "LDX",$B6
00:A5C3 B6
00:A5C4 535458          	  1868:   asc "STX",$96
00:A5C7 96
00:A5C8 00              	  1869:   dfb 0
                        	  1870: 
                        	  1871: ;------------------------------------
                        	  1872: ;  ASS_OPERAND_ZERO_PAGE_INDIRECT
                        	  1873: ;------------------------------------
                        	  1874: OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT = *
00:A5C9 414443          	  1875:   asc "ADC",$72
00:A5CC 72
00:A5CD 414E44          	  1876:   asc "AND",$32
00:A5D0 32
00:A5D1 434D50          	  1877:   asc "CMP",$D2
00:A5D4 D2
00:A5D5 454F52          	  1878:   asc "EOR",$52
00:A5D8 52
00:A5D9 4C4441          	  1879:   asc "LDA",$B2
00:A5DC B2
00:A5DD 4F5241          	  1880:   asc "ORA",$12
00:A5E0 12
00:A5E1 534243          	  1881:   asc "SBC",$F2
00:A5E4 F2
00:A5E5 535441          	  1882:   asc "STA",$92
00:A5E8 92
00:A5E9 00              	  1883:   dfb 0
                        	  1884: 
                        	  1885: ;------------------------------------
                        	  1886: ;  ASS_OPERAND_ZERO_PAGE_INDIRECT  - for tokenised opcodes like AND
                        	  1887: ;------------------------------------
                        	  1888: OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_TOKENISED = *
00:A5EA 8D              	  1889:   dfb TOKEN_AND,$32
00:A5EB 32
00:A5EC 00              	  1890:   dfb 0
                        	  1891: 
                        	  1892: ;------------------------------------
                        	  1893: ;  ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
                        	  1894: ;------------------------------------
                        	  1895: OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y = *
00:A5ED 414443          	  1896:   asc "ADC",$71
00:A5F0 71
00:A5F1 414E44          	  1897:   asc "AND",$31
00:A5F4 31
00:A5F5 434D50          	  1898:   asc "CMP",$D1
00:A5F8 D1
00:A5F9 454F52          	  1899:   asc "EOR",$51
00:A5FC 51
00:A5FD 4C4441          	  1900:   asc "LDA",$B1
00:A600 B1
00:A601 4F5241          	  1901:   asc "ORA",$11
00:A604 11
00:A605 534243          	  1902:   asc "SBC",$F1
00:A608 F1
00:A609 535441          	  1903:   asc "STA",$91
00:A60C 91
00:A60D 00              	  1904:   dfb 0
                        	  1905: 
                        	  1906: ;------------------------------------
                        	  1907: ;  ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y - for tokenised opcodes like AND
                        	  1908: ;------------------------------------
                        	  1909: OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y_TOKENISED  = *
00:A60E 8D              	  1910:   dfb TOKEN_AND,$31
00:A60F 31
00:A610 00              	  1911:   dfb 0
                        	  1912: 
                        	  1913: 
                        	  1914: ; ---------------------------
                        	  1915: ; Compiler directives
                        	  1916: ; ---------------------------
                        	  1917: 
                        	  1918: ;
                        	  1919: ;  ASSERT <expression>  - raises an error if <expression> is zero
                        	  1920: ;
                        	  1921: asm_do_assert:
00:A611 A56B            	  1922:   lda ASS_OPERAND
00:A613 C901            	  1923:   cmp #ASS_OPERAND_ABSOLUTE
00:A615 D00E            	  1924:   bne asm_do_constant_expectedJ
00:A617 A500            	  1925:   lda VALUE
00:A619 0501            	  1926:   ora VALUE+1
00:A61B 0502            	  1927:   ora VALUE+2
00:A61D F001            	  1928:   beq asm_do_assert_failed
00:A61F 60              	  1929:   rts
                        	  1930: 
                        	  1931: asm_do_assert_failed:
00:A620 A234            	  1932:   ldx #52
00:A622 4CEBA0          	  1933:   jmp ass_error
                        	  1934: 
00:A625 4CBDA6          	  1935: asm_do_constant_expectedJ jmp asm_do_constant_expected
                        	  1936: 
                        	  1937: ;
                        	  1938: ; LIST (0= none, 1=source, 2=opcodes, 4=symbols, can OR these together)
                        	  1939: ; LIST  is the same as LIST 3
                        	  1940: 
                        	  1941: asm_do_list = *
                        	  1942: 
                        	  1943: ;   lda #'f'
                        	  1944: ;   jsr ass_debug_point
                        	  1945: 
00:A628 A56B            	  1946:   lda ASS_OPERAND
00:A62A C908            	  1947:   cmp #ASS_OPERAND_IMPLIED      ; implied (ie. no operand) will resolve to be the same as LIST 3
00:A62C F01A            	  1948:   beq asm_do_list_no_operand
00:A62E C901            	  1949:   cmp #ASS_OPERAND_ABSOLUTE
00:A630 F01A            	  1950:   beq asm_do_list_ok
00:A632 A202            	  1951:   ldx #2    ; ERROR: constant expected
00:A634 4CEBA0          	  1952:   jmp ass_error
                        	  1953: 
                        	  1954: ;
                        	  1955: ;  NOLIST is the same as LIST 0
                        	  1956: ;
                        	  1957: asm_do_nolist:
00:A637 A56B            	  1958:   lda ASS_OPERAND
00:A639 C908            	  1959:   cmp #ASS_OPERAND_IMPLIED
00:A63B F005            	  1960:   beq asm_do_nolist_ok              ; should have no operand
00:A63D A217            	  1961:   ldx #23   ; ERROR: Illegal factor
00:A63F 4CEBA0          	  1962:   jmp ass_error
                        	  1963: asm_do_nolist_ok:
00:A642 A900            	  1964:   lda #0
00:A644 8500            	  1965:   sta VALUE
00:A646 8004            	  1966:   bra asm_do_list_ok
                        	  1967: 
                        	  1968: asm_do_list_no_operand:
00:A648 A903            	  1969:   lda #3
00:A64A 8573            	  1970:   sta ASS_VALUE
                        	  1971: asm_do_list_ok:
00:A64C A576            	  1972:   lda ASS_PASS
00:A64E F025            	  1973:   beq asm_do_list_first_pass  ; ignore on first pass
                        	  1974: 
                        	  1975: ;  lda ASS_VALUE
                        	  1976: ;  clc
                        	  1977: ;  adc #'0'
                        	  1978: ;  jsr ass_debug_point
                        	  1979: 
00:A650 A573            	  1980:   lda ASS_VALUE
00:A652 2901            	  1981:   and #$01
00:A654 F00C            	  1982:   beq asm_do_list_not    ; no listing wanted
00:A656 A904            	  1983:   lda #FLAG_LIST_SOURCE ; already listing?
00:A658 25BE            	  1984:   and system_flags
00:A65A D00A            	  1985:   bne  asm_do_list1   ; yep
00:A65C A904            	  1986:   lda #FLAG_LIST_SOURCE
00:A65E 04BE            	  1987:   tsb system_flags
                        	  1988: ;  jsr token_line        ; list the current line  TODO: don't know, I think it bumps the line number wrongly
00:A660 8004            	  1989:   bra asm_do_list1
                        	  1990: 
                        	  1991: ;
                        	  1992: ;  turn off list flag
                        	  1993: ;
                        	  1994: asm_do_list_not:
00:A662 A904            	  1995:   lda #FLAG_LIST_SOURCE
00:A664 14BE            	  1996:   trb system_flags
                        	  1997: 
                        	  1998: asm_do_list1:
                        	  1999: 
                        	  2000: 
00:A666 A573            	  2001:   lda ASS_VALUE
00:A668 2902            	  2002:   and #$02
00:A66A 852E            	  2003:   sta DCODE
                        	  2004: 
                        	  2005: 
00:A66C A573            	  2006:   lda ASS_VALUE
00:A66E 2904            	  2007:   and #$04
00:A670 8582            	  2008:   sta show_symbols
                        	  2009: ;
                        	  2010: ;  output a newline, to get past the asterisks
                        	  2011: ;
00:A672 206894          	  2012:   jsr CROUT
                        	  2013: asm_do_list_first_pass:
00:A675 60              	  2014:   rts
                        	  2015: 
                        	  2016: ;
                        	  2017: ;  ASC "String"
                        	  2018: ;
                        	  2019: asm_do_asc = *
00:A676 A56B            	  2020:   lda ASS_OPERAND
00:A678 C911            	  2021:   cmp #ASS_OPERAND_STRING
00:A67A F005            	  2022:   beq asm_do_asc_ok
00:A67C A208            	  2023:   ldx #8    ; ERROR: incorrect string
00:A67E 4CEBA0          	  2024:   jmp ass_error
                        	  2025: ;
                        	  2026: ;  now emit the string
                        	  2027: ;
                        	  2028: asm_do_asc_ok:
00:A681 A000            	  2029:   ldy  #0
                        	  2030: asm_do_asc_loop:
00:A683 B90002          	  2031:   lda  INBUF,Y
00:A686 C8              	  2032:   iny         ; onto next character in the string
00:A687 5A              	  2033:   phy
00:A688 20ADA0          	  2034:   jsr ass_emit
00:A68B 7A              	  2035:   ply
                        	  2036: 
                        	  2037: asm_do_asc_next:
00:A68C C692            	  2038:   dec token_length
00:A68E D0F3            	  2039:   bne asm_do_asc_loop
00:A690 60              	  2040:   rts
                        	  2041: 
                        	  2042: 
                        	  2043: ;
                        	  2044: ;  ASCIIZ / STRING - output a string with a null terminator
                        	  2045: ;
                        	  2046: 
                        	  2047: asm_do_string:
00:A691 2076A6          	  2048:   jsr asm_do_asc    ; do the string
00:A694 A900            	  2049:   lda #0            ; and the terminator
00:A696 20ADA0          	  2050:   jsr ass_emit
00:A699 60              	  2051:   rts
                        	  2052: 
                        	  2053: 
                        	  2054: ;
                        	  2055: ;  EQU
                        	  2056: ;
                        	  2057: ;  The label, which must be present, takes on the value of the expression
                        	  2058: ;
                        	  2059: 
                        	  2060: asm_do_equ:
00:A69A A56B            	  2061:   lda ASS_OPERAND
00:A69C C901            	  2062:   cmp #ASS_OPERAND_ABSOLUTE
00:A69E D01D            	  2063:   bne asm_do_constant_expected
00:A6A0 A583            	  2064:   lda ass_current_label
00:A6A2 0584            	  2065:   ora ass_current_label+1
00:A6A4 D005            	  2066:   bne asm_do_equ_have_label
00:A6A6 A230            	  2067:   ldx #48    ; ERROR: label required
00:A6A8 4CEBA0          	  2068:   jmp ass_error
                        	  2069: 
                        	  2070: asm_do_equ_have_label:
00:A6AB A004            	  2071:   ldy #SYMDSP
00:A6AD A573            	  2072:   lda ASS_VALUE
00:A6AF 9183            	  2073:   sta (ass_current_label),y
00:A6B1 C8              	  2074:   iny
00:A6B2 A574            	  2075:   lda ASS_VALUE+1
00:A6B4 9183            	  2076:   sta (ass_current_label),y
00:A6B6 60              	  2077:   rts
                        	  2078: 
                        	  2079: ;
                        	  2080: ;  ORG
                        	  2081: ;
                        	  2082: ;  The program counter becomes the value of the expression
                        	  2083: ;
                        	  2084: 
                        	  2085: asm_do_org:
00:A6B7 A56B            	  2086:   lda ASS_OPERAND
00:A6B9 C901            	  2087:   cmp #ASS_OPERAND_ABSOLUTE
00:A6BB F005            	  2088:   beq asm_do_org_ok
                        	  2089: asm_do_constant_expected:
00:A6BD A202            	  2090:   ldx #2    ; ERROR: constant expected
00:A6BF 4CEBA0          	  2091:   jmp ass_error
                        	  2092: 
                        	  2093: asm_do_org_ok:
00:A6C2 A573            	  2094:   lda ASS_VALUE
00:A6C4 8523            	  2095:   sta PCODE
00:A6C6 A574            	  2096:   lda ASS_VALUE+1
00:A6C8 8524            	  2097:   sta PCODE+1
00:A6CA 60              	  2098:   rts
                        	  2099: 
                        	  2100: ;
                        	  2101: ;  DFB - define one byte (value being the expression)
                        	  2102: ;
                        	  2103: 
                        	  2104: asm_do_dfb:
00:A6CB A56B            	  2105:   lda ASS_OPERAND
00:A6CD C912            	  2106:   cmp #ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE  ; multiple values?
00:A6CF F008            	  2107:   beq asm_do_dfb_multiple
00:A6D1 C901            	  2108:   cmp #ASS_OPERAND_ABSOLUTE
00:A6D3 D0E8            	  2109:   bne asm_do_constant_expected
00:A6D5 20FDA6          	  2110:   jsr asm_emit_one_byte
00:A6D8 60              	  2111:   rts
                        	  2112: 
                        	  2113: ;
                        	  2114: ;  so if we got here we thought we had two values (like a BBR0 $12,foo)
                        	  2115: ;  - the first is in REMAIN and the other in VALUE
                        	  2116: ;
                        	  2117: ;  let's emit REMAIN, then VALUE, then look for other values
                        	  2118: ;
                        	  2119: asm_do_dfb_multiple:
00:A6D9 A507            	  2120:   lda REMAIN+1
00:A6DB D01B            	  2121:   bne asm_do_dfb_too_big
00:A6DD A508            	  2122:   lda REMAIN+2
00:A6DF D017            	  2123:   bne asm_do_dfb_too_big
00:A6E1 A506            	  2124:   lda REMAIN
00:A6E3 20ADA0          	  2125:   jsr ass_emit  ; emit REMAIN
                        	  2126: asm_do_dfb_multiple_loop:
00:A6E6 20FDA6          	  2127:   jsr asm_emit_one_byte  ; emit VALUE
00:A6E9 A593            	  2128:   lda token_type
00:A6EB C92C            	  2129:   cmp #','      ; another?
00:A6ED D008            	  2130:   bne asm_do_dfb_multiple_done
00:A6EF 20D3CB          	  2131:   jsr get_token
00:A6F2 20189F          	  2132:   jsr ass_get_value  ; should have some sort of address now in VALUE
00:A6F5 80EF            	  2133:   bra asm_do_dfb_multiple_loop
                        	  2134: 
                        	  2135: asm_do_dfb_multiple_done:
00:A6F7 60              	  2136:   rts
                        	  2137: 
                        	  2138: 
                        	  2139: asm_do_dfb_too_big:
00:A6F8 A22C            	  2140:   ldx #44
00:A6FA 4CEBA0          	  2141:   jmp ass_error
                        	  2142: 
                        	  2143: asm_emit_one_byte:
00:A6FD A574            	  2144:   lda ASS_VALUE+1
00:A6FF D0F7            	  2145:   bne asm_do_dfb_too_big
00:A701 A575            	  2146:   lda ASS_VALUE+2
00:A703 D0F3            	  2147:   bne asm_do_dfb_too_big
00:A705 A573            	  2148:   lda ASS_VALUE
00:A707 20ADA0          	  2149:   jsr ass_emit
00:A70A 60              	  2150:   rts
                        	  2151: 
                        	  2152: 
                        	  2153: ;
                        	  2154: ;  DFW - define two bytes (value being the expression)
                        	  2155: ;
                        	  2156: 
                        	  2157: asm_do_dfw:
00:A70B A56B            	  2158:   lda ASS_OPERAND
00:A70D C912            	  2159:   cmp #ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE  ; multiple values?
00:A70F F008            	  2160:   beq asm_do_dfw_multiple
00:A711 C901            	  2161:   cmp #ASS_OPERAND_ABSOLUTE
00:A713 D0A8            	  2162:   bne asm_do_constant_expected
00:A715 2039A7          	  2163:   jsr asm_emit_two_bytes
00:A718 60              	  2164:   rts
                        	  2165: 
                        	  2166: ;
                        	  2167: ;  so if we got here we thought we had two values (like a BBR0 $12,foo)
                        	  2168: ;  - the first is in REMAIN and the other in VALUE
                        	  2169: ;
                        	  2170: ;  let's emit REMAIN, then VALUE, then look for other values
                        	  2171: ;
                        	  2172: asm_do_dfw_multiple:
00:A719 A508            	  2173:   lda REMAIN+2
00:A71B D0DB            	  2174:   bne asm_do_dfb_too_big
00:A71D A506            	  2175:   lda REMAIN
00:A71F 20ADA0          	  2176:   jsr ass_emit  ; emit REMAIN
00:A722 A507            	  2177:   lda REMAIN+1
00:A724 20ADA0          	  2178:   jsr ass_emit  ; emit REMAIN+1
                        	  2179: asm_do_dfw_multiple_loop:
00:A727 2039A7          	  2180:   jsr asm_emit_two_bytes  ; emit VALUE
00:A72A A593            	  2181:   lda token_type
00:A72C C92C            	  2182:   cmp #','      ; another?
00:A72E D008            	  2183:   bne asm_do_dfw_multiple_done
00:A730 20D3CB          	  2184:   jsr get_token
00:A733 20189F          	  2185:   jsr ass_get_value  ; should have some sort of address now in VALUE
00:A736 80EF            	  2186:   bra asm_do_dfw_multiple_loop
                        	  2187: 
                        	  2188: asm_do_dfw_multiple_done:
00:A738 60              	  2189:   rts
                        	  2190: 
                        	  2191: 
                        	  2192: asm_emit_two_bytes:
00:A739 A575            	  2193:   lda ASS_VALUE+2
00:A73B D0BB            	  2194:   bne asm_do_dfb_too_big
00:A73D A573            	  2195:   lda ASS_VALUE
00:A73F 20ADA0          	  2196:   jsr ass_emit
00:A742 A574            	  2197:   lda ASS_VALUE+1
00:A744 20ADA0          	  2198:   jsr ass_emit
00:A747 60              	  2199:   rts
                        	  2200: 
                        	  2201: 
                        	  2202: 
                        	  2203: ;
                        	  2204: ;  BLK - zero fill <expression> bytes (eg. BLK 5 output 5 zeroes)
                        	  2205: ;
                        	  2206: 
                        	  2207: asm_do_blk:
00:A748 A56B            	  2208:   lda ASS_OPERAND
00:A74A C901            	  2209:   cmp #ASS_OPERAND_ABSOLUTE
00:A74C D030            	  2210:   bne asm_do_constant_expectedJ2
00:A74E A575            	  2211:   lda ASS_VALUE+2
00:A750 D0A6            	  2212:   bne asm_do_dfb_too_big
                        	  2213: ;
                        	  2214: ; handle (obscure) case of them defining zero bytes
                        	  2215: ;
00:A752 A573            	  2216:   lda ASS_VALUE
00:A754 0574            	  2217:   ora ASS_VALUE+1
00:A756 F00D            	  2218:   beq asm_do_blk_done
                        	  2219: asm_do_blk_loop:
                        	  2220: ;
                        	  2221: ;  emit one zero
                        	  2222: ;
00:A758 A900            	  2223:   lda #0
00:A75A 20ADA0          	  2224:   jsr ass_emit
00:A75D C673            	  2225:   dec ASS_VALUE
00:A75F D0F7            	  2226:   bne asm_do_blk_loop
00:A761 C674            	  2227:   dec ASS_VALUE+1
00:A763 10F3            	  2228:   bpl asm_do_blk_loop
                        	  2229: asm_do_blk_done:
00:A765 60              	  2230:   rts
                        	  2231: 
                        	  2232: ;
                        	  2233: ;  RESERVE - reserve <expression> bytes without writing to them
                        	  2234: ;   useful for leaving a gap (eg. for zero-page variables)
                        	  2235: ;
                        	  2236: 
                        	  2237: asm_do_reserve:
00:A766 A56B            	  2238:   lda ASS_OPERAND
00:A768 C901            	  2239:   cmp #ASS_OPERAND_ABSOLUTE
00:A76A D012            	  2240:   bne asm_do_constant_expectedJ2
00:A76C A575            	  2241:   lda ASS_VALUE+2
00:A76E D088            	  2242:   bne asm_do_dfb_too_big
00:A770 18              	  2243:   clc
00:A771 A523            	  2244:   lda PCODE
00:A773 6573            	  2245:   adc ASS_VALUE
00:A775 8523            	  2246:   sta PCODE
00:A777 A524            	  2247:   lda PCODE+1
00:A779 6574            	  2248:   adc ASS_VALUE+1
00:A77B 8524            	  2249:   sta PCODE+1
00:A77D 60              	  2250:   rts
                        	  2251: 
00:A77E 4CBDA6          	  2252: asm_do_constant_expectedJ2 jmp asm_do_constant_expected
                        	  2253: 
                        	  2254: ;
                        	  2255: ;  SYM <address> symbol table relocation
                        	  2256: ;
                        	  2257: asm_do_sym:
00:A781 A56B            	  2258:   lda ASS_OPERAND
00:A783 C901            	  2259:   cmp #ASS_OPERAND_ABSOLUTE
00:A785 D0F7            	  2260:   bne asm_do_constant_expectedJ2
                        	  2261: ;
                        	  2262: ;  only relocate symbol table on the first pass
                        	  2263: ;
00:A787 A576            	  2264:   lda ASS_PASS
00:A789 D00F            	  2265:   bne asm_do_sym_done
                        	  2266: 
00:A78B A573            	  2267:   lda  ASS_VALUE
00:A78D 8531            	  2268:   sta  ENDSYM
00:A78F 852F            	  2269:   sta  STARTSYM
00:A791 A574            	  2270:   lda  ASS_VALUE+1
00:A793 8532            	  2271:   sta  ENDSYM+1        ; store symbol table address
00:A795 8530            	  2272:   sta  STARTSYM+1
                        	  2273: ;
                        	  2274: ;  put our library functions back into the symbol table
                        	  2275: ;
00:A797 20BBAC          	  2276:   jsr  add_assembler_library_functions  ; add our inbuilt functions to the symbol table
                        	  2277: 
                        	  2278: asm_do_sym_done:
00:A79A 60              	  2279:   rts
                        	  2280: ;
                        	  2281: 
                        	  2282: 
00:A79B 41646472204E616D	  2283: info_message asciiz "Addr Name\n"
00:A7A3 650A
00:A7A5 00
                        	  2284: 
                        	  2285: list_symbols  = *
00:A7A6 A99B            	  2286:          lda #<info_message
00:A7A8 A2A7            	  2287:          ldx #>info_message
00:A7AA 202682          	  2288:          jsr print
                        	  2289: 
00:A7AD A532            	  2290:          lda  ENDSYM+1    ; get the end of the symbol table
00:A7AF 8541            	  2291:          sta  SYMITM+1    ; make it the current symbol
00:A7B1 A531            	  2292:          lda  ENDSYM
00:A7B3 800B            	  2293:          bra  list_symbols_check
                        	  2294: 
                        	  2295: list_symbols_next =  *
00:A7B5 A000            	  2296:          ldy  #SYMPRV
00:A7B7 B140            	  2297:          lda  (SYMITM),Y
00:A7B9 AA              	  2298:          tax
00:A7BA C8              	  2299:          iny
00:A7BB B140            	  2300:          lda  (SYMITM),Y
00:A7BD 8541            	  2301:          sta  SYMITM+1   ; previous link
00:A7BF 8A              	  2302:          txa
                        	  2303: ;
                        	  2304: ;  go to the previous symbol table item
                        	  2305: ;
                        	  2306: list_symbols_check     =  *
00:A7C0 8540            	  2307:          sta  SYMITM
00:A7C2 C52F            	  2308:          cmp  STARTSYM
00:A7C4 D009            	  2309:          bne  list_symbols_line
00:A7C6 A541            	  2310:          lda  SYMITM+1
00:A7C8 C530            	  2311:          cmp  STARTSYM+1
00:A7CA D003            	  2312:          bne  list_symbols_line       ; more to go
00:A7CC 4CFAA7          	  2313:          jmp  list_symbols_done       ; finished if symitm and symitm+1 are both zero
                        	  2314: 
                        	  2315: list_symbols_line = *
00:A7CF A004            	  2316:          ldy  #SYMDSP
00:A7D1 C8              	  2317:          iny
00:A7D2 B140            	  2318:          lda  (SYMITM),Y  ; displacement
00:A7D4 20DD94          	  2319:          jsr  PRBYTE
00:A7D7 88              	  2320:          dey
00:A7D8 B140            	  2321:          lda  (SYMITM),Y  ; displacement
00:A7DA 20DD94          	  2322:          jsr  PRBYTE
00:A7DD A920            	  2323:          lda  #' '
00:A7DF 20C594          	  2324:          jsr  PRCHAR
00:A7E2 A009            	  2325:          ldy  #SYMLEN
00:A7E4 B140            	  2326:          lda  (SYMITM),Y  ; length
00:A7E6 AA              	  2327:          tax
00:A7E7 A00A            	  2328:          ldy  #SYMNAM
                        	  2329: list_symbols_name = *
00:A7E9 B140            	  2330:          lda  (SYMITM),Y  ; name
00:A7EB 5A              	  2331:          phy
00:A7EC 20C594          	  2332:          jsr  PRCHAR
00:A7EF 7A              	  2333:          ply
00:A7F0 C8              	  2334:          iny
00:A7F1 CA              	  2335:          dex
00:A7F2 D0F5            	  2336:          bne list_symbols_name
00:A7F4 206894          	  2337:          jsr CROUT
00:A7F7 4CB5A7          	  2338:          jmp list_symbols_next
                        	  2339: 
                        	  2340: list_symbols_done = *
00:A7FA 60              	  2341:          rts
                        	  2342: 
                        	  2343: assembler_library_functions_table:
                        	  2344: ;
                        	  2345: ;  put them in reverse alphabetic order so they come out in alphabetic
                        	  2346: ;  order if you request a symbols list
                        	  2347: ;
                        	  2348:   makeAsmLibraryFunction "write_to_serial",      write_to_serial
00:A7FB 77726974655F746F	     1M      asciiz   "write_to_serial"
00:A803 5F73657269616C
00:A80A 00
00:A80B 3DCB            	     2M      word     write_to_serial
                        	  2349:   makeAsmLibraryFunction "write_to_lcd",         write_to_lcd
00:A80D 77726974655F746F	     1M      asciiz   "write_to_lcd"
00:A815 5F6C6364
00:A819 00
00:A81A 48CB            	     2M      word     write_to_lcd
                        	  2350:   makeAsmLibraryFunction "write_function",       write_function
00:A81C 77726974655F6675	     1M      asciiz   "write_function"
00:A824 6E6374696F6E
00:A82A 00
00:A82B 1700            	     2M      word     write_function
                        	  2351:   makeAsmLibraryFunction "write_char",           write_char
00:A82D 77726974655F6368	     1M      asciiz   "write_char"
00:A835 6172
00:A837 00
00:A838 9DCB            	     2M      word     write_char
                        	  2352:   makeAsmLibraryFunction "value",                VALUE
00:A83A 76616C7565      	     1M      asciiz   "value"
00:A83F 00
00:A840 0000            	     2M      word     VALUE
                        	  2353:   makeAsmLibraryFunction "value2",               VALUE2
00:A842 76616C756532    	     1M      asciiz   "value2"
00:A848 00
00:A849 0300            	     2M      word     VALUE2
                        	  2354:   makeAsmLibraryFunction "typing_latency",       typing_latency
00:A84B 747970696E675F6C	     1M      asciiz   "typing_latency"
00:A853 6174656E6379
00:A859 00
00:A85A 0D00            	     2M      word     typing_latency
                        	  2355:   makeAsmLibraryFunction "tknjmp",               TKNJMP
00:A85C 746B6E6A6D70    	     1M      asciiz   "tknjmp"
00:A862 00
00:A863 D291            	     2M      word     TKNJMP
                        	  2356:   makeAsmLibraryFunction "reset",                START
00:A865 7265736574      	     1M      asciiz   "reset"
00:A86A 00
00:A86B 74DC            	     2M      word     START
                        	  2357:   makeAsmLibraryFunction "srce",                 SRCE
00:A86D 73726365        	     1M      asciiz   "srce"
00:A871 00
00:A872 0000            	     2M      word     SRCE
                        	  2358:   makeAsmLibraryFunction "spi_transfer",         spi_transfer
00:A874 7370695F7472616E	     1M      asciiz   "spi_transfer"
00:A87C 73666572
00:A880 00
00:A881 86D3            	     2M      word     spi_transfer
                        	  2359:   makeAsmLibraryFunction "spi_ss_low",           spi_ss_low
00:A883 7370695F73735F6C	     1M      asciiz   "spi_ss_low"
00:A88B 6F77
00:A88D 00
00:A88E EAD3            	     2M      word     spi_ss_low
                        	  2360:   makeAsmLibraryFunction "spi_ss_high",          spi_ss_high
00:A890 7370695F73735F68	     1M      asciiz   "spi_ss_high"
00:A898 696768
00:A89B 00
00:A89C F2D3            	     2M      word     spi_ss_high
                        	  2361:   makeAsmLibraryFunction "spi_send_two_bytes",   spi_send_two_bytes
00:A89E 7370695F73656E64	     1M      asciiz   "spi_send_two_bytes"
00:A8A6 5F74776F5F627974
00:A8AE 6573
00:A8B0 00
00:A8B1 FAD3            	     2M      word     spi_send_two_bytes
                        	  2362:   makeAsmLibraryFunction "spi_init",             spi_init
00:A8B3 7370695F696E6974	     1M      asciiz   "spi_init"
00:A8BB 00
00:A8BC 50D3            	     2M      word     spi_init
                        	  2363:   makeAsmLibraryFunction "serial_print_message", serial_print_message
00:A8BE 73657269616C5F70	     1M      asciiz   "serial_print_message"
00:A8C6 72696E745F6D6573
00:A8CE 73616765
00:A8D2 00
00:A8D3 C2CB            	     2M      word     serial_print_message
                        	  2364:   makeAsmLibraryFunction "serial_available",     serial_available
00:A8D5 73657269616C5F61	     1M      asciiz   "serial_available"
00:A8DD 7661696C61626C65
00:A8E5 00
00:A8E6 64CB            	     2M      word     serial_available
                        	  2365:   makeAsmLibraryFunction "nmi",                  RESTART
00:A8E8 6E6D69          	     1M      asciiz   "nmi"
00:A8EB 00
00:A8EC 90DC            	     2M      word     RESTART
                        	  2366:   makeAsmLibraryFunction "remain",               REMAIN
00:A8EE 72656D61696E    	     1M      asciiz   "remain"
00:A8F4 00
00:A8F5 0600            	     2M      word     REMAIN
                        	  2367:   makeAsmLibraryFunction "random",               random
00:A8F7 72616E646F6D    	     1M      asciiz   "random"
00:A8FD 00
00:A8FE 0900            	     2M      word     random
                        	  2368:   makeAsmLibraryFunction "putsp",                PUTSP
00:A900 7075747370      	     1M      asciiz   "putsp"
00:A905 00
00:A906 F394            	     2M      word     PUTSP
                        	  2369:   makeAsmLibraryFunction "print",                print
00:A908 7072696E74      	     1M      asciiz   "print"
00:A90D 00
00:A90E 2682            	     2M      word     print
                        	  2370:   makeAsmLibraryFunction "prchar",               PRCHAR
00:A910 707263686172    	     1M      asciiz   "prchar"
00:A916 00
00:A917 C594            	     2M      word     PRCHAR
                        	  2371:   makeAsmLibraryFunction "prbyte",               PRBYTE
00:A919 707262797465    	     1M      asciiz   "prbyte"
00:A91F 00
00:A920 DD94            	     2M      word     PRBYTE
                        	  2372:   makeAsmLibraryFunction "pinmode",              pinmode
00:A922 70696E6D6F6465  	     1M      asciiz   "pinmode"
00:A929 00
00:A92A C2CA            	     2M      word     pinmode
                        	  2373:   makeAsmLibraryFunction "lcd_wait",             lcd_wait
00:A92C 6C63645F77616974	     1M      asciiz   "lcd_wait"
00:A934 00
00:A935 9CBA            	     2M      word     lcd_wait
                        	  2374:   makeAsmLibraryFunction "lcd_second_line",      lcd_second_line
00:A937 6C63645F7365636F	     1M      asciiz   "lcd_second_line"
00:A93F 6E645F6C696E65
00:A946 00
00:A947 33BB            	     2M      word     lcd_second_line
                        	  2375:   makeAsmLibraryFunction "lcd_print_message",    lcd_print_message
00:A949 6C63645F7072696E	     1M      asciiz   "lcd_print_message"
00:A951 745F6D6573736167
00:A959 65
00:A95A 00
00:A95B 43BB            	     2M      word     lcd_print_message
                        	  2376:   makeAsmLibraryFunction "lcd_print_char",       lcd_print_char
00:A95D 6C63645F7072696E	     1M      asciiz   "lcd_print_char"
00:A965 745F63686172
00:A96B 00
00:A96C F9BA            	     2M      word     lcd_print_char
                        	  2377:   makeAsmLibraryFunction "lcd_instruction",      lcd_instruction
00:A96E 6C63645F696E7374	     1M      asciiz   "lcd_instruction"
00:A976 72756374696F6E
00:A97D 00
00:A97E D7BA            	     2M      word     lcd_instruction
                        	  2378:   makeAsmLibraryFunction "lcd_home",             lcd_home
00:A980 6C63645F686F6D65	     1M      asciiz   "lcd_home"
00:A988 00
00:A989 3BBB            	     2M      word     lcd_home
                        	  2379:   makeAsmLibraryFunction "lcd_get_address",      lcd_get_address
00:A98B 6C63645F6765745F	     1M      asciiz   "lcd_get_address"
00:A993 61646472657373
00:A99A 00
00:A99B B7BA            	     2M      word     lcd_get_address
                        	  2380:   makeAsmLibraryFunction "lcd_clear_display",    lcd_clear_display
00:A99D 6C63645F636C6561	     1M      asciiz   "lcd_clear_display"
00:A9A5 725F646973706C61
00:A9AD 79
00:A9AE 00
00:A9AF 2BBB            	     2M      word     lcd_clear_display
                        	  2381:   makeAsmLibraryFunction "isxdigit",             isxdigit
00:A9B1 6973786469676974	     1M      asciiz   "isxdigit"
00:A9B9 00
00:A9BA 3E81            	     2M      word     isxdigit
                        	  2382:   makeAsmLibraryFunction "isupper",              isupper
00:A9BC 69737570706572  	     1M      asciiz   "isupper"
00:A9C3 00
00:A9C4 0E81            	     2M      word     isupper
                        	  2383:   makeAsmLibraryFunction "isspace",              isspace
00:A9C6 69737370616365  	     1M      asciiz   "isspace"
00:A9CD 00
00:A9CE 4A81            	     2M      word     isspace
                        	  2384:   makeAsmLibraryFunction "islower",              islower
00:A9D0 69736C6F776572  	     1M      asciiz   "islower"
00:A9D7 00
00:A9D8 1A81            	     2M      word     islower
                        	  2385:   makeAsmLibraryFunction "isdigit",              isdigit
00:A9DA 69736469676974  	     1M      asciiz   "isdigit"
00:A9E1 00
00:A9E2 3281            	     2M      word     isdigit
                        	  2386:   makeAsmLibraryFunction "iscntrl",              iscntrl
00:A9E4 6973636E74726C  	     1M      asciiz   "iscntrl"
00:A9EB 00
00:A9EC 5681            	     2M      word     iscntrl
                        	  2387:   makeAsmLibraryFunction "isalpha",              isalpha
00:A9EE 6973616C706861  	     1M      asciiz   "isalpha"
00:A9F5 00
00:A9F6 2681            	     2M      word     isalpha
                        	  2388:   makeAsmLibraryFunction "isalnum",              isalnum
00:A9F8 6973616C6E756D  	     1M      asciiz   "isalnum"
00:A9FF 00
00:AA00 6281            	     2M      word     isalnum
                        	  2389:   makeAsmLibraryFunction "inbuf",                INBUF
00:AA02 696E627566      	     1M      asciiz   "inbuf"
00:AA07 00
00:AA08 0002            	     2M      word     INBUF
                        	  2390:   makeAsmLibraryFunction "i2c_send",             i2c_send
00:AA0A 6932635F73656E64	     1M      asciiz   "i2c_send"
00:AA12 00
00:AA13 FAD2            	     2M      word     i2c_send
                        	  2391:   makeAsmLibraryFunction "i2c_receive",          i2c_receive
00:AA15 6932635F72656365	     1M      asciiz   "i2c_receive"
00:AA1D 697665
00:AA20 00
00:AA21 23D3            	     2M      word     i2c_receive
                        	  2392:   makeAsmLibraryFunction "i2c_init",             i2c_init
00:AA23 6932635F696E6974	     1M      asciiz   "i2c_init"
00:AA2B 00
00:AA2C F4D1            	     2M      word     i2c_init
                        	  2393:   makeAsmLibraryFunction "hardware_init",        hardware_init
00:AA2E 6861726477617265	     1M      asciiz   "hardware_init"
00:AA36 5F696E6974
00:AA3B 00
00:AA3C 6ACB            	     2M      word     hardware_init
                        	  2394:   makeAsmLibraryFunction "getin",                GETIN
00:AA3E 676574696E      	     1M      asciiz   "getin"
00:AA43 00
00:AA44 53CB            	     2M      word     GETIN
                        	  2395:   makeAsmLibraryFunction "gen_random",           gen_random
00:AA46 67656E5F72616E64	     1M      asciiz   "gen_random"
00:AA4E 6F6D
00:AA50 00
00:AA51 1A92            	     2M      word     gen_random
                        	  2396:   makeAsmLibraryFunction "exp_unary_minus",      exp_unary_minus
00:AA53 6578705F756E6172	     1M      asciiz   "exp_unary_minus"
00:AA5B 795F6D696E7573
00:AA62 00
00:AA63 4DAE            	     2M      word     exp_unary_minus
                        	  2397:   makeAsmLibraryFunction "exp_true",             exp_true
00:AA65 6578705F74727565	     1M      asciiz   "exp_true"
00:AA6D 00
00:AA6E 30AD            	     2M      word     exp_true
                        	  2398:   makeAsmLibraryFunction "exp_subtract",         exp_subtract
00:AA70 6578705F73756274	     1M      asciiz   "exp_subtract"
00:AA78 72616374
00:AA7C 00
00:AA7D 1AAD            	     2M      word     exp_subtract
                        	  2399:   makeAsmLibraryFunction "exp_shift_right",      exp_shift_right
00:AA7F 6578705F73686966	     1M      asciiz   "exp_shift_right"
00:AA87 745F7269676874
00:AA8E 00
00:AA8F 13AE            	     2M      word     exp_shift_right
                        	  2400:   makeAsmLibraryFunction "exp_shift_left",       exp_shift_left
00:AA91 6578705F73686966	     1M      asciiz   "exp_shift_left"
00:AA99 745F6C656674
00:AA9F 00
00:AAA0 FAAD            	     2M      word     exp_shift_left
                        	  2401:   makeAsmLibraryFunction "exp_not",              exp_not
00:AAA2 6578705F6E6F74  	     1M      asciiz   "exp_not"
00:AAA9 00
00:AAAA 3FAE            	     2M      word     exp_not
                        	  2402:   makeAsmLibraryFunction "exp_neq",              exp_neq
00:AAAC 6578705F6E6571  	     1M      asciiz   "exp_neq"
00:AAB3 00
00:AAB4 54AD            	     2M      word     exp_neq
                        	  2403:   makeAsmLibraryFunction "exp_negate",           exp_negate
00:AAB6 6578705F6E656761	     1M      asciiz   "exp_negate"
00:AABE 7465
00:AAC0 00
00:AAC1 2CAE            	     2M      word     exp_negate
                        	  2404:   makeAsmLibraryFunction "exp_multiply",         exp_multiply
00:AAC3 6578705F6D756C74	     1M      asciiz   "exp_multiply"
00:AACB 69706C79
00:AACF 00
00:AAD0 D4AE            	     2M      word     exp_multiply
                        	  2405:   makeAsmLibraryFunction "exp_modulo",           exp_modulo
00:AAD2 6578705F6D6F6475	     1M      asciiz   "exp_modulo"
00:AADA 6C6F
00:AADC 00
00:AADD 6DAF            	     2M      word     exp_modulo
                        	  2406:   makeAsmLibraryFunction "exp_low_byte",         exp_low_byte
00:AADF 6578705F6C6F775F	     1M      asciiz   "exp_low_byte"
00:AAE7 62797465
00:AAEB 00
00:AAEC 61AE            	     2M      word     exp_low_byte
                        	  2407:   makeAsmLibraryFunction "exp_logical_or",       exp_logical_or
00:AAEE 6578705F6C6F6769	     1M      asciiz   "exp_logical_or"
00:AAF6 63616C5F6F72
00:AAFC 00
00:AAFD D9AD            	     2M      word     exp_logical_or
                        	  2408:   makeAsmLibraryFunction "exp_logical_and",      exp_logical_and
00:AAFF 6578705F6C6F6769	     1M      asciiz   "exp_logical_and"
00:AB07 63616C5F616E64
00:AB0E 00
00:AB0F E8AD            	     2M      word     exp_logical_and
                        	  2409:   makeAsmLibraryFunction "exp_less_than",        exp_less_than
00:AB11 6578705F6C657373	     1M      asciiz   "exp_less_than"
00:AB19 5F7468616E
00:AB1E 00
00:AB1F 68AD            	     2M      word     exp_less_than
                        	  2410:   makeAsmLibraryFunction "exp_leq",              exp_leq
00:AB21 6578705F6C6571  	     1M      asciiz   "exp_leq"
00:AB28 00
00:AB29 7EAD            	     2M      word     exp_leq
                        	  2411:   makeAsmLibraryFunction "exp_high_byte",        exp_high_byte
00:AB2B 6578705F68696768	     1M      asciiz   "exp_high_byte"
00:AB33 5F62797465
00:AB38 00
00:AB39 66AE            	     2M      word     exp_high_byte
                        	  2412:   makeAsmLibraryFunction "exp_greater_than",     exp_greater_than
00:AB3B 6578705F67726561	     1M      asciiz   "exp_greater_than"
00:AB43 7465725F7468616E
00:AB4B 00
00:AB4C 6FAD            	     2M      word     exp_greater_than
                        	  2413:   makeAsmLibraryFunction "exp_geq",              exp_geq
00:AB4E 6578705F676571  	     1M      asciiz   "exp_geq"
00:AB55 00
00:AB56 8DAD            	     2M      word     exp_geq
                        	  2414:   makeAsmLibraryFunction "exp_false",            exp_false
00:AB58 6578705F66616C73	     1M      asciiz   "exp_false"
00:AB60 65
00:AB61 00
00:AB62 39AD            	     2M      word     exp_false
                        	  2415:   makeAsmLibraryFunction "exp_eql",              exp_eql
00:AB64 6578705F65716C  	     1M      asciiz   "exp_eql"
00:AB6B 00
00:AB6C 40AD            	     2M      word     exp_eql
                        	  2416:   makeAsmLibraryFunction "exp_divide",           exp_divide
00:AB6E 6578705F64697669	     1M      asciiz   "exp_divide"
00:AB76 6465
00:AB78 00
00:AB79 0DAF            	     2M      word     exp_divide
                        	  2417:   makeAsmLibraryFunction "exp_bitwise_xor",      exp_bitwise_xor
00:AB7B 6578705F62697477	     1M      asciiz   "exp_bitwise_xor"
00:AB83 6973655F786F72
00:AB8A 00
00:AB8B BEAD            	     2M      word     exp_bitwise_xor
                        	  2418:   makeAsmLibraryFunction "exp_bitwise_or",       exp_bitwise_or
00:AB8D 6578705F62697477	     1M      asciiz   "exp_bitwise_or"
00:AB95 6973655F6F72
00:AB9B 00
00:AB9C 94AD            	     2M      word     exp_bitwise_or
                        	  2419:   makeAsmLibraryFunction "exp_bitwise_and",      exp_bitwise_and
00:AB9E 6578705F62697477	     1M      asciiz   "exp_bitwise_and"
00:ABA6 6973655F616E64
00:ABAD 00
00:ABAE A9AD            	     2M      word     exp_bitwise_and
                        	  2420:   makeAsmLibraryFunction "exp_add",              exp_add
00:ABB0 6578705F616464  	     1M      asciiz   "exp_add"
00:ABB7 00
00:ABB8 06AD            	     2M      word     exp_add
                        	  2421:   makeAsmLibraryFunction "exp_abs_val",          exp_abs_val
00:ABBA 6578705F6162735F	     1M      asciiz   "exp_abs_val"
00:ABC2 76616C
00:ABC5 00
00:ABC6 6FAE            	     2M      word     exp_abs_val
                        	  2422:   makeAsmLibraryFunction "display_in_decimal",   display_in_decimal
00:ABC8 646973706C61795F	     1M      asciiz   "display_in_decimal"
00:ABD0 696E5F646563696D
00:ABD8 616C
00:ABDA 00
00:ABDB 9293            	     2M      word     display_in_decimal
                        	  2423:   makeAsmLibraryFunction "digitalwrite",         digitalwrite
00:ABDD 6469676974616C77	     1M      asciiz   "digitalwrite"
00:ABE5 72697465
00:ABE9 00
00:ABEA F1CA            	     2M      word     digitalwrite
                        	  2424:   makeAsmLibraryFunction "digitalread",          digitalread
00:ABEC 6469676974616C72	     1M      asciiz   "digitalread"
00:ABF4 656164
00:ABF7 00
00:ABF8 20CB            	     2M      word     digitalread
                        	  2425:   makeAsmLibraryFunction "dest",                 DEST
00:ABFA 64657374        	     1M      asciiz   "dest"
00:ABFE 00
00:ABFF 0300            	     2M      word     DEST
                        	  2426:   makeAsmLibraryFunction "delay",                delay
00:AC01 64656C6179      	     1M      asciiz   "delay"
00:AC06 00
00:AC07 1593            	     2M      word     delay
                        	  2427:   makeAsmLibraryFunction "delay_1ms",            delay_1ms
00:AC09 64656C61795F316D	     1M      asciiz   "delay_1ms"
00:AC11 73
00:AC12 00
00:AC13 0B93            	     2M      word     delay_1ms
                        	  2428:   makeAsmLibraryFunction "crout",                CROUT
00:AC15 63726F7574      	     1M      asciiz   "crout"
00:AC1A 00
00:AC1B 6894            	     2M      word     CROUT
                        	  2429:   makeAsmLibraryFunction "crc_val",              crc_val
00:AC1D 6372635F76616C  	     1M      asciiz   "crc_val"
00:AC24 00
00:AC25 0600            	     2M      word     crc_val
                        	  2430:   makeAsmLibraryFunction "crc_num",              crc_num
00:AC27 6372635F6E756D  	     1M      asciiz   "crc_num"
00:AC2E 00
00:AC2F 0300            	     2M      word     crc_num
                        	  2431:   makeAsmLibraryFunction "crc_byte",             crc_byte
00:AC31 6372635F62797465	     1M      asciiz   "crc_byte"
00:AC39 00
00:AC3A 6592            	     2M      word     crc_byte
                        	  2432:   makeAsmLibraryFunction "crc_addr",             crc_addr
00:AC3C 6372635F61646472	     1M      asciiz   "crc_addr"
00:AC44 00
00:AC45 0000            	     2M      word     crc_addr
                        	  2433:   makeAsmLibraryFunction "crc16",                crc16
00:AC47 6372633136      	     1M      asciiz   "crc16"
00:AC4C 00
00:AC4D 3D92            	     2M      word     crc16
                        	  2434:   .if USE_CP437_FONT
                        	  2435:   makeAsmLibraryFunction "cp437_font",           cp437_font
00:AC4F 63703433375F666F	     1M      asciiz   "cp437_font"
00:AC57 6E74
00:AC59 00
00:AC5A 0AD4            	     2M      word     cp437_font
                        	  2436:   .endif
                        	  2437:   makeAsmLibraryFunction "cout",                 COUT
00:AC5C 636F7574        	     1M      asciiz   "cout"
00:AC60 00
00:AC61 F695            	     2M      word     COUT
                        	  2438:   makeAsmLibraryFunction "comstl",               COMSTL
00:AC63 636F6D73746C    	     1M      asciiz   "comstl"
00:AC69 00
00:AC6A 6D94            	     2M      word     COMSTL
                        	  2439:   makeAsmLibraryFunction "call_y",               call_y
00:AC6C 63616C6C5F79    	     1M      asciiz   "call_y"
00:AC72 00
00:AC73 1200            	     2M      word     call_y
                        	  2440:   makeAsmLibraryFunction "call_x",               call_x
00:AC75 63616C6C5F78    	     1M      asciiz   "call_x"
00:AC7B 00
00:AC7C 1100            	     2M      word     call_x
                        	  2441:   makeAsmLibraryFunction "call_s",               call_s
00:AC7E 63616C6C5F73    	     1M      asciiz   "call_s"
00:AC84 00
00:AC85 1400            	     2M      word     call_s
                        	  2442:   makeAsmLibraryFunction "call_p",               call_p
00:AC87 63616C6C5F70    	     1M      asciiz   "call_p"
00:AC8D 00
00:AC8E 1300            	     2M      word     call_p
                        	  2443:   makeAsmLibraryFunction "call_a",               call_a
00:AC90 63616C6C5F61    	     1M      asciiz   "call_a"
00:AC96 00
00:AC97 1000            	     2M      word     call_a
                        	  2444:   makeAsmLibraryFunction "binary_to_decimal",    binary_to_decimal
00:AC99 62696E6172795F74	     1M      asciiz   "binary_to_decimal"
00:ACA1 6F5F646563696D61
00:ACA9 6C
00:ACAA 00
00:ACAB BB93            	     2M      word     binary_to_decimal
                        	  2445:   makeAsmLibraryFunction "bcd_result",           bcd_result
00:ACAD 6263645F72657375	     1M      asciiz   "bcd_result"
00:ACB5 6C74
00:ACB7 00
00:ACB8 6000            	     2M      word     bcd_result
                        	  2446: 
00:ACBA 00              	  2447:   dfb 0   ; end of table
                        	  2448: 
                        	  2449: 
                        	  2450: add_assembler_library_functions:
00:ACBB A9FB            	  2451:   lda #<assembler_library_functions_table
00:ACBD 8500            	  2452:   sta REG
00:ACBF A9A7            	  2453:   lda #>assembler_library_functions_table
00:ACC1 8501            	  2454:   sta REG+1
                        	  2455: add_assembler_library_functions_loop:
00:ACC3 A000            	  2456:   ldy #0
00:ACC5 B100            	  2457:   lda (REG),Y
00:ACC7 F03C            	  2458:   beq add_assembler_library_functions_done
00:ACC9 A500            	  2459:   lda REG
00:ACCB 8590            	  2460:   sta token_address
00:ACCD A501            	  2461:   lda REG+1
00:ACCF 8591            	  2462:   sta token_address+1
00:ACD1 6492            	  2463:   stz token_length
                        	  2464: ;
                        	  2465: ;  find name length
                        	  2466: ;
                        	  2467: add_assembler_library_functions_name_loop
00:ACD3 C8              	  2468:   iny
00:ACD4 E692            	  2469:   inc token_length
00:ACD6 B100            	  2470:   lda (REG),Y
00:ACD8 D0F9            	  2471:   bne add_assembler_library_functions_name_loop
00:ACDA 5A              	  2472:   phy
00:ACDB 207ABC          	  2473:   jsr CHKDUP
00:ACDE A943            	  2474:   lda #SYMBOL_CONSTANT  ; add the symbol as a constant for now
00:ACE0 20D3BB          	  2475:   jsr ADDSYM
00:ACE3 7A              	  2476:   ply
                        	  2477: 
00:ACE4 C8              	  2478:   iny             ; get next byte
00:ACE5 B100            	  2479:   lda (REG),Y     ; get function address low-byte
00:ACE7 5A              	  2480:   phy
00:ACE8 A004            	  2481:   ldy #SYMDSP
00:ACEA 9140            	  2482:   sta (SYMITM),Y  ; save function address low-byte
00:ACEC 7A              	  2483:   ply
                        	  2484: 
00:ACED C8              	  2485:   iny             ; get next byte
00:ACEE B100            	  2486:   lda (REG),Y     ; get function address high-byte
00:ACF0 5A              	  2487:   phy
00:ACF1 A005            	  2488:   ldy #SYMDSP+1
00:ACF3 9140            	  2489:   sta (SYMITM),Y  ; save function address high-byte
00:ACF5 7A              	  2490:   ply
                        	  2491: 
00:ACF6 C8              	  2492:   iny         ; get past that last byte
00:ACF7 98              	  2493:   tya         ; move REG onto next entry
00:ACF8 18              	  2494:   clc
00:ACF9 6500            	  2495:   adc REG
00:ACFB 8500            	  2496:   sta REG
00:ACFD A900            	  2497:   lda #0
00:ACFF 6501            	  2498:   adc REG+1
00:AD01 8501            	  2499:   sta REG+1
00:AD03 80BE            	  2500:   bra add_assembler_library_functions_loop
                        	  2501: 
                        	  2502: add_assembler_library_functions_done:
00:AD05 60              	  2503:   rts
                        	  2504: 

Source: "gpascal.asm"
                        	   182:   .include "math.inc"

Source: "math.inc"
                        	     1: ;--------------------------------------------------
                        	     2: ; Maths routines. 3-byte operations on VALUE and VALUE2
                        	     3: ;
                        	     4: ;--------------------------------------------------
                        	     5: exp_add:
00:AD06 18              	     6:   clc
00:AD07 A500            	     7:   lda VALUE
00:AD09 6503            	     8:   adc VALUE2
00:AD0B 8500            	     9:   sta VALUE
00:AD0D A501            	    10:   lda VALUE+1
00:AD0F 6504            	    11:   adc VALUE2+1
00:AD11 8501            	    12:   sta VALUE+1
00:AD13 A502            	    13:   lda VALUE+2
00:AD15 6505            	    14:   adc VALUE2+2
00:AD17 8502            	    15:   sta VALUE+2
00:AD19 60              	    16:   rts
                        	    17: 
                        	    18: ;
                        	    19: ;  subtract VALUE2 from VALUE, store in VALUE, also set the sign bit
                        	    20: ;   and put the low order two bytes in X and Y
                        	    21: ;
                        	    22: exp_subtract:
00:AD1A 38              	    23:   sec
00:AD1B A500            	    24:   lda VALUE
00:AD1D E503            	    25:   sbc VALUE2
00:AD1F 8500            	    26:   sta VALUE
00:AD21 A8              	    27:   tay
00:AD22 A501            	    28:   lda VALUE+1
00:AD24 E504            	    29:   sbc VALUE2+1
00:AD26 AA              	    30:   tax
00:AD27 8501            	    31:   sta VALUE+1
00:AD29 A502            	    32:   lda VALUE+2
00:AD2B E505            	    33:   sbc VALUE2+2
00:AD2D 8502            	    34:   sta VALUE+2
00:AD2F 60              	    35:   rts
                        	    36: 
                        	    37: exp_true:
00:AD30 A901            	    38:   lda #1
00:AD32 8500            	    39:   sta VALUE
00:AD34 6401            	    40:   stz VALUE+1
00:AD36 6402            	    41:   stz VALUE+2
00:AD38 60              	    42:   rts
                        	    43: 
                        	    44: exp_false:
00:AD39 6400            	    45:   stz VALUE
00:AD3B 6401            	    46:   stz VALUE+1
00:AD3D 6402            	    47:   stz VALUE+2
00:AD3F 60              	    48:   rts
                        	    49: 
                        	    50: exp_eql:
00:AD40 A500            	    51:   lda VALUE
00:AD42 C503            	    52:   cmp VALUE2
00:AD44 D0F3            	    53:   bne exp_false
00:AD46 A501            	    54:   lda VALUE+1
00:AD48 C504            	    55:   cmp VALUE2+1
00:AD4A D0ED            	    56:   bne exp_false
00:AD4C A502            	    57:   lda VALUE+2
00:AD4E C505            	    58:   cmp VALUE2+2
00:AD50 D0E7            	    59:   bne exp_false
00:AD52 80DC            	    60:   bra exp_true
                        	    61: 
                        	    62: exp_neq:
00:AD54 A500            	    63:   lda VALUE
00:AD56 C503            	    64:   cmp VALUE2
00:AD58 D0D6            	    65:   bne exp_true
00:AD5A A501            	    66:   lda VALUE+1
00:AD5C C504            	    67:   cmp VALUE2+1
00:AD5E D0D0            	    68:   bne exp_true
00:AD60 A502            	    69:   lda VALUE+2
00:AD62 C505            	    70:   cmp VALUE2+2
00:AD64 D0CA            	    71:   bne exp_true
00:AD66 80D1            	    72:   bra exp_false
                        	    73: 
                        	    74: exp_less_than:
00:AD68 201AAD          	    75:   jsr exp_subtract
00:AD6B 30C3            	    76:   bmi exp_true
00:AD6D 10CA            	    77:   bpl exp_false
                        	    78: 
                        	    79: exp_greater_than:
00:AD6F 201AAD          	    80:   jsr exp_subtract
00:AD72 30C5            	    81:   bmi exp_false
00:AD74 D0BA            	    82:   bne exp_true
00:AD76 98              	    83:   tya
00:AD77 D0B7            	    84:   bne exp_true
00:AD79 8A              	    85:   txa
00:AD7A D0B4            	    86:   bne exp_true
00:AD7C 10BB            	    87:   bpl exp_false
                        	    88: 
                        	    89: exp_leq:
00:AD7E 201AAD          	    90:   jsr exp_subtract
00:AD81 30AD            	    91:   bmi exp_true
00:AD83 D0B4            	    92:   bne exp_false
00:AD85 98              	    93:   tya
00:AD86 D0B1            	    94:   bne exp_false
00:AD88 8A              	    95:   txa
00:AD89 D0AE            	    96:   bne exp_false
00:AD8B 10A3            	    97:   bpl exp_true
                        	    98: 
                        	    99: exp_geq:
00:AD8D 201AAD          	   100:   jsr exp_subtract
00:AD90 30A7            	   101:   bmi exp_false
00:AD92 109C            	   102:   bpl exp_true
                        	   103: 
                        	   104: exp_bitwise_or:
00:AD94 A500            	   105:   lda VALUE
00:AD96 0503            	   106:   ora VALUE2
00:AD98 8500            	   107:   sta VALUE
00:AD9A A8              	   108:   tay
00:AD9B A501            	   109:   lda VALUE+1
00:AD9D 0504            	   110:   ora VALUE2+1
00:AD9F 8501            	   111:   sta VALUE+1
00:ADA1 AA              	   112:   tax
00:ADA2 A502            	   113:   lda VALUE+2
00:ADA4 0505            	   114:   ora VALUE2+2
00:ADA6 8502            	   115:   sta VALUE+2
00:ADA8 60              	   116:   rts
                        	   117: 
                        	   118: exp_bitwise_and:
00:ADA9 A500            	   119:   lda VALUE
00:ADAB 2503            	   120:   and VALUE2
00:ADAD 8500            	   121:   sta VALUE
00:ADAF A8              	   122:   tay
00:ADB0 A501            	   123:   lda VALUE+1
00:ADB2 2504            	   124:   and VALUE2+1
00:ADB4 8501            	   125:   sta VALUE+1
00:ADB6 AA              	   126:   tax
00:ADB7 A502            	   127:   lda VALUE+2
00:ADB9 2505            	   128:   and VALUE2+2
00:ADBB 8502            	   129:   sta VALUE+2
00:ADBD 60              	   130:   rts
                        	   131: 
                        	   132: exp_bitwise_xor:
00:ADBE A500            	   133:   lda VALUE
00:ADC0 4503            	   134:   eor VALUE2
00:ADC2 8500            	   135:   sta VALUE
00:ADC4 A8              	   136:   tay
00:ADC5 A501            	   137:   lda VALUE+1
00:ADC7 4504            	   138:   eor VALUE2+1
00:ADC9 8501            	   139:   sta VALUE+1
00:ADCB AA              	   140:   tax
00:ADCC A502            	   141:   lda VALUE+2
00:ADCE 4505            	   142:   eor VALUE2+2
00:ADD0 8502            	   143:   sta VALUE+2
00:ADD2 60              	   144:   rts
                        	   145: 
                        	   146: 
00:ADD3 4C30AD          	   147: exp_trueJ jmp exp_true
00:ADD6 4C39AD          	   148: exp_falseJ jmp exp_false
                        	   149: 
                        	   150: exp_logical_or:
00:ADD9 2094AD          	   151:   jsr exp_bitwise_or
00:ADDC D0F5            	   152:   bne exp_trueJ
00:ADDE E000            	   153:   cpx #0
00:ADE0 D0F1            	   154:   bne exp_trueJ
00:ADE2 C000            	   155:   cpy #0
00:ADE4 D0ED            	   156:   bne exp_trueJ
00:ADE6 80EE            	   157:   bra exp_falseJ
                        	   158: 
                        	   159: exp_logical_and:
00:ADE8 A500            	   160:   lda VALUE
00:ADEA 0501            	   161:   ora VALUE+1
00:ADEC 0502            	   162:   ora VALUE+2
00:ADEE F0E6            	   163:   beq exp_falseJ  ; if VALUE has all bits zero the logical "and" must be false
                        	   164: ;
                        	   165: ;  VALUE is non-zero, how about VALUE2?
                        	   166: ;
00:ADF0 A503            	   167:   lda VALUE2
00:ADF2 0504            	   168:   ora VALUE2+1
00:ADF4 0505            	   169:   ora VALUE2+2
00:ADF6 F0DE            	   170:   beq exp_falseJ  ; if VALUE2 has all bits zero the logical "and" must be false
00:ADF8 80D9            	   171:   bra exp_trueJ   ; both are non-zero, therefore the result is true
                        	   172: 
                        	   173: exp_shift_left:
00:ADFA A504            	   174:   lda VALUE2+1
00:ADFC 0505            	   175:   ora VALUE2+2
00:ADFE D0D6            	   176:   bne exp_falseJ  ; big shifts will return zero
00:AE00 A503            	   177:   lda VALUE2
00:AE02 F00E            	   178:   beq exp_shift_left_done ; shift by zero? we are done then
00:AE04 AA              	   179:   tax
00:AE05 29E0            	   180:   and #$E0        ; maximum of 32 shifts
00:AE07 D0CD            	   181:   bne exp_falseJ
                        	   182: exp_shift_left_loop:
00:AE09 0600            	   183:   asl VALUE
00:AE0B 2601            	   184:   rol VALUE+1
00:AE0D 2602            	   185:   rol VALUE+2
00:AE0F CA              	   186:   dex
00:AE10 D0F7            	   187:   bne exp_shift_left_loop
                        	   188: exp_shift_left_done:
00:AE12 60              	   189:   rts
                        	   190: 
                        	   191: exp_shift_right:
00:AE13 A504            	   192:   lda VALUE2+1
00:AE15 0505            	   193:   ora VALUE2+2
00:AE17 D0BD            	   194:   bne exp_falseJ  ; big shifts will return zero
00:AE19 A503            	   195:   lda VALUE2
00:AE1B F00E            	   196:   beq exp_shift_right_done ; shift by zero? we are done then
00:AE1D AA              	   197:   tax
00:AE1E 29E0            	   198:   and #$E0        ; maximum of 32 shifts
00:AE20 D0B4            	   199:   bne exp_falseJ
                        	   200: exp_shift_right_loop:
00:AE22 4602            	   201:   lsr VALUE+2
00:AE24 6601            	   202:   ror VALUE+1
00:AE26 6600            	   203:   ror VALUE
00:AE28 CA              	   204:   dex
00:AE29 D0F7            	   205:   bne exp_shift_right_loop
                        	   206: exp_shift_right_done:
00:AE2B 60              	   207:   rts
                        	   208: 
                        	   209: exp_negate:
00:AE2C A500            	   210:   lda VALUE
00:AE2E 49FF            	   211:   eor #$FF
00:AE30 8500            	   212:   sta VALUE
00:AE32 A501            	   213:   lda VALUE+1
00:AE34 49FF            	   214:   eor #$FF
00:AE36 8501            	   215:   sta VALUE+1
00:AE38 A502            	   216:   lda VALUE+2
00:AE3A 49FF            	   217:   eor #$FF
00:AE3C 8502            	   218:   sta VALUE+2
00:AE3E 60              	   219:   rts
                        	   220: 
                        	   221: exp_not:
00:AE3F A500            	   222:   lda VALUE
00:AE41 D093            	   223:   bne exp_falseJ
00:AE43 A501            	   224:   lda VALUE+1
00:AE45 D08F            	   225:   bne exp_falseJ
00:AE47 A502            	   226:   lda VALUE+2
00:AE49 D08B            	   227:   bne exp_falseJ
00:AE4B 8086            	   228:   bra exp_trueJ
                        	   229: 
                        	   230: exp_unary_minus:
00:AE4D 38              	   231:   sec
00:AE4E A900            	   232:   lda #0
00:AE50 E500            	   233:   sbc VALUE
00:AE52 8500            	   234:   sta VALUE
00:AE54 A900            	   235:   lda #0
00:AE56 E501            	   236:   sbc VALUE+1
00:AE58 8501            	   237:   sta VALUE+1
00:AE5A A900            	   238:   lda #0
00:AE5C E502            	   239:   sbc VALUE+2
00:AE5E 8502            	   240:   sta VALUE+2
00:AE60 60              	   241:   rts
                        	   242: 
                        	   243: 
                        	   244: exp_low_byte:
00:AE61 6401            	   245:   stz VALUE+1
00:AE63 6402            	   246:   stz VALUE+2
00:AE65 60              	   247:   rts
                        	   248: 
                        	   249: exp_high_byte:
00:AE66 A501            	   250:   lda VALUE+1
00:AE68 8500            	   251:   sta VALUE
00:AE6A 6401            	   252:   stz VALUE+1
00:AE6C 6402            	   253:   stz VALUE+2
00:AE6E 60              	   254:   rts
                        	   255: 
                        	   256: ;
                        	   257: ;  make VALUE positive
                        	   258: ;
                        	   259: exp_abs_val:
00:AE6F A502            	   260:   lda  VALUE+2  ; check high-order byte, see if negative
00:AE71 1013            	   261:   bpl  exp_abs_val_done
                        	   262: exp_negate_val:
00:AE73 38              	   263:   sec
00:AE74 A900            	   264:   lda  #0
00:AE76 E500            	   265:   sbc  VALUE
00:AE78 8500            	   266:   sta  VALUE
00:AE7A A900            	   267:   lda  #0
00:AE7C E501            	   268:   sbc  VALUE+1
00:AE7E 8501            	   269:   sta  VALUE+1
00:AE80 A900            	   270:   lda  #0
00:AE82 E502            	   271:   sbc  VALUE+2
00:AE84 8502            	   272:   sta  VALUE+2
                        	   273: exp_abs_val_done:
00:AE86 60              	   274:   rts
                        	   275: 
                        	   276: ;
                        	   277: ;  make VALUE2 positive
                        	   278: ;
                        	   279: exp_abs_val2:
00:AE87 A505            	   280:   lda  VALUE2+2  ; check high-order byte, see if negative
00:AE89 1013            	   281:   bpl  exp_abs_val2_done
                        	   282: exp_negate_val2:
00:AE8B 38              	   283:   sec
00:AE8C A900            	   284:   lda  #0
00:AE8E E503            	   285:   sbc  VALUE2
00:AE90 8503            	   286:   sta  VALUE2
00:AE92 A900            	   287:   lda  #0
00:AE94 E504            	   288:   sbc  VALUE2+1
00:AE96 8504            	   289:   sta  VALUE2+1
00:AE98 A900            	   290:   lda  #0
00:AE9A E505            	   291:   sbc  VALUE2+2
00:AE9C 8505            	   292:   sta  VALUE2+2
                        	   293: exp_abs_val2_done:
00:AE9E 60              	   294:   rts
                        	   295: 
                        	   296: 
                        	   297: ZERRES:
00:AE9F A900            	   298:   lda  #0
00:AEA1 8552            	   299:   sta  RES
00:AEA3 8553            	   300:   sta  RES+1
00:AEA5 8554            	   301:   sta  RES+2
00:AEA7 60              	   302:   rts
                        	   303: 
                        	   304: exp_find_sign:
00:AEA8 209FAE          	   305:    jsr  ZERRES     ; zero result
00:AEAB A502            	   306:    lda  VALUE+2
00:AEAD 2980            	   307:    and  #$80
00:AEAF 855B            	   308:    sta  RMNDR
00:AEB1 A505            	   309:    lda  VALUE2+2
00:AEB3 2980            	   310:    and  #$80
00:AEB5 455B            	   311:    eor  RMNDR
00:AEB7 855B            	   312:    sta  RMNDR     ; RMNDR is 0x80 if the result needs to be negative
00:AEB9 206FAE          	   313:    jsr  exp_abs_val
00:AEBC 2087AE          	   314:    jsr  exp_abs_val2
00:AEBF 60              	   315:    rts
                        	   316: ;
                        	   317: 
                        	   318: exp_fix_sign:
00:AEC0 A55B            	   319:   lda  RMNDR
00:AEC2 100F            	   320:   bpl  exp_fix_sign_done      ; nothing needs to be changed
00:AEC4 38              	   321:   sec                         ; subtract result from zero
00:AEC5 A900            	   322:   lda  #0
00:AEC7 E552            	   323:   sbc  RES
00:AEC9 AA              	   324:   tax
00:AECA A900            	   325:   lda  #0
00:AECC E553            	   326:   sbc  RES+1
00:AECE A8              	   327:   tay
00:AECF A900            	   328:   lda  #0
00:AED1 E554            	   329:   sbc  RES+2
                        	   330: exp_fix_sign_done:
00:AED3 60              	   331:   rts
                        	   332: 
                        	   333: 
                        	   334: ;
                        	   335: ;  multiply VALUE1 by VALUE2 and store in VALUE
                        	   336: ;
                        	   337: ;  see: https://llx.com/Neil/a2/mult.html for a discussion
                        	   338: ;
                        	   339: 
                        	   340: exp_multiply:
00:AED4 20A8AE          	   341:   jsr exp_find_sign
00:AED7 A218            	   342:   ldx  #24       ; for all 24 bits
                        	   343: exp_multiply_loop:
00:AED9 0652            	   344:   asl  RES
00:AEDB 2653            	   345:   rol  RES+1
00:AEDD 2654            	   346:   rol  RES+2                    ; shift RES left one bit
00:AEDF 0600            	   347:   asl  VALUE
00:AEE1 2601            	   348:   rol  VALUE+1
00:AEE3 2602            	   349:   rol  VALUE+2                  ; shift one argument left one bit and get the low-order bit into carry
00:AEE5 9013            	   350:   bcc  exp_multiply_no_add      ; if no low-order bit, don't add anything
00:AEE7 18              	   351:   clc                           ; add the other argument to the result
00:AEE8 A503            	   352:   lda  VALUE2
00:AEEA 6552            	   353:   adc  RES
00:AEEC 8552            	   354:   sta  RES
00:AEEE A504            	   355:   lda  VALUE2+1
00:AEF0 6553            	   356:   adc  RES+1
00:AEF2 8553            	   357:   sta  RES+1
00:AEF4 A505            	   358:   lda  VALUE2+2
00:AEF6 6554            	   359:   adc  RES+2
00:AEF8 8554            	   360:   sta  RES+2
                        	   361: exp_multiply_no_add:
00:AEFA CA              	   362:   dex                      ; count bits
00:AEFB D0DC            	   363:   bne  exp_multiply_loop   ; go back if more to go
00:AEFD 20C0AE          	   364:   jsr  exp_fix_sign
00:AF00 A552            	   365:   lda  RES
00:AF02 8500            	   366:   sta  VALUE
00:AF04 A553            	   367:   lda  RES+1
00:AF06 8501            	   368:   sta  VALUE+1
00:AF08 A554            	   369:   lda  RES+2
00:AF0A 8502            	   370:   sta  VALUE+2
00:AF0C 60              	   371:   rts
                        	   372: 
                        	   373: ;
                        	   374: ;  divide VALUE by VALUE2, store result in VALUE
                        	   375: ;
                        	   376: exp_divide:
00:AF0D 20A8AE          	   377:   jsr exp_find_sign
                        	   378: 
00:AF10 A503            	   379:   lda  VALUE2
00:AF12 0504            	   380:   ora  VALUE2+1
00:AF14 0505            	   381:   ora  VALUE2+2
00:AF16 D005            	   382:   bne  exp_divide_not_zero  ; check not dividing by zero
00:AF18 A22F            	   383:   ldx  #47                  ; ERROR: divide by zero
00:AF1A 4CEBA0          	   384:   jmp  ass_error
                        	   385:   ;
                        	   386: exp_divide_not_zero:
00:AF1D 209FAE          	   387:   jsr  ZERRES     ; zero result (RES) - leaves zero in A register
00:AF20 8506            	   388:   sta  REMAIN
00:AF22 8507            	   389:   sta  REMAIN+1
00:AF24 8508            	   390:   sta  REMAIN+2
00:AF26 A918            	   391:   lda  #24       ; for all 24 bits of the operands ...
00:AF28 858D            	   392:   sta  maths_work
                        	   393: exp_divide_loop:
00:AF2A 0600            	   394:   asl  VALUE
00:AF2C 2601            	   395:   rol  VALUE+1
00:AF2E 2602            	   396:   rol  VALUE+2    ; shift the dividend left one bit
00:AF30 2606            	   397:   rol  REMAIN    ; the low-order bit of the dividend is shifted into the remainder
00:AF32 2607            	   398:   rol  REMAIN+1
00:AF34 2608            	   399:   rol  REMAIN+2
00:AF36 38              	   400:   sec
00:AF37 A506            	   401:   lda  REMAIN    ; do a trial subtraction of: remainder - divisor
00:AF39 E503            	   402:   sbc  VALUE2
00:AF3B AA              	   403:   tax
00:AF3C A507            	   404:   lda  REMAIN+1
00:AF3E E504            	   405:   sbc  VALUE2+1
00:AF40 A8              	   406:   tay
00:AF41 A508            	   407:   lda  REMAIN+2
00:AF43 E505            	   408:   sbc  VALUE2+2
00:AF45 300B            	   409:   bmi  exp_divide_subtraction_negative      ; if the subtraction fails (is negative) then discard the result
00:AF47 8508            	   410:   sta  REMAIN+2  ; if it succeeds then the result of the subtraction is our new remainder
00:AF49 98              	   411:   tya
00:AF4A 8507            	   412:   sta  REMAIN+1
00:AF4C 8A              	   413:   txa
00:AF4D 8506            	   414:   sta  REMAIN
00:AF4F 38              	   415:   sec            ; shift a one-bit into the quotient
00:AF50 B001            	   416:   bcs  exp_divide_subtraction_positive
                        	   417: exp_divide_subtraction_negative:
00:AF52 18              	   418:   clc            ; here if subtraction failed, quotient (RES) gets a 0-bit shifted in
                        	   419: exp_divide_subtraction_positive:
00:AF53 2652            	   420:   rol  RES       ; the carry bit (from above) is shifted into the quotient
00:AF55 2653            	   421:   rol  RES+1
00:AF57 2654            	   422:   rol  RES+2
00:AF59 C68D            	   423:   dec  maths_work      ; one less bit to go
00:AF5B D0CD            	   424:   bne  exp_divide_loop      ; repeat until 24 bits done
00:AF5D 20C0AE          	   425:   jsr  exp_fix_sign
00:AF60 A552            	   426:   lda  RES
00:AF62 8500            	   427:   sta  VALUE
00:AF64 A553            	   428:   lda  RES+1
00:AF66 8501            	   429:   sta  VALUE+1
00:AF68 A554            	   430:   lda  RES+2
00:AF6A 8502            	   431:   sta  VALUE+2
00:AF6C 60              	   432:   rts
                        	   433: 
                        	   434: exp_modulo:
00:AF6D 200DAF          	   435:   jsr exp_divide
00:AF70 A506            	   436:   lda REMAIN
00:AF72 8500            	   437:   sta VALUE
00:AF74 A507            	   438:   lda REMAIN+1
00:AF76 8501            	   439:   sta VALUE+1
00:AF78 A508            	   440:   lda REMAIN+2
00:AF7A 8502            	   441:   sta VALUE+2
00:AF7C 60              	   442:   rts
                        	   443: 

Source: "gpascal.asm"
                        	   183:   .include "interpreter.inc"

Source: "interpreter.inc"
                        	     1: ;--------------------------------------------------
                        	     2: ; Runtime P-code interpreter
                        	     3: ;
                        	     4: ;--------------------------------------------------
                        	     5: 
                        	     6: 
                        	     7: ;--------------------------------
                        	     8: ; P-codes - these are generated in the compilation phase and looked up
                        	     9: ;           in execution_address_table at runtime
                        	    10: ;
                        	    11: ; Note: some P-codes must appear in sequence, eg. PCODE_STO and PCODE_STOC
                        	    12: ;       That is because one refers to integers (STO) and one refers to characters (STOC)
                        	    13: ;       The code in various places is virtually identical except it adds 1 to the P-code
                        	    14: ;       for characters. These generally are the Load/Store operations.
                        	    15: ;--------------------------------
                        	    16: 
                        	    17: ; Not implemented yet: $05, $13, $15, $39
                        	    18: 
                        	    19: ;                 Code            Description                         Arguments
                        	    20: ;                 ----            -----------------------------       -----------------------
                        	    21: PCODE_LIT     =   $00 ; Dec:  0 - Load constant                     - 3-byte literal (number)
                        	    22: PCODE_STACK   =   $01 ; Dec:  1 - Alter runtime stack to address    - 2-byte stack address
                        	    23: PCODE_NEG     =   $02 ; Dec:  2 - Unary minus 0 - (sp)              - none
                        	    24: PCODE_LIB_CALL =  $03 ; Dec:  3 - Call library function/procedure   - absolute address
                        	    25: PCODE_ADD     =   $04 ; Dec:  4 - Add (sp) to (sp - 1)              - none
                        	    26: PCODE_SUB     =   $06 ; Dec:  6 - Subtract (sp) from (sp - 1)       - none
                        	    27: PCODE_MUL     =   $08 ; Dec:  8 - Multiply (sp) * (sp - 1)          - none
                        	    28: PCODE_DIV     =   $0A ; Dec: 10 - Divide (sp - 1) / (sp)            - none
                        	    29: PCODE_MOD     =   $0B ; Dec: 11 - Modulus (sp - 1) MOD (sp)         - none
                        	    30: PCODE_ADRNN   =   $0C ; Dec: 12 - Address of integer                - level, displ
                        	    31: PCODE_ADRNC   =   $0D ; Dec: 13 - Address of character              - level, displ
                        	    32: PCODE_ADRAN   =   $0E ; Dec: 14 - Address of integer array          - level, displ
                        	    33: PCODE_ADRAC   =   $0F ; Dec: 15 - Address of character array        - level, displ
                        	    34: PCODE_EQL     =   $10 ; Dec: 16 - Test (sp - 1) == (sp)             - none
                        	    35: PCODE_FINISHD =   $11 ; Dec: 17 - Stop run (end program)            - none
                        	    36: PCODE_NEQ     =   $12 ; Dec: 18 - Test (sp - 1) != (sp)             - none
                        	    37: PCODE_LSS     =   $14 ; Dec: 20 - Test (sp - 1) < (sp)              - none
                        	    38: PCODE_GEQ     =   $16 ; Dec: 22 - Test (sp - 1) >= (sp)             - none
                        	    39: PCODE_GTR     =   $18 ; Dec: 24 - Test (sp - 1) > (sp)              - none
                        	    40: PCODE_LEQ     =   $19 ; Dec: 25 - Test (sp - 1) <= (sp)             - none
                        	    41: PCODE_ORR     =   $1A ; Dec: 26 - OR  (sp - 1) | (sp)               - none
                        	    42: PCODE_AND     =   $1B ; Dec: 27 - AND (sp - 1) & (sp)               - none
                        	    43: PCODE_INP     =   $1C ; Dec: 28 - Input number                      - none
                        	    44: PCODE_INPC    =   $1D ; Dec: 29 - Input character                   - none
                        	    45: PCODE_OUT     =   $1E ; Dec: 30 - Output number                     - none
                        	    46: PCODE_OUTC    =   $1F ; Dec: 31 - Output character                  - none
                        	    47: PCODE_EOR     =   $20 ; Dec: 32 - Not (sp) (logical negate)         - none
                        	    48: PCODE_OUH     =   $21 ; Dec: 33 - Output hex number                 - none
                        	    49: PCODE_SHL     =   $22 ; Dec: 34 - Shift left (sp) bits              - none
                        	    50: PCODE_OUS     =   $23 ; Dec: 35 - Output string                     - length, string
                        	    51: PCODE_SHR     =   $24 ; Dec: 36 - Shift right (sp) bits             - none
                        	    52: PCODE_INS     =   $25 ; Dec: 37 - Input string into array           - max, level, displ
                        	    53: PCODE_INC     =   $26 ; Dec: 38 - Increment (sp) by 1               - none
                        	    54: PCODE_CLL     =   $27 ; Dec: 39 - Relative procedure/function call  - level, relative address
                        	    55: PCODE_DEC     =   $28 ; Dec: 40 - Decrement (sp) by 1               - none
                        	    56: PCODE_RTN     =   $29 ; Dec: 41 - Procedure/function return         - none
                        	    57: PCODE_MOV     =   $2A ; Dec: 42 - Copy (sp) to (sp + 1)             - none
                        	    58: PCODE_CLA     =   $2B ; Dec: 43 - Call absolute address             - none
                        	    59: PCODE_LOD     =   $2C ; Dec: 44 - Load integer onto stack           - level, displ
                        	    60: PCODE_LODC    =   $2D ; Dec: 45 - Load character onto stack         - level, displ
                        	    61: PCODE_LDA     =   $2E ; Dec: 46 - Load absolute address integer     - none
                        	    62: PCODE_LDAC    =   $2F ; Dec: 47 - Load absolute address character   - none
                        	    63: PCODE_LDI     =   $30 ; Dec: 48 - Load integer indexed              - level, displ
                        	    64: PCODE_LDIC    =   $31 ; Dec: 49 - Load character indexed            - level, displ
                        	    65: PCODE_STO     =   $32 ; Dec: 50 - Store integer                     - level, displ
                        	    66: PCODE_STOC    =   $33 ; Dec: 51 - Store character                   - level, displ
                        	    67: PCODE_STA     =   $34 ; Dec: 52 - Store integer absolute address    - none
                        	    68: PCODE_STAC    =   $35 ; Dec: 53 - Store character absolute address  - none
                        	    69: PCODE_STI     =   $36 ; Dec: 54 - Store integer indexed             - level, displ
                        	    70: PCODE_STIC    =   $37 ; Dec: 55 - Store character indexed           - level, displ
                        	    71: PCODE_ABSCLL  =   $38 ; Dec: 56 - Absolute procedure/function call  - level, absolute address
                        	    72: PCODE_XOR     =   $3A ; Dec: 58 - XOR (sp - 1) ^ (sp)               - none
                        	    73: PCODE_INT     =   $3B ; Dec: 59 - Increment stack pointer           - increment
                        	    74: PCODE_JMP     =   $3C ; Dec: 60 - Jump unconditionally              - relative address
                        	    75: PCODE_JMZ     =   $3D ; Dec: 61 - Jump if (sp) zero                 - relative address
                        	    76: PCODE_JM1     =   $3E ; Dec: 62 - Jump if (sp) not zero             - relative address
                        	    77: PCODE_OUTCR   =   $40 ; Dec: 64 - Output a carriage-return          - none
                        	    78: PCODE_LCD_WRITE_NUM = $42 ; Dec: 66 - Write number to LCD           - none
                        	    79: PCODE_LCD_WRITE_STR = $43 ; Dec: 67 - Write string to LCD           - none
                        	    80: PCODE_LCD_WRITE_HEX = $44 ; Dec: 68 - Write hex number to LCD       - none
                        	    81: PCODE_LCD_WRITE_CHR = $45 ; Dec: 69 - Write character to LCD        - none
                        	    82: 
                        	    83: PCODE_LAST    =   PCODE_LCD_WRITE_CHR  ; PUT THIS LAST! (error check)                  -
                        	    84: 
                        	    85: ; 0x80 to 0xFF - Load low literal (onto stack), where literal is P-code with 8-bit clear (ie. P-code & 0x7F)
                        	    86: 
                        	    87: 
                        	    88: ;
                        	    89: ;  P-code execution routine lookup.
                        	    90: ;  For symbolic version see list above
                        	    91: ;
                        	    92: ;  Y is zero when starting to execute these routines
                        	    93: ;
                        	    94: execution_address_table  =  *
00:AF7D AEB2            	    95:   word  EX_LIT             ; $00 = LIT      Load constant
00:AF7F A2B6            	    96:   word  EX_NEW_STACK       ; $01 =          Change stack to addr
00:AF81 C0B2            	    97:   word  EX_NEG             ; $02 = NEG      Unary minus: 0 - (sp)
00:AF83 2EB8            	    98:   word  EX_LIB_CALL        ; $03 = LIB_CALL Library function call
00:AF85 C9B2            	    99:   word  EX_ADD             ; $04 = ADD      Add (sp) to (sp - 1)
00:AF87 DCB1            	   100:   word  EX_INVINS          ; $05 =          NOT IMPLEMENTED
00:AF89 D2B2            	   101:   word  EX_SUB             ; $06 = SUB      Subtract (sp) from (sp - 1)
00:AF8B DCB1            	   102:   word  EX_INVINS          ; $07 =          NOT IMPLEMENTED
00:AF8D DEB2            	   103:   word  EX_MUL             ; $08 = MUL      Multiply (sp) * (sp - 1)
00:AF8F DCB1            	   104:   word  EX_INVINS          ; $09 =          NOT IMPLEMENTED
00:AF91 19B3            	   105:   word  EX_DIV             ; $0A = DIV      Divide (sp - 1) / (sp)
00:AF93 EEB2            	   106:   word  EX_MOD             ; $0B = MOD      Modulus (sp - 1) MOD (sp)
00:AF95 8DB7            	   107:   word  EX_ADRNN           ; $0C = ADRNN    Address of integer
00:AF97 7DB7            	   108:   word  EX_ADRNC           ; $0D = ADRNC    Address of character
00:AF99 9BB7            	   109:   word  EX_ADRAN           ; $0E = ADRAN    Address of integer array
00:AF9B A1B7            	   110:   word  EX_ADRAC           ; $0F = ADRAC    Address of character array
00:AF9D 36B3            	   111:   word  EX_EQL             ; $10 = EQL      Test (sp - 1) == (sp)
00:AF9F 29B1            	   112:   word  EX_FINISHD         ; $11 = FINISHD  Stop run (end program)
00:AFA1 50B3            	   113:   word  EX_NEQ             ; $12 = NEQ      Test (sp - 1) != (sp)
00:AFA3 DCB1            	   114:   word  EX_INVINS          ; $13 =          NOT IMPLEMENTED
00:AFA5 59B3            	   115:   word  EX_LSS             ; $14 = LSS      Test (sp - 1) < (sp)
00:AFA7 DCB1            	   116:   word  EX_INVINS          ; $15 =          NOT IMPLEMENTED
00:AFA9 71B3            	   117:   word  EX_GEQ             ; $16 = GEQ      Test (sp - 1) >= (sp)
00:AFAB DCB1            	   118:   word  EX_INVINS          ; $17 =          NOT IMPLEMENTED
00:AFAD 65B3            	   119:   word  EX_GTR             ; $18 = GTR      Test (sp - 1) > (sp)
00:AFAF 7DB3            	   120:   word  EX_LEQ             ; $19 = LEQ      Test (sp - 1) <= (sp)
00:AFB1 92B3            	   121:   word  EX_ORR             ; $1A = ORR      OR  (sp - 1) | (sp)
00:AFB3 9BB3            	   122:   word  EX_AND             ; $1B = AND      AND (sp - 1) & (sp)
00:AFB5 1BB5            	   123:   word  EX_INP             ; $1C = INP      Input number
00:AFB7 E3B6            	   124:   word  EX_INPC            ; $1D = INPC     Input character
00:AFB9 5BB5            	   125:   word  EX_OUT             ; $1E = OUT      Output number
00:AFBB FDB6            	   126:   word  EX_OUTC            ; $1F = OUTC     Output character
00:AFBD A4B3            	   127:   word  EX_EOR             ; $20 = EOR      Not (sp) (logical negate)
00:AFBF 6FB5            	   128:   word  EX_OUH             ; $21 = OUH      Output hex number
00:AFC1 ADB3            	   129:   word  EX_SHL             ; $22 = SHL      Shift left (sp) bits
00:AFC3 8FB5            	   130:   word  EX_OUS             ; $23 = OUS      Output string
00:AFC5 B9B3            	   131:   word  EX_SHR             ; $24 = SHR      Shift right (sp) bits
00:AFC7 1FB7            	   132:   word  EX_INS             ; $25 = INS      Input string into array
00:AFC9 C5B3            	   133:   word  EX_INC             ; $26 = INC      Increment (sp) by 1
00:AFCB C9B5            	   134:   word  EX_CLL             ; $27 = CLL      Relative procedure/function call
00:AFCD DDB3            	   135:   word  EX_DEC             ; $28 = DEC      Decrement (sp) by 1
00:AFCF E2B4            	   136:   word  EX_RTN             ; $29 = RTN      Procedure/function return
00:AFD1 F5B3            	   137:   word  EX_MOV             ; $2A = MOV      Copy (sp) to (sp + 1)
00:AFD3 58B6            	   138:   word  EX_CLA             ; $2B = CLA      Call absolute address
00:AFD5 18B4            	   139:   word  EX_LOD             ; $2C = LOD      Load integer onto stack
00:AFD7 06B4            	   140:   word  EX_LODC            ; $2D = LODC     Load character onto stack
00:AFD9 39B4            	   141:   word  EX_LDA             ; $2E = LDA      Load absolute address integer
00:AFDB 2EB4            	   142:   word  EX_LDAC            ; $2F = LDAC     Load absolute address character
00:AFDD 74B4            	   143:   word  EX_LDI             ; $30 = LDI      Load integer indexed
00:AFDF 6EB4            	   144:   word  EX_LDIC            ; $31 = LDIC     Load character indexed
00:AFE1 87B4            	   145:   word  EX_STO             ; $32 = STO      Store integer
00:AFE3 7AB4            	   146:   word  EX_STOC            ; $33 = STOC     Store character
00:AFE5 9AB4            	   147:   word  EX_STA             ; $34 = STA      Store integer absolute address
00:AFE7 B0B4            	   148:   word  EX_STAC            ; $35 = STAC     Store character absolute address
00:AFE9 C7B4            	   149:   word  EX_STI             ; $36 = STI      Store integer indexed
00:AFEB B9B4            	   150:   word  EX_STIC            ; $37 = STIC     Store character indexed
00:AFED C2B5            	   151:   word  EX_ABSCLL          ; $38 = ABSCLL   Absolute procedure/function call
00:AFEF DCB1            	   152:   word  EX_INVINS          ; $39 =          NOT IMPLEMENTED
00:AFF1 89B3            	   153:   word  EX_XOR             ; $3A = XOR      XOR (sp - 1) ^ (sp)
00:AFF3 78B6            	   154:   word  EX_INT             ; $3B = INT      Increment stack pointer
00:AFF5 B4B6            	   155:   word  EX_JMP             ; $3C = JMP      Jump unconditionally
00:AFF7 C7B6            	   156:   word  EX_JMZ             ; $3D = JMZ      Jump if (sp) zero
00:AFF9 D8B6            	   157:   word  EX_JM1             ; $3E = JM1      Jump if (sp) not zero
00:AFFB DCB1            	   158:   word  EX_INVINS          ; $3F =          NOT IMPLEMENTED
00:AFFD 89B1            	   159:   word  EX_OUTCR           ; $40 = OUTCR    Output a carriage-return
00:AFFF DCB1            	   160:   word  EX_INVINS          ; $41 =          NOT IMPLEMENTED
00:B001 60B5            	   161:   word  EX_LCD_WRITE_NUM   ; $42 = LCD_WRITE_NUM  Write number to LCD
00:B003 94B5            	   162:   word  EX_LCD_WRITE_STR   ; $43 = LCD_WRITE_STR  Write string to LCD
00:B005 74B5            	   163:   word  EX_LCD_WRITE_HEX   ; $44 = LCD_WRITE_HEX  Write hex to LCD
00:B007 02B7            	   164:   word  EX_LCD_WRITE_CHR   ; $45 = LCD_WRITE_CHR  Write character to LCD
                        	   165: 
                        	   166: ;--------------------------------------------------------------------------
                        	   167: ;
                        	   168: ;  STACK FRAMES
                        	   169: ;
                        	   170: ;  The compiler can't know where variables are actually going to be stored because
                        	   171: ;  they will be relative to the (interpreter) stack (not the processor stack) which
                        	   172: ;  is an unknown address because procedures/functions can be called directly or from
                        	   173: ;  other procedures/functions.
                        	   174: ;
                        	   175: ;  Hence variables are referenced to BASE which is the base of the current stack frame,
                        	   176: ;  thus a variable will be a certain offset from that. However in the case of nested
                        	   177: ;  calls we need to go back to a previous stack frame. That is what the 6-byte "stack
                        	   178: ;  frame linkage data" is about.
                        	   179: ;
                        	   180: ;  Variables are referred to by a "level difference" and a displacement. For the current
                        	   181: ;  procedure the level difference will be zero, and thus the variable will be BASE +
                        	   182: ;  the offset for this particular variable.
                        	   183: ;
                        	   184: ;  For variables in earlier procedures/functions (ones which called this one) there will
                        	   185: ;  be a level difference, being the depth (lexically) between the called function and the
                        	   186: ;  one with the variable. For example, if foo calls bar, and bar recurses five times, foo
                        	   187: ;  and bar are still only one level apart, from the point of view of accessing foo's
                        	   188: ;  variables.
                        	   189: ;
                        	   190: ;  Thus, to find an address we need to "walk" back through the STATIC stack frame links
                        	   191: ;  (bytes 5 and 6 of the stack frame data) to find the appropriate stack frame, and then
                        	   192: ;  take the offset from that.
                        	   193: ;
                        	   194: ;  However for recursive calls, once a recursed call ends, we need to get back the stack
                        	   195: ;  frame of the caller, which will be different from the static frame. So, to restore the
                        	   196: ;  stack frame after a procedure/function ends, we must take the DYNAMIC stack frame address
                        	   197: ;  (bytes 3 and 4 of the stack frame data) to get back the previous stack frame. In fact,
                        	   198: ;  all procedures/functions do this, it's just that the static and dynamic stack frames will
                        	   199: ;  be the same if the procedure/function does not recurse.
                        	   200: ;
                        	   201: ;  Finally, the return address (in the P-codes) for the procedure/function call is also
                        	   202: ;  stored in the stack frame data (bytes 1 and 2 of the stack frame data) so that, after
                        	   203: ;  doing a return, we can restore the P-code address to the PCODE variable after the call.
                        	   204: ;
                        	   205: ;  When a procedure/function is called these 6 bytes are pushed onto the stack. Then, for
                        	   206: ;  some reason, the code moves the stack pointer back 6 (adds to it). Then as part of the
                        	   207: ;  procedure/function initialisation the stack pointer has 6 or 9 added to it, to allow
                        	   208: ;  for not overwriting this stack frame data, and in the case of functions, the extra 3
                        	   209: ;  bytes are for the returned value.
                        	   210: ;
                        	   211: ;  Note that the stack grows downwards, as it starts at "high memory" (whatever that is
                        	   212: ;  defined as, and grows downwards, taking the gap between the end of the P-codes and the
                        	   213: ;  end of memory.
                        	   214: ;
                        	   215: ;  Then the function will add additional spaces to the stack (ie. by subtracting from the
                        	   216: ;  stack pointer) to make room for variables declared in that procedure/function. Now we
                        	   217: ;  are ready to push data onto the stack as part of normal expression evalution. It follows
                        	   218: ;  from this that variables initially have undefined values, as they will contain whatever
                        	   219: ;  happened to be in the stack when this space was allocated.
                        	   220: ;
                        	   221: ;  The function GETADR resolves these addresses by starting with BASE, the stack frame base
                        	   222: ;  for the current procedure/function, and then using the static stack frame link to load a
                        	   223: ;  (temporary) new base, and repeating that until the level difference is zero. Then it adds
                        	   224: ;  the offset of the wanted variable to the stack base to derive the actual variable address.
                        	   225: ;
                        	   226: ;--------------------------------------------------------------------------
                        	   227: 
                        	   228: 
                        	   229: ;
00:B009 20537461636B3A20	   230: DM1               asciiz  ' Stack: '
00:B011 00
00:B012 20426173653A2020	   231: DM2               asciiz  ' Base:  '
00:B01A 00
00:B01B 52756E6E696E670A	   232: running_message   asciiz  'Running\n'
00:B023 00
                        	   233: 
                        	   234: ;
                        	   235: DEBUG    =  *
00:B024 208394          	   236: DB11     jsr  DISPAD    ; display P-code address
00:B027 A523            	   237:          lda  PCODE
00:B029 8537            	   238:          sta  WORK
00:B02B A524            	   239:          lda  PCODE+1
00:B02D 8538            	   240:          sta  WORK+1
00:B02F A204            	   241:          ldx  #4
00:B031 20EDB0          	   242:          jsr  display_x_characters      ; display 4 bytes from WORK (ie. the P-codes)
00:B034 206894          	   243:          jsr  CROUT
00:B037 A649            	   244:          ldx  DBGFLG
00:B039 3051            	   245:          bmi  DEBUG_DONE        ; trace only
00:B03B A909            	   246:          lda  #<DM1             ; ' Stack: '
00:B03D A2B0            	   247:          ldx  #>DM1
00:B03F 202682          	   248:          jsr  print
00:B042 A532            	   249:          lda  T+1
00:B044 20DD94          	   250:          jsr  PRBYTE        ; display the stack pointer address
00:B047 A531            	   251:          lda  T
00:B049 207D94          	   252:          jsr  DISHX         ; display hex and a space after
00:B04C A93D            	   253:          lda  #'='
00:B04E 20F695          	   254:          jsr  COUT
00:B051 A531            	   255:          lda  T
00:B053 8537            	   256:          sta  WORK
00:B055 A532            	   257:          lda  T+1
00:B057 8538            	   258:          sta  WORK+1
00:B059 A209            	   259:          ldx  #9         ; show 9 bytes on stack, namely 3 variables
00:B05B 20EDB0          	   260:          jsr  display_x_characters
00:B05E 206894          	   261:          jsr  CROUT
00:B061 A912            	   262:          lda  #<DM2       ; ' Base:  '
00:B063 A2B0            	   263:          ldx  #>DM2
00:B065 202682          	   264:          jsr  print
00:B068 A53C            	   265:          lda  BASE+1
00:B06A 20DD94          	   266:          jsr  PRBYTE      ; display the base pointer address
00:B06D A53B            	   267:          lda  BASE
00:B06F 207D94          	   268:          jsr  DISHX
00:B072 A93D            	   269:          lda  #'='
00:B074 20F695          	   270:          jsr  COUT
00:B077 A53B            	   271:          lda  BASE
00:B079 38              	   272:          sec
00:B07A E906            	   273:          sbc  #6    ; the linkage data is 6 bytes below the base
00:B07C 8537            	   274:          sta  WORK
00:B07E A53C            	   275:          lda  BASE+1
00:B080 E900            	   276:          sbc  #0
00:B082 8538            	   277:          sta  WORK+1
00:B084 A206            	   278:          ldx  #6    ; show 6 bytes of base linkage data (return, dynamic link, static link)
00:B086 20EDB0          	   279:          jsr  display_x_characters
00:B089 4C6894          	   280:          jmp  CROUT
                        	   281: 
00:B08C 60              	   282: DEBUG_DONE rts
                        	   283: 
                        	   284: 
                        	   285: ;***********************************************
                        	   286: ; Interpreter initialization
                        	   287: ;***********************************************
                        	   288: 
                        	   289: INTERP   =  *
00:B08D 08              	   290:   php
00:B08E 68              	   291:   pla
00:B08F 8513            	   292:   sta  call_p   ; make sure call_p has some reasonable value in it
                        	   293: ;
                        	   294: ;  Move the start of where the P-codes start into PCODE (our first P-code)
                        	   295: ;
00:B091 A525            	   296:   lda  ACT_PCDA
00:B093 8523            	   297:   sta  PCODE
00:B095 A526            	   298:   lda  ACT_PCDA+1
00:B097 8524            	   299:   sta  PCODE+1
                        	   300: ;
                        	   301: ;  Running message
                        	   302: ;
00:B099 A91B            	   303:   lda  #<running_message   ; Running
00:B09B A2B0            	   304:   ldx  #>running_message
00:B09D 202682          	   305:   jsr  print
                        	   306: ;
                        	   307: ;  Running flag
                        	   308: ;
00:B0A0 A00C            	   309:   ldy  #$0C
00:B0A2 843F            	   310:   sty  RUNNING
                        	   311: ;
                        	   312: ;  Set up the runtime stack pointer which is also our first stack frame base
                        	   313: ;
00:B0A4 A9FF            	   314:   lda  #<HIGHEST_RAM
00:B0A6 8531            	   315:   sta  T
00:B0A8 853B            	   316:   sta  BASE
00:B0AA A93F            	   317:   lda  #>HIGHEST_RAM
00:B0AC 8532            	   318:   sta  T+1
00:B0AE 853C            	   319:   sta  BASE+1
                        	   320: 
00:B0B0 4C9EB1          	   321:   jmp  MAIN ; start interpreting
                        	   322: ;
                        	   323: ;
                        	   324: ;
                        	   325: 
                        	   326: 
                        	   327: ;***********************************************
                        	   328: ;  INTERPRETER
                        	   329: ;***********************************************
                        	   330: 
                        	   331: ;
                        	   332: ;
00:B0B3 496C6C6567616C20	   333: DM5      asciiz  "Illegal instruction\n"
00:B0BB 696E737472756374
00:B0C3 696F6E0A
00:B0C7 00
00:B0C8 427265616B202E2E	   334: DM6      asciiz  'Break ...\n'
00:B0D0 2E0A
00:B0D2 00
00:B0D3 4572726F72206F63	   335: DM7      asciiz  "Error occurred at P-code "
00:B0DB 6375727265642061
00:B0E3 7420502D636F6465
00:B0EB 20
00:B0EC 00
                        	   336: 
                        	   337: ;
                        	   338: ; DISPLAY (X) CHARACTERS FROM (WORK)
                        	   339: ;
                        	   340: display_x_characters:
00:B0ED 8A              	   341:          txa
00:B0EE 48              	   342:          pha
00:B0EF 20F394          	   343:          jsr  PUTSP
00:B0F2 68              	   344:          pla
00:B0F3 AA              	   345:          tax
00:B0F4 A000            	   346: DIS5     ldy  #0
00:B0F6 B137            	   347:          lda  (WORK),Y
00:B0F8 E637            	   348:          inc  WORK
00:B0FA D002            	   349:          bne  DIS5_A
00:B0FC E638            	   350:          inc  WORK+1
                        	   351: DIS5_A   =  *
00:B0FE A8              	   352:          tay
00:B0FF 8A              	   353:          txa
00:B100 48              	   354:          pha
00:B101 98              	   355:          tya
00:B102 207D94          	   356:          jsr  DISHX
00:B105 68              	   357:          pla
00:B106 AA              	   358:          tax
00:B107 CA              	   359:          dex
00:B108 D0EA            	   360:          bne  DIS5
00:B10A 60              	   361:          rts
                        	   362: 
                        	   363: ;
                        	   364: ; Ding a bell - however we don't have it on this board
                        	   365: ;
                        	   366: BELL1    =  *
00:B10B 48              	   367:          pha
00:B10C A900            	   368:          lda  #0
00:B10E 853F            	   369:          sta  RUNNING
00:B110 206894          	   370:          jsr  CROUT
00:B113 68              	   371:          pla
00:B114 60              	   372:          rts
                        	   373: ;
                        	   374: ;
00:B115 200BB1          	   375: RUNERR   jsr  BELL1
00:B118 A9D3            	   376:          lda  #<DM7  ; Error occurred at P-code
00:B11A A2B0            	   377:          ldx  #>DM7
00:B11C 202682          	   378:          jsr  print
00:B11F A54E            	   379:          lda  LASTP+1
00:B121 20DD94          	   380:          jsr  PRBYTE
00:B124 A54D            	   381:          lda  LASTP
00:B126 207D94          	   382:          jsr  DISHX
                        	   383: EX_FINISHD  =  *
00:B129 A900            	   384:          lda  #0
00:B12B 206894          	   385:          jsr  CROUT
00:B12E A940            	   386:          lda  #<FIN_MSG
00:B130 A2B1            	   387:          ldx  #>FIN_MSG
00:B132 202682          	   388:          jsr  print
00:B135 648B            	   389:          stz  serial_in_byte_received  ; get rid of read-ahead
00:B137 2053CB          	   390:          jsr  GETIN      ; wait till message seen
00:B13A 206894          	   391:          jsr  CROUT      ; output a newline in case they press space or something
00:B13D 4C90DC          	   392:          jmp  RESTART
                        	   393: ;
00:B140 52756E2066696E69	   394: FIN_MSG  asciiz  'Run finished - press a key ...'
00:B148 73686564202D2070
00:B150 726573732061206B
00:B158 6579202E2E2E
00:B15E 00
                        	   395: ;
                        	   396: ;
                        	   397: CHK_KBD  =  *
00:B15F C90E            	   398:          cmp  #KEY_STOP_TRACE       ; Ctrl+N - stop tracing
00:B161 D008            	   399:          bne  CHK_NOTN
00:B163 648B            	   400:          stz  serial_in_byte_received
00:B165 A900            	   401:          lda  #0
00:B167 8549            	   402:          sta  DBGFLG
00:B169 38              	   403:          sec
00:B16A 60              	   404:          rts
00:B16B C914            	   405: CHK_NOTN cmp  #KEY_TRACE      ; Ctrl+T - start tracing
00:B16D D00A            	   406:          bne  CHK_NOTT
00:B16F 648B            	   407:          stz  serial_in_byte_received
00:B171 A980            	   408:          lda  #$80
00:B173 8549            	   409:          sta  DBGFLG
00:B175 852E            	   410:          sta  DCODE
00:B177 38              	   411:          sec
00:B178 60              	   412:          rts
00:B179 C904            	   413: CHK_NOTT cmp  #KEY_DEBUG      ; Ctrl+D - start debugging
00:B17B D00A            	   414:          bne  CHK_NOTD
00:B17D 648B            	   415:          stz  serial_in_byte_received
00:B17F A901            	   416:          lda  #1
00:B181 8549            	   417:          sta  DBGFLG
00:B183 852E            	   418:          sta  DCODE
00:B185 38              	   419:          sec
00:B186 60              	   420:          rts
00:B187 18              	   421: CHK_NOTD clc
00:B188 60              	   422:          rts
                        	   423: ;
                        	   424: EX_OUTCR    =  *
00:B189 206894          	   425:   jsr  CROUT      ; OUTPUT C/R
00:B18C 4C9EB1          	   426:   jmp  MAIN
                        	   427: ;
                        	   428: ;  Here for a "low literal" - a P-code with the 0x80 bit set. Clear that bit and push
                        	   429: ;   the resulting number onto the stack
                        	   430: ;
                        	   431: LOWLIT:
00:B18F E623            	   432:   inc  PCODE     ; increment P-code past the low literal
00:B191 D002            	   433:   bne  LOWLIT1
00:B193 E624            	   434:   inc  PCODE+1
                        	   435: LOWLIT1:
00:B195 8401            	   436:   sty  REG+1     ; Y and REGB were cleared below
00:B197 297F            	   437:   and  #$7F
00:B199 8500            	   438:   sta  REG
                        	   439: ;
                        	   440: ;  fall down to push this value
                        	   441: ;
                        	   442: 
                        	   443: 
                        	   444: ;
                        	   445: ; Push previous result (REG) and then drop down to do the next instruction
                        	   446: ;
                        	   447: MAINP:
00:B19B 207BB2          	   448:  jsr  PSHTOP    ; push REG onto stack and go back to MAIN
                        	   449: 
                        	   450: ;
                        	   451: ;  Main interpreter loop - each instruction jumps back here (or to MAINP above if it
                        	   452: ;              needs to push a previous calculation result)
                        	   453: ;
                        	   454: MAIN:
00:B19E A549            	   455:   lda  DBGFLG   ; debugging?
00:B1A0 F003            	   456:   beq  MAIN_2   ; no
00:B1A2 2024B0          	   457:   jsr  DEBUG    ; yes - show debug info
                        	   458: MAIN_2   =  *
                        	   459: ; check if key pressed here, to abort, or turn on/off tracing or debugging
00:B1A5 A58B            	   460:   lda  serial_in_byte_received
00:B1A7 F00A            	   461:   beq  MAIN_OK
00:B1A9 C903            	   462:   cmp  #KEY_ABORT
00:B1AB D003            	   463:   bne  MAIN_NOT_ABORT
00:B1AD 4C29B1          	   464:   jmp  EX_FINISHD
                        	   465: MAIN_NOT_ABORT = *
00:B1B0 205FB1          	   466:   jsr  CHK_KBD          ; check for turning on trace, debug, etc.
                        	   467: MAIN_OK  =  *
00:B1B3 A523            	   468:   lda  PCODE             ; save P-code address as LASTP (for errors I presume)
00:B1B5 854D            	   469:   sta  LASTP
00:B1B7 A524            	   470:   lda  PCODE+1
00:B1B9 854E            	   471:   sta  LASTP+1
                        	   472: ;
                        	   473: ;  now grab the P-code
                        	   474: ;
00:B1BB A000            	   475:   ldy  #0
00:B1BD 8402            	   476:   sty  REGB
00:B1BF B123            	   477:   lda  (PCODE),Y         ; get the P-code from the P-codes
00:B1C1 30CC            	   478:   bmi  LOWLIT            ; low literal - just handle it
00:B1C3 C946            	   479:   cmp  #PCODE_LAST+1
00:B1C5 B015            	   480:   bcs  EX_INVINS         ; error if off end of table
                        	   481: ;
                        	   482: ;  increment past this P-code
                        	   483: ;
                        	   484: MAIN_5   =  *
00:B1C7 E623            	   485:   inc  PCODE
00:B1C9 D002            	   486:   bne  MAIN_1
00:B1CB E624            	   487:   inc  PCODE+1
                        	   488: ;
                        	   489: ;  grab the execution handler from the execution_address_table
                        	   490: ;
                        	   491: MAIN_1   =  *
00:B1CD 0A              	   492:   asl  A             ; double the P-code because each address takes 2 bytes
00:B1CE AA              	   493:   tax
00:B1CF BD7DAF          	   494:   lda  execution_address_table,X      ; otherwise get the execution address
00:B1D2 8537            	   495:   sta  WORK
00:B1D4 BD7EAF          	   496:   lda  execution_address_table+1,X    ; and the high-order byte
00:B1D7 8538            	   497:   sta  WORK+1
00:B1D9 6C3700          	   498:   jmp  (WORK)        ; execute the appropriate P-code implementation routine
                        	   499: 
                        	   500: ;
                        	   501: NOTIMP   =  *
                        	   502: EX_INVINS   =  *
00:B1DC A9B3            	   503:          LDA  #<DM5   ; Illegal Instruction
00:B1DE A2B0            	   504:          LDX  #>DM5
                        	   505: NOTIM1   =  *
00:B1E0 202682          	   506:          JSR  print
00:B1E3 4C15B1          	   507:          JMP  RUNERR
                        	   508: ;
                        	   509: BREAK    =  *
00:B1E6 A9C8            	   510:          LDA  #<DM6  ; Break ...
00:B1E8 A2B0            	   511:          LDX  #>DM6
00:B1EA 4CE0B1          	   512:          JMP  NOTIM1
                        	   513: 
                        	   514: 
00:B1ED A000            	   515: GETADR   LDY  #0
00:B1EF B123            	   516:          LDA  (PCODE),Y     ; level
00:B1F1 854B            	   517:          STA  COUNT1        ; count of levels to work through
00:B1F3 A53C            	   518:          LDA  BASE+1        ; start with our stack base address
00:B1F5 A63B            	   519:          LDX  BASE
                        	   520: GET2     =  *
00:B1F7 853E            	   521:          STA  DATA+1        ; our data is relative to the stack base
00:B1F9 863D            	   522:          STX  DATA
00:B1FB A8              	   523:          TAY
00:B1FC A54B            	   524:          LDA  COUNT1        ; any levels left?
00:B1FE F018            	   525:          BEQ  GETADR1       ; no, we can continue
00:B200 38              	   526:          SEC                ; yes
00:B201 8A              	   527:          TXA                ; subtract 2 from the base to get the static link
00:B202 E902            	   528:          SBC  #2
00:B204 8537            	   529:          STA  WORK
00:B206 98              	   530:          TYA
00:B207 E900            	   531:          SBC  #0
00:B209 8538            	   532:          STA  WORK+1        ; BASE - 2 -> WORK
00:B20B A000            	   533:          LDY  #0
00:B20D B137            	   534:          LDA  (WORK),Y      ; grab contents of BASE-2
00:B20F C8              	   535:          INY
00:B210 AA              	   536:          TAX
00:B211 B137            	   537:          LDA  (WORK),Y
00:B213 C64B            	   538:          DEC  COUNT1        ; one less level
00:B215 4CF7B1          	   539:          JMP  GET2          ; keep going until we used all levels
                        	   540: 
                        	   541: GETADR1     =  *
00:B218 A001            	   542:          LDY  #1            ; now get the offset
00:B21A 18              	   543:          CLC
00:B21B B123            	   544:          LDA  (PCODE),Y     ; offset low-order byte
00:B21D 653D            	   545:          ADC  DATA          ; add base
00:B21F 853D            	   546:          STA  DATA
00:B221 C8              	   547:          INY
00:B222 B123            	   548:          LDA  (PCODE),Y     ; offset high-order byte
00:B224 653E            	   549:          ADC  DATA+1        ; add base
00:B226 853E            	   550:          STA  DATA+1        ; DATA now holds the data address
00:B228 A523            	   551:          LDA  PCODE         ; add 3 to PCODE to skip level and offset
00:B22A 18              	   552:          CLC
00:B22B 6903            	   553:          ADC  #3
00:B22D 8523            	   554:          STA  PCODE
00:B22F 9002            	   555:          BCC  GET1_A
00:B231 E624            	   556:          INC  PCODE+1
                        	   557: GET1_A   =  *
00:B233 60              	   558:          RTS                ; done - we can use DATA to access whatever-it-is
                        	   559: 
                        	   560: ;
                        	   561: ;  Pull the top item on the runtime stack into REG (aka VALUE)
                        	   562: ;
                        	   563: PULTOP   =  *
00:B234 A000            	   564:          LDY  #0
00:B236 B131            	   565:          LDA  (T),Y
00:B238 8500            	   566:          STA  REG
00:B23A C8              	   567:          INY
00:B23B B131            	   568:          LDA  (T),Y
00:B23D 8501            	   569:          STA  REG+1
00:B23F C8              	   570:          INY
00:B240 B131            	   571:          LDA  (T),Y
00:B242 8502            	   572:          STA  REGB
00:B244 A531            	   573:          LDA  T
00:B246 18              	   574:          CLC      ; add 3 to the stack because we removed one integer from it
00:B247 6903            	   575:          ADC  #3
00:B249 8531            	   576:          STA  T
00:B24B 9002            	   577:          BCC  PUL_END
00:B24D E632            	   578:          INC  T+1
                        	   579: PUL_END  =  *
00:B24F A500            	   580:          LDA  REG
00:B251 A601            	   581:          LDX  REG+1
00:B253 A402            	   582:          LDY  REGB
00:B255 60              	   583:          RTS
                        	   584: 
00:B256 2034B2          	   585: PULBOTH  JSR  PULTOP     ; Pulls both of them - do one and then fall through to do the other
                        	   586: 
                        	   587: ;
                        	   588: ;  Pull the top item on the runtime stack into REG2 (aka VALUE2)
                        	   589: ;
                        	   590: PULTOP2  =  *
00:B259 A000            	   591:          LDY  #0
00:B25B B131            	   592:          LDA  (T),Y
00:B25D 8503            	   593:          STA  REG2
00:B25F C8              	   594:          INY
00:B260 B131            	   595:          LDA  (T),Y
00:B262 8504            	   596:          STA  REG2+1
00:B264 C8              	   597:          INY
00:B265 B131            	   598:          LDA  (T),Y
00:B267 8505            	   599:          STA  REG2B
00:B269 A531            	   600:          LDA  T
00:B26B 18              	   601:          CLC         ; add 3 to the stack because we removed one integer from it
00:B26C 6903            	   602:          ADC  #3
00:B26E 8531            	   603:          STA  T
00:B270 9002            	   604:          BCC  PUL2_END
00:B272 E632            	   605:          INC  T+1
                        	   606: PUL2_END =  *
00:B274 A503            	   607:          LDA  REG2
00:B276 A604            	   608:          LDX  REG2+1
00:B278 A405            	   609:          LDY  REG2B
00:B27A 60              	   610:          RTS
                        	   611: 
                        	   612: ;
                        	   613: ;  Push REG (aka VALUE) onto the runtime stack
                        	   614: ;
                        	   615: PSHTOP   =  *
00:B27B 38              	   616:          SEC        ;  subtract 3 from the stack because we are about to add one integer to it
00:B27C A531            	   617:          LDA  T
00:B27E E903            	   618:          SBC  #3
00:B280 8531            	   619:          STA  T
00:B282 B002            	   620:          BCS  PSH1
00:B284 C632            	   621:          DEC  T+1
                        	   622: PSH1     =  *
00:B286 A000            	   623:          LDY  #0
00:B288 A500            	   624:          LDA  REG
00:B28A 9131            	   625:          STA  (T),Y
00:B28C C8              	   626:          INY
00:B28D A501            	   627:          LDA  REG+1
00:B28F 9131            	   628:          STA  (T),Y
00:B291 C8              	   629:          INY
00:B292 A502            	   630:          LDA  REGB
00:B294 9131            	   631:          STA  (T),Y
00:B296 60              	   632:          RTS
                        	   633: ;
                        	   634: ;  get a literal (2 bytes) from the P-codes and put it into REG
                        	   635: ;
                        	   636: GETLIT   =  *
00:B297 A000            	   637:   ldy  #0
00:B299 B123            	   638:   lda  (PCODE),Y
00:B29B 8500            	   639:   sta  REG
00:B29D C8              	   640:   iny
00:B29E B123            	   641:   lda  (PCODE),Y
00:B2A0 8501            	   642:   sta  REG+1
00:B2A2 A523            	   643:   lda  PCODE
00:B2A4 18              	   644:   clc         ; P-code address goes up by 2
00:B2A5 6902            	   645:   adc  #2
00:B2A7 8523            	   646:   sta  PCODE
00:B2A9 9002            	   647:   bcc  GET_END
00:B2AB E624            	   648:   inc  PCODE+1
                        	   649: GET_END:
00:B2AD 60              	   650:   rts
                        	   651: ;
                        	   652: ; load literal onto the stack (the literal is the next 3 bytes after the P-code)
                        	   653: ;
                        	   654: EX_LIT:
00:B2AE 2097B2          	   655:   jsr  GETLIT   ; get the first 2 bytes
00:B2B1 A000            	   656:   ldy  #0
00:B2B3 B123            	   657:   lda  (PCODE),Y    ; now the third byte
00:B2B5 8502            	   658:   sta  REGB
00:B2B7 E623            	   659:   inc  PCODE
00:B2B9 D002            	   660:   bne  LIT1
00:B2BB E624            	   661:   inc  PCODE+1
                        	   662: LIT1:
00:B2BD 4C9BB1          	   663:   jmp  MAINP    ; now we can push it
                        	   664: ;
                        	   665: ;  Negate (0 - (sp) )
                        	   666: ;
                        	   667: EX_NEG:
00:B2C0 2034B2          	   668:   jsr PULTOP
00:B2C3 204DAE          	   669:   jsr exp_unary_minus
00:B2C6 4C9BB1          	   670:   jmp MAINP
                        	   671: ;
                        	   672: ;  Add (sp) to (sp -1)
                        	   673: ;
                        	   674: EX_ADD:
00:B2C9 2056B2          	   675:   JSR  PULBOTH
00:B2CC 2006AD          	   676:   jsr  exp_add
00:B2CF 4C9BB1          	   677:   JMP  MAINP
                        	   678: ;
                        	   679: ;
                        	   680: ;  Add (sp) from (sp - 1)
                        	   681: ;
                        	   682: EX_SUB:
00:B2D2 2059B2          	   683:   JSR  PULTOP2
00:B2D5 2034B2          	   684:   jsr  PULTOP
00:B2D8 201AAD          	   685:   jsr  exp_subtract
00:B2DB 4C9BB1          	   686:   JMP  MAINP
                        	   687: ;
                        	   688: ;  Multiply (sp) by (sp - 1)
                        	   689: ;
                        	   690: EX_MUL:
00:B2DE 2056B2          	   691:   jsr PULBOTH
00:B2E1 20D4AE          	   692:   jsr exp_multiply
00:B2E4 4C9BB1          	   693:   jmp MAINP
                        	   694: 
                        	   695: ;
                        	   696: ;  we will take the current key (and return to the user)
                        	   697: ;  and zero it out anyway, so that consumes the key
                        	   698: ;
                        	   699: EX_GETKEY   =  *
00:B2E7 A58B            	   700:   lda  serial_in_byte_received
00:B2E9 648B            	   701:   stz  serial_in_byte_received
00:B2EB 4C41B3          	   702:   jmp  TRUE2
                        	   703: ;
                        	   704: ;  Modulus (remainder)
                        	   705: ;
                        	   706: EX_MOD:
00:B2EE 2059B2          	   707:   jsr PULTOP2
                        	   708: ;
                        	   709: ;  check for divide by zero because I want a run-time error message
                        	   710: ;
00:B2F1 A503            	   711:   lda VALUE2
00:B2F3 0504            	   712:   ora VALUE2+1
00:B2F5 0505            	   713:   ora VALUE2+2
00:B2F7 F009            	   714:   beq EX_DIVIDE_BY_ZERO
00:B2F9 2034B2          	   715:   jsr PULTOP
00:B2FC 206DAF          	   716:   jsr exp_modulo
00:B2FF 4C9BB1          	   717:   jmp MAINP
                        	   718: ;
                        	   719: 
                        	   720: EX_DIVIDE_BY_ZERO:
00:B302 A909            	   721:   lda  #<DIVBY0
00:B304 A2B3            	   722:   ldx  #>DIVBY0
00:B306 4CE0B1          	   723:   jmp  NOTIM1
                        	   724: 
00:B309 4469766964652062	   725: DIVBY0   asciiz  'Divide by zero\n'
00:B311 79207A65726F0A
00:B318 00
                        	   726: ;
                        	   727: ;  Divide (sp - 1) by (sp)
                        	   728: ;
                        	   729: EX_DIV:
00:B319 2059B2          	   730:   jsr PULTOP2
00:B31C A503            	   731:   lda VALUE2
00:B31E 0504            	   732:   ora VALUE2+1
00:B320 0505            	   733:   ora VALUE2+2
00:B322 F0DE            	   734:   beq EX_DIVIDE_BY_ZERO
00:B324 2034B2          	   735:   jsr PULTOP
00:B327 200DAF          	   736:   jsr exp_divide
00:B32A 4C9BB1          	   737:   jmp MAINP
                        	   738: 
                        	   739: ;
                        	   740: ;  Absolute value of (sp)
                        	   741: ;
                        	   742: EX_ABS:
00:B32D 2034B2          	   743:   jsr  PULTOP
00:B330 206FAE          	   744:   jsr exp_abs_val
00:B333 4C9BB1          	   745:   jmp  MAINP
                        	   746: 
                        	   747: ; Equal
                        	   748: ;
                        	   749: EX_EQL:
00:B336 2056B2          	   750:   jsr PULBOTH
00:B339 2040AD          	   751:   jsr exp_eql
00:B33C 4C9BB1          	   752:   jmp MAINP
                        	   753: 
                        	   754: ;
                        	   755: ;  Push 1
                        	   756: ;
                        	   757: TRUE:
00:B33F A901            	   758:   lda  #1
                        	   759: ;
                        	   760: ;  Push A into low-order byte, zero other two bytes
                        	   761: ;
                        	   762: TRUE2:
00:B341 8500            	   763:   sta  REG
00:B343 A900            	   764:   lda  #0
00:B345 8501            	   765:   sta  REG+1
00:B347 8502            	   766:   sta  REGB
00:B349 4C9BB1          	   767:   jmp  MAINP
                        	   768: 
                        	   769: ;
                        	   770: ;  Push 0
                        	   771: ;
                        	   772: FALSE:
00:B34C A900            	   773:   lda  #0
00:B34E 80F1            	   774:   bra TRUE2
                        	   775: ;
                        	   776: ;  Not equal
                        	   777: ;
                        	   778: EX_NEQ:
00:B350 2056B2          	   779:     jsr PULBOTH
00:B353 2054AD          	   780:     jsr exp_neq
00:B356 4C9BB1          	   781:     jmp MAINP
                        	   782: 
                        	   783: ;
                        	   784: ;  Less than
                        	   785: ;
                        	   786: EX_LSS:
00:B359 2059B2          	   787:   jsr PULTOP2
00:B35C 2034B2          	   788:   jsr PULTOP
00:B35F 2068AD          	   789:   jsr exp_less_than
00:B362 4C9BB1          	   790:   jmp MAINP
                        	   791: 
                        	   792: ;
                        	   793: ;  Greater than
                        	   794: ;
                        	   795: EX_GTR:
00:B365 2059B2          	   796:   jsr PULTOP2
00:B368 2034B2          	   797:   jsr PULTOP
00:B36B 206FAD          	   798:   jsr exp_greater_than
00:B36E 4C9BB1          	   799:   jmp MAINP
                        	   800: 
                        	   801: ;
                        	   802: ;  Greater than or equal
                        	   803: ;
                        	   804: EX_GEQ:
00:B371 2059B2          	   805:   jsr PULTOP2
00:B374 2034B2          	   806:   jsr PULTOP
00:B377 208DAD          	   807:   jsr exp_geq
00:B37A 4C9BB1          	   808:   jmp MAINP
                        	   809: 
                        	   810: ;
                        	   811: ;  Less than or equal
                        	   812: ;
                        	   813: EX_LEQ:
00:B37D 2059B2          	   814:   jsr PULTOP2
00:B380 2034B2          	   815:   jsr PULTOP
00:B383 207EAD          	   816:   jsr exp_leq
00:B386 4C9BB1          	   817:   jmp MAINP
                        	   818: 
                        	   819: ;
                        	   820: ;  Exclusive OR
                        	   821: ;
                        	   822: EX_XOR:
00:B389 2056B2          	   823:   jsr PULBOTH
00:B38C 20BEAD          	   824:   jsr exp_bitwise_xor
00:B38F 4C9BB1          	   825:   jmp MAINP
                        	   826: ;
                        	   827: ;  Or
                        	   828: ;
                        	   829: EX_ORR:
00:B392 2056B2          	   830:   jsr PULBOTH
00:B395 2094AD          	   831:   jsr exp_bitwise_or
00:B398 4C9BB1          	   832:   jmp MAINP
                        	   833: 
                        	   834: ;
                        	   835: ;  And
                        	   836: ;
                        	   837: EX_AND:
00:B39B 2056B2          	   838:   jsr  PULBOTH
00:B39E 20A9AD          	   839:   jsr exp_bitwise_and
00:B3A1 4C9BB1          	   840:   jmp MAINP
                        	   841: 
                        	   842: ;
                        	   843: ;  Not
                        	   844: ;
                        	   845: EX_EOR:
00:B3A4 2034B2          	   846:   jsr PULTOP
00:B3A7 203FAE          	   847:   jsr exp_not
00:B3AA 4C9BB1          	   848:   jmp MAINP
                        	   849: ;
                        	   850: ; Shift left
                        	   851: ;
                        	   852: EX_SHL:
00:B3AD 2059B2          	   853:   jsr PULTOP2
00:B3B0 2034B2          	   854:   jsr PULTOP
00:B3B3 20FAAD          	   855:   jsr exp_shift_left
00:B3B6 4C9BB1          	   856:   jmp MAINP
                        	   857: 
                        	   858: ;
                        	   859: ;  Shift right
                        	   860: ;
                        	   861: EX_SHR:
00:B3B9 2059B2          	   862:   jsr PULTOP2
00:B3BC 2034B2          	   863:   jsr PULTOP
00:B3BF 2013AE          	   864:   jsr exp_shift_right
00:B3C2 4C9BB1          	   865:   jmp MAINP
                        	   866: 
                        	   867: ;
                        	   868: ;  increment number on top of stack by one
                        	   869: ;
                        	   870: EX_INC:
00:B3C5 18              	   871:   clc
00:B3C6 B131            	   872:   lda  (T),Y
00:B3C8 6901            	   873:   adc  #1
00:B3CA 9131            	   874:   sta  (T),Y
00:B3CC C8              	   875:   iny
00:B3CD B131            	   876:   lda  (T),Y
00:B3CF 6900            	   877:   adc  #0
00:B3D1 9131            	   878:   sta  (T),Y
00:B3D3 C8              	   879:   iny
00:B3D4 B131            	   880:   lda  (T),Y
00:B3D6 6900            	   881:   adc  #0
00:B3D8 9131            	   882:   sta  (T),Y
00:B3DA 4C9EB1          	   883:   jmp  MAIN
                        	   884: ;
                        	   885: ;  decrement number on top of stack by one
                        	   886: ;
                        	   887: 
                        	   888: EX_DEC:
00:B3DD 38              	   889:   sec
00:B3DE B131            	   890:   lda  (T),Y
00:B3E0 E901            	   891:   sbc  #1
00:B3E2 9131            	   892:   sta  (T),Y
00:B3E4 C8              	   893:   iny
00:B3E5 B131            	   894:   lda  (T),Y
00:B3E7 E900            	   895:   sbc  #0
00:B3E9 9131            	   896:   sta  (T),Y
00:B3EB C8              	   897:   iny
00:B3EC B131            	   898:   lda  (T),Y
00:B3EE E900            	   899:   sbc  #0
00:B3F0 9131            	   900:   sta  (T),Y
00:B3F2 4C9EB1          	   901:   jmp  MAIN
                        	   902: 
                        	   903: ;
                        	   904: ;  Copy (sp) to (sp + 1)
                        	   905: ;
                        	   906: EX_MOV:
00:B3F5 B131            	   907:   lda  (T),Y  ; get item at top of stack
00:B3F7 8500            	   908:   sta REG
00:B3F9 C8              	   909:   iny
00:B3FA B131            	   910:   lda  (T),Y
00:B3FC 8501            	   911:   sta REG+1
00:B3FE C8              	   912:   iny
00:B3FF B131            	   913:   lda  (T),Y
00:B401 8502            	   914:   sta REGB
00:B403 4C9BB1          	   915:   jmp MAINP   ; push it
                        	   916: 
                        	   917: ;
                        	   918: ;  Load a single-character value (variable) onto the stack
                        	   919: ;
                        	   920: 
                        	   921: EX_LODC:
00:B406 20EDB1          	   922:   jsr  GETADR
                        	   923: EX_LOD3:
00:B409 A002            	   924:   ldy  #2
                        	   925: EX_LOD3_A:
00:B40B A900            	   926:   lda  #0      ; since this is a character zero out the high-order bytes
00:B40D 8501            	   927:   sta  REG+1
00:B40F 8502            	   928:   sta  REGB
00:B411 B13D            	   929:   lda  (DATA),Y  ; (DATA) contains the lower-order byte
00:B413 8500            	   930:   sta  REG       ; REG will be pushed
00:B415 4C9BB1          	   931:   jmp  MAINP     ; push REG and go to MAIN
                        	   932: ;
                        	   933: ;  Load a 3-byte value (variable) onto the stack
                        	   934: ;
                        	   935: EX_LOD:
00:B418 20EDB1          	   936:   jsr  GETADR
                        	   937: EX_LOD2:
00:B41B A000            	   938:   ldy  #0
00:B41D B13D            	   939:   lda  (DATA),Y    ; (DATA) contains the variable value
00:B41F 8500            	   940:   sta  REG
00:B421 C8              	   941:   iny
00:B422 B13D            	   942:   lda  (DATA),Y
00:B424 8501            	   943:   sta  REG+1
00:B426 C8              	   944:   iny
00:B427 B13D            	   945:   lda  (DATA),Y
00:B429 8502            	   946:   sta REGB
00:B42B 4C9BB1          	   947:   jmp MAINP   ; push it
                        	   948: 
                        	   949: ;
                        	   950: ;  Load absolute address character
                        	   951: ;
                        	   952: EX_LDAC:
00:B42E 2034B2          	   953:   jsr  PULTOP
00:B431 853D            	   954:   sta  DATA
00:B433 863E            	   955:   stx  DATA+1
00:B435 A000            	   956:   ldy  #0
00:B437 F0D2            	   957:   beq  EX_LOD3_A
                        	   958: ;
                        	   959: ;  Load absolute address integer
                        	   960: ;
                        	   961: EX_LDA:
00:B439 2034B2          	   962:   jsr  PULTOP
00:B43C 853D            	   963:   sta  DATA
00:B43E 863E            	   964:   stx  DATA+1
00:B440 4C1BB4          	   965:   jmp  EX_LOD2
                        	   966: ;
                        	   967: ;  Get address of indexed character
                        	   968: ;
                        	   969: GETIDC:
00:B443 2059B2          	   970:   jsr  PULTOP2    ; pull index into REG2
00:B446 20EDB1          	   971:   jsr  GETADR
00:B449 4C60B4          	   972:   jmp  GETID2
                        	   973: ;
                        	   974: ;  Get address of indexed integer
                        	   975: ;
                        	   976: GETIDX   =  *
00:B44C 2059B2          	   977:   jsr  PULTOP2  ; pull index into REG2
00:B44F 0603            	   978:   asl  REG2     ; now multiply by 3
00:B451 2604            	   979:   rol  REG2+1
00:B453 18              	   980:   clc
00:B454 6503            	   981:   adc  REG2
00:B456 8503            	   982:   sta  REG2
00:B458 8A              	   983:   txa
00:B459 6504            	   984:   adc  REG2+1
00:B45B 8504            	   985:   sta  REG2+1     ; TIMES 3
00:B45D 20EDB1          	   986:   jsr  GETADR
                        	   987: ;
                        	   988: ;  Get address of indexed integer/character
                        	   989: ;
                        	   990: ;  It looks like arrays expand downwards
                        	   991: ;
                        	   992: GETID2:
00:B460 A53D            	   993:   lda  DATA     ; initial address
00:B462 38              	   994:   sec           ; subtract subscript
00:B463 E503            	   995:   sbc  REG2
00:B465 853D            	   996:   sta  DATA
00:B467 A53E            	   997:   lda  DATA+1
00:B469 E504            	   998:   sbc  REG2+1
00:B46B 853E            	   999:   sta  DATA+1
00:B46D 60              	  1000:   rts
                        	  1001: ;
                        	  1002: ;  Load indexed character
                        	  1003: ;
                        	  1004: EX_LDIC:
00:B46E 2043B4          	  1005:   jsr  GETIDC
00:B471 4C09B4          	  1006:   jmp  EX_LOD3
                        	  1007: ;
                        	  1008: ;  Load indexed integer
                        	  1009: ;
                        	  1010: EX_LDI:
00:B474 204CB4          	  1011:   jsr  GETIDX
00:B477 4C1BB4          	  1012:   jmp  EX_LOD2
                        	  1013: ;
                        	  1014: ;  Store character
                        	  1015: ;
                        	  1016: EX_STOC:
00:B47A 20EDB1          	  1017:   jsr  GETADR
00:B47D 2034B2          	  1018:   jsr  PULTOP
00:B480 A002            	  1019:   ldy  #2   ; why?
                        	  1020: EX_STO5:
00:B482 913D            	  1021:   sta  (DATA),Y
00:B484 4C9EB1          	  1022:   jmp  MAIN
                        	  1023: ;
                        	  1024: ;  Store integer
                        	  1025: ;
                        	  1026: EX_STO:
00:B487 20EDB1          	  1027:   jsr  GETADR   ; get its address
00:B48A 2034B2          	  1028:   jsr  PULTOP   ; get the value to store
                        	  1029: EX_STO2:
00:B48D A000            	  1030:   ldy  #0
00:B48F 913D            	  1031:   sta  (DATA),Y
00:B491 C8              	  1032:   iny
00:B492 8A              	  1033:   txa
00:B493 913D            	  1034:   sta  (DATA),Y
00:B495 A502            	  1035:   lda  REGB
00:B497 C8              	  1036:   iny
00:B498 D0E8            	  1037:   bne  EX_STO5
                        	  1038: ;
                        	  1039: ;  Store integer at absolute address
                        	  1040: ;
                        	  1041: EX_STA:
00:B49A 2056B2          	  1042:   jsr  PULBOTH  ; get address into REG2 and value into REG
00:B49D A000            	  1043:   ldy  #0
00:B49F A500            	  1044:   lda  REG
00:B4A1 9103            	  1045:   sta  (REG2),Y
00:B4A3 C8              	  1046:   iny
00:B4A4 A501            	  1047:   lda  REG+1
00:B4A6 9103            	  1048:   sta  (REG2),Y
00:B4A8 C8              	  1049:   iny
00:B4A9 A502            	  1050:   lda  REGB
                        	  1051: EX_STA5:
00:B4AB 9103            	  1052:   sta  (REG2),Y
00:B4AD 4C9EB1          	  1053:   jmp  MAIN
                        	  1054: ;
                        	  1055: ;  Store character at absolute address
                        	  1056: ;
                        	  1057: EX_STAC:
00:B4B0 2056B2          	  1058:   jsr  PULBOTH  ; get address into REG2 and value into REG
00:B4B3 A500            	  1059:   lda  REG
00:B4B5 A000            	  1060:   ldy  #0
00:B4B7 F0F2            	  1061:   beq  EX_STA5
                        	  1062: ;
                        	  1063: ;     Store character indexed
                        	  1064: ;
                        	  1065: EX_STIC:
00:B4B9 2034B2          	  1066:   jsr  PULTOP
00:B4BC 8545            	  1067:   sta  TEMP
00:B4BE 2043B4          	  1068:   jsr  GETIDC
00:B4C1 A545            	  1069:   lda  TEMP
00:B4C3 A002            	  1070:   ldy  #2
00:B4C5 D0BB            	  1071:   bne  EX_STO5
                        	  1072: ;
                        	  1073: ;     Store integer indexed
                        	  1074: ;
                        	  1075: EX_STI :
00:B4C7 2034B2          	  1076:   jsr  PULTOP
00:B4CA 8545            	  1077:   sta  TEMP
00:B4CC 8646            	  1078:   stx  TEMP+1
00:B4CE 98              	  1079:   tya
00:B4CF 48              	  1080:   pha
00:B4D0 204CB4          	  1081:   jsr  GETIDX
00:B4D3 A000            	  1082:   ldy  #0
00:B4D5 A545            	  1083:   lda  TEMP
00:B4D7 913D            	  1084:   sta  (DATA),Y
00:B4D9 A546            	  1085:   lda  TEMP+1
00:B4DB C8              	  1086:   iny
00:B4DC 913D            	  1087:   sta  (DATA),Y
00:B4DE 68              	  1088:   pla
00:B4DF C8              	  1089:   iny
00:B4E0 D0A0            	  1090:   bne  EX_STO5
                        	  1091: ;
                        	  1092: ;  Procedure/function return
                        	  1093: ;
                        	  1094: ;  Stack frame linkage data:
                        	  1095: ;
                        	  1096: ;    (from low to high address)
                        	  1097: ;
                        	  1098: ;    Return address <-- P-code to return to when function/procedure exits
                        	  1099: ;    Dynamic link   <-- The previous stack frame from the earlier function call
                        	  1100: ;    Static link    <-- The stack frame of the previous static function
                        	  1101: ;
                        	  1102: ;  Static and dynamic links will be the same except for recursive calls.
                        	  1103: ;
                        	  1104: ;  To unwind the stack we have to go back to the previous dynamic link (on a return)
                        	  1105: ;
                        	  1106: ;  However to find variables in previous lexical declarations we have to use the static link.
                        	  1107: ;
                        	  1108: ;
                        	  1109: EX_RTN:
                        	  1110: ;
                        	  1111: ;  Subtract 6 from the base address, put result into WORK
                        	  1112: ;
00:B4E2 38              	  1113:   sec
00:B4E3 A53B            	  1114:   lda  BASE
00:B4E5 E906            	  1115:   sbc  #6
00:B4E7 8537            	  1116:   sta  WORK
00:B4E9 A53C            	  1117:   lda  BASE+1
00:B4EB E900            	  1118:   sbc  #0
00:B4ED 8538            	  1119:   sta  WORK+1
                        	  1120: ;
                        	  1121: ;  The return address was at the bottom of BASE, so put that into PCODE
                        	  1122: ;
00:B4EF A000            	  1123:   ldy  #0
00:B4F1 B137            	  1124:   lda  (WORK),Y
00:B4F3 8523            	  1125:   sta  PCODE
00:B4F5 C8              	  1126:   iny
00:B4F6 B137            	  1127:   lda  (WORK),Y
00:B4F8 8524            	  1128:   sta  PCODE+1
                        	  1129: 
                        	  1130: ;
                        	  1131: ;  The base address becomes our new top of runtime stack
                        	  1132: ;
00:B4FA A53C            	  1133:   lda  BASE+1
00:B4FC 8532            	  1134:   sta  T+1
00:B4FE A53B            	  1135:   lda  BASE
00:B500 8531            	  1136:   sta  T
                        	  1137: ;
                        	  1138: ;  The dynamic stack frame address is 4 bytes down from the BASE - put that into WORK
                        	  1139: ;
00:B502 38              	  1140:   sec
00:B503 E904            	  1141:   sbc  #4
00:B505 8537            	  1142:   sta  WORK
00:B507 A53C            	  1143:   lda  BASE+1
00:B509 E900            	  1144:   sbc  #0
00:B50B 8538            	  1145:   sta  WORK+1
                        	  1146: ;
                        	  1147: ;  Get the previous dynamic stack frame address and put it into BASE (in case of
                        	  1148: ;   recursive function calls)
                        	  1149: ;
00:B50D A000            	  1150:   ldy  #0
00:B50F B137            	  1151:   lda  (WORK),Y
00:B511 853B            	  1152:   sta  BASE
00:B513 C8              	  1153:   iny
00:B514 B137            	  1154:   lda  (WORK),Y
00:B516 853C            	  1155:   sta  BASE+1
                        	  1156: ;
                        	  1157: ;  Stack, base and Pcode all changed, ready for next instruction
                        	  1158: ;
00:B518 4C9EB1          	  1159:   jmp  MAIN
                        	  1160: 
                        	  1161: ;
                        	  1162: ; Input a number into a variable
                        	  1163: ;
                        	  1164: EX_INP      =  *
00:B51B A980            	  1165:   lda #$80
00:B51D 853F            	  1166:   sta  RUNNING
00:B51F 20CE95          	  1167:   JSR  GET_LINE
00:B522 AD0002          	  1168:   lda  INBUF
00:B525 C903            	  1169:   cmp  #KEY_ABORT   ; check for aborting with Ctrl+C
00:B527 D003            	  1170:   bne  EX_INP_OK
00:B529 4C76B7          	  1171:   jmp  ex_input_aborted
                        	  1172: 
                        	  1173: EX_INP_OK:
00:B52C A900            	  1174:   lda #<INBUF
00:B52E 858E            	  1175:   sta token_start
00:B530 A902            	  1176:   lda #>INBUF
00:B532 858F            	  1177:   sta token_start+1
00:B534 6493            	  1178:   stz token_type
00:B536 20D3CB          	  1179:   jsr get_token
00:B539 C94E            	  1180:   cmp #TOKEN_NUMBER
00:B53B D016            	  1181:   bne BAD_INP
00:B53D A694            	  1182:   LDX  token_value
00:B53F A495            	  1183:   LDY  token_value+1
00:B541 A596            	  1184:   LDA  token_value+2
                        	  1185: INP3:
00:B543 8401            	  1186:   sty  REG+1
00:B545 8600            	  1187:   stx  REG
00:B547 8502            	  1188:   sta  REGB
00:B549 207BB2          	  1189:   jsr  PSHTOP
00:B54C A20C            	  1190:   ldx  #12
00:B54E 863F            	  1191:   stx  RUNNING
00:B550 4C9EB1          	  1192:   jmp  MAIN
                        	  1193: ;
                        	  1194: ;  bad number: set it to $800000
                        	  1195: ;
                        	  1196: BAD_INP:
00:B553 A980            	  1197:   lda #$80
00:B555 A200            	  1198:   ldx #0
00:B557 A000            	  1199:   ldy #0
00:B559 F0E8            	  1200:   beq INP3
                        	  1201: ;
                        	  1202: ; write a number to output
                        	  1203: ;
                        	  1204: EX_OUT:
00:B55B 203DCB          	  1205:   jsr write_to_serial
00:B55E 8003            	  1206:   bra OUT_COMMON
                        	  1207: 
                        	  1208: EX_LCD_WRITE_NUM:
00:B560 2048CB          	  1209:   jsr write_to_lcd
                        	  1210: 
                        	  1211: OUT_COMMON:
00:B563 2034B2          	  1212:   jsr  PULTOP
00:B566 209293          	  1213:   jsr  display_in_decimal
00:B569 203DCB          	  1214:   jsr  write_to_serial
00:B56C 4C9EB1          	  1215:   jmp  MAIN
                        	  1216: ;
                        	  1217: ;
                        	  1218: ; Output 6 hex characters (3 bytes)
                        	  1219: ;
                        	  1220: EX_OUH:
00:B56F 203DCB          	  1221:   jsr write_to_serial
00:B572 8003            	  1222:   bra EX_OUH_COMMON
                        	  1223: 
                        	  1224: EX_LCD_WRITE_HEX:
00:B574 2048CB          	  1225:   jsr write_to_lcd
                        	  1226: 
                        	  1227: EX_OUH_COMMON:
00:B577 2034B2          	  1228:   jsr  PULTOP
00:B57A A502            	  1229:   lda  REGB
00:B57C 20DD94          	  1230:   jsr  PRBYTE
00:B57F A501            	  1231:   lda  REG+1
00:B581 20DD94          	  1232:   jsr  PRBYTE
00:B584 A500            	  1233:   lda  REG
00:B586 20DD94          	  1234:   jsr  PRBYTE
00:B589 203DCB          	  1235:   jsr  write_to_serial
00:B58C 4C9EB1          	  1236:   jmp  MAIN
                        	  1237: ;
                        	  1238: ;  write a string to output
                        	  1239: ;
                        	  1240: EX_OUS      =  *
00:B58F 203DCB          	  1241:   jsr write_to_serial
00:B592 8003            	  1242:   bra EX_OUS_COMMON
                        	  1243: 
                        	  1244: EX_LCD_WRITE_STR:
00:B594 2048CB          	  1245:   jsr write_to_lcd
                        	  1246: 
                        	  1247: EX_OUS_COMMON:
00:B597 A523            	  1248:   lda  PCODE
00:B599 18              	  1249:   clc
00:B59A 6901            	  1250:   adc  #1
00:B59C 8537            	  1251:   sta  WORK
00:B59E A524            	  1252:   lda  PCODE+1
00:B5A0 6900            	  1253:   adc  #0
00:B5A2 8538            	  1254:   sta  WORK+1
00:B5A4 B123            	  1255:   lda  (PCODE),Y
00:B5A6 854B            	  1256:   sta  COUNT1     ; NO. OF CHARS
00:B5A8 18              	  1257:   clc
00:B5A9 6901            	  1258:   adc  #1
00:B5AB 6523            	  1259:   adc  PCODE
00:B5AD 8523            	  1260:   sta  PCODE
00:B5AF 9002            	  1261:   bcc  EX_OUS1
00:B5B1 E624            	  1262:   inc  PCODE+1
                        	  1263: EX_OUS1:
00:B5B3 A537            	  1264:   lda  WORK
00:B5B5 A638            	  1265:   ldx  WORK+1
00:B5B7 A44B            	  1266:   ldy  COUNT1
00:B5B9 20F794          	  1267:   jsr  PT
00:B5BC 203DCB          	  1268:   jsr write_to_serial
00:B5BF 4C9EB1          	  1269:   jmp  MAIN
                        	  1270: 
                        	  1271: 
                        	  1272: 
                        	  1273: ;
                        	  1274: ;  Stack frame linkage data:
                        	  1275: ;
                        	  1276: ;    (from low to high address)
                        	  1277: ;
                        	  1278: ;    Return address <-- P-code to return to when function/procedure exits
                        	  1279: ;    Dynamic link   <-- The previous stack frame from the earlier function call
                        	  1280: ;    Static link    <-- The stack frame of the previous static function
                        	  1281: ;
                        	  1282: ;  Static and dynamic links will be the same except for recursive calls.
                        	  1283: ;
                        	  1284: ;  To unwind the stack we have to go back to the previous dynamic link (on a return)
                        	  1285: ;
                        	  1286: ;  However to find variables in previous lexical declarations we have to use the static link.
                        	  1287: ;
                        	  1288: ;
                        	  1289: ; Call absolute procedure - I don't think this is used in this version TBH
                        	  1290: ;
                        	  1291: ; Note: Y is zero when entering
                        	  1292: ;
                        	  1293: EX_ABSCLL   =  *
00:B5C2 8447            	  1294:   sty  CALL      ; zero out address to be called
00:B5C4 8448            	  1295:   sty  CALL+1    ; (offset therefore becomes absolute address)
00:B5C6 4CD1B5          	  1296:   jmp  EX_CLL_A
                        	  1297: ;
                        	  1298: ; Call relative procedure
                        	  1299: ;
                        	  1300: ; Note: Y is zero when entering
                        	  1301: ;
                        	  1302: EX_CLL      =  *
00:B5C9 A54D            	  1303:   lda  LASTP
00:B5CB 8547            	  1304:   sta  CALL
00:B5CD A54E            	  1305:   lda  LASTP+1
00:B5CF 8548            	  1306:   sta  CALL+1
                        	  1307: EX_CLL_A    =  *
00:B5D1 B123            	  1308:   lda  (PCODE),Y     ; level
00:B5D3 854B            	  1309:   sta  COUNT1
00:B5D5 C8              	  1310:   iny
00:B5D6 18              	  1311:   clc
00:B5D7 B123            	  1312:   lda  (PCODE),Y     ; relative address
00:B5D9 6547            	  1313:   adc  CALL          ; add to current P-code address
00:B5DB 8547            	  1314:   sta  CALL
00:B5DD C8              	  1315:   iny
00:B5DE B123            	  1316:   lda  (PCODE),Y
00:B5E0 6548            	  1317:   adc  CALL+1
00:B5E2 8548            	  1318:   sta  CALL+1
00:B5E4 A523            	  1319:   lda  PCODE         ; add 3 to P-code to bypass level / address
00:B5E6 18              	  1320:   clc                ; this will become our return address
00:B5E7 6903            	  1321:   adc  #3
00:B5E9 8523            	  1322:   sta  PCODE
00:B5EB 9002            	  1323:   bcc  EX_CLL4
00:B5ED E624            	  1324:   inc  PCODE+1
                        	  1325: EX_CLL4     =  *
00:B5EF A53C            	  1326:   lda  BASE+1
00:B5F1 A63B            	  1327:   ldx  BASE
                        	  1328: EX_CLL2     =  *
00:B5F3 853E            	  1329:   sta  DATA+1      ; this was BASE
00:B5F5 863D            	  1330:   stx  DATA
00:B5F7 A8              	  1331:   tay
00:B5F8 A54B            	  1332:   lda  COUNT1      ; this was the level
00:B5FA F018            	  1333:   beq  EX_CLL3
00:B5FC 38              	  1334:   sec
00:B5FD 8A              	  1335:   txa
00:B5FE E902            	  1336:   sbc  #2          ; subtract 2 from BASE, store in WORK
00:B600 8537            	  1337:   sta  WORK
00:B602 98              	  1338:   tya
00:B603 E900            	  1339:   sbc  #0
00:B605 8538            	  1340:   sta  WORK+1
00:B607 A000            	  1341:   ldy  #0
00:B609 B137            	  1342:   lda  (WORK),Y
00:B60B C8              	  1343:   iny
00:B60C AA              	  1344:   tax
00:B60D B137            	  1345:   lda  (WORK),Y
00:B60F C64B            	  1346:   dec  COUNT1
00:B611 4CF3B5          	  1347:   jmp  EX_CLL2
                        	  1348: EX_CLL3     =  *
00:B614 A531            	  1349:   lda  T         ; our stack pointer
00:B616 8545            	  1350:   sta  TEMP      ; save it
00:B618 A532            	  1351:   lda  T+1
00:B61A 8546            	  1352:   sta  TEMP+1
                        	  1353: ;
                        	  1354: ; this is as confusing as all-get-out but it looks like we
                        	  1355: ; are pushing onto the stack: DATA / BASE / PCODE (return address)
                        	  1356: ;  (which is why we saved T into TEMP so it didn't change during the pushes)
                        	  1357: ;
                        	  1358: 
00:B61C A53D            	  1359:   lda  DATA      ; put DATA into REG
00:B61E 8501            	  1360:   sta  REG+1
00:B620 A53E            	  1361:   lda  DATA+1
00:B622 8502            	  1362:   sta  REGB
00:B624 A53C            	  1363:   lda  BASE+1
00:B626 8500            	  1364:   sta  REG
00:B628 207BB2          	  1365:   jsr  PSHTOP      ; push REG (DATA + BASE[1])
00:B62B A53B            	  1366:   lda  BASE
00:B62D 8502            	  1367:   sta  REGB
00:B62F A545            	  1368:   lda  TEMP        ; old stack pointer
00:B631 853B            	  1369:   sta  BASE        ; becomes BASE
00:B633 A546            	  1370:   lda  TEMP+1      ; ditto for other byte
00:B635 853C            	  1371:   sta  BASE+1
00:B637 A523            	  1372:   lda  PCODE       ; get ready to push current P-Code
00:B639 8500            	  1373:   sta  REG
00:B63B A524            	  1374:   lda  PCODE+1
00:B63D 8501            	  1375:   sta  REG+1
00:B63F 207BB2          	  1376:   jsr  PSHTOP     ; push REG (BASE[0] + PCODE)
00:B642 A547            	  1377:   lda  CALL       ; now get the address of the place we want to call
00:B644 8523            	  1378:   sta  PCODE      ; and put it into PCODE
00:B646 A548            	  1379:   lda  CALL+1
00:B648 8524            	  1380:   sta  PCODE+1
00:B64A 18              	  1381:   clc             ; add 6 to the stack pointer because we later emit the code to INT 6 (leave room for base stuff)
00:B64B A531            	  1382:   lda  T
00:B64D 6906            	  1383:   adc  #6
00:B64F 8531            	  1384:   sta  T
00:B651 9002            	  1385:   bcc  EX_CLL5
00:B653 E632            	  1386:   inc  T+1
                        	  1387: EX_CLL5     =  *
00:B655 4C9EB1          	  1388:   jmp  MAIN        ; we are done, MAIN will now go to the called subroutine
                        	  1389: ;
                        	  1390: ;  Here for calling machine code from Pascal
                        	  1391: ;
                        	  1392: EX_CLA:
00:B658 2034B2          	  1393:   jsr  PULTOP      ; pull the address to be called from the stack
00:B65B A513            	  1394:   lda  call_p      ; status register
00:B65D 48              	  1395:   pha
00:B65E A510            	  1396:   lda  call_a      ; A register
00:B660 A611            	  1397:   ldx  call_x      ; X register
00:B662 A412            	  1398:   ldy  call_y      ; Y register
00:B664 28              	  1399:   plp              ; get status register back
00:B665 2075B6          	  1400:   jsr  EX_CLL_JMP  ; call the subroutine
00:B668 08              	  1401:   php              ; save the status register
00:B669 8510            	  1402:   sta  call_a      ; store the A/X/Y register
00:B66B 8611            	  1403:   stx  call_x
00:B66D 8412            	  1404:   sty  call_y
00:B66F 68              	  1405:   pla              ; get status register back
00:B670 8513            	  1406:   sta  call_p      ; save it
00:B672 4C9EB1          	  1407:   jmp  MAIN        ; done!
                        	  1408: 
00:B675 6C0000          	  1409: EX_CLL_JMP  jmp  (REG)
                        	  1410: ;
                        	  1411: ;
                        	  1412: ; increment stack pointer (that is, subtract the literal from it, as it grows downwards)
                        	  1413: ;
                        	  1414: EX_INT:
00:B678 2097B2          	  1415:   jsr  GETLIT
00:B67B 38              	  1416:   sec
00:B67C A531            	  1417:   lda  T
00:B67E E500            	  1418:   sbc  REG
00:B680 8531            	  1419:   sta  T
00:B682 A532            	  1420:   lda  T+1
00:B684 E501            	  1421:   sbc  REG+1
00:B686 8532            	  1422:   sta  T+1
00:B688 C544            	  1423:   cmp  END_PCD+1
00:B68A 9003            	  1424:   bcc  INT_ERR
00:B68C 4C9EB1          	  1425:   jmp  MAIN
                        	  1426: ;
                        	  1427: INT_ERR  =  *
00:B68F A996            	  1428:   lda  #<INT_ERRM    ; stack full
00:B691 A2B6            	  1429:   ldx  #>INT_ERRM
00:B693 4CE0B1          	  1430:   jmp  NOTIM1
                        	  1431: ;
00:B696 537461636B206675	  1432: INT_ERRM asciiz "Stack full\n"    ; stack full
00:B69E 6C6C0A
00:B6A1 00
                        	  1433: ;
                        	  1434: 
                        	  1435: ;
                        	  1436: ;  Change the runtime stack to the address given (assuming stack is empty)
                        	  1437: ;   Done by the {%S nnnn} compiler directive.
                        	  1438: ;
                        	  1439: EX_NEW_STACK:
00:B6A2 2097B2          	  1440:   jsr GETLIT
00:B6A5 A500            	  1441:   lda REG
00:B6A7 8531            	  1442:   sta T
00:B6A9 853B            	  1443:   sta BASE
00:B6AB A501            	  1444:   lda REG+1
00:B6AD 8532            	  1445:   sta T+1
00:B6AF 853C            	  1446:   sta BASE+1
00:B6B1 4C9EB1          	  1447:   jmp MAIN
                        	  1448: 
                        	  1449: ;
                        	  1450: ;  Jump to the address following the P-code
                        	  1451: ;
                        	  1452: EX_JMP:
00:B6B4 2097B2          	  1453:   jsr  GETLIT   ; get the address
00:B6B7 18              	  1454:   clc
00:B6B8 A500            	  1455:   lda  REG
00:B6BA 654D            	  1456:   adc  LASTP
00:B6BC 8523            	  1457:   sta  PCODE
00:B6BE A501            	  1458:   lda  REG+1
00:B6C0 654E            	  1459:   adc  LASTP+1
00:B6C2 8524            	  1460:   sta  PCODE+1
00:B6C4 4C9EB1          	  1461:   jmp  MAIN
                        	  1462: ;
                        	  1463: ;  Jump if the top of the stack is zero
                        	  1464: ;
                        	  1465: EX_JMZ:
00:B6C7 2034B2          	  1466:   jsr  PULTOP   ; puts REG into A
00:B6CA 0501            	  1467:   ora  REG+1
00:B6CC 0502            	  1468:   ora  REGB
00:B6CE D002            	  1469:   bne  EX_NOJUMP
00:B6D0 F0E2            	  1470:   beq  EX_JMP
                        	  1471: ;
                        	  1472: ;  Don't jump, just move past the address (TODO: just add 2?)
                        	  1473: ;
                        	  1474: EX_NOJUMP:
00:B6D2 2097B2          	  1475:   jsr  GETLIT
00:B6D5 4C9EB1          	  1476:   jmp  MAIN
                        	  1477: ;
                        	  1478: ;  Jump if the top of the stack is non-zero
                        	  1479: ;
                        	  1480: EX_JM1:
00:B6D8 2034B2          	  1481:   jsr  PULTOP    ; puts REG into A
00:B6DB 0501            	  1482:   ora  REG+1
00:B6DD 0502            	  1483:   ora  REGB
00:B6DF D0D3            	  1484:   bne  EX_JMP
00:B6E1 F0EF            	  1485:   beq  EX_NOJUMP
                        	  1486: ;
                        	  1487: ;
                        	  1488: EX_INPC:
00:B6E3 2053CB          	  1489:   jsr GETIN
00:B6E6 C903            	  1490:   cmp  #KEY_ABORT   ; check for aborting with Ctrl+C
00:B6E8 D003            	  1491:   bne  EX_INPC_OK
00:B6EA 4C76B7          	  1492:   jmp  ex_input_aborted
                        	  1493: 
                        	  1494: EX_INPC_OK:
00:B6ED 205FB1          	  1495:   jsr CHK_KBD
00:B6F0 B0F1            	  1496:   bcs EX_INPC
00:B6F2 8500            	  1497:   sta REG
00:B6F4 A900            	  1498:   lda #0
00:B6F6 8501            	  1499:   sta REG+1
00:B6F8 8502            	  1500:   sta REGB
00:B6FA 4C9BB1          	  1501:   jmp  MAINP
                        	  1502: ;
                        	  1503: EX_OUTC:
00:B6FD 203DCB          	  1504:   jsr write_to_serial
00:B700 8003            	  1505:   bra EX_OUTC_COMMON
                        	  1506: 
                        	  1507: EX_LCD_WRITE_CHR:
00:B702 2048CB          	  1508:   jsr write_to_lcd
                        	  1509: 
                        	  1510: EX_OUTC_COMMON:
00:B705 2034B2          	  1511:   jsr  PULTOP
00:B708 A500            	  1512:   lda  REG
00:B70A 20F695          	  1513:   jsr  COUT
00:B70D 203DCB          	  1514:   jsr write_to_serial
00:B710 4C9EB1          	  1515:   jmp  MAIN
                        	  1516:   ;
                        	  1517: 
                        	  1518: EX_LCDHOME:
00:B713 203BBB          	  1519:   jsr lcd_home
00:B716 4C9EB1          	  1520:   JMP MAIN
                        	  1521: 
                        	  1522: 
                        	  1523: EX_LCDCLEAR:
00:B719 202BBB          	  1524:   jsr lcd_clear_display
00:B71C 4C9EB1          	  1525:   JMP MAIN
                        	  1526: 
                        	  1527: EX_INS      =  *
00:B71F B123            	  1528:   lda  (PCODE),Y   ; wanted length
00:B721 8545            	  1529:   sta  TEMP
00:B723 E623            	  1530:   inc  PCODE
00:B725 D002            	  1531:   bne  EX_INS3
00:B727 E624            	  1532:   inc  PCODE+1
                        	  1533: EX_INS3     =  *
00:B729 20CE95          	  1534:   jsr  GET_LINE
00:B72C AD0002          	  1535:   lda  INBUF
00:B72F C903            	  1536:   cmp  #KEY_ABORT     ; check for them aborting the run on input
00:B731 F043            	  1537:   beq  ex_input_aborted
00:B733 205FB1          	  1538:   jsr  CHK_KBD
00:B736 B0F1            	  1539:   bcs  EX_INS3      ; we turned on/off tracing etc, ignore this line
00:B738 98              	  1540:   tya               ; length of line
00:B739 18              	  1541:   clc
00:B73A 6901            	  1542:   adc  #1        ; why?
00:B73C C545            	  1543:   cmp  TEMP
00:B73E 9002            	  1544:   bcc  EX_INS1
00:B740 A545            	  1545:   lda  TEMP      ; use max allowed length rather than received length
                        	  1546: EX_INS1     =  *
00:B742 8546            	  1547:   sta  TEMP+1    ; this is the length we are copying
00:B744 20EDB1          	  1548:   jsr  GETADR    ; get address to put the line
00:B747 A003            	  1549:   ldy  #3        ; why?
00:B749 A200            	  1550:   ldx  #0
                        	  1551: ;
                        	  1552: ;  copying loop - arrays are stored downwards, so we subtract from DATA each time
                        	  1553: ;
                        	  1554: EX_INS2     =  *
00:B74B C63D            	  1555:   dec  DATA
00:B74D A53D            	  1556:   lda  DATA
00:B74F C9FF            	  1557:   cmp  #$FF
00:B751 D002            	  1558:   bne  EX_INS4
00:B753 C63E            	  1559:   dec  DATA+1
                        	  1560: EX_INS4     =  *
00:B755 BD0002          	  1561:   lda  INBUF,X
00:B758 913D            	  1562:   sta  (DATA),Y
00:B75A E8              	  1563:   inx
00:B75B C646            	  1564:   dec  TEMP+1      ; count of bytes to copy
00:B75D D0EC            	  1565:   bne  EX_INS2
00:B75F 4C9EB1          	  1566:   jmp  MAIN        ; stop now
                        	  1567:   ;
                        	  1568: 
00:B762 0A45786563757469	  1569: execution_aborted_message asciiz "\nExecution aborted\n"
00:B76A 6F6E2061626F7274
00:B772 65640A
00:B775 00
                        	  1570: 
                        	  1571: ex_input_aborted:
00:B776 A962            	  1572:   lda #<execution_aborted_message
00:B778 A2B7            	  1573:   ldx #>execution_aborted_message
00:B77A 4CE0B1          	  1574:   jmp NOTIM1
                        	  1575: ;
                        	  1576: ;
                        	  1577: EX_ADRNC    =  *
00:B77D 20EDB1          	  1578:   jsr  GETADR
                        	  1579: EX_ADRNC2   =  *
00:B780 A53D            	  1580:   lda  DATA
00:B782 18              	  1581:   clc
00:B783 6902            	  1582:   adc  #2
00:B785 853D            	  1583:   sta  DATA
00:B787 9007            	  1584:   bcc  EX_ADRN2
00:B789 E63E            	  1585:   inc  DATA+1
00:B78B B003            	  1586:   bcs  EX_ADRN2
                        	  1587: EX_ADRNN    =  *
00:B78D 20EDB1          	  1588:   jsr  GETADR
                        	  1589: EX_ADRN2    =  *
00:B790 A53D            	  1590:   lda  DATA
00:B792 8500            	  1591:   sta  REG
00:B794 A53E            	  1592:   lda  DATA+1
00:B796 8501            	  1593:   sta  REG+1
00:B798 4C9BB1          	  1594:   jmp  MAINP
                        	  1595: ;
                        	  1596: EX_ADRAN    =  *
00:B79B 204CB4          	  1597:   jsr  GETIDX
00:B79E 4C90B7          	  1598:   jmp  EX_ADRN2
                        	  1599: ;
                        	  1600: EX_ADRAC    =  *
00:B7A1 2043B4          	  1601:    jsr  GETIDC
00:B7A4 4C80B7          	  1602:    jmp  EX_ADRNC2
                        	  1603: ;
                        	  1604: ;
                        	  1605: ;
                        	  1606: 
                        	  1607: 
                        	  1608: ;
                        	  1609: ;  DIGITALREAD (pin) pin:0 to 15; pushes 0 or 1
                        	  1610: ;
                        	  1611: EX_DIGITALREAD = *
00:B7A7 2034B2          	  1612:   jsr PULTOP  ; which pin
00:B7AA 2020CB          	  1613:   jsr digitalread
00:B7AD D003            	  1614:   bne EX_DIGITALREAD_ONE
00:B7AF 4C4CB3          	  1615:   jmp FALSE
                        	  1616: EX_DIGITALREAD_ONE:
00:B7B2 4C3FB3          	  1617:   jmp TRUE    ; done
                        	  1618: 
                        	  1619: ;
                        	  1620: ;  LCDPOS (line, column)
                        	  1621: ;
                        	  1622: 
                        	  1623: EX_LCDPOS = *
00:B7B5 2034B2          	  1624:   jsr PULTOP   ; x
00:B7B8 290F            	  1625:   and #$0F     ; max 15
00:B7BA 858C            	  1626:   sta hardware_work  ; save it
00:B7BC 2034B2          	  1627:   jsr PULTOP   ; y
00:B7BF 2901            	  1628:   and #1       ; can be 0 or 1
00:B7C1 F002            	  1629:   beq EX_LCDPOS_1
00:B7C3 A940            	  1630:   lda #$40
                        	  1631: EX_LCDPOS_1:
00:B7C5 058C            	  1632:   ora hardware_work  ; or in the column
00:B7C7 0980            	  1633:   ora #$80     ; command to set the address
00:B7C9 20D7BA          	  1634:   jsr lcd_instruction
00:B7CC 4C9EB1          	  1635:   jmp MAIN
                        	  1636: 
                        	  1637: ;
                        	  1638: ;  RANDOM
                        	  1639: ;
                        	  1640: EX_RANDOM:
00:B7CF 201A92          	  1641:   jsr gen_random
00:B7D2 A509            	  1642:   lda random
00:B7D4 8500            	  1643:   sta REG
00:B7D6 A50A            	  1644:   lda random+1
00:B7D8 8501            	  1645:   sta REG+1
00:B7DA A50B            	  1646:   lda random+2
00:B7DC 8502            	  1647:   sta REGB
00:B7DE 4C9BB1          	  1648:   jmp MAINP
                        	  1649: 
                        	  1650: 
                        	  1651: ;
                        	  1652: ;  LATENCY
                        	  1653: ;
                        	  1654: EX_LATENCY:
00:B7E1 A50D            	  1655:   lda typing_latency
00:B7E3 8500            	  1656:   sta REG
00:B7E5 A50E            	  1657:   lda typing_latency+1
00:B7E7 8501            	  1658:   sta REG+1
00:B7E9 A50F            	  1659:   lda typing_latency+2
00:B7EB 8502            	  1660:   sta REGB
00:B7ED 4C9BB1          	  1661:   jmp MAINP
                        	  1662: 
                        	  1663: ; PULTOP puts stuff here thus:
                        	  1664: ;
                        	  1665: ;        LDA  REG
                        	  1666: ;        LDX  REG+1
                        	  1667: ;        LDY  REGB
                        	  1668: 
                        	  1669: EX_DELAY = *
00:B7F0 2034B2          	  1670:   JSR  PULTOP  ; get the time interval in ms
                        	  1671:   ; (Y = high-order byte, X = lo-order byte)
00:B7F3 A600            	  1672:   ldx REG
00:B7F5 A501            	  1673:   lda REG+1
00:B7F7 297F            	  1674:   and #$7F
00:B7F9 A8              	  1675:   tay
00:B7FA 201593          	  1676:   jsr delay
00:B7FD 4C9EB1          	  1677:   jmp MAIN
                        	  1678: 
                        	  1679: ;
                        	  1680: ;  RANDOMSEED
                        	  1681: ;
                        	  1682: EX_RANDOMSEED = *
00:B800 2034B2          	  1683:   JSR  PULTOP  ; get the seed
00:B803 850A            	  1684:   sta random+1
00:B805 860B            	  1685:   stx random+2
00:B807 840C            	  1686:   sty random+3
00:B809 A9FF            	  1687:   lda #$FF     ; ensure seed has some 1 bits
00:B80B 8509            	  1688:   sta random
00:B80D 4C9EB1          	  1689:   jmp MAIN
                        	  1690: 
                        	  1691: ;
                        	  1692: ;  PINMODE (pin, mode) pin:0 to 15; mode: 0=read, 1=write
                        	  1693: ;
                        	  1694: EX_PINMODE = *
00:B810 2034B2          	  1695:   jsr PULTOP  ; the mode
00:B813 AA              	  1696:   tax         ; input or output?
00:B814 DA              	  1697:   phx         ; save the mode
00:B815 2034B2          	  1698:   jsr PULTOP  ; which pin
00:B818 FA              	  1699:   plx         ; get mode back
00:B819 20C2CA          	  1700:   jsr pinmode ; pin in A, mode in X
00:B81C 4C9EB1          	  1701:   jmp MAIN    ; done
                        	  1702: 
                        	  1703: ;
                        	  1704: ;  DIGITALWRITE (pin, value) pin:0 to 15; value: 0 or 1
                        	  1705: ;
                        	  1706: EX_DIGITALWRITE = *
00:B81F 2034B2          	  1707:   jsr PULTOP  ; the value
00:B822 AA              	  1708:   tax         ;
00:B823 DA              	  1709:   phx         ; save the value
00:B824 2034B2          	  1710:   jsr PULTOP  ; which pin
00:B827 FA              	  1711:   plx         ; get mode back
00:B828 20F1CA          	  1712:   jsr digitalwrite ; pin in A, value in X
00:B82B 4C9EB1          	  1713:   jmp MAIN    ; done
                        	  1714: 
                        	  1715: EX_LIB_CALL:
00:B82E 2097B2          	  1716:   JSR  GETLIT
00:B831 6C0000          	  1717:   jmp  (REG)
                        	  1718: 
                        	  1719: ;
                        	  1720: ;  Assert (expression)
                        	  1721: ;
                        	  1722: 
                        	  1723: EX_ASSERT:
00:B834 2034B2          	  1724:   jsr PULTOP  ; the value
00:B837 A500            	  1725:   lda REG
00:B839 0501            	  1726:   ora REG+1
00:B83B 0502            	  1727:   ora REGB
00:B83D D00A            	  1728:   bne EX_ASSERT_OK
00:B83F A965            	  1729:   lda #<assertion_failed_message  ; "Assertion failed"
00:B841 A299            	  1730:   ldx #>assertion_failed_message
00:B843 202682          	  1731:   jsr print
00:B846 4C15B1          	  1732:   jmp RUNERR
                        	  1733: 
                        	  1734: EX_ASSERT_OK:
00:B849 4C9EB1          	  1735:   jmp MAIN
                        	  1736: 

Source: "gpascal.asm"
                        	   184:   .include "interrupts.inc"

Source: "interrupts.inc"
                        	     1: 
00:B84C 0A42524B20657865	     2: break_message     asciiz "\nBRK executed at address $"
00:B854 6375746564206174
00:B85C 2061646472657373
00:B864 2024
00:B866 00
00:B867 2C2041203D2024  	     3: a_equals_message  asciiz ", A = $"
00:B86E 00
00:B86F 2C2058203D2024  	     4: x_equals_message  asciiz ", X = $"
00:B876 00
00:B877 2C2059203D2024  	     5: y_equals_message  asciiz ", Y = $"
00:B87E 00
00:B87F 2C2050203D2024  	     6: p_equals_message  asciiz ", P = $"
00:B886 00
00:B887 2C2053203D2024  	     7: s_equals_message  asciiz ", S = $"
00:B88E 00
00:B88F 2C206964203D2024	     8: id_equals_message asciiz ", id = $"
00:B897 00
                        	     9: 
                        	    10: ;--------------------------------------------------
                        	    11: ;  IRQ - here on BRK interrupt
                        	    12: ;--------------------------------------------------
                        	    13: brk_executed:
00:B898 8412            	    14:   sty call_y    ; save Y - we didn't touch that
00:B89A 8614            	    15:   stx call_s    ; X still has the stack pointer in it
00:B89C FA              	    16:   plx           ; get X back
00:B89D 8611            	    17:   stx call_x
00:B89F 68              	    18:   pla           ; get A back
00:B8A0 8510            	    19:   sta call_a    ; save A
00:B8A2 68              	    20:   pla           ; get the processor flags from the stack
00:B8A3 8513            	    21:   sta call_p
00:B8A5 68              	    22:   pla           ; low-order address of BRK
00:B8A6 8515            	    23:   sta brk_address
00:B8A8 68              	    24:   pla           ; high order address of BRK
00:B8A9 8516            	    25:   sta brk_address+1
                        	    26: 
00:B8AB A2FF            	    27:   ldx  #NEW_STK
00:B8AD 9A              	    28:   txs             ; reset stack so we don't write over it
                        	    29: 
00:B8AE 58              	    30:   cli           ; allow interrupts now so we can print
                        	    31: 
                        	    32: ;
                        	    33: ;  display BRK info for the user
                        	    34: ;
                        	    35:   ;
                        	    36:   ;  subtract 2 from brk_address to get where it actually was
                        	    37:   ;
00:B8AF 38              	    38:   sec
00:B8B0 A515            	    39:   lda brk_address
00:B8B2 E902            	    40:   sbc #2
00:B8B4 8515            	    41:   sta brk_address
00:B8B6 A516            	    42:   lda brk_address+1
00:B8B8 E900            	    43:   sbc #0
00:B8BA 8516            	    44:   sta brk_address+1
00:B8BC A94C            	    45:   lda #<break_message
00:B8BE A2B8            	    46:   ldx #>break_message
00:B8C0 202682          	    47:   jsr print
00:B8C3 A516            	    48:   lda brk_address+1
00:B8C5 20DD94          	    49:   jsr PRBYTE
00:B8C8 A515            	    50:   lda brk_address
00:B8CA 20DD94          	    51:   jsr PRBYTE
                        	    52: ;
                        	    53: ;  show A, X, Y, P, S
                        	    54: ;
00:B8CD A967            	    55:   lda #<a_equals_message
00:B8CF A2B8            	    56:   ldx #>a_equals_message
00:B8D1 202682          	    57:   jsr print
00:B8D4 A510            	    58:   lda call_a
00:B8D6 20DD94          	    59:   jsr PRBYTE
00:B8D9 A96F            	    60:   lda #<x_equals_message
00:B8DB A2B8            	    61:   ldx #>x_equals_message
00:B8DD 202682          	    62:   jsr print
00:B8E0 A511            	    63:   lda call_x
00:B8E2 20DD94          	    64:   jsr PRBYTE
00:B8E5 A977            	    65:   lda #<y_equals_message
00:B8E7 A2B8            	    66:   ldx #>y_equals_message
00:B8E9 202682          	    67:   jsr print
00:B8EC A512            	    68:   lda call_y
00:B8EE 20DD94          	    69:   jsr PRBYTE
00:B8F1 A97F            	    70:   lda #<p_equals_message
00:B8F3 A2B8            	    71:   ldx #>p_equals_message
00:B8F5 202682          	    72:   jsr print
00:B8F8 A513            	    73:   lda call_p
00:B8FA 20DD94          	    74:   jsr PRBYTE
00:B8FD A987            	    75:   lda #<s_equals_message
00:B8FF A2B8            	    76:   ldx #>s_equals_message
00:B901 202682          	    77:   jsr print
00:B904 A514            	    78:   lda call_s
00:B906 20DD94          	    79:   jsr PRBYTE
00:B909 A98F            	    80:   lda #<id_equals_message
00:B90B A2B8            	    81:   ldx #>id_equals_message
00:B90D 202682          	    82:   jsr print
                        	    83: ;
                        	    84: ;  advance one byte to get the break ID (byte after the BRK)
                        	    85: ;
00:B910 E615            	    86:   inc brk_address
00:B912 D002            	    87:   bne brk_executed1
00:B914 E616            	    88:   inc brk_address+1
                        	    89: brk_executed1:
00:B916 A000            	    90:   ldy #0
00:B918 B115            	    91:   lda (brk_address),Y
00:B91A 20DD94          	    92:   jsr PRBYTE
                        	    93: ;
                        	    94: ;  put brk_address back to where we should resume from
                        	    95: ;
00:B91D E615            	    96:   inc brk_address
00:B91F D002            	    97:   bne brk_executed2
00:B921 E616            	    98:   inc brk_address+1
                        	    99: brk_executed2:
                        	   100: 
00:B923 206894          	   101:   jsr CROUT
                        	   102: ;
                        	   103: ;  display stack
                        	   104: ;
00:B926 A957            	   105:   lda #<stack_message
00:B928 A2B9            	   106:   ldx #>stack_message
00:B92A 202682          	   107:   jsr print
00:B92D A514            	   108:   lda call_s
00:B92F 18              	   109:   clc
00:B930 6906            	   110:   adc #6  ; the interrupt pushed 3 we pushed 2, plus the stack points to the first UNUSED spot
00:B932 AA              	   111:   tax
                        	   112: brk_executed3:
00:B933 BD0001          	   113:   lda $100,x
00:B936 DA              	   114:   phx
00:B937 20DD94          	   115:   jsr PRBYTE
00:B93A 20F394          	   116:   jsr PUTSP
00:B93D FA              	   117:   plx
00:B93E E8              	   118:   inx
00:B93F F00C            	   119:   beq brk_executed4
00:B941 A910            	   120:   lda #FLAG_VALID_ASSEMBLE
00:B943 25BE            	   121:   and system_flags
00:B945 F0EC            	   122:   beq brk_executed3
                        	   123: ;
                        	   124: ;  for run/assembler break, stop when stack reaches RUNNING_STACK_TOP
                        	   125: ;
00:B947 E0C1            	   126:   cpx #(RUNNING_STACK_TOP + 1)
00:B949 F002            	   127:   beq brk_executed4         ; we started here so let's stop here
00:B94B 80E6            	   128:   bra brk_executed3
                        	   129: 
                        	   130: ;
                        	   131: ;  we are done now
                        	   132: ;
                        	   133: brk_executed4:
00:B94D 206894          	   134:   jsr CROUT
00:B950 A980            	   135:   lda #FLAG_BRK_REACHED
00:B952 04BE            	   136:   tsb system_flags
00:B954 4C7282          	   137:   jmp main_prompt
                        	   138: 
00:B957 537461636B3A20  	   139: stack_message asciiz "Stack: "
00:B95E 00
                        	   140: 
00:B95F 4C98B8          	   141: brk_executedJ jmp brk_executed
                        	   142: 
                        	   143: ;--------------------------------------------------
                        	   144: ;  IRQ - here on maskable interrupt
                        	   145: ;--------------------------------------------------
                        	   146: 
                        	   147: irq:
00:B962 48              	   148:   pha       ; save A and X
00:B963 DA              	   149:   phx
00:B964 BA              	   150:   tsx       ; get stack pointer
00:B965 E0FB            	   151:   cpx #$FB  ; should be lesss than $FB (since the interrupt pushed 3 and we pushed 2)
00:B967 9006            	   152:   bcc irq1
00:B969 A21B            	   153:   ldx #27   ; ERROR: stack full
00:B96B 58              	   154:   cli       ; allow interrupts or error won't print
00:B96C 4CAB99          	   155:   jmp ERROR
                        	   156: 
                        	   157: irq1:
00:B96F BD0301          	   158:   lda $103,X    ; this will be the processor flags on the stack (3 up from where we are now)
00:B972 2910            	   159:   and #$10      ; check BRK flag
00:B974 D0E9            	   160:   bne brk_executedJ
                        	   161: ;
                        	   162: ;  here for a hardware IRQ
                        	   163: ;
00:B976 ADFD7F          	   164:   lda VIA_IFR
00:B979 2908            	   165:   and #VIA_FLAG_CB2        ; CB2 active edge
00:B97B D00A            	   166:   bne cb2_interrupt
                        	   167: 
00:B97D ADFD7F          	   168:   lda VIA_IFR
00:B980 2940            	   169:   and #VIA_FLAG_TIMER1     ; Time out of T1
00:B982 D034            	   170:   bne timer1_interrupt
                        	   171: 
                        	   172: 
                        	   173: ;
                        	   174: ;  we shouldn't get here, and if we do we will probably just loop servicing the interrupt
                        	   175: ;
                        	   176:   .if SERIAL_DEBUGGING
                        	   177: 
                        	   178:     lda #SERIAL_SPARE2_MASK
                        	   179:     tsb VIA_PORTA
                        	   180:     trb VIA_PORTA
                        	   181: 
                        	   182:   .endif  ; SERIAL_DEBUGGING
                        	   183: 
00:B984 4CE7B9          	   184:   jmp irq_done
                        	   185: 
                        	   186: ;
                        	   187: ;  here for incoming start bit
                        	   188: ;
                        	   189: cb2_interrupt:
                        	   190: 
00:B987 8DFE7F          	   191:   sta VIA_IER           ; turn off that interrupt
00:B98A 8DFD7F          	   192:   sta VIA_IFR           ; indicate we noticed it
                        	   193: 
00:B98D DA              	   194:   phx
00:B98E 5A              	   195:   phy
                        	   196: 
00:B98F A208            	   197:   ldx #8              ; count of bits
00:B991 A030            	   198:   ldy #SERIAL_DELAY1  ; delay interval for first bit (allow for code above) TODO - probably needs to be less now
                        	   199: serial_in_loop:
                        	   200: ;
                        	   201: ; wait for bit time to be up
                        	   202: ;
00:B993 88              	   203:   dey
00:B994 D0FD            	   204:   bne serial_in_loop
                        	   205: 
                        	   206:   .if SERIAL_DEBUGGING
                        	   207:     lda #SERIAL_DEBUG1_MASK     ; toggle debug flag (2 cycles)
                        	   208:     tsb VIA_PORTA               ; paint the fence: up (6 cycles)
                        	   209:     trb VIA_PORTA               ; down (6 cycles)
                        	   210:                                 ; look eye! always look eye
                        	   211:   .else
00:B996 EA              	   212:     NOP    ; take the same time so the timing isn't thrown out
00:B997 EA              	   213:     NOP    ; 2 cycles each
00:B998 EA              	   214:     NOP
00:B999 EA              	   215:     NOP
00:B99A EA              	   216:     NOP
00:B99B EA              	   217:     NOP
00:B99C EA              	   218:     NOP    ; total of 14 cycles
                        	   219:   .endif  ; SERIAL_DEBUGGING
                        	   220: 
00:B99D ADF17F          	   221:   lda VIA_PORTA
00:B9A0 6A              	   222:   ror A                 ; put incoming bit into carry
00:B9A1 668A            	   223:   ror serial_in_byte    ; shift one bit in
00:B9A3 A023            	   224:   ldy #SERIAL_DELAY2    ; delay interval for remaining bits
00:B9A5 CA              	   225:   dex
00:B9A6 D0EB            	   226:   bne serial_in_loop
                        	   227: 
00:B9A8 7A              	   228:   ply
00:B9A9 FA              	   229:   plx
                        	   230: ;
                        	   231: ;  re-enable interrupts on the falling edge
                        	   232: ;
00:B9AA A988            	   233:   lda #VIA_FLAG_ENABLE | VIA_FLAG_CB2
00:B9AC 8DFE7F          	   234:   sta VIA_IER
00:B9AF 8DFD7F          	   235:   sta VIA_IFR   ; indicate we know about previous falling edges
                        	   236: 
                        	   237: ;
                        	   238: ;  move to place that we know it will be noticed
                        	   239: ;
00:B9B2 A58A            	   240:   lda serial_in_byte
00:B9B4 858B            	   241:   sta serial_in_byte_received
                        	   242: 
00:B9B6 802F            	   243:   bra irq_done
                        	   244: 
                        	   245: ;
                        	   246: ;  here for time to send another outgoing bit
                        	   247: ;
                        	   248: timer1_interrupt :
                        	   249: 
00:B9B8 8DFD7F          	   250:   sta VIA_IFR           ; indicate we noticed it
00:B9BB A589            	   251:   lda serial_out_bit    ; are we in fact sending a byte?
00:B9BD F028            	   252:   beq irq_done          ; no, just exit
                        	   253: 
                        	   254:   .if SERIAL_DEBUGGING
                        	   255: 
                        	   256:   lda #SERIAL_DEBUG2_MASK     ; toggle debug flag (2 cycles)
                        	   257:   tsb VIA_PORTA               ; wash on   (6 cycles)
                        	   258:   trb VIA_PORTA               ; wash off  (6 cycles)
                        	   259:                               ; now, sand the floor
                        	   260:  .else
00:B9BF EA              	   261:      NOP    ; take the same time so the timing isn't thrown out
00:B9C0 EA              	   262:      NOP    ; 2 cycles each
00:B9C1 EA              	   263:      NOP
00:B9C2 EA              	   264:      NOP
00:B9C3 EA              	   265:      NOP
00:B9C4 EA              	   266:      NOP
00:B9C5 EA              	   267:      NOP    ; total of 14 cycles
                        	   268:   .endif  ; SERIAL_DEBUGGING
                        	   269: 
00:B9C6 6688            	   270:   ror serial_out_byte+1  ; we don't care about the high-order bit
00:B9C8 6687            	   271:   ror serial_out_byte    ; get the low-order bit into Carry
00:B9CA 9007            	   272:   bcc write_zero
00:B9CC A902            	   273:   lda #SERIAL_OUT_MASK   ; (send a 1 bit)
00:B9CE 0DF17F          	   274:   ora VIA_PORTA
00:B9D1 8005            	   275:   bra serial_send_count_bits
                        	   276: 
                        	   277: write_zero:
00:B9D3 A9FD            	   278:   lda #~SERIAL_OUT_MASK  ; (send a 0 bit)
00:B9D5 2DF17F          	   279:   and VIA_PORTA
                        	   280: 
                        	   281: serial_send_count_bits:
00:B9D8 8DF17F          	   282:   sta VIA_PORTA          ; output this bit
00:B9DB C689            	   283:   dec serial_out_bit     ; remember bit count for later
00:B9DD D008            	   284:   bne irq_done
                        	   285: 
                        	   286: ; here when all bits have been sent
                        	   287: ; disable the timer as we don't need it any more
                        	   288: ; and this will be a flag that we can send another byte
                        	   289: 
00:B9DF A940            	   290:   lda #VIA_FLAG_DISABLE | VIA_FLAG_TIMER1  ; cancel interrupt on T1 timeout
00:B9E1 8DFE7F          	   291:   sta VIA_IER
00:B9E4 ADF47F          	   292:   lda VIA_T1C_L     ; clear interrupt flag
                        	   293: 
                        	   294: irq_done:
00:B9E7 FA              	   295:   plx   ; restore X
00:B9E8 68              	   296:   pla   ; restore A
00:B9E9 40              	   297:   rti
                        	   298: 

Source: "gpascal.asm"
                        	   185:   .include "lcd.inc"

Source: "lcd.inc"
                        	     1:   .if !EMULATOR
                        	     2:   .if LCD_SUPPORT
                        	     3: 
                        	     4: ;
                        	     5: ;  LCD stuff
                        	     6: ;
                        	     7: 
                        	     8: lcd_initialise:
                        	     9: ;
                        	    10: ;  LCD initialise
                        	    11: ;
                        	    12: 
00:B9EA ADF37F          	    13:   lda VIA_DDRA
00:B9ED 09E0            	    14:   ora #(LCD_RW|LCD_RS|LCD_E)    ; set appropriate pins on Port A to output
00:B9EF 8DF37F          	    15:   sta VIA_DDRA
                        	    16: 
                        	    17:   ; see HD44780U documentation: "Initializing by Instruction" (page 46)
00:B9F2 206BBA          	    18:   jsr lcd_prepare_to_write_instruction
00:B9F5 A930            	    19:   lda #$30
00:B9F7 20CBBA          	    20:   jsr lcd_write_instruction_nibble
                        	    21:   ; wait > 4.1 ms
00:B9FA A214            	    22:   ldx #20
00:B9FC A000            	    23:   ldy #0
00:B9FE 201593          	    24:   jsr delay      ; 20 ms delay (in case of faster board clock speeds)
00:BA01 20CBBA          	    25:   jsr lcd_write_instruction_nibble
00:BA04 200B93          	    26:   jsr delay_1ms  ; do it 4 times in case of faster board clock speeds
00:BA07 200B93          	    27:   jsr delay_1ms
00:BA0A 200B93          	    28:   jsr delay_1ms
00:BA0D 200B93          	    29:   jsr delay_1ms
00:BA10 20CBBA          	    30:   jsr lcd_write_instruction_nibble
00:BA13 200B93          	    31:   jsr delay_1ms  ; do it 4 times in case of faster board clock speeds
00:BA16 200B93          	    32:   jsr delay_1ms
00:BA19 200B93          	    33:   jsr delay_1ms
00:BA1C 200B93          	    34:   jsr delay_1ms
00:BA1F A920            	    35:   lda #$20    ; switch to 4-bit mode
00:BA21 20CBBA          	    36:   jsr lcd_write_instruction_nibble
00:BA24 200B93          	    37:   jsr delay_1ms  ; do it 4 times in case of faster board clock speeds
00:BA27 200B93          	    38:   jsr delay_1ms
00:BA2A 200B93          	    39:   jsr delay_1ms
00:BA2D 200B93          	    40:   jsr delay_1ms
                        	    41: ;
                        	    42: ;  now we can switch to sending 8-bits in two nibbles
                        	    43: ;
00:BA30 A928            	    44:   lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
00:BA32 20D7BA          	    45:   jsr lcd_instruction
00:BA35 A90C            	    46:   lda #%00001100 ; DCB: Display on; cursor off; blink off
00:BA37 20D7BA          	    47:   jsr lcd_instruction
00:BA3A A906            	    48:   lda #%00000110 ; Increment and shift cursor; don't shift display
00:BA3C 20D7BA          	    49:   jsr lcd_instruction
00:BA3F 202BBB          	    50:   jsr lcd_clear_display
00:BA42 60              	    51:   rts
                        	    52: 
                        	    53: lcd_prepare_to_read_register:
00:BA43 ADF17F          	    54:   lda VIA_PORTA
00:BA46 0940            	    55:   ora #LCD_RW             ; set RW bit  (ie. enable reading)
00:BA48 295F            	    56:   and #<(~(LCD_RS|LCD_E)) ; Clear RS/E bits
00:BA4A 8DF17F          	    57:   sta VIA_PORTA
00:BA4D ADF27F          	    58:   lda VIA_DDRB
00:BA50 290F            	    59:   and #$0F
00:BA52 8DF27F          	    60:   sta VIA_DDRB            ; we are reading from DDRB
00:BA55 60              	    61:   rts
                        	    62: 
                        	    63: lcd_prepare_to_write_data:
00:BA56 48              	    64:   pha
00:BA57 ADF17F          	    65:   lda VIA_PORTA
00:BA5A 293F            	    66:   and #<(~(LCD_RW|LCD_E))  ; clear RW and E (enable writing)
00:BA5C 0920            	    67:   ora #LCD_RS              ; setting this means we write a character
00:BA5E 8DF17F          	    68:   sta VIA_PORTA
00:BA61 ADF27F          	    69:   lda VIA_DDRB
00:BA64 09F0            	    70:   ora #$F0      ; Set high-order pins on port B to output
00:BA66 8DF27F          	    71:   sta VIA_DDRB
00:BA69 68              	    72:   pla
00:BA6A 60              	    73:   rts
                        	    74: 
                        	    75: lcd_prepare_to_write_instruction:
00:BA6B 48              	    76:   pha
00:BA6C ADF17F          	    77:   lda VIA_PORTA
00:BA6F 291F            	    78:   and #<(~(LCD_RW|LCD_RS|LCD_E))  ; clear RW, RS and E (enable writing)
00:BA71 8DF17F          	    79:   sta VIA_PORTA
00:BA74 ADF27F          	    80:   lda VIA_DDRB
00:BA77 09F0            	    81:   ora #$F0      ; Set high-order pins on port B to output
00:BA79 8DF27F          	    82:   sta VIA_DDRB
00:BA7C 68              	    83:   pla
00:BA7D 60              	    84:   rts
                        	    85: 
                        	    86: lcd_set_enable:
00:BA7E ADF17F          	    87:   lda VIA_PORTA
00:BA81 0980            	    88:   ora #LCD_E
00:BA83 8DF17F          	    89:   sta VIA_PORTA   ; Set enable (E)
00:BA86 60              	    90:   rts
                        	    91: 
                        	    92: lcd_clear_enable:
00:BA87 ADF17F          	    93:   lda VIA_PORTA
00:BA8A 297F            	    94:   and #<(~LCD_E)  ; Clear enable (E)
00:BA8C 8DF17F          	    95:   sta VIA_PORTA
00:BA8F 60              	    96:   rts
                        	    97: 
                        	    98: lcd_read_instruction_nibble:
00:BA90 207EBA          	    99:   jsr lcd_set_enable
00:BA93 ADF07F          	   100:   lda VIA_PORTB   ; read the data on port B
00:BA96 48              	   101:   pha             ; save the data
00:BA97 2087BA          	   102:   jsr lcd_clear_enable
00:BA9A 68              	   103:   pla             ; get the data back
00:BA9B 60              	   104:   rts
                        	   105: 
                        	   106: ;
                        	   107: ; wait until LCD is not busy
                        	   108: ;
                        	   109: lcd_wait:
00:BA9C DA              	   110:   phx
00:BA9D 5A              	   111:   phy
00:BA9E 48              	   112:   pha
00:BA9F 2043BA          	   113:   jsr lcd_prepare_to_read_register
00:BAA2 A200            	   114:   ldx #0
                        	   115: lcdbusy:
                        	   116: ;
                        	   117: ;  timeout after 256 iterations of this loop so we don't hang
                        	   118: ;  if there is no LCD or it doesn't respond
                        	   119: ;
00:BAA4 CA              	   120:   dex
00:BAA5 F00C            	   121:   beq lcd_wait_timeout
00:BAA7 2090BA          	   122:   jsr lcd_read_instruction_nibble
00:BAAA 2980            	   123:   and #$80        ; get busy flag
00:BAAC A8              	   124:   tay             ; save busy status
00:BAAD 2090BA          	   125:   jsr lcd_read_instruction_nibble   ; do second nibble
00:BAB0 98              	   126:   tya             ; get busy status back
00:BAB1 D0F1            	   127:   bne lcdbusy     ; if busy go back
                        	   128: ;
                        	   129: ;  here when not busy any more
                        	   130: ;
                        	   131: lcd_wait_timeout:
00:BAB3 68              	   132:   pla
00:BAB4 7A              	   133:   ply
00:BAB5 FA              	   134:   plx
00:BAB6 60              	   135:   rts
                        	   136: 
                        	   137: ;
                        	   138: ;  Find the current LCD (cursor) address - useful for knowing
                        	   139: ;  if we exceed the limit of line 1
                        	   140: ;
                        	   141: lcd_get_address:
00:BAB7 2043BA          	   142:   jsr lcd_prepare_to_read_register
00:BABA 2090BA          	   143:   jsr lcd_read_instruction_nibble
00:BABD 2970            	   144:   and #$70        ; ignore busy bit, mask out other junk
00:BABF 8586            	   145:   sta lcd_work
00:BAC1 2090BA          	   146:   jsr lcd_read_instruction_nibble
00:BAC4 4A              	   147:   lsr A   ; shift this lot into low-order bits
00:BAC5 4A              	   148:   lsr A
00:BAC6 4A              	   149:   lsr A
00:BAC7 4A              	   150:   lsr A
00:BAC8 0586            	   151:   ora lcd_work    ; get the high-order bits back
00:BACA 60              	   152:   rts
                        	   153: 
                        	   154: lcd_write_instruction_nibble:
00:BACB 48              	   155:   pha
00:BACC 8DF07F          	   156:   sta VIA_PORTB         ; set up the data
00:BACF 207EBA          	   157:   jsr lcd_set_enable    ; toggle enable
00:BAD2 2087BA          	   158:   jsr lcd_clear_enable
00:BAD5 68              	   159:   pla
00:BAD6 60              	   160:   rts
                        	   161: 
                        	   162: ;
                        	   163: ;  send an instruction to the LCD
                        	   164: ;
                        	   165: lcd_instruction:
00:BAD7 209CBA          	   166:   jsr lcd_wait
00:BADA 206BBA          	   167:   jsr lcd_prepare_to_write_instruction
00:BADD 20CBBA          	   168:   jsr lcd_write_instruction_nibble
00:BAE0 48              	   169:   pha
00:BAE1 0A              	   170:   asl a   ; move the low-order bits into the high-order bits
00:BAE2 0A              	   171:   asl a   ; because the high-order 4 bits are the active ones
00:BAE3 0A              	   172:   asl a
00:BAE4 0A              	   173:   asl a
00:BAE5 20CBBA          	   174:   jsr lcd_write_instruction_nibble
00:BAE8 68              	   175:   pla
00:BAE9 60              	   176:   rts
                        	   177: 
                        	   178: lcd_data_nibble:
00:BAEA 48              	   179:   pha
00:BAEB 2056BA          	   180:   jsr lcd_prepare_to_write_data
00:BAEE 8DF07F          	   181:   sta VIA_PORTB
00:BAF1 207EBA          	   182:   jsr lcd_set_enable
00:BAF4 2087BA          	   183:   jsr lcd_clear_enable
00:BAF7 68              	   184:   pla
00:BAF8 60              	   185:   rts
                        	   186: 
                        	   187: ;
                        	   188: ;  print a character to the LCD
                        	   189: ;
                        	   190: lcd_print_char:
00:BAF9 209CBA          	   191:   jsr lcd_wait  ; wait for previous write to finish
00:BAFC C90A            	   192:   cmp #NL
00:BAFE D004            	   193:   bne lcd_print_not_newline ; newline jumps to 2nd line
00:BB00 2033BB          	   194:   jsr lcd_second_line       ; go to second line
00:BB03 60              	   195:   rts                       ; and don't print the newline :)
                        	   196: 
                        	   197: lcd_print_not_newline:
00:BB04 48              	   198:   pha                   ; save the character we want to print
00:BB05 20B7BA          	   199:   jsr lcd_get_address
00:BB08 C910            	   200:   cmp #16         ; 16 characters on the first line
00:BB0A 900E            	   201:   bcc lcd_print_char_ok ; not there yet
00:BB0C D005            	   202:   bne lcd_print_char_on_2nd_line  ; not < 16 and not == 16, must be > 16
                        	   203:   ; we have exactly 16, so drop down to address 64
00:BB0E 2033BB          	   204:   jsr lcd_second_line  ; at char 16 go to 2nd line (address 64)
00:BB11 8007            	   205:   bra lcd_print_char_ok
                        	   206: 
                        	   207: lcd_print_char_on_2nd_line:
00:BB13 C950            	   208:   cmp #80                  ; more than 16 characters on in 2nd line? (64 + 16)
00:BB15 9003            	   209:   bcc lcd_print_char_ok    ; nah
00:BB17 202BBB          	   210:   jsr lcd_clear_display    ; yes, clear display then and start again
                        	   211: lcd_print_char_ok:
                        	   212: lcd_print_char_newline:
00:BB1A 2056BA          	   213:   jsr lcd_prepare_to_write_data
00:BB1D 68              	   214:   pla                      ; get the character back
00:BB1E 20EABA          	   215:   jsr lcd_data_nibble
00:BB21 48              	   216:   pha
00:BB22 0A              	   217:   asl a     ; now send the low-order bits
00:BB23 0A              	   218:   asl a
00:BB24 0A              	   219:   asl a
00:BB25 0A              	   220:   asl a
00:BB26 20EABA          	   221:   jsr lcd_data_nibble
00:BB29 68              	   222:   pla
00:BB2A 60              	   223:   rts
                        	   224: 
                        	   225: lcd_clear_display:
00:BB2B 48              	   226:   pha
00:BB2C A901            	   227:   lda #%00000001 ; Clear display
00:BB2E 20D7BA          	   228:   jsr lcd_instruction
00:BB31 68              	   229:   pla
00:BB32 60              	   230:   rts
                        	   231: 
                        	   232: lcd_second_line:
00:BB33 48              	   233:   pha
00:BB34 A9C0            	   234:   lda #$C0 ; set output address to 0x40 (set DDRAM address)
00:BB36 20D7BA          	   235:   jsr lcd_instruction
00:BB39 68              	   236:   pla
00:BB3A 60              	   237:   rts
                        	   238: 
                        	   239: lcd_home:
00:BB3B 48              	   240:   pha
00:BB3C A980            	   241:   lda #$80 ; set output address to 0 (set DDRAM address)
00:BB3E 20D7BA          	   242:   jsr lcd_instruction
00:BB41 68              	   243:   pla
00:BB42 60              	   244:   rts
                        	   245: 
                        	   246: 
                        	   247: ;
                        	   248: ;  print null-terminated message on LCD, message in A (lo) and X (hi)
                        	   249: ;  returns the length of the message in Y
                        	   250: ;
                        	   251: lcd_print_message:
00:BB43 8503            	   252:   sta REG2
00:BB45 8604            	   253:   stx REG2+1
00:BB47 A000            	   254:   ldy #0
00:BB49 202BBB          	   255:   jsr lcd_clear_display
                        	   256: lcd_print:
00:BB4C B103            	   257:   lda (REG2),y
00:BB4E F006            	   258:   beq lcd_print_done
00:BB50 20F9BA          	   259:   jsr lcd_print_char
00:BB53 C8              	   260:   iny
00:BB54 80F6            	   261:   bra lcd_print
                        	   262: 
00:BB56 60              	   263: lcd_print_done rts
                        	   264: 
                        	   265:   .else ; LCD_SUPPORT
                        	   266: 
                        	   267: lcd_print_char :
                        	   268: lcd_clear_display :
                        	   269: lcd_second_line:
                        	   270: lcd_print_message:
                        	   271: lcd_instruction:
                        	   272: lcd_get_address:
                        	   273: lcd_home:
                        	   274: lcd_wait:
                        	   275:     ldx #50     ; No LCD
                        	   276:     jmp ERROR
                        	   277: 
                        	   278: 
                        	   279:   .endif  ; (no) LCD_SUPPORT
                        	   280: 
                        	   281:   .endif  ; not emulator
                        	   282: 

Source: "gpascal.asm"
                        	   186:   .include "symbols.inc"

Source: "symbols.inc"
                        	     1: ;***********************************************
                        	     2: ; SYMBOL TABLE STUFF: Offsets from the start of a particular symbol
                        	     3: ; Stored as a linked list, where you search backwards so the more local one is found first
                        	     4: ;***********************************************
                        	     5: 
                        	     6: SYMPRV   =  0         ; address of previous symbol (for working backwards through symbols)
                        	     7: SYMLVL   =  2         ; nested level (eg. entering a procedure/function increments the level,
                        	     8:                       ;                   and leaving it decrements the level)
                        	     9:                       ; - used to detect duplicate symbols at the same level
                        	    10: SYMTYP   =  3         ; Symbol type: C = constant, V = variable, Y = function return value
                        	    11:                       ;              P = procedure, F = function, A = array
                        	    12:                       ;              p = library procedure, f = library function
                        	    13:                       ;  See defines below.
                        	    14: SYMDSP   =  4         ; if the symbol is a constant, what the value is (3 bytes)
                        	    15:                       ; if the symbol is a variable, array or function return then this is the offset (2 bytes)
                        	    16: SYMARG   =  6         ; if the symbol is a procedure/function, count of arguments (can be zero)
                        	    17: SYMSUB   =  6         ; MAX SUBSCRIPT+1 - for arrays, so this is the actual array length
                        	    18: SYMDAT   =  8         ; data type: 0 = integer, 1 = char
                        	    19: SYMLEN   =  9         ; length of the name, der
                        	    20: SYMNAM   =  10        ; name of symbol for SYMLEN characters, stored in upper-case
                        	    21: 
                        	    22: ;
                        	    23: ; Symbol types
                        	    24: ;
                        	    25: 
                        	    26: SYMBOL_CONSTANT          = 'C'
                        	    27: SYMBOL_VARIABLE          = 'V'
                        	    28: SYMBOL_FUNCTION_RETURN   = 'Y'
                        	    29: SYMBOL_PROCEDURE         = 'P'
                        	    30: SYMBOL_FUNCTION          = 'F'
                        	    31: SYMBOL_LIBRARY_PROCEDURE = 'Q'  ; library procedures and functions are implemented in assembler
                        	    32: SYMBOL_LIBRARY_FUNCTION  = 'R'
                        	    33: SYMBOL_ARRAY             = 'A'
                        	    34: 
                        	    35: 
                        	    36: 
                        	    37: ;
                        	    38: ;***********************************************
                        	    39: ;SEARCH SYMBOL TABLE - returns Z if not found (BEQ <not found>)
                        	    40: ;***********************************************
                        	    41: SEARCH   =  *
00:BB57 A532            	    42:          lda  ENDSYM+1    ; get the end of the symbol table
00:BB59 8541            	    43:          sta  SYMITM+1    ; make it the current symbol
00:BB5B A531            	    44:          lda  ENDSYM
00:BB5D 800B            	    45:          bra  SEA1
                        	    46: 
                        	    47: SEA_NEXT =  *
00:BB5F A000            	    48:          ldy  #SYMPRV
00:BB61 B140            	    49:          lda  (SYMITM),Y
00:BB63 AA              	    50:          tax
00:BB64 C8              	    51:          iny
00:BB65 B140            	    52:          lda  (SYMITM),Y
00:BB67 8541            	    53:          sta  SYMITM+1   ; previous link
00:BB69 8A              	    54:          txa
                        	    55: ;
                        	    56: ;  go to the previous symbol table item
                        	    57: ;
                        	    58: SEA1     =  *
00:BB6A 8540            	    59:          sta  SYMITM
00:BB6C C52F            	    60:          cmp  STARTSYM
00:BB6E D007            	    61:          bne  SEA2
00:BB70 A541            	    62:          lda  SYMITM+1
00:BB72 C530            	    63:          cmp  STARTSYM+1
00:BB74 D001            	    64:          bne  SEA2       ; more to go
00:BB76 60              	    65:          rts             ; finished if we are back at the start of the symbol table
                        	    66: 
                        	    67: SEA2     =  *
00:BB77 A009            	    68:          ldy  #SYMLEN
00:BB79 B140            	    69:          lda  (SYMITM),Y  ; get this item's length
00:BB7B C592            	    70:          cmp  token_length      ; compare to the token legnth we got
00:BB7D D0E0            	    71:          bne  SEA_NEXT    ; wrong length - try another
00:BB7F A540            	    72:          lda  SYMITM      ; back to this symbol's start address
00:BB81 18              	    73:          clc
00:BB82 690A            	    74:          adc  #SYMNAM     ; add the offset of the name to it
00:BB84 8503            	    75:          sta  DEST
00:BB86 A541            	    76:          lda  SYMITM+1
00:BB88 6900            	    77:          adc  #0
00:BB8A 8504            	    78:          sta  DEST+1      ; the memory location of the symbol name is in DEST
00:BB8C A590            	    79:          lda  token_address      ; now put the token's address into SRCE
00:BB8E 8500            	    80:          sta  SRCE
00:BB90 A591            	    81:          lda  token_address+1
00:BB92 8501            	    82:          sta  SRCE+1
00:BB94 A492            	    83:          ldy  token_length
00:BB96 206D94          	    84:          jsr  COMSTL      ; compare SRCE to DEST
00:BB99 D0C4            	    85:          bne  SEA_NEXT    ; not that one - try another
00:BB9B 2013BD          	    86:          jsr  GET_DAT     ; get the symbol's data type into DATTYP
00:BB9E A002            	    87:          ldy  #SYMLVL     ; and level - why isn't this a function, huh?
00:BBA0 B140            	    88:          lda  (SYMITM),Y
00:BBA2 AA              	    89:          tax              ; level into X
00:BBA3 A003            	    90:          ldy  #SYMTYP
00:BBA5 B140            	    91:          lda  (SYMITM),Y  ; get type of symbol
00:BBA7 8536            	    92:          sta  BSAVE       ; symbol type -> BSAVE
00:BBA9 C943            	    93:          cmp  #SYMBOL_CONSTANT       ; constant?
00:BBAB D013            	    94:          bne  SEA4        ; nah
                        	    95: ;
                        	    96: ;  symbol is a constant
                        	    97: ;
00:BBAD A004            	    98:          ldy  #SYMDSP     ; if a constant, this is the value
00:BBAF B140            	    99:          lda  (SYMITM),Y
00:BBB1 8594            	   100:          sta  token_value
00:BBB3 C8              	   101:          iny
00:BBB4 B140            	   102:          lda  (SYMITM),Y
00:BBB6 8595            	   103:          sta  token_value+1
00:BBB8 C8              	   104:          iny
00:BBB9 B140            	   105:          lda  (SYMITM),Y
00:BBBB 8596            	   106:          sta  token_value+2     ; token_value (3 bytes) now has the value in it
00:BBBD 4CCBBB          	   107:          jmp  SEA3
                        	   108: ;
                        	   109: ;  symbol is not a constant
                        	   110: ;
                        	   111: SEA4     =  *                           ; not constant
00:BBC0 C956            	   112:          cmp  #SYMBOL_VARIABLE          ; variable?
00:BBC2 F004            	   113:          beq  SEA5                      ; yes
00:BBC4 C959            	   114:          cmp  #SYMBOL_FUNCTION_RETURN   ; argument?
00:BBC6 D003            	   115:          bne  SEA3                      ; no - must be SYMBOL_ARRAY, SYMBOL_PROCEDURE or SYMBOL_FUNCTION
                        	   116: ;
                        	   117: ;  here for variables and function return values
                        	   118: ;
                        	   119: SEA5     =  *
00:BBC8 206EBD          	   120:          jsr  GET_OFF    ; get the variable's offset
                        	   121: SEA3     =  *
00:BBCB A536            	   122:          lda  BSAVE      ; A now has the symbol type in it
                        	   123: 
                        	   124: ; Types are: SYMBOL_CONSTANT, SYMBOL_VARIABLE, SYMBOL_FUNCTION_RETURN,
                        	   125: ;            SYMBOL_PROCEDURE, SYMBOL_FUNCTION, SYMBOL_ARRAY
                        	   126: 
00:BBCD 60              	   127:          rts             ; SHOULD SET 'NEQ' FLAG
                        	   128: 
                        	   129: 
00:BBCE A225            	   130: SYM_FULL ldx  #37     ; ERROR: Symbol table full
00:BBD0 4CAB99          	   131:          jmp  ERROR
                        	   132: 
                        	   133: ;***********************************************
                        	   134: ; ADD SYMBOL TO SYMBOL TABLE - going downwards until we hit the P-codes
                        	   135: ;  A = the symbol type
                        	   136: ;***********************************************
                        	   137: ADDSYM   =  *
00:BBD3 48              	   138:          pha            ; save the symbol type
                        	   139: 
00:BBD4 A631            	   140:          ldx  ENDSYM    ; get the end of the symbol table
00:BBD6 8640            	   141:          stx  SYMITM    ; make it the current symbol
00:BBD8 A632            	   142:          ldx  ENDSYM+1
00:BBDA 8641            	   143:          stx  SYMITM+1
                        	   144: ;
                        	   145: ;  since we are going downwards, we need to subtract the fixed size of a symbol table item,
                        	   146: ;  plus the symbol length, from SYMITM
                        	   147: ;
00:BBDC 38              	   148:          sec            ; first subtract the token length
00:BBDD A540            	   149:          lda  SYMITM
00:BBDF E592            	   150:          sbc  token_length
00:BBE1 8540            	   151:          sta  SYMITM
00:BBE3 8503            	   152:          sta  DEST      ; put this spot into DEST for copying the name
00:BBE5 A541            	   153:          lda  SYMITM+1
00:BBE7 E900            	   154:          sbc  #0
00:BBE9 8541            	   155:          sta  SYMITM+1
00:BBEB 8504            	   156:          sta  DEST+1
00:BBED 38              	   157:          sec            ; and now the fixed size
00:BBEE A540            	   158:          lda  SYMITM
00:BBF0 E90A            	   159:          sbc  #SYMNAM
00:BBF2 8540            	   160:          sta  SYMITM
00:BBF4 A541            	   161:          lda  SYMITM+1
00:BBF6 E900            	   162:          sbc  #0
00:BBF8 8541            	   163:          sta  SYMITM+1
                        	   164: ;
                        	   165: ;  check we haven't hit the P-codes
                        	   166: ;
00:BBFA A902            	   167:          lda  #FLAG_ASSEMBLING
00:BBFC 25BE            	   168:          and  system_flags
00:BBFE D008            	   169:          bne  ADDSYM_NOT_FULL
00:BC00 A524            	   170:          lda  PCODE+1
00:BC02 C541            	   171:          cmp  SYMITM+1
00:BC04 9002            	   172:          bcc  ADDSYM_NOT_FULL   ; less than - ok
00:BC06 80C6            	   173:          bra  SYM_FULL          ; greater than or equal (high-order byte) - uh oh
                        	   174: ;
                        	   175: ;  ah, for assembling it is a pain to know whether the symbol table has overflowed, so I'm going
                        	   176: ;  to ignore that as a problem for now. Checking against PCODE will not work if the assembler output
                        	   177: ;  has been relocated to above the symbol table, and the only other thing we can compare against is
                        	   178: ;  the end of the source which we don't necessarily know.
                        	   179: ;
                        	   180: ;
                        	   181: ;  now put the previous start in as the link for the previous one for this item
                        	   182: ;
                        	   183: ADDSYM_NOT_FULL:
00:BC08 A000            	   184:          ldy  #SYMPRV
00:BC0A A531            	   185:          lda  ENDSYM
00:BC0C 9140            	   186:          sta  (SYMITM),Y
00:BC0E A532            	   187:          lda  ENDSYM+1
00:BC10 C8              	   188:          iny
00:BC11 9140            	   189:          sta  (SYMITM),Y
                        	   190: ;
                        	   191: ;  SYMITM now becomes the start of the symbol table
                        	   192: ;
00:BC13 A540            	   193:          lda  SYMITM
00:BC15 8531            	   194:          sta  ENDSYM
00:BC17 A541            	   195:          lda  SYMITM+1
00:BC19 8532            	   196:          sta  ENDSYM+1
                        	   197: ;
                        	   198: ;  OK, we should be done linking it in.
                        	   199: ;  SYMITM now points to this (as yet unfilled-in) item and the first two bytes now point to
                        	   200: ;   where the symbols previously ended
                        	   201: ;
00:BC1B 68              	   202:          pla                ; get symbol type back
00:BC1C A003            	   203:          ldy  #SYMTYP
00:BC1E 9140            	   204:          sta  (SYMITM),Y    ; store the type which was in A
00:BC20 A002            	   205:          ldy  #SYMLVL
00:BC22 48              	   206:          pha                ; save symbol type again
00:BC23 A522            	   207:          lda  LEVEL
00:BC25 9140            	   208:          sta  (SYMITM),Y    ; store the level
00:BC27 A009            	   209:          ldy  #SYMLEN
00:BC29 A592            	   210:          lda  token_length
00:BC2B 9140            	   211:          sta  (SYMITM),Y    ; store the token length
00:BC2D A8              	   212:          tay
00:BC2E 88              	   213:          dey                ; make zero-relative
                        	   214: ADD1     =  *               ; copy the name across, in upper case
00:BC2F B190            	   215:          lda  (token_address),Y
00:BC31 200492          	   216:          jsr  MAKE_UPPER
00:BC34 9103            	   217:          sta  (DEST),Y
00:BC36 88              	   218:          dey
00:BC37 10F6            	   219:          bpl  ADD1      ; keep copying
                        	   220: 
                        	   221: ;
                        	   222: ;  we have added name to the table, now do the rest
                        	   223: ;
00:BC39 68              	   224:          pla                     ; get symbol type back again
00:BC3A AA              	   225:          tax                     ; symbol type
00:BC3B C943            	   226:          cmp  #SYMBOL_CONSTANT   ; CONSTANT??
00:BC3D D013            	   227:          bne  ADD4
                        	   228: ;
                        	   229: ;  constant
                        	   230: ;
00:BC3F A004            	   231:          ldy  #SYMDSP            ; put this token's value into SYMDSP offset from SYMITM (for 3 bytes)
00:BC41 A594            	   232:          lda  token_value
00:BC43 9140            	   233:          sta  (SYMITM),Y
00:BC45 C8              	   234:          iny
00:BC46 A595            	   235:          lda  token_value+1
00:BC48 9140            	   236:          sta  (SYMITM),Y
00:BC4A C8              	   237:          iny
00:BC4B A596            	   238:          lda  token_value+2
00:BC4D 9140            	   239:          sta  (SYMITM),Y
00:BC4F 4C6EBC          	   240:          jmp  ADD9
                        	   241: ;
                        	   242: ;  not a constant
                        	   243: ;
                        	   244: ADD4     =  *
00:BC52 A008            	   245:          ldy  #SYMDAT
00:BC54 A901            	   246:          lda  #1            ; char type (?)
00:BC56 9140            	   247:          sta  (SYMITM),Y
00:BC58 8A              	   248:          txa                ; get symbol type back
00:BC59 C956            	   249:          cmp  #SYMBOL_VARIABLE
00:BC5B D011            	   250:          bne  ADD9
                        	   251: ;
                        	   252: ;  variable type
                        	   253: ;
00:BC5D A005            	   254:          ldy  #SYMDSP+1
00:BC5F A521            	   255:          lda  FRAME+1       ; save frame
00:BC61 9140            	   256:          sta  (SYMITM),Y
00:BC63 88              	   257:          dey
00:BC64 A520            	   258:          lda  FRAME
00:BC66 9140            	   259:          sta  (SYMITM),Y
00:BC68 E620            	   260:          inc  FRAME         ; add 1 to frame number
00:BC6A D002            	   261:          bne  ADD9
00:BC6C E621            	   262:          inc  FRAME+1
                        	   263: ADD9     =  *
00:BC6E 60              	   264:          rts
                        	   265: ;
                        	   266: 
                        	   267: ;
                        	   268: LOOKUP   =  *
00:BC6F 2057BB          	   269:          JSR  SEARCH
00:BC72 D005            	   270:          BNE  LOOK1
00:BC74 A20B            	   271:          LDX  #11     ; ERROR: Undeclared Identifier
00:BC76 4CAB99          	   272:          jmp  ERROR
00:BC79 60              	   273: LOOK1    RTS
                        	   274: ;
00:BC7A 2057BB          	   275: CHKDUP   JSR  SEARCH
00:BC7D F00A            	   276:          BEQ  DUP9
00:BC7F 8A              	   277:          TXA
00:BC80 C522            	   278:          CMP  LEVEL
00:BC82 D005            	   279:          BNE  DUP9
00:BC84 A226            	   280:          LDX  #38   ; ERROR: Duplicate Identifier
00:BC86 4CAB99          	   281:          jmp  ERROR
00:BC89 60              	   282: DUP9     RTS
                        	   283: 

Source: "gpascal.asm"
                        	   187:   .include "compiler.inc"

Source: "compiler.inc"
                        	     1: 
                        	     2: ;***********************************************
                        	     3: ; COMPILER
                        	     4: ;***********************************************
                        	     5: 
                        	     6: 
                        	     7: ;
                        	     8: ;
                        	     9: ;  Compiler directives:
                        	    10: ;
                        	    11: ;    {%L} - list during compile (source code and current P-code address)
                        	    12: ;    {%P} - show generated P-codes during compile - only works during compile (not syntax check)
                        	    13: ;    {%N} - stop listing during compile (cancels %L and %P)
                        	    14: ;    {%S <address>} - relocate symbol table to <address> - must be done before defining symbols
                        	    15: ;                     also generates an opcode to relocate the runtime stack
                        	    16: ;
                        	    17: ;   The % must directly follow the start of the comment.
                        	    18: ;
                        	    19: ;
                        	    20: ;  Comments:  (* some comment *) or { some comment }
                        	    21: ;             "(*" / "{", and "*)" / "}" are treated interchangeably so (* some comment } would work
                        	    22: ;  Comments cannot be nested.
                        	    23: ;
                        	    24: ;  Tips:
                        	    25: ;
                        	    26: ;   Procedures and functions must be declared at the START of a block, not in the middle.
                        	    27: ;   The order is important. CONST first, then VAR, then procedure/function declarations, then BEGIN
                        	    28: 
                        	    29: ;    eg.
                        	    30: ;
                        	    31: ;    const limit = 10;   { <-- this is the start of a block: CONST before VAR }
                        	    32: ;    var k: integer;     { we declare variables and constants here - BEFORE "begin" }
                        	    33: ;    line : array [100] of char;  { array }
                        	    34: ;    function foo;       { and functions and procedures - this is the start of another block}
                        	    35: ;    begin
                        	    36: ;      foo := 42         { assign to function return value }
                        	    37: ;    end;                { end of the function block - note semicolon }
                        	    38: ;    begin               { end of declarations - now we have the block statements }
                        	    39: ;     for k := 1 to limit do
                        	    40: ;       writeln ("square of ", k, " is ", k * k);
                        	    41: ;     write (foo)        { call function }
                        	    42: ;    end.
                        	    43: ;
                        	    44: ;    ARGUMENTS: If the procedure or function does not take arguments OMIT THE BRACKETS.
                        	    45: ;               Likewise, omit the brackets if you call the procedure or function (unlike C)
                        	    46: ;
                        	    47: ;    Semicolons SEPARATE statements, they don't terminate them.
                        	    48: ;
                        	    49: ; Warnings: * Functions which do not assign to the function return value give undefined results.
                        	    50: ;           * Multiplication discards high-order bits if result is too large.
                        	    51: ;           * Divide remainder is always positive (ie. MOD always gives a positive result, regardless of operand signs)
                        	    52: ;           * Function arguments are always integers and always return an integer.
                        	    53: ;           * One to three-byte strings can be used as integer constants
                        	    54: ;               eg. a := "abc"; write (a);   --> Result: 6513249 (ie. 0x636261 or "abc")
                        	    55: ;               The first character is the low-order byte in the number, explaining the above results.
                        	    56: ;           * Strings can start with single or double quotes, whatever starts the string must terminate it.
                        	    57: ;           * String literals can have the same character that started the string embedded, to do that put it twice.
                        	    58: ;             eg. 'Nick''s cat'
                        	    59: ;           * Array access it not range-checked.
                        	    60: ;           * Arrays start at zero. The array size declared is the maximum index (unlike C) so foo: array [10] of integ
                        	    61: ;               would declare an array of 11 elements, numbered from foo [0] to foo [10]
                        	    62: ;           * Maximum arguments to a procedure/function is 85 (255 / 3) due to internal coding
                        	    63: ;
                        	    64: 
                        	    65: 
                        	    66: ;
00:BC8A A2FF            	    67: COMPIL   LDX  #NEW_STK
00:BC8C 9A              	    68:   txs    ; set stack back to 0xFF
                        	    69: 
00:BC8D 201A94          	    70:   jsr  INIT
00:BC90 A901            	    71:   lda  #FLAG_COMPILING
00:BC92 04BE            	    72:   tsb  system_flags
00:BC94 20FBC8          	    73:   jsr  add_pascal_library_functions
00:BC97 2081D1          	    74:   jsr  pas_get_token
00:BC9A 207EC5          	    75:   jsr  BLOCK
00:BC9D A92E            	    76:   lda  #'.'
00:BC9F A209            	    77:   ldx  #9        ; ERROR: . expected
00:BCA1 20E5D1          	    78:   jsr  CHKTKN
00:BCA4 A900            	    79:   lda  #0
00:BCA6 A213            	    80:   ldx  #19       ; ERROR: Incorrect Symbol
00:BCA8 20D5D1          	    81:   jsr  GETCHK
00:BCAB 206894          	    82:   jsr  CROUT
00:BCAE A91F            	    83:   lda  #<pcodes_ended_message  ; P-codes ended at
00:BCB0 A295            	    84:   ldx  #>pcodes_ended_message
00:BCB2 202682          	    85:   jsr  print
00:BCB5 A524            	    86:   lda  PCODE+1
00:BCB7 8544            	    87:   sta  END_PCD+1
00:BCB9 20DD94          	    88:   jsr  PRBYTE
00:BCBC A523            	    89:   lda  PCODE
00:BCBE 8543            	    90:   sta  END_PCD
00:BCC0 209295          	    91:   jsr  PRBYTECR
00:BCC3 20238F          	    92:   jsr  show_symbol_table_end
00:BCC6 20488F          	    93:   jsr  show_source_end
                        	    94: 
00:BCC9 A932            	    95:   lda  #<compile_finished_message  ; <C>ompile finished: No Errors
00:BCCB A295            	    96:   ldx  #>compile_finished_message
00:BCCD 202682          	    97:   jsr  print
00:BCD0 A642            	    98:   ldx  SYNTAX
00:BCD2 D004            	    99:   bne  END_CMP
00:BCD4 A908            	   100:   lda  #FLAG_VALID_COMPILE
00:BCD6 04BE            	   101:   tsb  system_flags
                        	   102: END_CMP  =  *
00:BCD8 4C7282          	   103:   jmp  main_prompt
                        	   104: ;
                        	   105: 
                        	   106: ;
                        	   107: CHKLHP   =  *
00:BCDB A928            	   108:          LDA  #'('
00:BCDD A21F            	   109:          LDX  #31     ; ERROR: ( expected
00:BCDF 4CD5D1          	   110:          JMP  GETCHK
                        	   111: ;
                        	   112: CHKRHP   =  *
00:BCE2 A929            	   113:          LDA  #')'
00:BCE4 A216            	   114:          LDX  #22     ; ERROR: ) expected
00:BCE6 20E5D1          	   115:          JSR  CHKTKN
00:BCE9 4C81D1          	   116:          JMP  pas_get_token
                        	   117: ;
                        	   118: GETSUB   =  *
00:BCEC 20F5BC          	   119:          JSR  CHKLHB
00:BCEF 2006C0          	   120:          JSR  EXPRES
00:BCF2 4CFFBC          	   121:          JMP  CHKRHB
                        	   122: ;
                        	   123: CHKLHB   =  *
00:BCF5 A95B            	   124:          LDA  #'['
00:BCF7 A221            	   125:          LDX  #33     ; ERROR: [ expected
00:BCF9 20D5D1          	   126:          JSR  GETCHK
00:BCFC 4C81D1          	   127:          JMP  pas_get_token
                        	   128: ;
                        	   129: CHKRHB   =  *
00:BCFF A95D            	   130:          LDA  #']'
00:BD01 A222            	   131:          LDX  #34     ; ERROR: ] expected
00:BD03 20E5D1          	   132:          JSR  CHKTKN
00:BD06 4C81D1          	   133:          JMP  pas_get_token
                        	   134: ;
                        	   135: GET_LEV  =  *
00:BD09 A522            	   136:          LDA  LEVEL
00:BD0B A002            	   137:          LDY  #SYMLVL
00:BD0D 38              	   138:          SEC
00:BD0E F140            	   139:          SBC  (SYMITM),Y
00:BD10 8527            	   140:          STA  DISPL
00:BD12 60              	   141:          RTS
                        	   142: ;
                        	   143: GET_DAT  =  *
00:BD13 A008            	   144:          LDY  #SYMDAT
00:BD15 B140            	   145:          LDA  (SYMITM),Y
00:BD17 854A            	   146:          STA  DATTYP
00:BD19 60              	   147:          RTS
                        	   148: ;
                        	   149: 
                        	   150: 
                        	   151: 
                        	   152: ; CONSTANT DEC
                        	   153: ;
                        	   154: CONDEC   =  *
00:BD1A A949            	   155:          LDA  #TOKEN_IDENTIFIER
00:BD1C A204            	   156:          LDX  #4        ; ERROR: Identifier expected
00:BD1E 20E5D1          	   157:          JSR  CHKTKN
00:BD21 200995          	   158:          JSR  TKNWRK
00:BD24 A592            	   159:          LDA  token_length
00:BD26 48              	   160:          PHA
00:BD27 A93D            	   161:          LDA  #'='
00:BD29 A203            	   162:          LDX  #3        ; ERROR: = expected
00:BD2B 20D5D1          	   163:          JSR  GETCHK
00:BD2E 2081D1          	   164:          JSR  pas_get_token
00:BD31 200DBE          	   165:          JSR  CONST
00:BD34 201495          	   166:          JSR  WRKTKN
00:BD37 68              	   167:          PLA
00:BD38 8592            	   168:          STA  token_length
00:BD3A 207ABC          	   169:          JSR  CHKDUP
00:BD3D A943            	   170:          LDA  #SYMBOL_CONSTANT
00:BD3F 20D3BB          	   171:          JSR  ADDSYM
00:BD42 4C81D1          	   172:          JMP  pas_get_token
                        	   173: ;
                        	   174: ;
                        	   175: ;--- SYMITM --> WORK
                        	   176: ;
                        	   177: SYMWRK   =  *
00:BD45 48              	   178:          PHA
00:BD46 A540            	   179:          LDA  SYMITM
00:BD48 8537            	   180:          STA  WORK
00:BD4A A541            	   181:          LDA  SYMITM+1
00:BD4C 8538            	   182:          STA  WORK+1
00:BD4E 68              	   183:          PLA
00:BD4F 60              	   184:          RTS
                        	   185: ;
                        	   186: ;--- WORK --> SYMITM
                        	   187: ;
                        	   188: WRKSYM   =  *
00:BD50 48              	   189:          PHA
00:BD51 A537            	   190:          LDA  WORK
00:BD53 8540            	   191:          STA  SYMITM
00:BD55 A538            	   192:          LDA  WORK+1
00:BD57 8541            	   193:          STA  SYMITM+1
00:BD59 68              	   194:          PLA
00:BD5A 60              	   195:          RTS
                        	   196: ;
                        	   197: ; PUSH PCODE ONTO STACK
                        	   198: ;
                        	   199: PSHPCODE =  *
00:BD5B 8536            	   200:          STA  BSAVE
00:BD5D 68              	   201:          PLA
00:BD5E AA              	   202:          TAX
00:BD5F 68              	   203:          PLA
00:BD60 A8              	   204:          TAY
00:BD61 A524            	   205:          LDA  PCODE+1
00:BD63 48              	   206:          PHA
00:BD64 A523            	   207:          LDA  PCODE
00:BD66 48              	   208:          PHA
00:BD67 98              	   209:          TYA
00:BD68 48              	   210:          PHA
00:BD69 8A              	   211:          TXA
00:BD6A 48              	   212:          PHA
00:BD6B A536            	   213:          LDA  BSAVE
00:BD6D 60              	   214:          RTS
                        	   215: ;
                        	   216: ;  Get the offset of this current symbol into OFFSET
                        	   217: ;
                        	   218: GET_OFF  =  *
00:BD6E 48              	   219:          PHA
00:BD6F A004            	   220:          LDY  #SYMDSP
00:BD71 B140            	   221:          LDA  (SYMITM),Y
00:BD73 8529            	   222:          STA  OFFSET
00:BD75 C8              	   223:          INY
00:BD76 B140            	   224:          LDA  (SYMITM),Y
00:BD78 852A            	   225:          STA  OFFSET+1
00:BD7A A003            	   226:          LDY  #SYMTYP
00:BD7C B140            	   227:          LDA  (SYMITM),Y
00:BD7E C956            	   228:          CMP  #SYMBOL_VARIABLE
00:BD80 F008            	   229:          BEQ  GETO_1
00:BD82 C941            	   230:          CMP  #SYMBOL_ARRAY
00:BD84 F004            	   231:          BEQ  GETO_1
00:BD86 C959            	   232:          CMP  #SYMBOL_FUNCTION_RETURN
00:BD88 D00D            	   233:          BNE  GETO_2
                        	   234: ;
                        	   235: ;  here if the symbol is a variable, array or function return value
                        	   236: ;   subtract the offset from -3
                        	   237: ;
                        	   238: GETO_1   =  *
00:BD8A 38              	   239:          SEC
00:BD8B A9FD            	   240:          LDA  #$FD
00:BD8D E529            	   241:          SBC  OFFSET
00:BD8F 8529            	   242:          STA  OFFSET
00:BD91 A9FF            	   243:          LDA  #$FF
00:BD93 E52A            	   244:          SBC  OFFSET+1
00:BD95 852A            	   245:          STA  OFFSET+1
                        	   246: GETO_2   =  *
00:BD97 68              	   247:          PLA
00:BD98 60              	   248:          RTS
                        	   249: ;
                        	   250: GETEXPR  =  *
00:BD99 2081D1          	   251:          JSR  pas_get_token
00:BD9C 4C06C0          	   252:          JMP  EXPRES
                        	   253: ;
                        	   254: ;
                        	   255: PCD_WRKD =  *
00:BD9F 48              	   256:          PHA
00:BDA0 A523            	   257:          LDA  PCODE
00:BDA2 8533            	   258:          STA  WORKD
00:BDA4 A524            	   259:          LDA  PCODE+1
00:BDA6 8534            	   260:          STA  WORKD+1
00:BDA8 68              	   261:          PLA
00:BDA9 60              	   262:          RTS
                        	   263: ;
                        	   264: WRK_OPND =  *
00:BDAA 48              	   265:          PHA
00:BDAB A537            	   266:          LDA  WORK
00:BDAD 852B            	   267:          STA  OPND
00:BDAF A538            	   268:          LDA  WORK+1
00:BDB1 852C            	   269:          STA  OPND+1
00:BDB3 68              	   270:          PLA
00:BDB4 60              	   271:          RTS
                        	   272: ;
                        	   273: WRKD_WRK =  *
00:BDB5 48              	   274:          PHA
00:BDB6 A533            	   275:          LDA  WORKD
00:BDB8 8537            	   276:          STA  WORK
00:BDBA A534            	   277:          LDA  WORKD+1
00:BDBC 8538            	   278:          STA  WORK+1
00:BDBE 68              	   279:          PLA
00:BDBF 60              	   280:          RTS
                        	   281: ;
                        	   282: WRK_WRKD =  *
00:BDC0 48              	   283:          PHA
00:BDC1 A537            	   284:          LDA  WORK
00:BDC3 8533            	   285:          STA  WORKD
00:BDC5 A538            	   286:          LDA  WORK+1
00:BDC7 8534            	   287:          STA  WORKD+1
00:BDC9 68              	   288:          PLA
00:BDCA 60              	   289:          RTS
                        	   290: ;
                        	   291: GET_COMM =  *
00:BDCB A92C            	   292:          LDA  #','
00:BDCD A220            	   293:          LDX  #32     ; ERROR: , expected
00:BDCF 4CE5D1          	   294:          JMP  CHKTKN
                        	   295: ;
                        	   296: GET_ITEM =  *
00:BDD2 20CBBD          	   297:          JSR  GET_COMM   ; check for comma
00:BDD5 4C99BD          	   298:          JMP  GETEXPR
                        	   299: ;
                        	   300: ;  Load (push) a constant (ie. a literal number)
                        	   301: ;
                        	   302: ;  Numbers in the range 0 to 0x7F are turned into a "low literal" which is a P-code
                        	   303: ;  with the 0x80 bit set. These then become a single-byte P-code which simply pushes
                        	   304: ;  that number onto the stack, thus saving having to have a 4-byte P-code being PCODE_LIT
                        	   305: ;  followed by a 3-byte number, 2 bytes of which would be zero.
                        	   306: ;
                        	   307: VAL_MOVE =  *
00:BDD8 48              	   308:          PHA
00:BDD9 18              	   309:          CLC
00:BDDA A594            	   310:          LDA  token_value
00:BDDC 8527            	   311:          STA  DISPL   ; why?
00:BDDE 1001            	   312:          BPL  VAL_1   ; is it 0x00 to 0x7F?
00:BDE0 38              	   313:          SEC          ; no, set carry bit
                        	   314: VAL_1    =  *
00:BDE1 A595            	   315:          LDA  token_value+1
00:BDE3 F001            	   316:          BEQ  VAL_2   ; is second byte 0x00?
00:BDE5 38              	   317:          SEC          ; no, set carry bit
                        	   318: VAL_2    =  *
00:BDE6 8529            	   319:          STA  OFFSET
00:BDE8 A596            	   320:          LDA  token_value+2
00:BDEA 852A            	   321:          STA  OFFSET+1
00:BDEC F001            	   322:          BEQ  VAL_3   ; is third byte 0x00?
00:BDEE 38              	   323:          SEC          ; no, set carry bit
                        	   324: VAL_3    =  *
00:BDEF 9007            	   325:          BCC  VAL_5   ; did we ever set the carry bit?
00:BDF1 A900            	   326:          LDA  #PCODE_LIT  ; yes, so just generate a "load literal"
00:BDF3 20BEC9          	   327:          JSR  GENADR
00:BDF6 68              	   328:          PLA
00:BDF7 60              	   329:          RTS
                        	   330: VAL_5    =  *
00:BDF8 A594            	   331:          LDA  token_value   ; get the low-order byte back
00:BDFA 0980            	   332:          ORA  #$80    ; set the 0x80 bit as a flag
00:BDFC 20A5C9          	   333:          JSR  GENNOP  ; output one P-code
00:BDFF 68              	   334:          PLA
00:BE00 60              	   335:          RTS
                        	   336: ;
                        	   337: ;
                        	   338: CHK_STAK =  *
00:BE01 BA              	   339:          TSX
00:BE02 8A              	   340:          TXA
00:BE03 C920            	   341:          CMP  #MAX_STK
00:BE05 9001            	   342:          BCC  STK_FULL
00:BE07 60              	   343:          RTS
                        	   344: STK_FULL =  *
00:BE08 A21B            	   345: STK_ERR  LDX  #27     ; ERROR: Stack full
00:BE0A 4CAB99          	   346:          jmp  ERROR      ; FULL
                        	   347: ;
                        	   348: ;
                        	   349: ; CONST get the value into token_value
                        	   350: ;
                        	   351: CONST    =  *
00:BE0D A593            	   352:          LDA  token_type
00:BE0F C94E            	   353:          CMP  #TOKEN_NUMBER
00:BE11 F01F            	   354:          BEQ  CONST9
00:BE13 C949            	   355:          CMP  #TOKEN_IDENTIFIER
00:BE15 F00D            	   356:          BEQ  CONST1
00:BE17 C922            	   357:          CMP  #TOKEN_STRING
00:BE19 D00E            	   358:          BNE  CONST3
00:BE1B A692            	   359:          LDX  token_length
00:BE1D E004            	   360:          CPX  #4
00:BE1F 9011            	   361:          BCC  CONST9
00:BE21 4CB5BF          	   362:          JMP  FACERR1    ; STRING TOO BIG
00:BE24 2057BB          	   363: CONST1   JSR  SEARCH
00:BE27 D005            	   364:          BNE  CONST2
                        	   365: CONST3   =  *
00:BE29 A202            	   366:          LDX  #2        ; ERROR: Constant expected
00:BE2B 4CAB99          	   367:          jmp  ERROR
00:BE2E C943            	   368: CONST2   CMP  #SYMBOL_CONSTANT
00:BE30 D0F7            	   369:          BNE  CONST3
00:BE32 60              	   370: CONST9   RTS
                        	   371: ;
                        	   372: ; VARIABLE DEC
                        	   373: ;
00:BE33 A949            	   374: VARDEC   LDA  #TOKEN_IDENTIFIER
00:BE35 A204            	   375:          LDX  #4      ; ERROR: Identifier expected
00:BE37 20E5D1          	   376:          JSR  CHKTKN
00:BE3A 207ABC          	   377:          JSR  CHKDUP
00:BE3D A956            	   378:          LDA  #SYMBOL_VARIABLE
00:BE3F 20D3BB          	   379:          JSR  ADDSYM
00:BE42 4C81D1          	   380:          JMP  pas_get_token
                        	   381: ;
                        	   382: ; SIMPLE EXPRESSION
                        	   383: ;
                        	   384: SIMEXP   =  *
00:BE45 A593            	   385:          LDA  token_type
00:BE47 C92B            	   386:          CMP  #'+'
00:BE49 F004            	   387:          BEQ  SIM1
00:BE4B C92D            	   388:          CMP  #'-'
00:BE4D D048            	   389:          BNE  SIM2
00:BE4F 48              	   390: SIM1     PHA
00:BE50 2081D1          	   391:          JSR  pas_get_token
00:BE53 20B7BE          	   392:          JSR  TERM
00:BE56 68              	   393:          PLA
00:BE57 C92D            	   394:          CMP  #'-'
00:BE59 D005            	   395:          BNE  SIM3
00:BE5B A902            	   396:          LDA  #PCODE_NEG      ; NEG       Negate (sp)
00:BE5D 20A5C9          	   397:          JSR  GENNOP     ; NEGATE
00:BE60 A593            	   398: SIM3     LDA  token_type
00:BE62 C92B            	   399:          CMP  #'+'
00:BE64 F00D            	   400:          BEQ  SIM4
00:BE66 C92D            	   401:          CMP  #'-'
00:BE68 F009            	   402:          BEQ  SIM4
00:BE6A C98A            	   403:          CMP  #TOKEN_OR       ; OR
00:BE6C F005            	   404:          BEQ  SIM4
00:BE6E C9A4            	   405:          CMP  #TOKEN_XOR      ; XOR
00:BE70 F001            	   406:          BEQ  SIM4
00:BE72 60              	   407:          RTS
00:BE73 48              	   408: SIM4     PHA
00:BE74 2081D1          	   409:          JSR  pas_get_token
00:BE77 20B7BE          	   410:          JSR  TERM
00:BE7A 68              	   411:          PLA
00:BE7B C92D            	   412:          CMP  #'-'
00:BE7D F010            	   413:          BEQ  SIM5
00:BE7F C92B            	   414:          CMP  #'+'
00:BE81 F010            	   415:          BEQ  SIM6
00:BE83 C9A4            	   416:          CMP  #TOKEN_XOR          ; XOR
00:BE85 F016            	   417:          BEQ  SIM8
00:BE87 A91A            	   418:          LDA  #PCODE_ORR          ; ORR       OR  (sp - 1) | (sp)
00:BE89 20A5C9          	   419: SIM7     JSR  GENNOP
00:BE8C 4C60BE          	   420:          JMP  SIM3
00:BE8F A906            	   421: SIM5     LDA  #PCODE_SUB          ; MINUS
00:BE91 D0F6            	   422:          BNE  SIM7
00:BE93 A904            	   423: SIM6     LDA  #PCODE_ADD          ; PLUS
00:BE95 D0F2            	   424:          BNE  SIM7
00:BE97 20B7BE          	   425: SIM2     JSR  TERM
00:BE9A 4C60BE          	   426:          JMP  SIM3
00:BE9D A93A            	   427: SIM8     LDA  #PCODE_XOR         ; XOR
00:BE9F D0E8            	   428:          BNE  SIM7
                        	   429: ;
                        	   430: ; TERM
                        	   431: ;
00:BEA1 2A              	   432: TERMT1   ASC    '*'
00:BEA2 C4BE            	   433:          word   TERM1
00:BEA4 8B              	   434:          DFB    TOKEN_DIV    ; div
00:BEA5 C4BE            	   435:          word   TERM1
00:BEA7 2F              	   436:          ASC    '/'
00:BEA8 C4BE            	   437:          word   TERM1
00:BEAA 8D              	   438:          DFB    TOKEN_AND    ; and
00:BEAB C4BE            	   439:          word   TERM1
00:BEAD 8C              	   440:          DFB    TOKEN_MOD    ; mod
00:BEAE C4BE            	   441:          word   TERM1
00:BEB0 8E              	   442:          DFB    TOKEN_SHL    ; shl
00:BEB1 C4BE            	   443:          word   TERM1
00:BEB3 8F              	   444:          DFB    TOKEN_SHR    ; shr
00:BEB4 C4BE            	   445:          word   TERM1
00:BEB6 00              	   446:          DFB    0
                        	   447: ;
00:BEB7 2005BF          	   448: TERM     JSR  FACTOR
00:BEBA A2A1            	   449: TERM2    LDX  #<TERMT1
00:BEBC A0BE            	   450:          LDY  #>TERMT1
00:BEBE A593            	   451:          LDA  token_type
00:BEC0 20D291          	   452:          JSR  TKNJMP
00:BEC3 60              	   453:          RTS
                        	   454: ;
00:BEC4 48              	   455: TERM1    PHA
00:BEC5 2081D1          	   456:          JSR  pas_get_token
00:BEC8 2005BF          	   457:          JSR  FACTOR
00:BECB 68              	   458:          PLA
00:BECC A2EF            	   459:          LDX  #<TERMT3
00:BECE A0BE            	   460:          LDY  #>TERMT3
00:BED0 20D291          	   461:          JSR  TKNJMP
                        	   462: ;
00:BED3 A90A            	   463: TERM4    LDA  #PCODE_DIV       ; Divide (sp - 1) / (sp)
00:BED5 20A5C9          	   464: TERM3    JSR  GENNOP
00:BED8 4CBABE          	   465:          JMP  TERM2
00:BEDB A91B            	   466: TERM5    LDA  #PCODE_AND        ; AND
00:BEDD D0F6            	   467:          BNE  TERM3
00:BEDF A90B            	   468: TERM6    LDA  #PCODE_MOD        ; MOD
00:BEE1 D0F2            	   469:          BNE  TERM3
00:BEE3 A922            	   470: TERM7    LDA  #PCODE_SHL       ; Shift left (sp) bits
00:BEE5 D0EE            	   471:          BNE  TERM3
00:BEE7 A924            	   472: TERM8    LDA  #PCODE_SHR       ; Shift right (sp) bits
00:BEE9 D0EA            	   473:          BNE  TERM3
00:BEEB A908            	   474: TERM9    LDA  #PCODE_MUL        ; Multiply (sp) * (sp - 1)
00:BEED D0E6            	   475:          BNE  TERM3
                        	   476: ;
00:BEEF 8B              	   477: TERMT3   DFB    TOKEN_DIV     ; div
00:BEF0 D3BE            	   478:          word   TERM4
00:BEF2 2F              	   479:          ASC    '/'
00:BEF3 D3BE            	   480:          word   TERM4
00:BEF5 8D              	   481:          DFB    TOKEN_AND     ; and
00:BEF6 DBBE            	   482:          word   TERM5
00:BEF8 8C              	   483:          DFB    TOKEN_MOD     ; mod
00:BEF9 DFBE            	   484:          word   TERM6
00:BEFB 8E              	   485:          DFB    TOKEN_SHL     ; shl
00:BEFC E3BE            	   486:          word   TERM7
00:BEFE 8F              	   487:          DFB    TOKEN_SHR     ; shr
00:BEFF E7BE            	   488:          word   TERM8
00:BF01 2A              	   489:          ASC    '*'
00:BF02 EBBE            	   490:          word   TERM9
00:BF04 00              	   491:          DFB  0
                        	   492: ;
                        	   493: ; FACTOR
                        	   494: ;
00:BF05 2001BE          	   495: FACTOR   JSR  CHK_STAK
00:BF08 A593            	   496:          LDA  token_type
00:BF0A A2ED            	   497:          LDX  #<FACTB1
00:BF0C A0BF            	   498:          LDY  #>FACTB1
00:BF0E 20D291          	   499:          JSR  TKNJMP
00:BF11 A217            	   500:          LDX  #23     ; ERROR: Illegal factor
00:BF13 4CAB99          	   501:          jmp  ERROR
                        	   502: ;
00:BF16 206FBC          	   503: IDENT    JSR  LOOKUP
00:BF19 C950            	   504: IDENT1   CMP  #SYMBOL_PROCEDURE
00:BF1B F004            	   505:          beq  IDENT1A
00:BF1D C951            	   506:          CMP  #SYMBOL_LIBRARY_PROCEDURE
00:BF1F D005            	   507:          BNE  IDENT2
                        	   508: IDENT1A:
00:BF21 A215            	   509:          LDX  #21     ; ERROR: Use of procedure Identifier in expression
00:BF23 4CAB99          	   510:          jmp  ERROR
00:BF26 C959            	   511: IDENT2   CMP  #SYMBOL_FUNCTION_RETURN
00:BF28 D015            	   512:          BNE  IDENT2A
00:BF2A A000            	   513:          LDY  #SYMPRV      ; this symbol is actually the function return value symbol
00:BF2C B140            	   514:          LDA  (SYMITM),Y   ; so go to the previous symbol which will be the function
00:BF2E AA              	   515:          TAX               ; declaration symbol with the address of the function to be called
00:BF2F C8              	   516:          INY
00:BF30 B140            	   517:          LDA  (SYMITM),Y
00:BF32 8541            	   518:          STA  SYMITM+1
00:BF34 8A              	   519:          TXA
00:BF35 8540            	   520:          STA  SYMITM
00:BF37 A980            	   521:          lda  #$80       ; push 0 onto the stack which will be the default function return value
00:BF39 20A5C9          	   522:          jsr  GENNOP     ; when the function returns this will be left on the top of the stack
00:BF3C 4C86C2          	   523:          JMP  FNCPRC     ; with the function's assigned value in it (or zero if nothing assigned);
                        	   524: 
00:BF3F C952            	   525: IDENT2A  CMP #SYMBOL_LIBRARY_FUNCTION
00:BF41 D003            	   526:          bne IDENT3
00:BF43 4C55C9          	   527:          jmp  library_function_call
                        	   528: 
00:BF46 C941            	   529: IDENT3   CMP  #SYMBOL_ARRAY
00:BF48 F030            	   530:          BEQ  IDENT4
00:BF4A C943            	   531:          CMP  #SYMBOL_CONSTANT
00:BF4C D00E            	   532:          BNE  IDENT5
00:BF4E 20D8BD          	   533:          JSR  VAL_MOVE
00:BF51 4C6FBF          	   534:          JMP  IDENT7
                        	   535: ;
                        	   536: ;   Here for address of integer variable
                        	   537: ;
00:BF54 A90C            	   538: FACAD1   LDA  #PCODE_ADRNN
00:BF56 205EBF          	   539:          JSR  IDENT5_A
00:BF59 4CE2BC          	   540:          JMP  CHKRHP
                        	   541: ;
00:BF5C A92C            	   542: IDENT5   LDA  #PCODE_LOD   ; load integer onto stack
00:BF5E 48              	   543: IDENT5_A PHA
                        	   544: ;
00:BF5F 8636            	   545:          STX  BSAVE
00:BF61 A522            	   546:          LDA  LEVEL
00:BF63 38              	   547:          SEC
00:BF64 E536            	   548:          SBC  BSAVE
00:BF66 8527            	   549:          STA  DISPL
00:BF68 68              	   550:          PLA
00:BF69 18              	   551: IDENT6   CLC
00:BF6A 654A            	   552:          ADC  DATTYP
00:BF6C 20BEC9          	   553:          JSR  GENADR
00:BF6F 4C81D1          	   554: IDENT7   JMP  pas_get_token
                        	   555: ;
00:BF72 A90E            	   556: FACAD2   LDA  #PCODE_ADRAN  ; address of integer array
00:BF74 207CBF          	   557:          JSR  IDENT4_A
00:BF77 4CE2BC          	   558:          JMP  CHKRHP
                        	   559: ;
                        	   560: ;    Here for load indexed integer
                        	   561: ;
00:BF7A A930            	   562: IDENT4   LDA  #PCODE_LDI         ; Load integer indexed
00:BF7C 48              	   563: IDENT4_A PHA
                        	   564: ;
00:BF7D 2045BD          	   565:          JSR  SYMWRK
00:BF80 209F94          	   566:          JSR  PSHWRK
00:BF83 20ECBC          	   567:          JSR  GETSUB
00:BF86 20B294          	   568:          JSR  PULWRK
00:BF89 2050BD          	   569:          JSR  WRKSYM
00:BF8C 2013BD          	   570:          JSR  GET_DAT
00:BF8F 2009BD          	   571:          JSR  GET_LEV
00:BF92 206EBD          	   572:          JSR  GET_OFF
00:BF95 68              	   573:          PLA
00:BF96 18              	   574:          CLC
00:BF97 654A            	   575:          ADC  DATTYP
00:BF99 4CBEC9          	   576:          JMP  GENADR
                        	   577: ;
                        	   578: ; ADDRESS (IDENTIFIER)
                        	   579: ;
                        	   580: ;
                        	   581: FACADR   =  *
00:BF9C 20DBBC          	   582:          JSR  CHKLHP
00:BF9F 20EAD1          	   583:          JSR  GET_LOOK
00:BFA2 C956            	   584:          CMP  #SYMBOL_VARIABLE
00:BFA4 F0AE            	   585:          BEQ  FACAD1
00:BFA6 C941            	   586:          CMP  #SYMBOL_ARRAY
00:BFA8 F0C8            	   587:          BEQ  FACAD2
00:BFAA A217            	   588:          LDX  #23     ; ERROR: Illegal factor
00:BFAC 4CAB99          	   589:          jmp  ERROR
                        	   590: ;
                        	   591: ;
00:BFAF A592            	   592: FACSTR   LDA  token_length
00:BFB1 C904            	   593:          CMP  #4
00:BFB3 9005            	   594:          BCC  FACNUM    ; BLT
00:BFB5 A21D            	   595: FACERR1  LDX  #29        ; ERROR: string literal too big
00:BFB7 4CAB99          	   596:          jmp  ERROR
                        	   597: FACNUM   =  *
00:BFBA 20D8BD          	   598:          JSR  VAL_MOVE
00:BFBD 4C6FBF          	   599:          JMP  IDENT7
                        	   600: ;
00:BFC0 2099BD          	   601: PAREN    JSR  GETEXPR
00:BFC3 4CE2BC          	   602:          JMP  CHKRHP
                        	   603: ;
00:BFC6 A900            	   604: FACMEM   LDA  #0          ; add zero below to get PCODE_LDA
00:BFC8 854A            	   605:          STA  DATTYP
00:BFCA F004            	   606:          BEQ  FACM2
00:BFCC A901            	   607: FACMMC   LDA  #1          ; add one below to get PCODE_LDAC
00:BFCE 854A            	   608:          STA  DATTYP
00:BFD0 A54A            	   609: FACM2    LDA  DATTYP
00:BFD2 48              	   610:          PHA
00:BFD3 20ECBC          	   611:          JSR  GETSUB
00:BFD6 68              	   612:          PLA
00:BFD7 18              	   613:          CLC
00:BFD8 692E            	   614:          ADC  #PCODE_LDA    ; Load absolute address integer or PCODE_LDAC if we added 1
00:BFDA D008            	   615:          BNE  GENNOP1
                        	   616: ;
00:BFDC 2081D1          	   617: FACNOT   JSR  pas_get_token
00:BFDF 2005BF          	   618:          JSR  FACTOR
00:BFE2 A920            	   619:          LDA  #PCODE_EOR     ; Not (sp) (logical negate)
00:BFE4 4CA5C9          	   620: GENNOP1  JMP  GENNOP
                        	   621: ;
00:BFE7 20A5C9          	   622: FACRND1  JSR  GENNOP
00:BFEA 4C81D1          	   623:          JMP  pas_get_token
                        	   624: ;
                        	   625: ;
                        	   626: ;
00:BFED 49              	   627: FACTB1   DFB    TOKEN_IDENTIFIER
00:BFEE 16BF            	   628:          word   IDENT
00:BFF0 4E              	   629:          ASC    TOKEN_NUMBER
00:BFF1 BABF            	   630:          word   FACNUM
00:BFF3 22              	   631: FACTQT1  DFB    TOKEN_STRING        ; QUOTE SYMBOL
00:BFF4 AFBF            	   632:          word   FACSTR
00:BFF6 28              	   633:          ASC    '('
00:BFF7 C0BF            	   634:          word   PAREN
00:BFF9 91              	   635:          DFB    TOKEN_MEM
00:BFFA C6BF            	   636:          word   FACMEM     ; MEM
00:BFFC 90              	   637:          DFB    TOKEN_NOT
00:BFFD DCBF            	   638:          word   FACNOT
00:BFFF A2              	   639:          DFB    TOKEN_MEMC
00:C000 CCBF            	   640:          word   FACMMC     ; MEMC
00:C002 A9              	   641:          DFB    TOKEN_ADDRESS
00:C003 9CBF            	   642:          word   FACADR
00:C005 00              	   643:          DFB  0
                        	   644: ;
                        	   645: ; EXPRESSION
                        	   646: ;
00:C006 2001BE          	   647: EXPRES   JSR  CHK_STAK
00:C009 2045BE          	   648:          JSR  SIMEXP
00:C00C A593            	   649:          LDA  token_type
00:C00E A216            	   650:          LDX  #<EXPTB1
00:C010 A0C0            	   651:          LDY  #>EXPTB1
00:C012 20D291          	   652:          JSR  TKNJMP
00:C015 60              	   653:          RTS
                        	   654: ;
00:C016 3D              	   655: EXPTB1   ASC    '='
00:C017 29C0            	   656:          word   EXPR1
00:C019 55              	   657:          DFB    TOKEN_NEQ
00:C01A 29C0            	   658:          word   EXPR1
00:C01C 3C              	   659:          ASC    '<'
00:C01D 29C0            	   660:          word   EXPR1
00:C01F 80              	   661:          DFB    TOKEN_LEQ
00:C020 29C0            	   662:          word   EXPR1
00:C022 81              	   663:          DFB    TOKEN_GEQ
00:C023 29C0            	   664:          word   EXPR1
00:C025 3E              	   665:          ASC    '>'
00:C026 29C0            	   666:          word   EXPR1
00:C028 00              	   667:          DFB  0
                        	   668: ;
00:C029 48              	   669: EXPR1    PHA
00:C02A 2081D1          	   670:          JSR  pas_get_token
00:C02D 2045BE          	   671:          JSR  SIMEXP
00:C030 68              	   672:          PLA
00:C031 A238            	   673:          LDX  #<EXPTB3
00:C033 A0C0            	   674:          LDY  #>EXPTB3
00:C035 20D291          	   675:          JSR  TKNJMP
                        	   676: ;
00:C038 3D              	   677: EXPTB3   ASC    '='
00:C039 4BC0            	   678:          word   EXPR2
00:C03B 55              	   679:          ASC    TOKEN_NEQ
00:C03C 51C0            	   680:          word   EXPR3
00:C03E 3C              	   681:          ASC    '<'
00:C03F 55C0            	   682:          word   EXPR4
00:C041 81              	   683:          DFB    TOKEN_GEQ
00:C042 59C0            	   684:          word   EXPR5
00:C044 3E              	   685:          ASC    '>'
00:C045 5DC0            	   686:          word   EXPR6
00:C047 80              	   687:          DFB    TOKEN_LEQ
00:C048 61C0            	   688:          word   EXPR7
00:C04A 00              	   689:          DFB  0
                        	   690: ;
00:C04B A910            	   691: EXPR2    LDA  #PCODE_EQL       ; EQL      Test (sp - 1) == (sp)
00:C04D 20A5C9          	   692: EXPR8    JSR  GENNOP
00:C050 60              	   693:          RTS
00:C051 A912            	   694: EXPR3    LDA  #PCODE_NEQ       ; NEQ      Test (sp - 1) != (sp)
00:C053 D0F8            	   695:          BNE  EXPR8
00:C055 A914            	   696: EXPR4    LDA  #PCODE_LSS       ; LSS      Test (sp - 1) < (sp)
00:C057 D0F4            	   697:          BNE  EXPR8
00:C059 A916            	   698: EXPR5    LDA  #PCODE_GEQ       ; GEQ      Test (sp - 1) >= (sp)
00:C05B D0F0            	   699:          BNE  EXPR8
00:C05D A918            	   700: EXPR6    LDA  #PCODE_GTR       ; GTR      Test (sp - 1) > (sp)
00:C05F D0EC            	   701:          BNE  EXPR8
00:C061 A919            	   702: EXPR7    LDA  #PCODE_LEQ       ; LEQ      Test (sp - 1) <= (sp)
00:C063 D0E8            	   703:          BNE  EXPR8
                        	   704: ;
                        	   705: ; STATEMENT
                        	   706: ;
00:C065 2001BE          	   707: STMNT    JSR  CHK_STAK
00:C068 A593            	   708:          LDA  token_type
00:C06A A272            	   709:          LDX  #<STMNT1
00:C06C A0C0            	   710:          LDY  #>STMNT1
00:C06E 20D291          	   711:          JSR  TKNJMP
00:C071 60              	   712:          RTS
                        	   713: ;
00:C072 49              	   714: STMNT1   DFB    TOKEN_IDENTIFIER
00:C073 9DC0            	   715:          word   ASSIGN
00:C075 92              	   716:          DFB    TOKEN_IF
00:C076 0DC3            	   717:          word   IF
00:C078 9A              	   718:          DFB    TOKEN_FOR
00:C079 74C4            	   719:          word   FOR
00:C07B 96              	   720:          DFB    TOKEN_WHILE
00:C07C 87C3            	   721:          word   WHILE
00:C07E 95              	   722:          DFB    TOKEN_CASE
00:C07F B9C3            	   723:          word   CASE
00:C081 98              	   724:          DFB    TOKEN_REPEAT
00:C082 63C3            	   725:          word   REPEAT
00:C084 88              	   726:          DFB    TOKEN_BEGIN
00:C085 4DC3            	   727:          word   BEG
00:C087 9E              	   728:          DFB    TOKEN_READ
00:C088 B5C1            	   729:          word   READ
00:C08A 9D              	   730:          DFB    TOKEN_WRITE
00:C08B 13C1            	   731:          word   WRITE
00:C08D 91              	   732:          DFB    TOKEN_MEM
00:C08E 5EC2            	   733:          word   MEM
00:C090 9F              	   734:          DFB    TOKEN_CALL
00:C091 79C2            	   735:          word   CALLSB
00:C093 A2              	   736:          DFB    TOKEN_MEMC
00:C094 63C2            	   737:          word   MEMC
00:C096 FF              	   738:          DFB    TOKEN_WRITELN
00:C097 04C1            	   739:          word   WRITELN
00:C099 F1              	   740:          DB     TOKEN_LCDWRITE
00:C09A 64C1            	   741:          word   STMNT_WRITE_LCD
00:C09C 00              	   742:          DFB  0
                        	   743: ;
                        	   744: ; ASSIGNMENT - this is where we store an integer/char into a variable or array index
                        	   745: ;
00:C09D 206FBC          	   746: ASSIGN   JSR  LOOKUP
00:C0A0 A2AC            	   747: ASS1     LDX  #<ASSTB1
00:C0A2 A0C0            	   748:          LDY  #>ASSTB1
00:C0A4 20D291          	   749:          JSR  TKNJMP
00:C0A7 A218            	   750:          LDX  #24     ; ERROR: Type mismatch
00:C0A9 4CAB99          	   751:          jmp  ERROR
                        	   752: ;
00:C0AC 41              	   753: ASSTB1   DFB   SYMBOL_ARRAY
00:C0AD C7C0            	   754:          word  ASSARR
00:C0AF 56              	   755:          DFB   SYMBOL_VARIABLE
00:C0B0 D9C0            	   756:          word  ASSVAR
00:C0B2 59              	   757:          DFB   SYMBOL_FUNCTION_RETURN
00:C0B3 D9C0            	   758:          word  ASSVAR
00:C0B5 50              	   759:          DFB   SYMBOL_PROCEDURE
00:C0B6 86C2            	   760:          word  FNCPRC
00:C0B8 51              	   761:          DFB   SYMBOL_LIBRARY_PROCEDURE
00:C0B9 55C9            	   762:          word  library_function_call
00:C0BB 46              	   763:          DFB   SYMBOL_FUNCTION
00:C0BC C2C0            	   764:          word  assign_bad_identifier
00:C0BE 52              	   765:          DFB   SYMBOL_LIBRARY_FUNCTION
00:C0BF C2C0            	   766:          word  assign_bad_identifier
00:C0C1 00              	   767:          DFB  0
                        	   768: 
                        	   769: assign_bad_identifier:
00:C0C2 A235            	   770:           ldx #53   ; ERROR: Use of function identifier in statement
00:C0C4 4CAB99          	   771:           jmp ERROR
                        	   772: ;
00:C0C7 2045BD          	   773: ASSARR   JSR  SYMWRK
00:C0CA 209F94          	   774:          JSR  PSHWRK
00:C0CD A936            	   775:          LDA  #PCODE_STI    ; Store integer indexed
00:C0CF 18              	   776:          CLC
00:C0D0 654A            	   777:          ADC  DATTYP        ; A becomes PCODE_STIC (Store character indexed) if DATTYP == 1
00:C0D2 48              	   778:          PHA
00:C0D3 20ECBC          	   779:          JSR  GETSUB
00:C0D6 4CE8C0          	   780:          JMP  ASS2
                        	   781: ;
00:C0D9 2045BD          	   782: ASSVAR   JSR  SYMWRK
00:C0DC 209F94          	   783:          JSR  PSHWRK
00:C0DF A932            	   784:          LDA  #PCODE_STO    ;  Store integer
00:C0E1 18              	   785:          CLC
00:C0E2 654A            	   786:          ADC  DATTYP        ; A becomes PCODE_STOC (Store character indexed) if DATTYP == 1
00:C0E4 48              	   787:          PHA
00:C0E5 2081D1          	   788:          JSR  pas_get_token
00:C0E8 A941            	   789: ASS2     LDA  #TOKEN_ASSIGN
00:C0EA A20D            	   790:          LDX  #13       ; ERROR: := expected
00:C0EC 20E5D1          	   791:          JSR  CHKTKN
00:C0EF 2099BD          	   792:          JSR  GETEXPR
00:C0F2 68              	   793:          PLA
00:C0F3 20B294          	   794:          JSR  PULWRK
00:C0F6 2050BD          	   795:          JSR  WRKSYM
00:C0F9 48              	   796:          PHA
00:C0FA 2009BD          	   797:          JSR  GET_LEV
00:C0FD 206EBD          	   798:          JSR  GET_OFF
00:C100 68              	   799:          PLA
00:C101 4CBEC9          	   800:          JMP  GENADR
                        	   801: ;
                        	   802: 
                        	   803: ;
                        	   804: ;
                        	   805: ; WRITELN
                        	   806: ;
00:C104 2081D1          	   807: WRITELN  JSR  pas_get_token     ; SEE IF ( PRESENT
00:C107 C928            	   808:          CMP  #'('
00:C109 D003            	   809:          BNE  WRITELN9   ; NOPE
00:C10B 2016C1          	   810:          JSR  WRIT9
                        	   811: WRITELN9 =  *
00:C10E A940            	   812:          LDA  #PCODE_OUTCR   ; OUTPUT C/R
00:C110 4CA5C9          	   813:          JMP  GENNOP
                        	   814: ;
                        	   815: ;
                        	   816: ; WRITE
                        	   817: ;
00:C113 20DBBC          	   818: WRITE    JSR  CHKLHP
00:C116 2081D1          	   819: WRIT9    JSR  pas_get_token
00:C119 C922            	   820:          CMP  #TOKEN_STRING
00:C11B D022            	   821:          BNE  WRIT1
00:C11D A923            	   822:          LDA  #PCODE_OUS    ; Output string
00:C11F 2025C1          	   823:          JSR  W_STRING
00:C122 4C4FC1          	   824:          JMP  WRIT5
                        	   825: ;
                        	   826: W_STRING =  *
00:C125 20A5C9          	   827:          JSR  GENNOP
00:C128 A592            	   828:          LDA  token_length
00:C12A 20A5C9          	   829:          JSR  GENNOP
00:C12D A000            	   830:          LDY  #0
00:C12F B90002          	   831: WRIT2    LDA  INBUF,Y
00:C132 C8              	   832: WRIT10   INY
00:C133 5A              	   833:          phy
00:C134 20A5C9          	   834:          JSR  GENNOP
00:C137 7A              	   835:          ply
00:C138 C692            	   836:          DEC  token_length
00:C13A D0F3            	   837:          BNE  WRIT2
00:C13C 4C81D1          	   838:          JMP  pas_get_token
                        	   839: ;
                        	   840: WRIT1    =  *          ; here if not string
00:C13F C9AB            	   841:          CMP  #TOKEN_CHR       ; CHR?
00:C141 F015            	   842:          BEQ  W_CHR      ; yes
00:C143 C9AC            	   843:          CMP  #TOKEN_HEX       ; HEX?
00:C145 F019            	   844:          BEQ  W_HEX      ; yes
00:C147 2006C0          	   845:          JSR  EXPRES     ; just ordinary number - get it
00:C14A A91E            	   846:          LDA  #PCODE_OUT        ; OUT       Output number
00:C14C 20A5C9          	   847:          JSR  GENNOP
00:C14F A593            	   848: WRIT5    LDA  token_type
00:C151 C92C            	   849:          CMP  #','
00:C153 F0C1            	   850:          BEQ  WRIT9
00:C155 4CE2BC          	   851:          JMP  CHKRHP
                        	   852: ;
                        	   853: ; here for write (chr(x))
                        	   854: ;
                        	   855: W_CHR    =  *
00:C158 A91F            	   856:          LDA  #PCODE_OUTC   ; OUTC      Output character
                        	   857: W_CHR1   =  *
00:C15A 2054C2          	   858:          JSR  WAIT_1     ; process expression in parentheses
00:C15D 4C4FC1          	   859:          JMP  WRIT5      ; back for next item
                        	   860: ;
                        	   861: ; here for write (hex(x))
                        	   862: ;
                        	   863: W_HEX    =  *
00:C160 A921            	   864:          LDA  #PCODE_OUH        ; OUH       Output hex number
00:C162 D0F6            	   865:          BNE  W_CHR1
                        	   866: 
                        	   867: ;
                        	   868: ;
                        	   869: ; WRITELCD: can write number, string, hex or chr
                        	   870: ;
00:C164 20DBBC          	   871: STMNT_WRITE_LCD    JSR  CHKLHP
00:C167 2081D1          	   872: WRITE_LCD9    JSR  pas_get_token
00:C16A C922            	   873:          CMP  #TOKEN_STRING
00:C16C D022            	   874:          BNE  WRITE_LCD1
00:C16E A943            	   875:          LDA  #PCODE_LCD_WRITE_STR    ; Output string
00:C170 2076C1          	   876:          JSR  WRITE_LCD_STRING
00:C173 4CA0C1          	   877:          JMP  WRITE_LCD5
                        	   878: ;
                        	   879: WRITE_LCD_STRING =  *
00:C176 20A5C9          	   880:          JSR  GENNOP
00:C179 A592            	   881:          LDA  token_length
00:C17B 20A5C9          	   882:          JSR  GENNOP
00:C17E A000            	   883:          LDY  #0
00:C180 B90002          	   884: WRITE_LCD2    LDA  INBUF,Y    ; strings are placed in INBUF during parsing
00:C183 C8              	   885:          INY
00:C184 5A              	   886:          phy
00:C185 20A5C9          	   887:          JSR  GENNOP
00:C188 7A              	   888:          ply
00:C189 C692            	   889:          DEC  token_length
00:C18B D0F3            	   890:          BNE  WRITE_LCD2
00:C18D 4C81D1          	   891:          JMP  pas_get_token
                        	   892: ;
                        	   893: WRITE_LCD1    =  *            ; here if not string
00:C190 C9AB            	   894:          CMP  #TOKEN_CHR      ; CHR?
00:C192 F015            	   895:          BEQ  WRITE_LDC_CHR   ; yes
00:C194 C9AC            	   896:          CMP  #TOKEN_HEX      ; HEX?
00:C196 F019            	   897:          BEQ  WRITE_LDC_HEX   ; yes
00:C198 2006C0          	   898:          JSR  EXPRES          ; just ordinary number - get it
00:C19B A942            	   899:          LDA  #PCODE_LCD_WRITE_NUM        ; OUT       Output number
00:C19D 20A5C9          	   900:          JSR  GENNOP
00:C1A0 A593            	   901: WRITE_LCD5    LDA  token_type
00:C1A2 C92C            	   902:          CMP  #','
00:C1A4 F0C1            	   903:          BEQ  WRITE_LCD9
00:C1A6 4CE2BC          	   904:          JMP  CHKRHP
                        	   905: ;
                        	   906: ; here for lcdwrite (chr(x))
                        	   907: ;
                        	   908: WRITE_LDC_CHR    =  *
00:C1A9 A945            	   909:          LDA  #PCODE_LCD_WRITE_CHR   ; OUTC     Output character
                        	   910: WRITE_LDC_CHR1   =  *
00:C1AB 2054C2          	   911:          JSR  WAIT_1          ; process expression in parentheses
00:C1AE 4CA0C1          	   912:          JMP  WRITE_LCD5      ; back for next item
                        	   913: ;
                        	   914: ; here for lcdwrite (hex(x))
                        	   915: ;
                        	   916: WRITE_LDC_HEX    =  *
00:C1B1 A944            	   917:          LDA  #PCODE_LCD_WRITE_HEX        ; OUH       Output hex number
00:C1B3 D0F6            	   918:          BNE  WRITE_LDC_CHR1
                        	   919: 
                        	   920: ;
                        	   921: ;
                        	   922: ; READ
                        	   923: ;
00:C1B5 20DBBC          	   924: READ     jsr  CHKLHP    ; check for "("
00:C1B8 20EAD1          	   925: READ8    jsr  GET_LOOK
00:C1BB 2045BD          	   926: READ2    jsr  SYMWRK      ; SYMITM --> WORK
00:C1BE 209F94          	   927:          jsr  PSHWRK
00:C1C1 A200            	   928:          ldx  #0
00:C1C3 864B            	   929:          stx  COUNT1      ; this will have 1 in it if we are reading into an array element
00:C1C5 C941            	   930:          cmp  #SYMBOL_ARRAY
00:C1C7 F03B            	   931:          beq  READ3
00:C1C9 C956            	   932:          cmp  #SYMBOL_VARIABLE
00:C1CB F005            	   933:          beq  READ9
00:C1CD A20C            	   934:          ldx  #12     ; ERROR: Illegal Identifier
00:C1CF 4CAB99          	   935:          jmp  ERROR
                        	   936: 
00:C1D2 20D3CB          	   937: READ9    jsr get_token
00:C1D5 A91C            	   938: READ11   lda  #PCODE_INP  ; Input number
00:C1D7 18              	   939:          clc
00:C1D8 654A            	   940:          adc  DATTYP      ; becomes PCODE_INPC (input character) if DATTYP == 1
00:C1DA 20A5C9          	   941:          jsr  GENNOP
00:C1DD 20B294          	   942:          jsr  PULWRK
00:C1E0 2050BD          	   943:          jsr  WRKSYM      ; WORK --> SYMITM
00:C1E3 2013BD          	   944:          jsr  GET_DAT
00:C1E6 2009BD          	   945:          jsr  GET_LEV
00:C1E9 206EBD          	   946:          jsr  GET_OFF
00:C1EC A932            	   947:          lda  #PCODE_STO    ; Store integer
00:C1EE A64B            	   948:          ldx  COUNT1
00:C1F0 F002            	   949:          beq  READ7
00:C1F2 A936            	   950:          lda  #PCODE_STI    ; Store integer indexed
00:C1F4 18              	   951: READ7    clc
00:C1F5 654A            	   952:          adc  DATTYP        ; add 1 if a char to become PCODE_STOC / PCODE_STIC
00:C1F7 20BEC9          	   953:          jsr  GENADR
00:C1FA A593            	   954: READ7_A  lda  token_type
00:C1FC C92C            	   955:          cmp  #','
00:C1FE F0B8            	   956:          beq  READ8         ; get another variable to read into
                        	   957: ;
                        	   958: ;  done with READ statement
                        	   959: ;
00:C200 20E2BC          	   960:          jsr  CHKRHP        ; check for ")"
00:C203 60              	   961:          rts
                        	   962: ;
                        	   963: ;  here for reading into an array
                        	   964: ;
00:C204 A54A            	   965: READ3    lda  DATTYP
00:C206 48              	   966:          pha              ; push data type of array
00:C207 2081D1          	   967:          jsr  pas_get_token
00:C20A C95B            	   968:          cmp  #'['
00:C20C F025            	   969:          beq  READ3_A
00:C20E 68              	   970:          pla            ; get back data type of array
00:C20F 854A            	   971:          sta  DATTYP    ; 0 = integer, 1 = char
00:C211 D005            	   972:          bne  READ3_B
00:C213 A218            	   973:          ldx  #24       ; ERROR: Type mismatch (cannot read into array of integer)
00:C215 4CAB99          	   974:          jmp  ERROR
00:C218 20B294          	   975: READ3_B  jsr  PULWRK
00:C21B 2050BD          	   976:          jsr  WRKSYM     ; WORK --> SYMITM
00:C21E A925            	   977:          lda  #PCODE_INS        ; READ STRING - Input string into array
00:C220 20A5C9          	   978:          jsr  GENNOP
00:C223 2009BD          	   979:          jsr  GET_LEV
00:C226 206EBD          	   980:          jsr  GET_OFF
00:C229 A006            	   981:          ldy  #SYMSUB
00:C22B B140            	   982:          lda  (SYMITM),Y  ; maximum array size
00:C22D 20BEC9          	   983:          jsr  GENADR     ; A = length, not the P-code which we just output above
00:C230 4CFAC1          	   984:          jmp  READ7_A
                        	   985: ;
                        	   986: ;  read into subscripted item
                        	   987: ;
00:C233 2099BD          	   988: READ3_A  jsr  GETEXPR   ; subscript
00:C236 20FFBC          	   989:          jsr  CHKRHB    ; check for "]"
00:C239 E64B            	   990:          inc  COUNT1    ; flag for reading into array element
00:C23B 68              	   991:          pla            ; get back data type of array
00:C23C 854A            	   992:          sta  DATTYP    ; save
00:C23E 4CD5C1          	   993:          jmp  READ11
                        	   994: ;
                        	   995: 
                        	   996: ;
                        	   997: ;
00:C241 20DBBC          	   998: TWO_OP   JSR  CHKLHP
00:C244 2099BD          	   999:          JSR  GETEXPR
00:C247 20D2BD          	  1000: ONE_OP2  JSR  GET_ITEM
00:C24A 20E2BC          	  1001: ONE_OP   JSR  CHKRHP
00:C24D 68              	  1002:          PLA
00:C24E 4CA5C9          	  1003:          JMP  GENNOP
                        	  1004: 
                        	  1005: 
                        	  1006: 
00:C251 4CA5C9          	  1007: GENNOP2  JMP  GENNOP
                        	  1008: ;
                        	  1009: 
00:C254 48              	  1010: WAIT_1   PHA
00:C255 20DBBC          	  1011:          JSR  CHKLHP
00:C258 2099BD          	  1012:          JSR  GETEXPR
00:C25B 4C4AC2          	  1013:          JMP  ONE_OP
                        	  1014: ;
                        	  1015: ; MEM
                        	  1016: ;
00:C25E A900            	  1017: MEM      LDA  #0        ; integer
00:C260 48              	  1018:          PHA
00:C261 F003            	  1019:          BEQ  MEM2
00:C263 A901            	  1020: MEMC     LDA  #1        ; character
00:C265 48              	  1021:          PHA
00:C266 20ECBC          	  1022: MEM2     JSR  GETSUB
00:C269 A941            	  1023:          LDA  #TOKEN_ASSIGN
00:C26B A20D            	  1024:          LDX  #13     ; ERROR: := expected
00:C26D 20E5D1          	  1025:          JSR  CHKTKN
00:C270 2099BD          	  1026:          JSR  GETEXPR
00:C273 68              	  1027:          PLA
00:C274 18              	  1028:          CLC
00:C275 6934            	  1029:          ADC  #PCODE_STA     ; Store integer absolute address (or PCODE_STAC if A == 1)
00:C277 D0D8            	  1030:          BNE  GENNOP2
                        	  1031: ;
                        	  1032: ; CALL ABSOLUTE ADDRESS
                        	  1033: ;
00:C279 20DBBC          	  1034: CALLSB   JSR  CHKLHP
00:C27C 2099BD          	  1035:          JSR  GETEXPR
00:C27F 20E2BC          	  1036:          JSR  CHKRHP
00:C282 A92B            	  1037:          LDA  #PCODE_CLA    ; Call absolute address
00:C284 D0CB            	  1038:          BNE  GENNOP2
                        	  1039: ;
                        	  1040: ; FUNCTION OR PROCEDURE CALL
                        	  1041: ;
00:C286 A900            	  1042: FNCPRC   LDA  #0
00:C288 854B            	  1043:          STA  COUNT1      ; number of arguments
00:C28A A006            	  1044:          LDY  #SYMARG
00:C28C B140            	  1045:          LDA  (SYMITM),Y
00:C28E F033            	  1046:          BEQ  FNC1
00:C290 20DBBC          	  1047:          JSR  CHKLHP
00:C293 A54B            	  1048: FNC2     LDA  COUNT1    ; save on stack in case the expression calls functions
00:C295 48              	  1049:          PHA
00:C296 2045BD          	  1050:          JSR  SYMWRK
00:C299 209F94          	  1051:          JSR  PSHWRK
00:C29C 2099BD          	  1052:          JSR  GETEXPR
00:C29F 20B294          	  1053:          JSR  PULWRK
00:C2A2 2050BD          	  1054:          JSR  WRKSYM
00:C2A5 68              	  1055:          PLA            ; get number of arguments back
00:C2A6 854B            	  1056:          STA  COUNT1
00:C2A8 E64B            	  1057:          INC  COUNT1    ; add 1 for the one we just processed
00:C2AA A593            	  1058:          LDA  token_type
00:C2AC C92C            	  1059:          CMP  #','
00:C2AE F0E3            	  1060:          BEQ  FNC2
00:C2B0 A54B            	  1061:          LDA  COUNT1
00:C2B2 A006            	  1062:          LDY  #SYMARG
00:C2B4 D140            	  1063:          CMP  (SYMITM),Y   ; check we got the right number of arguments
00:C2B6 F005            	  1064:          BEQ  FNC3
00:C2B8 A223            	  1065:          LDX  #35     ; ERROR: Parameters mismatched
00:C2BA 4CAB99          	  1066:          jmp  ERROR
00:C2BD 20E2BC          	  1067: FNC3     JSR  CHKRHP
00:C2C0 4CC6C2          	  1068:          JMP  FNC5
00:C2C3 2081D1          	  1069: FNC1     JSR  pas_get_token
00:C2C6 2009BD          	  1070: FNC5     JSR  GET_LEV
00:C2C9 206EBD          	  1071:          JSR  GET_OFF
00:C2CC A008            	  1072:          LDY  #SYMDAT
00:C2CE B140            	  1073:          LDA  (SYMITM),Y
00:C2D0 D011            	  1074:          BNE  FNC5A
00:C2D2 A529            	  1075:          LDA  OFFSET
00:C2D4 38              	  1076:          SEC
00:C2D5 E523            	  1077:          SBC  PCODE         ; calculate relative procedure address
00:C2D7 8529            	  1078:          STA  OFFSET
00:C2D9 A52A            	  1079:          LDA  OFFSET+1
00:C2DB E524            	  1080:          SBC  PCODE+1
00:C2DD 852A            	  1081:          STA  OFFSET+1
00:C2DF A927            	  1082:          LDA  #PCODE_CLL         ; Relative procedure/function call
00:C2E1 D002            	  1083:          BNE  FNC5B
00:C2E3 A938            	  1084: FNC5A    LDA  #PCODE_ABSCLL      ; Absolute procedure/function call
00:C2E5 20BEC9          	  1085: FNC5B    JSR  GENADR
00:C2E8 A54B            	  1086:          LDA  COUNT1    ; number of arguments
00:C2EA F01B            	  1087:          BEQ  FNC4
00:C2EC A54B            	  1088:          LDA  COUNT1     ; TIMES 3
00:C2EE 0A              	  1089:          ASL             ; multiply by two then add one more COUNT1
00:C2EF B017            	  1090:          BCS  FNC6
00:C2F1 654B            	  1091:          ADC  COUNT1
00:C2F3 854B            	  1092:          STA  COUNT1
00:C2F5 B011            	  1093:          BCS  FNC6
00:C2F7 A900            	  1094:          LDA  #0
00:C2F9 38              	  1095:          SEC
00:C2FA E54B            	  1096:          SBC  COUNT1
00:C2FC 852B            	  1097:          STA  OPND
00:C2FE A9FF            	  1098:          LDA  #$FF
00:C300 852C            	  1099:          STA  OPND+1      ;  calculate: 0 - (number_of_arguments * 3)
00:C302 A93B            	  1100:          LDA  #PCODE_INT     ; Increment stack pointer (allow for arguments)
00:C304 202ECA          	  1101:          JSR  GENJMP
00:C307 60              	  1102: FNC4     RTS
00:C308 A20F            	  1103: FNC6     LDX  #15       ; ERROR: compiler limits exceeded
00:C30A 4CAB99          	  1104:          jmp  ERROR
                        	  1105: ;
                        	  1106: ;
                        	  1107: ; IF
                        	  1108: ;
00:C30D 2099BD          	  1109: IF       JSR  GETEXPR
00:C310 A993            	  1110:          LDA  #TOKEN_THEN
00:C312 A210            	  1111:          LDX  #16     ; ERROR: THEN expected
00:C314 20E5D1          	  1112:          JSR  CHKTKN
00:C317 2081D1          	  1113:          JSR  pas_get_token
00:C31A 205BBD          	  1114:          JSR  PSHPCODE
00:C31D A93D            	  1115:          LDA  #PCODE_JMZ     ; JMZ      Jump if (sp) zero
00:C31F 2028CA          	  1116:          JSR  GENNJM
00:C322 2065C0          	  1117:          JSR  STMNT
00:C325 A593            	  1118:          LDA  token_type
00:C327 C994            	  1119:          CMP  #TOKEN_ELSE       ; ELSE
00:C329 F007            	  1120:          BEQ  IF1
00:C32B 20B294          	  1121: IF2      JSR  PULWRK
00:C32E 205CCA          	  1122:          JSR  FIXAD
00:C331 60              	  1123:          RTS
00:C332 20B294          	  1124: IF1      JSR  PULWRK     ; HERE FOR ELSE
00:C335 20C0BD          	  1125:          JSR  WRK_WRKD
00:C338 205BBD          	  1126:          JSR  PSHPCODE
00:C33B 2026CA          	  1127:          JSR  GENNJP
00:C33E 20B5BD          	  1128:          JSR  WRKD_WRK
00:C341 205CCA          	  1129:          JSR  FIXAD
00:C344 2081D1          	  1130:          JSR  pas_get_token
00:C347 2065C0          	  1131:          JSR  STMNT
00:C34A 4C2BC3          	  1132:          JMP  IF2
                        	  1133: ;
                        	  1134: ; BEGIN
                        	  1135: ;
00:C34D 2081D1          	  1136: BEG      JSR  pas_get_token
00:C350 2065C0          	  1137:          JSR  STMNT
00:C353 A593            	  1138:          LDA  token_type
00:C355 C93B            	  1139:          CMP  #';'
00:C357 F0F4            	  1140:          BEQ  BEG
00:C359 A989            	  1141:          LDA  #TOKEN_END       ; END
00:C35B A211            	  1142:          LDX  #17         ; ERROR: ; or END expected
00:C35D 20E5D1          	  1143:          JSR  CHKTKN
00:C360 4C81D1          	  1144:          JMP  pas_get_token
                        	  1145: ;
                        	  1146: ; REPEAT
                        	  1147: ;
00:C363 205BBD          	  1148: REPEAT   JSR  PSHPCODE
00:C366 2081D1          	  1149: REP1     JSR  pas_get_token
00:C369 2065C0          	  1150:          JSR  STMNT
00:C36C A593            	  1151:          LDA  token_type
00:C36E C93B            	  1152:          CMP  #';'
00:C370 F0F4            	  1153:          BEQ  REP1
00:C372 A999            	  1154:          LDA  #TOKEN_UNTIL
00:C374 A20A            	  1155:          LDX  #10           ; ERROR: ; expected
00:C376 20E5D1          	  1156:          JSR  CHKTKN
00:C379 2099BD          	  1157:          JSR  GETEXPR
00:C37C 20B294          	  1158:          JSR  PULWRK
00:C37F 20AABD          	  1159:          JSR  WRK_OPND
00:C382 A93D            	  1160:          LDA  #PCODE_JMZ         ; JMZ      Jump if (sp) zero
00:C384 4C14CA          	  1161:          JMP  GENRJMP
                        	  1162: ;
                        	  1163: ; WHILE
                        	  1164: ;
00:C387 205BBD          	  1165: WHILE    JSR  PSHPCODE
00:C38A 2099BD          	  1166:          JSR  GETEXPR
00:C38D 205BBD          	  1167:          JSR  PSHPCODE
00:C390 A93D            	  1168:          LDA  #PCODE_JMZ       ; JMZ      Jump if (sp) zero
00:C392 2028CA          	  1169:          JSR  GENNJM
00:C395 A997            	  1170:          LDA  #TOKEN_DO
00:C397 A212            	  1171:          LDX  #18             ; ERROR: DO expected
00:C399 20E5D1          	  1172:          JSR  CHKTKN
00:C39C 2081D1          	  1173:          JSR  pas_get_token
00:C39F 2065C0          	  1174:          JSR  STMNT
00:C3A2 20B294          	  1175:          JSR  PULWRK
00:C3A5 20C0BD          	  1176:          JSR  WRK_WRKD
00:C3A8 20B294          	  1177:          JSR  PULWRK
00:C3AB 20AABD          	  1178:          JSR  WRK_OPND
00:C3AE A93C            	  1179:          LDA  #PCODE_JMP     ; JMP      Jump unconditionally
00:C3B0 2014CA          	  1180:          JSR  GENRJMP
00:C3B3 20B5BD          	  1181:          JSR  WRKD_WRK
00:C3B6 4C5CCA          	  1182:          JMP  FIXAD
                        	  1183: ;
                        	  1184: ; CASE
                        	  1185: ;
00:C3B9 2099BD          	  1186: CASE     JSR  GETEXPR
00:C3BC A985            	  1187:          LDA  #TOKEN_OF       ; OF
00:C3BE A21A            	  1188:          LDX  #26         ; ERROR: "of " expected
00:C3C0 20E5D1          	  1189:          JSR  CHKTKN
00:C3C3 A901            	  1190:          LDA  #1
00:C3C5 854B            	  1191:          STA  COUNT1
00:C3C7 A900            	  1192: CASE7    LDA  #0
00:C3C9 854C            	  1193:          STA  COUNT2
                        	  1194: CASE2    =  *
00:C3CB A92A            	  1195:          LDA  #PCODE_MOV  ; make copy of selector:  MOV       Copy (sp) to (sp + 1)
00:C3CD 20A5C9          	  1196:          JSR  GENNOP
00:C3D0 2099BD          	  1197:          JSR  GETEXPR    ; next expression to compare
00:C3D3 A910            	  1198:          LDA  #PCODE_EQL       ;  EQL       Test (sp - 1) == (sp)
00:C3D5 20A5C9          	  1199:          JSR  GENNOP
00:C3D8 A593            	  1200:          LDA  token_type
00:C3DA C93A            	  1201:          CMP  #':'
00:C3DC F014            	  1202:          BEQ  CASE1
00:C3DE A92C            	  1203:          LDA  #','
00:C3E0 A205            	  1204:          LDX  #5      ; ERROR: , or : expected
00:C3E2 20E5D1          	  1205:          JSR  CHKTKN
00:C3E5 205BBD          	  1206:          JSR  PSHPCODE
00:C3E8 A93E            	  1207:          LDA  #PCODE_JM1     ; JM1      Jump if (sp) not zero
00:C3EA 2028CA          	  1208:          JSR  GENNJM
00:C3ED E64C            	  1209:          INC  COUNT2
00:C3EF 4CCBC3          	  1210:          JMP  CASE2
00:C3F2 209FBD          	  1211: CASE1    JSR  PCD_WRKD
00:C3F5 A93D            	  1212:          LDA  #PCODE_JMZ     ; JMZ      Jump if (sp) zero
00:C3F7 2028CA          	  1213:          JSR  GENNJM
00:C3FA A54C            	  1214:          LDA  COUNT2
00:C3FC F00A            	  1215:          BEQ  CASE3
00:C3FE 20B294          	  1216: CASE4    JSR  PULWRK
00:C401 205CCA          	  1217:          JSR  FIXAD
00:C404 C64C            	  1218:          DEC  COUNT2
00:C406 D0F6            	  1219:          BNE  CASE4
00:C408 20B5BD          	  1220: CASE3    JSR  WRKD_WRK
00:C40B 209F94          	  1221:          JSR  PSHWRK
00:C40E 2081D1          	  1222:          JSR  pas_get_token
00:C411 A54B            	  1223:          LDA  COUNT1
00:C413 48              	  1224:          PHA
00:C414 2065C0          	  1225:          JSR  STMNT
00:C417 68              	  1226:          PLA
00:C418 854B            	  1227:          STA  COUNT1
00:C41A A593            	  1228:          LDA  token_type
00:C41C C994            	  1229:          CMP  #TOKEN_ELSE       ; ELSE
00:C41E F01B            	  1230:          BEQ  CASE5
00:C420 C93B            	  1231:          CMP  #';'
00:C422 D035            	  1232:          BNE  CASE6
00:C424 209FBD          	  1233:          JSR  PCD_WRKD
00:C427 2026CA          	  1234:          JSR  GENNJP
00:C42A 20B294          	  1235:          JSR  PULWRK
00:C42D 205CCA          	  1236:          JSR  FIXAD
00:C430 20B5BD          	  1237:          JSR  WRKD_WRK
00:C433 209F94          	  1238:          JSR  PSHWRK
00:C436 E64B            	  1239:          INC  COUNT1
00:C438 4CC7C3          	  1240:          JMP  CASE7
00:C43B 209FBD          	  1241: CASE5    JSR  PCD_WRKD
00:C43E 2026CA          	  1242:          JSR  GENNJP
00:C441 20B294          	  1243:          JSR  PULWRK
00:C444 205CCA          	  1244:          JSR  FIXAD
00:C447 20B5BD          	  1245:          JSR  WRKD_WRK
00:C44A 209F94          	  1246:          JSR  PSHWRK
00:C44D 2081D1          	  1247:          JSR  pas_get_token
00:C450 A54B            	  1248:          LDA  COUNT1
00:C452 48              	  1249:          PHA
00:C453 2065C0          	  1250:          JSR  STMNT
00:C456 68              	  1251:          PLA
00:C457 854B            	  1252:          STA  COUNT1
00:C459 A989            	  1253: CASE6    LDA  #TOKEN_END       ; END
00:C45B A211            	  1254:          LDX  #17         ; ERROR: ; or END expected
00:C45D 20E5D1          	  1255:          JSR  CHKTKN
00:C460 A54B            	  1256:          LDA  COUNT1
00:C462 F00A            	  1257:          BEQ  CASE8
00:C464 20B294          	  1258: CASE9    JSR  PULWRK
00:C467 205CCA          	  1259:          JSR  FIXAD
00:C46A C64B            	  1260:          DEC  COUNT1
00:C46C D0F6            	  1261:          BNE  CASE9
00:C46E 203AC5          	  1262: CASE8    JSR  FOR6
00:C471 4C81D1          	  1263:          JMP  pas_get_token
                        	  1264: ;
                        	  1265: ; FOR
                        	  1266: ;
00:C474 A949            	  1267: FOR      LDA  #TOKEN_IDENTIFIER
00:C476 A204            	  1268:          LDX  #4      ; ERROR:  Identifier expected
00:C478 20D5D1          	  1269:          JSR  GETCHK
00:C47B 206FBC          	  1270:          JSR  LOOKUP
00:C47E C956            	  1271: FOR1     CMP  #SYMBOL_VARIABLE
00:C480 F009            	  1272:          BEQ  FOR2
00:C482 C959            	  1273:          CMP  #SYMBOL_FUNCTION_RETURN
00:C484 F005            	  1274:          BEQ  FOR2
00:C486 A20C            	  1275:          LDX  #12   ; ERROR: Illegal Identifier
00:C488 4CAB99          	  1276:          jmp  ERROR
00:C48B 20D9C0          	  1277: FOR2     JSR  ASSVAR
00:C48E 2045BD          	  1278:          JSR  SYMWRK
00:C491 A900            	  1279:          LDA  #0
00:C493 854B            	  1280:          STA  COUNT1
00:C495 A593            	  1281:          LDA  token_type
00:C497 C99B            	  1282:          CMP  #TOKEN_TO       ; TO
00:C499 F009            	  1283:          BEQ  FOR3
00:C49B A99C            	  1284:          LDA  #TOKEN_DOWNTO       ; DOWNTO
00:C49D A21C            	  1285:          LDX  #28       ; ERROR: TO or DOWNTO expected
00:C49F 20E5D1          	  1286:          JSR  CHKTKN
00:C4A2 C64B            	  1287:          DEC  COUNT1
00:C4A4 A54B            	  1288: FOR3     LDA  COUNT1
00:C4A6 48              	  1289:          PHA
00:C4A7 209F94          	  1290:          JSR  PSHWRK
00:C4AA 2099BD          	  1291:          JSR  GETEXPR
00:C4AD 20B294          	  1292:          JSR  PULWRK
00:C4B0 2050BD          	  1293:          JSR  WRKSYM
00:C4B3 68              	  1294:          PLA
00:C4B4 854B            	  1295:          STA  COUNT1
00:C4B6 205BBD          	  1296:          JSR  PSHPCODE
00:C4B9 A92A            	  1297:          LDA  #PCODE_MOV     ; MOV      Copy (sp) to (sp + 1)
00:C4BB 20A5C9          	  1298:          JSR  GENNOP
00:C4BE 2009BD          	  1299:          JSR  GET_LEV
00:C4C1 206EBD          	  1300:          JSR  GET_OFF
00:C4C4 2013BD          	  1301:          JSR  GET_DAT
00:C4C7 18              	  1302:          CLC
00:C4C8 692C            	  1303:          ADC  #PCODE_LOD  ; Load integer onto stack or PCODE_LODC if a char
00:C4CA 20BEC9          	  1304:          JSR  GENADR
00:C4CD A916            	  1305:          LDA  #PCODE_GEQ        ; UP (GEQ): GEQ       Test (sp - 1) >= (sp)
00:C4CF A64B            	  1306:          LDX  COUNT1
00:C4D1 F002            	  1307:          BEQ  FOR4
00:C4D3 A919            	  1308:          LDA  #PCODE_LEQ        ; DOWN (LEQ): LEQ       Test (sp - 1) <= (sp)
00:C4D5 20A5C9          	  1309: FOR4     JSR  GENNOP
00:C4D8 205BBD          	  1310:          JSR  PSHPCODE
00:C4DB A93D            	  1311:          LDA  #PCODE_JMZ       ;  JMZ       Jump if (sp) zero
00:C4DD 2028CA          	  1312:          JSR  GENNJM
00:C4E0 A54B            	  1313:          LDA  COUNT1
00:C4E2 48              	  1314:          PHA
00:C4E3 2045BD          	  1315:          JSR  SYMWRK
00:C4E6 209F94          	  1316:          JSR  PSHWRK
00:C4E9 A997            	  1317:          LDA  #TOKEN_DO
00:C4EB A212            	  1318:          LDX  #18       ; ERROR: DO expected
00:C4ED 20E5D1          	  1319:          JSR  CHKTKN
00:C4F0 2081D1          	  1320:          JSR  pas_get_token
00:C4F3 2065C0          	  1321:          JSR  STMNT
00:C4F6 20B294          	  1322:          JSR  PULWRK
00:C4F9 2050BD          	  1323:          JSR  WRKSYM
00:C4FC 2009BD          	  1324:          JSR  GET_LEV
00:C4FF 2013BD          	  1325:          JSR  GET_DAT
00:C502 206EBD          	  1326:          JSR  GET_OFF
00:C505 A54A            	  1327:          LDA  DATTYP
00:C507 18              	  1328:          CLC
00:C508 692C            	  1329:          ADC  #PCODE_LOD       ; LOD      Load integer onto stack
00:C50A 20BEC9          	  1330:          JSR  GENADR
00:C50D 68              	  1331:          PLA
00:C50E 854B            	  1332:          STA  COUNT1
00:C510 A926            	  1333:          LDA  #PCODE_INC     ; INC      Increment (sp) by 1
00:C512 A64B            	  1334:          LDX  COUNT1
00:C514 F002            	  1335:          BEQ  FOR5
00:C516 A928            	  1336:          LDA  #PCODE_DEC        ; DEC       Decrement (sp) by 1
00:C518 20A5C9          	  1337: FOR5     JSR  GENNOP
00:C51B A932            	  1338:          LDA  #PCODE_STO       ; STO      Store integer
00:C51D 18              	  1339:          CLC
00:C51E 654A            	  1340:          ADC  DATTYP          ; may become PCODE_STOC if a char
00:C520 20BEC9          	  1341:          JSR  GENADR
00:C523 20B294          	  1342:          JSR  PULWRK
00:C526 20C0BD          	  1343:          JSR  WRK_WRKD
00:C529 20B294          	  1344:          JSR  PULWRK
00:C52C 20AABD          	  1345:          JSR  WRK_OPND
00:C52F A93C            	  1346:          LDA  #PCODE_JMP       ; JMP      Jump unconditionally
00:C531 2014CA          	  1347:          JSR  GENRJMP
00:C534 20B5BD          	  1348:          JSR  WRKD_WRK
00:C537 205CCA          	  1349:          JSR  FIXAD
00:C53A A9FF            	  1350: FOR6     LDA  #$FF
00:C53C 852C            	  1351:          STA  OPND+1
00:C53E A9FD            	  1352:          LDA  #$FD
00:C540 852B            	  1353:          STA  OPND
00:C542 A93B            	  1354:          LDA  #PCODE_INT       ;  INT       Increment stack pointer
00:C544 4C2ECA          	  1355:          JMP  GENJMP
                        	  1356: 
                        	  1357: 
                        	  1358: ;***********************************************
                        	  1359: ; MORE OF THE COMPILER (PROCESSING A 'BLOCK')
                        	  1360: ;***********************************************
                        	  1361: 
                        	  1362: CHKGET   =  *
00:C547 20E5D1          	  1363:          JSR  CHKTKN
00:C54A 4C81D1          	  1364:          JMP  pas_get_token
                        	  1365: ;
                        	  1366: ;  copy WORK to token_value
                        	  1367: ;
                        	  1368: WRK_VAL  =  *
00:C54D 48              	  1369:          PHA
00:C54E A537            	  1370:          LDA  WORK
00:C550 8594            	  1371:          STA  token_value
00:C552 A538            	  1372:          LDA  WORK+1
00:C554 8595            	  1373:          STA  token_value+1
00:C556 68              	  1374:          PLA
00:C557 60              	  1375:          RTS
                        	  1376: ;
                        	  1377: ;  copy VALUE to WORK
                        	  1378: ;
                        	  1379: VAL_WRK  =  *
00:C558 48              	  1380:          PHA
00:C559 A594            	  1381:          LDA  token_value
00:C55B 8537            	  1382:          STA  WORK
00:C55D A595            	  1383:          LDA  token_value+1
00:C55F 8538            	  1384:          STA  WORK+1
00:C561 68              	  1385:          PLA
00:C562 60              	  1386:          RTS
                        	  1387: ;
                        	  1388: ;  copy ENDSYM to WORK
                        	  1389: ;
                        	  1390: END_WRK  =  *
00:C563 48              	  1391:          PHA
00:C564 A531            	  1392:          LDA  ENDSYM
00:C566 8537            	  1393:          STA  WORK
00:C568 A532            	  1394:          LDA  ENDSYM+1
00:C56A 8538            	  1395:          STA  WORK+1
00:C56C 68              	  1396:          PLA
00:C56D 60              	  1397:          RTS
                        	  1398: ;
                        	  1399: ;***********************************************
                        	  1400: ;
                        	  1401: ;
                        	  1402: ; BLOCK
                        	  1403: ;
00:C56E 82              	  1404: BLCKT1   DFB  TOKEN_CONST
00:C56F C5C5            	  1405:          word BLKCNS
00:C571 83              	  1406: BLCKT2   DFB  TOKEN_VAR
00:C572 DCC5            	  1407:          word BLKVAR
00:C574 86              	  1408: BLCKT3   DFB  TOKEN_PROCEDURE
00:C575 19C7            	  1409:          word BLKPRC
00:C577 87              	  1410:          DFB  TOKEN_FUNCTION
00:C578 39C7            	  1411:          word BLKFNC
00:C57A 88              	  1412:          DFB  TOKEN_BEGIN
00:C57B 01C8            	  1413:          word BLKBEG
00:C57D 00              	  1414:          DFB  0
                        	  1415: ;
                        	  1416: ;
00:C57E 2001BE          	  1417: BLOCK    JSR  CHK_STAK
00:C581 A900            	  1418:          LDA  #0
00:C583 8521            	  1419:          STA  FRAME+1
00:C585 A906            	  1420:          LDA  #6
00:C587 8520            	  1421:          STA  FRAME
00:C589 A539            	  1422:          LDA  PRCITM
00:C58B 8537            	  1423:          STA  WORK
00:C58D A63A            	  1424:          LDX  PRCITM+1
00:C58F 8638            	  1425:          STX  WORK+1
00:C591 053A            	  1426:          ORA  PRCITM+1
00:C593 F014            	  1427:          BEQ  BLK1
                        	  1428: 
                        	  1429: ;
00:C595 A004            	  1430: BLK1A    LDY  #SYMDSP
00:C597 A523            	  1431:          LDA  PCODE
00:C599 9137            	  1432:          STA  (WORK),Y
00:C59B C8              	  1433:          INY
00:C59C A524            	  1434:          LDA  PCODE+1
00:C59E 9137            	  1435:          STA  (WORK),Y
00:C5A0 A900            	  1436:          LDA  #0
00:C5A2 A008            	  1437:          LDY  #SYMDAT
00:C5A4 9137            	  1438:          STA  (WORK),Y   ; FLAG RELATIVE PROCEDURE
00:C5A6 4CB1C5          	  1439:          JMP  BLK2
00:C5A9 A523            	  1440: BLK1     LDA  PCODE
00:C5AB 8537            	  1441:          STA  WORK
00:C5AD A524            	  1442:          LDA  PCODE+1
00:C5AF 8538            	  1443:          STA  WORK+1
00:C5B1 209F94          	  1444: BLK2     JSR  PSHWRK
00:C5B4 2026CA          	  1445:          JSR  GENNJP
00:C5B7 A26E            	  1446:          LDX  #<BLCKT1
00:C5B9 A0C5            	  1447:          LDY  #>BLCKT1
00:C5BB A593            	  1448: BLK4     LDA  token_type
00:C5BD 20D291          	  1449:          JSR  TKNJMP
00:C5C0 A219            	  1450:          LDX  #25       ; ERROR: BEGIN expected
00:C5C2 4CAB99          	  1451:          jmp  ERROR
                        	  1452: ;
                        	  1453: ;
                        	  1454: ; CONSTANT
                        	  1455: ;
00:C5C5 2081D1          	  1456: BLKCNS   JSR  pas_get_token
00:C5C8 201ABD          	  1457: BLKCN1   JSR  CONDEC
00:C5CB A93B            	  1458:          LDA  #';'
00:C5CD A20A            	  1459:          LDX  #10       ; ERROR: ; expected
00:C5CF 2047C5          	  1460:          JSR  CHKGET
00:C5D2 A271            	  1461:          LDX  #<BLCKT2
00:C5D4 A0C5            	  1462:          LDY  #>BLCKT2
00:C5D6 20D291          	  1463:          JSR  TKNJMP
00:C5D9 4CC8C5          	  1464:          JMP  BLKCN1
                        	  1465: ;
                        	  1466: ; VARIABLE
                        	  1467: ;
00:C5DC A900            	  1468: BLKVAR   LDA  #0
00:C5DE 854B            	  1469:          STA  COUNT1
00:C5E0 2081D1          	  1470: BLKVR1   JSR  pas_get_token
00:C5E3 2033BE          	  1471: BLKVR6   JSR  VARDEC    ; check we have an identifier, add it to the symbol table, get another token
00:C5E6 E64B            	  1472:          INC  COUNT1    ; how many variables in this declaration
00:C5E8 1003            	  1473:          BPL  BLKVR7
00:C5EA 4C5AC6          	  1474:          JMP  BLKV13     ; ERROR  - compiler limits exceeded (more than 127 variables?)
00:C5ED A593            	  1475: BLKVR7   LDA  token_type
00:C5EF C92C            	  1476:          CMP  #','
00:C5F1 F0ED            	  1477:          BEQ  BLKVR1    ; back for another
00:C5F3 A93A            	  1478:          LDA  #':'
00:C5F5 A205            	  1479:          LDX  #5        ; ERROR: , or : expected
00:C5F7 2047C5          	  1480:          JSR  CHKGET
00:C5FA C984            	  1481:          CMP  #TOKEN_ARRAY   ; ARRAY
00:C5FC F043            	  1482:          BEQ  BLKVR2
00:C5FE C9FE            	  1483:          CMP  #TOKEN_INTEGER ; INTEGER
00:C600 F00A            	  1484:          BEQ  BLKVR8
00:C602 A9A1            	  1485:          LDA  #TOKEN_CHAR    ; CHAR
00:C604 A224            	  1486:          LDX  #36            ; ERROR: Data Type not recognised
00:C606 20E5D1          	  1487:          JSR  CHKTKN
00:C609 4C01C7          	  1488:          JMP  BLKVR3
                        	  1489: 
                        	  1490: ;
                        	  1491: ;  integer variable
                        	  1492: ;
00:C60C 20A6C6          	  1493: BLKVR8   JSR  BLKVR9  ; subtract COUNT1 from FRAME, put WORK into VALUE, put ENDSYM into WORK
                        	  1494: BLKV10   = *
00:C60F A008            	  1495:          LDY  #SYMDAT
00:C611 A900            	  1496:          LDA  #0         ; INTEGER TYPE
00:C613 9137            	  1497:          STA  (WORK),Y
00:C615 A520            	  1498:          LDA  FRAME
00:C617 A004            	  1499:          LDY  #SYMDSP
00:C619 9137            	  1500:          STA  (WORK),Y
00:C61B C8              	  1501:          INY
00:C61C A521            	  1502:          LDA  FRAME+1
00:C61E 9137            	  1503:          STA  (WORK),Y
00:C620 18              	  1504:          CLC
00:C621 A520            	  1505:          LDA  FRAME
00:C623 6903            	  1506:          ADC  #3
00:C625 8520            	  1507:          STA  FRAME
00:C627 9002            	  1508:          BCC  BLKV10_A
00:C629 E621            	  1509:          INC  FRAME+1
                        	  1510: BLKV10_A =  *
00:C62B C64B            	  1511:          DEC  COUNT1
00:C62D D003            	  1512:          BNE  BLKV10_B
00:C62F 4C01C7          	  1513:          JMP  BLKVR3
                        	  1514: 
                        	  1515: BLKV10_B = *
                        	  1516: ;
                        	  1517: ;  more in the list, go to the previous symbol
                        	  1518: ;
00:C632 A000            	  1519:          LDY  #SYMPRV
00:C634 B137            	  1520:          LDA  (WORK),Y
00:C636 AA              	  1521:          TAX
00:C637 C8              	  1522:          INY
00:C638 B137            	  1523:          LDA  (WORK),Y
00:C63A 8538            	  1524:          STA  WORK+1
00:C63C 8A              	  1525:          TXA
00:C63D 8537            	  1526:          STA  WORK       ; PREVIOUS ITEM
00:C63F 80CE            	  1527:          BRA  BLKV10
                        	  1528: 
                        	  1529: ;
                        	  1530: ; ARRAY [ N ] OF ...
                        	  1531: ;
00:C641 20F5BC          	  1532: BLKVR2   JSR  CHKLHB
00:C644 200DBE          	  1533:          JSR  CONST     ; get how many are in the array
00:C647 A596            	  1534:          LDA  token_value+2   ; can't be more than 65536
00:C649 D00F            	  1535:          BNE  BLKV13
00:C64B A594            	  1536:          LDA  token_value     ; add 1 to the count since array [3] of char means 4 elements
00:C64D 18              	  1537:          CLC
00:C64E 6901            	  1538:          ADC  #1
00:C650 8594            	  1539:          STA  token_value
00:C652 A595            	  1540:          LDA  token_value+1
00:C654 3004            	  1541:          BMI  BLKV13
00:C656 6900            	  1542:          ADC  #0
00:C658 1005            	  1543:          BPL  BLKVR4
00:C65A A20F            	  1544: BLKV13   LDX  #15       ; ERROR: compiler limits exceeded
00:C65C 4CAB99          	  1545:          jmp  ERROR
00:C65F 8595            	  1546: BLKVR4   STA  token_value+1
00:C661 2058C5          	  1547:          JSR  VAL_WRK   ; put the value (array count) in WORK
00:C664 2081D1          	  1548:          JSR  pas_get_token
00:C667 20FFBC          	  1549:          JSR  CHKRHB
00:C66A A901            	  1550:          LDA  #1        ; char
00:C66C 854A            	  1551:          STA  DATTYP
00:C66E A985            	  1552:          LDA  #TOKEN_OF  ; OF
00:C670 A21A            	  1553:          LDX  #26        ; ERROR: "of " expected
00:C672 2047C5          	  1554:          JSR  CHKGET
00:C675 C9FE            	  1555:          CMP  #TOKEN_INTEGER  ; INTEGER
00:C677 D020            	  1556:          BNE  BLKV11
00:C679 C64A            	  1557:          DEC  DATTYP    ; DATTYP of 0 is integer, and 1 is char
00:C67B 204DC5          	  1558:          JSR  WRK_VAL   ; get the array count back into token_value
                        	  1559: ;
                        	  1560: ; MULTIPLY token_value BY 3
                        	  1561: ;
00:C67E A594            	  1562:          LDA  token_value
00:C680 A695            	  1563:          LDX  token_value+1
00:C682 0694            	  1564:          ASL  token_value
00:C684 2695            	  1565:          ROL  token_value+1
00:C686 B0D2            	  1566:          BCS  BLKV13
00:C688 6594            	  1567:          ADC  token_value
00:C68A 8594            	  1568:          STA  token_value
00:C68C 8A              	  1569:          TXA
00:C68D 6595            	  1570:          ADC  token_value+1
00:C68F B0C9            	  1571:          BCS  BLKV13
00:C691 8595            	  1572:          STA  token_value+1
00:C693 2058C5          	  1573:          JSR  VAL_WRK     ; put the array count (times 3) back into WORK
00:C696 4CA0C6          	  1574:          JMP  BLKV12
                        	  1575:  ;
                        	  1576:  ;  here for array of char
                        	  1577:  ;
00:C699 A9A1            	  1578: BLKV11   LDA  #TOKEN_CHAR       ; CHAR
00:C69B A224            	  1579:          LDX  #36           ; ERROR: Data Type not recognised
00:C69D 20E5D1          	  1580:          JSR  CHKTKN
00:C6A0 20A6C6          	  1581: BLKV12   JSR  BLKVR9        ; we are COUNT1 frames back
00:C6A3 4CBFC6          	  1582:          JMP  BLKVR5
                        	  1583: 
                        	  1584: BLKVR9   =  *
00:C6A6 A520            	  1585:          LDA  FRAME         ; subtract COUNT1 (the variable position) from the frame number
00:C6A8 38              	  1586:          SEC
00:C6A9 E54B            	  1587:          SBC  COUNT1
00:C6AB 8520            	  1588:          STA  FRAME
00:C6AD A521            	  1589:          LDA  FRAME+1
00:C6AF E900            	  1590:          SBC  #0
00:C6B1 8521            	  1591:          STA  FRAME+1
00:C6B3 204DC5          	  1592:          JSR  WRK_VAL     ; copy WORK to VALUE (array count, possibly multiplied by 3)
00:C6B6 A531            	  1593:          LDA  ENDSYM      ; end of symbol table into WORK
00:C6B8 8537            	  1594:          STA  WORK
00:C6BA A532            	  1595:          LDA  ENDSYM+1
00:C6BC 8538            	  1596:          STA  WORK+1
00:C6BE 60              	  1597:          RTS
                        	  1598: 
                        	  1599: ;
                        	  1600: ;  we should be here with ENDSYM in WORK (for walking back through the symbol table for all the variables we just decla
                        	  1601: ;  COUNT1 will be the number of symbols we have to fix up
                        	  1602: ;
                        	  1603: BLKVR5   = *
00:C6BF A003            	  1604:          ldy  #SYMTYP
00:C6C1 A941            	  1605:          lda  #SYMBOL_ARRAY
00:C6C3 9137            	  1606:          sta  (WORK),Y    ; make symbol type array
00:C6C5 A004            	  1607:          ldy  #SYMDSP
00:C6C7 A520            	  1608:          lda  FRAME       ; FRAME is the displacement
00:C6C9 9137            	  1609:          sta  (WORK),Y
00:C6CB C8              	  1610:          iny
00:C6CC A521            	  1611:          lda  FRAME+1
00:C6CE 9137            	  1612:          sta  (WORK),Y
00:C6D0 A594            	  1613:          lda  token_value       ; array count (multiplied by 3 in the case of integers)
00:C6D2 18              	  1614:          clc
00:C6D3 6520            	  1615:          adc  FRAME       ; add to the stack frame address
00:C6D5 8520            	  1616:          sta  FRAME
00:C6D7 A595            	  1617:          lda  token_value+1
00:C6D9 6521            	  1618:          adc  FRAME+1
00:C6DB 8521            	  1619:          sta  FRAME+1
00:C6DD A008            	  1620:          ldy  #SYMDAT
00:C6DF A54A            	  1621:          lda  DATTYP       ; save the data type in the symbol
00:C6E1 9137            	  1622:          sta  (WORK),Y
00:C6E3 A006            	  1623:          ldy  #SYMSUB
00:C6E5 A594            	  1624:          lda  token_value        ; max subscript + 1
00:C6E7 9137            	  1625:          sta  (WORK),Y
00:C6E9 A595            	  1626:          lda  token_value+1
00:C6EB C8              	  1627:          iny
00:C6EC 9137            	  1628:          sta  (WORK),Y
00:C6EE C64B            	  1629:          dec  COUNT1
00:C6F0 F00F            	  1630:          beq  BLKVR3
                        	  1631: ;
                        	  1632: ;  onto the previous symbol
                        	  1633: ;
00:C6F2 A000            	  1634:          ldy  #SYMPRV
00:C6F4 B137            	  1635:          lda  (WORK),Y
00:C6F6 AA              	  1636:          tax
00:C6F7 C8              	  1637:          iny
00:C6F8 B137            	  1638:          lda  (WORK),Y
00:C6FA 8538            	  1639:          sta  WORK+1
00:C6FC 8A              	  1640:          txa
00:C6FD 8537            	  1641:          sta  WORK       ; PREVIOUS ITEM
00:C6FF 80BE            	  1642:          bra  BLKVR5
                        	  1643: ;
                        	  1644: ;  here at end of variable declaration (after INTEGER / CHAR)
                        	  1645: ;
00:C701 A93B            	  1646: BLKVR3   LDA  #';'
00:C703 A20A            	  1647:          LDX  #10       ; ERROR: ; expected
00:C705 20D5D1          	  1648:          JSR  GETCHK
00:C708 2081D1          	  1649:          JSR  pas_get_token
00:C70B A274            	  1650:          LDX  #<BLCKT3  ; now look for procedure / function / begin
00:C70D A0C5            	  1651:          LDY  #>BLCKT3
00:C70F 20D291          	  1652:          JSR  TKNJMP    ; if not there, look for another variable declaration
00:C712 A900            	  1653:          LDA  #0        ; zero variables in this list so far
00:C714 854B            	  1654:          STA  COUNT1
00:C716 4CE3C5          	  1655:          JMP  BLKVR6
                        	  1656: ;
                        	  1657: ; PROCEDURE DECLARATION
                        	  1658: ;
00:C719 A949            	  1659: BLKPRC   LDA  #'I'
00:C71B A204            	  1660:          LDX  #4         ; ERROR: Identifier expected
00:C71D 20D5D1          	  1661:          JSR  GETCHK
00:C720 A900            	  1662:          LDA  #0
00:C722 854B            	  1663:          STA  COUNT1    ; no function return value
00:C724 207ABC          	  1664:          JSR  CHKDUP
00:C727 A950            	  1665:          LDA  #SYMBOL_PROCEDURE
00:C729 20D3BB          	  1666:          JSR  ADDSYM
00:C72C E622            	  1667:          INC  LEVEL
00:C72E A540            	  1668:          LDA  SYMITM
00:C730 8539            	  1669:          STA  PRCITM    ; PRCITM is the symbol of the procedure/function
00:C732 A541            	  1670:          LDA  SYMITM+1
00:C734 853A            	  1671:          STA  PRCITM+1
00:C736 4C5BC7          	  1672:          JMP  BLKPR1
                        	  1673: ;
                        	  1674: ; FUNCTION DECLARATION
                        	  1675: ;
00:C739 A949            	  1676: BLKFNC   LDA  #TOKEN_IDENTIFIER
00:C73B A204            	  1677:          LDX  #4      ; ERROR: Identifier expected
00:C73D 20D5D1          	  1678:          JSR  GETCHK
00:C740 207ABC          	  1679:          JSR  CHKDUP
00:C743 A946            	  1680:          LDA  #SYMBOL_FUNCTION
00:C745 20D3BB          	  1681:          JSR  ADDSYM
00:C748 E622            	  1682:          INC  LEVEL
00:C74A A901            	  1683:          LDA  #1
00:C74C 854B            	  1684:          STA  COUNT1    ; we have the function return as a symbol
00:C74E A540            	  1685:          LDA  SYMITM
00:C750 8539            	  1686:          STA  PRCITM   ; PRCITM is the symbol of the procedure/function
00:C752 A541            	  1687:          LDA  SYMITM+1
00:C754 853A            	  1688:          STA  PRCITM+1
00:C756 A959            	  1689:          LDA  #SYMBOL_FUNCTION_RETURN ; for assigning the results to
00:C758 20D3BB          	  1690:          JSR  ADDSYM
                        	  1691: ;
                        	  1692: ; PROCEDURE AND FUNCTION COMMON CODE
                        	  1693: ;
00:C75B A54B            	  1694: BLKPR1   LDA  COUNT1
00:C75D 854C            	  1695:          STA  COUNT2    ; remember if we had 0 or 1 extra symbols (function return)
00:C75F 2063C5          	  1696:          JSR  END_WRK
00:C762 209F94          	  1697:          JSR  PSHWRK
00:C765 A520            	  1698:          LDA  FRAME
00:C767 8537            	  1699:          STA  WORK
00:C769 A521            	  1700:          LDA  FRAME+1
00:C76B 8538            	  1701:          STA  WORK+1
00:C76D 209F94          	  1702:          JSR  PSHWRK
00:C770 2081D1          	  1703:          JSR  pas_get_token
00:C773 C928            	  1704:          CMP  #'('      ; opening bracket after procedure/function name?
00:C775 D016            	  1705:          BNE  BLKPR2
00:C777 2081D1          	  1706: BLKPR3   JSR  pas_get_token
00:C77A 2033BE          	  1707:          JSR  VARDEC
00:C77D E64B            	  1708:          INC  COUNT1    ; count arguments
00:C77F 1003            	  1709:          BPL  BLKPR6
00:C781 4C5AC6          	  1710:          JMP  BLKV13
00:C784 A593            	  1711: BLKPR6   LDA  token_type
00:C786 C92C            	  1712:          CMP  #','
00:C788 F0ED            	  1713:          BEQ  BLKPR3
00:C78A 20E2BC          	  1714:          JSR  CHKRHP
00:C78D A539            	  1715: BLKPR2   LDA  PRCITM      ; here after argument list, if any
00:C78F 8537            	  1716:          STA  WORK
00:C791 A53A            	  1717:          LDA  PRCITM+1
00:C793 8538            	  1718:          STA  WORK+1
00:C795 A006            	  1719:          LDY  #SYMARG
00:C797 A54B            	  1720:          LDA  COUNT1
00:C799 38              	  1721:          SEC
00:C79A E54C            	  1722:          SBC  COUNT2      ; subtract 0 or 1 depending on if this is a function or not
00:C79C 9137            	  1723:          STA  (WORK),Y    ; store the number of arguments to this procedure/function
00:C79E A93B            	  1724:          LDA  #';'
00:C7A0 A20A            	  1725:          LDX  #10         ; ERROR: ; expected
00:C7A2 20E5D1          	  1726:          JSR  CHKTKN
00:C7A5 A54B            	  1727:          LDA  COUNT1
00:C7A7 F02C            	  1728:          BEQ  BLKPR4
00:C7A9 2063C5          	  1729:          JSR  END_WRK     ; ENDSYM -> WORK
00:C7AC A2FD            	  1730:          LDX  #$FD        ; X = -3
                        	  1731: ; WORK starts off pointing to the procedure/function symbol
                        	  1732: BLKPR5   = *
00:C7AE A008            	  1733:          LDY  #SYMDAT
00:C7B0 A900            	  1734:          LDA  #0
00:C7B2 9137            	  1735:          STA  (WORK),Y    ; data type = integer
00:C7B4 A004            	  1736:          LDY  #SYMDSP
00:C7B6 8A              	  1737:          TXA
00:C7B7 9137            	  1738:          STA  (WORK),Y
00:C7B9 38              	  1739:          SEC
00:C7BA E903            	  1740:          SBC  #3
00:C7BC AA              	  1741:          TAX
00:C7BD A9FF            	  1742:          LDA  #$FF
00:C7BF C8              	  1743:          INY
00:C7C0 9137            	  1744:          STA  (WORK),Y
00:C7C2 C64B            	  1745:          DEC  COUNT1
00:C7C4 F00F            	  1746:          beq  BLKPR4
                        	  1747: ;
                        	  1748: ;  back to previous symbol
                        	  1749: ;
00:C7C6 A000            	  1750:          LDY  #SYMPRV
00:C7C8 B137            	  1751:          LDA  (WORK),Y
00:C7CA 48              	  1752:          PHA
00:C7CB C8              	  1753:          INY
00:C7CC B137            	  1754:          LDA  (WORK),Y
00:C7CE 8538            	  1755:          STA  WORK+1
00:C7D0 68              	  1756:          PLA
00:C7D1 8537            	  1757:          STA  WORK
00:C7D3 80D9            	  1758:          bra  BLKPR5
00:C7D5 2081D1          	  1759: BLKPR4   JSR  pas_get_token
00:C7D8 207EC5          	  1760:          JSR  BLOCK
00:C7DB C622            	  1761:          DEC  LEVEL
00:C7DD 20B294          	  1762:          JSR  PULWRK
00:C7E0 A537            	  1763:          LDA  WORK
00:C7E2 8520            	  1764:          STA  FRAME
00:C7E4 A538            	  1765:          LDA  WORK+1
00:C7E6 8521            	  1766:          STA  FRAME+1
00:C7E8 20B294          	  1767:          JSR  PULWRK
00:C7EB A537            	  1768:          LDA  WORK
00:C7ED 8531            	  1769:          STA  ENDSYM
00:C7EF A538            	  1770:          LDA  WORK+1
00:C7F1 8532            	  1771:          STA  ENDSYM+1
00:C7F3 A93B            	  1772:          LDA  #';'
00:C7F5 A20A            	  1773:          LDX  #10       ; ERROR: ; expected
00:C7F7 2047C5          	  1774:          JSR  CHKGET
00:C7FA A274            	  1775:          LDX  #<BLCKT3
00:C7FC A0C5            	  1776:          LDY  #>BLCKT3
00:C7FE 4CBBC5          	  1777:          JMP  BLK4
                        	  1778: ;
                        	  1779: ; BEGIN (COMPOUND STATEMENT)
                        	  1780: ;
00:C801 2081D1          	  1781: BLKBEG   JSR  pas_get_token
00:C804 20B294          	  1782:          JSR  PULWRK
00:C807 A522            	  1783:          LDA  LEVEL
00:C809 D006            	  1784:          BNE  BLKB1
00:C80B 205CCA          	  1785: BLKB3    JSR  FIXAD
00:C80E 4C2DC8          	  1786:          JMP  BLKB2
00:C811 2050BD          	  1787: BLKB1    JSR  WRKSYM
00:C814 A004            	  1788:          LDY  #SYMDSP
00:C816 B140            	  1789:          LDA  (SYMITM),Y
00:C818 8537            	  1790:          STA  WORK
00:C81A C8              	  1791:          INY
00:C81B B140            	  1792:          LDA  (SYMITM),Y
00:C81D 8538            	  1793:          STA  WORK+1
00:C81F A004            	  1794:          LDY  #SYMDSP
00:C821 A523            	  1795:          LDA  PCODE
00:C823 9140            	  1796:          STA  (SYMITM),Y
00:C825 A524            	  1797:          LDA  PCODE+1
00:C827 C8              	  1798:          INY
00:C828 9140            	  1799:          STA  (SYMITM),Y
00:C82A 4C0BC8          	  1800:          JMP  BLKB3
00:C82D A520            	  1801: BLKB2    LDA  FRAME
00:C82F 852B            	  1802:          STA  OPND
00:C831 A521            	  1803:          LDA  FRAME+1
00:C833 852C            	  1804:          STA  OPND+1
00:C835 A93B            	  1805:          LDA  #PCODE_INT         ; INT      Increment stack pointer
00:C837 202ECA          	  1806:          JSR  GENJMP
00:C83A 2065C0          	  1807: BLKB5    JSR  STMNT
00:C83D A593            	  1808:          LDA  token_type
00:C83F C93B            	  1809:          CMP  #';'
00:C841 D006            	  1810:          BNE  BLKB4
00:C843 2081D1          	  1811:          JSR  pas_get_token
00:C846 4C3AC8          	  1812:          JMP  BLKB5
00:C849 A989            	  1813: BLKB4    LDA  #TOKEN_END       ; END
00:C84B A211            	  1814:          LDX  #17         ; ERROR: ; or END expected
00:C84D 2047C5          	  1815:          JSR  CHKGET
00:C850 A929            	  1816:          LDA  #PCODE_RTN  ; OK - we are at the end of a block - this is a procedure/function return
00:C852 A622            	  1817:          LDX  LEVEL       ; OR - if we are at level 0, then that is the end of the program
00:C854 D002            	  1818:          BNE  BLKB6
00:C856 A911            	  1819:          LDA  #PCODE_FINISHD        ; Opcode: FINISHED  Stop run (end program)
                        	  1820: TEST1    =  *
00:C858 4CA5C9          	  1821: BLKB6    JMP  GENNOP
                        	  1822: ;
                        	  1823: 
                        	  1824: 
                        	  1825: ;
                        	  1826: ;  Writing library functions is quite easy:
                        	  1827: ;
                        	  1828: ;   1. For each of the n arguments that they have (could be zero) do a PULTOP to get
                        	  1829: ;      that value from the runtime stack into REG. Or, PULTOP2 to get the value into REG2.
                        	  1830: ;      For two arguments you can do PULBOTH to get them into REG and REG2.
                        	  1831: ;   2. Do whatever the function/procedure is supposed to do with those arguments
                        	  1832: ;   3. If a procedure, you are finished: JMP MAIN
                        	  1833: ;      For a function, put the result into REG, and then JMP MAINP
                        	  1834: ;      - or - (equivalently): JSR PSHTOP, JMP MAIN
                        	  1835: ;
                        	  1836: ;  Note: PULTOP puts the value into REG and also: A, X and Y registers where A is the low-order
                        	  1837: ;        byte, X the middle byte, and Y the high-order byte.
                        	  1838: ;
                        	  1839: 
                        	  1840: ;                         Name           function or procedure   Args Execution address
                        	  1841: pascal_library_functions_table:
                        	  1842: ;
                        	  1843: ;    functions
                        	  1844: ;
                        	  1845:   makePasLibraryFunction "ABS",          SYMBOL_LIBRARY_FUNCTION,  1, EX_ABS
00:C85B 414253          	     1M      asciiz   "ABS"
00:C85E 00
00:C85F 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:C860 01              	     3M      dfb      1
00:C861 2DB3            	     4M      word     EX_ABS
                        	  1846:   makePasLibraryFunction "DIGITALREAD",  SYMBOL_LIBRARY_FUNCTION,  1, EX_DIGITALREAD
00:C863 4449474954414C52	     1M      asciiz   "DIGITALREAD"
00:C86B 454144
00:C86E 00
00:C86F 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:C870 01              	     3M      dfb      1
00:C871 A7B7            	     4M      word     EX_DIGITALREAD
                        	  1847:   makePasLibraryFunction "GETKEY",       SYMBOL_LIBRARY_FUNCTION,  0, EX_GETKEY
00:C873 4745544B4559    	     1M      asciiz   "GETKEY"
00:C879 00
00:C87A 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:C87B 00              	     3M      dfb      0
00:C87C E7B2            	     4M      word     EX_GETKEY
                        	  1848:   makePasLibraryFunction "RANDOM",       SYMBOL_LIBRARY_FUNCTION,  0, EX_RANDOM
00:C87E 52414E444F4D    	     1M      asciiz   "RANDOM"
00:C884 00
00:C885 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:C886 00              	     3M      dfb      0
00:C887 CFB7            	     4M      word     EX_RANDOM
                        	  1849:   makePasLibraryFunction "LATENCY",      SYMBOL_LIBRARY_FUNCTION,  0, EX_LATENCY
00:C889 4C4154454E4359  	     1M      asciiz   "LATENCY"
00:C890 00
00:C891 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:C892 00              	     3M      dfb      0
00:C893 E1B7            	     4M      word     EX_LATENCY
                        	  1850: ;
                        	  1851: ;      procedures
                        	  1852: ;
                        	  1853:   makePasLibraryFunction "ASSERT",       SYMBOL_LIBRARY_PROCEDURE, 1, EX_ASSERT
00:C895 415353455254    	     1M      asciiz   "ASSERT"
00:C89B 00
00:C89C 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C89D 01              	     3M      dfb      1
00:C89E 34B8            	     4M      word     EX_ASSERT
                        	  1854:   makePasLibraryFunction "DELAY",        SYMBOL_LIBRARY_PROCEDURE, 1, EX_DELAY
00:C8A0 44454C4159      	     1M      asciiz   "DELAY"
00:C8A5 00
00:C8A6 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C8A7 01              	     3M      dfb      1
00:C8A8 F0B7            	     4M      word     EX_DELAY
                        	  1855:   makePasLibraryFunction "DIGITALWRITE", SYMBOL_LIBRARY_PROCEDURE, 2, EX_DIGITALWRITE
00:C8AA 4449474954414C57	     1M      asciiz   "DIGITALWRITE"
00:C8B2 52495445
00:C8B6 00
00:C8B7 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C8B8 02              	     3M      dfb      2
00:C8B9 1FB8            	     4M      word     EX_DIGITALWRITE
                        	  1856:   makePasLibraryFunction "LCDCLEAR",     SYMBOL_LIBRARY_PROCEDURE, 0, EX_LCDCLEAR
00:C8BB 4C4344434C454152	     1M      asciiz   "LCDCLEAR"
00:C8C3 00
00:C8C4 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C8C5 00              	     3M      dfb      0
00:C8C6 19B7            	     4M      word     EX_LCDCLEAR
                        	  1857:   makePasLibraryFunction "LCDHOME",      SYMBOL_LIBRARY_PROCEDURE, 0, EX_LCDHOME
00:C8C8 4C4344484F4D45  	     1M      asciiz   "LCDHOME"
00:C8CF 00
00:C8D0 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C8D1 00              	     3M      dfb      0
00:C8D2 13B7            	     4M      word     EX_LCDHOME
                        	  1858:   makePasLibraryFunction "LCDPOS",       SYMBOL_LIBRARY_PROCEDURE, 2, EX_LCDPOS
00:C8D4 4C4344504F53    	     1M      asciiz   "LCDPOS"
00:C8DA 00
00:C8DB 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C8DC 02              	     3M      dfb      2
00:C8DD B5B7            	     4M      word     EX_LCDPOS
                        	  1859:   makePasLibraryFunction "PINMODE",      SYMBOL_LIBRARY_PROCEDURE, 2, EX_PINMODE
00:C8DF 50494E4D4F4445  	     1M      asciiz   "PINMODE"
00:C8E6 00
00:C8E7 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C8E8 02              	     3M      dfb      2
00:C8E9 10B8            	     4M      word     EX_PINMODE
                        	  1860:   makePasLibraryFunction "RANDOMSEED",   SYMBOL_LIBRARY_PROCEDURE, 1, EX_RANDOMSEED
00:C8EB 52414E444F4D5345	     1M      asciiz   "RANDOMSEED"
00:C8F3 4544
00:C8F5 00
00:C8F6 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C8F7 01              	     3M      dfb      1
00:C8F8 00B8            	     4M      word     EX_RANDOMSEED
00:C8FA 00              	  1861:   dfb 0   ; end of table
                        	  1862: 
                        	  1863: add_pascal_library_functions:
00:C8FB A95B            	  1864:   lda #<pascal_library_functions_table
00:C8FD 8500            	  1865:   sta REG
00:C8FF A9C8            	  1866:   lda #>pascal_library_functions_table
00:C901 8501            	  1867:   sta REG+1
                        	  1868: add_pascal_library_functions_loop:
00:C903 A000            	  1869:   ldy #0
00:C905 B100            	  1870:   lda (REG),Y
00:C907 F04B            	  1871:   beq add_pascal_library_functions_done
00:C909 A500            	  1872:   lda REG
00:C90B 8590            	  1873:   sta token_address
00:C90D A501            	  1874:   lda REG+1
00:C90F 8591            	  1875:   sta token_address+1
00:C911 6492            	  1876:   stz token_length
                        	  1877: ;
                        	  1878: ;  find name length
                        	  1879: ;
                        	  1880: add_pascal_library_functions_name_loop
00:C913 C8              	  1881:   iny
00:C914 E692            	  1882:   inc token_length
00:C916 B100            	  1883:   lda (REG),Y
00:C918 D0F9            	  1884:   bne add_pascal_library_functions_name_loop
00:C91A 5A              	  1885:   phy
00:C91B A943            	  1886:   lda #SYMBOL_CONSTANT  ; add the symbol as a constant for now
00:C91D 20D3BB          	  1887:   jsr ADDSYM
00:C920 7A              	  1888:   ply
                        	  1889: 
00:C921 C8              	  1890:   iny             ; get past the 0x00
00:C922 B100            	  1891:   lda (REG),Y     ; get symbol type
00:C924 5A              	  1892:   phy
00:C925 A003            	  1893:   ldy #SYMTYP
00:C927 9140            	  1894:   sta (SYMITM),Y  ; change symbol type to be correct
00:C929 7A              	  1895:   ply
                        	  1896: 
00:C92A C8              	  1897:   iny             ; get next byte
00:C92B B100            	  1898:   lda (REG),Y     ; get number of arguments
00:C92D 5A              	  1899:   phy
00:C92E A006            	  1900:   ldy #SYMARG
00:C930 9140            	  1901:   sta (SYMITM),Y  ; save number of arguments
00:C932 7A              	  1902:   ply
                        	  1903: 
00:C933 C8              	  1904:   iny             ; get next byte
00:C934 B100            	  1905:   lda (REG),Y     ; get function address low-byte
00:C936 5A              	  1906:   phy
00:C937 A004            	  1907:   ldy #SYMDSP
00:C939 9140            	  1908:   sta (SYMITM),Y  ; save function address low-byte
00:C93B 7A              	  1909:   ply
                        	  1910: 
00:C93C C8              	  1911:   iny             ; get next byte
00:C93D B100            	  1912:   lda (REG),Y     ; get function address high-byte
00:C93F 5A              	  1913:   phy
00:C940 A005            	  1914:   ldy #SYMDSP+1
00:C942 9140            	  1915:   sta (SYMITM),Y  ; save function address high-byte
00:C944 7A              	  1916:   ply
                        	  1917: 
00:C945 C8              	  1918:   iny         ; get past that last byte
00:C946 98              	  1919:   tya         ; move REG onto next entry
00:C947 18              	  1920:   clc
00:C948 6500            	  1921:   adc REG
00:C94A 8500            	  1922:   sta REG
00:C94C A900            	  1923:   lda #0
00:C94E 6501            	  1924:   adc REG+1
00:C950 8501            	  1925:   sta REG+1
00:C952 80AF            	  1926:   bra add_pascal_library_functions_loop
                        	  1927: 
                        	  1928: add_pascal_library_functions_done:
00:C954 60              	  1929:   rts
                        	  1930: 
                        	  1931: 
                        	  1932: library_function_call:
                        	  1933: 
00:C955 A900            	  1934:   lda  #0
00:C957 854B            	  1935:   sta  COUNT1      ; number of arguments
00:C959 A006            	  1936:   ldy  #SYMARG
00:C95B B140            	  1937:   lda  (SYMITM),Y
00:C95D F032            	  1938:   beq  library_function_call_1
                        	  1939: 
                        	  1940: ;
                        	  1941: ;  here if it has arguments - push them on the stack
                        	  1942: ;
                        	  1943: 
00:C95F 20DBBC          	  1944:   jsr  CHKLHP
                        	  1945: library_function_call_2
00:C962 A54B            	  1946:   lda  COUNT1    ; save on stack in case the expression calls functions
00:C964 48              	  1947:   pha
00:C965 2045BD          	  1948:   jsr  SYMWRK
00:C968 209F94          	  1949:   jsr  PSHWRK
00:C96B 2099BD          	  1950:   jsr  GETEXPR
00:C96E 20B294          	  1951:   jsr  PULWRK
00:C971 2050BD          	  1952:   jsr  WRKSYM
00:C974 68              	  1953:   pla            ; get number of arguments back
00:C975 854B            	  1954:   sta  COUNT1
00:C977 E64B            	  1955:   inc  COUNT1    ; add 1 for the one we just processed
00:C979 A593            	  1956:   lda  token_type
00:C97B C92C            	  1957:   cmp  #','
00:C97D F0E3            	  1958:   beq  library_function_call_2
                        	  1959: 
00:C97F A54B            	  1960:   lda  COUNT1
00:C981 A006            	  1961:   ldy  #SYMARG
00:C983 D140            	  1962:   cmp  (SYMITM),Y   ; check we got the right number of arguments
00:C985 F005            	  1963:   beq  library_function_call_3
                        	  1964: 
00:C987 A223            	  1965:   ldx  #35     ; ERROR: Parameters mismatched
00:C989 4CAB99          	  1966:   jmp  ERROR
                        	  1967: library_function_call_3:
00:C98C 20E2BC          	  1968:   jsr  CHKRHP
00:C98F 8003            	  1969:   bra  library_function_call_5
                        	  1970: 
                        	  1971: ;
                        	  1972: ;  here for no arguments
                        	  1973: ;
                        	  1974: 
                        	  1975: library_function_call_1:
00:C991 2081D1          	  1976:   jsr  pas_get_token      ; one token look-ahead
                        	  1977: 
                        	  1978: library_function_call_5:
00:C994 A004            	  1979:   ldy  #SYMDSP
00:C996 B140            	  1980:   lda  (SYMITM),Y
00:C998 852B            	  1981:   sta  OPND
00:C99A C8              	  1982:   iny
00:C99B B140            	  1983:   lda  (SYMITM),Y
00:C99D 852C            	  1984:   sta  OPND+1
00:C99F A903            	  1985:   lda  #PCODE_LIB_CALL
00:C9A1 202ECA          	  1986:   jsr  GENJMP
00:C9A4 60              	  1987:   rts
                        	  1988: 
                        	  1989: 
                        	  1990: ;***********************************************
                        	  1991: ; GENERATE P-CODES - NO OPERANDS
                        	  1992: ;***********************************************
                        	  1993: GENNOP   =  *
00:C9A5 A442            	  1994:          LDY  SYNTAX
00:C9A7 D011            	  1995:          BNE  GEN1      ; no storing/displaying if syntax-only compile
00:C9A9 9123            	  1996:          STA  (PCODE),Y
00:C9AB 48              	  1997:          PHA
00:C9AC 208394          	  1998:          JSR  DISPAD
00:C9AF 68              	  1999:          PLA
00:C9B0 A62E            	  2000:          LDX  DCODE
00:C9B2 F006            	  2001:          BEQ  GEN1
00:C9B4 207D94          	  2002:          JSR  DISHX
00:C9B7 206894          	  2003:          JSR  CROUT
                        	  2004: GEN1     =  *
00:C9BA A901            	  2005:          LDA  #1      ; 1-byte P-code
00:C9BC D035            	  2006:          BNE  GEN2_B
                        	  2007: ;***********************************************
                        	  2008: ; GENERATE P-CODES - WITH ADDRESS (3-bytes stored in DISPL (1)/OFFSET(2))
                        	  2009: ;***********************************************
                        	  2010: GENADR   =  *
00:C9BE A442            	  2011:          LDY  SYNTAX
00:C9C0 D02F            	  2012:          BNE  GEN2    ; no storing/displaying if syntax-only compile
00:C9C2 9123            	  2013:          STA  (PCODE),Y
00:C9C4 48              	  2014:          PHA
00:C9C5 A527            	  2015:          LDA  DISPL
00:C9C7 C8              	  2016:          INY
00:C9C8 9123            	  2017:          STA  (PCODE),Y
00:C9CA A529            	  2018:          LDA  OFFSET
00:C9CC C8              	  2019:          INY
00:C9CD 9123            	  2020:          STA  (PCODE),Y
00:C9CF A52A            	  2021:          LDA  OFFSET+1
00:C9D1 C8              	  2022:          INY
00:C9D2 9123            	  2023:          STA  (PCODE),Y
00:C9D4 208394          	  2024:          JSR  DISPAD
00:C9D7 68              	  2025:          PLA
00:C9D8 A62E            	  2026:          LDX  DCODE
00:C9DA F015            	  2027:          BEQ  GEN2
00:C9DC 207D94          	  2028:          JSR  DISHX
00:C9DF A527            	  2029:          LDA  DISPL
00:C9E1 207D94          	  2030:          JSR  DISHX
00:C9E4 A529            	  2031:          LDA  OFFSET
00:C9E6 207D94          	  2032:          JSR  DISHX
00:C9E9 A52A            	  2033:          LDA  OFFSET+1
00:C9EB 207D94          	  2034:          JSR  DISHX
00:C9EE 206894          	  2035:          JSR  CROUT
                        	  2036: GEN2     =  *
00:C9F1 A904            	  2037:          LDA  #4      ; 4-byte P-code
                        	  2038: GEN2_B   =  *
00:C9F3 18              	  2039:          CLC
00:C9F4 6523            	  2040:          ADC  PCODE
00:C9F6 8523            	  2041:          STA  PCODE
00:C9F8 9002            	  2042:          BCC  GEN2_A
00:C9FA E624            	  2043:          INC  PCODE+1
                        	  2044: GEN2_A   =  *
00:C9FC A542            	  2045:          LDA  SYNTAX
00:C9FE D013            	  2046:          BNE  GEN2_C      ; no storing/displaying if syntax-only compile
00:CA00 A524            	  2047:          LDA  PCODE+1     ; see if P-codes full
00:CA02 C532            	  2048:          CMP  ENDSYM+1   ; in other words, have we hit the symbol table?
00:CA04 900D            	  2049:          BCC  GEN2_C      ; less than
00:CA06 D006            	  2050:          BNE  GEN_FULL
00:CA08 A523            	  2051:          LDA  PCODE
00:CA0A C531            	  2052:          CMP  ENDSYM   ; TODO - what?
00:CA0C 9005            	  2053:          BCC  GEN2_C
00:CA0E A201            	  2054: GEN_FULL LDX  #1         ; MEM FULL
00:CA10 4CAB99          	  2055:          jmp  ERROR
                        	  2056: GEN2_C   =  *
00:CA13 60              	  2057: DISP9    RTS
                        	  2058: ;***********************************************
                        	  2059: ; GENERATE P-CODES - JUMP ADDRESS (relative to current P-code address in OPND)
                        	  2060: ;***********************************************
                        	  2061: GENRJMP  =  *
00:CA14 48              	  2062:          PHA
00:CA15 A52B            	  2063:          LDA  OPND
00:CA17 38              	  2064:          SEC
00:CA18 E523            	  2065:          SBC  PCODE
00:CA1A 852B            	  2066:          STA  OPND      ; subtract P-code address to find difference
00:CA1C A52C            	  2067:          LDA  OPND+1
00:CA1E E524            	  2068:          SBC  PCODE+1
00:CA20 852C            	  2069:          STA  OPND+1
00:CA22 68              	  2070:          PLA
00:CA23 4C2ECA          	  2071:          JMP  GENJMP
                        	  2072: ;
                        	  2073: GENNJP   =  *
00:CA26 A93C            	  2074:          LDA  #PCODE_JMP       ; JMP
                        	  2075: 
                        	  2076: ; Generate jump, P-code is in "A" register (eg. PCODE_JMZ, PCODE_JM1)
                        	  2077: ;
                        	  2078: ;  Note: the destination here is 0000, however FIXAD will be called later to fix up
                        	  2079: ;        the jump, once we know what the destination will be (ie. further down the code)
                        	  2080: ;
00:CA28 A200            	  2081: GENNJM   LDX  #0
00:CA2A 862B            	  2082:          STX  OPND
00:CA2C 862C            	  2083:          STX  OPND+1
                        	  2084: ;
                        	  2085: ;***********************************************
                        	  2086: ; GENERATE P-CODES - JUMP ADDRESS (absolute address in OPND)
                        	  2087: ;   also used in other places, like increment stack address
                        	  2088: ;***********************************************
                        	  2089: GENJMP   =  *
00:CA2E A442            	  2090:          LDY  SYNTAX
00:CA30 D025            	  2091:          BNE  GEN3     ; no storing/displaying if syntax-only compile
00:CA32 9123            	  2092:          STA  (PCODE),Y
00:CA34 48              	  2093:          PHA
00:CA35 A52B            	  2094:          LDA  OPND
00:CA37 C8              	  2095:          INY
00:CA38 9123            	  2096:          STA  (PCODE),Y
00:CA3A A52C            	  2097:          LDA  OPND+1
00:CA3C C8              	  2098:          INY
00:CA3D 9123            	  2099:          STA  (PCODE),Y
00:CA3F 208394          	  2100:          JSR  DISPAD
00:CA42 68              	  2101:          PLA
00:CA43 A62E            	  2102:          LDX  DCODE
00:CA45 F010            	  2103:          BEQ  GEN3
00:CA47 207D94          	  2104:          JSR  DISHX
00:CA4A A52B            	  2105:          LDA  OPND
00:CA4C 207D94          	  2106:          JSR  DISHX
00:CA4F A52C            	  2107:          LDA  OPND+1
00:CA51 207D94          	  2108:          JSR  DISHX
00:CA54 206894          	  2109:          JSR  CROUT
                        	  2110: GEN3     =  *
00:CA57 A903            	  2111:          LDA  #3        ; 3-byte P-code
00:CA59 4CF3C9          	  2112:          JMP  GEN2_B
                        	  2113: 
                        	  2114: ;***********************************************
                        	  2115: ; FIXUP ADDRESSES
                        	  2116: ;***********************************************
                        	  2117: FIXAD    =  *
00:CA5C A442            	  2118:          LDY  SYNTAX
00:CA5E D039            	  2119:          BNE  FIXAD1
00:CA60 A001            	  2120:          LDY  #1
00:CA62 A523            	  2121:          LDA  PCODE
00:CA64 38              	  2122:          SEC
00:CA65 E537            	  2123:          SBC  WORK
00:CA67 9137            	  2124:          STA  (WORK),Y
00:CA69 C8              	  2125:          INY
00:CA6A A524            	  2126:          LDA  PCODE+1
00:CA6C E538            	  2127:          SBC  WORK+1
00:CA6E 9137            	  2128:          STA  (WORK),Y
00:CA70 A52E            	  2129:          LDA  DCODE
00:CA72 F025            	  2130:          BEQ  FIXAD1
00:CA74 A99A            	  2131:          LDA  #<FIXM1
00:CA76 A2CA            	  2132:          LDX  #>FIXM1
00:CA78 202682          	  2133:          JSR  print
00:CA7B A538            	  2134:          LDA  WORK+1
00:CA7D 20DD94          	  2135:          JSR  PRBYTE
00:CA80 A537            	  2136:          LDA  WORK
00:CA82 207D94          	  2137:          JSR  DISHX
00:CA85 A9A3            	  2138:          LDA  #<FIXM2
00:CA87 A2CA            	  2139:          LDX  #>FIXM2
00:CA89 202682          	  2140:          JSR  print
00:CA8C A524            	  2141:          LDA  PCODE+1
00:CA8E 20DD94          	  2142:          JSR  PRBYTE
00:CA91 A523            	  2143:          LDA  PCODE
00:CA93 207D94          	  2144:          JSR  DISHX
00:CA96 4C6894          	  2145:          JMP  CROUT
00:CA99 60              	  2146: FIXAD1    rts
                        	  2147: 
00:CA9A 4A756D7020617420	  2148: FIXM1    asciiz  'Jump at '
00:CAA2 00
00:CAA3 6368616E67656420	  2149: FIXM2    asciiz  'changed to '   ; changed to
00:CAAB 746F20
00:CAAE 00
                        	  2150: 
                        	  2151: 

Source: "gpascal.asm"
                        	   188:   .include "hardware.inc"

Source: "hardware.inc"
                        	     1: 
                        	     2: ; VIA - Versatile Interface Adapter (W65C22) hardware
                        	     3: 
                        	     4: VIA_PORTB   = $7FF0   ; input/output register "B"
                        	     5: VIA_PORTA   = $7FF1   ; input/output register "A"
                        	     6: VIA_DDRB    = $7FF2   ; data direction register "B"
                        	     7: VIA_DDRA    = $7FF3   ; data direction register "A"
                        	     8: VIA_T1C_L   = $7FF4   ; T1 write: latch (L), read: counter (L)
                        	     9: VIA_T1C_H   = $7FF5   ; T1 high_order counter
                        	    10: VIA_T1L_L   = $7FF6   ; T1 low_order latches
                        	    11: VIA_T1L_H   = $7FF7   ; T1 high_order latches
                        	    12: VIA_T2C_L   = $7FF8   ; T2 write: latch (L), read: counter (L)
                        	    13: VIA_T2C_H   = $7FF9   ; T2 high_order counter
                        	    14: VIA_SR      = $7FFA   ; shift register
                        	    15: VIA_ACR     = $7FFB   ; auxilliary control register
                        	    16: VIA_PCR     = $7FFC   ; peripheral control register
                        	    17: VIA_IFR     = $7FFD   ; interrupt flag register
                        	    18: VIA_IER     = $7FFE   ; interrupt enable register
                        	    19: 
                        	    20: VIA_FLAG_ENABLE   = %10000000 ; high-order bit set enables the flag
                        	    21: VIA_FLAG_DISABLE  = %00000000 ; high-order bit clear disables the flag
                        	    22: VIA_FLAG_TIMER1   = %01000000
                        	    23: VIA_FLAG_TIMER2   = %00100000
                        	    24: VIA_FLAG_CB1      = %00010000
                        	    25: VIA_FLAG_CB2      = %00001000
                        	    26: VIA_FLAG_SHIFT    = %00000100
                        	    27: VIA_FLAG_CA1      = %00000010
                        	    28: VIA_FLAG_CA2      = %00000001
                        	    29: 
                        	    30: ;
                        	    31: ; VIA Port A pin masks
                        	    32: ;
                        	    33: 
                        	    34: SERIAL_IN_MASK     = %00000001   ; serial in on PA0 (also connect to CB2) (to FTDI TxD pin - pin 4)
                        	    35: SERIAL_OUT_MASK    = %00000010   ; serial out on PA1 (to FTDI RxD pin - pin 5)
                        	    36: SERIAL_DEBUG1_MASK = %00000100   ; serial debugging on PA2
                        	    37: SERIAL_DEBUG2_MASK = %00001000   ; serial debugging on PA3
                        	    38: SERIAL_SPARE2_MASK = %00010000   ; spare VIA pins (PA4)
                        	    39: 
                        	    40: 
                        	    41: ;***********************************************
                        	    42: ;  Functions added for Ben's Board
                        	    43: ;***********************************************
                        	    44: 
                        	    45: ;
                        	    46: ;  Converts a pin number in the range 0 to 15 to a mask
                        	    47: ;  eg. 00000001, 00000010, 00000100 and so on
                        	    48: ;
                        	    49: ;  Returns mask in Y
                        	    50: ;
                        	    51: ;  Returns with Z set if the range was 0 to 7 an
                        	    52: ;  and Z clear if the range was 8 to 15
                        	    53: ;
                        	    54: pin_number_to_mask = *
00:CAAF 48              	    55:   pha         ; save for a moment
00:CAB0 2907            	    56:   and #$7     ; make in range 0 to 7
00:CAB2 A8              	    57:   tay
00:CAB3 A901            	    58:   lda #1      ; initial mask
                        	    59: pin_number_to_mask_loop:
00:CAB5 C000            	    60:   cpy #0
00:CAB7 F004            	    61:   beq pin_number_to_mask_done
00:CAB9 0A              	    62:   asl A
00:CABA 88              	    63:   dey
00:CABB 80F8            	    64:   bra pin_number_to_mask_loop
                        	    65: pin_number_to_mask_done:
00:CABD A8              	    66:   tay         ; save mask in Y
00:CABE 68              	    67:   pla
00:CABF 2908            	    68:   and #$8     ; DDRA or DDRB ?
00:CAC1 60              	    69:   rts
                        	    70: 
                        	    71: ;
                        	    72: ;  pin in A, mode in X
                        	    73: ;
                        	    74: pinmode:
00:CAC2 868C            	    75:   stx hardware_work ; input or output
00:CAC4 20AFCA          	    76:   jsr pin_number_to_mask  ; convert to appropriate mask bit
00:CAC7 D00A            	    77:   bne pinmode_B        ; Z is clear if it is DDRB
00:CAC9 A9F3            	    78:   lda #<VIA_DDRA
00:CACB 8500            	    79:   sta REG
00:CACD A97F            	    80:   lda #>VIA_DDRA
00:CACF 8501            	    81:   sta REG+1
00:CAD1 8008            	    82:   bra pinmode_C
                        	    83: pinmode_B:
00:CAD3 A9F2            	    84:   lda #<VIA_DDRB
00:CAD5 8500            	    85:   sta REG
00:CAD7 A97F            	    86:   lda #>VIA_DDRB
00:CAD9 8501            	    87:   sta REG+1
                        	    88: ;
                        	    89: ;  The DDR register is now in REG
                        	    90: ;
                        	    91: pinmode_C:
00:CADB A58C            	    92:   lda hardware_work     ; input or output?
00:CADD D00A            	    93:   bne pinmode_OUTPUT
                        	    94: ;
                        	    95: ;  here to set input mode
                        	    96: ;
00:CADF 98              	    97:   tya       ; get the mask back
00:CAE0 A000            	    98:   ldy #0
00:CAE2 49FF            	    99:   eor #$FF  ; negate the mask
00:CAE4 3100            	   100:   and (REG),y
00:CAE6 9100            	   101:   sta (REG),y
00:CAE8 60              	   102:   rts       ; done
                        	   103: ;
                        	   104: ;  here to set output mode
                        	   105: ;
                        	   106: pinmode_OUTPUT:
00:CAE9 98              	   107:   tya          ; get the mask back
00:CAEA A000            	   108:   ldy #0
00:CAEC 1100            	   109:   ora (REG),y  ; or in with the existing DDR register
00:CAEE 9100            	   110:   sta (REG),y  ; and write it back
00:CAF0 60              	   111:   rts          ; done
                        	   112: 
                        	   113: 
                        	   114: ;
                        	   115: ;  DIGITALWRITE (pin, value) pin:0 to 15; value: 0 or 1 : pin in A, mode in X
                        	   116: ;
                        	   117: digitalwrite = *
00:CAF1 868C            	   118:   stx hardware_work ; save what to write (0 or 1)
00:CAF3 20AFCA          	   119:   jsr pin_number_to_mask  ; convert to appropriate mask bit
00:CAF6 D00A            	   120:   bne digitalwrite_B        ; Z is clear if it is PORTB
00:CAF8 A9F1            	   121:   lda #<VIA_PORTA
00:CAFA 8500            	   122:   sta REG
00:CAFC A97F            	   123:   lda #>VIA_PORTA
00:CAFE 8501            	   124:   sta REG+1
00:CB00 8008            	   125:   bra digitalwrite_C
                        	   126: digitalwrite_B:
00:CB02 A9F0            	   127:   lda #<VIA_PORTB
00:CB04 8500            	   128:   sta REG
00:CB06 A97F            	   129:   lda #>VIA_PORTB
00:CB08 8501            	   130:   sta REG+1
                        	   131: ;
                        	   132: ;  The PORT register is now in REG
                        	   133: ;
                        	   134: digitalwrite_C:
00:CB0A A58C            	   135:   lda hardware_work
00:CB0C D00A            	   136:   bne digitalwrite_ONE  ; any non-zero value is writing a 1
                        	   137: ;
                        	   138: ;  here to write a zero
                        	   139: ;
00:CB0E 98              	   140:   tya
00:CB0F A000            	   141:   ldy #0
00:CB11 49FF            	   142:   eor #$FF  ; negate the mask
00:CB13 3100            	   143:   and (REG),y
00:CB15 9100            	   144:   sta (REG),y
00:CB17 60              	   145:   rts       ; done
                        	   146: 
                        	   147: ;
                        	   148: ;  here to write a one
                        	   149: ;
                        	   150: digitalwrite_ONE:
00:CB18 98              	   151:   tya          ; get the mask back
00:CB19 A000            	   152:   ldy #0
00:CB1B 1100            	   153:   ora (REG),y  ; or in with the existing DDR register
00:CB1D 9100            	   154:   sta (REG),y  ; and write it back
00:CB1F 60              	   155:   rts          ; done
                        	   156: 
                        	   157: 
                        	   158: ;
                        	   159: ;  DIGITALREAD (pin) pin:0 to 15; Pin to read is in in A. returns or non-zero in A.
                        	   160: ;
                        	   161: digitalread = *
00:CB20 20AFCA          	   162:   jsr pin_number_to_mask  ; convert to appropriate mask bit
00:CB23 D00A            	   163:   bne digitalread_B        ; Z is clear if it is PORTB
00:CB25 A9F1            	   164:   lda #<VIA_PORTA
00:CB27 8500            	   165:   sta REG
00:CB29 A97F            	   166:   lda #>VIA_PORTA
00:CB2B 8501            	   167:   sta REG+1
00:CB2D 8008            	   168:   bra digitalread_C
                        	   169: digitalread_B:
00:CB2F A9F0            	   170:   lda #<VIA_PORTB
00:CB31 8500            	   171:   sta REG
00:CB33 A97F            	   172:   lda #>VIA_PORTB
00:CB35 8501            	   173:   sta REG+1
                        	   174: ;
                        	   175: ;  The PORT register is now in REG
                        	   176: ;
                        	   177: digitalread_C:
00:CB37 98              	   178:   tya         ; get the mask back
00:CB38 A000            	   179:   ldy #0
00:CB3A 3100            	   180:   and (REG),y ; get that bit
00:CB3C 60              	   181:   rts
                        	   182: 
                        	   183: 
                        	   184: 
                        	   185: ;
                        	   186: ;  Functions to change where writing is done
                        	   187: ;
                        	   188: write_to_serial:
00:CB3D 48              	   189:   pha
00:CB3E A99D            	   190:   lda  #<write_char
00:CB40 8517            	   191:   sta  write_function
00:CB42 A9CB            	   192:   lda  #>write_char
00:CB44 8518            	   193:   sta  write_function+1
00:CB46 68              	   194:   pla
00:CB47 60              	   195:   rts
                        	   196: 
                        	   197: write_to_lcd:
00:CB48 48              	   198:   pha
00:CB49 A9F9            	   199:   lda  #<lcd_print_char
00:CB4B 8517            	   200:   sta  write_function
00:CB4D A9BA            	   201:   lda  #>lcd_print_char
00:CB4F 8518            	   202:   sta  write_function+1
00:CB51 68              	   203:   pla
00:CB52 60              	   204:   rts
                        	   205: 
                        	   206: 
                        	   207: 
                        	   208: ; ---------------------------
                        	   209: ; Simulate kernel interfaces
                        	   210: ; ---------------------------
                        	   211: ; We interface by reading/writing to special
                        	   212: ; RAM that is implemented in the emulator
                        	   213: 
                        	   214: 
                        	   215: 
                        	   216:     .if EMULATOR
                        	   217: 
                        	   218: ;
                        	   219: ;  Emulator testing
                        	   220: ;
                        	   221: CHRIN    =  *
                        	   222:          lda  $7F22
                        	   223:          rts
                        	   224: 
                        	   225: write_char   =  *
                        	   226:          sta  $7F23
                        	   227:          rts
                        	   228: 
                        	   229: 
                        	   230: GETIN    =  *
                        	   231:          lda  $7F29
                        	   232:          rts
                        	   233: 
                        	   234: hardware_init rts
                        	   235: 
                        	   236: ;
                        	   237: ;  put debug number in A
                        	   238: ;
                        	   239: EMULATOR_DEBUG = *
                        	   240:          sta $7F46
                        	   241:          rts
                        	   242: 
                        	   243: START_TRACE = *
                        	   244:          sta $7F47
                        	   245:          rts
                        	   246: 
                        	   247: STOP_TRACE = *
                        	   248:          sta $7F48
                        	   249:          rts
                        	   250: ;
                        	   251: ;  not applicable in emulator
                        	   252: ;
                        	   253: lcd_print_message   rts
                        	   254: lcd_clear_display   rts
                        	   255: lcd_print_char      rts
                        	   256: lcd_second_line     rts
                        	   257: lcd_instruction     rts
                        	   258: lcd_get_address     rts
                        	   259: lcd_wait            rts
                        	   260: lcd_home            rts
                        	   261: lcd_initialise      rts
                        	   262: serial_available    rts
                        	   263: serial_print_message rts
                        	   264: 
                        	   265:   .else
                        	   266: 
                        	   267: ;
                        	   268: ;  Ben's Board
                        	   269: ;
                        	   270: 
                        	   271: ;
                        	   272: ;  typing_latency could be used as a seed for the random number generator
                        	   273: ;    - the exact time between keypresses would be somewhat unpredictable
                        	   274: ;
                        	   275: CHRIN  = *
                        	   276: GETIN    =  *
00:CB53 E60D            	   277:          inc typing_latency
00:CB55 D006            	   278:          bne GETIN1
00:CB57 E60E            	   279:          inc typing_latency+1
00:CB59 D002            	   280:          bne GETIN1
00:CB5B E60F            	   281:          inc typing_latency+2
                        	   282: GETIN1:
00:CB5D A58B            	   283:          lda serial_in_byte_received
00:CB5F F0F2            	   284:          beq GETIN    ; nothing yet
00:CB61 648B            	   285:          stz serial_in_byte_received
00:CB63 60              	   286:          rts
                        	   287: 
                        	   288: serial_available = *
00:CB64 A58B            	   289:          lda serial_in_byte_received
00:CB66 60              	   290:          rts
                        	   291: 
                        	   292: 
00:CB67 60              	   293: EMULATOR_DEBUG rts
00:CB68 60              	   294: START_TRACE rts
00:CB69 60              	   295: STOP_TRACE rts
                        	   296: 
                        	   297: 
                        	   298: ;
                        	   299: ;  set up serial hardware
                        	   300: ;
                        	   301: 
                        	   302: hardware_init:
                        	   303: 
00:CB6A A902            	   304:   lda #SERIAL_OUT_MASK  ; set 1 bit (idle serial comms), and others to zero
00:CB6C 8DF17F          	   305:   sta VIA_PORTA
                        	   306: 
                        	   307:   ; set output enable bits
00:CB6F A91E            	   308:   lda #(SERIAL_OUT_MASK | SERIAL_DEBUG1_MASK | SERIAL_DEBUG2_MASK | SERIAL_SPARE2_MASK)
00:CB71 8DF37F          	   309:   sta VIA_DDRA
                        	   310: 
00:CB74 A940            	   311:   lda #%01000000      ; continuous interrupts on T1
00:CB76 8DFB7F          	   312:   sta VIA_ACR
                        	   313: 
00:CB79 A900            	   314:   lda #0              ; Input-negative active edge
00:CB7B 8DFC7F          	   315:   sta VIA_PCR
                        	   316: 
00:CB7E A9D0            	   317:   lda #<BIT_INTERVAL  ; ie. baud rate interval
00:CB80 8DF47F          	   318:   sta VIA_T1C_L       ; for sending bits
00:CB83 A900            	   319:   lda #>BIT_INTERVAL
00:CB85 8DF57F          	   320:   sta VIA_T1C_H       ; this starts the counter
                        	   321: 
                        	   322:   ; set up for serial input
                        	   323: 
00:CB88 A988            	   324:   lda #VIA_FLAG_ENABLE | VIA_FLAG_CB2  ; interrupt on CB2 falling edge
00:CB8A 8DFE7F          	   325:   sta VIA_IER
                        	   326: 
00:CB8D A9FF            	   327:   lda #$FF         ; clear all interrupt flags
00:CB8F 8DFD7F          	   328:   sta VIA_IFR
                        	   329: 
                        	   330:   .if LCD_SUPPORT
00:CB92 20EAB9          	   331:   jsr lcd_initialise
                        	   332:   .endif
                        	   333: 
00:CB95 648A            	   334:   stz serial_in_byte    ; non-zero means an interrupt put in incoming byte there
00:CB97 6489            	   335:   stz serial_out_bit
00:CB99 6468            	   336:   stz spi_mode          ; default to SPI mode zero
                        	   337: 
00:CB9B 58              	   338:   cli         ; enable interrupts
00:CB9C 60              	   339:   rts
                        	   340: 
                        	   341: 
                        	   342: ;
                        	   343: ;  Write a character (in A) to the serial port.
                        	   344: ;   Interrupts MUST be enabled for this to work!
                        	   345: ;
                        	   346: write_char:
00:CB9D 48              	   347:   pha                   ; save original character
00:CB9E 0A              	   348:   asl a                 ; shift in a zero which will be the start bit
00:CB9F 8587            	   349:   sta serial_out_byte
00:CBA1 A9FF            	   350:   lda #0xff             ; will become the stop bit(s)
00:CBA3 2A              	   351:   rol a                 ; rotate in the high-order bit from the data byte
00:CBA4 8588            	   352:   sta serial_out_byte+1
00:CBA6 A90B            	   353:   lda #11               ; 8 data bits, one start bit, two stop bits
00:CBA8 8589            	   354:   sta serial_out_bit    ; number of bits to shift out
00:CBAA A9D0            	   355:   lda #<BIT_INTERVAL    ; ie. baud rate interval
00:CBAC 8DF47F          	   356:   sta VIA_T1C_L         ; for sending bits
00:CBAF A900            	   357:   lda #>BIT_INTERVAL
00:CBB1 8DF57F          	   358:   sta VIA_T1C_H         ; this starts the counter
00:CBB4 A9C0            	   359:   lda #VIA_FLAG_ENABLE | VIA_FLAG_TIMER1  ; interrupt on T1 timeout
00:CBB6 8DFE7F          	   360:   sta VIA_IER
                        	   361: 
                        	   362: ;
                        	   363: ; wait for this byte to finish - otherwise it might interfere with many things
                        	   364: ;
                        	   365: 
                        	   366: write_char_loop:
00:CBB9 ADFE7F          	   367:   lda VIA_IER
00:CBBC 2940            	   368:   and #VIA_FLAG_TIMER1  ; are T1 interrupts enabled?
00:CBBE D0F9            	   369:   bne write_char_loop   ; loop until this character sent
00:CBC0 68              	   370:   pla                   ; get character back
00:CBC1 60              	   371:   rts
                        	   372: 
                        	   373: 
                        	   374: ;
                        	   375: ;  sends null-terminated message to serial port, message in A (lo) and X (hi)
                        	   376: ;  returns the length of the message in Y
                        	   377: ;
                        	   378: serial_print_message:
00:CBC2 8503            	   379:   sta REG2
00:CBC4 8604            	   380:   stx REG2+1
00:CBC6 A000            	   381:   ldy #0
                        	   382: serial_print:
00:CBC8 B103            	   383:   lda (REG2),y
00:CBCA F006            	   384:   beq serial_print_done
00:CBCC 209DCB          	   385:   jsr write_char
00:CBCF C8              	   386:   iny
00:CBD0 80F6            	   387:   bra serial_print
                        	   388: 
00:CBD2 60              	   389: serial_print_done rts
                        	   390: 
                        	   391:   .endif  ; not EMULATOR
                        	   392: 
                        	   393: 

Source: "gpascal.asm"
                        	   189:   .include "gtoken.inc"

Source: "gtoken.inc"
                        	     1: ;
                        	     2: ;  get_token
                        	     3: ;
                        	     4: ;  Gets a lexical token from the specified address.
                        	     5: ;
                        	     6: ;  - Start parsing at token_start (this should be the first character of the token)
                        	     7: ;  - The first found character (after spaces, comments, newlines) is in token_address
                        	     8: ;      - this is mainly used for knowing what the identifier is so we can put it in the symbol table
                        	     9: ;      - strings are put into INBUF after processing, so token_address is not as useful in that case
                        	    10: ;  - The length is in token_length (in the case of strings, this is the processed length)
                        	    11: ;  - The type is in token_type - zero would mean end of file
                        	    12: ;
                        	    13: ;  The types are one of the token codes below
                        	    14: ;
                        	    15: ;  Tokens which start with a letter and are possibly followed by letters, numbers, and
                        	    16: ;    the underscore character become TOKEN_IDENTIFIER.
                        	    17: ;
                        	    18: ;  Tokens starting with a number (TOKEN_NUMBER) are parsed for the value which is placed into token_value.
                        	    19: ;
                        	    20: ;  Tokens starting with a single or double quote are parsed for the internal string (TOKEN_STRING)
                        	    21: ;  which is placed in INBUF. The internal string has internal double-quotes turned
                        	    22: ;  into single quotes, and sequences like \n or \x42 turned into their appropriate characters.
                        	    23: ;
                        	    24: ;  String tokens which are up to 3 bytes long also have the 3 bytes placed into token_value.
                        	    25: ;
                        	    26: ;  Hex and binary tokens are parsed for their value which is placed into token_value.
                        	    27: ;
                        	    28: ;  Various 2-character tokens are given their own code (eg. <> == != := << >> and so on).
                        	    29: ;
                        	    30: ;  Spaces and comments are skipped, however Pascal directives inside comments are processed
                        	    31: ;
                        	    32: ;  Newlines are skipped in Pascal but returned as a token in assembler (ASSEMBLING == true)
                        	    33: ;  If newlines are skipped then token_line is called to handle listing the line (the line
                        	    34: ;   we are about to process, not the previous line)
                        	    35: ;
                        	    36: ; Rewritten in February 2022 to be easier to read and have well-defined work variables (zero-page variables)
                        	    37: 
                        	    38: ; multi-byte token codes (single byte tokens are themselves)
                        	    39: 
                        	    40: TOKEN_ASSIGN     = 'A'   ; :=
                        	    41: TOKEN_IDENTIFIER = 'I'   ; alpha-numeric identifiers
                        	    42: TOKEN_NUMBER     = 'N'   ; numbers
                        	    43: TOKEN_STRING     = '"'   ; string literal
                        	    44: TOKEN_LEQ        = $80   ; <=
                        	    45: TOKEN_GEQ        = $81   ; >=
                        	    46: TOKEN_NEQ        = 'U'   ; <>
                        	    47: 
                        	    48: ;
                        	    49: ;  the ones below are used in the assembler
                        	    50: ;
                        	    51: TOKEN_EQUALITY    = 'E'     ; ==
                        	    52: TOKEN_SHIFT_LEFT  = 'L'     ; <<
                        	    53: TOKEN_SHIFT_RIGHT = 'R'     ; >>
                        	    54: TOKEN_UNARY_MINUS = 'M'     ; -
                        	    55: TOKEN_LOW_BYTE    = 'V'     ; eg. lda #<foo
                        	    56: TOKEN_HIGH_BYTE   = 'W'     ; eg. lda #>foo
                        	    57: TOKEN_LOGICAL_AND = 'X'     ; &&
                        	    58: TOKEN_LOGICAL_OR  = 'Y'     ; ||
                        	    59: TOKEN_INEQUALITY  = 'Z'     ; !=
                        	    60: 
                        	    61: 
                        	    62: get_token:
00:CBD3 A593            	    63:   lda token_type      ; remember previous token for checking if + or - stand on their own
00:CBD5 8598            	    64:   sta token_work
                        	    65: get_token_loop:
00:CBD7 A000            	    66:   ldy #0              ; offset into the token address
00:CBD9 8497            	    67:   sty token_sign      ; Y is zero at this point
00:CBDB 8494            	    68:   sty token_value     ; no value yet
00:CBDD 8495            	    69:   sty token_value+1
00:CBDF 8496            	    70:   sty token_value+2
                        	    71: 
                        	    72: gc_skip_spaces:
00:CBE1 B18E            	    73:   lda (token_start),y
00:CBE3 F034            	    74:   beq gc_done         ; 0x00 means end, so return it WITHOUT incrementing the pointer
00:CBE5 C90A            	    75:   cmp #NL             ; newline need special handling
00:CBE7 F00D            	    76:   beq gc_newline
00:CBE9 204A81          	    77:   jsr isspace
00:CBEC 9043            	    78:   bcc gc_not_space
00:CBEE E68E            	    79:   inc token_start     ; increment pointer because spaces can be any length
00:CBF0 D0EF            	    80:   bne gc_skip_spaces
00:CBF2 E68F            	    81:   inc token_start+1
00:CBF4 80EB            	    82:   bra gc_skip_spaces
                        	    83: 
                        	    84: ;
                        	    85: ;  got a newline - if assembling, return that so we know where lines end
                        	    86: ;  otherwise just call token_line to display the next line and press on looking
                        	    87: ;  for tokens.
                        	    88: ;
                        	    89: gc_newline:
00:CBF6 A902            	    90:   lda #FLAG_ASSEMBLING
00:CBF8 25BE            	    91:   and system_flags
00:CBFA D014            	    92:   bne gc_newline_assembling    ; return the newline as a token
00:CBFC C8              	    93:   iny              ; length in Y (ie. one)
00:CBFD E68E            	    94:   inc token_start
00:CBFF D002            	    95:   bne gc_newline1
00:CC01 E68F            	    96:   inc token_start+1
                        	    97: gc_newline1:
00:CC03 A58E            	    98:   lda token_start
00:CC05 859C            	    99:   sta token_line_start
00:CC07 A58F            	   100:   lda token_start+1
00:CC09 859D            	   101:   sta token_line_start+1
00:CC0B 2073CC          	   102:   jsr token_line        ; list the next line
00:CC0E 80C7            	   103:   bra get_token_loop    ; look for another token
                        	   104: 
                        	   105: gc_newline_assembling:
00:CC10 A90A            	   106:   lda #NL       ; get the newline back
00:CC12 4C17CC          	   107:   jmp gc_single_byte_token
                        	   108: 
                        	   109: ;
                        	   110: ;  wrap up getting a token:
                        	   111: ;
                        	   112: ;   - save the type
                        	   113: ;   - save the current address as token_address
                        	   114: ;   - add the length to token_start ready for next time
                        	   115: ;
                        	   116: gc_single_byte_already_known:
00:CC15 A593            	   117:   lda token_type        ; get back saved token type
                        	   118: gc_single_byte_token:
00:CC17 A001            	   119:   ldy #1
                        	   120: gc_done:
00:CC19 8492            	   121:   sty token_length      ; Y has our length
00:CC1B 8593            	   122:   sta token_type        ; A has our type
00:CC1D 18              	   123:   clc
00:CC1E A58E            	   124:   lda token_start
00:CC20 8590            	   125:   sta token_address     ; save the starting address of the token
00:CC22 6592            	   126:   adc token_length      ; now add its length
00:CC24 858E            	   127:   sta token_start       ; that gives the ending address
                        	   128: 
00:CC26 A58F            	   129:   lda token_start+1     ; repeat for high-order byte
00:CC28 8591            	   130:   sta token_address+1
00:CC2A 6900            	   131:   adc #0
00:CC2C 858F            	   132:   sta token_start+1
                        	   133: 
00:CC2E A593            	   134:   lda token_type        ; get token type back into A
00:CC30 60              	   135:   rts
                        	   136: 
                        	   137: ;
                        	   138: ;  not a space (or newline) so this must be the actual start of it
                        	   139: ;
                        	   140: 
                        	   141: gc_not_space:
                        	   142: 
                        	   143: ;
                        	   144: ;  first look for classes of characters (ie. alpha, numeric)
                        	   145: ;
00:CC31 202681          	   146:   jsr isalpha
00:CC34 9026            	   147:   bcc gc_not_alpha
                        	   148: 
                        	   149: ;
                        	   150: ;  find end of identifier
                        	   151: ;
                        	   152: gc_alpha_loop:
00:CC36 C8              	   153:   iny
00:CC37 D005            	   154:   bne gc_alpha_ok   ; if it becomes zero now, we have 256+ long identifier
00:CC39 A20C            	   155:   ldx #12       ; ERROR: Illegal Identifier (too long)
00:CC3B 4CAB99          	   156:   jmp ERROR
                        	   157: 
                        	   158: gc_alpha_ok:
00:CC3E A940            	   159:   lda #FLAG_ONLY_ALPHA
00:CC40 24BE            	   160:   bit system_flags
00:CC42 D00F            	   161:   bne gc_alpha_alpha_only
00:CC44 B18E            	   162:   lda (token_start),y
00:CC46 206281          	   163:   jsr isalnum
00:CC49 B0EB            	   164:   bcs gc_alpha_loop
00:CC4B C95F            	   165:   cmp #'_'
00:CC4D F0E7            	   166:   beq gc_alpha_loop
                        	   167: 
                        	   168: ;
                        	   169: ; end of identifier
                        	   170: ;
                        	   171: gc_alpha_done:
00:CC4F A949            	   172:   lda #TOKEN_IDENTIFIER
00:CC51 80C6            	   173:   bra gc_done
                        	   174: 
                        	   175: 
                        	   176: gc_alpha_alpha_only:
00:CC53 B18E            	   177:   lda (token_start),y
00:CC55 202681          	   178:   jsr isalpha
00:CC58 B0DC            	   179:   bcs gc_alpha_loop
00:CC5A 80F3            	   180:   bra gc_alpha_done
                        	   181: 
                        	   182: ;
                        	   183: ; now see if it is a digit
                        	   184: ;
                        	   185: gc_not_alpha:
00:CC5C 203281          	   186:   jsr isdigit
00:CC5F 9007            	   187:   bcc gc_not_digit
                        	   188: 
00:CC61 20C2CC          	   189:   jsr atoi
00:CC64 A94E            	   190:   lda  #TOKEN_NUMBER
00:CC66 80B1            	   191:   bra  gc_done
                        	   192: 
                        	   193: ;
                        	   194: ;  not alpha and not digit - so let's consider:
                        	   195: ;   * prefixes: $ for hex and % for binary
                        	   196: ;   *  + or - in front of numbers or on their own
                        	   197: ;   * single character tokens, eg. =, (, ) and so on
                        	   198: ;   * double-character tokens, eg. ==, >= << and so on
                        	   199: ;   * strings, eg. "foo"
                        	   200: ;
                        	   201: ;  we'll do a jump on the first character
                        	   202: ;
                        	   203: gc_not_digit:
00:CC68 8593            	   204:   sta token_type            ; remember it in case of possible two-byte sequences
00:CC6A A250            	   205:   ldx #<gtoken_table
00:CC6C A0CD            	   206:   ldy #>gtoken_table
00:CC6E 20D291          	   207:   jsr TKNJMP
00:CC71 80A2            	   208:   bra gc_single_byte_already_known  ; it is what it is
                        	   209: 
                        	   210: ;
                        	   211: ;  here when get_token discovers a newline - print the next line if wanted
                        	   212: ;
                        	   213: 
                        	   214: token_line:
                        	   215: ;
                        	   216: ;  count lines
                        	   217: ;
00:CC73 E6A2            	   218:   inc current_line
00:CC75 D002            	   219:   bne token_line1
00:CC77 E6A3            	   220:   inc current_line+1
                        	   221: token_line1:
                        	   222: ;
                        	   223: ;  compiling or assembling?
                        	   224: ;
00:CC79 A901            	   225:   lda #FLAG_COMPILING
00:CC7B 0902            	   226:   ora #FLAG_ASSEMBLING
00:CC7D 25BE            	   227:   and system_flags
00:CC7F F040            	   228:   beq token_line_done ; no - no listing
                        	   229: ;
                        	   230: ;  listing wanted?
                        	   231: ;
00:CC81 A904            	   232:   lda #FLAG_LIST_SOURCE
00:CC83 25BE            	   233:   and system_flags
00:CC85 D00D            	   234:   bne token_line_listing ; yes
                        	   235: 
                        	   236: ;
                        	   237: ;  no listing - show an asterisk every 15 lines
                        	   238: ;
00:CC87 A5A2            	   239:   lda current_line
00:CC89 290F            	   240:   and #$0F
00:CC8B D034            	   241:   bne token_line_done
00:CC8D A92A            	   242:   lda #'*'
00:CC8F 20F695          	   243:   jsr COUT
00:CC92 802D            	   244:   bra token_line_done
                        	   245: 
                        	   246: token_line_listing:
00:CC94 A52E            	   247:   lda DCODE
00:CC96 48              	   248:   pha
00:CC97 A901            	   249:   lda #1
00:CC99 852E            	   250:   sta DCODE
00:CC9B 208394          	   251:   jsr DISPAD
00:CC9E 68              	   252:   pla
00:CC9F 852E            	   253:   sta DCODE
00:CCA1 20358C          	   254:   jsr show_current_line_number
                        	   255: 
00:CCA4 A59C            	   256:   lda token_line_start
00:CCA6 8598            	   257:   sta token_work
00:CCA8 A59D            	   258:   lda token_line_start+1
00:CCAA 8599            	   259:   sta token_work+1
                        	   260: 
                        	   261: token_line_loop:
00:CCAC A000            	   262:   ldy #0
00:CCAE B198            	   263:   lda (token_work),Y
00:CCB0 F00F            	   264:   beq token_line_done
00:CCB2 48              	   265:   pha
00:CCB3 20F695          	   266:   jsr COUT
00:CCB6 E698            	   267:   inc token_work
00:CCB8 D002            	   268:   bne token_line_loop1
00:CCBA E699            	   269:   inc token_work+1
                        	   270: token_line_loop1:
00:CCBC 68              	   271:   pla
00:CCBD C90A            	   272:   cmp #NL
00:CCBF D0EB            	   273:   bne token_line_loop
                        	   274: 
                        	   275: token_line_done:
00:CCC1 60              	   276:   rts
                        	   277: 
                        	   278: 
                        	   279: ;
                        	   280: ;  atoi
                        	   281: ;
                        	   282: ; get a decimal number - returns carry flag set if bad number and running
                        	   283: ;   (if compiling and a bad number gives an error)
                        	   284: ;
                        	   285: ;  token_start : the start address of the number
                        	   286: ;  Y : offset into token_start
                        	   287: ;  token_sign : non-zero if negative
                        	   288: ;
                        	   289: ;  returns: token_value  and carry clear (if no error)
                        	   290: ;           carry set if error (for use at runtime)
                        	   291: ;           Y at offset of first non-numeric character
                        	   292: 
                        	   293: atoi:
00:CCC2 38              	   294:   sec
00:CCC3 E930            	   295:   sbc  #'0'   ;  ; subtract out ASCII stuff, save first digit
00:CCC5 8594            	   296:   sta  token_value
00:CCC7 6495            	   297:   stz  token_value+1
00:CCC9 6496            	   298:   stz  token_value+2
                        	   299: atoi_loop    =  *
00:CCCB C8              	   300:   iny
00:CCCC B18E            	   301:   lda  (token_start),y
00:CCCE 203281          	   302:   jsr  isdigit
00:CCD1 B009            	   303:   bcs  atoi_more      ; more digits
                        	   304: ;
                        	   305: ; end of number - make negative if we got a sign earlier
                        	   306: ;
00:CCD3 A597            	   307:   lda  token_sign
00:CCD5 F003            	   308:   beq  atoi_positive    ; not signed
                        	   309: ;
                        	   310: ;  make negative
                        	   311: ;
00:CCD7 203CCD          	   312:   jsr negate_token_value
                        	   313: ;
                        	   314: ;  done! clear carry and return
                        	   315: ;
                        	   316: atoi_positive:
00:CCDA 18              	   317:   clc                   ; indicate no error for numeric conversion
00:CCDB 60              	   318:   rts
                        	   319: ;
                        	   320: ;  Multiply previous value by 10, add in new digit
                        	   321: ;
                        	   322: atoi_more    =  *
00:CCDC 38              	   323:   sec
00:CCDD E930            	   324:   sbc  #'0'
00:CCDF 859B            	   325:   sta  token_digit
00:CCE1 0694            	   326:   asl  token_value         ; multiply token_value by 2
00:CCE3 2695            	   327:   rol  token_value+1
00:CCE5 2696            	   328:   rol  token_value+2
00:CCE7 3048            	   329:   bmi  atoi_error
                        	   330: 
00:CCE9 A594            	   331:   lda  token_value         ; save token_value*2 in token_work
00:CCEB 8598            	   332:   sta  token_work
00:CCED A595            	   333:   lda  token_value+1
00:CCEF 8599            	   334:   sta  token_work+1
00:CCF1 A596            	   335:   lda  token_value+2
00:CCF3 859A            	   336:   sta  token_work+2
                        	   337: 
00:CCF5 0694            	   338:   asl  token_value         ; now token_value is multiplied by 4
00:CCF7 2695            	   339:   rol  token_value+1
00:CCF9 2696            	   340:   rol  token_value+2
00:CCFB 3034            	   341:   bmi  atoi_error
                        	   342: 
00:CCFD 0694            	   343:   asl  token_value         ; now token_value is multiplied by 8
00:CCFF 2695            	   344:   rol  token_value+1
00:CD01 2696            	   345:   rol  token_value+2
00:CD03 302C            	   346:   bmi  atoi_error
                        	   347: 
00:CD05 A598            	   348:   lda  token_work          ; now add back in token_value*2 (giving token_value*10)
00:CD07 6594            	   349:   adc  token_value
00:CD09 8594            	   350:   sta  token_value
00:CD0B A599            	   351:   lda  token_work+1
00:CD0D 6595            	   352:   adc  token_value+1
00:CD0F 8595            	   353:   sta  token_value+1
00:CD11 A59A            	   354:   lda  token_work+2
00:CD13 6596            	   355:   adc  token_value+2
00:CD15 8596            	   356:   sta  token_value+2
00:CD17 3018            	   357:   bmi  atoi_error      ; if negative, the number was too big
00:CD19 18              	   358:   clc
00:CD1A A594            	   359:   lda  token_value     ; now take the value and add in our new digit
00:CD1C 659B            	   360:   adc  token_digit
00:CD1E 8594            	   361:   sta  token_value
00:CD20 A900            	   362:   lda #0
00:CD22 6595            	   363:   adc  token_value+1   ; increment next byte if necessary
00:CD24 8595            	   364:   sta  token_value+1
00:CD26 A900            	   365:   lda #0
00:CD28 6596            	   366:   adc  token_value+2
00:CD2A 8596            	   367:   sta  token_value+2
00:CD2C 3003            	   368:   bmi  atoi_error
00:CD2E 4CCBCC          	   369:   jmp  atoi_loop     ; onwards for next digit
                        	   370: 
                        	   371: atoi_error    =  *
00:CD31 A53F            	   372:   lda  RUNNING
00:CD33 1002            	   373:   bpl  atoi_not_running
00:CD35 38              	   374:   sec             ; otherwise set carry and return
00:CD36 60              	   375:   rts
                        	   376: atoi_not_running  =  *
00:CD37 A21E            	   377:   ldx  #30       ; ERROR: Number out of Range
00:CD39 4CAB99          	   378:   jmp  ERROR
                        	   379: 
                        	   380: ;
                        	   381: ;  for negative numbers, subtract token_value from zero
                        	   382: ;
                        	   383: negate_token_value:
00:CD3C 38              	   384:   sec
00:CD3D A900            	   385:   lda  #0
00:CD3F E594            	   386:   sbc  token_value
00:CD41 8594            	   387:   sta  token_value
00:CD43 A900            	   388:   lda  #0
00:CD45 E595            	   389:   sbc  token_value+1
00:CD47 8595            	   390:   sta  token_value+1
00:CD49 A900            	   391:   lda  #0
00:CD4B E596            	   392:   sbc  token_value+2
00:CD4D 8596            	   393:   sta  token_value+2
00:CD4F 60              	   394:   rts
                        	   395: 
                        	   396: 
                        	   397: gtoken_table:
                        	   398:   tknjmpItem '(',gc_lh_paren
00:CD50 28              	     1M    dfb   '('
00:CD51 98CD            	     2M    word  gc_lh_paren
                        	   399:   tknjmpItem '{',gc_lh_brace
00:CD53 7B              	     1M    dfb   '{'
00:CD54 94CD            	     2M    word  gc_lh_brace
                        	   400:   tknjmpItem '"',gc_quote
00:CD56 22              	     1M    dfb   '"'
00:CD57 87CE            	     2M    word  gc_quote
                        	   401:   tknjmpItem SINGLE_QUOTE,gc_quote
00:CD59 27              	     1M    dfb   SINGLE_QUOTE
00:CD5A 87CE            	     2M    word  gc_quote
                        	   402:   tknjmpItem '$',gc_dollar
00:CD5C 24              	     1M    dfb   '$'
00:CD5D 55CF            	     2M    word  gc_dollar
                        	   403:   tknjmpItem '%',gc_percent
00:CD5F 25              	     1M    dfb   '%'
00:CD60 AFCF            	     2M    word  gc_percent
                        	   404:   tknjmpItem ':',gc_colon
00:CD62 3A              	     1M    dfb   ':'
00:CD63 D9CF            	     2M    word  gc_colon
                        	   405:   tknjmpItem '<',gc_less_than
00:CD65 3C              	     1M    dfb   '<'
00:CD66 EACF            	     2M    word  gc_less_than
                        	   406:   tknjmpItem '>',gc_greater_than
00:CD68 3E              	     1M    dfb   '>'
00:CD69 0DD0            	     2M    word  gc_greater_than
                        	   407:   tknjmpItem '-',gc_minus
00:CD6B 2D              	     1M    dfb   '-'
00:CD6C 27D0            	     2M    word  gc_minus
                        	   408:   tknjmpItem '+',gc_plus
00:CD6E 2B              	     1M    dfb   '+'
00:CD6F 29D0            	     2M    word  gc_plus
                        	   409:   tknjmpItem '&',gc_ampersand
00:CD71 26              	     1M    dfb   '&'
00:CD72 48D0            	     2M    word  gc_ampersand
                        	   410:   tknjmpItem '|',gc_bar
00:CD74 7C              	     1M    dfb   '|'
00:CD75 59D0            	     2M    word  gc_bar
                        	   411:   tknjmpItem '=',gc_equals
00:CD77 3D              	     1M    dfb   '='
00:CD78 6AD0            	     2M    word  gc_equals
                        	   412:   tknjmpItem '!',gc_bang
00:CD7A 21              	     1M    dfb   '!'
00:CD7B 7BD0            	     2M    word  gc_bang
                        	   413:   tknjmpItem ';',gc_semicolon
00:CD7D 3B              	     1M    dfb   ';'
00:CD7E 4ECE            	     2M    word  gc_semicolon
00:CD80 00              	   414:   dfb        0   ; end of table
                        	   415: 
                        	   416: gtoken_directive_table:
                        	   417:   tknjmpItem 'S',gc_directive_symbols
00:CD81 53              	     1M    dfb   'S'
00:CD82 00CE            	     2M    word  gc_directive_symbols
                        	   418:   tknjmpItem 'L',gc_directive_list
00:CD84 4C              	     1M    dfb   'L'
00:CD85 38CE            	     2M    word  gc_directive_list
                        	   419:   tknjmpItem 'P',gc_directive_pcodes
00:CD87 50              	     1M    dfb   'P'
00:CD88 3FCE            	     2M    word  gc_directive_pcodes
                        	   420:   tknjmpItem 'N',gc_directive_nolist
00:CD8A 4E              	     1M    dfb   'N'
00:CD8B 45CE            	     2M    word  gc_directive_nolist
00:CD8D 00              	   421:   dfb        0
                        	   422: 
                        	   423: ; single byte token, in A
00:CD8E 4C17CC          	   424: gc_single_byte_tokenJ jmp gc_single_byte_token
                        	   425: ; single byte token in token_type
00:CD91 4C15CC          	   426: gc_single_byte_already_knownJ jmp gc_single_byte_already_known
                        	   427: 
                        	   428: gc_lh_brace:
00:CD94 A000            	   429:   ldy #0
00:CD96 800E            	   430:   bra gc_pascal_comment
                        	   431: gc_lh_paren:
00:CD98 A902            	   432:   lda #FLAG_ASSEMBLING
00:CD9A 25BE            	   433:   and system_flags
00:CD9C D0F3            	   434:   bne gc_single_byte_already_knownJ
00:CD9E A001            	   435:   ldy #1
00:CDA0 B18E            	   436:   lda (token_start),Y
00:CDA2 C92A            	   437:   cmp #'*'      ; was it: (* ?
00:CDA4 D0EB            	   438:   bne gc_single_byte_already_knownJ  ; nope
                        	   439: 
                        	   440: ;
                        	   441: ;  Y will be 0 or 1 depending on the sort of starting comment
                        	   442: ;  first look for % which indicates a compiler directive
                        	   443: ;
                        	   444: gc_pascal_comment:
00:CDA6 C8              	   445:   iny
00:CDA7 B18E            	   446:   lda (token_start),Y
00:CDA9 C925            	   447:   cmp #'%'   ; directive?
00:CDAB D018            	   448:   bne gc_pascal_comment_find_end
00:CDAD C8              	   449:   iny
00:CDAE B18E            	   450:   lda (token_start),Y ; get the directive: S, L, P or N
00:CDB0 48              	   451:   pha   ; save the directive for now
00:CDB1 98              	   452:   tya
                        	   453: ;
                        	   454: ;  make token_start point to where we are up to, so we can skip the comment, even if it is long
                        	   455: ;
00:CDB2 38              	   456:   sec               ; I actually want to be one past where the directive letter is
00:CDB3 658E            	   457:   adc token_start
00:CDB5 858E            	   458:   sta token_start
00:CDB7 A900            	   459:   lda #0
00:CDB9 658F            	   460:   adc token_start+1
00:CDBB 858F            	   461:   sta token_start+1
00:CDBD 68              	   462:   pla   ; get the directive back
00:CDBE A281            	   463:   ldx #<gtoken_directive_table
00:CDC0 A0CD            	   464:   ldy #>gtoken_directive_table
00:CDC2 20D291          	   465:   jsr TKNJMP  ; do the directive handler
                        	   466: ;
                        	   467: ;  fall through if not found and just find the end of the comment
                        	   468: ;
                        	   469: 
                        	   470: gc_pascal_comment_find_end:
00:CDC5 A000            	   471:   ldy #0    ; we normalised token_start to be where we want to start
00:CDC7 B18E            	   472:   lda (token_start),Y
00:CDC9 D005            	   473:   bne gc_comment_not_eof
00:CDCB A207            	   474:   ldx  #7           ; NO } FOUND
00:CDCD 4CAB99          	   475:   jmp  ERROR
                        	   476: gc_comment_not_eof:
00:CDD0 C90A            	   477:   cmp #NL
00:CDD2 D005            	   478:   bne gc_comment_not_newline
00:CDD4 2073CC          	   479:   jsr token_line    ; handle the newline (we can't be assembling or we wouldn't be here)
00:CDD7 800F            	   480:   bra gc_comment_keep_looking
                        	   481: gc_comment_not_newline:
00:CDD9 C97D            	   482:   cmp #'}'
00:CDDB F013            	   483:   beq gc_comment_found_end
00:CDDD C92A            	   484:   cmp #'*'
00:CDDF D007            	   485:   bne gc_comment_keep_looking
00:CDE1 C8              	   486:   iny
00:CDE2 B18E            	   487:   lda (token_start),Y
00:CDE4 C929            	   488:   cmp #')'
00:CDE6 F008            	   489:   beq gc_comment_found_end
                        	   490: 
                        	   491: ;
                        	   492: ;  skip this byte and keep looking for the end of comment
                        	   493: ;
                        	   494: gc_comment_keep_looking:
00:CDE8 E68E            	   495:   inc token_start
00:CDEA D0D9            	   496:   bne gc_pascal_comment_find_end
00:CDEC E68F            	   497:   inc token_start+1
00:CDEE 80D5            	   498:   bra gc_pascal_comment_find_end
                        	   499: 
                        	   500: ;
                        	   501: ;  found end of comment, so move token_start to this character
                        	   502: ;   (the one past the end of the comment) and try again for a token
                        	   503: ;
                        	   504: gc_comment_found_end:
00:CDF0 C8              	   505:   iny   ; get past end of comment
00:CDF1 98              	   506:   tya
00:CDF2 18              	   507:   clc
00:CDF3 658E            	   508:   adc token_start
00:CDF5 858E            	   509:   sta token_start
00:CDF7 A900            	   510:   lda #0
00:CDF9 658F            	   511:   adc token_start+1
00:CDFB 858F            	   512:   sta token_start+1
00:CDFD 4CD7CB          	   513:   jmp get_token_loop
                        	   514: 
                        	   515: ;
                        	   516: ;  {%S $nnnn}
                        	   517: ;  symbol table relocation
                        	   518: ;
                        	   519: gc_directive_symbols:
00:CE00 20D7CB          	   520:    jsr  get_token_loop     ; re-call get_token to find the address
00:CE03 C94E            	   521:    cmp  #TOKEN_NUMBER ; number?
00:CE05 F005            	   522:    beq  gc_directive_symbols_ok      ; yes
00:CE07 A202            	   523:    ldx  #2
00:CE09 4CAB99          	   524:    jmp  ERROR      ; 'Constant expected'
                        	   525: 
                        	   526: gc_directive_symbols_ok:
                        	   527:   ;
                        	   528:   ;  check we haven't generated any code
                        	   529:   ;
00:CE0C A523            	   530:   lda PCODE
00:CE0E C525            	   531:   cmp ACT_PCDA
00:CE10 D021            	   532:   bne gc_directive_symbols_too_late
00:CE12 A524            	   533:   lda PCODE+1
00:CE14 C526            	   534:   cmp ACT_PCDA+1
00:CE16 D01B            	   535:   bne gc_directive_symbols_too_late
                        	   536: 
00:CE18 A594            	   537:   lda  token_value
00:CE1A 8531            	   538:   sta  ENDSYM
00:CE1C 852F            	   539:   sta  STARTSYM
00:CE1E 852B            	   540:   sta  OPND
00:CE20 A595            	   541:   lda  token_value+1
00:CE22 8532            	   542:   sta  ENDSYM+1        ; store symbol table address
00:CE24 8530            	   543:   sta  STARTSYM+1
00:CE26 852C            	   544:   sta  OPND+1
00:CE28 A901            	   545:   lda  #PCODE_STACK    ; change runtime stack
00:CE2A 202ECA          	   546:   jsr  GENJMP
                        	   547: ;
                        	   548: ;  put the library functions back
                        	   549: ;
00:CE2D 20FBC8          	   550:   jsr  add_pascal_library_functions
                        	   551: 
00:CE30 4CC5CD          	   552:   jmp  gc_pascal_comment_find_end     ; go back and find the end of the comment
                        	   553: ;
                        	   554: 
                        	   555: gc_directive_symbols_too_late:
00:CE33 A233            	   556:   ldx #51        ; code already generated
00:CE35 4CAB99          	   557:   JMP  ERROR
                        	   558: 
                        	   559: 
                        	   560: ;
                        	   561: ;  {%L} - list source
                        	   562: ;
                        	   563: gc_directive_list:
00:CE38 A904            	   564:   lda #FLAG_LIST_SOURCE
00:CE3A 04BE            	   565:   tsb system_flags
00:CE3C 4CC5CD          	   566:   jmp gc_pascal_comment_find_end
                        	   567: 
                        	   568: ;
                        	   569: ;  {%P} - list source and P-codes
                        	   570: ;
                        	   571: gc_directive_pcodes:
00:CE3F A901            	   572:   lda #1
00:CE41 852E            	   573:   sta DCODE
00:CE43 80F3            	   574:   bra gc_directive_list   ; also list source
                        	   575: ;
                        	   576: ;  {%N} - do not list source or P-codes
                        	   577: ;
                        	   578: gc_directive_nolist:
00:CE45 A904            	   579:   lda #FLAG_LIST_SOURCE
00:CE47 14BE            	   580:   trb system_flags    ; clear both of the above flags
00:CE49 642E            	   581:   stz DCODE
00:CE4B 4CC5CD          	   582:   jmp gc_pascal_comment_find_end
                        	   583: 
                        	   584: ;
                        	   585: ;  semicolons start comments in the assembler
                        	   586: ;
                        	   587: gc_semicolon:
00:CE4E A902            	   588:   lda #FLAG_ASSEMBLING
00:CE50 25BE            	   589:   and system_flags
00:CE52 D003            	   590:   bne gc_assembler_comment_find_end
00:CE54 4C15CC          	   591:   jmp gc_single_byte_already_known
                        	   592: 
                        	   593: gc_assembler_comment_find_end:
00:CE57 A000            	   594:   ldy #0
00:CE59 B18E            	   595:   lda (token_start),Y
00:CE5B D005            	   596:   bne gc_assembler_comment_not_eof
00:CE5D A90A            	   597:   lda #NL
00:CE5F 8593            	   598:   sta token_type
00:CE61 60              	   599:   rts     ; exit without incrementing token_start
                        	   600: 
                        	   601: gc_assembler_comment_not_eof:
00:CE62 C90A            	   602:   cmp #NL
00:CE64 D003            	   603:   bne gc_assembler_comment_keep_looking
00:CE66 4C17CC          	   604:   jmp gc_single_byte_token
                        	   605: ;
                        	   606: ;  skip this byte and keep looking for the newline at the end of comment
                        	   607: ;
                        	   608: gc_assembler_comment_keep_looking:
00:CE69 E68E            	   609:   inc token_start
00:CE6B D0EA            	   610:   bne gc_assembler_comment_find_end
00:CE6D E68F            	   611:   inc token_start+1
00:CE6F 80E6            	   612:   bra gc_assembler_comment_find_end
                        	   613: 
                        	   614: 
                        	   615: gc_backslash_tokens:
00:CE71 41              	   616:          DFB  'A',$07  ; bell ($07)
00:CE72 07
00:CE73 42              	   617:          DFB  'B',$08  ; backspace ($08)
00:CE74 08
00:CE75 45              	   618:          DFB  'E',$1B  ; escape  (0x1B)
00:CE76 1B
00:CE77 46              	   619:          DFB  'F',$0C  ; formfeed ($0C)
00:CE78 0C
00:CE79 4E              	   620:          DFB  'N',$0A  ; newline  (0x0A)
00:CE7A 0A
00:CE7B 52              	   621:          DFB  'R',$0D  ; carriage return (0x0D)
00:CE7C 0D
00:CE7D 54              	   622:          DFB  'T',$09  ; horizontal tab (0x09)
00:CE7E 09
00:CE7F 56              	   623:          DFB  'V',$0B  ; vertical tab (0x0B)
00:CE80 0B
00:CE81 5C              	   624:          DFB  $5C,$5C  ; backslash
00:CE82 5C
00:CE83 22              	   625:          DFB  '"','"'  ; double quote
00:CE84 22
00:CE85 27              	   626:          DFB  SINGLE_QUOTE,SINGLE_QUOTE  ; single quote
00:CE86 27
                        	   627: gc_backslash_tokens_end = *
                        	   628: gc_backslash_tokens_length = gc_backslash_tokens_end - gc_backslash_tokens
                        	   629: 
                        	   630: ;
                        	   631: ;  quoted string
                        	   632: ;
                        	   633: ;  resolve double quotes and backslash sequences and store it in INBUF
                        	   634: ;
                        	   635: ;
                        	   636: gc_quote:
00:CE87 8598            	   637:   sta token_work    ; remember which sort
00:CE89 A000            	   638:   ldy #0            ; back to the start
00:CE8B 6492            	   639:   stz token_length  ; zero-length string so far
00:CE8D A58E            	   640:   lda token_start
00:CE8F 8590            	   641:   sta token_address   ; save the starting address of the token (not that it matters too much)
00:CE91 A58F            	   642:   lda token_start+1   ; repeat for high-order byte
00:CE93 8591            	   643:   sta token_address+1
                        	   644: 
                        	   645: gc_quote_loop:
00:CE95 C8              	   646:   iny                 ; onto next character
00:CE96 B18E            	   647:   lda (token_start),Y ; get the next character in the string
00:CE98 F004            	   648:   beq gc_quote_bad
00:CE9A C90A            	   649:   cmp  #NL
00:CE9C D005            	   650:   bne  gc_quote_loop_not_end_of_line
                        	   651: 
                        	   652: gc_quote_bad:
00:CE9E A208            	   653:   ldx  #8         ; MISSING QUOTE: Incorrect string
00:CEA0 4CAB99          	   654:   jmp  ERROR
                        	   655: 
                        	   656: gc_quote_loop_not_end_of_line:
00:CEA3 C598            	   657:   cmp  token_work  ; same as start quote?
00:CEA5 D037            	   658:   bne  gc_quote_not_finished       ; no
00:CEA7 C8              	   659:   iny
00:CEA8 B18E            	   660:   lda (token_start),Y ; see if another quote follows
00:CEAA C598            	   661:   cmp  token_work
00:CEAC F05A            	   662:   beq  gc_quote_not_backslash      ; embedded quote (ie. two quotes in a row)? Store a single quote symbol
                        	   663:   ;
                        	   664:   ;  here at end of quoted string
                        	   665:   ;
00:CEAE 8498            	   666:   sty  token_work  ; remember how far through our input we are
00:CEB0 A003            	   667:   ldy  #3          ; OK, we have the final quote, so is the string <= 3 characters long?
00:CEB2 C492            	   668:   cpy  token_length
00:CEB4 9002            	   669:   bcc  gc_quote_long_string   ; BLT - no
00:CEB6 A492            	   670:   ldy  token_length           ; yes - load its actual length into Y (ie. 0, 1, 2, 3)
                        	   671: gc_quote_long_string:
00:CEB8 88              	   672:   dey      ; zero-relative
00:CEB9 3008            	   673:   bmi  gc_quote_copied_value   ; keep going into the length done
00:CEBB B90002          	   674:   lda  INBUF,Y   ; store the (up to) 3 bytes into VALUE as the token value
00:CEBE 999400          	   675:   sta  token_value,Y
00:CEC1 D0F5            	   676:   bne  gc_quote_long_string   ; keep going until we hit the 0x00 at the end
                        	   677: 
                        	   678: gc_quote_copied_value:
00:CEC3 A592            	   679:   lda  token_length    ; now see how long it is?
00:CEC5 D005            	   680:   bne  gc_quote_done     ; don't allow zero length strings
00:CEC7 A20E            	   681:   ldx  #14        ; BAD STRING: literal string of zero length
00:CEC9 4CAB99          	   682:   jmp  ERROR
                        	   683: 
                        	   684: gc_quote_done:
00:CECC 18              	   685:   clc
00:CECD A58E            	   686:   lda token_start       ; bump up our token_start address to past the quoted string
00:CECF 6598            	   687:   adc token_work        ; now add its (actual) length, not the length afer mucking around
00:CED1 858E            	   688:   sta token_start       ; that gives the ending address
00:CED3 A58F            	   689:   lda token_start+1   ; repeat for high-order byte
00:CED5 6900            	   690:   adc #0
00:CED7 858F            	   691:   sta token_start+1
00:CED9 A922            	   692:   lda  #TOKEN_STRING   ; it's a string token
00:CEDB 8593            	   693:   sta  token_type
00:CEDD 60              	   694:   rts
                        	   695: 
                        	   696: 
                        	   697: gc_quote_not_finished:
00:CEDE C95C            	   698:   cmp #$5C    ; backslash?
00:CEE0 D026            	   699:   bne  gc_quote_not_backslash
                        	   700: ;
                        	   701: ;  backslash - see what follows
                        	   702: ;
00:CEE2 C8              	   703:   iny
00:CEE3 B18E            	   704:   lda (token_start),Y ; the character after the backslash
00:CEE5 F0B7            	   705:   beq gc_quote_bad    ; nothing? bad
00:CEE7 200492          	   706:   jsr MAKE_UPPER
00:CEEA C958            	   707:   cmp #'X'
00:CEEC F038            	   708:   beq gc_quote_hex_character
00:CEEE A200            	   709:   ldx #0
                        	   710: gc_quote_backslash_loop:
00:CEF0 DD71CE          	   711:   cmp gc_backslash_tokens,X
00:CEF3 F00F            	   712:   beq gc_quote_found_backslash_character   ; good match
00:CEF5 E8              	   713:   inx
00:CEF6 E8              	   714:   inx
00:CEF7 E016            	   715:   cpx #gc_backslash_tokens_length
00:CEF9 90F5            	   716:   bcc gc_quote_backslash_loop
                        	   717: gc_quote_bad_string:
00:CEFB A208            	   718:   ldx #8
00:CEFD 4CAB99          	   719:   jmp ERROR   ; ERROR: Incorrect string
                        	   720: 
                        	   721: gc_quote_hex_character_done:
00:CF00 A594            	   722:   lda token_value
00:CF02 8004            	   723:   bra gc_quote_not_backslash
                        	   724: 
                        	   725: gc_quote_found_backslash_character:
00:CF04 E8              	   726:   inx
00:CF05 BD71CE          	   727:   lda gc_backslash_tokens,X  ; get its replacement
                        	   728: 
                        	   729: gc_quote_not_backslash:
00:CF08 A692            	   730:   ldx  token_length
00:CF0A 9D0002          	   731:   sta  INBUF,x           ; store it in INBUF
00:CF0D E692            	   732:   inc  token_length
00:CF0F F003            	   733:   beq  gc_quote_too_long
00:CF11 4C95CE          	   734:   jmp  gc_quote_loop     ; keep adding to string
                        	   735: 
                        	   736: 
                        	   737: gc_quote_too_long:
                        	   738:   ;            string over 255 characters long - error!
00:CF14 A21D            	   739:   ldx   #29  ; ERROR: string literal too big
00:CF16 4CAB99          	   740:   jmp  ERROR
                        	   741: 
                        	   742: ;
                        	   743: ;  "fix" a hex digit by making it upper-case, then subtracting 7 if it is A-F
                        	   744: ;   then subtracting '0' so we get a number in the range 0x00 to 0x0F in A
                        	   745: ;
                        	   746: gc_fix_hex:
00:CF19 200492          	   747:   jsr  MAKE_UPPER
00:CF1C C941            	   748:   cmp  #'A'
00:CF1E 9002            	   749:   bcc  gc_fix_hex_not_a_to_f
00:CF20 E907            	   750:   sbc  #7
                        	   751: gc_fix_hex_not_a_to_f:
00:CF22 38              	   752:   sec
00:CF23 E930            	   753:   sbc  #'0'
00:CF25 60              	   754:   rts
                        	   755: 
                        	   756: gc_quote_hex_character:
00:CF26 C8              	   757:   iny
00:CF27 F0EB            	   758:   beq  gc_quote_too_long
00:CF29 B18E            	   759:   lda  (token_start),Y ; the character after the backslash
00:CF2B 203E81          	   760:   jsr  isxdigit
00:CF2E 90CB            	   761:   bcc  gc_quote_bad_string  ; what? should be hex
00:CF30 2019CF          	   762:   jsr  gc_fix_hex
00:CF33 8594            	   763:   sta  token_value  ; first nibble
00:CF35 C8              	   764:   iny
00:CF36 F0DC            	   765:   beq  gc_quote_too_long
00:CF38 B18E            	   766:   lda  (token_start),Y ; a second hex character?
00:CF3A F0BF            	   767:   beq  gc_quote_bad_string
00:CF3C 203E81          	   768:   jsr  isxdigit
00:CF3F 9011            	   769:   bcc  gc_quote_hex_character_one_only
00:CF41 2019CF          	   770:   jsr  gc_fix_hex
00:CF44 0694            	   771:   asl  token_value    ; shift existing value 4 bits left
00:CF46 0694            	   772:   asl  token_value
00:CF48 0694            	   773:   asl  token_value
00:CF4A 0694            	   774:   asl  token_value
00:CF4C 0594            	   775:   ora  token_value
00:CF4E 8594            	   776:   sta  token_value
00:CF50 80AE            	   777:   bra  gc_quote_hex_character_done
                        	   778: 
                        	   779: gc_quote_hex_character_one_only:
00:CF52 88              	   780:   dey         ; undo add since we didn't find another hex character
00:CF53 80AB            	   781:   bra gc_quote_hex_character_done
                        	   782: 
                        	   783: ;
                        	   784: ;  $nnnnnn where nnnnnn is one or more hex digits
                        	   785: ;    if no hex digits, then it is the token '$'
                        	   786: ;
                        	   787: gc_dollar:
00:CF55 A001            	   788:   ldy  #1    ; start with the character after the dollar
00:CF57 B18E            	   789:   lda  (token_start),Y ; followed by a hex character?
00:CF59 203E81          	   790:   jsr  isxdigit
00:CF5C B003            	   791:   bcs  gc_hex_literal
00:CF5E 4C15CC          	   792:   jmp  gc_single_byte_already_known
                        	   793: 
                        	   794: gc_hex_literal:
00:CF61 2019CF          	   795:   jsr gc_fix_hex
00:CF64 8594            	   796:   sta token_value       ; store the first digit
00:CF66 6495            	   797:   stz token_value+1
00:CF68 6496            	   798:   stz token_value+2
                        	   799: gc_hex_loop:
00:CF6A C8              	   800:   iny
00:CF6B B18E            	   801:   lda (token_start),Y ; followed by another hex character?
00:CF6D 203E81          	   802:   jsr isxdigit
00:CF70 9033            	   803:   bcc gc_hex_done
00:CF72 2019CF          	   804:   jsr gc_fix_hex
                        	   805: ;
                        	   806: ;  shift the existing value left 4 bits to make room for the new nibble
                        	   807: ;
00:CF75 0694            	   808:   asl  token_value        ; token_value shifted left 1 bit
00:CF77 2695            	   809:   rol  token_value+1
00:CF79 2696            	   810:   rol  token_value+2
00:CF7B B02D            	   811:   bcs  gc_hex_too_big
00:CF7D 0694            	   812:   asl  token_value        ; token_value shifted left 2 bits
00:CF7F 2695            	   813:   rol  token_value+1
00:CF81 2696            	   814:   rol  token_value+2
00:CF83 B025            	   815:   bcs  gc_hex_too_big
00:CF85 0694            	   816:   asl  token_value        ; token_value shifted left 3 bits
00:CF87 2695            	   817:   rol  token_value+1
00:CF89 2696            	   818:   rol  token_value+2
00:CF8B B01D            	   819:   bcs  gc_hex_too_big
00:CF8D 0694            	   820:   asl  token_value        ; token_value shifted left 4 bits
00:CF8F 2695            	   821:   rol  token_value+1
00:CF91 2696            	   822:   rol  token_value+2
00:CF93 B015            	   823:   bcs  gc_hex_too_big
00:CF95 6594            	   824:   adc  token_value        ; now add in this last digit (carry will be clear)
00:CF97 8594            	   825:   sta  token_value        ; store the new result
00:CF99 90CF            	   826:   bcc  gc_hex_loop
00:CF9B E695            	   827:   inc  token_value+1
00:CF9D 90CB            	   828:   bcc  gc_hex_loop
00:CF9F E695            	   829:   inc  token_value+1
00:CFA1 B007            	   830:   bcs  gc_hex_too_big
00:CFA3 80C5            	   831:   bra  gc_hex_loop
                        	   832: 
                        	   833: gc_hex_done:
00:CFA5 A94E            	   834:   lda #TOKEN_NUMBER
00:CFA7 4C19CC          	   835:   jmp gc_done
                        	   836: 
                        	   837: gc_hex_too_big:
00:CFAA A21E            	   838:   ldx  #30       ; ERROR: Number out of Range
00:CFAC 4CAB99          	   839:   jmp  ERROR
                        	   840: 
                        	   841: ;
                        	   842: ;  %nnnnnn where nnnnnn is one or more binary digits
                        	   843: ;    if no binary digits, then it is the token '%'
                        	   844: ;
                        	   845: 
                        	   846: gc_percent:
00:CFAF A001            	   847:   ldy  #1    ; start with the character after the %
00:CFB1 B18E            	   848:   lda  (token_start),Y ; followed by a binary character?
00:CFB3 206E81          	   849:   jsr  isbinary
00:CFB6 B003            	   850:   bcs  gc_binary_literal
00:CFB8 4C15CC          	   851:   jmp  gc_single_byte_already_known
                        	   852: 
                        	   853: gc_binary_literal:
00:CFBB E930            	   854:   sbc #'0'              ; we know carry is set
00:CFBD 8594            	   855:   sta token_value       ; store the first digit
00:CFBF 6495            	   856:   stz token_value+1
00:CFC1 6496            	   857:   stz token_value+2
                        	   858: gc_binary_loop:
00:CFC3 C8              	   859:   iny
00:CFC4 B18E            	   860:   lda (token_start),Y ; followed by another binary character?
00:CFC6 206E81          	   861:   jsr isbinary
00:CFC9 90DA            	   862:   bcc gc_hex_done
00:CFCB E930            	   863:   sbc #'0'              ; we know carry is set
                        	   864: 
00:CFCD 6A              	   865:   ror A   ; get the new bit into Carry
00:CFCE 2694            	   866:   rol token_value
00:CFD0 2695            	   867:   rol token_value+1
00:CFD2 2696            	   868:   rol token_value+2
00:CFD4 90ED            	   869:   bcc gc_binary_loop
00:CFD6 4CAACF          	   870:   jmp gc_hex_too_big   ; number too large
                        	   871: 
                        	   872: ;
                        	   873: ;  token : might be :=
                        	   874: ;
                        	   875: gc_colon:
00:CFD9 A001            	   876:   ldy  #1               ; get the next character
00:CFDB B18E            	   877:   lda  (token_start),Y  ; followed by = ?
00:CFDD C93D            	   878:   cmp  #'='
00:CFDF F003            	   879:   beq  gc_assign
00:CFE1 4C15CC          	   880:   jmp  gc_single_byte_already_known
                        	   881: 
                        	   882: gc_assign:
00:CFE4 A941            	   883:   lda #TOKEN_ASSIGN
00:CFE6 C8              	   884:   iny
00:CFE7 4C19CC          	   885:   jmp gc_done
                        	   886: 
                        	   887: ;
                        	   888: ;  token: < might be <=, <>, <<
                        	   889: ;
                        	   890: gc_less_than:
00:CFEA A001            	   891:   ldy  #1               ; get the next character
00:CFEC B18E            	   892:   lda  (token_start),Y  ; followed by = ?
00:CFEE C8              	   893:   iny                   ; make it a 2-byte token
00:CFEF C93D            	   894:   cmp  #'='
00:CFF1 F00B            	   895:   beq  gc_leq
00:CFF3 C93E            	   896:   cmp  #'>'
00:CFF5 F00C            	   897:   beq  gc_neq
00:CFF7 C93C            	   898:   cmp  #'<'
00:CFF9 F00D            	   899:   beq  gc_shift_left
00:CFFB 4C15CC          	   900:   jmp  gc_single_byte_already_known
                        	   901: 
                        	   902: gc_leq:
00:CFFE A980            	   903:   lda #TOKEN_LEQ
00:D000 4C19CC          	   904:   jmp gc_done
                        	   905: 
                        	   906: gc_neq:
00:D003 A955            	   907:   lda #TOKEN_NEQ
00:D005 4C19CC          	   908:   jmp gc_done
                        	   909: 
                        	   910: gc_shift_left:
00:D008 A94C            	   911:   lda #TOKEN_SHIFT_LEFT
00:D00A 4C19CC          	   912:   jmp gc_done
                        	   913: 
                        	   914: ;
                        	   915: ;  token: > might be <>=, >>
                        	   916: ;
                        	   917: gc_greater_than:
00:D00D A001            	   918:   ldy  #1               ; get the next character
00:D00F B18E            	   919:   lda  (token_start),Y  ; followed by = ?
00:D011 C8              	   920:   iny                   ; make it a 2-byte token
00:D012 C93D            	   921:   cmp  #'='
00:D014 F007            	   922:   beq  gc_geq
00:D016 C93E            	   923:   cmp  #'>'
00:D018 F008            	   924:   beq  gc_shift_right
                        	   925: 
                        	   926: gc_single_byte_already_knownJ2:
00:D01A 4C15CC          	   927:   jmp  gc_single_byte_already_known
                        	   928: 
                        	   929: gc_geq:
00:D01D A981            	   930:   lda #TOKEN_GEQ
00:D01F 4C19CC          	   931:   jmp gc_done
                        	   932: 
                        	   933: gc_shift_right:
00:D022 A952            	   934:   lda #TOKEN_SHIFT_RIGHT
00:D024 4C19CC          	   935:   jmp gc_done
                        	   936: 
                        	   937: 
                        	   938: ;
                        	   939: ;  minus and plus sign
                        	   940: ;
                        	   941: 
                        	   942: gc_minus:
00:D027 8597            	   943:   sta token_sign
                        	   944: gc_plus:
                        	   945: 
                        	   946: ;
                        	   947: ;  new stuff - treat a sign as a token on its own if the previous token was one of:
                        	   948: ;    a) a number
                        	   949: ;    b) an identifier
                        	   950: ;    c) a RH bracket
                        	   951: ;
                        	   952: ;  So, for example: 2+3 is three tokens, but 2+-5 is also three, as the -5 becomes one token
                        	   953: ;
00:D029 A598            	   954:   lda  token_work            ; saved previous token on entry to get_token
00:D02B C94E            	   955:   cmp  #TOKEN_NUMBER
00:D02D F0EB            	   956:   beq  gc_single_byte_already_knownJ2
00:D02F C949            	   957:   cmp  #TOKEN_IDENTIFIER
00:D031 F0E7            	   958:   beq  gc_single_byte_already_knownJ2
00:D033 C929            	   959:   cmp  #')'
00:D035 F0E3            	   960:   beq  gc_single_byte_already_knownJ2
                        	   961: ;
                        	   962: ;  if not, see if this is a signed number (ie. it is directly followed by a digit)
                        	   963: ;
00:D037 A001            	   964:   ldy  #1               ; get the next character
00:D039 B18E            	   965:   lda  (token_start),Y  ; followed by a digit?
00:D03B 203281          	   966:   jsr  isdigit
00:D03E 90DA            	   967:   bcc  gc_single_byte_already_knownJ2
00:D040 20C2CC          	   968:   jsr atoi
00:D043 A94E            	   969:   lda  #TOKEN_NUMBER
00:D045 4C19CC          	   970:   jmp  gc_done
                        	   971: 
                        	   972: 
                        	   973: ;
                        	   974: ;  token: & might be &&
                        	   975: ;
                        	   976: gc_ampersand:
00:D048 A001            	   977:   ldy  #1               ; get the next character
00:D04A B18E            	   978:   lda  (token_start),Y  ; followed by & ?
00:D04C C926            	   979:   cmp  #'&'
00:D04E F003            	   980:   beq  gc_logical_and
00:D050 4C15CC          	   981:   jmp  gc_single_byte_already_known
                        	   982: 
                        	   983: gc_logical_and:
00:D053 A958            	   984:   lda #TOKEN_LOGICAL_AND
00:D055 C8              	   985:   iny
00:D056 4C19CC          	   986:   jmp gc_done
                        	   987: 
                        	   988: ;
                        	   989: ;  token: | might be ||
                        	   990: ;
                        	   991: gc_bar:
00:D059 A001            	   992:   ldy  #1               ; get the next character
00:D05B B18E            	   993:   lda  (token_start),Y  ; followed by | ?
00:D05D C97C            	   994:   cmp  #'|'
00:D05F F003            	   995:   beq  gc_logical_or
00:D061 4C15CC          	   996:   jmp  gc_single_byte_already_known
                        	   997: 
                        	   998: gc_logical_or:
00:D064 A959            	   999:   lda #TOKEN_LOGICAL_OR
00:D066 C8              	  1000:   iny
00:D067 4C19CC          	  1001:   jmp gc_done
                        	  1002: 
                        	  1003: ;
                        	  1004: ;  token: = might be ==
                        	  1005: ;
                        	  1006: gc_equals:
00:D06A A001            	  1007:   ldy  #1               ; get the next character
00:D06C B18E            	  1008:   lda  (token_start),Y  ; followed by = ?
00:D06E C93D            	  1009:   cmp  #'='
00:D070 F003            	  1010:   beq  gc_equality
00:D072 4C15CC          	  1011:   jmp  gc_single_byte_already_known
                        	  1012: 
                        	  1013: gc_equality:
00:D075 A945            	  1014:   lda #TOKEN_EQUALITY
00:D077 C8              	  1015:   iny
00:D078 4C19CC          	  1016:   jmp gc_done
                        	  1017: 
                        	  1018: ;
                        	  1019: ;  token: ! might be !=
                        	  1020: ;
                        	  1021: gc_bang:
00:D07B A001            	  1022:   ldy  #1               ; get the next character
00:D07D B18E            	  1023:   lda  (token_start),Y  ; followed by = ?
00:D07F C93D            	  1024:   cmp  #'='
00:D081 F003            	  1025:   beq  gc_inequality
00:D083 4C15CC          	  1026:   jmp  gc_single_byte_already_known
                        	  1027: 
                        	  1028: gc_inequality:
00:D086 A95A            	  1029:   lda #TOKEN_INEQUALITY
00:D088 C8              	  1030:   iny
00:D089 4C19CC          	  1031:   jmp gc_done
                        	  1032: 
                        	  1033: 
                        	  1034: 
                        	  1035: ; Pascal tokens
                        	  1036: 
                        	  1037: TOKEN_CONST     = $82
                        	  1038: TOKEN_VAR       = $83
                        	  1039: TOKEN_ARRAY     = $84
                        	  1040: TOKEN_OF        = $85
                        	  1041: TOKEN_PROCEDURE = $86
                        	  1042: TOKEN_FUNCTION  = $87
                        	  1043: TOKEN_BEGIN     = $88
                        	  1044: TOKEN_END       = $89
                        	  1045: TOKEN_OR        = $8A
                        	  1046: TOKEN_DIV       = $8B
                        	  1047: TOKEN_MOD       = $8C
                        	  1048: TOKEN_AND       = $8D
                        	  1049: TOKEN_SHL       = $8E
                        	  1050: TOKEN_SHR       = $8F
                        	  1051: TOKEN_NOT       = $90
                        	  1052: TOKEN_MEM       = $91
                        	  1053: TOKEN_IF        = $92
                        	  1054: TOKEN_THEN      = $93
                        	  1055: TOKEN_ELSE      = $94
                        	  1056: TOKEN_CASE      = $95
                        	  1057: TOKEN_WHILE     = $96
                        	  1058: TOKEN_DO        = $97
                        	  1059: TOKEN_REPEAT    = $98
                        	  1060: TOKEN_UNTIL     = $99
                        	  1061: TOKEN_FOR       = $9A
                        	  1062: TOKEN_TO        = $9B
                        	  1063: TOKEN_DOWNTO    = $9C
                        	  1064: TOKEN_WRITE     = $9D
                        	  1065: TOKEN_READ      = $9E
                        	  1066: TOKEN_CALL      = $9F
                        	  1067: TOKEN_CHAR      = $A1
                        	  1068: TOKEN_MEMC      = $A2
                        	  1069: TOKEN_XOR       = $A4
                        	  1070: TOKEN_ADDRESS   = $A9
                        	  1071: TOKEN_CHR       = $AB
                        	  1072: TOKEN_HEX       = $AC
                        	  1073: ; $B0 to $DE used by message tokens
                        	  1074: TOKEN_LCDWRITE  = $F1
                        	  1075: TOKEN_INTEGER   = $FE
                        	  1076: TOKEN_WRITELN   = $FF
                        	  1077: 
                        	  1078: 
                        	  1079: 
                        	  1080: ; RESERVED WORD TABLE
                        	  1081: ;
                        	  1082: ;***********************************************
                        	  1083:          .macro makeToken  ; MACRO DEFINITION FOR TOKENS: Length, token number, token name
                        	  1084:          DFB  \1
                        	  1085:          DFB  \2
                        	  1086:          text  \3
                        	  1087:          .endmacro           ; END OF MACRO
                        	  1088: 
                        	  1089: ;
                        	  1090: ; Reserved words are identified internally by their code (eg. $86 for PROCEDURE)
                        	  1091: ;
                        	  1092: ;  They are also stored "tokenised" and expanded out when you list the source
                        	  1093: ;
                        	  1094: ; Other tokens are:
                        	  1095: ;  * Punctuation (eg. "<", ">", "=", ".", "(", ")", "$", "+", "-"
                        	  1096: ;  * Identifiers: "I"        (eg. MY_VARIABLE)
                        	  1097: ;  * Constant numbers: "N"   (eg. -1234 and $1234)
                        	  1098: ;  * Literal strings:  '"' (quote symbol)  (eg. "Nick")
                        	  1099: ;  * Double-character punctuation:
                        	  1100: ;       <= : $80
                        	  1101: ;       >= : $81
                        	  1102: ;       Unequal (<>) : "U"
                        	  1103: ;       Assignment (:=) : "A"
                        	  1104: ;
                        	  1105: ; Comments are skipped: (* some comment *)
                        	  1106: ;
                        	  1107: ;
                        	  1108: ; However comments can have compiler directives embedded, eg. (*%A $4000) - put P-codes at $4000
                        	  1109: ;    (*%L*) - list during compile
                        	  1110: ;    (*%N*) - stop listing during compile (cancels %L and %P)
                        	  1111: ;    (*%P*) - show P-codes during compile
                        	  1112: ;    (*%A  $nnnn *) - put P-codes at address $nnnn - must be at START of program
                        	  1113: ;
                        	  1114: ;
                        	  1115: 
                        	  1116: ;              Length   Code             Name
                        	  1117: ;                  --   --------------- ---------------
                        	  1118: RSVWRD   =  *
                        	  1119:    makeToken   5, TOKEN_CONST     ,"CONST"
00:D08C 05              	     1M          DFB  5
00:D08D 82              	     2M          DFB  TOKEN_CONST     
00:D08E 434F4E5354      	     3M          text  "CONST"
                        	  1120:    makeToken   3, TOKEN_VAR       ,"VAR"
00:D093 03              	     1M          DFB  3
00:D094 83              	     2M          DFB  TOKEN_VAR       
00:D095 564152          	     3M          text  "VAR"
                        	  1121:    makeToken   5, TOKEN_ARRAY     ,"ARRAY"
00:D098 05              	     1M          DFB  5
00:D099 84              	     2M          DFB  TOKEN_ARRAY     
00:D09A 4152524159      	     3M          text  "ARRAY"
                        	  1122:    makeToken   2, TOKEN_OF        ,"OF"
00:D09F 02              	     1M          DFB  2
00:D0A0 85              	     2M          DFB  TOKEN_OF        
00:D0A1 4F46            	     3M          text  "OF"
                        	  1123:    makeToken   9, TOKEN_PROCEDURE ,"PROCEDURE"
00:D0A3 09              	     1M          DFB  9
00:D0A4 86              	     2M          DFB  TOKEN_PROCEDURE 
00:D0A5 50524F4345445552	     3M          text  "PROCEDURE"
00:D0AD 45
                        	  1124:    makeToken   8, TOKEN_FUNCTION  ,"FUNCTION"
00:D0AE 08              	     1M          DFB  8
00:D0AF 87              	     2M          DFB  TOKEN_FUNCTION  
00:D0B0 46554E4354494F4E	     3M          text  "FUNCTION"
                        	  1125:    makeToken   5, TOKEN_BEGIN     ,"BEGIN"
00:D0B8 05              	     1M          DFB  5
00:D0B9 88              	     2M          DFB  TOKEN_BEGIN     
00:D0BA 424547494E      	     3M          text  "BEGIN"
                        	  1126:    makeToken   3, TOKEN_END       ,"END"
00:D0BF 03              	     1M          DFB  3
00:D0C0 89              	     2M          DFB  TOKEN_END       
00:D0C1 454E44          	     3M          text  "END"
                        	  1127:    makeToken   2, TOKEN_OR        ,"OR"
00:D0C4 02              	     1M          DFB  2
00:D0C5 8A              	     2M          DFB  TOKEN_OR        
00:D0C6 4F52            	     3M          text  "OR"
                        	  1128:    makeToken   3, TOKEN_DIV       ,"DIV"
00:D0C8 03              	     1M          DFB  3
00:D0C9 8B              	     2M          DFB  TOKEN_DIV       
00:D0CA 444956          	     3M          text  "DIV"
                        	  1129:    makeToken   3, TOKEN_MOD       ,"MOD"
00:D0CD 03              	     1M          DFB  3
00:D0CE 8C              	     2M          DFB  TOKEN_MOD       
00:D0CF 4D4F44          	     3M          text  "MOD"
                        	  1130:    makeToken   3, TOKEN_AND       ,"AND"
00:D0D2 03              	     1M          DFB  3
00:D0D3 8D              	     2M          DFB  TOKEN_AND       
00:D0D4 414E44          	     3M          text  "AND"
                        	  1131:    makeToken   3, TOKEN_SHL       ,"SHL"
00:D0D7 03              	     1M          DFB  3
00:D0D8 8E              	     2M          DFB  TOKEN_SHL       
00:D0D9 53484C          	     3M          text  "SHL"
                        	  1132:    makeToken   3, TOKEN_SHR       ,"SHR"
00:D0DC 03              	     1M          DFB  3
00:D0DD 8F              	     2M          DFB  TOKEN_SHR       
00:D0DE 534852          	     3M          text  "SHR"
                        	  1133:    makeToken   3, TOKEN_NOT       ,"NOT"
00:D0E1 03              	     1M          DFB  3
00:D0E2 90              	     2M          DFB  TOKEN_NOT       
00:D0E3 4E4F54          	     3M          text  "NOT"
                        	  1134:    makeToken   3, TOKEN_MEM       ,"MEM"
00:D0E6 03              	     1M          DFB  3
00:D0E7 91              	     2M          DFB  TOKEN_MEM       
00:D0E8 4D454D          	     3M          text  "MEM"
                        	  1135:    makeToken   2, TOKEN_IF        ,"IF"
00:D0EB 02              	     1M          DFB  2
00:D0EC 92              	     2M          DFB  TOKEN_IF        
00:D0ED 4946            	     3M          text  "IF"
                        	  1136:    makeToken   4, TOKEN_THEN      ,"THEN"
00:D0EF 04              	     1M          DFB  4
00:D0F0 93              	     2M          DFB  TOKEN_THEN      
00:D0F1 5448454E        	     3M          text  "THEN"
                        	  1137:    makeToken   4, TOKEN_ELSE      ,"ELSE"
00:D0F5 04              	     1M          DFB  4
00:D0F6 94              	     2M          DFB  TOKEN_ELSE      
00:D0F7 454C5345        	     3M          text  "ELSE"
                        	  1138:    makeToken   4, TOKEN_CASE      ,"CASE"
00:D0FB 04              	     1M          DFB  4
00:D0FC 95              	     2M          DFB  TOKEN_CASE      
00:D0FD 43415345        	     3M          text  "CASE"
                        	  1139:    makeToken   5, TOKEN_WHILE     ,"WHILE"
00:D101 05              	     1M          DFB  5
00:D102 96              	     2M          DFB  TOKEN_WHILE     
00:D103 5748494C45      	     3M          text  "WHILE"
                        	  1140:    makeToken   2, TOKEN_DO        ,"DO"
00:D108 02              	     1M          DFB  2
00:D109 97              	     2M          DFB  TOKEN_DO        
00:D10A 444F            	     3M          text  "DO"
                        	  1141:    makeToken   6, TOKEN_REPEAT    ,"REPEAT"
00:D10C 06              	     1M          DFB  6
00:D10D 98              	     2M          DFB  TOKEN_REPEAT    
00:D10E 524550454154    	     3M          text  "REPEAT"
                        	  1142:    makeToken   5, TOKEN_UNTIL     ,"UNTIL"
00:D114 05              	     1M          DFB  5
00:D115 99              	     2M          DFB  TOKEN_UNTIL     
00:D116 554E54494C      	     3M          text  "UNTIL"
                        	  1143:    makeToken   3, TOKEN_FOR       ,"FOR"
00:D11B 03              	     1M          DFB  3
00:D11C 9A              	     2M          DFB  TOKEN_FOR       
00:D11D 464F52          	     3M          text  "FOR"
                        	  1144:    makeToken   2, TOKEN_TO        ,"TO"
00:D120 02              	     1M          DFB  2
00:D121 9B              	     2M          DFB  TOKEN_TO        
00:D122 544F            	     3M          text  "TO"
                        	  1145:    makeToken   6, TOKEN_DOWNTO    ,"DOWNTO"
00:D124 06              	     1M          DFB  6
00:D125 9C              	     2M          DFB  TOKEN_DOWNTO    
00:D126 444F574E544F    	     3M          text  "DOWNTO"
                        	  1146:    makeToken   5, TOKEN_WRITE     ,"WRITE"
00:D12C 05              	     1M          DFB  5
00:D12D 9D              	     2M          DFB  TOKEN_WRITE     
00:D12E 5752495445      	     3M          text  "WRITE"
                        	  1147:    makeToken   4, TOKEN_READ      ,"READ"
00:D133 04              	     1M          DFB  4
00:D134 9E              	     2M          DFB  TOKEN_READ      
00:D135 52454144        	     3M          text  "READ"
                        	  1148:    makeToken   4, TOKEN_CALL      ,"CALL"
00:D139 04              	     1M          DFB  4
00:D13A 9F              	     2M          DFB  TOKEN_CALL      
00:D13B 43414C4C        	     3M          text  "CALL"
                        	  1149:    makeToken   4, TOKEN_CHAR      ,"CHAR"
00:D13F 04              	     1M          DFB  4
00:D140 A1              	     2M          DFB  TOKEN_CHAR      
00:D141 43484152        	     3M          text  "CHAR"
                        	  1150:    makeToken   4, TOKEN_MEMC      ,"MEMC"
00:D145 04              	     1M          DFB  4
00:D146 A2              	     2M          DFB  TOKEN_MEMC      
00:D147 4D454D43        	     3M          text  "MEMC"
                        	  1151:    makeToken   3, TOKEN_XOR       ,"XOR"
00:D14B 03              	     1M          DFB  3
00:D14C A4              	     2M          DFB  TOKEN_XOR       
00:D14D 584F52          	     3M          text  "XOR"
                        	  1152:    makeToken   7, TOKEN_ADDRESS   ,"ADDRESS"
00:D150 07              	     1M          DFB  7
00:D151 A9              	     2M          DFB  TOKEN_ADDRESS   
00:D152 41444452455353  	     3M          text  "ADDRESS"
                        	  1153:    makeToken   3, TOKEN_CHR       ,"CHR"
00:D159 03              	     1M          DFB  3
00:D15A AB              	     2M          DFB  TOKEN_CHR       
00:D15B 434852          	     3M          text  "CHR"
                        	  1154:    makeToken   3, TOKEN_HEX       ,"HEX"
00:D15E 03              	     1M          DFB  3
00:D15F AC              	     2M          DFB  TOKEN_HEX       
00:D160 484558          	     3M          text  "HEX"
                        	  1155:    makeToken   7, TOKEN_INTEGER   ,"INTEGER"
00:D163 07              	     1M          DFB  7
00:D164 FE              	     2M          DFB  TOKEN_INTEGER   
00:D165 494E5445474552  	     3M          text  "INTEGER"
                        	  1156:    makeToken   7, TOKEN_WRITELN   ,"WRITELN"
00:D16C 07              	     1M          DFB  7
00:D16D FF              	     2M          DFB  TOKEN_WRITELN   
00:D16E 57524954454C4E  	     3M          text  "WRITELN"
                        	  1157:    makeToken   8, TOKEN_LCDWRITE  ,"LCDWRITE"
00:D175 08              	     1M          DFB  8
00:D176 F1              	     2M          DFB  TOKEN_LCDWRITE  
00:D177 4C43445752495445	     3M          text  "LCDWRITE"
                        	  1158: 
                        	  1159: 
00:D17F 00              	  1160: RSVEND   DFB  0,0        ; END OF TABLE
00:D180 00
                        	  1161: ;
                        	  1162: 
                        	  1163: ;
                        	  1164: ;  Pascal get_token
                        	  1165: ;
                        	  1166: ;  Used in the Pascal section. Does a get_token, and then if an identifier is found tries to look
                        	  1167: ;  it up.
                        	  1168: ;
                        	  1169: pas_get_token:
00:D181 20D3CB          	  1170:   jsr get_token
00:D184 F004            	  1171:   beq pas_get_token_eof   ; branch to make sure Z flag stays set
00:D186 C949            	  1172:   cmp #TOKEN_IDENTIFIER
00:D188 F001            	  1173:   beq pas_gc_identifier
                        	  1174: pas_get_token_eof:
00:D18A 60              	  1175:   rts
                        	  1176: ;
                        	  1177: ;  here if get_token got an identifier
                        	  1178: ;
                        	  1179: pas_gc_identifier:
00:D18B A98C            	  1180:   lda  #<RSVWRD
00:D18D 8598            	  1181:   sta  token_work
00:D18F A9D0            	  1182:   lda  #>RSVWRD
00:D191 8599            	  1183:   sta  token_work+1
                        	  1184: pas_gc_loop:
00:D193 A000            	  1185:   ldy  #0
00:D195 B198            	  1186:   lda  (token_work),Y
00:D197 D003            	  1187:   bne  pas_gc_more        ; MORE TO GO
00:D199 A949            	  1188:   lda  #TOKEN_IDENTIFIER
00:D19B 60              	  1189:   rts
                        	  1190: ;
                        	  1191: ; SEARCH for RESERVED WORD
                        	  1192: ;
                        	  1193: pas_gc_more:
00:D19C B198            	  1194:   lda  (token_work),Y     ; length of word in table
00:D19E C592            	  1195:   cmp  token_length       ; same?
00:D1A0 D022            	  1196:   bne  pas_gc_no_match    ; no - can't be it then
00:D1A2 A8              	  1197:   tay                     ; length
00:D1A3 A590            	  1198:   lda  token_address      ; put token start address into SRCE
00:D1A5 8500            	  1199:   sta  SRCE
00:D1A7 A591            	  1200:   lda  token_address+1
00:D1A9 8501            	  1201:   sta  SRCE+1
00:D1AB A598            	  1202:   lda  token_work         ; put current token_work+2 into DEST
00:D1AD 18              	  1203:   clc
00:D1AE 6902            	  1204:   adc  #2
00:D1B0 8503            	  1205:   sta  DEST
00:D1B2 A599            	  1206:   lda  token_work+1
00:D1B4 6900            	  1207:   adc  #0
00:D1B6 8504            	  1208:   sta  DEST+1
00:D1B8 200182          	  1209:   jsr  str_ic_compare
00:D1BB D007            	  1210:   bne  pas_gc_no_match      ; NOT FOUND
00:D1BD A001            	  1211:   ldy  #1
00:D1BF B198            	  1212:   lda  (token_work),Y
00:D1C1 8593            	  1213:   sta  token_type
00:D1C3 60              	  1214:   rts
                        	  1215: pas_gc_no_match    =  *
00:D1C4 A000            	  1216:   ldy  #0
00:D1C6 B198            	  1217:   lda  (token_work),Y     ; token_work points to reserved word entry
00:D1C8 18              	  1218:   clc
00:D1C9 6902            	  1219:   adc  #2         ; add 2 to bypass length and code
00:D1CB 6598            	  1220:   adc  token_work
00:D1CD 8598            	  1221:   sta  token_work         ; put it back
00:D1CF 90C2            	  1222:   bcc  pas_gc_loop
00:D1D1 E699            	  1223:   inc  token_work+1       ; handle overflow
00:D1D3 80BE            	  1224:   bra  pas_gc_loop     ; try for another
                        	  1225: 
                        	  1226: 
                        	  1227: 
                        	  1228: ;***********************************************
                        	  1229: ; GET A TOKEN - CHECK THAT IT
                        	  1230: ; IS THE SAME AS IN "A", IF NOT
                        	  1231: ; CALL ERROR "X"
                        	  1232: ;***********************************************
                        	  1233: GETCHK:
00:D1D5 DA              	  1234:   phx   ; save error number
00:D1D6 48              	  1235:   pha   ; save wanted token type
00:D1D7 2081D1          	  1236:   jsr pas_get_token
00:D1DA 68              	  1237:   pla   ; get it back
00:D1DB C593            	  1238:   cmp token_type
00:D1DD F004            	  1239:   beq CHKOK
00:D1DF FA              	  1240:   plx   ; get error number back
                        	  1241: CHKNOK   =  *
00:D1E0 4CAB99          	  1242:   jmp ERROR
                        	  1243: CHKOK    =  *
00:D1E3 FA              	  1244:   plx   ; get error number back
00:D1E4 60              	  1245:   rts
                        	  1246: 
                        	  1247: ;***********************************************
                        	  1248: ; CHECK TOKEN AGREES WITH "A",
                        	  1249: ; IF NOT, GIVE ERROR "X"
                        	  1250: ;***********************************************
                        	  1251: CHKTKN:
00:D1E5 C593            	  1252:   cmp  token_type
00:D1E7 D0F7            	  1253:   bne  CHKNOK
00:D1E9 60              	  1254:   rts
                        	  1255: 
                        	  1256: ;***********************************************
                        	  1257: ;
                        	  1258: ; GET NEXT TOKEN - MUST BE IDENTIFIER
                        	  1259: ; THEN LOOK IT UP IN SYMBOL TABLE
                        	  1260: ;***********************************************
                        	  1261: 
                        	  1262: GET_LOOK:
00:D1EA A949            	  1263:   lda  #TOKEN_IDENTIFIER
00:D1EC A204            	  1264:   ldx  #4      ; ERROR: Identifier expected
00:D1EE 20D5D1          	  1265:   jsr  GETCHK
00:D1F1 4C6FBC          	  1266:   jmp  LOOKUP
                        	  1267: 

Source: "gpascal.asm"
                        	   190:   .include "i2c.inc"

Source: "i2c.inc"
                        	     1: ;
                        	     2: ;  I2C interface routines
                        	     3: ;
                        	     4: ; Author: Nick Gammon
                        	     5: ; Date: 2 March 2022
                        	     6: 
                        	     7: ; PROTOCOL
                        	     8: ;
                        	     9: ;  BUS NOT BUSY: Both data and clock lines remain HIGH.
                        	    10: ;
                        	    11: ;  START DATA TRANSFER: A change in the state of the data line, from HIGH to LOW, while the clock is
                        	    12: ;  HIGH, defines a START condition.
                        	    13: ;
                        	    14: ;  STOP DATA TRANSFER: A change in the state of the data line, from LOW to HIGH, while the clock line
                        	    15: ;  is HIGH, defines the STOP condition.
                        	    16: ;
                        	    17: ;  DATA VALID: The state of the data line represents valid data when, after a START condition, the data
                        	    18: ;  line is stable for the duration of the HIGH period of the clock signal. The data on the line must be
                        	    19: ;  changed during the LOW period of the clock signal. There is one clock pulse per bit of data.
                        	    20: ;  Each data transfer is initiated with a START co ndition and terminated with a STOP condition. The
                        	    21: ;  number of data bytes transferred between START and STOP conditions is not limited, and is
                        	    22: ;  determined by the master device. The information is transferred byte-wise and each receiver
                        	    23: ;  acknowledges with a ninth bit.
                        	    24: ;
                        	    25: ;  CLOCK STRETCHING
                        	    26: ;
                        	    27: ;  If a slave wants us to wait, or another master is attempting to take over the bus, SCL will not go
                        	    28: ;  high immediately after we set it to input (high impedance) so we therefore wait until SCL is in
                        	    29: ;  fact high before proceeding.
                        	    30: ;
                        	    31: ;  ARBITRATION
                        	    32: ;
                        	    33: ;  If two masters are attempting to write to the bus we can detect that as soon as one of them writes
                        	    34: ;  a one, but reads back a zero. This indicates that another master wrote the zero. The master that
                        	    35: ;  read back the one then abandons its attempt to write (to try again later).
                        	    36: ;
                        	    37: ;  Since, up to this point, both have read back what they wrote, the bus is not corrupted.
                        	    38: ;
                        	    39: 
                        	    40: 
                        	    41: ; Configuration of which VIA ports are used by SCL and SDA
                        	    42: 
                        	    43: I2C_SCL     = %00000100   ; SCL (serial clock) - PA2
                        	    44: I2C_SDA     = %00001000   ; SDA (serial data)  - PA3
                        	    45: 
                        	    46: I2C_PORT    = VIA_PORTA   ; PORT A
                        	    47: I2C_DDR     = VIA_DDRA    ; DDR  A
                        	    48: 
                        	    49: ;
                        	    50: ;  Initialise hardware for I2C comms.
                        	    51: ;
                        	    52: ;  Set SCL and SDA to high, however make the ports input for now
                        	    53: ;
                        	    54: i2c_init:
                        	    55: 
                        	    56: ;
                        	    57: ;  Set ports to low
                        	    58: ;
00:D1F4 A90C            	    59:   lda #I2C_SCL | I2C_SDA
00:D1F6 1CF17F          	    60:   trb I2C_PORT
                        	    61: 
                        	    62: ;
                        	    63: ;  Set ports to input
                        	    64: ;
                        	    65: 
00:D1F9 A90C            	    66:   lda #I2C_SCL | I2C_SDA
00:D1FB 1CF37F          	    67:   trb I2C_DDR
                        	    68: 
                        	    69: 
00:D1FE 60              	    70:   rts
                        	    71: 
                        	    72: ;---------------------------------------------
                        	    73: ;  delay between clock bits - could make shorter if using a 1 MHz clock
                        	    74: ;---------------------------------------------
                        	    75: i2c_delay:
00:D1FF EA              	    76:     nop
00:D200 EA              	    77:     nop
00:D201 EA              	    78:     nop
00:D202 60              	    79:     rts
                        	    80: 
                        	    81: ;---------------------------------------------
                        	    82: ;  toggle the SCL line from low to high and back again
                        	    83: ;---------------------------------------------
                        	    84: i2c_toggle_clock:
00:D203 A904            	    85:   lda #I2C_SCL
00:D205 1CF37F          	    86:   trb I2C_DDR      ; SCL high
00:D208 20FFD1          	    87:   jsr i2c_delay
                        	    88: ;
                        	    89: ;  check if the slave wants us to wait by pulling the clock low
                        	    90: ;
                        	    91: i2c_toggle_clock_wait:
00:D20B ADF17F          	    92:   lda I2C_PORT
00:D20E 2904            	    93:   and #I2C_SCL
00:D210 F0F9            	    94:   beq i2c_toggle_clock_wait   ; should be high, but is low
                        	    95: ;
                        	    96: ;  we let the clock go high, and it actually IS high, so we can proceed
                        	    97: ;
00:D212 0CF37F          	    98:   tsb I2C_DDR       ; SCL low
00:D215 A908            	    99:   lda #I2C_SDA      ; immediately set SDA to low
00:D217 1CF37F          	   100:   trb I2C_DDR
00:D21A 20FFD1          	   101:   jsr i2c_delay
00:D21D 60              	   102:   rts
                        	   103: 
                        	   104: ;---------------------------------------------
                        	   105: ;
                        	   106: ;  Begin transmission: send a start condition
                        	   107: ;
                        	   108: ;  Slave address in A, read/write bit in low-order bit
                        	   109: ;    0 = write, 1 = read
                        	   110: ;
                        	   111: ;  Sets carry if OK
                        	   112: ;
                        	   113: ;  START CONDITION:
                        	   114: ;
                        	   115: ;  A change in the state of the data line, from HIGH to LOW, while the clock is HIGH
                        	   116: ;---------------------------------------------
                        	   117: 
                        	   118: i2c_begin_transmission:
                        	   119: 
00:D21E 48              	   120:   pha             ; save address
                        	   121: 
00:D21F 20F4D1          	   122:   jsr i2c_init    ; set ports to low, and ports to input
                        	   123: 
                        	   124: ;
                        	   125: ;  Check if SDA or SCL are in use (low) - if so, wait until they are not
                        	   126: ;
                        	   127: i2c_begin_transmission_loop:
00:D222 A908            	   128:   lda #I2C_SDA
00:D224 2DF17F          	   129:   and I2C_PORT
00:D227 F0F9            	   130:   beq i2c_begin_transmission_loop
00:D229 A904            	   131:   lda #I2C_SCL
00:D22B 2DF17F          	   132:   and I2C_PORT
00:D22E F0F2            	   133:   beq i2c_begin_transmission_loop
                        	   134: 
                        	   135: ;
                        	   136: ;  The start condition pulls SDA low but SCL stays high
                        	   137: ;
                        	   138: 
00:D230 A908            	   139:   lda #I2C_SDA
00:D232 0CF37F          	   140:   tsb I2C_DDR
00:D235 20FFD1          	   141:   jsr i2c_delay
                        	   142: 
                        	   143: ;
                        	   144: ;  But now we pull SCL low ready for clocking out bits
                        	   145: ;
                        	   146: 
00:D238 A904            	   147:   lda #I2C_SCL
00:D23A 0CF37F          	   148:   tsb I2C_DDR
00:D23D 20FFD1          	   149:   jsr i2c_delay
                        	   150: 
00:D240 68              	   151:   pla   ; get address back
                        	   152: 
00:D241 2045D2          	   153:   jsr i2c_write
                        	   154: 
00:D244 60              	   155:   rts
                        	   156: 
                        	   157: ;---------------------------------------------
                        	   158: ;
                        	   159: ;  I2C write: send 8 data bits, wait for acknowledge
                        	   160: ;
                        	   161: ;---------------------------------------------
                        	   162: 
                        	   163: i2c_write:
00:D245 A208            	   164:   ldx #8  ; count of bits
00:D247 A8              	   165:   tay
                        	   166: 
                        	   167: i2c_write_loop:
00:D248 98              	   168:   tya
00:D249 2A              	   169:   rol a   ; get bit to write into carry
00:D24A A8              	   170:   tay
                        	   171: 
00:D24B B007            	   172:   bcs i2c_write_one
                        	   173: ;
                        	   174: ;  write a zero by setting SDA to output
                        	   175: ;
00:D24D A908            	   176:   lda #I2C_SDA
00:D24F 0CF37F          	   177:   tsb I2C_DDR
00:D252 800B            	   178:   bra i2c_write_clock
                        	   179: ;
                        	   180: ;  write a one by setting SDA to input
                        	   181: ;
                        	   182: i2c_write_one:
00:D254 A908            	   183:   lda #I2C_SDA
00:D256 1CF37F          	   184:   trb I2C_DDR
                        	   185: ;
                        	   186: ;  if SDA is not high, another master has taken control of the bus, abandon this write
                        	   187: ;
00:D259 EA              	   188:   nop
00:D25A 2DF17F          	   189:   and I2C_PORT
00:D25D F028            	   190:   beq i2c_write_lost_arbitration   ; error return, give up
                        	   191: 
                        	   192: ;---------------------------------------------
                        	   193: ;
                        	   194: ;  toggle clock
                        	   195: ;
                        	   196: ;---------------------------------------------
                        	   197: i2c_write_clock:
00:D25F 2003D2          	   198:   jsr i2c_toggle_clock
                        	   199: ;
                        	   200: ;  back for another bit?
                        	   201: ;
00:D262 CA              	   202:   dex
00:D263 D0E3            	   203:   bne i2c_write_loop
                        	   204: 
                        	   205:   ;---------------------------------------------
                        	   206:   ;  wait for acknowledge bit
                        	   207:   ;---------------------------------------------
                        	   208: 
                        	   209:   ;
                        	   210:   ;  make SDA input and see if it is pulled low
                        	   211:   ;
                        	   212: 
00:D265 A908            	   213:   lda #I2C_SDA
00:D267 1CF37F          	   214:   trb I2C_DDR         ; SDA to input
                        	   215: 
00:D26A A904            	   216:   lda #I2C_SCL        ; clock high
00:D26C 1CF37F          	   217:   trb I2C_DDR
                        	   218: 
                        	   219: ;
                        	   220: ;  check if the slave wants us to wait by pulling the clock low
                        	   221: ;
                        	   222: i2c_write_clock_wait:
00:D26F ADF17F          	   223:   lda I2C_PORT
00:D272 2904            	   224:   and #I2C_SCL
00:D274 F0F9            	   225:   beq i2c_write_clock_wait   ; should be high, but is low
                        	   226: 
00:D276 20FFD1          	   227:   jsr i2c_delay       ; give it time to respond
                        	   228: 
00:D279 A908            	   229:   lda #I2C_SDA
00:D27B 2DF17F          	   230:   and I2C_PORT        ; read SDA
                        	   231: 
00:D27E AA              	   232:   tax                 ; save result for a moment
00:D27F A904            	   233:   lda #I2C_SCL        ; clock low
00:D281 0CF37F          	   234:   tsb I2C_DDR
                        	   235: 
00:D284 8A              	   236:   txa             ; get ack/nak bit back
                        	   237: 
00:D285 F002            	   238:   beq i2c_write_got_ack
                        	   239: 
                        	   240: i2c_write_lost_arbitration:
00:D287 18              	   241:   clc   ; error return
00:D288 60              	   242:   rts
                        	   243: 
                        	   244: i2c_write_got_ack:
00:D289 38              	   245:   sec   ; carry means OK
00:D28A 60              	   246:   rts
                        	   247: 
                        	   248: 
                        	   249: ;---------------------------------------------
                        	   250: ;
                        	   251: ;  I2C read: receive 8 data bits, then acknowledge unless hardware_work is zero
                        	   252: ;    hardware_work will be the count of outstanding bytes to be sent
                        	   253: ;    on the last bit we NAK it to tell the sender not to send any more
                        	   254: ;
                        	   255: ;---------------------------------------------
                        	   256: 
                        	   257: i2c_read:
00:D28B A208            	   258:   ldx #8  ; count of bits
00:D28D A000            	   259:   ldy #0  ; current result
                        	   260: 
00:D28F A908            	   261:   lda #I2C_SDA
00:D291 1CF37F          	   262:   trb I2C_DDR         ; SDA to input
                        	   263: 
                        	   264: i2c_read_loop:
                        	   265: 
00:D294 A904            	   266:   lda #I2C_SCL        ; clock high
00:D296 1CF37F          	   267:   trb I2C_DDR
00:D299 20FFD1          	   268:   jsr i2c_delay       ; give it time to respond
                        	   269: 
00:D29C A908            	   270:   lda #I2C_SDA
00:D29E 2DF17F          	   271:   and I2C_PORT        ; read SDA
00:D2A1 F006            	   272:   beq i2c_read_zero
                        	   273: ;
                        	   274: ;  read a 1
                        	   275: ;
00:D2A3 98              	   276:   tya       ; get previous result
00:D2A4 38              	   277:   sec
00:D2A5 2A              	   278:   rol a     ; rotate in a one-bit
00:D2A6 A8              	   279:   tay       ; keep for later
00:D2A7 8004            	   280:   bra i2c_read_next
                        	   281: 
                        	   282: ;
                        	   283: ;  read a 0
                        	   284: ;
                        	   285: i2c_read_zero:
00:D2A9 98              	   286:   tya       ; get previous result
00:D2AA 18              	   287:   clc
00:D2AB 2A              	   288:   rol a     ; rotate in a zero-bit
00:D2AC A8              	   289:   tay       ; keep for later
                        	   290: 
                        	   291: i2c_read_next:
                        	   292: 
00:D2AD A904            	   293:   lda #I2C_SCL        ; clock low
00:D2AF 0CF37F          	   294:   tsb I2C_DDR
00:D2B2 20FFD1          	   295:   jsr i2c_delay       ; give it time to respond
                        	   296: 
                        	   297: ;
                        	   298: ;  back for another bit?
                        	   299: ;
00:D2B5 CA              	   300:   dex
00:D2B6 D0DC            	   301:   bne i2c_read_loop
                        	   302: 
00:D2B8 A58C            	   303:   lda hardware_work   ; NAK on last read so they stop sending
00:D2BA F007            	   304:   beq i2c_read_nak
                        	   305: 
00:D2BC A908            	   306:   lda #I2C_SDA
00:D2BE 0CF37F          	   307:   tsb I2C_DDR         ; pull SDA low to ACK the byte
00:D2C1 8005            	   308:   bra i2c_read_ack_or_nak
                        	   309: 
                        	   310: i2c_read_nak:
00:D2C3 A908            	   311:   lda #I2C_SDA
00:D2C5 1CF37F          	   312:   trb I2C_DDR         ; pull SDA high to NAK the final byte
                        	   313: 
                        	   314: i2c_read_ack_or_nak:
                        	   315: 
00:D2C8 A904            	   316:   lda #I2C_SCL        ; clock high
00:D2CA 1CF37F          	   317:   trb I2C_DDR
                        	   318: 
                        	   319: ;
                        	   320: ;  check if the slave wants us to wait by pulling the clock low
                        	   321: ;   (clock stretching)
                        	   322: ;
                        	   323: 
                        	   324: i2c_read_ack_or_nak_wait:
00:D2CD ADF17F          	   325:   lda I2C_PORT
00:D2D0 2904            	   326:   and #I2C_SCL
00:D2D2 F0F9            	   327:   beq i2c_read_ack_or_nak_wait   ; should be high, but is low
                        	   328: 
00:D2D4 20FFD1          	   329:   jsr i2c_delay       ; give it time to respond
                        	   330: 
00:D2D7 A904            	   331:   lda #I2C_SCL        ; clock low
00:D2D9 0CF37F          	   332:   tsb I2C_DDR
00:D2DC 20FFD1          	   333:   jsr i2c_delay
                        	   334: 
                        	   335: i2c_read_done:
                        	   336: 
00:D2DF 98              	   337:   tya                 ; result in A
00:D2E0 60              	   338:   rts
                        	   339: 
                        	   340: 
                        	   341: ;---------------------------------------------
                        	   342: ;  end transmission - send stop condition
                        	   343: ;
                        	   344: ;  STOP CONDITION:
                        	   345: ;
                        	   346: ;  A change in the state of the data line, from LOW to HIGH, while the clock is HIGH
                        	   347: ;---------------------------------------------
                        	   348: 
                        	   349: i2c_end_transmission:
                        	   350: 
                        	   351: ;
                        	   352: ;  make sure SDA is low, otherwise it can't transition low to high
                        	   353: ;
00:D2E1 A908            	   354:   lda #I2C_SDA
00:D2E3 0CF37F          	   355:   tsb I2C_DDR
                        	   356: 
00:D2E6 20FFD1          	   357:   jsr i2c_delay
                        	   358: 
                        	   359: ;
                        	   360: ;  Set SCL to input so it floats high
                        	   361: ;
00:D2E9 A904            	   362:   lda #I2C_SCL
00:D2EB 1CF37F          	   363:   trb I2C_DDR
                        	   364: 
00:D2EE 20FFD1          	   365:   jsr i2c_delay
                        	   366: 
                        	   367: ;
                        	   368: ;  Now with SCL high, set SDA to input so it also floats high
                        	   369: ;
00:D2F1 A908            	   370:   lda #I2C_SDA
00:D2F3 1CF37F          	   371:   trb I2C_DDR
                        	   372: 
00:D2F6 20FFD1          	   373:   jsr i2c_delay
                        	   374: 
                        	   375: ;
                        	   376: ;  Both SDA and SCL are now high (by the pull-up resistors) so we are done
                        	   377: ;
00:D2F9 60              	   378:   rts
                        	   379: 
                        	   380: ;---------------------------------------------
                        	   381: ;
                        	   382: ;  Send a message, address in A (excluding write bit)
                        	   383: ;  Message in (VALUE)
                        	   384: ;  Length in Y
                        	   385: ;  Returns carry set on success, carry clear on failure
                        	   386: ;
                        	   387: ;---------------------------------------------
                        	   388: i2c_send:
00:D2FA 848C            	   389:   sty hardware_work
00:D2FC 0A              	   390:   asl A     ; move zero into write bit
00:D2FD 201ED2          	   391:   jsr i2c_begin_transmission
00:D300 901C            	   392:   bcc i2c_send_fail
                        	   393: 
                        	   394: ;
                        	   395: ;  send each byte
                        	   396: ;
                        	   397: i2c_send_loop:
00:D302 A58C            	   398:   lda hardware_work           ; number of bytes to go
00:D304 F013            	   399:   beq i2c_send_done
00:D306 C68C            	   400:   dec hardware_work
00:D308 A000            	   401:   ldy #0
00:D30A B100            	   402:   lda (VALUE),Y
00:D30C 2045D2          	   403:   jsr i2c_write
00:D30F 900D            	   404:   bcc i2c_send_fail
00:D311 E600            	   405:   inc VALUE
00:D313 D0ED            	   406:   bne i2c_send_loop
00:D315 E601            	   407:   inc VALUE+1
00:D317 80E9            	   408:   bra i2c_send_loop
                        	   409: ;
                        	   410: ;  sending done
                        	   411: ;
                        	   412: i2c_send_done:
00:D319 20E1D2          	   413:   jsr i2c_end_transmission
00:D31C 38              	   414:   sec
00:D31D 60              	   415:   rts
                        	   416: ;
                        	   417: ;  sending failure
                        	   418: ;
                        	   419: i2c_send_fail:
00:D31E 20E1D2          	   420:   jsr i2c_end_transmission
00:D321 18              	   421:   clc
00:D322 60              	   422:   rts
                        	   423: 
                        	   424: ;---------------------------------------------
                        	   425: ;
                        	   426: ;  Receive messave, slave address in A (excluding write bit)
                        	   427: ;  Message in (VALUE)
                        	   428: ;  Length in Y
                        	   429: ;---------------------------------------------
                        	   430: 
                        	   431: i2c_receive:
00:D323 848C            	   432:   sty hardware_work
00:D325 38              	   433:   sec
00:D326 2A              	   434:   rol A   ; move one into write bit (so it is read mode)
00:D327 201ED2          	   435:   jsr i2c_begin_transmission
00:D32A 901F            	   436:   bcc i2c_receive_fail
                        	   437: 
                        	   438: ;
                        	   439: ;  put serial data (SDA) into input mode so we can read from it
                        	   440: ;
00:D32C A908            	   441:   lda #I2C_SDA
00:D32E 1CF37F          	   442:   trb I2C_DDR
                        	   443: 
                        	   444: ;
                        	   445: ;  receive each byte
                        	   446: ;
                        	   447: i2c_receive_loop:
00:D331 A58C            	   448:   lda hardware_work           ; number of bytes to go
00:D333 F011            	   449:   beq i2c_receive_done
00:D335 C68C            	   450:   dec hardware_work
00:D337 208BD2          	   451:   jsr i2c_read
00:D33A A000            	   452:   ldy #0
00:D33C 9100            	   453:   sta (VALUE),Y
00:D33E E600            	   454:   inc VALUE
00:D340 D0EF            	   455:   bne i2c_receive_loop
00:D342 E601            	   456:   inc VALUE+1
00:D344 80EB            	   457:   bra i2c_receive_loop
                        	   458: ;
                        	   459: ;  receiving done
                        	   460: ;
                        	   461: i2c_receive_done:
00:D346 20E1D2          	   462:   jsr i2c_end_transmission
00:D349 38              	   463:   sec
00:D34A 60              	   464:   rts
                        	   465: ;
                        	   466: ;  receiving failure
                        	   467: ;
                        	   468: i2c_receive_fail:
00:D34B 20E1D2          	   469:   jsr i2c_end_transmission
00:D34E 18              	   470:   clc
00:D34F 60              	   471:   rts
                        	   472: 
                        	   473: 

Source: "gpascal.asm"
                        	   191:   .include "spi.inc"

Source: "spi.inc"
                        	     1: ;
                        	     2: ;  SPI interface routines
                        	     3: ;
                        	     4: ; Author: Nick Gammon
                        	     5: ; Date: 6 March 2022
                        	     6: ;
                        	     7: 
                        	     8: ; Configuration of which VIA ports are used by SS, MOSI, MISO, SCK
                        	     9: 
                        	    10: SPI_SS    = %00000001   ; SS   (slave select) - PB0
                        	    11: SPI_MOSI  = %00000010   ; MOSI (master out, slave in) - PB1
                        	    12: SPI_MISO  = %00000100   ; MISO (master in, slave out) - PB2
                        	    13: SPI_SCK   = %00001000   ; SCK  (serial clock) - PB3
                        	    14: 
                        	    15: SPI_PORT    = VIA_PORTB   ; PORT B
                        	    16: SPI_DDR     = VIA_DDRB    ; DDR  B
                        	    17: 
                        	    18: ;---------------------------------------------
                        	    19: ;  Initialise hardware for SPI comms.
                        	    20: ;
                        	    21: ;  SPI mode in A, as follows:
                        	    22: 
                        	    23: ;   Mode 0 - clock is normally low,  the data is sampled on the transition from low to high (leading edge)
                        	    24: ;   Mode 1 - clock is normally low,  the data is sampled on the transition from high to low (trailing edge)
                        	    25: ;   Mode 2 - clock is normally high, the data is sampled on the transition from high to low (leading edge)
                        	    26: ;   Mode 3 - clock is normally high, the data is sampled on the transition from low to high (trailing edge)
                        	    27: ;
                        	    28: ;  Set SS, MOSI and SCK to outputs. Set MISO to input.
                        	    29: ;---------------------------------------------
                        	    30: spi_init:
                        	    31: 
00:D350 8568            	    32:   sta spi_mode
                        	    33: 
                        	    34: ;
                        	    35: ;  Set MISO to input
                        	    36: ;
                        	    37: 
00:D352 A904            	    38:   lda #SPI_MISO
00:D354 1CF27F          	    39:   trb SPI_DDR
                        	    40: 
                        	    41: ;
                        	    42: ;  Set SS to high (it is active low)
                        	    43: ;
00:D357 A901            	    44:   lda #SPI_SS
00:D359 0CF07F          	    45:   tsb SPI_PORT
                        	    46: 
                        	    47: ;
                        	    48: ; In modes 0 and 1, the clock is normally low
                        	    49: ;
00:D35C A568            	    50:   lda spi_mode
00:D35E 2902            	    51:   and #2
00:D360 D007            	    52:   bne spi_init_clock_high
                        	    53: 
00:D362 A908            	    54:   lda #SPI_SCK
00:D364 1CF07F          	    55:   trb SPI_PORT
00:D367 8005            	    56:   bra spi_init2
                        	    57: 
                        	    58: ;
                        	    59: ; In modes 2 and 3, the clock is normally high
                        	    60: ;
                        	    61: spi_init_clock_high:
00:D369 A908            	    62:   lda #SPI_SCK
00:D36B 0CF07F          	    63:   tsb SPI_PORT
                        	    64: ;
                        	    65: ;  Now set up MOSI
                        	    66: ;
                        	    67: 
                        	    68: spi_init2:
                        	    69: 
00:D36E A568            	    70:   lda spi_mode
00:D370 2901            	    71:   and #1
00:D372 D007            	    72:   bne spi_init_mosi_low
                        	    73: 
                        	    74: ;
                        	    75: ;  In modes 0 and 2, MOSI idles high
                        	    76: ;
00:D374 A902            	    77:   lda #SPI_MOSI
00:D376 0CF07F          	    78:   tsb SPI_PORT
00:D379 8005            	    79:   bra spi_init3
                        	    80: 
                        	    81: ;
                        	    82: ;  In modes 1 and 3, MOSI idles low
                        	    83: ;
                        	    84: 
                        	    85: spi_init_mosi_low:
00:D37B A902            	    86:   lda #SPI_MOSI
00:D37D 1CF07F          	    87:   trb SPI_PORT
                        	    88: 
                        	    89: ;
                        	    90: ;   Set SS, MOSI and SCK to outputs
                        	    91: ;
                        	    92: 
                        	    93: spi_init3:
00:D380 A90B            	    94:   lda #SPI_SS | SPI_MOSI | SPI_SCK
00:D382 0CF27F          	    95:   tsb SPI_DDR
                        	    96: 
00:D385 60              	    97:   rts
                        	    98: 
                        	    99: ;---------------------------------------------
                        	   100: ;  Transfer one byte.
                        	   101: ;    Byte to be sent in A.
                        	   102: ;    Returns received byte in A.
                        	   103: ;    Preserves X and Y
                        	   104: ;
                        	   105: ;   Mode 0 - clock is normally low,  the data is sampled on the transition from low to high (leading edge)
                        	   106: ;   Mode 1 - clock is normally low,  the data is sampled on the transition from high to low (trailing edge)
                        	   107: ;   Mode 2 - clock is normally high, the data is sampled on the transition from high to low (leading edge)
                        	   108: ;   Mode 3 - clock is normally high, the data is sampled on the transition from low to high (trailing edge)
                        	   109: ;---------------------------------------------
                        	   110: 
                        	   111: spi_transfer:
00:D386 DA              	   112:   phx
00:D387 5A              	   113:   phy
00:D388 A208            	   114:   ldx  #8               ; count of bits
00:D38A A8              	   115:   tay                   ; save the byte we are sending
                        	   116: spi_transfer_loop:
00:D38B 98              	   117:   tya                   ; get the byte we are sending back
                        	   118: ;
                        	   119: ;  set up MOSI, ready to be sampled on the clock transition
                        	   120: ;
00:D38C 2A              	   121:   rol A                 ; get MSB into carry
00:D38D A8              	   122:   tay                   ; save the byte which we shifted left
00:D38E 9007            	   123:   bcc spi_send_zero     ; if no carry, we are sending a zero
                        	   124: 
                        	   125: ;
                        	   126: ; here to send a one bit
                        	   127: ;
00:D390 A902            	   128:   lda #SPI_MOSI
00:D392 0CF07F          	   129:   tsb SPI_PORT    ; set MOSI to high
00:D395 8005            	   130:   bra spi_send_clock_pulse_1
                        	   131: 
                        	   132: ;
                        	   133: ; here to send a zero bit
                        	   134: ;
                        	   135: spi_send_zero:
00:D397 A902            	   136:   lda #SPI_MOSI
00:D399 1CF07F          	   137:   trb SPI_PORT    ; set MOSI to low
                        	   138: 
                        	   139: ;
                        	   140: ; transition clock
                        	   141: ;
                        	   142: spi_send_clock_pulse_1:
                        	   143: 
                        	   144: ;
                        	   145: ; In modes 0 and 1, the clock is normally low, so we need to make it high
                        	   146: ;
00:D39C A568            	   147:   lda spi_mode
00:D39E 2902            	   148:   and #2
00:D3A0 D007            	   149:   bne spi_send_clock_high_low
                        	   150: 
                        	   151: ;
                        	   152: ; Make SCK high
                        	   153: ;
00:D3A2 A908            	   154:   lda #SPI_SCK
00:D3A4 0CF07F          	   155:   tsb SPI_PORT
00:D3A7 8005            	   156:   bra spi_send2
                        	   157: 
                        	   158: ;
                        	   159: ; Otherwise we need to make it low
                        	   160: ;
                        	   161: spi_send_clock_high_low:
                        	   162: ;
                        	   163: ;  Make SCK low
                        	   164: ;
00:D3A9 A908            	   165:   lda #SPI_SCK
00:D3AB 1CF07F          	   166:   trb SPI_PORT
                        	   167: 
                        	   168: ;
                        	   169: ;  We have done the leading edge of SCK
                        	   170: ;
                        	   171: spi_send2:
                        	   172: 
                        	   173: ;
                        	   174: ;  In modes 1 and 3 we sample on the trailing edge, so do nothing here
                        	   175: ;
00:D3AE A568            	   176:   lda spi_mode
00:D3B0 2901            	   177:   and #1
00:D3B2 D00B            	   178:   bne spi_send3
                        	   179: 
                        	   180: ;
                        	   181: ;  sample incoming data on leading edge
                        	   182: ;
00:D3B4 18              	   183:   clc
00:D3B5 A904            	   184:   lda #SPI_MISO
00:D3B7 2DF07F          	   185:   and SPI_PORT
00:D3BA F001            	   186:   beq spi_read_02_done
00:D3BC 38              	   187:   sec
                        	   188: spi_read_02_done:
00:D3BD 268C            	   189:   rol hardware_work   ; rotate in zero or one from carry
                        	   190: 
                        	   191: spi_send3:
                        	   192: 
                        	   193: ;
                        	   194: ;  transition clock again to give the trailing edge
                        	   195: ;
                        	   196: 
                        	   197: ;
                        	   198: ; In modes 0 and 1, the clock is normally low, so we need to make it low again
                        	   199: ;
00:D3BF A568            	   200:   lda spi_mode
00:D3C1 2902            	   201:   and #2
00:D3C3 D007            	   202:   bne spi_send_clock_low_high
                        	   203: 
00:D3C5 A908            	   204:   lda #SPI_SCK
00:D3C7 1CF07F          	   205:   trb SPI_PORT
00:D3CA 8005            	   206:   bra spi_send4
                        	   207: 
                        	   208: spi_send_clock_low_high:
00:D3CC A908            	   209:   lda #SPI_SCK
00:D3CE 0CF07F          	   210:   tsb SPI_PORT
                        	   211: 
                        	   212: spi_send4:
                        	   213: 
                        	   214: ;
                        	   215: ;  In modes 1 and 3 we sample on the trailing edge
                        	   216: ;
00:D3D1 A568            	   217:   lda spi_mode
00:D3D3 2901            	   218:   and #1
00:D3D5 F00B            	   219:   beq spi_send_bit_done
                        	   220: 
                        	   221: ;
                        	   222: ;  sample incoming data on trailing edge
                        	   223: ;
00:D3D7 18              	   224:   clc
00:D3D8 A904            	   225:   lda #SPI_MISO
00:D3DA 2DF07F          	   226:   and SPI_PORT
00:D3DD F001            	   227:   beq spi_read_13_done
00:D3DF 38              	   228:   sec
                        	   229: spi_read_13_done:
00:D3E0 268C            	   230:   rol hardware_work   ; rotate in zero or one from carry
                        	   231: 
                        	   232: spi_send_bit_done:
00:D3E2 CA              	   233:   dex
00:D3E3 D0A6            	   234:   bne spi_transfer_loop
                        	   235: 
                        	   236: ;
                        	   237: ;  get incoming byte back into A
                        	   238: ;
00:D3E5 7A              	   239:   ply
00:D3E6 FA              	   240:   plx
00:D3E7 A58C            	   241:   lda hardware_work
00:D3E9 60              	   242:   rts
                        	   243: 
                        	   244: 
                        	   245: ;---------------------------------------------
                        	   246: ; Select the slave (send SS low) - preserves all registers
                        	   247: ;---------------------------------------------
                        	   248: spi_ss_low:
00:D3EA 48              	   249:   pha
00:D3EB A901            	   250:   lda #SPI_SS
00:D3ED 1CF07F          	   251:   trb SPI_PORT
00:D3F0 68              	   252:   pla
00:D3F1 60              	   253:   rts
                        	   254: 
                        	   255: ;---------------------------------------------
                        	   256: ; Deselect the slave (send SS high) - preserves all registers
                        	   257: ;---------------------------------------------
                        	   258: spi_ss_high:
00:D3F2 48              	   259:   pha
00:D3F3 A901            	   260:   lda #SPI_SS
00:D3F5 0CF07F          	   261:   tsb SPI_PORT
00:D3F8 68              	   262:   pla
00:D3F9 60              	   263:   rts
                        	   264: 
                        	   265: ;---------------------------------------------
                        	   266: ;  send two bytes: first in A, second in X
                        	   267: ;   preserves all registers
                        	   268: ;---------------------------------------------
                        	   269: spi_send_two_bytes:
00:D3FA 48              	   270:   pha
00:D3FB 20EAD3          	   271:   jsr spi_ss_low    ; SS low
00:D3FE 2086D3          	   272:   jsr spi_transfer  ; send first byte
00:D401 8A              	   273:   txa               ; get second byte
00:D402 2086D3          	   274:   jsr spi_transfer  ; send second byte
00:D405 20F2D3          	   275:   jsr spi_ss_high   ; SS high again
00:D408 68              	   276:   pla
00:D409 60              	   277:   rts
                        	   278: 
                        	   279: 

Source: "gpascal.asm"
                        	   192: 
                        	   193:   .if USE_CP437_FONT
                        	   194:     .include "cp437_font.inc"

Source: "cp437_font.inc"
                        	     1: ; bit patterns for the CP437 font
                        	     2: 
                        	     3: cp437_font:
                        	     4: 
00:D40A 00              	     5:   dfb $00,$00,$00,$00,$00,$00,$00,$00 ; $00
00:D40B 00
00:D40C 00
00:D40D 00
00:D40E 00
00:D40F 00
00:D410 00
00:D411 00
00:D412 7E              	     6:   dfb $7E,$81,$A5,$81,$BD,$99,$81,$7E ; $01
00:D413 81
00:D414 A5
00:D415 81
00:D416 BD
00:D417 99
00:D418 81
00:D419 7E
00:D41A 7E              	     7:   dfb $7E,$FF,$DB,$FF,$C3,$E7,$FF,$7E ; $02
00:D41B FF
00:D41C DB
00:D41D FF
00:D41E C3
00:D41F E7
00:D420 FF
00:D421 7E
00:D422 6C              	     8:   dfb $6C,$FE,$FE,$FE,$7C,$38,$10,$00 ; $03
00:D423 FE
00:D424 FE
00:D425 FE
00:D426 7C
00:D427 38
00:D428 10
00:D429 00
00:D42A 10              	     9:   dfb $10,$38,$7C,$FE,$7C,$38,$10,$00 ; $04
00:D42B 38
00:D42C 7C
00:D42D FE
00:D42E 7C
00:D42F 38
00:D430 10
00:D431 00
00:D432 38              	    10:   dfb $38,$7C,$38,$FE,$FE,$7C,$38,$7C ; $05
00:D433 7C
00:D434 38
00:D435 FE
00:D436 FE
00:D437 7C
00:D438 38
00:D439 7C
00:D43A 10              	    11:   dfb $10,$10,$38,$7C,$FE,$7C,$38,$7C ; $06
00:D43B 10
00:D43C 38
00:D43D 7C
00:D43E FE
00:D43F 7C
00:D440 38
00:D441 7C
00:D442 00              	    12:   dfb $00,$00,$18,$3C,$3C,$18,$00,$00 ; $07
00:D443 00
00:D444 18
00:D445 3C
00:D446 3C
00:D447 18
00:D448 00
00:D449 00
00:D44A FF              	    13:   dfb $FF,$FF,$E7,$C3,$C3,$E7,$FF,$FF ; $08
00:D44B FF
00:D44C E7
00:D44D C3
00:D44E C3
00:D44F E7
00:D450 FF
00:D451 FF
00:D452 00              	    14:   dfb $00,$3C,$66,$42,$42,$66,$3C,$00 ; $09
00:D453 3C
00:D454 66
00:D455 42
00:D456 42
00:D457 66
00:D458 3C
00:D459 00
00:D45A FF              	    15:   dfb $FF,$C3,$99,$BD,$BD,$99,$C3,$FF ; $0A
00:D45B C3
00:D45C 99
00:D45D BD
00:D45E BD
00:D45F 99
00:D460 C3
00:D461 FF
00:D462 0F              	    16:   dfb $0F,$07,$0F,$7D,$CC,$CC,$CC,$78 ; $0B
00:D463 07
00:D464 0F
00:D465 7D
00:D466 CC
00:D467 CC
00:D468 CC
00:D469 78
00:D46A 3C              	    17:   dfb $3C,$66,$66,$66,$3C,$18,$7E,$18 ; $0C
00:D46B 66
00:D46C 66
00:D46D 66
00:D46E 3C
00:D46F 18
00:D470 7E
00:D471 18
00:D472 3F              	    18:   dfb $3F,$33,$3F,$30,$30,$70,$F0,$E0 ; $0D
00:D473 33
00:D474 3F
00:D475 30
00:D476 30
00:D477 70
00:D478 F0
00:D479 E0
00:D47A 7F              	    19:   dfb $7F,$63,$7F,$63,$63,$67,$E6,$C0 ; $0E
00:D47B 63
00:D47C 7F
00:D47D 63
00:D47E 63
00:D47F 67
00:D480 E6
00:D481 C0
00:D482 99              	    20:   dfb $99,$5A,$3C,$E7,$E7,$3C,$5A,$99 ; $0F
00:D483 5A
00:D484 3C
00:D485 E7
00:D486 E7
00:D487 3C
00:D488 5A
00:D489 99
00:D48A 80              	    21:   dfb $80,$E0,$F8,$FE,$F8,$E0,$80,$00 ; $10
00:D48B E0
00:D48C F8
00:D48D FE
00:D48E F8
00:D48F E0
00:D490 80
00:D491 00
00:D492 02              	    22:   dfb $02,$0E,$3E,$FE,$3E,$0E,$02,$00 ; $11
00:D493 0E
00:D494 3E
00:D495 FE
00:D496 3E
00:D497 0E
00:D498 02
00:D499 00
00:D49A 18              	    23:   dfb $18,$3C,$7E,$18,$18,$7E,$3C,$18 ; $12
00:D49B 3C
00:D49C 7E
00:D49D 18
00:D49E 18
00:D49F 7E
00:D4A0 3C
00:D4A1 18
00:D4A2 66              	    24:   dfb $66,$66,$66,$66,$66,$00,$66,$00 ; $13
00:D4A3 66
00:D4A4 66
00:D4A5 66
00:D4A6 66
00:D4A7 00
00:D4A8 66
00:D4A9 00
00:D4AA 7F              	    25:   dfb $7F,$DB,$DB,$7B,$1B,$1B,$1B,$00 ; $14
00:D4AB DB
00:D4AC DB
00:D4AD 7B
00:D4AE 1B
00:D4AF 1B
00:D4B0 1B
00:D4B1 00
00:D4B2 3E              	    26:   dfb $3E,$63,$38,$6C,$6C,$38,$CC,$78 ; $15
00:D4B3 63
00:D4B4 38
00:D4B5 6C
00:D4B6 6C
00:D4B7 38
00:D4B8 CC
00:D4B9 78
00:D4BA 00              	    27:   dfb $00,$00,$00,$00,$7E,$7E,$7E,$00 ; $16
00:D4BB 00
00:D4BC 00
00:D4BD 00
00:D4BE 7E
00:D4BF 7E
00:D4C0 7E
00:D4C1 00
00:D4C2 18              	    28:   dfb $18,$3C,$7E,$18,$7E,$3C,$18,$FF ; $17
00:D4C3 3C
00:D4C4 7E
00:D4C5 18
00:D4C6 7E
00:D4C7 3C
00:D4C8 18
00:D4C9 FF
00:D4CA 18              	    29:   dfb $18,$3C,$7E,$18,$18,$18,$18,$00 ; $18
00:D4CB 3C
00:D4CC 7E
00:D4CD 18
00:D4CE 18
00:D4CF 18
00:D4D0 18
00:D4D1 00
00:D4D2 18              	    30:   dfb $18,$18,$18,$18,$7E,$3C,$18,$00 ; $19
00:D4D3 18
00:D4D4 18
00:D4D5 18
00:D4D6 7E
00:D4D7 3C
00:D4D8 18
00:D4D9 00
00:D4DA 00              	    31:   dfb $00,$18,$0C,$FE,$0C,$18,$00,$00 ; $1A
00:D4DB 18
00:D4DC 0C
00:D4DD FE
00:D4DE 0C
00:D4DF 18
00:D4E0 00
00:D4E1 00
00:D4E2 00              	    32:   dfb $00,$30,$60,$FE,$60,$30,$00,$00 ; $1B
00:D4E3 30
00:D4E4 60
00:D4E5 FE
00:D4E6 60
00:D4E7 30
00:D4E8 00
00:D4E9 00
00:D4EA 00              	    33:   dfb $00,$00,$C0,$C0,$C0,$FE,$00,$00 ; $1C
00:D4EB 00
00:D4EC C0
00:D4ED C0
00:D4EE C0
00:D4EF FE
00:D4F0 00
00:D4F1 00
00:D4F2 00              	    34:   dfb $00,$24,$66,$FF,$66,$24,$00,$00 ; $1D
00:D4F3 24
00:D4F4 66
00:D4F5 FF
00:D4F6 66
00:D4F7 24
00:D4F8 00
00:D4F9 00
00:D4FA 00              	    35:   dfb $00,$18,$3C,$7E,$FF,$FF,$00,$00 ; $1E
00:D4FB 18
00:D4FC 3C
00:D4FD 7E
00:D4FE FF
00:D4FF FF
00:D500 00
00:D501 00
00:D502 00              	    36:   dfb $00,$FF,$FF,$7E,$3C,$18,$00,$00 ; $1F
00:D503 FF
00:D504 FF
00:D505 7E
00:D506 3C
00:D507 18
00:D508 00
00:D509 00
00:D50A 00              	    37:   dfb $00,$00,$00,$00,$00,$00,$00,$00 ; ' '
00:D50B 00
00:D50C 00
00:D50D 00
00:D50E 00
00:D50F 00
00:D510 00
00:D511 00
00:D512 30              	    38:   dfb $30,$78,$78,$30,$30,$00,$30,$00 ; '!'
00:D513 78
00:D514 78
00:D515 30
00:D516 30
00:D517 00
00:D518 30
00:D519 00
00:D51A 6C              	    39:   dfb $6C,$6C,$6C,$00,$00,$00,$00,$00 ; '"'
00:D51B 6C
00:D51C 6C
00:D51D 00
00:D51E 00
00:D51F 00
00:D520 00
00:D521 00
00:D522 6C              	    40:   dfb $6C,$6C,$FE,$6C,$FE,$6C,$6C,$00 ; '#'
00:D523 6C
00:D524 FE
00:D525 6C
00:D526 FE
00:D527 6C
00:D528 6C
00:D529 00
00:D52A 30              	    41:   dfb $30,$7C,$C0,$78,$0C,$F8,$30,$00 ; '$'
00:D52B 7C
00:D52C C0
00:D52D 78
00:D52E 0C
00:D52F F8
00:D530 30
00:D531 00
00:D532 00              	    42:   dfb $00,$C6,$CC,$18,$30,$66,$C6,$00 ; '%'
00:D533 C6
00:D534 CC
00:D535 18
00:D536 30
00:D537 66
00:D538 C6
00:D539 00
00:D53A 38              	    43:   dfb $38,$6C,$38,$76,$DC,$CC,$76,$00 ; '&'
00:D53B 6C
00:D53C 38
00:D53D 76
00:D53E DC
00:D53F CC
00:D540 76
00:D541 00
00:D542 60              	    44:   dfb $60,$60,$C0,$00,$00,$00,$00,$00 ; '''
00:D543 60
00:D544 C0
00:D545 00
00:D546 00
00:D547 00
00:D548 00
00:D549 00
00:D54A 18              	    45:   dfb $18,$30,$60,$60,$60,$30,$18,$00 ; '('
00:D54B 30
00:D54C 60
00:D54D 60
00:D54E 60
00:D54F 30
00:D550 18
00:D551 00
00:D552 60              	    46:   dfb $60,$30,$18,$18,$18,$30,$60,$00 ; ')'
00:D553 30
00:D554 18
00:D555 18
00:D556 18
00:D557 30
00:D558 60
00:D559 00
00:D55A 00              	    47:   dfb $00,$66,$3C,$FF,$3C,$66,$00,$00 ; '*'
00:D55B 66
00:D55C 3C
00:D55D FF
00:D55E 3C
00:D55F 66
00:D560 00
00:D561 00
00:D562 00              	    48:   dfb $00,$30,$30,$FC,$30,$30,$00,$00 ; '+'
00:D563 30
00:D564 30
00:D565 FC
00:D566 30
00:D567 30
00:D568 00
00:D569 00
00:D56A 00              	    49:   dfb $00,$00,$00,$00,$00,$30,$30,$60 ; ','
00:D56B 00
00:D56C 00
00:D56D 00
00:D56E 00
00:D56F 30
00:D570 30
00:D571 60
00:D572 00              	    50:   dfb $00,$00,$00,$FC,$00,$00,$00,$00 ; '-'
00:D573 00
00:D574 00
00:D575 FC
00:D576 00
00:D577 00
00:D578 00
00:D579 00
00:D57A 00              	    51:   dfb $00,$00,$00,$00,$00,$30,$30,$00 ; '.'
00:D57B 00
00:D57C 00
00:D57D 00
00:D57E 00
00:D57F 30
00:D580 30
00:D581 00
00:D582 06              	    52:   dfb $06,$0C,$18,$30,$60,$C0,$80,$00 ; '/'
00:D583 0C
00:D584 18
00:D585 30
00:D586 60
00:D587 C0
00:D588 80
00:D589 00
00:D58A 7C              	    53:   dfb $7C,$C6,$CE,$DE,$F6,$E6,$7C,$00 ; '0'
00:D58B C6
00:D58C CE
00:D58D DE
00:D58E F6
00:D58F E6
00:D590 7C
00:D591 00
00:D592 30              	    54:   dfb $30,$70,$30,$30,$30,$30,$FC,$00 ; '1'
00:D593 70
00:D594 30
00:D595 30
00:D596 30
00:D597 30
00:D598 FC
00:D599 00
00:D59A 78              	    55:   dfb $78,$CC,$0C,$38,$60,$CC,$FC,$00 ; '2'
00:D59B CC
00:D59C 0C
00:D59D 38
00:D59E 60
00:D59F CC
00:D5A0 FC
00:D5A1 00
00:D5A2 78              	    56:   dfb $78,$CC,$0C,$38,$0C,$CC,$78,$00 ; '3'
00:D5A3 CC
00:D5A4 0C
00:D5A5 38
00:D5A6 0C
00:D5A7 CC
00:D5A8 78
00:D5A9 00
00:D5AA 1C              	    57:   dfb $1C,$3C,$6C,$CC,$FE,$0C,$1E,$00 ; '4'
00:D5AB 3C
00:D5AC 6C
00:D5AD CC
00:D5AE FE
00:D5AF 0C
00:D5B0 1E
00:D5B1 00
00:D5B2 FC              	    58:   dfb $FC,$C0,$F8,$0C,$0C,$CC,$78,$00 ; '5'
00:D5B3 C0
00:D5B4 F8
00:D5B5 0C
00:D5B6 0C
00:D5B7 CC
00:D5B8 78
00:D5B9 00
00:D5BA 38              	    59:   dfb $38,$60,$C0,$F8,$CC,$CC,$78,$00 ; '6'
00:D5BB 60
00:D5BC C0
00:D5BD F8
00:D5BE CC
00:D5BF CC
00:D5C0 78
00:D5C1 00
00:D5C2 FC              	    60:   dfb $FC,$CC,$0C,$18,$30,$30,$30,$00 ; '7'
00:D5C3 CC
00:D5C4 0C
00:D5C5 18
00:D5C6 30
00:D5C7 30
00:D5C8 30
00:D5C9 00
00:D5CA 78              	    61:   dfb $78,$CC,$CC,$78,$CC,$CC,$78,$00 ; '8'
00:D5CB CC
00:D5CC CC
00:D5CD 78
00:D5CE CC
00:D5CF CC
00:D5D0 78
00:D5D1 00
00:D5D2 78              	    62:   dfb $78,$CC,$CC,$7C,$0C,$18,$70,$00 ; '9'
00:D5D3 CC
00:D5D4 CC
00:D5D5 7C
00:D5D6 0C
00:D5D7 18
00:D5D8 70
00:D5D9 00
00:D5DA 00              	    63:   dfb $00,$30,$30,$00,$00,$30,$30,$00 ; ':'
00:D5DB 30
00:D5DC 30
00:D5DD 00
00:D5DE 00
00:D5DF 30
00:D5E0 30
00:D5E1 00
00:D5E2 00              	    64:   dfb $00,$30,$30,$00,$00,$30,$30,$60 ; ';'
00:D5E3 30
00:D5E4 30
00:D5E5 00
00:D5E6 00
00:D5E7 30
00:D5E8 30
00:D5E9 60
00:D5EA 18              	    65:   dfb $18,$30,$60,$C0,$60,$30,$18,$00 ; '<'
00:D5EB 30
00:D5EC 60
00:D5ED C0
00:D5EE 60
00:D5EF 30
00:D5F0 18
00:D5F1 00
00:D5F2 00              	    66:   dfb $00,$00,$FC,$00,$00,$FC,$00,$00 ; '='
00:D5F3 00
00:D5F4 FC
00:D5F5 00
00:D5F6 00
00:D5F7 FC
00:D5F8 00
00:D5F9 00
00:D5FA 60              	    67:   dfb $60,$30,$18,$0C,$18,$30,$60,$00 ; '>'
00:D5FB 30
00:D5FC 18
00:D5FD 0C
00:D5FE 18
00:D5FF 30
00:D600 60
00:D601 00
00:D602 78              	    68:   dfb $78,$CC,$0C,$18,$30,$00,$30,$00 ; '?'
00:D603 CC
00:D604 0C
00:D605 18
00:D606 30
00:D607 00
00:D608 30
00:D609 00
00:D60A 7C              	    69:   dfb $7C,$C6,$DE,$DE,$DE,$C0,$78,$00 ; '@'
00:D60B C6
00:D60C DE
00:D60D DE
00:D60E DE
00:D60F C0
00:D610 78
00:D611 00
00:D612 30              	    70:   dfb $30,$78,$CC,$CC,$FC,$CC,$CC,$00 ; 'A'
00:D613 78
00:D614 CC
00:D615 CC
00:D616 FC
00:D617 CC
00:D618 CC
00:D619 00
00:D61A FC              	    71:   dfb $FC,$66,$66,$7C,$66,$66,$FC,$00 ; 'B'
00:D61B 66
00:D61C 66
00:D61D 7C
00:D61E 66
00:D61F 66
00:D620 FC
00:D621 00
00:D622 3C              	    72:   dfb $3C,$66,$C0,$C0,$C0,$66,$3C,$00 ; 'C'
00:D623 66
00:D624 C0
00:D625 C0
00:D626 C0
00:D627 66
00:D628 3C
00:D629 00
00:D62A F8              	    73:   dfb $F8,$6C,$66,$66,$66,$6C,$F8,$00 ; 'D'
00:D62B 6C
00:D62C 66
00:D62D 66
00:D62E 66
00:D62F 6C
00:D630 F8
00:D631 00
00:D632 FE              	    74:   dfb $FE,$62,$68,$78,$68,$62,$FE,$00 ; 'E'
00:D633 62
00:D634 68
00:D635 78
00:D636 68
00:D637 62
00:D638 FE
00:D639 00
00:D63A FE              	    75:   dfb $FE,$62,$68,$78,$68,$60,$F0,$00 ; 'F'
00:D63B 62
00:D63C 68
00:D63D 78
00:D63E 68
00:D63F 60
00:D640 F0
00:D641 00
00:D642 3C              	    76:   dfb $3C,$66,$C0,$C0,$CE,$66,$3E,$00 ; 'G'
00:D643 66
00:D644 C0
00:D645 C0
00:D646 CE
00:D647 66
00:D648 3E
00:D649 00
00:D64A CC              	    77:   dfb $CC,$CC,$CC,$FC,$CC,$CC,$CC,$00 ; 'H'
00:D64B CC
00:D64C CC
00:D64D FC
00:D64E CC
00:D64F CC
00:D650 CC
00:D651 00
00:D652 78              	    78:   dfb $78,$30,$30,$30,$30,$30,$78,$00 ; 'I'
00:D653 30
00:D654 30
00:D655 30
00:D656 30
00:D657 30
00:D658 78
00:D659 00
00:D65A 1E              	    79:   dfb $1E,$0C,$0C,$0C,$CC,$CC,$78,$00 ; 'J'
00:D65B 0C
00:D65C 0C
00:D65D 0C
00:D65E CC
00:D65F CC
00:D660 78
00:D661 00
00:D662 E6              	    80:   dfb $E6,$66,$6C,$78,$6C,$66,$E6,$00 ; 'K'
00:D663 66
00:D664 6C
00:D665 78
00:D666 6C
00:D667 66
00:D668 E6
00:D669 00
00:D66A F0              	    81:   dfb $F0,$60,$60,$60,$62,$66,$FE,$00 ; 'L'
00:D66B 60
00:D66C 60
00:D66D 60
00:D66E 62
00:D66F 66
00:D670 FE
00:D671 00
00:D672 C6              	    82:   dfb $C6,$EE,$FE,$FE,$D6,$C6,$C6,$00 ; 'M'
00:D673 EE
00:D674 FE
00:D675 FE
00:D676 D6
00:D677 C6
00:D678 C6
00:D679 00
00:D67A C6              	    83:   dfb $C6,$E6,$F6,$DE,$CE,$C6,$C6,$00 ; 'N'
00:D67B E6
00:D67C F6
00:D67D DE
00:D67E CE
00:D67F C6
00:D680 C6
00:D681 00
00:D682 38              	    84:   dfb $38,$6C,$C6,$C6,$C6,$6C,$38,$00 ; 'O'
00:D683 6C
00:D684 C6
00:D685 C6
00:D686 C6
00:D687 6C
00:D688 38
00:D689 00
00:D68A FC              	    85:   dfb $FC,$66,$66,$7C,$60,$60,$F0,$00 ; 'P'
00:D68B 66
00:D68C 66
00:D68D 7C
00:D68E 60
00:D68F 60
00:D690 F0
00:D691 00
00:D692 78              	    86:   dfb $78,$CC,$CC,$CC,$DC,$78,$1C,$00 ; 'Q'
00:D693 CC
00:D694 CC
00:D695 CC
00:D696 DC
00:D697 78
00:D698 1C
00:D699 00
00:D69A FC              	    87:   dfb $FC,$66,$66,$7C,$6C,$66,$E6,$00 ; 'R'
00:D69B 66
00:D69C 66
00:D69D 7C
00:D69E 6C
00:D69F 66
00:D6A0 E6
00:D6A1 00
00:D6A2 78              	    88:   dfb $78,$CC,$E0,$70,$1C,$CC,$78,$00 ; 'S'
00:D6A3 CC
00:D6A4 E0
00:D6A5 70
00:D6A6 1C
00:D6A7 CC
00:D6A8 78
00:D6A9 00
00:D6AA FC              	    89:   dfb $FC,$B4,$30,$30,$30,$30,$78,$00 ; 'T'
00:D6AB B4
00:D6AC 30
00:D6AD 30
00:D6AE 30
00:D6AF 30
00:D6B0 78
00:D6B1 00
00:D6B2 CC              	    90:   dfb $CC,$CC,$CC,$CC,$CC,$CC,$FC,$00 ; 'U'
00:D6B3 CC
00:D6B4 CC
00:D6B5 CC
00:D6B6 CC
00:D6B7 CC
00:D6B8 FC
00:D6B9 00
00:D6BA CC              	    91:   dfb $CC,$CC,$CC,$CC,$CC,$78,$30,$00 ; 'V'
00:D6BB CC
00:D6BC CC
00:D6BD CC
00:D6BE CC
00:D6BF 78
00:D6C0 30
00:D6C1 00
00:D6C2 C6              	    92:   dfb $C6,$C6,$C6,$D6,$FE,$EE,$C6,$00 ; 'W'
00:D6C3 C6
00:D6C4 C6
00:D6C5 D6
00:D6C6 FE
00:D6C7 EE
00:D6C8 C6
00:D6C9 00
00:D6CA C6              	    93:   dfb $C6,$C6,$6C,$38,$38,$6C,$C6,$00 ; 'X'
00:D6CB C6
00:D6CC 6C
00:D6CD 38
00:D6CE 38
00:D6CF 6C
00:D6D0 C6
00:D6D1 00
00:D6D2 CC              	    94:   dfb $CC,$CC,$CC,$78,$30,$30,$78,$00 ; 'Y'
00:D6D3 CC
00:D6D4 CC
00:D6D5 78
00:D6D6 30
00:D6D7 30
00:D6D8 78
00:D6D9 00
00:D6DA FE              	    95:   dfb $FE,$C6,$8C,$18,$32,$66,$FE,$00 ; 'Z'
00:D6DB C6
00:D6DC 8C
00:D6DD 18
00:D6DE 32
00:D6DF 66
00:D6E0 FE
00:D6E1 00
00:D6E2 78              	    96:   dfb $78,$60,$60,$60,$60,$60,$78,$00 ; '['
00:D6E3 60
00:D6E4 60
00:D6E5 60
00:D6E6 60
00:D6E7 60
00:D6E8 78
00:D6E9 00
00:D6EA C0              	    97:   dfb $C0,$60,$30,$18,$0C,$06,$02,$00 ; back
00:D6EB 60
00:D6EC 30
00:D6ED 18
00:D6EE 0C
00:D6EF 06
00:D6F0 02
00:D6F1 00
00:D6F2 78              	    98:   dfb $78,$18,$18,$18,$18,$18,$78,$00 ; ']'
00:D6F3 18
00:D6F4 18
00:D6F5 18
00:D6F6 18
00:D6F7 18
00:D6F8 78
00:D6F9 00
00:D6FA 10              	    99:   dfb $10,$38,$6C,$C6,$00,$00,$00,$00 ; '^'
00:D6FB 38
00:D6FC 6C
00:D6FD C6
00:D6FE 00
00:D6FF 00
00:D700 00
00:D701 00
00:D702 00              	   100:   dfb $00,$00,$00,$00,$00,$00,$00,$FF ; '_'
00:D703 00
00:D704 00
00:D705 00
00:D706 00
00:D707 00
00:D708 00
00:D709 FF
00:D70A 30              	   101:   dfb $30,$30,$18,$00,$00,$00,$00,$00 ; '`'
00:D70B 30
00:D70C 18
00:D70D 00
00:D70E 00
00:D70F 00
00:D710 00
00:D711 00
00:D712 00              	   102:   dfb $00,$00,$78,$0C,$7C,$CC,$76,$00 ; 'a'
00:D713 00
00:D714 78
00:D715 0C
00:D716 7C
00:D717 CC
00:D718 76
00:D719 00
00:D71A E0              	   103:   dfb $E0,$60,$60,$7C,$66,$66,$DC,$00 ; 'b'
00:D71B 60
00:D71C 60
00:D71D 7C
00:D71E 66
00:D71F 66
00:D720 DC
00:D721 00
00:D722 00              	   104:   dfb $00,$00,$78,$CC,$C0,$CC,$78,$00 ; 'c'
00:D723 00
00:D724 78
00:D725 CC
00:D726 C0
00:D727 CC
00:D728 78
00:D729 00
00:D72A 1C              	   105:   dfb $1C,$0C,$0C,$7C,$CC,$CC,$76,$00 ; 'd'
00:D72B 0C
00:D72C 0C
00:D72D 7C
00:D72E CC
00:D72F CC
00:D730 76
00:D731 00
00:D732 00              	   106:   dfb $00,$00,$78,$CC,$FC,$C0,$78,$00 ; 'e'
00:D733 00
00:D734 78
00:D735 CC
00:D736 FC
00:D737 C0
00:D738 78
00:D739 00
00:D73A 38              	   107:   dfb $38,$6C,$60,$F0,$60,$60,$F0,$00 ; 'f'
00:D73B 6C
00:D73C 60
00:D73D F0
00:D73E 60
00:D73F 60
00:D740 F0
00:D741 00
00:D742 00              	   108:   dfb $00,$00,$76,$CC,$CC,$7C,$0C,$F8 ; 'g'
00:D743 00
00:D744 76
00:D745 CC
00:D746 CC
00:D747 7C
00:D748 0C
00:D749 F8
00:D74A E0              	   109:   dfb $E0,$60,$6C,$76,$66,$66,$E6,$00 ; 'h'
00:D74B 60
00:D74C 6C
00:D74D 76
00:D74E 66
00:D74F 66
00:D750 E6
00:D751 00
00:D752 30              	   110:   dfb $30,$00,$70,$30,$30,$30,$78,$00 ; 'i'
00:D753 00
00:D754 70
00:D755 30
00:D756 30
00:D757 30
00:D758 78
00:D759 00
00:D75A 0C              	   111:   dfb $0C,$00,$0C,$0C,$0C,$CC,$CC,$78 ; 'j'
00:D75B 00
00:D75C 0C
00:D75D 0C
00:D75E 0C
00:D75F CC
00:D760 CC
00:D761 78
00:D762 E0              	   112:   dfb $E0,$60,$66,$6C,$78,$6C,$E6,$00 ; 'k'
00:D763 60
00:D764 66
00:D765 6C
00:D766 78
00:D767 6C
00:D768 E6
00:D769 00
00:D76A 70              	   113:   dfb $70,$30,$30,$30,$30,$30,$78,$00 ; 'l'
00:D76B 30
00:D76C 30
00:D76D 30
00:D76E 30
00:D76F 30
00:D770 78
00:D771 00
00:D772 00              	   114:   dfb $00,$00,$CC,$FE,$FE,$D6,$C6,$00 ; 'm'
00:D773 00
00:D774 CC
00:D775 FE
00:D776 FE
00:D777 D6
00:D778 C6
00:D779 00
00:D77A 00              	   115:   dfb $00,$00,$F8,$CC,$CC,$CC,$CC,$00 ; 'n'
00:D77B 00
00:D77C F8
00:D77D CC
00:D77E CC
00:D77F CC
00:D780 CC
00:D781 00
00:D782 00              	   116:   dfb $00,$00,$78,$CC,$CC,$CC,$78,$00 ; 'o'
00:D783 00
00:D784 78
00:D785 CC
00:D786 CC
00:D787 CC
00:D788 78
00:D789 00
00:D78A 00              	   117:   dfb $00,$00,$DC,$66,$66,$7C,$60,$F0 ; 'p'
00:D78B 00
00:D78C DC
00:D78D 66
00:D78E 66
00:D78F 7C
00:D790 60
00:D791 F0
00:D792 00              	   118:   dfb $00,$00,$76,$CC,$CC,$7C,$0C,$1E ; 'q'
00:D793 00
00:D794 76
00:D795 CC
00:D796 CC
00:D797 7C
00:D798 0C
00:D799 1E
00:D79A 00              	   119:   dfb $00,$00,$DC,$76,$66,$60,$F0,$00 ; 'r'
00:D79B 00
00:D79C DC
00:D79D 76
00:D79E 66
00:D79F 60
00:D7A0 F0
00:D7A1 00
00:D7A2 00              	   120:   dfb $00,$00,$7C,$C0,$78,$0C,$F8,$00 ; 's'
00:D7A3 00
00:D7A4 7C
00:D7A5 C0
00:D7A6 78
00:D7A7 0C
00:D7A8 F8
00:D7A9 00
00:D7AA 10              	   121:   dfb $10,$30,$7C,$30,$30,$34,$18,$00 ; 't'
00:D7AB 30
00:D7AC 7C
00:D7AD 30
00:D7AE 30
00:D7AF 34
00:D7B0 18
00:D7B1 00
00:D7B2 00              	   122:   dfb $00,$00,$CC,$CC,$CC,$CC,$76,$00 ; 'u'
00:D7B3 00
00:D7B4 CC
00:D7B5 CC
00:D7B6 CC
00:D7B7 CC
00:D7B8 76
00:D7B9 00
00:D7BA 00              	   123:   dfb $00,$00,$CC,$CC,$CC,$78,$30,$00 ; 'v'
00:D7BB 00
00:D7BC CC
00:D7BD CC
00:D7BE CC
00:D7BF 78
00:D7C0 30
00:D7C1 00
00:D7C2 00              	   124:   dfb $00,$00,$C6,$D6,$FE,$FE,$6C,$00 ; 'w'
00:D7C3 00
00:D7C4 C6
00:D7C5 D6
00:D7C6 FE
00:D7C7 FE
00:D7C8 6C
00:D7C9 00
00:D7CA 00              	   125:   dfb $00,$00,$C6,$6C,$38,$6C,$C6,$00 ; 'x'
00:D7CB 00
00:D7CC C6
00:D7CD 6C
00:D7CE 38
00:D7CF 6C
00:D7D0 C6
00:D7D1 00
00:D7D2 00              	   126:   dfb $00,$00,$CC,$CC,$CC,$7C,$0C,$F8 ; 'y'
00:D7D3 00
00:D7D4 CC
00:D7D5 CC
00:D7D6 CC
00:D7D7 7C
00:D7D8 0C
00:D7D9 F8
00:D7DA 00              	   127:   dfb $00,$00,$FC,$98,$30,$64,$FC,$00 ; 'z'
00:D7DB 00
00:D7DC FC
00:D7DD 98
00:D7DE 30
00:D7DF 64
00:D7E0 FC
00:D7E1 00
00:D7E2 1C              	   128:   dfb $1C,$30,$30,$E0,$30,$30,$1C,$00 ; '{'
00:D7E3 30
00:D7E4 30
00:D7E5 E0
00:D7E6 30
00:D7E7 30
00:D7E8 1C
00:D7E9 00
00:D7EA 18              	   129:   dfb $18,$18,$18,$00,$18,$18,$18,$00 ; '|'
00:D7EB 18
00:D7EC 18
00:D7ED 00
00:D7EE 18
00:D7EF 18
00:D7F0 18
00:D7F1 00
00:D7F2 E0              	   130:   dfb $E0,$30,$30,$1C,$30,$30,$E0,$00 ; '}'
00:D7F3 30
00:D7F4 30
00:D7F5 1C
00:D7F6 30
00:D7F7 30
00:D7F8 E0
00:D7F9 00
00:D7FA 76              	   131:   dfb $76,$DC,$00,$00,$00,$00,$00,$00 ; '~'
00:D7FB DC
00:D7FC 00
00:D7FD 00
00:D7FE 00
00:D7FF 00
00:D800 00
00:D801 00
00:D802 00              	   132:   dfb $00,$10,$38,$6C,$C6,$C6,$FE,$00 ; $7F
00:D803 10
00:D804 38
00:D805 6C
00:D806 C6
00:D807 C6
00:D808 FE
00:D809 00
00:D80A 78              	   133:   dfb $78,$CC,$C0,$CC,$78,$18,$0C,$78 ; $80
00:D80B CC
00:D80C C0
00:D80D CC
00:D80E 78
00:D80F 18
00:D810 0C
00:D811 78
00:D812 00              	   134:   dfb $00,$CC,$00,$CC,$CC,$CC,$7E,$00 ; $81
00:D813 CC
00:D814 00
00:D815 CC
00:D816 CC
00:D817 CC
00:D818 7E
00:D819 00
00:D81A 1C              	   135:   dfb $1C,$00,$78,$CC,$FC,$C0,$78,$00 ; $82
00:D81B 00
00:D81C 78
00:D81D CC
00:D81E FC
00:D81F C0
00:D820 78
00:D821 00
00:D822 7E              	   136:   dfb $7E,$C3,$3C,$06,$3E,$66,$3F,$00 ; $83
00:D823 C3
00:D824 3C
00:D825 06
00:D826 3E
00:D827 66
00:D828 3F
00:D829 00
00:D82A CC              	   137:   dfb $CC,$00,$78,$0C,$7C,$CC,$7E,$00 ; $84
00:D82B 00
00:D82C 78
00:D82D 0C
00:D82E 7C
00:D82F CC
00:D830 7E
00:D831 00
00:D832 E0              	   138:   dfb $E0,$00,$78,$0C,$7C,$CC,$7E,$00 ; $85
00:D833 00
00:D834 78
00:D835 0C
00:D836 7C
00:D837 CC
00:D838 7E
00:D839 00
00:D83A 30              	   139:   dfb $30,$30,$78,$0C,$7C,$CC,$7E,$00 ; $86
00:D83B 30
00:D83C 78
00:D83D 0C
00:D83E 7C
00:D83F CC
00:D840 7E
00:D841 00
00:D842 00              	   140:   dfb $00,$00,$78,$C0,$C0,$78,$0C,$38 ; $87
00:D843 00
00:D844 78
00:D845 C0
00:D846 C0
00:D847 78
00:D848 0C
00:D849 38
00:D84A 7E              	   141:   dfb $7E,$C3,$3C,$66,$7E,$60,$3C,$00 ; $88
00:D84B C3
00:D84C 3C
00:D84D 66
00:D84E 7E
00:D84F 60
00:D850 3C
00:D851 00
00:D852 CC              	   142:   dfb $CC,$00,$78,$CC,$FC,$C0,$78,$00 ; $89
00:D853 00
00:D854 78
00:D855 CC
00:D856 FC
00:D857 C0
00:D858 78
00:D859 00
00:D85A E0              	   143:   dfb $E0,$00,$78,$CC,$FC,$C0,$78,$00 ; $8A
00:D85B 00
00:D85C 78
00:D85D CC
00:D85E FC
00:D85F C0
00:D860 78
00:D861 00
00:D862 CC              	   144:   dfb $CC,$00,$70,$30,$30,$30,$78,$00 ; $8B
00:D863 00
00:D864 70
00:D865 30
00:D866 30
00:D867 30
00:D868 78
00:D869 00
00:D86A 7C              	   145:   dfb $7C,$C6,$38,$18,$18,$18,$3C,$00 ; $8C
00:D86B C6
00:D86C 38
00:D86D 18
00:D86E 18
00:D86F 18
00:D870 3C
00:D871 00
00:D872 E0              	   146:   dfb $E0,$00,$70,$30,$30,$30,$78,$00 ; $8D
00:D873 00
00:D874 70
00:D875 30
00:D876 30
00:D877 30
00:D878 78
00:D879 00
00:D87A C6              	   147:   dfb $C6,$38,$6C,$C6,$FE,$C6,$C6,$00 ; $8E
00:D87B 38
00:D87C 6C
00:D87D C6
00:D87E FE
00:D87F C6
00:D880 C6
00:D881 00
00:D882 30              	   148:   dfb $30,$30,$00,$78,$CC,$FC,$CC,$00 ; $8F
00:D883 30
00:D884 00
00:D885 78
00:D886 CC
00:D887 FC
00:D888 CC
00:D889 00
00:D88A 1C              	   149:   dfb $1C,$00,$FC,$60,$78,$60,$FC,$00 ; $90
00:D88B 00
00:D88C FC
00:D88D 60
00:D88E 78
00:D88F 60
00:D890 FC
00:D891 00
00:D892 00              	   150:   dfb $00,$00,$7F,$0C,$7F,$CC,$7F,$00 ; $91
00:D893 00
00:D894 7F
00:D895 0C
00:D896 7F
00:D897 CC
00:D898 7F
00:D899 00
00:D89A 3E              	   151:   dfb $3E,$6C,$CC,$FE,$CC,$CC,$CE,$00 ; $92
00:D89B 6C
00:D89C CC
00:D89D FE
00:D89E CC
00:D89F CC
00:D8A0 CE
00:D8A1 00
00:D8A2 78              	   152:   dfb $78,$CC,$00,$78,$CC,$CC,$78,$00 ; $93
00:D8A3 CC
00:D8A4 00
00:D8A5 78
00:D8A6 CC
00:D8A7 CC
00:D8A8 78
00:D8A9 00
00:D8AA 00              	   153:   dfb $00,$CC,$00,$78,$CC,$CC,$78,$00 ; $94
00:D8AB CC
00:D8AC 00
00:D8AD 78
00:D8AE CC
00:D8AF CC
00:D8B0 78
00:D8B1 00
00:D8B2 00              	   154:   dfb $00,$E0,$00,$78,$CC,$CC,$78,$00 ; $95
00:D8B3 E0
00:D8B4 00
00:D8B5 78
00:D8B6 CC
00:D8B7 CC
00:D8B8 78
00:D8B9 00
00:D8BA 78              	   155:   dfb $78,$CC,$00,$CC,$CC,$CC,$7E,$00 ; $96
00:D8BB CC
00:D8BC 00
00:D8BD CC
00:D8BE CC
00:D8BF CC
00:D8C0 7E
00:D8C1 00
00:D8C2 00              	   156:   dfb $00,$E0,$00,$CC,$CC,$CC,$7E,$00 ; $97
00:D8C3 E0
00:D8C4 00
00:D8C5 CC
00:D8C6 CC
00:D8C7 CC
00:D8C8 7E
00:D8C9 00
00:D8CA 00              	   157:   dfb $00,$CC,$00,$CC,$CC,$7C,$0C,$F8 ; $98
00:D8CB CC
00:D8CC 00
00:D8CD CC
00:D8CE CC
00:D8CF 7C
00:D8D0 0C
00:D8D1 F8
00:D8D2 C3              	   158:   dfb $C3,$18,$3C,$66,$66,$3C,$18,$00 ; $99
00:D8D3 18
00:D8D4 3C
00:D8D5 66
00:D8D6 66
00:D8D7 3C
00:D8D8 18
00:D8D9 00
00:D8DA CC              	   159:   dfb $CC,$00,$CC,$CC,$CC,$CC,$78,$00 ; $9A
00:D8DB 00
00:D8DC CC
00:D8DD CC
00:D8DE CC
00:D8DF CC
00:D8E0 78
00:D8E1 00
00:D8E2 18              	   160:   dfb $18,$18,$7E,$C0,$C0,$7E,$18,$18 ; $9B
00:D8E3 18
00:D8E4 7E
00:D8E5 C0
00:D8E6 C0
00:D8E7 7E
00:D8E8 18
00:D8E9 18
00:D8EA 38              	   161:   dfb $38,$6C,$64,$F0,$60,$E6,$FC,$00 ; $9C
00:D8EB 6C
00:D8EC 64
00:D8ED F0
00:D8EE 60
00:D8EF E6
00:D8F0 FC
00:D8F1 00
00:D8F2 CC              	   162:   dfb $CC,$CC,$78,$FC,$30,$FC,$30,$30 ; $9D
00:D8F3 CC
00:D8F4 78
00:D8F5 FC
00:D8F6 30
00:D8F7 FC
00:D8F8 30
00:D8F9 30
00:D8FA F8              	   163:   dfb $F8,$CC,$CC,$FA,$C6,$CF,$C6,$C7 ; $9E
00:D8FB CC
00:D8FC CC
00:D8FD FA
00:D8FE C6
00:D8FF CF
00:D900 C6
00:D901 C7
00:D902 0E              	   164:   dfb $0E,$1B,$18,$3C,$18,$18,$D8,$70 ; $9F
00:D903 1B
00:D904 18
00:D905 3C
00:D906 18
00:D907 18
00:D908 D8
00:D909 70
00:D90A 1C              	   165:   dfb $1C,$00,$78,$0C,$7C,$CC,$7E,$00 ; $A0
00:D90B 00
00:D90C 78
00:D90D 0C
00:D90E 7C
00:D90F CC
00:D910 7E
00:D911 00
00:D912 38              	   166:   dfb $38,$00,$70,$30,$30,$30,$78,$00 ; $A1
00:D913 00
00:D914 70
00:D915 30
00:D916 30
00:D917 30
00:D918 78
00:D919 00
00:D91A 00              	   167:   dfb $00,$1C,$00,$78,$CC,$CC,$78,$00 ; $A2
00:D91B 1C
00:D91C 00
00:D91D 78
00:D91E CC
00:D91F CC
00:D920 78
00:D921 00
00:D922 00              	   168:   dfb $00,$1C,$00,$CC,$CC,$CC,$7E,$00 ; $A3
00:D923 1C
00:D924 00
00:D925 CC
00:D926 CC
00:D927 CC
00:D928 7E
00:D929 00
00:D92A 00              	   169:   dfb $00,$F8,$00,$F8,$CC,$CC,$CC,$00 ; $A4
00:D92B F8
00:D92C 00
00:D92D F8
00:D92E CC
00:D92F CC
00:D930 CC
00:D931 00
00:D932 FC              	   170:   dfb $FC,$00,$CC,$EC,$FC,$DC,$CC,$00 ; $A5
00:D933 00
00:D934 CC
00:D935 EC
00:D936 FC
00:D937 DC
00:D938 CC
00:D939 00
00:D93A 3C              	   171:   dfb $3C,$6C,$6C,$3E,$00,$7E,$00,$00 ; $A6
00:D93B 6C
00:D93C 6C
00:D93D 3E
00:D93E 00
00:D93F 7E
00:D940 00
00:D941 00
00:D942 38              	   172:   dfb $38,$6C,$6C,$38,$00,$7C,$00,$00 ; $A7
00:D943 6C
00:D944 6C
00:D945 38
00:D946 00
00:D947 7C
00:D948 00
00:D949 00
00:D94A 30              	   173:   dfb $30,$00,$30,$60,$C0,$CC,$78,$00 ; $A8
00:D94B 00
00:D94C 30
00:D94D 60
00:D94E C0
00:D94F CC
00:D950 78
00:D951 00
00:D952 00              	   174:   dfb $00,$00,$00,$FC,$C0,$C0,$00,$00 ; $A9
00:D953 00
00:D954 00
00:D955 FC
00:D956 C0
00:D957 C0
00:D958 00
00:D959 00
00:D95A 00              	   175:   dfb $00,$00,$00,$FC,$0C,$0C,$00,$00 ; $AA
00:D95B 00
00:D95C 00
00:D95D FC
00:D95E 0C
00:D95F 0C
00:D960 00
00:D961 00
00:D962 C3              	   176:   dfb $C3,$C6,$CC,$DE,$33,$66,$CC,$0F ; $AB
00:D963 C6
00:D964 CC
00:D965 DE
00:D966 33
00:D967 66
00:D968 CC
00:D969 0F
00:D96A C3              	   177:   dfb $C3,$C6,$CC,$DB,$37,$6F,$CF,$03 ; $AC
00:D96B C6
00:D96C CC
00:D96D DB
00:D96E 37
00:D96F 6F
00:D970 CF
00:D971 03
00:D972 18              	   178:   dfb $18,$18,$00,$18,$18,$18,$18,$00 ; $AD
00:D973 18
00:D974 00
00:D975 18
00:D976 18
00:D977 18
00:D978 18
00:D979 00
00:D97A 00              	   179:   dfb $00,$33,$66,$CC,$66,$33,$00,$00 ; $AE
00:D97B 33
00:D97C 66
00:D97D CC
00:D97E 66
00:D97F 33
00:D980 00
00:D981 00
00:D982 00              	   180:   dfb $00,$CC,$66,$33,$66,$CC,$00,$00 ; $AF
00:D983 CC
00:D984 66
00:D985 33
00:D986 66
00:D987 CC
00:D988 00
00:D989 00
00:D98A 22              	   181:   dfb $22,$88,$22,$88,$22,$88,$22,$88 ; $B0
00:D98B 88
00:D98C 22
00:D98D 88
00:D98E 22
00:D98F 88
00:D990 22
00:D991 88
00:D992 55              	   182:   dfb $55,$AA,$55,$AA,$55,$AA,$55,$AA ; $B1
00:D993 AA
00:D994 55
00:D995 AA
00:D996 55
00:D997 AA
00:D998 55
00:D999 AA
00:D99A DB              	   183:   dfb $DB,$77,$DB,$EE,$DB,$77,$DB,$EE ; $B2
00:D99B 77
00:D99C DB
00:D99D EE
00:D99E DB
00:D99F 77
00:D9A0 DB
00:D9A1 EE
00:D9A2 18              	   184:   dfb $18,$18,$18,$18,$18,$18,$18,$18 ; $B3
00:D9A3 18
00:D9A4 18
00:D9A5 18
00:D9A6 18
00:D9A7 18
00:D9A8 18
00:D9A9 18
00:D9AA 18              	   185:   dfb $18,$18,$18,$18,$F8,$18,$18,$18 ; $B4
00:D9AB 18
00:D9AC 18
00:D9AD 18
00:D9AE F8
00:D9AF 18
00:D9B0 18
00:D9B1 18
00:D9B2 18              	   186:   dfb $18,$18,$F8,$18,$F8,$18,$18,$18 ; $B5
00:D9B3 18
00:D9B4 F8
00:D9B5 18
00:D9B6 F8
00:D9B7 18
00:D9B8 18
00:D9B9 18
00:D9BA 36              	   187:   dfb $36,$36,$36,$36,$F6,$36,$36,$36 ; $B6
00:D9BB 36
00:D9BC 36
00:D9BD 36
00:D9BE F6
00:D9BF 36
00:D9C0 36
00:D9C1 36
00:D9C2 00              	   188:   dfb $00,$00,$00,$00,$FE,$36,$36,$36 ; $B7
00:D9C3 00
00:D9C4 00
00:D9C5 00
00:D9C6 FE
00:D9C7 36
00:D9C8 36
00:D9C9 36
00:D9CA 00              	   189:   dfb $00,$00,$F8,$18,$F8,$18,$18,$18 ; $B8
00:D9CB 00
00:D9CC F8
00:D9CD 18
00:D9CE F8
00:D9CF 18
00:D9D0 18
00:D9D1 18
00:D9D2 36              	   190:   dfb $36,$36,$F6,$06,$F6,$36,$36,$36 ; $B9
00:D9D3 36
00:D9D4 F6
00:D9D5 06
00:D9D6 F6
00:D9D7 36
00:D9D8 36
00:D9D9 36
00:D9DA 36              	   191:   dfb $36,$36,$36,$36,$36,$36,$36,$36 ; $BA
00:D9DB 36
00:D9DC 36
00:D9DD 36
00:D9DE 36
00:D9DF 36
00:D9E0 36
00:D9E1 36
00:D9E2 00              	   192:   dfb $00,$00,$FE,$06,$F6,$36,$36,$36 ; $BB
00:D9E3 00
00:D9E4 FE
00:D9E5 06
00:D9E6 F6
00:D9E7 36
00:D9E8 36
00:D9E9 36
00:D9EA 36              	   193:   dfb $36,$36,$F6,$06,$FE,$00,$00,$00 ; $BC
00:D9EB 36
00:D9EC F6
00:D9ED 06
00:D9EE FE
00:D9EF 00
00:D9F0 00
00:D9F1 00
00:D9F2 36              	   194:   dfb $36,$36,$36,$36,$FE,$00,$00,$00 ; $BD
00:D9F3 36
00:D9F4 36
00:D9F5 36
00:D9F6 FE
00:D9F7 00
00:D9F8 00
00:D9F9 00
00:D9FA 18              	   195:   dfb $18,$18,$F8,$18,$F8,$00,$00,$00 ; $BE
00:D9FB 18
00:D9FC F8
00:D9FD 18
00:D9FE F8
00:D9FF 00
00:DA00 00
00:DA01 00
00:DA02 00              	   196:   dfb $00,$00,$00,$00,$F8,$18,$18,$18 ; $BF
00:DA03 00
00:DA04 00
00:DA05 00
00:DA06 F8
00:DA07 18
00:DA08 18
00:DA09 18
00:DA0A 18              	   197:   dfb $18,$18,$18,$18,$1F,$00,$00,$00 ; $C0
00:DA0B 18
00:DA0C 18
00:DA0D 18
00:DA0E 1F
00:DA0F 00
00:DA10 00
00:DA11 00
00:DA12 18              	   198:   dfb $18,$18,$18,$18,$FF,$00,$00,$00 ; $C1
00:DA13 18
00:DA14 18
00:DA15 18
00:DA16 FF
00:DA17 00
00:DA18 00
00:DA19 00
00:DA1A 00              	   199:   dfb $00,$00,$00,$00,$FF,$18,$18,$18 ; $C2
00:DA1B 00
00:DA1C 00
00:DA1D 00
00:DA1E FF
00:DA1F 18
00:DA20 18
00:DA21 18
00:DA22 18              	   200:   dfb $18,$18,$18,$18,$1F,$18,$18,$18 ; $C3
00:DA23 18
00:DA24 18
00:DA25 18
00:DA26 1F
00:DA27 18
00:DA28 18
00:DA29 18
00:DA2A 00              	   201:   dfb $00,$00,$00,$00,$FF,$00,$00,$00 ; $C4
00:DA2B 00
00:DA2C 00
00:DA2D 00
00:DA2E FF
00:DA2F 00
00:DA30 00
00:DA31 00
00:DA32 18              	   202:   dfb $18,$18,$18,$18,$FF,$18,$18,$18 ; $C5
00:DA33 18
00:DA34 18
00:DA35 18
00:DA36 FF
00:DA37 18
00:DA38 18
00:DA39 18
00:DA3A 18              	   203:   dfb $18,$18,$1F,$18,$1F,$18,$18,$18 ; $C6
00:DA3B 18
00:DA3C 1F
00:DA3D 18
00:DA3E 1F
00:DA3F 18
00:DA40 18
00:DA41 18
00:DA42 36              	   204:   dfb $36,$36,$36,$36,$37,$36,$36,$36 ; $C7
00:DA43 36
00:DA44 36
00:DA45 36
00:DA46 37
00:DA47 36
00:DA48 36
00:DA49 36
00:DA4A 36              	   205:   dfb $36,$36,$37,$30,$3F,$00,$00,$00 ; $C8
00:DA4B 36
00:DA4C 37
00:DA4D 30
00:DA4E 3F
00:DA4F 00
00:DA50 00
00:DA51 00
00:DA52 00              	   206:   dfb $00,$00,$3F,$30,$37,$36,$36,$36 ; $C9
00:DA53 00
00:DA54 3F
00:DA55 30
00:DA56 37
00:DA57 36
00:DA58 36
00:DA59 36
00:DA5A 36              	   207:   dfb $36,$36,$F7,$00,$FF,$00,$00,$00 ; $CA
00:DA5B 36
00:DA5C F7
00:DA5D 00
00:DA5E FF
00:DA5F 00
00:DA60 00
00:DA61 00
00:DA62 00              	   208:   dfb $00,$00,$FF,$00,$F7,$36,$36,$36 ; $CB
00:DA63 00
00:DA64 FF
00:DA65 00
00:DA66 F7
00:DA67 36
00:DA68 36
00:DA69 36
00:DA6A 36              	   209:   dfb $36,$36,$37,$30,$37,$36,$36,$36 ; $CC
00:DA6B 36
00:DA6C 37
00:DA6D 30
00:DA6E 37
00:DA6F 36
00:DA70 36
00:DA71 36
00:DA72 00              	   210:   dfb $00,$00,$FF,$00,$FF,$00,$00,$00 ; $CD
00:DA73 00
00:DA74 FF
00:DA75 00
00:DA76 FF
00:DA77 00
00:DA78 00
00:DA79 00
00:DA7A 36              	   211:   dfb $36,$36,$F7,$00,$F7,$36,$36,$36 ; $CE
00:DA7B 36
00:DA7C F7
00:DA7D 00
00:DA7E F7
00:DA7F 36
00:DA80 36
00:DA81 36
00:DA82 18              	   212:   dfb $18,$18,$FF,$00,$FF,$00,$00,$00 ; $CF
00:DA83 18
00:DA84 FF
00:DA85 00
00:DA86 FF
00:DA87 00
00:DA88 00
00:DA89 00
00:DA8A 36              	   213:   dfb $36,$36,$36,$36,$FF,$00,$00,$00 ; $D0
00:DA8B 36
00:DA8C 36
00:DA8D 36
00:DA8E FF
00:DA8F 00
00:DA90 00
00:DA91 00
00:DA92 00              	   214:   dfb $00,$00,$FF,$00,$FF,$18,$18,$18 ; $D1
00:DA93 00
00:DA94 FF
00:DA95 00
00:DA96 FF
00:DA97 18
00:DA98 18
00:DA99 18
00:DA9A 00              	   215:   dfb $00,$00,$00,$00,$FF,$36,$36,$36 ; $D2
00:DA9B 00
00:DA9C 00
00:DA9D 00
00:DA9E FF
00:DA9F 36
00:DAA0 36
00:DAA1 36
00:DAA2 36              	   216:   dfb $36,$36,$36,$36,$3F,$00,$00,$00 ; $D3
00:DAA3 36
00:DAA4 36
00:DAA5 36
00:DAA6 3F
00:DAA7 00
00:DAA8 00
00:DAA9 00
00:DAAA 18              	   217:   dfb $18,$18,$1F,$18,$1F,$00,$00,$00 ; $D4
00:DAAB 18
00:DAAC 1F
00:DAAD 18
00:DAAE 1F
00:DAAF 00
00:DAB0 00
00:DAB1 00
00:DAB2 00              	   218:   dfb $00,$00,$1F,$18,$1F,$18,$18,$18 ; $D5
00:DAB3 00
00:DAB4 1F
00:DAB5 18
00:DAB6 1F
00:DAB7 18
00:DAB8 18
00:DAB9 18
00:DABA 00              	   219:   dfb $00,$00,$00,$00,$3F,$36,$36,$36 ; $D6
00:DABB 00
00:DABC 00
00:DABD 00
00:DABE 3F
00:DABF 36
00:DAC0 36
00:DAC1 36
00:DAC2 36              	   220:   dfb $36,$36,$36,$36,$FF,$36,$36,$36 ; $D7
00:DAC3 36
00:DAC4 36
00:DAC5 36
00:DAC6 FF
00:DAC7 36
00:DAC8 36
00:DAC9 36
00:DACA 18              	   221:   dfb $18,$18,$FF,$18,$FF,$18,$18,$18 ; $D8
00:DACB 18
00:DACC FF
00:DACD 18
00:DACE FF
00:DACF 18
00:DAD0 18
00:DAD1 18
00:DAD2 18              	   222:   dfb $18,$18,$18,$18,$F8,$00,$00,$00 ; $D9
00:DAD3 18
00:DAD4 18
00:DAD5 18
00:DAD6 F8
00:DAD7 00
00:DAD8 00
00:DAD9 00
00:DADA 00              	   223:   dfb $00,$00,$00,$00,$1F,$18,$18,$18 ; $DA
00:DADB 00
00:DADC 00
00:DADD 00
00:DADE 1F
00:DADF 18
00:DAE0 18
00:DAE1 18
00:DAE2 FF              	   224:   dfb $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF ; $DB
00:DAE3 FF
00:DAE4 FF
00:DAE5 FF
00:DAE6 FF
00:DAE7 FF
00:DAE8 FF
00:DAE9 FF
00:DAEA 00              	   225:   dfb $00,$00,$00,$00,$FF,$FF,$FF,$FF ; $DC
00:DAEB 00
00:DAEC 00
00:DAED 00
00:DAEE FF
00:DAEF FF
00:DAF0 FF
00:DAF1 FF
00:DAF2 F0              	   226:   dfb $F0,$F0,$F0,$F0,$F0,$F0,$F0,$F0 ; $DD
00:DAF3 F0
00:DAF4 F0
00:DAF5 F0
00:DAF6 F0
00:DAF7 F0
00:DAF8 F0
00:DAF9 F0
00:DAFA 0F              	   227:   dfb $0F,$0F,$0F,$0F,$0F,$0F,$0F,$0F ; $DE
00:DAFB 0F
00:DAFC 0F
00:DAFD 0F
00:DAFE 0F
00:DAFF 0F
00:DB00 0F
00:DB01 0F
00:DB02 FF              	   228:   dfb $FF,$FF,$FF,$FF,$00,$00,$00,$00 ; $DF
00:DB03 FF
00:DB04 FF
00:DB05 FF
00:DB06 00
00:DB07 00
00:DB08 00
00:DB09 00
00:DB0A 00              	   229:   dfb $00,$00,$76,$DC,$C8,$DC,$76,$00 ; $E0
00:DB0B 00
00:DB0C 76
00:DB0D DC
00:DB0E C8
00:DB0F DC
00:DB10 76
00:DB11 00
00:DB12 00              	   230:   dfb $00,$78,$CC,$F8,$CC,$F8,$C0,$C0 ; $E1
00:DB13 78
00:DB14 CC
00:DB15 F8
00:DB16 CC
00:DB17 F8
00:DB18 C0
00:DB19 C0
00:DB1A 00              	   231:   dfb $00,$FC,$CC,$C0,$C0,$C0,$C0,$00 ; $E2
00:DB1B FC
00:DB1C CC
00:DB1D C0
00:DB1E C0
00:DB1F C0
00:DB20 C0
00:DB21 00
00:DB22 00              	   232:   dfb $00,$FE,$6C,$6C,$6C,$6C,$6C,$00 ; $E3
00:DB23 FE
00:DB24 6C
00:DB25 6C
00:DB26 6C
00:DB27 6C
00:DB28 6C
00:DB29 00
00:DB2A FC              	   233:   dfb $FC,$CC,$60,$30,$60,$CC,$FC,$00 ; $E4
00:DB2B CC
00:DB2C 60
00:DB2D 30
00:DB2E 60
00:DB2F CC
00:DB30 FC
00:DB31 00
00:DB32 00              	   234:   dfb $00,$00,$7E,$D8,$D8,$D8,$70,$00 ; $E5
00:DB33 00
00:DB34 7E
00:DB35 D8
00:DB36 D8
00:DB37 D8
00:DB38 70
00:DB39 00
00:DB3A 00              	   235:   dfb $00,$66,$66,$66,$66,$7C,$60,$C0 ; $E6
00:DB3B 66
00:DB3C 66
00:DB3D 66
00:DB3E 66
00:DB3F 7C
00:DB40 60
00:DB41 C0
00:DB42 00              	   236:   dfb $00,$76,$DC,$18,$18,$18,$18,$00 ; $E7
00:DB43 76
00:DB44 DC
00:DB45 18
00:DB46 18
00:DB47 18
00:DB48 18
00:DB49 00
00:DB4A FC              	   237:   dfb $FC,$30,$78,$CC,$CC,$78,$30,$FC ; $E8
00:DB4B 30
00:DB4C 78
00:DB4D CC
00:DB4E CC
00:DB4F 78
00:DB50 30
00:DB51 FC
00:DB52 38              	   238:   dfb $38,$6C,$C6,$FE,$C6,$6C,$38,$00 ; $E9
00:DB53 6C
00:DB54 C6
00:DB55 FE
00:DB56 C6
00:DB57 6C
00:DB58 38
00:DB59 00
00:DB5A 38              	   239:   dfb $38,$6C,$C6,$C6,$6C,$6C,$EE,$00 ; $EA
00:DB5B 6C
00:DB5C C6
00:DB5D C6
00:DB5E 6C
00:DB5F 6C
00:DB60 EE
00:DB61 00
00:DB62 1C              	   240:   dfb $1C,$30,$18,$7C,$CC,$CC,$78,$00 ; $EB
00:DB63 30
00:DB64 18
00:DB65 7C
00:DB66 CC
00:DB67 CC
00:DB68 78
00:DB69 00
00:DB6A 00              	   241:   dfb $00,$00,$7E,$DB,$DB,$7E,$00,$00 ; $EC
00:DB6B 00
00:DB6C 7E
00:DB6D DB
00:DB6E DB
00:DB6F 7E
00:DB70 00
00:DB71 00
00:DB72 06              	   242:   dfb $06,$0C,$7E,$DB,$DB,$7E,$60,$C0 ; $ED
00:DB73 0C
00:DB74 7E
00:DB75 DB
00:DB76 DB
00:DB77 7E
00:DB78 60
00:DB79 C0
00:DB7A 38              	   243:   dfb $38,$60,$C0,$F8,$C0,$60,$38,$00 ; $EE
00:DB7B 60
00:DB7C C0
00:DB7D F8
00:DB7E C0
00:DB7F 60
00:DB80 38
00:DB81 00
00:DB82 78              	   244:   dfb $78,$CC,$CC,$CC,$CC,$CC,$CC,$00 ; $EF
00:DB83 CC
00:DB84 CC
00:DB85 CC
00:DB86 CC
00:DB87 CC
00:DB88 CC
00:DB89 00
00:DB8A 00              	   245:   dfb $00,$FC,$00,$FC,$00,$FC,$00,$00 ; $F0
00:DB8B FC
00:DB8C 00
00:DB8D FC
00:DB8E 00
00:DB8F FC
00:DB90 00
00:DB91 00
00:DB92 30              	   246:   dfb $30,$30,$FC,$30,$30,$00,$FC,$00 ; $F1
00:DB93 30
00:DB94 FC
00:DB95 30
00:DB96 30
00:DB97 00
00:DB98 FC
00:DB99 00
00:DB9A 60              	   247:   dfb $60,$30,$18,$30,$60,$00,$FC,$00 ; $F2
00:DB9B 30
00:DB9C 18
00:DB9D 30
00:DB9E 60
00:DB9F 00
00:DBA0 FC
00:DBA1 00
00:DBA2 18              	   248:   dfb $18,$30,$60,$30,$18,$00,$FC,$00 ; $F3
00:DBA3 30
00:DBA4 60
00:DBA5 30
00:DBA6 18
00:DBA7 00
00:DBA8 FC
00:DBA9 00
00:DBAA 0E              	   249:   dfb $0E,$1B,$1B,$18,$18,$18,$18,$18 ; $F4
00:DBAB 1B
00:DBAC 1B
00:DBAD 18
00:DBAE 18
00:DBAF 18
00:DBB0 18
00:DBB1 18
00:DBB2 18              	   250:   dfb $18,$18,$18,$18,$18,$D8,$D8,$70 ; $F5
00:DBB3 18
00:DBB4 18
00:DBB5 18
00:DBB6 18
00:DBB7 D8
00:DBB8 D8
00:DBB9 70
00:DBBA 30              	   251:   dfb $30,$30,$00,$FC,$00,$30,$30,$00 ; $F6
00:DBBB 30
00:DBBC 00
00:DBBD FC
00:DBBE 00
00:DBBF 30
00:DBC0 30
00:DBC1 00
00:DBC2 00              	   252:   dfb $00,$76,$DC,$00,$76,$DC,$00,$00 ; $F7
00:DBC3 76
00:DBC4 DC
00:DBC5 00
00:DBC6 76
00:DBC7 DC
00:DBC8 00
00:DBC9 00
00:DBCA 38              	   253:   dfb $38,$6C,$6C,$38,$00,$00,$00,$00 ; $F8
00:DBCB 6C
00:DBCC 6C
00:DBCD 38
00:DBCE 00
00:DBCF 00
00:DBD0 00
00:DBD1 00
00:DBD2 00              	   254:   dfb $00,$00,$00,$18,$18,$00,$00,$00 ; $F9
00:DBD3 00
00:DBD4 00
00:DBD5 18
00:DBD6 18
00:DBD7 00
00:DBD8 00
00:DBD9 00
00:DBDA 00              	   255:   dfb $00,$00,$00,$00,$18,$00,$00,$00 ; $FA
00:DBDB 00
00:DBDC 00
00:DBDD 00
00:DBDE 18
00:DBDF 00
00:DBE0 00
00:DBE1 00
00:DBE2 0F              	   256:   dfb $0F,$0C,$0C,$0C,$EC,$6C,$3C,$1C ; $FB
00:DBE3 0C
00:DBE4 0C
00:DBE5 0C
00:DBE6 EC
00:DBE7 6C
00:DBE8 3C
00:DBE9 1C
00:DBEA 78              	   257:   dfb $78,$6C,$6C,$6C,$6C,$00,$00,$00 ; $FC
00:DBEB 6C
00:DBEC 6C
00:DBED 6C
00:DBEE 6C
00:DBEF 00
00:DBF0 00
00:DBF1 00
00:DBF2 70              	   258:   dfb $70,$18,$30,$60,$78,$00,$00,$00 ; $FD
00:DBF3 18
00:DBF4 30
00:DBF5 60
00:DBF6 78
00:DBF7 00
00:DBF8 00
00:DBF9 00
00:DBFA 00              	   259:   dfb $00,$00,$3C,$3C,$3C,$3C,$00,$00 ; $FE
00:DBFB 00
00:DBFC 3C
00:DBFD 3C
00:DBFE 3C
00:DBFF 3C
00:DC00 00
00:DC01 00
00:DC02 00              	   260:   dfb $00,$00,$00,$00,$00,$00,$00,$00 ; $FF
00:DC03 00
00:DC04 00
00:DC05 00
00:DC06 00
00:DC07 00
00:DC08 00
00:DC09 00
                        	   261: 

Source: "gpascal.asm"
                        	   195:   .endif
                        	   196: 
00:DC0A 472D50617363616C	   197: introduction asc    "G-Pascal compiler, version 4.03.\n"
00:DC12 20636F6D70696C65
00:DC1A 722C207665727369
00:DC22 6F6E20342E30332E
00:DC2A 0A
00:DC2B 5772697474656E20	   198:              asciiz "Written by Nick Gammon.\nType H for help.\n"
00:DC33 6279204E69636B20
00:DC3B 47616D6D6F6E2E0A
00:DC43 5479706520482066
00:DC4B 6F722068656C702E
00:DC53 0A
00:DC54 00
                        	   199: 
                        	   200:   .if LCD_SUPPORT
00:DC55 4E69636B27732047	   201: LCD_welcome asciiz "Nick's G-Pascal\nCompiler v4.03"
00:DC5D 2D50617363616C0A
00:DC65 436F6D70696C6572
00:DC6D 2076342E3033
00:DC73 00
                        	   202:   .endif
                        	   203: 
                        	   204: ;
                        	   205: ; here for cold start - clear text file to null etc. etc.
                        	   206: ;
                        	   207: START    =  *
00:DC74 D8              	   208:   cld             ; cancel decimal mode
00:DC75 78              	   209:   sei             ; no interrupts yet
00:DC76 A9FF            	   210:   lda #$FF
00:DC78 8509            	   211:   sta random      ; initialise random numbers
00:DC7A 850A            	   212:   sta random+1
00:DC7C 850B            	   213:   sta random+2
00:DC7E 850C            	   214:   sta random+3
                        	   215: ;
                        	   216: ;  Put 0x00 at start of source
                        	   217: ;
00:DC80 A900            	   218:   lda  #<TEXT_START
00:DC82 8500            	   219:   sta  REG
00:DC84 A903            	   220:   lda  #>TEXT_START
00:DC86 8501            	   221:   sta  REG+1
00:DC88 A900            	   222:   lda  #0
00:DC8A A8              	   223:   tay
00:DC8B 9100            	   224:   sta  (REG),Y     ; null edit file
00:DC8D 84BE            	   225:   sty  system_flags
00:DC8F AA              	   226:   tax
                        	   227: ;
                        	   228: ;  now do rest of initialization
                        	   229: ;
                        	   230: RESTART  =  *
00:DC90 A2FF            	   231:   ldx  #NEW_STK
00:DC92 9A              	   232:   txs             ; reset stack
00:DC93 58              	   233:   cli             ; allow interrupts after a NMI
00:DC94 D8              	   234:   cld             ; cancel decimal mode
00:DC95 206ACB          	   235:   jsr hardware_init
                        	   236: 
                        	   237: ;
                        	   238: REST1    =  *
                        	   239:   .if LCD_SUPPORT
                        	   240:     ;
                        	   241:     ;  put message on the LCD screen to prove it is working
                        	   242:     ;
00:DC98 A955            	   243:     lda  #<LCD_welcome  ; G-pascal compiler
00:DC9A A2DC            	   244:     ldx  #>LCD_welcome
00:DC9C 2043BB          	   245:     jsr lcd_print_message
                        	   246:   .endif
                        	   247: 
                        	   248: ;
                        	   249: ;  now direct output to the serial port
                        	   250: ;
00:DC9F 203DCB          	   251:   jsr  write_to_serial   ; set up outputting function
00:DCA2 A900            	   252:   lda  #0
00:DCA4 853F            	   253:   sta  RUNNING
00:DCA6 4C6B82          	   254:   jmp  main_start    ; go to "shell"
                        	   255: 
                        	   256: 
                        	   257: ;
                        	   258: ;  processor hardware vectors
                        	   259: ;
                        	   260:   .org $FFFA
01:FFFA 90DC            	   261:   .word RESTART   ; non-maskable interrupt (NMI)
01:FFFC 74DC            	   262:   .word START     ; reset vector
01:FFFE 62B9            	   263:   .word irq       ; maskable interrupt (IRQ)
                        	   264: 


Symbols by name:
ACT_PCDA                         S:0025
ADD1                             E:BC2F
ADD4                             E:BC52
ADD9                             E:BC6E
ADDSYM                           E:BBD3
ADDSYM_NOT_FULL                  A:BC08
ASS1                             A:C0A0
ASS2                             A:C0E8
ASSARR                           A:C0C7
ASSEMBLE                         A:9A89
ASSEMBLE_PASS                    A:9A9B
ASSEMBLE_SECOND_PASS             A:9A96
ASSIGN                           A:C09D
ASSTB1                           A:C0AC
ASSVAR                           A:C0D9
ASS_COUNT                        S:0072
ASS_EMIT_COUNT                   S:006F
ASS_OPCODE_WORK                  S:0070
ASS_OPERAND                      S:006B
ASS_OPERAND_ABSOLUTE             E:0001
ASS_OPERAND_ABSOLUTE_INDEXED_IN  E:0002
ASS_OPERAND_ABSOLUTE_INDEXED_WI  E:0003
ASS_OPERAND_ABSOLUTE_INDEXED_WI  E:0004
ASS_OPERAND_ABSOLUTE_INDIRECT    E:0005
ASS_OPERAND_ACCUMULATOR_A        E:0006
ASS_OPERAND_IMMEDIATE            E:0007
ASS_OPERAND_IMPLIED              E:0008
ASS_OPERAND_STRING               E:0011
ASS_OPERAND_ZERO_PAGE            E:000B
ASS_OPERAND_ZERO_PAGE_AND_ABSOL  E:0012
ASS_OPERAND_ZERO_PAGE_INDEXED_I  E:000C
ASS_OPERAND_ZERO_PAGE_INDEXED_W  E:000D
ASS_OPERAND_ZERO_PAGE_INDEXED_W  E:000E
ASS_OPERAND_ZERO_PAGE_INDIRECT   E:000F
ASS_OPERAND_ZERO_PAGE_INDIRECT_  E:0010
ASS_PASS                         S:0076
ASS_VALUE                        S:0073
BACKSPACE                        E:0008
BAD_INP                          A:B553
BASE                             S:003B
BAUD_RATE                        E:12C0
BEG                              A:C34D
BELL1                            E:B10B
BIT_INTERVAL                     E:00D0
BLCKT1                           A:C56E
BLCKT2                           A:C571
BLCKT3                           A:C574
BLK1                             A:C5A9
BLK1A                            A:C595
BLK2                             A:C5B1
BLK4                             A:C5BB
BLKB1                            A:C811
BLKB2                            A:C82D
BLKB3                            A:C80B
BLKB4                            A:C849
BLKB5                            A:C83A
BLKB6                            A:C858
BLKBEG                           A:C801
BLKCN1                           A:C5C8
BLKCNS                           A:C5C5
BLKFNC                           A:C739
BLKPR1                           A:C75B
BLKPR2                           A:C78D
BLKPR3                           A:C777
BLKPR4                           A:C7D5
BLKPR5                           E:C7AE
BLKPR6                           A:C784
BLKPRC                           A:C719
BLKV10                           E:C60F
BLKV10_A                         E:C62B
BLKV10_B                         E:C632
BLKV11                           A:C699
BLKV12                           A:C6A0
BLKV13                           A:C65A
BLKVAR                           A:C5DC
BLKVR1                           A:C5E0
BLKVR2                           A:C641
BLKVR3                           A:C701
BLKVR4                           A:C65F
BLKVR5                           E:C6BF
BLKVR6                           A:C5E3
BLKVR7                           A:C5ED
BLKVR8                           A:C60C
BLKVR9                           E:C6A6
BLOCK                            A:C57E
BSAVE                            S:0036
CALL                             S:0047
CALLSB                           A:C279
CASE                             A:C3B9
CASE1                            A:C3F2
CASE2                            E:C3CB
CASE3                            A:C408
CASE4                            A:C3FE
CASE5                            A:C43B
CASE6                            A:C459
CASE7                            A:C3C7
CASE8                            A:C46E
CASE9                            A:C464
CHKDUP                           A:BC7A
CHKGET                           E:C547
CHKLHB                           E:BCF5
CHKLHP                           E:BCDB
CHKNOK                           E:D1E0
CHKOK                            E:D1E3
CHKRHB                           E:BCFF
CHKRHP                           E:BCE2
CHKTKN                           A:D1E5
CHK_KBD                          E:B15F
CHK_NOTD                         A:B187
CHK_NOTN                         A:B16B
CHK_NOTT                         A:B179
CHK_RUN                          A:95AB
CHK_STAK                         E:BE01
CHK_VAL                          E:9598
CHK_VAL9                         E:95AA
CHRIN                            E:CB53
CLOCK_RATE                       E:4240
COMPIL                           A:BC8A
COMS8                            A:947A
COMS9                            A:9479
COMSTL                           E:946D
CONDEC                           E:BD1A
CONST                            E:BE0D
CONST1                           A:BE24
CONST2                           A:BE2E
CONST3                           E:BE29
CONST9                           A:BE32
COUNT1                           S:004B
COUNT2                           S:004C
COUT                             A:95F6
COUT_CALL                        A:9600
CR                               E:000D
CROUT                            E:9468
DATA                             S:003D
DATTYP                           S:004A
DB11                             A:B024
DBGFLG                           S:0049
DCODE                            S:002E
DEBUG                            E:B024
DEBUG_DONE                       A:B08C
DEST                             E:0003
DIRECTIVES                       E:A202
DIS5                             A:B0F4
DIS5_A                           E:B0FE
DISHX                            A:947D
DISP9                            A:CA13
DISPAD                           E:9483
DISPAD2                          A:949E
DISPL                            S:0027
DIVBY0                           A:B309
DM1                              A:B009
DM2                              A:B012
DM5                              A:B0B3
DM6                              A:B0C8
DM7                              A:B0D3
DUP9                             A:BC89
EFLAG_ALLOW_ZERO_FROM            E:0002
EFLAG_FIND                       E:0010
EFLAG_LOAD                       E:0004
EFLAG_NO_LINE_NUMBERS            E:0080
EFLAG_REPLACE                    E:0020
EFLAG_SAVE                       E:0008
EFLAG_SHOW_LINE                  E:0001
EFLAG_SUPPRESS_NEWLINE           E:0040
EMULATOR                         E:0000
EMULATOR_DEBUG                   A:CB67
ENDSYM                           S:0031
END_CMP                          E:BCD8
END_EDITOR_INPUT                 E:001B
END_PCD                          S:0043
END_WRK                          E:C563
ERR1                             E:99BE
ERR3                             E:99D2
ERR5                             E:99E2
ERR6                             E:99E8
ERR7                             E:99B4
ERRLIT                           A:999F
ERRNO                            S:0035
ERROR                            A:99AB
EXPR1                            A:C029
EXPR2                            A:C04B
EXPR3                            A:C051
EXPR4                            A:C055
EXPR5                            A:C059
EXPR6                            A:C05D
EXPR7                            A:C061
EXPR8                            A:C04D
EXPRES                           A:C006
EXPTB1                           A:C016
EXPTB3                           A:C038
EX_ABS                           A:B32D
EX_ABSCLL                        E:B5C2
EX_ADD                           A:B2C9
EX_ADRAC                         E:B7A1
EX_ADRAN                         E:B79B
EX_ADRN2                         E:B790
EX_ADRNC                         E:B77D
EX_ADRNC2                        E:B780
EX_ADRNN                         E:B78D
EX_AND                           A:B39B
EX_ASSERT                        A:B834
EX_ASSERT_OK                     A:B849
EX_CLA                           A:B658
EX_CLL                           E:B5C9
EX_CLL2                          E:B5F3
EX_CLL3                          E:B614
EX_CLL4                          E:B5EF
EX_CLL5                          E:B655
EX_CLL_A                         E:B5D1
EX_CLL_JMP                       A:B675
EX_DEC                           A:B3DD
EX_DELAY                         E:B7F0
EX_DIGITALREAD                   E:B7A7
EX_DIGITALREAD_ONE               A:B7B2
EX_DIGITALWRITE                  E:B81F
EX_DIV                           A:B319
EX_DIVIDE_BY_ZERO                A:B302
EX_EOR                           A:B3A4
EX_EQL                           A:B336
EX_FINISHD                       E:B129
EX_GEQ                           A:B371
EX_GETKEY                        E:B2E7
EX_GTR                           A:B365
EX_INC                           A:B3C5
EX_INP                           E:B51B
EX_INPC                          A:B6E3
EX_INPC_OK                       A:B6ED
EX_INP_OK                        A:B52C
EX_INS                           E:B71F
EX_INS1                          E:B742
EX_INS2                          E:B74B
EX_INS3                          E:B729
EX_INS4                          E:B755
EX_INT                           A:B678
EX_INVINS                        E:B1DC
EX_JM1                           A:B6D8
EX_JMP                           A:B6B4
EX_JMZ                           A:B6C7
EX_LATENCY                       A:B7E1
EX_LCDCLEAR                      A:B719
EX_LCDHOME                       A:B713
EX_LCDPOS                        E:B7B5
EX_LCDPOS_1                      A:B7C5
EX_LCD_WRITE_CHR                 A:B702
EX_LCD_WRITE_HEX                 A:B574
EX_LCD_WRITE_NUM                 A:B560
EX_LCD_WRITE_STR                 A:B594
EX_LDA                           A:B439
EX_LDAC                          A:B42E
EX_LDI                           A:B474
EX_LDIC                          A:B46E
EX_LEQ                           A:B37D
EX_LIB_CALL                      A:B82E
EX_LIT                           A:B2AE
EX_LOD                           A:B418
EX_LOD2                          A:B41B
EX_LOD3                          A:B409
EX_LOD3_A                        A:B40B
EX_LODC                          A:B406
EX_LSS                           A:B359
EX_MOD                           A:B2EE
EX_MOV                           A:B3F5
EX_MUL                           A:B2DE
EX_NEG                           A:B2C0
EX_NEQ                           A:B350
EX_NEW_STACK                     A:B6A2
EX_NOJUMP                        A:B6D2
EX_ORR                           A:B392
EX_OUH                           A:B56F
EX_OUH_COMMON                    A:B577
EX_OUS                           E:B58F
EX_OUS1                          A:B5B3
EX_OUS_COMMON                    A:B597
EX_OUT                           A:B55B
EX_OUTC                          A:B6FD
EX_OUTCR                         E:B189
EX_OUTC_COMMON                   A:B705
EX_PINMODE                       E:B810
EX_RANDOM                        A:B7CF
EX_RANDOMSEED                    E:B800
EX_RTN                           A:B4E2
EX_SHL                           A:B3AD
EX_SHR                           A:B3B9
EX_STA                           A:B49A
EX_STA5                          A:B4AB
EX_STAC                          A:B4B0
EX_STI                           A:B4C7
EX_STIC                          A:B4B9
EX_STO                           A:B487
EX_STO2                          A:B48D
EX_STO5                          A:B482
EX_STOC                          A:B47A
EX_SUB                           A:B2D2
EX_XOR                           A:B389
FACAD1                           A:BF54
FACAD2                           A:BF72
FACADR                           E:BF9C
FACERR1                          A:BFB5
FACM2                            A:BFD0
FACMEM                           A:BFC6
FACMMC                           A:BFCC
FACNOT                           A:BFDC
FACNUM                           E:BFBA
FACRND1                          A:BFE7
FACSTR                           A:BFAF
FACTB1                           A:BFED
FACTOR                           A:BF05
FACTQT1                          A:BFF3
FALSE                            A:B34C
FFLAG_GLOBAL                     E:0002
FFLAG_IGNORE_CASE                E:0001
FFLAG_QUIET                      E:0004
FIN_MSG                          A:B140
FIXAD                            E:CA5C
FIXAD1                           A:CA99
FIXM1                            A:CA9A
FIXM2                            A:CAA3
FLAG_ASSEMBLING                  E:0002
FLAG_BRK_REACHED                 E:0080
FLAG_COMPILING                   E:0001
FLAG_LIST_SOURCE                 E:0004
FLAG_ONLY_ALPHA                  E:0040
FLAG_VALID_ASSEMBLE              E:0010
FLAG_VALID_COMPILE               E:0008
FNC1                             A:C2C3
FNC2                             A:C293
FNC3                             A:C2BD
FNC4                             A:C307
FNC5                             A:C2C6
FNC5A                            A:C2E3
FNC5B                            A:C2E5
FNC6                             A:C308
FNCPRC                           A:C286
FOR                              A:C474
FOR1                             A:C47E
FOR2                             A:C48B
FOR3                             A:C4A4
FOR4                             A:C4D5
FOR5                             A:C518
FOR6                             A:C53A
FRAME                            S:0020
FROM                             E:0040
GEN1                             E:C9BA
GEN2                             E:C9F1
GEN2_A                           E:C9FC
GEN2_B                           E:C9F3
GEN2_C                           E:CA13
GEN3                             E:CA57
GENADR                           E:C9BE
GENJMP                           E:CA2E
GENNJM                           A:CA28
GENNJP                           E:CA26
GENNOP                           E:C9A5
GENNOP1                          A:BFE4
GENNOP2                          A:C251
GENRJMP                          E:CA14
GEN_FULL                         A:CA0E
GET1                             A:95D0
GET1_A                           E:B233
GET2                             E:B1F7
GET3                             A:95ED
GETADR                           A:B1ED
GETADR1                          E:B218
GETCHK                           A:D1D5
GETEXPR                          E:BD99
GETID2                           A:B460
GETIDC                           A:B443
GETIDX                           E:B44C
GETIN                            E:CB53
GETIN1                           A:CB5D
GETLIT                           E:B297
GETLN1                           E:95CE
GETLN_OVERFLOW                   A:95F3
GETO_1                           E:BD8A
GETO_2                           E:BD97
GETSUB                           E:BCEC
GET_COMM                         E:BDCB
GET_DAT                          E:BD13
GET_END                          A:B2AD
GET_ITEM                         E:BDD2
GET_LEV                          E:BD09
GET_LINE                         E:95CE
GET_LOOK                         A:D1EA
GET_OFF                          E:BD6E
HIGHEST_RAM                      E:3FFF
I2C_DDR                          E:7FF3
I2C_PORT                         E:7FF1
I2C_SCL                          E:0004
I2C_SDA                          E:0008
IDENT                            A:BF16
IDENT1                           A:BF19
IDENT1A                          A:BF21
IDENT2                           A:BF26
IDENT2A                          A:BF3F
IDENT3                           A:BF46
IDENT4                           A:BF7A
IDENT4_A                         A:BF7C
IDENT5                           A:BF5C
IDENT5_A                         A:BF5E
IDENT6                           A:BF69
IDENT7                           A:BF6F
IF                               A:C30D
IF1                              A:C332
IF2                              A:C32B
INBUF                            S:0200
INBUF_SIZE                       E:0100
INIT                             E:941A
INIT9                            A:9467
INIT_SECOND_PASS                 A:9426
INP3                             A:B543
INTERP                           E:B08D
INT_ERR                          E:B68F
INT_ERRM                         A:B696
JMP1                             E:91DA
JMP2                             E:91E2
JMP3                             E:91F7
KEY_ABORT                        E:0003
KEY_DEBUG                        E:0004
KEY_STOP_TRACE                   E:000E
KEY_TRACE                        E:0014
LASTP                            S:004D
LCD_E                            E:0080
LCD_RS                           E:0020
LCD_RW                           E:0040
LCD_SUPPORT                      E:0001
LCD_welcome                      A:DC55
LEVEL                            S:0022
LINE_CNT                         S:0019
LIST                             S:001D
LIT1                             A:B2BD
LOOK1                            A:BC79
LOOKUP                           E:BC6F
LOWLIT                           A:B18F
LOWLIT1                          A:B195
MAIN                             A:B19E
MAINP                            A:B19B
MAIN_1                           E:B1CD
MAIN_2                           E:B1A5
MAIN_NOT_ABORT                   E:B1B0
MAIN_OK                          E:B1B3
MAKE_LOWER_DONE                  E:9219
MAKE_UPPER                       E:9204
MAKE_UPPER_DONE                  E:920E
MAX_STK                          E:0020
MEM                              A:C25E
MEM2                             A:C266
MEMC                             A:C263
NEW_STK                          E:00FF
NL                               E:000A
NOSCE                            A:9409
NOTIM1                           E:B1E0
OFFSET                           S:0029
ONE_OP                           A:C24A
ONE_OP2                          A:C247
OPCODE                           S:006C
OPCODE_3_CHAR_BRANCH             E:A2C6
OPCODE_3_CHAR_IMPLIED            E:A2EB
OPCODE_4_CHAR_BRANCH             E:A275
OPCODE_4_CHAR_ZERO_PAGE          E:A368
OPCODE_ASS_OPERAND_ABSOLUTE      E:A3B9
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A425
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A42A
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A46F
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A472
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A497
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A4B3
OPCODE_ASS_OPERAND_ABSOLUTE_TOK  E:A422
OPCODE_ASS_OPERAND_ACCUMULATOR_  E:A49A
OPCODE_ASS_OPERAND_IMMEDIATE     E:A4B8
OPCODE_ASS_OPERAND_IMMEDIATE_TO  E:A4E9
OPCODE_ASS_OPERAND_ZERO_PAGE     E:A4EC
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A550
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A571
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A574
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A5BD
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A5C0
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A5C9
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A5ED
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A60E
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A5EA
OPCODE_ASS_OPERAND_ZERO_PAGE_TO  E:A54D
OPCODE_LEN                       S:006E
OPCODE_LOOKUP_HANDLER            E:0004
OPCODE_LOOKUP_OPCODE_LENGTH      E:0000
OPCODE_LOOKUP_OPCODE_TABLE       E:0002
OPCODE_LOOKUP_OPERAND_TYPE       E:0001
OPCODE_LOOKUP_TABLE              E:A15F
OPCODE_LOOKUP_TABLE_SIZE         E:0006
OPND                             S:002B
OUT_COMMON                       A:B563
PAREN                            A:BFC0
PCD_WRKD                         E:BD9F
PCODE                            S:0023
PCODE_ABSCLL                     E:0038
PCODE_ADD                        E:0004
PCODE_ADRAN                      E:000E
PCODE_ADRNN                      E:000C
PCODE_AND                        E:001B
PCODE_CLA                        E:002B
PCODE_CLL                        E:0027
PCODE_DEC                        E:0028
PCODE_DIV                        E:000A
PCODE_EOR                        E:0020
PCODE_EQL                        E:0010
PCODE_FINISHD                    E:0011
PCODE_GEQ                        E:0016
PCODE_GTR                        E:0018
PCODE_INC                        E:0026
PCODE_INP                        E:001C
PCODE_INS                        E:0025
PCODE_INT                        E:003B
PCODE_JM1                        E:003E
PCODE_JMP                        E:003C
PCODE_JMZ                        E:003D
PCODE_LAST                       E:0045
PCODE_LCD_WRITE_CHR              E:0045
PCODE_LCD_WRITE_HEX              E:0044
PCODE_LCD_WRITE_NUM              E:0042
PCODE_LCD_WRITE_STR              E:0043
PCODE_LDA                        E:002E
PCODE_LDI                        E:0030
PCODE_LEQ                        E:0019
PCODE_LIB_CALL                   E:0003
PCODE_LIT                        E:0000
PCODE_LOD                        E:002C
PCODE_LSS                        E:0014
PCODE_MOD                        E:000B
PCODE_MOV                        E:002A
PCODE_MUL                        E:0008
PCODE_NEG                        E:0002
PCODE_NEQ                        E:0012
PCODE_ORR                        E:001A
PCODE_OUH                        E:0021
PCODE_OUS                        E:0023
PCODE_OUT                        E:001E
PCODE_OUTC                       E:001F
PCODE_OUTCR                      E:0040
PCODE_RTN                        E:0029
PCODE_SHL                        E:0022
PCODE_SHR                        E:0024
PCODE_STA                        E:0034
PCODE_STACK                      E:0001
PCODE_STI                        E:0036
PCODE_STO                        E:0032
PCODE_SUB                        E:0006
PCODE_XOR                        E:003A
PRBYTE                           A:94DD
PRBYTECR                         E:9592
PRCHAR                           E:94C5
PRCITM                           S:0039
PRHEX                            A:94E6
PRHEX1                           A:94F0
PRHEXZ                           A:94E8
PSH1                             E:B286
PSH9                             A:94B1
PSHPCODE                         E:BD5B
PSHTOP                           E:B27B
PSHWRK                           E:949F
PT                               A:94F7
PT6                              A:94FF
PUL2_END                         E:B274
PULBOTH                          A:B256
PULTOP                           E:B234
PULTOP2                          E:B259
PULWRK                           E:94B2
PUL_END                          E:B24F
PUTSP                            E:94F3
READ                             A:C1B5
READ11                           A:C1D5
READ2                            A:C1BB
READ3                            A:C204
READ3_A                          A:C233
READ3_B                          A:C218
READ7                            A:C1F4
READ7_A                          A:C1FA
READ8                            A:C1B8
READ9                            A:C1D2
REG                              E:0000
REG2                             E:0003
REG2B                            E:0005
REGB                             E:0002
REMAIN                           S:0006
REP1                             A:C366
REPEAT                           A:C363
RES                              S:0052
RESTART                          E:DC90
RMNDR                            S:005B
RSVEND                           A:D17F
RSVWRD                           E:D08C
RUNERR                           A:B115
RUNNING                          S:003F
RUNNING_STACK_TOP                E:00C0
SEA1                             E:BB6A
SEA2                             E:BB77
SEA3                             E:BBCB
SEA4                             E:BBC0
SEA5                             E:BBC8
SEARCH                           E:BB57
SEA_NEXT                         E:BB5F
SERIAL_DEBUG1_MASK               E:0004
SERIAL_DEBUG2_MASK               E:0008
SERIAL_DEBUGGING                 E:0000
SERIAL_DELAY1                    E:0030
SERIAL_DELAY2                    E:0023
SERIAL_OUT_MASK                  E:0002
SERIAL_SPARE2_MASK               E:0010
SIM1                             A:BE4F
SIM2                             A:BE97
SIM3                             A:BE60
SIM4                             A:BE73
SIM5                             A:BE8F
SIM6                             A:BE93
SIM7                             A:BE89
SIM8                             A:BE9D
SIMEXP                           E:BE45
SINGLE_QUOTE                     E:0027
SPI_DDR                          E:7FF2
SPI_MISO                         E:0004
SPI_MOSI                         E:0002
SPI_PORT                         E:7FF0
SPI_SCK                          E:0008
SPI_SS                           E:0001
SRCE                             E:0000
START                            E:DC74
STARTSYM                         S:002F
START_OF_ROM                     E:8000
START_TRACE                      A:CB68
STK_ERR                          A:BE08
STK_FULL                         E:BE08
STMNT                            A:C065
STMNT1                           A:C072
STMNT_WRITE_LCD                  A:C164
STOP_TRACE                       A:CB69
ST_SYMTBL_LIST_CHECK             E:8DCA
ST_SYMTBL_LIST_DONE              E:8E5F
ST_SYMTBL_LIST_LINE              E:8DD9
ST_SYMTBL_LIST_NAME              E:8E4E
ST_SYMTBL_LIST_NEXT              E:8DBF
SYMARG                           E:0006
SYMBOL_ARRAY                     E:0041
SYMBOL_CONSTANT                  E:0043
SYMBOL_FUNCTION                  E:0046
SYMBOL_FUNCTION_RETURN           E:0059
SYMBOL_LIBRARY_FUNCTION          E:0052
SYMBOL_LIBRARY_PROCEDURE         E:0051
SYMBOL_PROCEDURE                 E:0050
SYMBOL_TABLE_START               E:3FFF
SYMBOL_VARIABLE                  E:0056
SYMDAT                           E:0008
SYMDSP                           E:0004
SYMITM                           S:0040
SYMLEN                           E:0009
SYMLVL                           E:0002
SYMNAM                           E:000A
SYMPRV                           E:0000
SYMSUB                           E:0006
SYMTYP                           E:0003
SYMWRK                           E:BD45
SYM_FULL                         A:BBCE
SYNTAX                           S:0042
T                                E:0031
TEMP                             S:0045
TERM                             A:BEB7
TERM1                            A:BEC4
TERM2                            A:BEBA
TERM3                            A:BED5
TERM4                            A:BED3
TERM5                            A:BEDB
TERM6                            A:BEDF
TERM7                            A:BEE3
TERM8                            A:BEE7
TERM9                            A:BEEB
TERMT1                           A:BEA1
TERMT3                           A:BEEF
TEXT_START                       E:0300
TKNJMP                           E:91D2
TKNWRK                           E:9509
TOKEN_ADDRESS                    E:00A9
TOKEN_AND                        E:008D
TOKEN_ARRAY                      E:0084
TOKEN_ASSIGN                     E:0041
TOKEN_BEGIN                      E:0088
TOKEN_CALL                       E:009F
TOKEN_CASE                       E:0095
TOKEN_CHAR                       E:00A1
TOKEN_CHR                        E:00AB
TOKEN_CONST                      E:0082
TOKEN_DIV                        E:008B
TOKEN_DO                         E:0097
TOKEN_DOWNTO                     E:009C
TOKEN_ELSE                       E:0094
TOKEN_END                        E:0089
TOKEN_EQUALITY                   E:0045
TOKEN_FOR                        E:009A
TOKEN_FUNCTION                   E:0087
TOKEN_GEQ                        E:0081
TOKEN_HEX                        E:00AC
TOKEN_HIGH_BYTE                  E:0057
TOKEN_IDENTIFIER                 E:0049
TOKEN_IF                         E:0092
TOKEN_INEQUALITY                 E:005A
TOKEN_INTEGER                    E:00FE
TOKEN_LCDWRITE                   E:00F1
TOKEN_LEQ                        E:0080
TOKEN_LOGICAL_AND                E:0058
TOKEN_LOGICAL_OR                 E:0059
TOKEN_LOW_BYTE                   E:0056
TOKEN_MEM                        E:0091
TOKEN_MEMC                       E:00A2
TOKEN_MOD                        E:008C
TOKEN_NEQ                        E:0055
TOKEN_NOT                        E:0090
TOKEN_NUMBER                     E:004E
TOKEN_OF                         E:0085
TOKEN_OR                         E:008A
TOKEN_PROCEDURE                  E:0086
TOKEN_READ                       E:009E
TOKEN_REPEAT                     E:0098
TOKEN_SHIFT_LEFT                 E:004C
TOKEN_SHIFT_RIGHT                E:0052
TOKEN_SHL                        E:008E
TOKEN_SHR                        E:008F
TOKEN_STRING                     E:0022
TOKEN_THEN                       E:0093
TOKEN_TO                         E:009B
TOKEN_UNARY_MINUS                E:004D
TOKEN_UNTIL                      E:0099
TOKEN_VAR                        E:0083
TOKEN_WHILE                      E:0096
TOKEN_WRITE                      E:009D
TOKEN_WRITELN                    E:00FF
TOKEN_XOR                        E:00A4
TRUE                             A:B33F
TRUE2                            A:B341
TWO_OP                           A:C241
USE_CP437_FONT                   E:0001
VALUE                            S:0000
VALUE2                           S:0003
VAL_1                            E:BDE1
VAL_2                            E:BDE6
VAL_3                            E:BDEF
VAL_5                            E:BDF8
VAL_MOVE                         E:BDD8
VAL_WRK                          E:C558
VARDEC                           A:BE33
VIA_ACR                          E:7FFB
VIA_DDRA                         E:7FF3
VIA_DDRB                         E:7FF2
VIA_FLAG_CB2                     E:0008
VIA_FLAG_DISABLE                 E:0000
VIA_FLAG_ENABLE                  E:0080
VIA_FLAG_TIMER1                  E:0040
VIA_IER                          E:7FFE
VIA_IFR                          E:7FFD
VIA_PCR                          E:7FFC
VIA_PORTA                        E:7FF1
VIA_PORTB                        E:7FF0
VIA_T1C_H                        E:7FF5
VIA_T1C_L                        E:7FF4
WAIT_1                           A:C254
WHILE                            A:C387
WORK                             S:0037
WORKD                            S:0033
WRIT1                            E:C13F
WRIT10                           A:C132
WRIT2                            A:C12F
WRIT5                            A:C14F
WRIT9                            A:C116
WRITE                            A:C113
WRITELN                          A:C104
WRITELN9                         E:C10E
WRITE_LCD1                       E:C190
WRITE_LCD2                       A:C180
WRITE_LCD5                       A:C1A0
WRITE_LCD9                       A:C167
WRITE_LCD_STRING                 E:C176
WRITE_LDC_CHR                    E:C1A9
WRITE_LDC_CHR1                   E:C1AB
WRITE_LDC_HEX                    E:C1B1
WRKD_WRK                         E:BDB5
WRKSYM                           E:BD50
WRKTKN                           E:9514
WRK_OPND                         E:BDAA
WRK_VAL                          E:C54D
WRK_WRKD                         E:BDC0
W_CHR                            E:C158
W_CHR1                           E:C15A
W_HEX                            E:C160
W_STRING                         E:C125
ZERRES                           A:AE9F
a_equals_message                 A:B867
add_assembler_library_functions  A:ACBB
add_assembler_library_functions  A:AD05
add_assembler_library_functions  A:ACC3
add_assembler_library_functions  A:ACD3
add_pascal_library_functions     A:C8FB
add_pascal_library_functions_do  A:C954
add_pascal_library_functions_lo  A:C903
add_pascal_library_functions_na  A:C913
asm_do_asc                       E:A676
asm_do_asc_loop                  A:A683
asm_do_asc_next                  A:A68C
asm_do_asc_ok                    A:A681
asm_do_assert                    A:A611
asm_do_assert_failed             A:A620
asm_do_blk                       A:A748
asm_do_blk_done                  A:A765
asm_do_blk_loop                  A:A758
asm_do_constant_expected         A:A6BD
asm_do_constant_expectedJ        A:A625
asm_do_constant_expectedJ2       A:A77E
asm_do_dfb                       A:A6CB
asm_do_dfb_multiple              A:A6D9
asm_do_dfb_multiple_done         A:A6F7
asm_do_dfb_multiple_loop         A:A6E6
asm_do_dfb_too_big               A:A6F8
asm_do_dfw                       A:A70B
asm_do_dfw_multiple              A:A719
asm_do_dfw_multiple_done         A:A738
asm_do_dfw_multiple_loop         A:A727
asm_do_equ                       A:A69A
asm_do_equ_have_label            A:A6AB
asm_do_list                      E:A628
asm_do_list1                     A:A666
asm_do_list_first_pass           A:A675
asm_do_list_no_operand           A:A648
asm_do_list_not                  A:A662
asm_do_list_ok                   A:A64C
asm_do_nolist                    A:A637
asm_do_nolist_ok                 A:A642
asm_do_org                       A:A6B7
asm_do_org_ok                    A:A6C2
asm_do_reserve                   A:A766
asm_do_string                    A:A691
asm_do_sym                       A:A781
asm_do_sym_done                  A:A79A
asm_emit_one_byte                A:A6FD
asm_emit_two_bytes               A:A739
ass_absolute_another_value       A:9D06
ass_added_symbol                 A:9B43
ass_already_emitted              A:A0D0
ass_bad_identifier               A:9AFE
ass_bad_indirect                 A:9C6D
ass_bad_zp_indirect_indexed      A:9CA7
ass_branch_backwards             A:A11B
ass_branch_ok                    A:A11F
ass_branch_out_of_range          A:A125
ass_check_label_changed          A:9BAD
ass_check_no_more_tokens         A:9E01
ass_check_no_more_tokens_ok      A:9E0C
ass_check_we_have_x_or_y         A:9CAE
ass_check_we_have_x_or_y_ok      A:9CCA
ass_current_label                S:0083
ass_done                         A:9DBE
ass_done1                        A:9DE0
ass_done_jump                    A:9AC0
ass_done_message                 A:9DE3
ass_done_second_pass             A:9DC8
ass_emit                         A:A0AD
ass_emit1                        A:A0E8
ass_emit2                        A:A0C1
ass_emit3                        A:A0E2
ass_emit4                        A:A0DB
ass_emit_absolute                A:A154
ass_emit_bytes                   S:0077
ass_emit_immediate               A:A141
ass_emit_immediate_too_high      A:A14F
ass_emit_zero_page               A:A12E
ass_emit_zero_page_too_high      A:A13C
ass_error                        A:A0EB
ass_error1                       A:A0F2
ass_evaluate_operator            A:A086
ass_expression_apply_operator    A:A045
ass_expression_apply_operator_b  A:A081
ass_expression_cannot_be_unary   A:9FF1
ass_expression_found_value       A:9F7F
ass_expression_loop              A:9F32
ass_expression_loop1             A:9F63
ass_expression_loop1a            A:9F4C
ass_expression_loop2             A:9F90
ass_expression_loop3             A:9F9F
ass_expression_loop3a            A:9FAE
ass_expression_loop3b            A:9FA3
ass_expression_loop3c            A:9FB3
ass_expression_loop4             A:9FB9
ass_expression_loop6             A:A017
ass_expression_loop7             A:A000
ass_expression_loopJ             A:9FB6
ass_expression_loop_initial      A:9F35
ass_expression_not_small_string  A:9F5E
ass_expression_number            A:9F39
ass_expression_unary             A:A06E
ass_finish_line                  A:9AB5
ass_finish_lineJ                 A:9BD3
ass_fixup_bbr_branch             A:A0F5
ass_fixup_branch                 A:A102
ass_get_value                    A:9F18
ass_identifier                   A:9B03
ass_identifier_operand           A:9C11
ass_illegal_opcode               A:9B64
ass_immediate                    A:9BF5
ass_indexed                      A:9CDF
ass_indexed_x                    A:9CFD
ass_indirect                     A:9C08
ass_indirect_with_bracket        A:9C72
ass_label_not_found_yet          A:9F77
ass_line                         A:9AC3
ass_line1                        A:9AD2
ass_lookup_existing_label        A:9B2D
ass_lookup_loop                  A:A089
ass_lookup_save_address          A:9B37
ass_not_colon                    A:9B55
ass_not_colon2                   A:9B5C
ass_not_unary_greater_than       A:9FDB
ass_not_unary_less_than          A:9FD1
ass_not_unary_minus              A:9FC7
ass_not_x_or_y                   A:9CAC
ass_opcode                       A:9B6C
ass_opcode2                      A:9BC2
ass_opcode_found                 A:A0A7
ass_operand                      A:9BD6
ass_operand_value                A:9C32
ass_string                       A:9BE8
ass_symbol_address_changed       A:9BBD
ass_value_done                   A:9CD6
ass_value_not_indirect           A:9CCC
ass_value_not_indirectJ          A:9C6A
ass_zp_indirect_indexed          A:9C86
assembler_library_functions_tab  A:A7FB
assertion_failed_message         A:9965
assign_bad_identifier            A:C0C2
atoi                             A:CCC2
atoi_error                       E:CD31
atoi_loop                        E:CCCB
atoi_more                        E:CCDC
atoi_not_running                 E:CD37
atoi_positive                    A:CCDA
bad_command                      A:8248
bad_delimiter_message            A:86B1
bad_flag_message                 A:881B
bcd_output_digit                 A:93B0
bcd_positive                     A:939E
bcd_result                       S:0060
bcd_skip_zeroes                  A:93A5
bcd_table                        E:9332
bcd_unpack                       A:931F
bcd_work                         S:005C
binary_to_decimal                A:93BB
binary_to_decimal_loop           A:93C6
binary_to_decimal_next           A:93EB
break_message                    A:B84C
brk_address                      S:0015
brk_executed                     A:B898
brk_executed1                    A:B916
brk_executed2                    A:B923
brk_executed3                    A:B933
brk_executed4                    A:B94D
brk_executedJ                    A:B95F
brk_resumed                      A:8CC4
bytes_message                    A:92BB
call_a                           S:0010
call_assembler                   A:95C4
call_handler                     A:918A
call_p                           S:0013
call_s                           S:0014
call_x                           S:0011
call_y                           S:0012
cb2_interrupt                    A:B987
character_types_table            E:8006
compile_finished_message         A:9532
cp437_font                       A:D40A
crc16                            E:923D
crc16_loop                       E:9249
crc16_next                       A:9256
crc16_skip                       A:925C
crc_addr                         E:0000
crc_byte                         E:9265
crc_done                         A:9264
crc_helper1                      A:9295
crc_message                      A:9298
crc_num                          E:0003
crc_source                       E:92C3
crc_val                          E:0006
current_line                     S:00A2
delay                            E:9315
delay_1ms                        E:930B
delay_1ms_loop                   A:930E
digitalread                      E:CB20
digitalread_B                    A:CB2F
digitalread_C                    A:CB37
digitalwrite                     E:CAF1
digitalwrite_B                   A:CB02
digitalwrite_C                   A:CB0A
digitalwrite_ONE                 A:CB18
display_in_decimal               E:9392
display_x_characters             A:B0ED
editor_argument_check            A:8B75
editor_argument_check_failed     A:8B87
editor_argument_check_got_argum  A:8B91
editor_argument_check_loop       A:8B77
editor_assemble                  A:8FC6
editor_bad_delimiter             A:86C0
editor_bad_number                A:8546
editor_bad_range                 A:8601
editor_bad_rangeJ                A:869A
editor_check_no_more             A:862E
editor_check_no_more_failed      A:8640
editor_check_no_more_loop        A:8630
editor_check_no_more_ok          A:864A
editor_compile                   A:8F03
editor_debug                     A:8EC3
editor_debug_ok                  A:8ED6
editor_default_range             A:8528
editor_delete                    A:8B92
editor_delete_line_count_done    A:8C00
editor_delete_line_count_loop    A:8BE0
editor_delete_line_count_not_do  A:8BEC
editor_delete_line_count_not_ne  A:8BF8
editor_do_replace                A:8990
editor_do_replace_copy_done      A:89D5
editor_do_replace_smaller        A:89D2
editor_do_the_replace            A:88F6
editor_done_message              A:8E89
editor_easy_replace              A:8903
editor_easy_replace_done         A:8914
editor_easy_replace_loop         A:8907
editor_find                      A:8745
editor_find_bug                  A:8783
editor_find_case_sensitive       A:88B4
editor_find_found_it             A:88D8
editor_find_found_it1            A:88DE
editor_find_get_flags            A:87DD
editor_find_inner_loop           A:889D
editor_find_loop                 A:8899
editor_find_no_match             A:88C2
editor_find_or_replacing         A:8895
editor_find_problem              A:86C4
editor_find_second_delimiter_lo  A:8790
editor_find_skip_this            A:88BE
editor_find_test_character       A:88B5
editor_find_third_delimiter_loo  A:87B7
editor_flags                     S:00BC
editor_flags1                    A:87FD
editor_flags2                    A:8807
editor_flags3                    A:8811
editor_flags_loop                A:87DF
editor_get_delimiter             A:86EE
editor_get_number                A:8550
editor_get_number_done           A:85B8
editor_get_number_end            A:85BC
editor_get_number_none           A:85BA
editor_get_number_not_identifie  A:8592
editor_get_number_ok             A:85A8
editor_get_range                 A:864B
editor_get_range_done            A:8699
editor_get_range_hyphen          A:8681
editor_get_range_number          A:8686
editor_handlers                  A:82D6
editor_help                      A:8509
editor_help_done                 A:8525
editor_help_info                 A:8380
editor_help_loop                 A:8514
editor_info                      E:8EF1
editor_insert                    A:8A04
editor_insert_at_start           A:8A1E
editor_insert_backspace          A:8AB8
editor_insert_backspace_not_at_  A:8AC4
editor_insert_common             A:8A2C
editor_insert_done               A:8ADA
editor_insert_done_with_newline  A:8AEB
editor_insert_loop               A:8A6F
editor_insert_loop1              A:8AA8
editor_insert_no_line_number     A:8A80
editor_insert_not_newline        A:8A9F
editor_jmp                       A:912C
editor_jmp_got_number            A:9136
editor_jmp_number_in_range       A:913D
editor_jsr                       A:90FE
editor_jsr_got_number            A:9108
editor_jsr_got_number_execute    A:9129
editor_jsr_number_in_range       A:910F
editor_line_count_done           A:8FB8
editor_line_count_loop           A:8FA2
editor_line_count_not_newline    A:8FB0
editor_line_number_too_big       A:85E8
editor_list                      A:8751
editor_list_aborted              A:8888
editor_list_check_to_line        A:8944
editor_list_check_to_line_ok     A:8954
editor_list_completely_done      A:898D
editor_list_doing_find           A:8777
editor_list_done                 A:8970
editor_list_doneJ                A:885B
editor_list_fix_target_string    A:8829
editor_list_fixup_loop           A:8831
editor_list_get_on_with_it       A:8844
editor_list_got_from_point       A:878E
editor_list_have_source          A:8855
editor_list_loop                 A:8861
editor_list_loopJ                A:896D
editor_list_no_line_number       A:8932
editor_list_no_line_numberJ      A:885E
editor_list_not_find             A:8841
editor_list_not_finding          A:8925
editor_list_not_newline          A:895C
editor_list_skip_newline         A:8967
editor_load                      A:8A00
editor_memory                    A:8CEA
editor_memory_aborted            A:8D5D
editor_memory_ascii              A:8D68
editor_memory_done               A:8D5A
editor_memory_loop               A:8D04
editor_memory_loop1              A:8D25
editor_memory_loop2              A:8D37
editor_memory_loop3              A:8D4D
editor_memory_not_control        A:8D70
editor_memory_not_high           A:8D76
editor_memory_show_ascii         A:8D63
editor_memory_show_dot           A:8D74
editor_newline_processing        A:893A
editor_no_closing_delimiter      A:871C
editor_no_closing_delimiterJ     A:878B
editor_no_closing_delimiter_mes  A:8706
editor_no_find_string            A:8737
editor_no_lines                  A:8B1E
editor_not_assembler             A:8ECC
editor_poke                      A:9041
editor_poke_another              A:90A8
editor_poke_bad_token            A:9062
editor_poke_failed               A:90DB
editor_poke_failed_message       A:90BA
editor_poke_got_all_numbers      A:907D
editor_poke_got_enough           A:908D
editor_poke_got_number           A:9065
editor_poke_loop                 A:904B
editor_poke_message              A:9019
editor_poke_not_first            A:9074
editor_poke_to_message           A:90D5
editor_poking_loop               A:90A0
editor_recover                   A:8E74
editor_recover_not_needed        A:8E93
editor_replace                   A:873D
editor_replacement_loop          A:8897
editor_resume                    A:8FEB
editor_resume_ok                 A:8FFE
editor_run                       A:8F17
editor_save                      A:874B
editor_syntax                    A:8F0D
editor_test                      A:8CD8
editor_too_full                  A:8B06
editor_too_full_loop             A:8B0D
editor_trace                     A:8EDF
error1                           A:9A02
error_find_next                  A:99F9
error_found                      A:9A23
error_loop                       A:99F5
error_next                       A:99F4
error_not_found                  A:9A0B
error_not_found_message          A:9A30
errors_table                     A:9603
ex_input_aborted                 A:B776
execution_aborted_message        A:B762
execution_address_table          E:AF7D
exp_abs_val                      A:AE6F
exp_abs_val2                     A:AE87
exp_abs_val2_done                A:AE9E
exp_abs_val_done                 A:AE86
exp_add                          A:AD06
exp_bitwise_and                  A:ADA9
exp_bitwise_or                   A:AD94
exp_bitwise_xor                  A:ADBE
exp_divide                       A:AF0D
exp_divide_loop                  A:AF2A
exp_divide_not_zero              A:AF1D
exp_divide_subtraction_negative  A:AF52
exp_divide_subtraction_positive  A:AF53
exp_done                         A:A028
exp_done_error                   A:A02E
exp_done_ok                      A:A033
exp_eql                          A:AD40
exp_evaluation_function          S:007F
exp_false                        A:AD39
exp_falseJ                       A:ADD6
exp_find_sign                    A:AEA8
exp_fix_sign                     A:AEC0
exp_fix_sign_done                A:AED3
exp_geq                          A:AD8D
exp_get_operator                 A:9E83
exp_get_operator_ok              A:9E8C
exp_get_precedence               A:9EF1
exp_get_precedence_found         A:9F07
exp_get_precedence_loop          A:9EF3
exp_greater_than                 A:AD6F
exp_high_byte                    A:AE66
exp_leq                          A:AD7E
exp_less_than                    A:AD68
exp_logical_and                  A:ADE8
exp_logical_or                   A:ADD9
exp_low_byte                     A:AE61
exp_modulo                       A:AF6D
exp_multiply                     A:AED4
exp_multiply_loop                A:AED9
exp_multiply_no_add              A:AEFA
exp_negate                       A:AE2C
exp_negate_val                   A:AE73
exp_negate_val2                  A:AE8B
exp_neq                          A:AD54
exp_no_operators_left            A:A01F
exp_not                          A:AE3F
exp_operator                     S:007D
exp_operator_precedence          S:007E
exp_operator_stack_count         S:007C
exp_pop_operator                 A:9E73
exp_pop_operator_ok              A:9E7C
exp_pop_value                    E:9E38
exp_pop_value_ok                 A:9E41
exp_precedence_table             A:9E91
exp_precedence_table_end         E:9EF1
exp_push_operator                A:9E61
exp_push_operator_ok             A:9E6C
exp_push_value                   E:9E0D
exp_push_value_memory_full       A:9E13
exp_push_value_not_full          A:9E27
exp_push_value_ok                A:9E18
exp_shift_left                   A:ADFA
exp_shift_left_done              A:AE12
exp_shift_left_loop              A:AE09
exp_shift_right                  A:AE13
exp_shift_right_done             A:AE2B
exp_shift_right_loop             A:AE22
exp_subtract                     A:AD1A
exp_true                         A:AD30
exp_trueJ                        A:ADD3
exp_unary_minus                  A:AE4D
exp_unary_ok                     S:0081
exp_value_stack                  S:0079
exp_value_stack_count            S:007B
find_count                       S:00B9
find_delimiter                   S:00B4
find_flags                       S:00BD
find_from                        S:00B0
find_len                         S:00B3
find_line                        A:8C73
find_line_eof                    A:8CA6
find_line_loop                   A:8C81
find_line_next                   A:8C90
find_line_same_line              A:8C9E
find_pos                         S:00B2
find_source_end                  A:8CA7
find_source_end_done             E:8CC3
find_source_end_loop             E:8CAF
find_source_end_wrap             E:8CBD
find_string_too_long             A:86E8
find_string_too_longJ            A:8788
find_string_too_long_message     A:86CA
find_to                          S:00B1
found_message                    A:869D
found_this_line                  S:00BB
from_line                        S:009E
from_msg                         A:86A5
gc_alpha_alpha_only              A:CC53
gc_alpha_done                    A:CC4F
gc_alpha_loop                    A:CC36
gc_alpha_ok                      A:CC3E
gc_ampersand                     A:D048
gc_assembler_comment_find_end    A:CE57
gc_assembler_comment_keep_looki  A:CE69
gc_assembler_comment_not_eof     A:CE62
gc_assign                        A:CFE4
gc_backslash_tokens              A:CE71
gc_backslash_tokens_end          E:CE87
gc_backslash_tokens_length       E:0016
gc_bang                          A:D07B
gc_bar                           A:D059
gc_binary_literal                A:CFBB
gc_binary_loop                   A:CFC3
gc_colon                         A:CFD9
gc_comment_found_end             A:CDF0
gc_comment_keep_looking          A:CDE8
gc_comment_not_eof               A:CDD0
gc_comment_not_newline           A:CDD9
gc_directive_list                A:CE38
gc_directive_nolist              A:CE45
gc_directive_pcodes              A:CE3F
gc_directive_symbols             A:CE00
gc_directive_symbols_ok          A:CE0C
gc_directive_symbols_too_late    A:CE33
gc_dollar                        A:CF55
gc_done                          A:CC19
gc_equality                      A:D075
gc_equals                        A:D06A
gc_fix_hex                       A:CF19
gc_fix_hex_not_a_to_f            A:CF22
gc_geq                           A:D01D
gc_greater_than                  A:D00D
gc_hex_done                      A:CFA5
gc_hex_literal                   A:CF61
gc_hex_loop                      A:CF6A
gc_hex_too_big                   A:CFAA
gc_inequality                    A:D086
gc_leq                           A:CFFE
gc_less_than                     A:CFEA
gc_lh_brace                      A:CD94
gc_lh_paren                      A:CD98
gc_logical_and                   A:D053
gc_logical_or                    A:D064
gc_minus                         A:D027
gc_neq                           A:D003
gc_newline                       A:CBF6
gc_newline1                      A:CC03
gc_newline_assembling            A:CC10
gc_not_alpha                     A:CC5C
gc_not_digit                     A:CC68
gc_not_space                     A:CC31
gc_pascal_comment                A:CDA6
gc_pascal_comment_find_end       A:CDC5
gc_percent                       A:CFAF
gc_plus                          A:D029
gc_quote                         A:CE87
gc_quote_backslash_loop          A:CEF0
gc_quote_bad                     A:CE9E
gc_quote_bad_string              A:CEFB
gc_quote_copied_value            A:CEC3
gc_quote_done                    A:CECC
gc_quote_found_backslash_charac  A:CF04
gc_quote_hex_character           A:CF26
gc_quote_hex_character_done      A:CF00
gc_quote_hex_character_one_only  A:CF52
gc_quote_long_string             A:CEB8
gc_quote_loop                    A:CE95
gc_quote_loop_not_end_of_line    A:CEA3
gc_quote_not_backslash           A:CF08
gc_quote_not_finished            A:CEDE
gc_quote_too_long                A:CF14
gc_semicolon                     A:CE4E
gc_shift_left                    A:D008
gc_shift_right                   A:D022
gc_single_byte_already_known     A:CC15
gc_single_byte_already_knownJ    A:CD91
gc_single_byte_already_knownJ2   A:D01A
gc_single_byte_token             A:CC17
gc_single_byte_tokenJ            A:CD8E
gc_skip_spaces                   A:CBE1
gen_random                       A:921A
gen_random1                      A:923C
get_token                        A:CBD3
get_token_loop                   A:CBD7
gtoken_directive_table           A:CD81
gtoken_table                     A:CD50
handlerLookup                    A:914A
handler_find_length              A:9152
handler_found_directive          A:9178
handler_found_length             A:915B
handler_loop                     A:914C
handler_next                     A:915F
handler_same_length              A:916F
handlers_done                    A:9188
hardware_init                    A:CB6A
hardware_work                    S:008C
i2c_begin_transmission           A:D21E
i2c_begin_transmission_loop      A:D222
i2c_delay                        A:D1FF
i2c_end_transmission             A:D2E1
i2c_init                         A:D1F4
i2c_read                         A:D28B
i2c_read_ack_or_nak              A:D2C8
i2c_read_ack_or_nak_wait         A:D2CD
i2c_read_done                    A:D2DF
i2c_read_loop                    A:D294
i2c_read_nak                     A:D2C3
i2c_read_next                    A:D2AD
i2c_read_zero                    A:D2A9
i2c_receive                      A:D323
i2c_receive_done                 A:D346
i2c_receive_fail                 A:D34B
i2c_receive_loop                 A:D331
i2c_send                         A:D2FA
i2c_send_done                    A:D319
i2c_send_fail                    A:D31E
i2c_send_loop                    A:D302
i2c_toggle_clock                 A:D203
i2c_toggle_clock_wait            A:D20B
i2c_write                        A:D245
i2c_write_clock                  A:D25F
i2c_write_clock_wait             A:D26F
i2c_write_got_ack                A:D289
i2c_write_loop                   A:D248
i2c_write_lost_arbitration       A:D287
i2c_write_one                    A:D254
id_equals_message                A:B88F
info_message                     A:A79B
insert_limit                     S:00A4
introduction                     A:DC0A
irq                              A:B962
irq1                             A:B96F
irq_done                         A:B9E7
is_xxx_fail                      A:8106
is_xxx_pass                      A:810A
isalnum                          E:8162
isalpha                          E:8126
isbin                            A:8176
isbinary                         E:816E
iscntrl                          E:8156
isdigit                          E:8132
islower                          E:811A
isspace                          E:814A
isupper                          E:810E
isxdigit                         E:813E
lcd_clear_display                A:BB2B
lcd_clear_enable                 A:BA87
lcd_data_nibble                  A:BAEA
lcd_get_address                  A:BAB7
lcd_home                         A:BB3B
lcd_initialise                   A:B9EA
lcd_instruction                  A:BAD7
lcd_prepare_to_read_register     A:BA43
lcd_prepare_to_write_data        A:BA56
lcd_prepare_to_write_instructio  A:BA6B
lcd_print                        A:BB4C
lcd_print_char                   A:BAF9
lcd_print_char_newline           A:BB1A
lcd_print_char_ok                A:BB1A
lcd_print_char_on_2nd_line       A:BB13
lcd_print_done                   A:BB56
lcd_print_message                A:BB43
lcd_print_not_newline            A:BB04
lcd_read_instruction_nibble      A:BA90
lcd_second_line                  A:BB33
lcd_set_enable                   A:BA7E
lcd_wait                         A:BA9C
lcd_wait_timeout                 A:BAB3
lcd_work                         S:0086
lcd_write_instruction_nibble     A:BACB
lcdbusy                          A:BAA4
library_function_call            A:C955
library_function_call_1          A:C991
library_function_call_2          A:C962
library_function_call_3          A:C98C
library_function_call_5          A:C994
line_number_lt_1000              A:8C4E
line_number_output_spaces        A:8C5D
lines_deleted_message            A:8C2A
list_symbols                     E:A7A6
list_symbols_check               E:A7C0
list_symbols_done                E:A7FA
list_symbols_line                E:A7CF
list_symbols_name                E:A7E9
list_symbols_next                E:A7B5
load_message                     A:89DE
m_alnum                          E:0080
m_alpha                          E:0004
m_cntrl                          E:0040
m_digit                          E:0008
m_lower                          E:0002
m_space                          E:0020
m_upper                          E:0001
m_xdigit                         E:0010
main_loop                        A:828C
main_loop_not_run                A:82B8
main_prompt                      A:8272
main_start                       A:826B
maths_work                       S:008D
mem_move_dest                    S:00A8
mem_move_len                     S:00AA
mem_move_src                     S:00A6
memory_filled_up                 A:8B4C
memory_full                      A:8B31
movedown                         A:817A
movedown1                        A:819D
movedown2                        A:8190
movedown_done                    A:819C
movedown_loop                    A:8186
moveup                           A:81A6
moveup3                          A:81D8
moveup_done                      A:81E4
moveup_loop                      A:81CE
moveup_next                      E:81E5
negate_token_value               A:CD3C
no_break_message                 A:8FCC
no_find_message                  A:8722
no_valid_compile_message         A:9568
not_assembler_message            A:8E9D
notbin                           A:8178
number_bad_range_message         A:85F2
number_expected_message          A:8535
number_too_large_message         A:85C9
opcode_lookup                    A:9D15
opcode_lookup_correct_length     A:9D40
opcode_lookup_correct_operand    A:9D6E
opcode_lookup_loop               A:9D27
opcode_lookup_loop_done          A:9D85
opcode_lookup_loop_unknown       A:9DBA
opcode_lookup_next_table         A:9D31
opcode_lookup_no_handler         A:9D84
opcode_lookup_ok                 A:9DBD
p_equals_message                 A:B87F
partial_handler_Lookup           A:918D
partial_handler_done             A:91D1
partial_handler_found_directive  A:91BD
partial_handler_next             A:91A6
partial_handler_next_found_item  A:91AD
partial_handler_next_item        A:918F
partial_handler_next_loop        A:9197
partial_handler_skipped_string   A:91C4
pas_gc_identifier                A:D18B
pas_gc_loop                      A:D193
pas_gc_more                      A:D19C
pas_gc_no_match                  E:D1C4
pas_get_token                    A:D181
pas_get_token_eof                A:D18A
pascal_library_functions_table   A:C85B
pcodes_ended_message             A:951F
pin_number_to_mask               E:CAAF
pin_number_to_mask_done          A:CABD
pin_number_to_mask_loop          A:CAB5
pinmode                          A:CAC2
pinmode_B                        A:CAD3
pinmode_C                        A:CADB
pinmode_OUTPUT                   A:CAE9
prchar_not_control               A:94D8
print                            A:8226
print_done                       A:823E
print_loop                       A:8234
prompt                           A:8245
random                           S:0009
recover_done                     A:8E62
recover_not_needed               A:8E68
rep_diff                         S:00B7
rep_from                         S:00B5
rep_to                           S:00B6
run_assembler                    A:95B7
running_message                  A:B01B
s_equals_message                 A:B887
serial_available                 E:CB64
serial_in_byte                   S:008A
serial_in_byte_received          S:008B
serial_in_loop                   A:B993
serial_out_bit                   S:0089
serial_out_byte                  S:0087
serial_print                     A:CBC8
serial_print_done                A:CBD2
serial_print_message             A:CBC2
serial_send_count_bits           A:B9D8
show_current_line                A:9A40
show_current_line_done           A:9A85
show_current_line_loop           A:9A62
show_current_line_loop_print_on  A:9A7A
show_current_line_number         A:8C35
show_current_line_number_done    A:8C69
show_source_end                  A:8F48
show_source_lines                A:8F92
show_source_start                A:8F70
show_symbol_table_end            A:8F23
show_symbols                     S:0082
source_ended_message             A:8F35
source_length_message            A:92AB
source_line_count                A:8F82
source_starts_message            A:8F5D
spi_init                         A:D350
spi_init2                        A:D36E
spi_init3                        A:D380
spi_init_clock_high              A:D369
spi_init_mosi_low                A:D37B
spi_mode                         S:0068
spi_read_02_done                 A:D3BD
spi_read_13_done                 A:D3E0
spi_send2                        A:D3AE
spi_send3                        A:D3BF
spi_send4                        A:D3D1
spi_send_bit_done                A:D3E2
spi_send_clock_high_low          A:D3A9
spi_send_clock_low_high          A:D3CC
spi_send_clock_pulse_1           A:D39C
spi_send_two_bytes               A:D3FA
spi_send_zero                    A:D397
spi_ss_high                      A:D3F2
spi_ss_low                       A:D3EA
spi_transfer                     A:D386
spi_transfer_loop                A:D38B
stack_message                    A:B957
str_compare                      A:81F0
str_compare_done                 A:81FE
str_ic_compare                   A:8201
str_ic_compare_done              A:8223
str_ic_compare_fixed_dest        A:821E
str_ic_compare_fixed_srce        A:8210
str_work                         S:0085
symbol_table_ended_message       A:9550
symbol_table_message             A:8D8D
system_flags                     S:00BE
this_line                        S:00AC
this_line_addr                   S:00AE
timer1_interrupt                 A:B9B8
to_line                          S:00A0
to_msg                           A:86AC
token_address                    S:0090
token_digit                      S:009B
token_length                     S:0092
token_line                       A:CC73
token_line1                      A:CC79
token_line_done                  A:CCC1
token_line_listing               A:CC94
token_line_loop                  A:CCAC
token_line_loop1                 A:CCBC
token_line_start                 S:009C
token_sign                       S:0097
token_start                      S:008E
token_type                       S:0093
token_value                      S:0094
token_work                       S:0098
too_much_on_line                 A:860B
typing_latency                   S:000D
write_char                       A:CB9D
write_char_loop                  A:CBB9
write_function                   S:0017
write_to_lcd                     A:CB48
write_to_serial                  A:CB3D
write_zero                       A:B9D3
wtf_loop                         A:9DA9
x_equals_message                 A:B86F
y_equals_message                 A:B877

Symbols by value:
0000 EMULATOR
0000 OPCODE_LOOKUP_OPCODE_LENGTH
0000 PCODE_LIT
0000 REG
0000 SERIAL_DEBUGGING
0000 SRCE
0000 SYMPRV
0000 VALUE
0000 VIA_FLAG_DISABLE
0000 crc_addr
0001 ASS_OPERAND_ABSOLUTE
0001 EFLAG_SHOW_LINE
0001 FFLAG_IGNORE_CASE
0001 FLAG_COMPILING
0001 LCD_SUPPORT
0001 OPCODE_LOOKUP_OPERAND_TYPE
0001 PCODE_STACK
0001 SPI_SS
0001 USE_CP437_FONT
0001 m_upper
0002 ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
0002 EFLAG_ALLOW_ZERO_FROM
0002 FFLAG_GLOBAL
0002 FLAG_ASSEMBLING
0002 OPCODE_LOOKUP_OPCODE_TABLE
0002 PCODE_NEG
0002 REGB
0002 SERIAL_OUT_MASK
0002 SPI_MOSI
0002 SYMLVL
0002 m_lower
0003 ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
0003 DEST
0003 KEY_ABORT
0003 PCODE_LIB_CALL
0003 REG2
0003 SYMTYP
0003 VALUE2
0003 crc_num
0004 ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
0004 EFLAG_LOAD
0004 FFLAG_QUIET
0004 FLAG_LIST_SOURCE
0004 I2C_SCL
0004 KEY_DEBUG
0004 OPCODE_LOOKUP_HANDLER
0004 PCODE_ADD
0004 SERIAL_DEBUG1_MASK
0004 SPI_MISO
0004 SYMDSP
0004 m_alpha
0005 ASS_OPERAND_ABSOLUTE_INDIRECT
0005 REG2B
0006 ASS_OPERAND_ACCUMULATOR_A
0006 OPCODE_LOOKUP_TABLE_SIZE
0006 PCODE_SUB
0006 REMAIN
0006 SYMARG
0006 SYMSUB
0006 crc_val
0007 ASS_OPERAND_IMMEDIATE
0008 ASS_OPERAND_IMPLIED
0008 BACKSPACE
0008 EFLAG_SAVE
0008 FLAG_VALID_COMPILE
0008 I2C_SDA
0008 PCODE_MUL
0008 SERIAL_DEBUG2_MASK
0008 SPI_SCK
0008 SYMDAT
0008 VIA_FLAG_CB2
0008 m_digit
0009 SYMLEN
0009 random
000A NL
000A PCODE_DIV
000A SYMNAM
000B ASS_OPERAND_ZERO_PAGE
000B PCODE_MOD
000C ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
000C PCODE_ADRNN
000D ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
000D CR
000D typing_latency
000E ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
000E KEY_STOP_TRACE
000E PCODE_ADRAN
000F ASS_OPERAND_ZERO_PAGE_INDIRECT
0010 ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
0010 EFLAG_FIND
0010 FLAG_VALID_ASSEMBLE
0010 PCODE_EQL
0010 SERIAL_SPARE2_MASK
0010 call_a
0010 m_xdigit
0011 ASS_OPERAND_STRING
0011 PCODE_FINISHD
0011 call_x
0012 ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE
0012 PCODE_NEQ
0012 call_y
0013 call_p
0014 KEY_TRACE
0014 PCODE_LSS
0014 call_s
0015 brk_address
0016 PCODE_GEQ
0016 gc_backslash_tokens_length
0017 write_function
0018 PCODE_GTR
0019 LINE_CNT
0019 PCODE_LEQ
001A PCODE_ORR
001B END_EDITOR_INPUT
001B PCODE_AND
001C PCODE_INP
001D LIST
001E PCODE_OUT
001F PCODE_OUTC
0020 EFLAG_REPLACE
0020 FRAME
0020 LCD_RS
0020 MAX_STK
0020 PCODE_EOR
0020 m_space
0021 PCODE_OUH
0022 LEVEL
0022 PCODE_SHL
0022 TOKEN_STRING
0023 PCODE
0023 PCODE_OUS
0023 SERIAL_DELAY2
0024 PCODE_SHR
0025 ACT_PCDA
0025 PCODE_INS
0026 PCODE_INC
0027 DISPL
0027 PCODE_CLL
0027 SINGLE_QUOTE
0028 PCODE_DEC
0029 OFFSET
0029 PCODE_RTN
002A PCODE_MOV
002B OPND
002B PCODE_CLA
002C PCODE_LOD
002E DCODE
002E PCODE_LDA
002F STARTSYM
0030 PCODE_LDI
0030 SERIAL_DELAY1
0031 ENDSYM
0031 T
0032 PCODE_STO
0033 WORKD
0034 PCODE_STA
0035 ERRNO
0036 BSAVE
0036 PCODE_STI
0037 WORK
0038 PCODE_ABSCLL
0039 PRCITM
003A PCODE_XOR
003B BASE
003B PCODE_INT
003C PCODE_JMP
003D DATA
003D PCODE_JMZ
003E PCODE_JM1
003F RUNNING
0040 EFLAG_SUPPRESS_NEWLINE
0040 FLAG_ONLY_ALPHA
0040 FROM
0040 LCD_RW
0040 PCODE_OUTCR
0040 SYMITM
0040 VIA_FLAG_TIMER1
0040 m_cntrl
0041 SYMBOL_ARRAY
0041 TOKEN_ASSIGN
0042 PCODE_LCD_WRITE_NUM
0042 SYNTAX
0043 END_PCD
0043 PCODE_LCD_WRITE_STR
0043 SYMBOL_CONSTANT
0044 PCODE_LCD_WRITE_HEX
0045 PCODE_LAST
0045 PCODE_LCD_WRITE_CHR
0045 TEMP
0045 TOKEN_EQUALITY
0046 SYMBOL_FUNCTION
0047 CALL
0049 DBGFLG
0049 TOKEN_IDENTIFIER
004A DATTYP
004B COUNT1
004C COUNT2
004C TOKEN_SHIFT_LEFT
004D LASTP
004D TOKEN_UNARY_MINUS
004E TOKEN_NUMBER
0050 SYMBOL_PROCEDURE
0051 SYMBOL_LIBRARY_PROCEDURE
0052 RES
0052 SYMBOL_LIBRARY_FUNCTION
0052 TOKEN_SHIFT_RIGHT
0055 TOKEN_NEQ
0056 SYMBOL_VARIABLE
0056 TOKEN_LOW_BYTE
0057 TOKEN_HIGH_BYTE
0058 TOKEN_LOGICAL_AND
0059 SYMBOL_FUNCTION_RETURN
0059 TOKEN_LOGICAL_OR
005A TOKEN_INEQUALITY
005B RMNDR
005C bcd_work
0060 bcd_result
0068 spi_mode
006B ASS_OPERAND
006C OPCODE
006E OPCODE_LEN
006F ASS_EMIT_COUNT
0070 ASS_OPCODE_WORK
0072 ASS_COUNT
0073 ASS_VALUE
0076 ASS_PASS
0077 ass_emit_bytes
0079 exp_value_stack
007B exp_value_stack_count
007C exp_operator_stack_count
007D exp_operator
007E exp_operator_precedence
007F exp_evaluation_function
0080 EFLAG_NO_LINE_NUMBERS
0080 FLAG_BRK_REACHED
0080 LCD_E
0080 TOKEN_LEQ
0080 VIA_FLAG_ENABLE
0080 m_alnum
0081 TOKEN_GEQ
0081 exp_unary_ok
0082 TOKEN_CONST
0082 show_symbols
0083 TOKEN_VAR
0083 ass_current_label
0084 TOKEN_ARRAY
0085 TOKEN_OF
0085 str_work
0086 TOKEN_PROCEDURE
0086 lcd_work
0087 TOKEN_FUNCTION
0087 serial_out_byte
0088 TOKEN_BEGIN
0089 TOKEN_END
0089 serial_out_bit
008A TOKEN_OR
008A serial_in_byte
008B TOKEN_DIV
008B serial_in_byte_received
008C TOKEN_MOD
008C hardware_work
008D TOKEN_AND
008D maths_work
008E TOKEN_SHL
008E token_start
008F TOKEN_SHR
0090 TOKEN_NOT
0090 token_address
0091 TOKEN_MEM
0092 TOKEN_IF
0092 token_length
0093 TOKEN_THEN
0093 token_type
0094 TOKEN_ELSE
0094 token_value
0095 TOKEN_CASE
0096 TOKEN_WHILE
0097 TOKEN_DO
0097 token_sign
0098 TOKEN_REPEAT
0098 token_work
0099 TOKEN_UNTIL
009A TOKEN_FOR
009B TOKEN_TO
009B token_digit
009C TOKEN_DOWNTO
009C token_line_start
009D TOKEN_WRITE
009E TOKEN_READ
009E from_line
009F TOKEN_CALL
00A0 to_line
00A1 TOKEN_CHAR
00A2 TOKEN_MEMC
00A2 current_line
00A4 TOKEN_XOR
00A4 insert_limit
00A6 mem_move_src
00A8 mem_move_dest
00A9 TOKEN_ADDRESS
00AA mem_move_len
00AB TOKEN_CHR
00AC TOKEN_HEX
00AC this_line
00AE this_line_addr
00B0 find_from
00B1 find_to
00B2 find_pos
00B3 find_len
00B4 find_delimiter
00B5 rep_from
00B6 rep_to
00B7 rep_diff
00B9 find_count
00BB found_this_line
00BC editor_flags
00BD find_flags
00BE system_flags
00C0 RUNNING_STACK_TOP
00D0 BIT_INTERVAL
00F1 TOKEN_LCDWRITE
00FE TOKEN_INTEGER
00FF NEW_STK
00FF TOKEN_WRITELN
0100 INBUF_SIZE
0200 INBUF
0300 TEXT_START
12C0 BAUD_RATE
3FFF HIGHEST_RAM
3FFF SYMBOL_TABLE_START
7FF0 SPI_PORT
7FF0 VIA_PORTB
7FF1 I2C_PORT
7FF1 VIA_PORTA
7FF2 SPI_DDR
7FF2 VIA_DDRB
7FF3 I2C_DDR
7FF3 VIA_DDRA
7FF4 VIA_T1C_L
7FF5 VIA_T1C_H
7FFB VIA_ACR
7FFC VIA_PCR
7FFD VIA_IFR
7FFE VIA_IER
8000 START_OF_ROM
8006 character_types_table
8106 is_xxx_fail
810A is_xxx_pass
810E isupper
811A islower
8126 isalpha
8132 isdigit
813E isxdigit
814A isspace
8156 iscntrl
8162 isalnum
816E isbinary
8176 isbin
8178 notbin
817A movedown
8186 movedown_loop
8190 movedown2
819C movedown_done
819D movedown1
81A6 moveup
81CE moveup_loop
81D8 moveup3
81E4 moveup_done
81E5 moveup_next
81F0 str_compare
81FE str_compare_done
8201 str_ic_compare
8210 str_ic_compare_fixed_srce
821E str_ic_compare_fixed_dest
8223 str_ic_compare_done
8226 print
8234 print_loop
823E print_done
8245 prompt
8248 bad_command
826B main_start
8272 main_prompt
828C main_loop
82B8 main_loop_not_run
82D6 editor_handlers
8380 editor_help_info
8509 editor_help
8514 editor_help_loop
8525 editor_help_done
8528 editor_default_range
8535 number_expected_message
8546 editor_bad_number
8550 editor_get_number
8592 editor_get_number_not_identifier
85A8 editor_get_number_ok
85B8 editor_get_number_done
85BA editor_get_number_none
85BC editor_get_number_end
85C9 number_too_large_message
85E8 editor_line_number_too_big
85F2 number_bad_range_message
8601 editor_bad_range
860B too_much_on_line
862E editor_check_no_more
8630 editor_check_no_more_loop
8640 editor_check_no_more_failed
864A editor_check_no_more_ok
864B editor_get_range
8681 editor_get_range_hyphen
8686 editor_get_range_number
8699 editor_get_range_done
869A editor_bad_rangeJ
869D found_message
86A5 from_msg
86AC to_msg
86B1 bad_delimiter_message
86C0 editor_bad_delimiter
86C4 editor_find_problem
86CA find_string_too_long_message
86E8 find_string_too_long
86EE editor_get_delimiter
8706 editor_no_closing_delimiter_message
871C editor_no_closing_delimiter
8722 no_find_message
8737 editor_no_find_string
873D editor_replace
8745 editor_find
874B editor_save
8751 editor_list
8777 editor_list_doing_find
8783 editor_find_bug
8788 find_string_too_longJ
878B editor_no_closing_delimiterJ
878E editor_list_got_from_point
8790 editor_find_second_delimiter_loop
87B7 editor_find_third_delimiter_loop
87DD editor_find_get_flags
87DF editor_flags_loop
87FD editor_flags1
8807 editor_flags2
8811 editor_flags3
881B bad_flag_message
8829 editor_list_fix_target_string
8831 editor_list_fixup_loop
8841 editor_list_not_find
8844 editor_list_get_on_with_it
8855 editor_list_have_source
885B editor_list_doneJ
885E editor_list_no_line_numberJ
8861 editor_list_loop
8888 editor_list_aborted
8895 editor_find_or_replacing
8897 editor_replacement_loop
8899 editor_find_loop
889D editor_find_inner_loop
88B4 editor_find_case_sensitive
88B5 editor_find_test_character
88BE editor_find_skip_this
88C2 editor_find_no_match
88D8 editor_find_found_it
88DE editor_find_found_it1
88F6 editor_do_the_replace
8903 editor_easy_replace
8907 editor_easy_replace_loop
8914 editor_easy_replace_done
8925 editor_list_not_finding
8932 editor_list_no_line_number
893A editor_newline_processing
8944 editor_list_check_to_line
8954 editor_list_check_to_line_ok
895C editor_list_not_newline
8967 editor_list_skip_newline
896D editor_list_loopJ
8970 editor_list_done
898D editor_list_completely_done
8990 editor_do_replace
89D2 editor_do_replace_smaller
89D5 editor_do_replace_copy_done
89DE load_message
8A00 editor_load
8A04 editor_insert
8A1E editor_insert_at_start
8A2C editor_insert_common
8A6F editor_insert_loop
8A80 editor_insert_no_line_number
8A9F editor_insert_not_newline
8AA8 editor_insert_loop1
8AB8 editor_insert_backspace
8AC4 editor_insert_backspace_not_at_start
8ADA editor_insert_done
8AEB editor_insert_done_with_newline
8B06 editor_too_full
8B0D editor_too_full_loop
8B1E editor_no_lines
8B31 memory_full
8B4C memory_filled_up
8B75 editor_argument_check
8B77 editor_argument_check_loop
8B87 editor_argument_check_failed
8B91 editor_argument_check_got_argument
8B92 editor_delete
8BE0 editor_delete_line_count_loop
8BEC editor_delete_line_count_not_done
8BF8 editor_delete_line_count_not_newline
8C00 editor_delete_line_count_done
8C2A lines_deleted_message
8C35 show_current_line_number
8C4E line_number_lt_1000
8C5D line_number_output_spaces
8C69 show_current_line_number_done
8C73 find_line
8C81 find_line_loop
8C90 find_line_next
8C9E find_line_same_line
8CA6 find_line_eof
8CA7 find_source_end
8CAF find_source_end_loop
8CBD find_source_end_wrap
8CC3 find_source_end_done
8CC4 brk_resumed
8CD8 editor_test
8CEA editor_memory
8D04 editor_memory_loop
8D25 editor_memory_loop1
8D37 editor_memory_loop2
8D4D editor_memory_loop3
8D5A editor_memory_done
8D5D editor_memory_aborted
8D63 editor_memory_show_ascii
8D68 editor_memory_ascii
8D70 editor_memory_not_control
8D74 editor_memory_show_dot
8D76 editor_memory_not_high
8D8D symbol_table_message
8DBF ST_SYMTBL_LIST_NEXT
8DCA ST_SYMTBL_LIST_CHECK
8DD9 ST_SYMTBL_LIST_LINE
8E4E ST_SYMTBL_LIST_NAME
8E5F ST_SYMTBL_LIST_DONE
8E62 recover_done
8E68 recover_not_needed
8E74 editor_recover
8E89 editor_done_message
8E93 editor_recover_not_needed
8E9D not_assembler_message
8EC3 editor_debug
8ECC editor_not_assembler
8ED6 editor_debug_ok
8EDF editor_trace
8EF1 editor_info
8F03 editor_compile
8F0D editor_syntax
8F17 editor_run
8F23 show_symbol_table_end
8F35 source_ended_message
8F48 show_source_end
8F5D source_starts_message
8F70 show_source_start
8F82 source_line_count
8F92 show_source_lines
8FA2 editor_line_count_loop
8FB0 editor_line_count_not_newline
8FB8 editor_line_count_done
8FC6 editor_assemble
8FCC no_break_message
8FEB editor_resume
8FFE editor_resume_ok
9019 editor_poke_message
9041 editor_poke
904B editor_poke_loop
9062 editor_poke_bad_token
9065 editor_poke_got_number
9074 editor_poke_not_first
907D editor_poke_got_all_numbers
908D editor_poke_got_enough
90A0 editor_poking_loop
90A8 editor_poke_another
90BA editor_poke_failed_message
90D5 editor_poke_to_message
90DB editor_poke_failed
90FE editor_jsr
9108 editor_jsr_got_number
910F editor_jsr_number_in_range
9129 editor_jsr_got_number_execute
912C editor_jmp
9136 editor_jmp_got_number
913D editor_jmp_number_in_range
914A handlerLookup
914C handler_loop
9152 handler_find_length
915B handler_found_length
915F handler_next
916F handler_same_length
9178 handler_found_directive
9188 handlers_done
918A call_handler
918D partial_handler_Lookup
918F partial_handler_next_item
9197 partial_handler_next_loop
91A6 partial_handler_next
91AD partial_handler_next_found_item_length
91BD partial_handler_found_directive
91C4 partial_handler_skipped_string
91D1 partial_handler_done
91D2 TKNJMP
91DA JMP1
91E2 JMP2
91F7 JMP3
9204 MAKE_UPPER
920E MAKE_UPPER_DONE
9219 MAKE_LOWER_DONE
921A gen_random
923C gen_random1
923D crc16
9249 crc16_loop
9256 crc16_next
925C crc16_skip
9264 crc_done
9265 crc_byte
9295 crc_helper1
9298 crc_message
92AB source_length_message
92BB bytes_message
92C3 crc_source
930B delay_1ms
930E delay_1ms_loop
9315 delay
931F bcd_unpack
9332 bcd_table
9392 display_in_decimal
939E bcd_positive
93A5 bcd_skip_zeroes
93B0 bcd_output_digit
93BB binary_to_decimal
93C6 binary_to_decimal_loop
93EB binary_to_decimal_next
9409 NOSCE
941A INIT
9426 INIT_SECOND_PASS
9467 INIT9
9468 CROUT
946D COMSTL
9479 COMS9
947A COMS8
947D DISHX
9483 DISPAD
949E DISPAD2
949F PSHWRK
94B1 PSH9
94B2 PULWRK
94C5 PRCHAR
94D8 prchar_not_control
94DD PRBYTE
94E6 PRHEX
94E8 PRHEXZ
94F0 PRHEX1
94F3 PUTSP
94F7 PT
94FF PT6
9509 TKNWRK
9514 WRKTKN
951F pcodes_ended_message
9532 compile_finished_message
9550 symbol_table_ended_message
9568 no_valid_compile_message
9592 PRBYTECR
9598 CHK_VAL
95AA CHK_VAL9
95AB CHK_RUN
95B7 run_assembler
95C4 call_assembler
95CE GETLN1
95CE GET_LINE
95D0 GET1
95ED GET3
95F3 GETLN_OVERFLOW
95F6 COUT
9600 COUT_CALL
9603 errors_table
9965 assertion_failed_message
999F ERRLIT
99AB ERROR
99B4 ERR7
99BE ERR1
99D2 ERR3
99E2 ERR5
99E8 ERR6
99F4 error_next
99F5 error_loop
99F9 error_find_next
9A02 error1
9A0B error_not_found
9A23 error_found
9A30 error_not_found_message
9A40 show_current_line
9A62 show_current_line_loop
9A7A show_current_line_loop_print_one_character
9A85 show_current_line_done
9A89 ASSEMBLE
9A96 ASSEMBLE_SECOND_PASS
9A9B ASSEMBLE_PASS
9AB5 ass_finish_line
9AC0 ass_done_jump
9AC3 ass_line
9AD2 ass_line1
9AFE ass_bad_identifier
9B03 ass_identifier
9B2D ass_lookup_existing_label
9B37 ass_lookup_save_address
9B43 ass_added_symbol
9B55 ass_not_colon
9B5C ass_not_colon2
9B64 ass_illegal_opcode
9B6C ass_opcode
9BAD ass_check_label_changed
9BBD ass_symbol_address_changed
9BC2 ass_opcode2
9BD3 ass_finish_lineJ
9BD6 ass_operand
9BE8 ass_string
9BF5 ass_immediate
9C08 ass_indirect
9C11 ass_identifier_operand
9C32 ass_operand_value
9C6A ass_value_not_indirectJ
9C6D ass_bad_indirect
9C72 ass_indirect_with_bracket
9C86 ass_zp_indirect_indexed
9CA7 ass_bad_zp_indirect_indexed
9CAC ass_not_x_or_y
9CAE ass_check_we_have_x_or_y
9CCA ass_check_we_have_x_or_y_ok
9CCC ass_value_not_indirect
9CD6 ass_value_done
9CDF ass_indexed
9CFD ass_indexed_x
9D06 ass_absolute_another_value
9D15 opcode_lookup
9D27 opcode_lookup_loop
9D31 opcode_lookup_next_table
9D40 opcode_lookup_correct_length
9D6E opcode_lookup_correct_operand
9D84 opcode_lookup_no_handler
9D85 opcode_lookup_loop_done
9DA9 wtf_loop
9DBA opcode_lookup_loop_unknown
9DBD opcode_lookup_ok
9DBE ass_done
9DC8 ass_done_second_pass
9DE0 ass_done1
9DE3 ass_done_message
9E01 ass_check_no_more_tokens
9E0C ass_check_no_more_tokens_ok
9E0D exp_push_value
9E13 exp_push_value_memory_full
9E18 exp_push_value_ok
9E27 exp_push_value_not_full
9E38 exp_pop_value
9E41 exp_pop_value_ok
9E61 exp_push_operator
9E6C exp_push_operator_ok
9E73 exp_pop_operator
9E7C exp_pop_operator_ok
9E83 exp_get_operator
9E8C exp_get_operator_ok
9E91 exp_precedence_table
9EF1 exp_get_precedence
9EF1 exp_precedence_table_end
9EF3 exp_get_precedence_loop
9F07 exp_get_precedence_found
9F18 ass_get_value
9F32 ass_expression_loop
9F35 ass_expression_loop_initial
9F39 ass_expression_number
9F4C ass_expression_loop1a
9F5E ass_expression_not_small_string
9F63 ass_expression_loop1
9F77 ass_label_not_found_yet
9F7F ass_expression_found_value
9F90 ass_expression_loop2
9F9F ass_expression_loop3
9FA3 ass_expression_loop3b
9FAE ass_expression_loop3a
9FB3 ass_expression_loop3c
9FB6 ass_expression_loopJ
9FB9 ass_expression_loop4
9FC7 ass_not_unary_minus
9FD1 ass_not_unary_less_than
9FDB ass_not_unary_greater_than
9FF1 ass_expression_cannot_be_unary
A000 ass_expression_loop7
A017 ass_expression_loop6
A01F exp_no_operators_left
A028 exp_done
A02E exp_done_error
A033 exp_done_ok
A045 ass_expression_apply_operator
A06E ass_expression_unary
A081 ass_expression_apply_operator_bug
A086 ass_evaluate_operator
A089 ass_lookup_loop
A0A7 ass_opcode_found
A0AD ass_emit
A0C1 ass_emit2
A0D0 ass_already_emitted
A0DB ass_emit4
A0E2 ass_emit3
A0E8 ass_emit1
A0EB ass_error
A0F2 ass_error1
A0F5 ass_fixup_bbr_branch
A102 ass_fixup_branch
A11B ass_branch_backwards
A11F ass_branch_ok
A125 ass_branch_out_of_range
A12E ass_emit_zero_page
A13C ass_emit_zero_page_too_high
A141 ass_emit_immediate
A14F ass_emit_immediate_too_high
A154 ass_emit_absolute
A15F OPCODE_LOOKUP_TABLE
A202 DIRECTIVES
A275 OPCODE_4_CHAR_BRANCH
A2C6 OPCODE_3_CHAR_BRANCH
A2EB OPCODE_3_CHAR_IMPLIED
A368 OPCODE_4_CHAR_ZERO_PAGE
A3B9 OPCODE_ASS_OPERAND_ABSOLUTE
A422 OPCODE_ASS_OPERAND_ABSOLUTE_TOKENISED
A425 OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
A42A OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
A46F OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X_TOKENISED
A472 OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
A497 OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y_TOKENISED
A49A OPCODE_ASS_OPERAND_ACCUMULATOR_A
A4B3 OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT
A4B8 OPCODE_ASS_OPERAND_IMMEDIATE
A4E9 OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED
A4EC OPCODE_ASS_OPERAND_ZERO_PAGE
A54D OPCODE_ASS_OPERAND_ZERO_PAGE_TOKENISED
A550 OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
A571 OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT_TOKENISED
A574 OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
A5BD OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X_TOKENISED
A5C0 OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
A5C9 OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT
A5EA OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_TOKENISED
A5ED OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
A60E OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y_TOKENISED
A611 asm_do_assert
A620 asm_do_assert_failed
A625 asm_do_constant_expectedJ
A628 asm_do_list
A637 asm_do_nolist
A642 asm_do_nolist_ok
A648 asm_do_list_no_operand
A64C asm_do_list_ok
A662 asm_do_list_not
A666 asm_do_list1
A675 asm_do_list_first_pass
A676 asm_do_asc
A681 asm_do_asc_ok
A683 asm_do_asc_loop
A68C asm_do_asc_next
A691 asm_do_string
A69A asm_do_equ
A6AB asm_do_equ_have_label
A6B7 asm_do_org
A6BD asm_do_constant_expected
A6C2 asm_do_org_ok
A6CB asm_do_dfb
A6D9 asm_do_dfb_multiple
A6E6 asm_do_dfb_multiple_loop
A6F7 asm_do_dfb_multiple_done
A6F8 asm_do_dfb_too_big
A6FD asm_emit_one_byte
A70B asm_do_dfw
A719 asm_do_dfw_multiple
A727 asm_do_dfw_multiple_loop
A738 asm_do_dfw_multiple_done
A739 asm_emit_two_bytes
A748 asm_do_blk
A758 asm_do_blk_loop
A765 asm_do_blk_done
A766 asm_do_reserve
A77E asm_do_constant_expectedJ2
A781 asm_do_sym
A79A asm_do_sym_done
A79B info_message
A7A6 list_symbols
A7B5 list_symbols_next
A7C0 list_symbols_check
A7CF list_symbols_line
A7E9 list_symbols_name
A7FA list_symbols_done
A7FB assembler_library_functions_table
ACBB add_assembler_library_functions
ACC3 add_assembler_library_functions_loop
ACD3 add_assembler_library_functions_name_loop
AD05 add_assembler_library_functions_done
AD06 exp_add
AD1A exp_subtract
AD30 exp_true
AD39 exp_false
AD40 exp_eql
AD54 exp_neq
AD68 exp_less_than
AD6F exp_greater_than
AD7E exp_leq
AD8D exp_geq
AD94 exp_bitwise_or
ADA9 exp_bitwise_and
ADBE exp_bitwise_xor
ADD3 exp_trueJ
ADD6 exp_falseJ
ADD9 exp_logical_or
ADE8 exp_logical_and
ADFA exp_shift_left
AE09 exp_shift_left_loop
AE12 exp_shift_left_done
AE13 exp_shift_right
AE22 exp_shift_right_loop
AE2B exp_shift_right_done
AE2C exp_negate
AE3F exp_not
AE4D exp_unary_minus
AE61 exp_low_byte
AE66 exp_high_byte
AE6F exp_abs_val
AE73 exp_negate_val
AE86 exp_abs_val_done
AE87 exp_abs_val2
AE8B exp_negate_val2
AE9E exp_abs_val2_done
AE9F ZERRES
AEA8 exp_find_sign
AEC0 exp_fix_sign
AED3 exp_fix_sign_done
AED4 exp_multiply
AED9 exp_multiply_loop
AEFA exp_multiply_no_add
AF0D exp_divide
AF1D exp_divide_not_zero
AF2A exp_divide_loop
AF52 exp_divide_subtraction_negative
AF53 exp_divide_subtraction_positive
AF6D exp_modulo
AF7D execution_address_table
B009 DM1
B012 DM2
B01B running_message
B024 DB11
B024 DEBUG
B08C DEBUG_DONE
B08D INTERP
B0B3 DM5
B0C8 DM6
B0D3 DM7
B0ED display_x_characters
B0F4 DIS5
B0FE DIS5_A
B10B BELL1
B115 RUNERR
B129 EX_FINISHD
B140 FIN_MSG
B15F CHK_KBD
B16B CHK_NOTN
B179 CHK_NOTT
B187 CHK_NOTD
B189 EX_OUTCR
B18F LOWLIT
B195 LOWLIT1
B19B MAINP
B19E MAIN
B1A5 MAIN_2
B1B0 MAIN_NOT_ABORT
B1B3 MAIN_OK
B1CD MAIN_1
B1DC EX_INVINS
B1E0 NOTIM1
B1ED GETADR
B1F7 GET2
B218 GETADR1
B233 GET1_A
B234 PULTOP
B24F PUL_END
B256 PULBOTH
B259 PULTOP2
B274 PUL2_END
B27B PSHTOP
B286 PSH1
B297 GETLIT
B2AD GET_END
B2AE EX_LIT
B2BD LIT1
B2C0 EX_NEG
B2C9 EX_ADD
B2D2 EX_SUB
B2DE EX_MUL
B2E7 EX_GETKEY
B2EE EX_MOD
B302 EX_DIVIDE_BY_ZERO
B309 DIVBY0
B319 EX_DIV
B32D EX_ABS
B336 EX_EQL
B33F TRUE
B341 TRUE2
B34C FALSE
B350 EX_NEQ
B359 EX_LSS
B365 EX_GTR
B371 EX_GEQ
B37D EX_LEQ
B389 EX_XOR
B392 EX_ORR
B39B EX_AND
B3A4 EX_EOR
B3AD EX_SHL
B3B9 EX_SHR
B3C5 EX_INC
B3DD EX_DEC
B3F5 EX_MOV
B406 EX_LODC
B409 EX_LOD3
B40B EX_LOD3_A
B418 EX_LOD
B41B EX_LOD2
B42E EX_LDAC
B439 EX_LDA
B443 GETIDC
B44C GETIDX
B460 GETID2
B46E EX_LDIC
B474 EX_LDI
B47A EX_STOC
B482 EX_STO5
B487 EX_STO
B48D EX_STO2
B49A EX_STA
B4AB EX_STA5
B4B0 EX_STAC
B4B9 EX_STIC
B4C7 EX_STI
B4E2 EX_RTN
B51B EX_INP
B52C EX_INP_OK
B543 INP3
B553 BAD_INP
B55B EX_OUT
B560 EX_LCD_WRITE_NUM
B563 OUT_COMMON
B56F EX_OUH
B574 EX_LCD_WRITE_HEX
B577 EX_OUH_COMMON
B58F EX_OUS
B594 EX_LCD_WRITE_STR
B597 EX_OUS_COMMON
B5B3 EX_OUS1
B5C2 EX_ABSCLL
B5C9 EX_CLL
B5D1 EX_CLL_A
B5EF EX_CLL4
B5F3 EX_CLL2
B614 EX_CLL3
B655 EX_CLL5
B658 EX_CLA
B675 EX_CLL_JMP
B678 EX_INT
B68F INT_ERR
B696 INT_ERRM
B6A2 EX_NEW_STACK
B6B4 EX_JMP
B6C7 EX_JMZ
B6D2 EX_NOJUMP
B6D8 EX_JM1
B6E3 EX_INPC
B6ED EX_INPC_OK
B6FD EX_OUTC
B702 EX_LCD_WRITE_CHR
B705 EX_OUTC_COMMON
B713 EX_LCDHOME
B719 EX_LCDCLEAR
B71F EX_INS
B729 EX_INS3
B742 EX_INS1
B74B EX_INS2
B755 EX_INS4
B762 execution_aborted_message
B776 ex_input_aborted
B77D EX_ADRNC
B780 EX_ADRNC2
B78D EX_ADRNN
B790 EX_ADRN2
B79B EX_ADRAN
B7A1 EX_ADRAC
B7A7 EX_DIGITALREAD
B7B2 EX_DIGITALREAD_ONE
B7B5 EX_LCDPOS
B7C5 EX_LCDPOS_1
B7CF EX_RANDOM
B7E1 EX_LATENCY
B7F0 EX_DELAY
B800 EX_RANDOMSEED
B810 EX_PINMODE
B81F EX_DIGITALWRITE
B82E EX_LIB_CALL
B834 EX_ASSERT
B849 EX_ASSERT_OK
B84C break_message
B867 a_equals_message
B86F x_equals_message
B877 y_equals_message
B87F p_equals_message
B887 s_equals_message
B88F id_equals_message
B898 brk_executed
B916 brk_executed1
B923 brk_executed2
B933 brk_executed3
B94D brk_executed4
B957 stack_message
B95F brk_executedJ
B962 irq
B96F irq1
B987 cb2_interrupt
B993 serial_in_loop
B9B8 timer1_interrupt
B9D3 write_zero
B9D8 serial_send_count_bits
B9E7 irq_done
B9EA lcd_initialise
BA43 lcd_prepare_to_read_register
BA56 lcd_prepare_to_write_data
BA6B lcd_prepare_to_write_instruction
BA7E lcd_set_enable
BA87 lcd_clear_enable
BA90 lcd_read_instruction_nibble
BA9C lcd_wait
BAA4 lcdbusy
BAB3 lcd_wait_timeout
BAB7 lcd_get_address
BACB lcd_write_instruction_nibble
BAD7 lcd_instruction
BAEA lcd_data_nibble
BAF9 lcd_print_char
BB04 lcd_print_not_newline
BB13 lcd_print_char_on_2nd_line
BB1A lcd_print_char_newline
BB1A lcd_print_char_ok
BB2B lcd_clear_display
BB33 lcd_second_line
BB3B lcd_home
BB43 lcd_print_message
BB4C lcd_print
BB56 lcd_print_done
BB57 SEARCH
BB5F SEA_NEXT
BB6A SEA1
BB77 SEA2
BBC0 SEA4
BBC8 SEA5
BBCB SEA3
BBCE SYM_FULL
BBD3 ADDSYM
BC08 ADDSYM_NOT_FULL
BC2F ADD1
BC52 ADD4
BC6E ADD9
BC6F LOOKUP
BC79 LOOK1
BC7A CHKDUP
BC89 DUP9
BC8A COMPIL
BCD8 END_CMP
BCDB CHKLHP
BCE2 CHKRHP
BCEC GETSUB
BCF5 CHKLHB
BCFF CHKRHB
BD09 GET_LEV
BD13 GET_DAT
BD1A CONDEC
BD45 SYMWRK
BD50 WRKSYM
BD5B PSHPCODE
BD6E GET_OFF
BD8A GETO_1
BD97 GETO_2
BD99 GETEXPR
BD9F PCD_WRKD
BDAA WRK_OPND
BDB5 WRKD_WRK
BDC0 WRK_WRKD
BDCB GET_COMM
BDD2 GET_ITEM
BDD8 VAL_MOVE
BDE1 VAL_1
BDE6 VAL_2
BDEF VAL_3
BDF8 VAL_5
BE01 CHK_STAK
BE08 STK_ERR
BE08 STK_FULL
BE0D CONST
BE24 CONST1
BE29 CONST3
BE2E CONST2
BE32 CONST9
BE33 VARDEC
BE45 SIMEXP
BE4F SIM1
BE60 SIM3
BE73 SIM4
BE89 SIM7
BE8F SIM5
BE93 SIM6
BE97 SIM2
BE9D SIM8
BEA1 TERMT1
BEB7 TERM
BEBA TERM2
BEC4 TERM1
BED3 TERM4
BED5 TERM3
BEDB TERM5
BEDF TERM6
BEE3 TERM7
BEE7 TERM8
BEEB TERM9
BEEF TERMT3
BF05 FACTOR
BF16 IDENT
BF19 IDENT1
BF21 IDENT1A
BF26 IDENT2
BF3F IDENT2A
BF46 IDENT3
BF54 FACAD1
BF5C IDENT5
BF5E IDENT5_A
BF69 IDENT6
BF6F IDENT7
BF72 FACAD2
BF7A IDENT4
BF7C IDENT4_A
BF9C FACADR
BFAF FACSTR
BFB5 FACERR1
BFBA FACNUM
BFC0 PAREN
BFC6 FACMEM
BFCC FACMMC
BFD0 FACM2
BFDC FACNOT
BFE4 GENNOP1
BFE7 FACRND1
BFED FACTB1
BFF3 FACTQT1
C006 EXPRES
C016 EXPTB1
C029 EXPR1
C038 EXPTB3
C04B EXPR2
C04D EXPR8
C051 EXPR3
C055 EXPR4
C059 EXPR5
C05D EXPR6
C061 EXPR7
C065 STMNT
C072 STMNT1
C09D ASSIGN
C0A0 ASS1
C0AC ASSTB1
C0C2 assign_bad_identifier
C0C7 ASSARR
C0D9 ASSVAR
C0E8 ASS2
C104 WRITELN
C10E WRITELN9
C113 WRITE
C116 WRIT9
C125 W_STRING
C12F WRIT2
C132 WRIT10
C13F WRIT1
C14F WRIT5
C158 W_CHR
C15A W_CHR1
C160 W_HEX
C164 STMNT_WRITE_LCD
C167 WRITE_LCD9
C176 WRITE_LCD_STRING
C180 WRITE_LCD2
C190 WRITE_LCD1
C1A0 WRITE_LCD5
C1A9 WRITE_LDC_CHR
C1AB WRITE_LDC_CHR1
C1B1 WRITE_LDC_HEX
C1B5 READ
C1B8 READ8
C1BB READ2
C1D2 READ9
C1D5 READ11
C1F4 READ7
C1FA READ7_A
C204 READ3
C218 READ3_B
C233 READ3_A
C241 TWO_OP
C247 ONE_OP2
C24A ONE_OP
C251 GENNOP2
C254 WAIT_1
C25E MEM
C263 MEMC
C266 MEM2
C279 CALLSB
C286 FNCPRC
C293 FNC2
C2BD FNC3
C2C3 FNC1
C2C6 FNC5
C2E3 FNC5A
C2E5 FNC5B
C307 FNC4
C308 FNC6
C30D IF
C32B IF2
C332 IF1
C34D BEG
C363 REPEAT
C366 REP1
C387 WHILE
C3B9 CASE
C3C7 CASE7
C3CB CASE2
C3F2 CASE1
C3FE CASE4
C408 CASE3
C43B CASE5
C459 CASE6
C464 CASE9
C46E CASE8
C474 FOR
C47E FOR1
C48B FOR2
C4A4 FOR3
C4D5 FOR4
C518 FOR5
C53A FOR6
C547 CHKGET
C54D WRK_VAL
C558 VAL_WRK
C563 END_WRK
C56E BLCKT1
C571 BLCKT2
C574 BLCKT3
C57E BLOCK
C595 BLK1A
C5A9 BLK1
C5B1 BLK2
C5BB BLK4
C5C5 BLKCNS
C5C8 BLKCN1
C5DC BLKVAR
C5E0 BLKVR1
C5E3 BLKVR6
C5ED BLKVR7
C60C BLKVR8
C60F BLKV10
C62B BLKV10_A
C632 BLKV10_B
C641 BLKVR2
C65A BLKV13
C65F BLKVR4
C699 BLKV11
C6A0 BLKV12
C6A6 BLKVR9
C6BF BLKVR5
C701 BLKVR3
C719 BLKPRC
C739 BLKFNC
C75B BLKPR1
C777 BLKPR3
C784 BLKPR6
C78D BLKPR2
C7AE BLKPR5
C7D5 BLKPR4
C801 BLKBEG
C80B BLKB3
C811 BLKB1
C82D BLKB2
C83A BLKB5
C849 BLKB4
C858 BLKB6
C85B pascal_library_functions_table
C8FB add_pascal_library_functions
C903 add_pascal_library_functions_loop
C913 add_pascal_library_functions_name_loop
C954 add_pascal_library_functions_done
C955 library_function_call
C962 library_function_call_2
C98C library_function_call_3
C991 library_function_call_1
C994 library_function_call_5
C9A5 GENNOP
C9BA GEN1
C9BE GENADR
C9F1 GEN2
C9F3 GEN2_B
C9FC GEN2_A
CA0E GEN_FULL
CA13 DISP9
CA13 GEN2_C
CA14 GENRJMP
CA26 GENNJP
CA28 GENNJM
CA2E GENJMP
CA57 GEN3
CA5C FIXAD
CA99 FIXAD1
CA9A FIXM1
CAA3 FIXM2
CAAF pin_number_to_mask
CAB5 pin_number_to_mask_loop
CABD pin_number_to_mask_done
CAC2 pinmode
CAD3 pinmode_B
CADB pinmode_C
CAE9 pinmode_OUTPUT
CAF1 digitalwrite
CB02 digitalwrite_B
CB0A digitalwrite_C
CB18 digitalwrite_ONE
CB20 digitalread
CB2F digitalread_B
CB37 digitalread_C
CB3D write_to_serial
CB48 write_to_lcd
CB53 CHRIN
CB53 GETIN
CB5D GETIN1
CB64 serial_available
CB67 EMULATOR_DEBUG
CB68 START_TRACE
CB69 STOP_TRACE
CB6A hardware_init
CB9D write_char
CBB9 write_char_loop
CBC2 serial_print_message
CBC8 serial_print
CBD2 serial_print_done
CBD3 get_token
CBD7 get_token_loop
CBE1 gc_skip_spaces
CBF6 gc_newline
CC03 gc_newline1
CC10 gc_newline_assembling
CC15 gc_single_byte_already_known
CC17 gc_single_byte_token
CC19 gc_done
CC31 gc_not_space
CC36 gc_alpha_loop
CC3E gc_alpha_ok
CC4F gc_alpha_done
CC53 gc_alpha_alpha_only
CC5C gc_not_alpha
CC68 gc_not_digit
CC73 token_line
CC79 token_line1
CC94 token_line_listing
CCAC token_line_loop
CCBC token_line_loop1
CCC1 token_line_done
CCC2 atoi
CCCB atoi_loop
CCDA atoi_positive
CCDC atoi_more
CD31 atoi_error
CD37 atoi_not_running
CD3C negate_token_value
CD50 gtoken_table
CD81 gtoken_directive_table
CD8E gc_single_byte_tokenJ
CD91 gc_single_byte_already_knownJ
CD94 gc_lh_brace
CD98 gc_lh_paren
CDA6 gc_pascal_comment
CDC5 gc_pascal_comment_find_end
CDD0 gc_comment_not_eof
CDD9 gc_comment_not_newline
CDE8 gc_comment_keep_looking
CDF0 gc_comment_found_end
CE00 gc_directive_symbols
CE0C gc_directive_symbols_ok
CE33 gc_directive_symbols_too_late
CE38 gc_directive_list
CE3F gc_directive_pcodes
CE45 gc_directive_nolist
CE4E gc_semicolon
CE57 gc_assembler_comment_find_end
CE62 gc_assembler_comment_not_eof
CE69 gc_assembler_comment_keep_looking
CE71 gc_backslash_tokens
CE87 gc_backslash_tokens_end
CE87 gc_quote
CE95 gc_quote_loop
CE9E gc_quote_bad
CEA3 gc_quote_loop_not_end_of_line
CEB8 gc_quote_long_string
CEC3 gc_quote_copied_value
CECC gc_quote_done
CEDE gc_quote_not_finished
CEF0 gc_quote_backslash_loop
CEFB gc_quote_bad_string
CF00 gc_quote_hex_character_done
CF04 gc_quote_found_backslash_character
CF08 gc_quote_not_backslash
CF14 gc_quote_too_long
CF19 gc_fix_hex
CF22 gc_fix_hex_not_a_to_f
CF26 gc_quote_hex_character
CF52 gc_quote_hex_character_one_only
CF55 gc_dollar
CF61 gc_hex_literal
CF6A gc_hex_loop
CFA5 gc_hex_done
CFAA gc_hex_too_big
CFAF gc_percent
CFBB gc_binary_literal
CFC3 gc_binary_loop
CFD9 gc_colon
CFE4 gc_assign
CFEA gc_less_than
CFFE gc_leq
D003 gc_neq
D008 gc_shift_left
D00D gc_greater_than
D01A gc_single_byte_already_knownJ2
D01D gc_geq
D022 gc_shift_right
D027 gc_minus
D029 gc_plus
D048 gc_ampersand
D053 gc_logical_and
D059 gc_bar
D064 gc_logical_or
D06A gc_equals
D075 gc_equality
D07B gc_bang
D086 gc_inequality
D08C RSVWRD
D17F RSVEND
D181 pas_get_token
D18A pas_get_token_eof
D18B pas_gc_identifier
D193 pas_gc_loop
D19C pas_gc_more
D1C4 pas_gc_no_match
D1D5 GETCHK
D1E0 CHKNOK
D1E3 CHKOK
D1E5 CHKTKN
D1EA GET_LOOK
D1F4 i2c_init
D1FF i2c_delay
D203 i2c_toggle_clock
D20B i2c_toggle_clock_wait
D21E i2c_begin_transmission
D222 i2c_begin_transmission_loop
D245 i2c_write
D248 i2c_write_loop
D254 i2c_write_one
D25F i2c_write_clock
D26F i2c_write_clock_wait
D287 i2c_write_lost_arbitration
D289 i2c_write_got_ack
D28B i2c_read
D294 i2c_read_loop
D2A9 i2c_read_zero
D2AD i2c_read_next
D2C3 i2c_read_nak
D2C8 i2c_read_ack_or_nak
D2CD i2c_read_ack_or_nak_wait
D2DF i2c_read_done
D2E1 i2c_end_transmission
D2FA i2c_send
D302 i2c_send_loop
D319 i2c_send_done
D31E i2c_send_fail
D323 i2c_receive
D331 i2c_receive_loop
D346 i2c_receive_done
D34B i2c_receive_fail
D350 spi_init
D369 spi_init_clock_high
D36E spi_init2
D37B spi_init_mosi_low
D380 spi_init3
D386 spi_transfer
D38B spi_transfer_loop
D397 spi_send_zero
D39C spi_send_clock_pulse_1
D3A9 spi_send_clock_high_low
D3AE spi_send2
D3BD spi_read_02_done
D3BF spi_send3
D3CC spi_send_clock_low_high
D3D1 spi_send4
D3E0 spi_read_13_done
D3E2 spi_send_bit_done
D3EA spi_ss_low
D3F2 spi_ss_high
D3FA spi_send_two_bytes
D40A cp437_font
DC0A introduction
DC55 LCD_welcome
DC74 START
DC90 RESTART
4240 CLOCK_RATE
