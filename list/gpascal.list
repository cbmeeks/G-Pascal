Sections:
00: "seg8000" (8000-D15D)
01: "segfffa" (FFFA-0)


Source: "gpascal.asm"
                        	     1: ;***********************************************
                        	     2: ; G-PASCAL COMPILER
                        	     3: ; for Ben Eater's breadboard computer
                        	     4: ;
                        	     5: ; Author: Nick Gammon
                        	     6: ; Date: 20 January 2022
                        	     7: ;
                        	     8: ; To compile:
                        	     9: ;
                        	    10: ;  vasm6502_oldstyle gpascal.asm -wdc02 -esc -Fbin -o gpascal.bin -dotdir -L gpascal.list
                        	    11: ;
                        	    12: ; To program EEPROM:
                        	    13: ;
                        	    14: ;  minipro -p AT28C256 -w gpascal.bin
                        	    15: ;
                        	    16: ;
                        	    17: ;
                        	    18: ; To communicate, I suggest: miniterm /dev/ttyUSB0 4800 -e
                        	    19: ;
                        	    20: ;   Miniterm: Ctrl+]        : to exit.
                        	    21: ;             Ctrl+T Ctrl+H : help
                        	    22: ;             Ctrl+T Ctrl+E : toggle local echo
                        	    23: ;
                        	    24: ;
                        	    25: ;  Copyright 2022 by Nick Gammon
                        	    26: ;
                        	    27: ;  Permission is hereby granted, free of charge, to any person obtaining a copy
                        	    28: ;  of this software and associated documentation files (the "Software"), to deal
                        	    29: ;  in the Software without restriction, including without limitation the rights
                        	    30: ;  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                        	    31: ;  copies of the Software, and to permit persons to whom the Software is
                        	    32: ;  furnished to do so, subject to the following conditions:
                        	    33: ;
                        	    34: ;  The above copyright notice and this permission notice shall be included in all
                        	    35: ;  copies or substantial portions of the Software.
                        	    36: ;
                        	    37: ;  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                        	    38: ;  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                        	    39: ;  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                        	    40: ;  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                        	    41: ;  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                        	    42: ;  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
                        	    43: ;  SOFTWARE.
                        	    44: ;
                        	    45: ;***********************************************
                        	    46: ;
                        	    47: 
                        	    48: ; Note: BCC == BLT and BCS == BGE
                        	    49: ;
                        	    50: 
                        	    51: ;
                        	    52: ;  CONDITIONAL COMPILES
                        	    53: 
                        	    54: EMULATOR = 0          ; for testing on a PC running an emulator
                        	    55: LCD_SUPPORT = 1       ; 1 = support LCD, 0 = not. Unset if you have removed the LCD.
                        	    56: SERIAL_DEBUGGING = 0  ; if set, toggle VIA PA2 when reading a bit, and PA3 when writing a bit
                        	    57:                       ;  DO NOT USE I2C if this is on, as I2C functions use these two pins
                        	    58: 
                        	    59: ;
                        	    60: ;  CONFIGURATION
                        	    61: ;
                        	    62: CLOCK_RATE   = 1000000   ; 1 Mhz
                        	    63: START_OF_ROM = $8000     ; where the ROM chip starts
                        	    64: HIGHEST_RAM  = $3FFF      ; original board hardware
                        	    65: ;HIGHEST_RAM  = $5FFF    ; with suggested additional AND gate
                        	    66: 
                        	    67: ;
                        	    68: ;  serial output
                        	    69: ;
                        	    70: BAUD_RATE    = 4800         ; baud
                        	    71: BIT_INTERVAL = CLOCK_RATE / BAUD_RATE ; time between bits in Âµs
                        	    72: 
                        	    73: ;
                        	    74: ;  serial input - input commences on the interrupt generated by the falling edge
                        	    75: ;    of the start bit. Bits are then clocked in with a timed loop.
                        	    76: ;  - these delays can be tweaked if you believe the serial input is not being
                        	    77: ;    sampled at the right moment, confirm by turning SERIAL_DEBUGGING on
                        	    78: ;    and checking the debugging pulses compared to the middle of the bit times
                        	    79: ;    with an oscilloscope or logic analyser
                        	    80: ;
                        	    81: SERIAL_DELAY1 = 48    ; initial delay (count) - higher because it is 1.5 bit times
                        	    82: SERIAL_DELAY2 = 35    ; subsequent delays between bits (count)
                        	    83: 
                        	    84: SYMBOL_TABLE_START = HIGHEST_RAM  ; symbol table pointer (ENDSYM) is decremented before being used
                        	    85: 
                        	    86: STACK            =  $100  ; hardware stack address
                        	    87: SPACE            =  $20   ; uh-huh
                        	    88: SINGLE_QUOTE     =  $27
                        	    89: NL               =  $0A   ; newline
                        	    90: CR               =  $0D   ; carriage-return
                        	    91: BACKSPACE        =  $08   ; backspace
                        	    92: 
                        	    93: MAX_STK          =  32
                        	    94: NEW_STK          =  $FF
                        	    95: 
                        	    96:     .if EMULATOR
                        	    97: END_EDITOR_INPUT =  '`'   ; backtick terminates input
                        	    98:     .else
                        	    99: END_EDITOR_INPUT =  $1B   ; Esc terminates editor input
                        	   100:     .endif
                        	   101: 
                        	   102: KEY_DEBUG      = 'D'-$40   ; Ctrl+D start debugging
                        	   103: KEY_TRACE      = 'T'-$40   ; Ctrl+T start tracing
                        	   104: KEY_STOP_TRACE = 'N'-$40   ; Ctrl+N stop tracing
                        	   105: KEY_ABORT      = 'C'-$40   ; Ctrl+C abort execution
                        	   106: 
                        	   107: 
                        	   108:   .if LCD_SUPPORT
                        	   109: ;
                        	   110: ;  Pins connected from the VIA to the LCD
                        	   111: ;
                        	   112: LCD_RS             = %00100000  ; PA 5 - 0 = instruction, 1 = data
                        	   113: LCD_RW             = %01000000  ; PA 6 - 0 = write, 1 = read
                        	   114: LCD_E              = %10000000  ; PA 7 - toggle (0 -> 1 -> 0) to clock out a command or data
                        	   115:   .endif
                        	   116: 
                        	   117:   .include "zp_variables.inc"

Source: "zp_variables.inc"
                        	     1: ;***********************************************
                        	     2: ;
                        	     3: ; Zero-page variables (currently 64 (decimal) bytes are free for your use).
                        	     4: ;  I suggest using the high ones and working down in case there is a change to the code.
                        	     5: ;  For example, start with 0xFF, then 0xFE and so on.
                        	     6: ;
                        	     7: ;***********************************************
                        	     8: 
                        	     9:   .dsect
                        	    10: 
                        	    11: 
                        	    12: ;
                        	    13: ;  General work-areas for arithmetic routines (eg. add, subtract, divide, multiply)
                        	    14: ;   3-byte signed numbers: -8388608 to +8388607
                        	    15: ;
00:0000 00              	    16: VALUE    reserve 3    ; the current value of the token (ie. if a number)
00:0001 *
00:0003 00              	    17: VALUE2   reserve 3    ; used by the assembler expression evaluator
00:0004 *
                        	    18: 
                        	    19: ; SRCE and DEST used in compiler and editor, particularly for string comparisons
                        	    20: ;   (re-using VALUE and VALUE2)
                        	    21: 
                        	    22: SRCE     =  VALUE
                        	    23: DEST     =  VALUE2
                        	    24: 
00:0006 00              	    25: REMAIN   reserve 3    ; division remainder
00:0007 *
                        	    26: 
                        	    27: ;
                        	    28: ;  work "register" - re-using VALUE and VALUE2 again
                        	    29: ;
                        	    30: REG   = VALUE
                        	    31: REGB  = VALUE+2
                        	    32: REG2  = VALUE2
                        	    33: REG2B = VALUE2+2
                        	    34: 
                        	    35: ;
                        	    36: ;  re-using above for CRC-16 calculations
                        	    37: ;
                        	    38: crc_addr = VALUE      ; the address to take a CRC of (2 bytes)
                        	    39: crc_num  = VALUE2     ; the number of bytes to take a CRC of (2 bytes)
                        	    40: crc_val  = REMAIN     ; the current CRC value (2 bytes)
                        	    41: 
                        	    42: ;
                        	    43: ;  current random number - change this to reseed it
                        	    44: ;
00:0009 00              	    45: random         reserve 4 ; 32-bit random number
00:000A *
00:000D 00              	    46: typing_latency reserve 3 ; incremented while waiting for input
00:000E *
                        	    47: 
                        	    48: ;
                        	    49: ;  Used for seeding registers when calling machine code from Pascal
                        	    50: ;
00:0010 00              	    51: call_a reserve 1      ; used when doing a machine code call:  A register
00:0011 00              	    52: call_x reserve 1      ;  ditto: X register
00:0012 00              	    53: call_y reserve 1      ;  ditto: Y register
00:0013 00              	    54: call_p reserve 1      ;  ditto: status register
00:0014 00              	    55: call_s reserve 1      ; stack register, used by BRK
00:0015 00              	    56: brk_address reserve 2 ; BRK address
00:0016 *
                        	    57: 
                        	    58: ;
                        	    59: ;  address of write function (2 bytes)
                        	    60: ;
                        	    61: ;  This is called by "character out" function COUT. It writes the character in "A" to
                        	    62: ;   serial port or LCD. You could conceivably put another function address here if
                        	    63: ;   you wanted to capture output (eg. from calling DISP_BIN) and putting it somewhere else
                        	    64: ;   like into a series of memory locations, or to output to SPI.
                        	    65: ;  The functions write_to_serial and write_to_lcd
                        	    66: ;   put the appropriate outputting functions into this location.
                        	    67: ;
00:0017 00              	    68: write_function reserve 2  ; address of function to write to serial or LCD
00:0018 *
                        	    69: 
                        	    70: 
00:0019 00              	    71: LINE_CNT  reserve 2   ; line counter during compile
00:001A *
                        	    72: LINE_NO  =  LINE_CNT
                        	    73: 
00:001B 00              	    74: WX       reserve 2    ; 2-byte address used during compilation (reserved word lookup)
00:001C *
00:001D 00              	    75: LIST     reserve 1    ; 0 = no listing, 1 = list source during compile
00:001E 00              	    76: DIGIT    reserve 1    ; used only in GET_NUM to process a decimal number
00:001F 00              	    77: SIGN     reserve 1    ; used in compiling and inputting a number - is there a minus sign?
                        	    78: 
00:0020 00              	    79: FRAME    reserve 2    ; stack frame number - not totally certain but it used for procedure calls at runtime
00:0021 *
00:0022 00              	    80: LEVEL    reserve 1    ; current nested procedure/function level (how far we are nested)
00:0023 00              	    81: PCODE    reserve 2    ; current P-code address (increments during compile and running)
00:0024 *
                        	    82: PNTR     =  PCODE     ; 2-byte work pointer used in editor (eg. in find/replace etc.)
00:0025 00              	    83: ACT_PCDA reserve 2    ; start of P-codes (after source) - does not increment
00:0026 *
00:0027 00              	    84: DISPL    reserve 2    ; level? ahhh ... I don't know
00:0028 *
00:0029 00              	    85: OFFSET   reserve 2    ; variable offset? maybe just a work area
00:002A *
00:002B 00              	    86: OPND     reserve 3    ; jump operand ... not sure
00:002C *
00:002E 00              	    87: DCODE    reserve 1     ; 0 = no display, 1 = display P-codes during compile
00:002F 00              	    88: STARTSYM reserve 2    ; start of symbol table
00:0030 *
00:0031 00              	    89: ENDSYM   reserve 2    ; end of symbol table - used for reverse searching symbols
00:0032 *
                        	    90: T        =  ENDSYM     ; stack pointer 2 bytes
00:0033 00              	    91: WORKD    reserve 2    ; work area for holding P-code address
00:0034 *
00:0035 00              	    92: ERRNO    reserve 1    ; current error number, if ERROR called
00:0036 00              	    93: BSAVE    reserve 1    ; seems to be used to save "A" register, lol
00:0037 00              	    94: WORK     reserve 2    ; work area, used for pushing 2-bytes onto the (processor) stack
00:0038 *
00:0039 00              	    95: PRCITM   reserve 2    ; seems to hold the current procedure/function symbol
00:003A *
00:003B 00              	    96: BASE     reserve 2    ; the base interpreter stack frame (for this procedure)
00:003C *
                        	    97: TO       =  BASE      ; Used in editor (from/to list ranges, and copying text)
00:003D 00              	    98: DATA     reserve 2    ; 2-byte address work-area for calculating the address of a variable at runtime
00:003E *
00:003F 00              	    99: RUNNING  reserve 1    ; 0x40 - in editor, 0x80 - executing - affects stuff like numeric conversion
00:0040 00              	   100: SYMITM   reserve 2    ; current symbol table item (found by searching)
00:0041 *
                        	   101: FROM     =  SYMITM    ; Used in editor (from/to list ranges, and copying text)
00:0042 00              	   102: SYNTAX   reserve 1    ; 0 = full compile, 1 = syntax-only compile (no writing to memory)
00:0043 00              	   103: END_PCD  reserve 2    ; where the P-codes ended after a compile
00:0044 *
00:0045 00              	   104: TEMP     reserve 2    ; temporary work area?
00:0046 *
00:0047 00              	   105: CALL     reserve 2    ; the procedure address we are calling
00:0048 *
00:0049 00              	   106: DBGFLG   reserve 1    ; 0 = not debugging, 1 = debugging, $80 = tracing
00:004A 00              	   107: DATTYP   reserve 1    ; 0 for integers and 1 for characters
00:004B 00              	   108: COUNT1   reserve 1    ; work counter
00:004C 00              	   109: COUNT2   reserve 1    ; and another
00:004D 00              	   110: LASTP    reserve 2    ; 2-byte last P-code address executed at runtime (start of this P-code)
00:004E *
00:004F 00              	   111: IO_A     reserve 1    ; dunno
00:0050 00              	   112: IO_Y     reserve 1    ; seems to be used to save and restore Y
00:0051 00              	   113: IO_X     reserve 1    ;  ditto for X
00:0052 00              	   114: RES      reserve 3    ; multiplication result
00:0053 *
00:0055 00              	   115: MCAND    reserve 3    ; multiplicand
00:0056 *
                        	   116: DIVISOR  = MCAND      ; divisor for division (shares with multiplicand for multiplication)
00:0058 00              	   117: DVDN     reserve 3    ; dividend
00:0059 *
00:005B 00              	   118: RMNDR    reserve 1    ; for division, 0 if positive, 0x80 if negative
00:005C 00              	   119: bcd_work    reserve 4    ; work area for converting binary to decimal (packed)
00:005D *
00:0060 00              	   120: bcd_result  reserve 8    ; work area for turning numbers into printable (unpacked)
00:0061 *
00:0068 00              	   121: QT_TGL   reserve 1    ; quote toggle
00:0069 00              	   122: QUOT_SYM reserve 1     ; current quote symbol
00:006A 00              	   123: QT_SIZE  reserve 1    ; number of characters in reserved words
00:006B 00              	   124: ASS_OPERAND reserve 1 ; assembler operand type = see defines below
00:006C 00              	   125: OPCODE   reserve 2    ; address of opcode in assembler
00:006D *
00:006E 00              	   126: OPCODE_LEN reserve 1  ; length of opcode
00:006F 00              	   127: ASS_EMIT_COUNT reserve 1 ; number of bytes emitted on this line
00:0070 00              	   128: ASS_OPCODE_WORK reserve 2; for opcode lookups
00:0071 *
00:0072 00              	   129: ASS_COUNT reserve 1 ; for counting opcode matches
00:0073 00              	   130: ASS_VALUE reserve 3 ; the assembler operand (address or immediate) will be here
00:0074 *
00:0076 00              	   131: ASS_PASS  reserve 1 ; which assembler pass we are up to
00:0077 00              	   132: ass_emit_bytes reserve 2 ; how many bytes the assembler emitted altogether
00:0078 *
00:0079 00              	   133: exp_value_stack reserve 2  ; address of assembler value stack
00:007A *
00:007B 00              	   134: exp_value_stack_count reserve 1 ; how far through value stack we are (0 = empty)
00:007C 00              	   135: exp_operator_stack_count reserve 1 ;  how far through operator stack we are (0 = empty)
00:007D 00              	   136: exp_operator reserve 1  ; current operator for expression evaluation
00:007E 00              	   137: exp_operator_precedence reserve 1 ; current operator precedence
00:007F 00              	   138: exp_evaluation_function reserve 2 ; function to evaluate an expression
00:0080 *
00:0081 00              	   139: exp_unary_ok reserve 1  ; true if the next token can be a unary operator (like: - < >)
00:0082 00              	   140: show_symbols reserve 1  ; true to list the symbol table after an assemble
00:0083 00              	   141: ass_current_label reserve 2 ; current symbol table address of the label on this line
00:0084 *
00:0085 00              	   142: str_work reserve 1      ; work byte for string compares
                        	   143:   .if LCD_SUPPORT
00:0086 00              	   144: lcd_work  reserve 1 ; used by the LCD routines
                        	   145:   .endif
                        	   146: 
                        	   147: ;
                        	   148: ;  serial work
                        	   149: ;
00:0087 00              	   150: serial_out_byte reserve 2 ; current byte we are sending
00:0088 *
00:0089 00              	   151: serial_out_bit  reserve 1 ; current bit count
00:008A 00              	   152: serial_in_byte  reserve 1 ; current byte we are receiving
00:008B 00              	   153: serial_in_byte_received  reserve 1 ; last received byte
                        	   154: 
                        	   155: ;
                        	   156: ; hardware
                        	   157: ;
00:008C 00              	   158: hardware_work  reserve 1  ; work for use during interpreting
                        	   159: 
                        	   160: ;
                        	   161: ; maths
                        	   162: ;
00:008D 00              	   163: maths_work  reserve 1 ; work for multiply/divide
                        	   164: ;
                        	   165: ;  for get_token
                        	   166: ;
00:008E 00              	   167: token_start      reserve 2  ; where to start looking for a token
00:008F *
00:0090 00              	   168: token_address    reserve 2  ; where the token actually started
00:0091 *
00:0092 00              	   169: token_length     reserve 1  ; length of the token
00:0093 00              	   170: token_type       reserve 1  ; what type of token it is
00:0094 00              	   171: token_value      reserve 3  ; the value of numeric tokens
00:0095 *
00:0097 00              	   172: token_sign       reserve 1  ; non-zero if negative value
00:0098 00              	   173: token_work       reserve 3  ; temporary work area - also used by handlerLookup
00:0099 *
00:009B 00              	   174: token_digit      reserve 1  ; used by get_token
00:009C 00              	   175: token_line_start reserve 2  ; where the current line starts
00:009D *
                        	   176: 
                        	   177: ;
                        	   178: ;  for editor
                        	   179: ;
00:009E 00              	   180: from_line       reserve 2     ; list, delete, modify: FROM line number
00:009F *
00:00A0 00              	   181: to_line         reserve 2     ; list, delete, modify: TO line number
00:00A1 *
00:00A2 00              	   182: current_line    reserve 2     ; current editor line number
00:00A3 *
00:00A4 00              	   183: insert_limit    reserve 2     ; maximum we can input to
00:00A5 *
00:00A6 00              	   184: mem_move_src    reserve 2     ; for copying memory - source of move
00:00A7 *
00:00A8 00              	   185: mem_move_dest   reserve 2     ; for copying memory - destination of move
00:00A9 *
00:00AA 00              	   186: mem_move_len    reserve 2     ; for copying memory - length of move
00:00AB *
00:00AC 00              	   187: this_line       reserve 2     ; which line we are searching for
00:00AD *
00:00AE 00              	   188: this_line_addr  reserve 2     ; address of the "this" line
00:00AF *
00:00B0 00              	   189: find_from       reserve 1     ; editor find: from offset in INBUF (start of target string)
00:00B1 00              	   190: find_to         reserve 1     ; editor find: to offset in INBUF (end of target string)
00:00B2 00              	   191: find_pos        reserve 1     ; which offset in the current line we are currently searching from
00:00B3 00              	   192: find_len        reserve 1     ; the length of the find text
00:00B4 00              	   193: find_delimiter  reserve 1     ; the find/replace delimiter
00:00B5 00              	   194: rep_from        reserve 1     ; editor replace: start of replacement string
00:00B6 00              	   195: rep_to          reserve 1     ; editor replace: end of replacement string
00:00B7 00              	   196: rep_diff        reserve 2     ; difference in find/replace string lengths (signed 2 bytes)
00:00B8 *
00:00B9 00              	   197: find_count      reserve 2     ; count of find/replace
00:00BA *
00:00BB 00              	   198: found_this_line reserve 1     ; did we find something on this line?
                        	   199: insert_last_char = find_from  ; the last character we inserted in INSERT/LOAD mode
                        	   200: 
00:00BC 00              	   201: editor_flags    reserve 1     ; various flags, see below
                        	   202: 
                        	   203: EFLAG_SHOW_LINE        = %00000001    ; set after receiving a newline, so we display the next line
                        	   204: EFLAG_ALLOW_ZERO_FROM  = %00000010    ; for use with MEMORY, allow them to start from $0000
                        	   205: EFLAG_LOAD             = %00000100    ; doing a LOAD, do not show line numbers when inserting
                        	   206: EFLAG_SAVE             = %00001000    ; doing a SAVE, do not show line numbers
                        	   207: EFLAG_FIND             = %00010000    ; doing a FIND
                        	   208: EFLAG_REPLACE          = %00100000    ; doing a REPLACE
                        	   209: EFLAG_SUPPRESS_NEWLINE = %01000000    ; don't show newlines
                        	   210: EFLAG_NO_LINE_NUMBERS  = %10000000    ; don't show line numbers
                        	   211: 
00:00BD 00              	   212: find_flags     reserve 1      ; find/replace flags, see below
                        	   213: 
                        	   214: FFLAG_IGNORE_CASE = %00000001
                        	   215: FFLAG_GLOBAL      = %00000010
                        	   216: FFLAG_QUIET       = %00000100
                        	   217: 
                        	   218: ;
                        	   219: ;  system flags
                        	   220: ;
                        	   221: 
00:00BE 00              	   222: system_flags    reserve 1    ; general flags
                        	   223: 
                        	   224: FLAG_COMPILING      = %00000001
                        	   225: FLAG_ASSEMBLING     = %00000010
                        	   226: FLAG_LIST_SOURCE    = %00000100
                        	   227: FLAG_VALID_COMPILE  = %00001000
                        	   228: FLAG_VALID_ASSEMBLE = %00010000
                        	   229: FLAG_RUNNING        = %00100000
                        	   230: FLAG_ONLY_ALPHA     = %01000000   ; for editor, so you can L5 to do LIST 5
                        	   231: FLAG_ABORTED        = %10000000   ; Ctrl+C pressed during printing
                        	   232: 

Source: "gpascal.asm"
                        	   118: 
                        	   119: ;
                        	   120: ;  A general work-buffer is allocated from $200 to $2FF for use during keyboard input, and also
                        	   121: ;  for converting strings during tokenisation (eg. two quotes in a row to one quote, and handling
                        	   122: ;  string escape sequences). It is also used during assembly as a 256-byte operator stack.
                        	   123: ;
                        	   124:   .org $200
                        	   125: INBUF_SIZE = 256          ; we use this for string storage during tokenisation
01:0200 00              	   126: INBUF  reserve INBUF_SIZE ; and also for preprocessing string literals (eg. backslash expansion)
01:0201 *
                        	   127: TEXT_START = *            ; where source goes in memory (currently $300)
                        	   128:   .dend
                        	   129: 
                        	   130: 
                        	   131: 
                        	   132: ;------------------------------------------
                        	   133: ;  Macros
                        	   134: ;------------------------------------------
                        	   135: 
                        	   136:  .macro tknjmpItem ; tknjmp entry: token, handler
                        	   137:    dfb   \1
                        	   138:    word  \2
                        	   139:  .endmacro
                        	   140: 
                        	   141:  .macro makeHandler ; table of words and handlers: word, handler
                        	   142:    asciiz   \1
                        	   143:    word  \2
                        	   144:  .endmacro
                        	   145: 
                        	   146: ;
                        	   147: ; makePasLibraryFunction NAME (SYMNAM), TYPE (SYMTYP), ARG_COUNT (SYMARG), EXECUTION_ADDRESS (SYMDSP)
                        	   148: ;
                        	   149: ;   TYPE = SYMBOL_LIBRARY_PROCEDURE or SYMBOL_LIBRARY_FUNCTION
                        	   150:    .macro makePasLibraryFunction
                        	   151:      asciiz   \1
                        	   152:      dfb      \2
                        	   153:      dfb      \3
                        	   154:      word     \4
                        	   155:    .endmacro
                        	   156: 
                        	   157: ;
                        	   158: ; makeAsmLibraryFunction NAME (SYMNAM), EXECUTION_ADDRESS (SYMDSP)
                        	   159: ;
                        	   160:    .macro makeAsmLibraryFunction
                        	   161:      asciiz   \1
                        	   162:      word     \2
                        	   163:    .endmacro
                        	   164: 
                        	   165:   ORG  START_OF_ROM   ; normally $8000 in the case of Ben Eater's board
                        	   166: 
00:8000 4C28D1          	   167:   JMP  START   ; where RESET takes us - a cold start
00:8003 4C44D1          	   168:   JMP  RESTART ; where NMI takes us - a warm start
                        	   169: 
                        	   170: ;***********************************************
                        	   171: ; INCLUDES
                        	   172: ;***********************************************
                        	   173: 
                        	   174:   .include "memory.inc"

Source: "memory.inc"
                        	     1: ;---------------------------
                        	     2: ; standard library stuff
                        	     3: ;---------------------------
                        	     4: 
                        	     5: ;
                        	     6: ;  character type masks
                        	     7: ;
                        	     8: m_upper   = %00000001    ; $01
                        	     9: m_lower   = %00000010    ; $02
                        	    10: m_alpha   = %00000100    ; $04
                        	    11: m_digit   = %00001000    ; $08
                        	    12: m_xdigit  = %00010000    ; $10
                        	    13: m_space   = %00100000    ; $20
                        	    14: m_cntrl   = %01000000    ; $40
                        	    15: m_alnum   = %10000000    ; $80
                        	    16: 
                        	    17: ;
                        	    18: ;  for fast checks which corrupt registers
                        	    19: ;
                        	    20: ;    ldx THE_CHARACTER_TO_BE_TESTED
                        	    21: ;    lda character_types_table,X
                        	    22: ;    bne IS_IN_THAT_CLASS
                        	    23: ;
                        	    24: 
                        	    25: character_types_table = *
00:8006 40              	    26:   dfb $40,$40,$40,$40,$40,$40,$40,$40    ; 0x00
00:8007 40
00:8008 40
00:8009 40
00:800A 40
00:800B 40
00:800C 40
00:800D 40
00:800E 40              	    27:   dfb $40,$60,$60,$60,$60,$60,$40,$40    ; 0x08
00:800F 60
00:8010 60
00:8011 60
00:8012 60
00:8013 60
00:8014 40
00:8015 40
00:8016 40              	    28:   dfb $40,$40,$40,$40,$40,$40,$40,$40    ; 0x10
00:8017 40
00:8018 40
00:8019 40
00:801A 40
00:801B 40
00:801C 40
00:801D 40
00:801E 40              	    29:   dfb $40,$40,$40,$40,$40,$40,$40,$40    ; 0x18
00:801F 40
00:8020 40
00:8021 40
00:8022 40
00:8023 40
00:8024 40
00:8025 40
00:8026 20              	    30:   dfb $20,$00,$00,$00,$00,$00,$00,$00    ; 0x20   !"#$%&'
00:8027 00
00:8028 00
00:8029 00
00:802A 00
00:802B 00
00:802C 00
00:802D 00
00:802E 00              	    31:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x28  ()*+,-./
00:802F 00
00:8030 00
00:8031 00
00:8032 00
00:8033 00
00:8034 00
00:8035 00
00:8036 98              	    32:   dfb $98,$98,$98,$98,$98,$98,$98,$98    ; 0x30  01234567
00:8037 98
00:8038 98
00:8039 98
00:803A 98
00:803B 98
00:803C 98
00:803D 98
00:803E 98              	    33:   dfb $98,$98,$00,$00,$00,$00,$00,$00    ; 0x38  89:;<=>?
00:803F 98
00:8040 00
00:8041 00
00:8042 00
00:8043 00
00:8044 00
00:8045 00
00:8046 00              	    34:   dfb $00,$95,$95,$95,$95,$95,$95,$85    ; 0x40  @ABCDEFG
00:8047 95
00:8048 95
00:8049 95
00:804A 95
00:804B 95
00:804C 95
00:804D 85
00:804E 85              	    35:   dfb $85,$85,$85,$85,$85,$85,$85,$85    ; 0x48  HIJKLMNO
00:804F 85
00:8050 85
00:8051 85
00:8052 85
00:8053 85
00:8054 85
00:8055 85
00:8056 85              	    36:   dfb $85,$85,$85,$85,$85,$85,$85,$85    ; 0x50  PQRSTUVW
00:8057 85
00:8058 85
00:8059 85
00:805A 85
00:805B 85
00:805C 85
00:805D 85
00:805E 85              	    37:   dfb $85,$85,$85,$00,$00,$00,$00,$00    ; 0x58  XYZ[\]^_
00:805F 85
00:8060 85
00:8061 00
00:8062 00
00:8063 00
00:8064 00
00:8065 00
00:8066 00              	    38:   dfb $00,$96,$96,$96,$96,$96,$96,$86    ; 0x60  `abcdefg
00:8067 96
00:8068 96
00:8069 96
00:806A 96
00:806B 96
00:806C 96
00:806D 86
00:806E 86              	    39:   dfb $86,$86,$86,$86,$86,$86,$86,$86    ; 0x68  hijklmno
00:806F 86
00:8070 86
00:8071 86
00:8072 86
00:8073 86
00:8074 86
00:8075 86
00:8076 86              	    40:   dfb $86,$86,$86,$86,$86,$86,$86,$86    ; 0x70  pqrstuvw
00:8077 86
00:8078 86
00:8079 86
00:807A 86
00:807B 86
00:807C 86
00:807D 86
00:807E 86              	    41:   dfb $86,$86,$86,$00,$00,$00,$00,$40    ; 0x78  xyz{|}~
00:807F 86
00:8080 86
00:8081 00
00:8082 00
00:8083 00
00:8084 00
00:8085 40
00:8086 00              	    42:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x80
00:8087 00
00:8088 00
00:8089 00
00:808A 00
00:808B 00
00:808C 00
00:808D 00
00:808E 00              	    43:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x88
00:808F 00
00:8090 00
00:8091 00
00:8092 00
00:8093 00
00:8094 00
00:8095 00
00:8096 00              	    44:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x90
00:8097 00
00:8098 00
00:8099 00
00:809A 00
00:809B 00
00:809C 00
00:809D 00
00:809E 00              	    45:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x98
00:809F 00
00:80A0 00
00:80A1 00
00:80A2 00
00:80A3 00
00:80A4 00
00:80A5 00
00:80A6 00              	    46:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xA0
00:80A7 00
00:80A8 00
00:80A9 00
00:80AA 00
00:80AB 00
00:80AC 00
00:80AD 00
00:80AE 00              	    47:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xA8
00:80AF 00
00:80B0 00
00:80B1 00
00:80B2 00
00:80B3 00
00:80B4 00
00:80B5 00
00:80B6 00              	    48:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xB0
00:80B7 00
00:80B8 00
00:80B9 00
00:80BA 00
00:80BB 00
00:80BC 00
00:80BD 00
00:80BE 00              	    49:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xB8
00:80BF 00
00:80C0 00
00:80C1 00
00:80C2 00
00:80C3 00
00:80C4 00
00:80C5 00
00:80C6 00              	    50:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xC0
00:80C7 00
00:80C8 00
00:80C9 00
00:80CA 00
00:80CB 00
00:80CC 00
00:80CD 00
00:80CE 00              	    51:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xC8
00:80CF 00
00:80D0 00
00:80D1 00
00:80D2 00
00:80D3 00
00:80D4 00
00:80D5 00
00:80D6 00              	    52:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xD0
00:80D7 00
00:80D8 00
00:80D9 00
00:80DA 00
00:80DB 00
00:80DC 00
00:80DD 00
00:80DE 00              	    53:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xD8
00:80DF 00
00:80E0 00
00:80E1 00
00:80E2 00
00:80E3 00
00:80E4 00
00:80E5 00
00:80E6 00              	    54:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xE0
00:80E7 00
00:80E8 00
00:80E9 00
00:80EA 00
00:80EB 00
00:80EC 00
00:80ED 00
00:80EE 00              	    55:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xE8
00:80EF 00
00:80F0 00
00:80F1 00
00:80F2 00
00:80F3 00
00:80F4 00
00:80F5 00
00:80F6 00              	    56:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xF0
00:80F7 00
00:80F8 00
00:80F9 00
00:80FA 00
00:80FB 00
00:80FC 00
00:80FD 00
00:80FE 00              	    57:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xF8
00:80FF 00
00:8100 00
00:8101 00
00:8102 00
00:8103 00
00:8104 00
00:8105 00
                        	    58: 
                        	    59: ;
                        	    60: ;  character type tests: test character in A, Carry set if true, carry clear if false
                        	    61: ;    -no registers changed
                        	    62: ;
                        	    63: is_xxx_fail:
00:8106 FA              	    64:   plx
00:8107 68              	    65:   pla
00:8108 18              	    66:   clc
00:8109 60              	    67:   rts
                        	    68: 
                        	    69: is_xxx_pass:
00:810A FA              	    70:   plx
00:810B 68              	    71:   pla
00:810C 38              	    72:   sec
00:810D 60              	    73:   rts
                        	    74: 
                        	    75:   .macro isXXX
                        	    76: \1 = *
                        	    77:   pha
                        	    78:   phx
                        	    79:   tax
                        	    80:   lda character_types_table,x
                        	    81:   and #\2
                        	    82:   beq is_xxx_fail
                        	    83:   bra is_xxx_pass
                        	    84:   .endmacro
                        	    85: 
                        	    86: ;
                        	    87: ;  generate the various character type tests - done by fast table lookup
                        	    88: ;
                        	    89:   isXXX isupper,  m_upper
                        	     1M isupper = *
00:810E 48              	     2M   pha
00:810F DA              	     3M   phx
00:8110 AA              	     4M   tax
00:8111 BD0680          	     5M   lda character_types_table,x
00:8114 2901            	     6M   and #m_upper
00:8116 F0EE            	     7M   beq is_xxx_fail
00:8118 80F0            	     8M   bra is_xxx_pass
                        	    90:   isXXX islower,  m_lower
                        	     1M islower = *
00:811A 48              	     2M   pha
00:811B DA              	     3M   phx
00:811C AA              	     4M   tax
00:811D BD0680          	     5M   lda character_types_table,x
00:8120 2902            	     6M   and #m_lower
00:8122 F0E2            	     7M   beq is_xxx_fail
00:8124 80E4            	     8M   bra is_xxx_pass
                        	    91:   isXXX isalpha,  m_alpha
                        	     1M isalpha = *
00:8126 48              	     2M   pha
00:8127 DA              	     3M   phx
00:8128 AA              	     4M   tax
00:8129 BD0680          	     5M   lda character_types_table,x
00:812C 2904            	     6M   and #m_alpha
00:812E F0D6            	     7M   beq is_xxx_fail
00:8130 80D8            	     8M   bra is_xxx_pass
                        	    92:   isXXX isdigit,  m_digit
                        	     1M isdigit = *
00:8132 48              	     2M   pha
00:8133 DA              	     3M   phx
00:8134 AA              	     4M   tax
00:8135 BD0680          	     5M   lda character_types_table,x
00:8138 2908            	     6M   and #m_digit
00:813A F0CA            	     7M   beq is_xxx_fail
00:813C 80CC            	     8M   bra is_xxx_pass
                        	    93:   isXXX isxdigit, m_xdigit
                        	     1M isxdigit = *
00:813E 48              	     2M   pha
00:813F DA              	     3M   phx
00:8140 AA              	     4M   tax
00:8141 BD0680          	     5M   lda character_types_table,x
00:8144 2910            	     6M   and #m_xdigit
00:8146 F0BE            	     7M   beq is_xxx_fail
00:8148 80C0            	     8M   bra is_xxx_pass
                        	    94:   isXXX isspace,  m_space
                        	     1M isspace = *
00:814A 48              	     2M   pha
00:814B DA              	     3M   phx
00:814C AA              	     4M   tax
00:814D BD0680          	     5M   lda character_types_table,x
00:8150 2920            	     6M   and #m_space
00:8152 F0B2            	     7M   beq is_xxx_fail
00:8154 80B4            	     8M   bra is_xxx_pass
                        	    95:   isXXX iscntrl,  m_cntrl
                        	     1M iscntrl = *
00:8156 48              	     2M   pha
00:8157 DA              	     3M   phx
00:8158 AA              	     4M   tax
00:8159 BD0680          	     5M   lda character_types_table,x
00:815C 2940            	     6M   and #m_cntrl
00:815E F0A6            	     7M   beq is_xxx_fail
00:8160 80A8            	     8M   bra is_xxx_pass
                        	    96:   isXXX isalnum,  m_alnum
                        	     1M isalnum = *
00:8162 48              	     2M   pha
00:8163 DA              	     3M   phx
00:8164 AA              	     4M   tax
00:8165 BD0680          	     5M   lda character_types_table,x
00:8168 2980            	     6M   and #m_alnum
00:816A F09A            	     7M   beq is_xxx_fail
00:816C 809C            	     8M   bra is_xxx_pass
                        	    97: 
                        	    98: ;
                        	    99: ;  ran out of bits so implemented this one manually
                        	   100: ;
                        	   101: isbinary   =  *
00:816E C930            	   102:          cmp  #'0'
00:8170 F004            	   103:          beq  isbin
00:8172 C931            	   104:          cmp  #'1'
00:8174 D002            	   105:          bne  notbin
                        	   106: isbin:
00:8176 38              	   107:          sec
00:8177 60              	   108:          rts
                        	   109: notbin:
00:8178 18              	   110:          clc
00:8179 60              	   111:          rts
                        	   112: 
                        	   113: ;
                        	   114: ; Move memory down  (mem_move_dest is < mem_move_src)
                        	   115: ;
                        	   116: ;  Copies first byte first, working upwards
                        	   117: ;
                        	   118: ; mem_move_src = source start address
                        	   119: ; mem_move_dest = destination start address
                        	   120: ; mem_move_len = number of bytes mem_move_dest move
                        	   121: ;
                        	   122: movedown:
00:817A A5AA            	   123:   lda mem_move_len
00:817C 05AB            	   124:   ora mem_move_len+1
00:817E F01C            	   125:   beq movedown_done
00:8180 A000            	   126:   ldy #0
00:8182 8498            	   127:   sty  token_work      ; counter
00:8184 8499            	   128:   sty  token_work+1
                        	   129: ;
                        	   130: ;  copy one byte, increment counter
                        	   131: ;
                        	   132: movedown_loop:
00:8186 B1A6            	   133:   lda (mem_move_src),Y
00:8188 91A8            	   134:   sta (mem_move_dest),Y
00:818A E698            	   135:   inc token_work
00:818C D002            	   136:   bne movedown2
00:818E E699            	   137:   inc token_work+1
                        	   138: ;
                        	   139: ;  see if length reached
                        	   140: ;
                        	   141: movedown2:
                        	   142: 
00:8190 A598            	   143:   lda  token_work
00:8192 C5AA            	   144:   cmp  mem_move_len
00:8194 D007            	   145:   bne  movedown1
00:8196 A599            	   146:   lda  token_work+1
00:8198 C5AB            	   147:   cmp  mem_move_len+1
00:819A D001            	   148:   bne  movedown1
                        	   149: movedown_done:
00:819C 60              	   150:   rts
                        	   151: 
                        	   152: ;
                        	   153: ; increment Y, and increment high-order address bytes if necessary
                        	   154: ;
                        	   155: movedown1:
00:819D C8              	   156:   iny
00:819E D0E6            	   157:   bne  movedown_loop
00:81A0 E6A7            	   158:   inc  mem_move_src+1
00:81A2 E6A9            	   159:   inc  mem_move_dest+1
00:81A4 80E0            	   160:   bra  movedown_loop
                        	   161: 
                        	   162: ; Move memory up (mem_move_dest is > mem_move_src)
                        	   163: ;
                        	   164: ;   Copies last byte first, moving downwards
                        	   165: ;
                        	   166: ; mem_move_src = source start address
                        	   167: ; mem_move_dest = destination start address
                        	   168: ; mem_move_len = number of bytes mem_move_dest move
                        	   169: ;
                        	   170: moveup:
00:81A6 A5AA            	   171:   lda mem_move_len
00:81A8 05AB            	   172:   ora mem_move_len+1
00:81AA F038            	   173:   beq moveup_done
00:81AC A000            	   174:   ldy #0
00:81AE 8498            	   175:   sty  token_work      ; counter
00:81B0 8499            	   176:   sty  token_work+1
                        	   177:   ;
                        	   178:   ;  calculate final address of source
                        	   179:   ;
00:81B2 18              	   180:   clc
00:81B3 A5A6            	   181:   lda mem_move_src
00:81B5 65AA            	   182:   adc mem_move_len
00:81B7 85A6            	   183:   sta mem_move_src
00:81B9 A5A7            	   184:   lda mem_move_src+1
00:81BB 65AB            	   185:   adc mem_move_len+1
00:81BD 85A7            	   186:   sta mem_move_src+1
                        	   187:   ;
                        	   188:   ;  calculate final address of destination
                        	   189:   ;
00:81BF 18              	   190:   clc
00:81C0 A5A8            	   191:   lda mem_move_dest
00:81C2 65AA            	   192:   adc mem_move_len
00:81C4 85A8            	   193:   sta mem_move_dest
00:81C6 A5A9            	   194:   lda mem_move_dest+1
00:81C8 65AB            	   195:   adc mem_move_len+1
00:81CA 85A9            	   196:   sta mem_move_dest+1
00:81CC 8017            	   197:   bra moveup_next   ; have to decrement first
                        	   198: ;
                        	   199: ; move one byte, count moves
                        	   200: ;
                        	   201: moveup_loop:
00:81CE B1A6            	   202:   lda (mem_move_src),Y
00:81D0 91A8            	   203:   sta (mem_move_dest),Y
00:81D2 E698            	   204:   inc token_work
00:81D4 D002            	   205:   bne moveup3
00:81D6 E699            	   206:   inc token_work+1
                        	   207: moveup3:
                        	   208: ;
                        	   209: ;  see if length reached
                        	   210: ;
00:81D8 A598            	   211:   lda token_work
00:81DA C5AA            	   212:   cmp mem_move_len
00:81DC D007            	   213:   bne moveup_next
00:81DE A599            	   214:   lda token_work+1
00:81E0 C5AB            	   215:   cmp mem_move_len+1
00:81E2 D001            	   216:   bne moveup_next
                        	   217: moveup_done:
00:81E4 60              	   218:   rts
                        	   219: ;
                        	   220: ;  decrement Y, and decrement high-order address bytes if necessary
                        	   221: ;
                        	   222: moveup_next   =  *
00:81E5 88              	   223:   dey
00:81E6 C0FF            	   224:   cpy #$FF
00:81E8 D0E4            	   225:   bne moveup_loop
00:81EA C6A7            	   226:   dec mem_move_src+1
00:81EC C6A9            	   227:   dec mem_move_dest+1
00:81EE 80DE            	   228:   bra moveup_loop
                        	   229: 
                        	   230: ;
                        	   231: ;
                        	   232: ; String compare - case significant (max 128 byte strings)
                        	   233: ;
                        	   234: ; SRCE = source start address
                        	   235: ; DEST = destination start address
                        	   236: ; Y    = length of both strings (range 1 to 128)
                        	   237: ;
                        	   238: ;  returns Z set if strings are equal
                        	   239: ;
                        	   240: 
                        	   241: str_compare:
00:81F0 88              	   242:   dey             ; make zero-relative
00:81F1 300B            	   243:   bmi str_compare_done
00:81F3 B100            	   244:   lda (SRCE),y
00:81F5 8585            	   245:   sta str_work
00:81F7 B103            	   246:   lda (DEST),y
00:81F9 C585            	   247:   cmp str_work
00:81FB F0F3            	   248:   beq str_compare
00:81FD 60              	   249:   rts   ; no match, zero flag not set
                        	   250: str_compare_done:
00:81FE A900            	   251:   lda #0    ; set Z flag
00:8200 60              	   252:   rts
                        	   253: 
                        	   254: ;
                        	   255: ; String compare - case NOT significant (max 128 byte strings)
                        	   256: ;
                        	   257: ; SRCE = source start address
                        	   258: ; DEST = destination start address
                        	   259: ; Y    = length of both strings (range 1 to 128)
                        	   260: ;
                        	   261: ;  returns Z set if strings are equal
                        	   262: ;
                        	   263: 
                        	   264: str_ic_compare:
00:8201 88              	   265:   dey
00:8202 301F            	   266:   bmi str_ic_compare_done
00:8204 B100            	   267:   lda (SRCE),y
00:8206 C97B            	   268:   cmp #'z'+1
00:8208 B006            	   269:   bcs str_ic_compare_fixed_srce  ; BGE
00:820A C961            	   270:   cmp #'a'
00:820C 9002            	   271:   bcc str_ic_compare_fixed_srce  ; BLT
00:820E E920            	   272:   sbc #$20    ; make upper-case
                        	   273: str_ic_compare_fixed_srce:
00:8210 8585            	   274:   sta str_work
00:8212 B103            	   275:   lda (DEST),y
00:8214 C97B            	   276:   cmp #'z'+1
00:8216 B006            	   277:   bcs str_ic_compare_fixed_dest  ; BGE
00:8218 C961            	   278:   cmp #'a'
00:821A 9002            	   279:   bcc str_ic_compare_fixed_dest  ; BLT
00:821C E920            	   280:   sbc #$20    ; make upper-case
                        	   281: str_ic_compare_fixed_dest:
00:821E C585            	   282:   cmp str_work
00:8220 F0DF            	   283:   beq str_ic_compare
00:8222 60              	   284:   rts       ; no match, zero flag not set
                        	   285: str_ic_compare_done:
00:8223 A900            	   286:   lda #0    ; set Z flag
00:8225 60              	   287:   rts
                        	   288: 
                        	   289: 

Source: "gpascal.asm"
                        	   175:   .include "editor.inc"

Source: "editor.inc"
                        	     1: ;-------------------------------------------------
                        	     2: ;
                        	     3: ;  Shell, and text editor
                        	     4: ;
                        	     5: ;-------------------------------------------------
                        	     6: 
                        	     7: 
                        	     8: ;-------------------------------------------------
                        	     9: ;  print null-terminated message, message in A (lo) and X (hi)
                        	    10: ;  returns the length of the message in Y
                        	    11: ;-------------------------------------------------
                        	    12: print:
00:8226 A8              	    13:   tay   ; save A
00:8227 A503            	    14:   lda REG2 ; save REG2
00:8229 48              	    15:   pha
00:822A A504            	    16:   lda REG2+1  ; save REG2+1
00:822C 48              	    17:   pha
00:822D 98              	    18:   tya   ; get original A back
00:822E 8503            	    19:   sta REG2
00:8230 8604            	    20:   stx REG2+1
00:8232 A000            	    21:   ldy #0
                        	    22: print_loop:
00:8234 A58B            	    23:   lda  serial_in_byte_received
00:8236 F00A            	    24:   beq  print_not_abort
00:8238 C903            	    25:   cmp  #KEY_ABORT
00:823A D010            	    26:   bne  print_done
00:823C A980            	    27:   lda  #FLAG_ABORTED    ; set aborted flag
00:823E 04BE            	    28:   tsb  system_flags
00:8240 800A            	    29:   bra  print_done
                        	    30: print_not_abort:
00:8242 B103            	    31:   lda (REG2),y
00:8244 F006            	    32:   beq print_done
00:8246 201894          	    33:   jsr COUT
00:8249 C8              	    34:   iny
00:824A D0E8            	    35:   bne print_loop  ; give up if we overflow
                        	    36: print_done:
00:824C 648B            	    37:   stz serial_in_byte_received
                        	    38: ;
                        	    39: ;  get REG2 back
                        	    40: ;
00:824E 68              	    41:   pla
00:824F 8504            	    42:   sta REG2+1
00:8251 68              	    43:   pla
00:8252 8503            	    44:   sta REG2
00:8254 60              	    45:   rts
                        	    46: 
00:8255 472D50617363616C	    47: introduction asc    "G-Pascal compiler, version 4.0.\n"
00:825D 20636F6D70696C65
00:8265 722C207665727369
00:826D 6F6E20342E302E0A
00:8275 5772697474656E20	    48:              asciiz "Written by Nick Gammon.\nType H for help.\n"
00:827D 6279204E69636B20
00:8285 47616D6D6F6E2E0A
00:828D 5479706520482066
00:8295 6F722068656C702E
00:829D 0A
00:829E 00
00:829F 3A20            	    49: prompt       asciiz ": "
00:82A1 00
00:82A2 556E6B6E6F776E20	    50: bad_command  asciiz "Unknown command, type H for help.\n"
00:82AA 636F6D6D616E642C
00:82B2 2074797065204820
00:82BA 666F722068656C70
00:82C2 2E0A
00:82C4 00
                        	    51: 
                        	    52: ;-------------------------------------------------
                        	    53: ; Start here after Reset or NMI - show introduction
                        	    54: ;-------------------------------------------------
                        	    55: 
                        	    56: main_start:
00:82C5 A955            	    57:   lda #<introduction
00:82C7 A282            	    58:   ldx #>introduction
00:82C9 202682          	    59:   jsr print
                        	    60: 
                        	    61: main_prompt:
00:82CC A2FF            	    62:   ldx  #NEW_STK
00:82CE 9A              	    63:   txs
00:82CF D8              	    64:   cld
                        	    65: 
00:82D0 A99F            	    66:   lda #<prompt
00:82D2 A282            	    67:   ldx #>prompt
00:82D4 202682          	    68:   jsr print
                        	    69: 
00:82D7 20F093          	    70:   jsr  GET_LINE
                        	    71: 
00:82DA A900            	    72:   lda #<INBUF
00:82DC 858E            	    73:   sta token_start
00:82DE A902            	    74:   lda #>INBUF
00:82E0 858F            	    75:   sta token_start+1
                        	    76: 
00:82E2 A901            	    77:   lda #1
00:82E4 853F            	    78:   sta RUNNING
                        	    79: 
                        	    80: ;-------------------------------------------------
                        	    81: ; EDITOR (SHELL) MAIN LOOP
                        	    82: ;-------------------------------------------------
                        	    83: 
                        	    84: main_loop:
00:82E6 64BC            	    85:   stz editor_flags  ; no flags yet
00:82E8 64BD            	    86:   stz find_flags    ;  ditto
00:82EA A901            	    87:   lda #FLAG_COMPILING
00:82EC 0902            	    88:   ora #FLAG_ASSEMBLING
00:82EE 14BE            	    89:   trb system_flags  ; not compiling or assembling now
                        	    90: 
00:82F0 A940            	    91:   lda #FLAG_ONLY_ALPHA
00:82F2 04BE            	    92:   tsb system_flags  ; we only want alpha commands, thus we can enter L1 and be the same as List 1
                        	    93: 
00:82F4 208CC9          	    94:   jsr get_token
00:82F7 F0D3            	    95:   beq main_prompt   ; no input
                        	    96: 
                        	    97: ;
                        	    98: ;  Shortcut: If the input is "R" or "r" followed directly by a newline, assume they want to Run
                        	    99: ;
00:82F9 C949            	   100:   cmp #TOKEN_IDENTIFIER
00:82FB D015            	   101:   bne main_loop_not_run
                        	   102: 
00:82FD A000            	   103:   ldy #0
00:82FF B190            	   104:   lda (token_address),y
00:8301 202D90          	   105:   jsr MAKE_UPPER
00:8304 C952            	   106:   cmp #'R'
00:8306 D00A            	   107:   bne main_loop_not_run
00:8308 C8              	   108:   iny
00:8309 B190            	   109:   lda (token_address),y
00:830B C90A            	   110:   cmp #NL
00:830D D003            	   111:   bne main_loop_not_run
00:830F 4C028F          	   112:   jmp editor_run
                        	   113: 
                        	   114: ;
                        	   115: ;  Not a RUN shortcut, look up the command in our table
                        	   116: ;
                        	   117: main_loop_not_run:
                        	   118: ;
                        	   119: ;  set up our input line as where to find tokens
                        	   120: ;
00:8312 A590            	   121:   lda token_address
00:8314 8500            	   122:   sta SRCE
00:8316 A591            	   123:   lda token_address+1
00:8318 8501            	   124:   sta SRCE+1
                        	   125: 
                        	   126: ;
                        	   127: ;  get editor handlers
                        	   128: ;
00:831A A930            	   129:   lda #<editor_handlers
00:831C 8503            	   130:   sta DEST
00:831E A983            	   131:   lda #>editor_handlers
00:8320 8504            	   132:   sta DEST+1
                        	   133: 
                        	   134: ;
                        	   135: ;  get the token length and look up the handler
                        	   136: ;
00:8322 A592            	   137:   lda token_length
00:8324 20B68F          	   138:   jsr partial_handler_Lookup
                        	   139: 
                        	   140: ;
                        	   141: ;  if we returned, unknown command
                        	   142: ;
00:8327 A9A2            	   143:   lda #<bad_command
00:8329 A282            	   144:   ldx #>bad_command
00:832B 202682          	   145:   jsr print
00:832E 809C            	   146:   bra  main_prompt
                        	   147: 
                        	   148: 
                        	   149: editor_handlers:
                        	   150:   makeHandler "LIST",    editor_list
00:8330 4C495354        	     1M    asciiz   "LIST"
00:8334 00
00:8335 7B87            	     2M    word  editor_list
                        	   151:   makeHandler "INSERT",  editor_insert
00:8337 494E53455254    	     1M    asciiz   "INSERT"
00:833D 00
00:833E 2E8A            	     2M    word  editor_insert
                        	   152:   makeHandler "LOAD",    editor_load
00:8340 4C4F4144        	     1M    asciiz   "LOAD"
00:8344 00
00:8345 2A8A            	     2M    word  editor_load
                        	   153:   makeHandler "DELETE",  editor_delete
00:8347 44454C455445    	     1M    asciiz   "DELETE"
00:834D 00
00:834E BC8B            	     2M    word  editor_delete
                        	   154:   makeHandler "HELP",    editor_help
00:8350 48454C50        	     1M    asciiz   "HELP"
00:8354 00
00:8355 3385            	     2M    word  editor_help
                        	   155:   makeHandler "COMPILE" ,editor_compile
00:8357 434F4D50494C45  	     1M    asciiz   "COMPILE" 
00:835E 00
00:835F EE8E            	     2M    word  editor_compile
                        	   156:   makeHandler "SYNTAX",  editor_syntax
00:8361 53594E544158    	     1M    asciiz   "SYNTAX"
00:8367 00
00:8368 F88E            	     2M    word  editor_syntax
                        	   157:   makeHandler "SAVE",    editor_save
00:836A 53415645        	     1M    asciiz   "SAVE"
00:836E 00
00:836F 7587            	     2M    word  editor_save
                        	   158: ;  makeHandler "TEST",    editor_test
                        	   159:   makeHandler "MEMORY",  editor_memory
00:8371 4D454D4F5259    	     1M    asciiz   "MEMORY"
00:8377 00
00:8378 148D            	     2M    word  editor_memory
                        	   160:  ; makeHandler "SYMTBL", editor_symbol_table_list
                        	   161:   makeHandler "INFO",    editor_info
00:837A 494E464F        	     1M    asciiz   "INFO"
00:837E 00
00:837F DF8E            	     2M    word  editor_info
                        	   162:   makeHandler "TRACE",   editor_trace
00:8381 5452414345      	     1M    asciiz   "TRACE"
00:8386 00
00:8387 D38E            	     2M    word  editor_trace
                        	   163:   makeHandler "DEBUG",   editor_debug
00:8389 4445425547      	     1M    asciiz   "DEBUG"
00:838E 00
00:838F C78E            	     2M    word  editor_debug
                        	   164:   makeHandler "ASSEMBLE",editor_assemble
00:8391 415353454D424C45	     1M    asciiz   "ASSEMBLE"
00:8399 00
00:839A 6D8F            	     2M    word  editor_assemble
                        	   165:   makeHandler "FIND",    editor_find
00:839C 46494E44        	     1M    asciiz   "FIND"
00:83A0 00
00:83A1 6F87            	     2M    word  editor_find
                        	   166:   makeHandler "REPLACE", editor_replace
00:83A3 5245504C414345  	     1M    asciiz   "REPLACE"
00:83AA 00
00:83AB 6787            	     2M    word  editor_replace
                        	   167:   makeHandler "RUN",     editor_run
00:83AD 52554E          	     1M    asciiz   "RUN"
00:83B0 00
00:83B1 028F            	     2M    word  editor_run
                        	   168:   makeHandler "RECOVER", editor_recover
00:83B3 5245434F564552  	     1M    asciiz   "RECOVER"
00:83BA 00
00:83BB 9E8E            	     2M    word  editor_recover
00:83BD 00              	   169:   dfb 0
                        	   170: 
                        	   171: editor_help_info:
00:83BE 417661696C61626C	   172:   asc "Available actions:\n\n"
00:83C6 6520616374696F6E
00:83CE 733A0A0A
00:83D2 4C6973742F534176	   173:   asc "List/SAve   line_number_range\n"
00:83DA 652020206C696E65
00:83E2 5F6E756D6265725F
00:83EA 72616E67650A
00:83F0 44656C6574652020	   174:   asc "Delete      line_number_range\n"
00:83F8 202020206C696E65
00:8400 5F6E756D6265725F
00:8408 72616E67650A
00:840E 496E736572742F4C	   175:   asc "Insert/LOad after_line\n"
00:8416 4F61642061667465
00:841E 725F6C696E650A
00:8425 46696E6420202020	   176:   asc "Find        line_number_range /target/flags\n"
00:842D 202020206C696E65
00:8435 5F6E756D6265725F
00:843D 72616E6765202F74
00:8445 61726765742F666C
00:844D 6167730A
00:8451 5265706C61636520	   177:   asc "Replace     line_number_range /target/replacement/flags\n"
00:8459 202020206C696E65
00:8461 5F6E756D6265725F
00:8469 72616E6765202F74
00:8471 61726765742F7265
00:8479 706C6163656D656E
00:8481 742F666C6167730A
00:8489 0A              	   178:   asc "\n"
00:848A 48656C700A      	   179:   asc "Help\n"
00:848F 494E666F0A      	   180:   asc "INfo\n"
00:8494 4D656D6F72792020	   181:   asc "Memory      first_address last_address\n"
00:849C 2020202066697273
00:84A4 745F616464726573
00:84AC 73206C6173745F61
00:84B4 6464726573730A
00:84BB 436F6D70696C652F	   182:   asc "Compile/Syntax/Assemble\n"
00:84C3 53796E7461782F41
00:84CB 7373656D626C650A
00:84D3 52556E2F44454275	   183:   asc "RUn/DEBug/Trace\n"
00:84DB 672F54726163650A
00:84E3 5245436F7665720A	   184:   asc "RECover\n"
00:84EB 28416374696F6E73	   185:   asc "(Actions may be abbreviated)\n"
00:84F3 206D617920626520
00:84FB 6162627265766961
00:8503 746564290A
00:8508 28466C6167733A20	   186:   asc "(Flags: 'I'gnore case, 'G'lobal, 'Q'uiet)\n"
00:8510 274927676E6F7265
00:8518 20636173652C2027
00:8520 47276C6F62616C2C
00:8528 2027512775696574
00:8530 290A
00:8532 00              	   187:   dfb 0
                        	   188: 
                        	   189: 
                        	   190: ;--------------------------------------------
                        	   191: ;  HELP
                        	   192: ;--------------------------------------------
                        	   193: editor_help:
00:8533 205886          	   194:   jsr editor_check_no_more
00:8536 A9BE            	   195:   lda #<editor_help_info
00:8538 8500            	   196:   sta REG
00:853A A983            	   197:   lda #>editor_help_info
00:853C 8501            	   198:   sta REG+1
                        	   199: editor_help_loop:
00:853E A000            	   200:   ldy #0
00:8540 B100            	   201:   lda (REG),Y
00:8542 F00B            	   202:   beq editor_help_done
00:8544 201894          	   203:   jsr COUT
00:8547 E600            	   204:   inc REG
00:8549 D0F3            	   205:   bne editor_help_loop
00:854B E601            	   206:   inc REG+1
00:854D 80EF            	   207:   bra editor_help_loop
                        	   208: editor_help_done:
00:854F 4CCC82          	   209:   jmp main_prompt
                        	   210: 
                        	   211: ;
                        	   212: ;  Sets default range from 1 to 65535
                        	   213: ;
                        	   214: editor_default_range:
                        	   215: ;
                        	   216: ;  default to all lines
                        	   217: ;
00:8552 A901            	   218:   lda #1
00:8554 859E            	   219:   sta from_line
00:8556 649F            	   220:   stz from_line+1
00:8558 A9FF            	   221:   lda #$FF
00:855A 85A0            	   222:   sta to_line
00:855C 85A1            	   223:   sta to_line+1
00:855E 60              	   224:   rts
                        	   225: 
                        	   226: number_expected_message:
00:855F 4E756D6265722065	   227:   asciiz "Number expected\n"
00:8567 787065637465640A
00:856F 00
                        	   228: 
                        	   229: editor_bad_number:
00:8570 A95F            	   230:   lda #<number_expected_message
00:8572 A285            	   231:   ldx #>number_expected_message
00:8574 202682          	   232:   jsr print
00:8577 4CCC82          	   233:   jmp main_prompt
                        	   234: 
                        	   235: ;
                        	   236: ;  get a number for the editor: accepts eof or newline as "no number"
                        	   237: ;  otherwise must be a number and in the range 0x0001 to 0xFFFF
                        	   238: ;  returns carry set if a number (in token_value) and carry clear if
                        	   239: ;  no number. Raises an error otherwise
                        	   240: ;
                        	   241: editor_get_number:
00:857A 203ACF          	   242:   jsr pas_get_token   ; use this to find END as a token
00:857D F065            	   243:   beq editor_get_number_none ; no token? return with carry set
00:857F C90A            	   244:   cmp #NL
00:8581 F061            	   245:   beq editor_get_number_none ; newline counts as no token
00:8583 C94E            	   246:   cmp #TOKEN_NUMBER
00:8585 F04B            	   247:   beq editor_get_number_ok
00:8587 C989            	   248:   cmp #TOKEN_END
00:8589 F05B            	   249:   beq editor_get_number_end
00:858B C949            	   250:   cmp #TOKEN_IDENTIFIER
00:858D D02D            	   251:   bne editor_get_number_not_identifier
00:858F A592            	   252:   lda token_length
00:8591 C903            	   253:   cmp #3
00:8593 D0DB            	   254:   bne editor_bad_number
00:8595 A000            	   255:   ldy #0
00:8597 B190            	   256:   lda (token_address),y
00:8599 202D90          	   257:   jsr MAKE_UPPER
00:859C C941            	   258:   cmp #'A'
00:859E D0D0            	   259:   bne editor_bad_number
00:85A0 C8              	   260:   iny
00:85A1 B190            	   261:   lda (token_address),y
00:85A3 202D90          	   262:   jsr MAKE_UPPER
00:85A6 C94C            	   263:   cmp #'L'
00:85A8 D0C6            	   264:   bne editor_bad_number
00:85AA C8              	   265:   iny
00:85AB B190            	   266:   lda (token_address),y
00:85AD 202D90          	   267:   jsr MAKE_UPPER
00:85B0 C94C            	   268:   cmp #'L'
00:85B2 D0BC            	   269:   bne editor_bad_number
00:85B4 205285          	   270:   jsr editor_default_range
00:85B7 205886          	   271:   jsr editor_check_no_more ; can't have ALL - something
00:85BA 8028            	   272:   bra editor_get_number_none
                        	   273: ;
                        	   274: ;  find / replace can go straight to the delimiter
                        	   275: ;
                        	   276: editor_get_number_not_identifier:
00:85BC A910            	   277:   lda #EFLAG_FIND
00:85BE 0920            	   278:   ora #EFLAG_REPLACE
00:85C0 25BC            	   279:   and editor_flags
00:85C2 F0AC            	   280:   beq editor_bad_number
00:85C4 A592            	   281:   lda token_length
00:85C6 C901            	   282:   cmp #1
00:85C8 D0A6            	   283:   bne editor_bad_number
                        	   284: ;
                        	   285: ;  go back one character, we need get_token to find this again later
                        	   286: ;
00:85CA C68E            	   287:   dec token_start
00:85CC D016            	   288:   bne editor_get_number_none
00:85CE C68F            	   289:   dec token_start+1
00:85D0 8012            	   290:   bra editor_get_number_none
                        	   291: 
                        	   292: editor_get_number_ok:
00:85D2 A596            	   293:   lda token_value+2         ; must be a number
00:85D4 D03C            	   294:   bne editor_line_number_too_big
00:85D6 A5BC            	   295:   lda editor_flags
00:85D8 2902            	   296:   and #EFLAG_ALLOW_ZERO_FROM
00:85DA D006            	   297:   bne editor_get_number_done
00:85DC A594            	   298:   lda token_value
00:85DE 0595            	   299:   ora token_value+1
00:85E0 F030            	   300:   beq editor_line_number_too_big  ; too small actually
                        	   301: editor_get_number_done:
00:85E2 38              	   302:   sec
00:85E3 60              	   303:   rts
                        	   304: 
                        	   305: editor_get_number_none:
00:85E4 18              	   306:   clc
00:85E5 60              	   307:   rts
                        	   308: 
                        	   309: ;
                        	   310: ;  the word "END" will count as the highest possible line number
                        	   311: ;
                        	   312: editor_get_number_end:
00:85E6 A9FF            	   313:   lda #$FF
00:85E8 8594            	   314:   sta token_value
00:85EA 8595            	   315:   sta token_value+1
00:85EC 6496            	   316:   stz token_value+2
00:85EE 205886          	   317:   jsr editor_check_no_more ; can't have END - something
00:85F1 38              	   318:   sec
00:85F2 60              	   319:   rts
                        	   320: 
                        	   321: number_too_large_message:
00:85F3 4E756D6265722074	   322:   asciiz "Number too large or too small\n"
00:85FB 6F6F206C61726765
00:8603 206F7220746F6F20
00:860B 736D616C6C0A
00:8611 00
                        	   323: 
                        	   324: editor_line_number_too_big:
00:8612 A9F3            	   325:   lda #<number_too_large_message
00:8614 A285            	   326:   ldx #>number_too_large_message
00:8616 202682          	   327:   jsr print
00:8619 4CCC82          	   328:   jmp main_prompt
                        	   329: 
                        	   330: number_bad_range_message:
00:861C 52616E676520696E	   331:   asciiz "Range invalid\n"
00:8624 76616C69640A
00:862A 00
                        	   332: 
                        	   333: editor_bad_range:
00:862B A91C            	   334:   lda #<number_bad_range_message
00:862D A286            	   335:   ldx #>number_bad_range_message
00:862F 202682          	   336:   jsr print
00:8632 4CCC82          	   337:   jmp main_prompt
                        	   338: 
                        	   339: too_much_on_line:
00:8635 556E657870656374	   340:   asciiz "Unexpected trailing input on line\n"
00:863D 656420747261696C
00:8645 696E6720696E7075
00:864D 74206F6E206C696E
00:8655 650A
00:8657 00
                        	   341: 
                        	   342: ;
                        	   343: ;  check that all is left on the line is spaces
                        	   344: ;
                        	   345: editor_check_no_more:
00:8658 A000            	   346:   ldy #0
                        	   347: editor_check_no_more_loop:
00:865A B18E            	   348:   lda (token_start),y
00:865C F016            	   349:   beq editor_check_no_more_ok   ; end of file
00:865E C90A            	   350:   cmp #NL
00:8660 F012            	   351:   beq editor_check_no_more_ok   ; newline is OK
00:8662 204A81          	   352:   jsr isspace
00:8665 9003            	   353:   bcc editor_check_no_more_failed ; not spaces is bad
00:8667 C8              	   354:   iny
00:8668 D0F0            	   355:   bne editor_check_no_more_loop   ; skip spaces
                        	   356: 
                        	   357: editor_check_no_more_failed:
00:866A A935            	   358:   lda #<too_much_on_line
00:866C A286            	   359:   ldx #>too_much_on_line
00:866E 202682          	   360:   jsr print
00:8671 4CCC82          	   361:   jmp main_prompt
                        	   362: editor_check_no_more_ok:
00:8674 60              	   363:   rts
                        	   364: 
                        	   365: 
                        	   366: 
                        	   367: ;--------------------------------------------
                        	   368: ;  get a range of line numbers (eg. L 1,10; D 4; M 6,10 )
                        	   369: ;--------------------------------------------
                        	   370: 
                        	   371: editor_get_range:
                        	   372: 
                        	   373: 
                        	   374: ;
                        	   375: ;  get the first line number (if any)
                        	   376: ;
00:8675 207A85          	   377:   jsr editor_get_number
00:8678 9049            	   378:   bcc editor_get_range_done ; no token? take defaults
                        	   379: ;
                        	   380: ;  store the from line
                        	   381: ;
00:867A A594            	   382:   lda token_value
00:867C 859E            	   383:   sta from_line
00:867E 85A0            	   384:   sta to_line
00:8680 A595            	   385:   lda token_value+1
00:8682 859F            	   386:   sta from_line+1
00:8684 85A1            	   387:   sta to_line+1
                        	   388: 
                        	   389: ;
                        	   390: ;  comma or hyphen?
                        	   391: ;
00:8686 208CC9          	   392:   jsr get_token
00:8689 F038            	   393:   beq editor_get_range_done   ; line done, just the single line wanted
                        	   394: 
00:868B C92D            	   395:   cmp #'-'
00:868D F01C            	   396:   beq editor_get_range_hyphen
00:868F C94E            	   397:   cmp #TOKEN_NUMBER
00:8691 F01D            	   398:   beq editor_get_range_number
00:8693 C989            	   399:   cmp #TOKEN_END
00:8695 F019            	   400:   beq editor_get_range_number
00:8697 C92C            	   401:   cmp #','
00:8699 F010            	   402:   beq editor_get_range_hyphen
                        	   403: ;
                        	   404: ;  find and replace may have another character after the first line number
                        	   405: ;  which isn't a second line number or a hyphen/comma
                        	   406: ;
00:869B A910            	   407:   lda #EFLAG_FIND
00:869D 0920            	   408:   ora #EFLAG_REPLACE
00:869F 25BC            	   409:   and editor_flags
00:86A1 F088            	   410:   beq editor_bad_range
                        	   411: 
                        	   412: ;
                        	   413: ;  go back one character, we need get_token to find this again later
                        	   414: ;
00:86A3 C68E            	   415:   dec token_start
00:86A5 D01C            	   416:   bne editor_get_range_done
00:86A7 C68F            	   417:   dec token_start+1
00:86A9 8018            	   418:   bra editor_get_range_done
                        	   419: 
                        	   420: editor_get_range_hyphen:
                        	   421: ;
                        	   422: ;  get the second line number
                        	   423: ;
00:86AB 207A85          	   424:   jsr editor_get_number
00:86AE 9014            	   425:   bcc editor_bad_rangeJ
                        	   426: 
                        	   427: editor_get_range_number:
00:86B0 A594            	   428:   lda token_value
00:86B2 85A0            	   429:   sta to_line
00:86B4 A595            	   430:   lda token_value+1
00:86B6 85A1            	   431:   sta to_line+1
                        	   432: 
                        	   433: ;
                        	   434: ;  make sure range ascends
                        	   435: ;
00:86B8 38              	   436:   sec
00:86B9 A5A0            	   437:   lda to_line
00:86BB E59E            	   438:   sbc from_line
00:86BD A5A1            	   439:   lda to_line+1
00:86BF E59F            	   440:   sbc from_line+1
00:86C1 9001            	   441:   bcc editor_bad_rangeJ    ; <sigh> because of the way SBC works
                        	   442: 
                        	   443: editor_get_range_done:
00:86C3 60              	   444:   rts
                        	   445: 
00:86C4 4C2B86          	   446: editor_bad_rangeJ jmp editor_bad_range
                        	   447: 
                        	   448: ;
                        	   449: 
00:86C7 20666F756E640A  	   450: found_message asciiz  ' found\n'
00:86CE 00
                        	   451: 
                        	   452: 
                        	   453: 
00:86CF 46726F6D3A20    	   454: from_msg: asciiz "From: "
00:86D5 00
00:86D6 20746F20        	   455: to_msg:   asciiz " to "
00:86DA 00
                        	   456: 
00:86DB 4261642064656C69	   457: bad_delimiter_message asciiz "Bad delimiter\n"
00:86E3 6D697465720A
00:86E9 00
                        	   458: 
                        	   459: editor_bad_delimiter:
00:86EA A9DB            	   460:   lda #<bad_delimiter_message
00:86EC A286            	   461:   ldx #>bad_delimiter_message
                        	   462: editor_find_problem:
00:86EE 202682          	   463:   jsr print
00:86F1 4CCC82          	   464:   jmp main_prompt
                        	   465: 
00:86F4 46696E642F726570	   466: find_string_too_long_message asciiz "Find/replace string too long\n"
00:86FC 6C61636520737472
00:8704 696E6720746F6F20
00:870C 6C6F6E670A
00:8711 00
                        	   467: 
                        	   468: find_string_too_long:
00:8712 A9F4            	   469:   lda #<find_string_too_long_message
00:8714 A286            	   470:   ldx #>find_string_too_long_message
00:8716 80D6            	   471:   bra editor_find_problem
                        	   472: 
                        	   473: editor_get_delimiter:
00:8718 208CC9          	   474:   jsr get_token
00:871B C949            	   475:   cmp #TOKEN_IDENTIFIER
00:871D F0CB            	   476:   beq editor_bad_delimiter
00:871F C94E            	   477:   cmp #TOKEN_NUMBER
00:8721 F0C7            	   478:   beq editor_bad_delimiter
00:8723 C922            	   479:   cmp #TOKEN_STRING
00:8725 F0C3            	   480:   beq editor_bad_delimiter
00:8727 A692            	   481:   ldx token_length
00:8729 E001            	   482:   cpx #1
00:872B D0BD            	   483:   bne editor_bad_delimiter
00:872D 85B4            	   484:   sta find_delimiter
00:872F 60              	   485:   rts
                        	   486: 
00:8730 4E6F20636C6F7369	   487: editor_no_closing_delimiter_message asciiz "No closing delimiter\n"
00:8738 6E672064656C696D
00:8740 697465720A
00:8745 00
                        	   488: 
                        	   489: editor_no_closing_delimiter:
00:8746 A930            	   490:   lda #<editor_no_closing_delimiter_message
00:8748 A287            	   491:   ldx #>editor_no_closing_delimiter_message
00:874A 80A2            	   492:   bra editor_find_problem
                        	   493: 
00:874C 5461726765742073	   494: no_find_message asciiz "Target string empty\n"
00:8754 7472696E6720656D
00:875C 7074790A
00:8760 00
                        	   495: 
                        	   496: editor_no_find_string:
00:8761 A94C            	   497:   lda #<no_find_message
00:8763 A287            	   498:   ldx #>no_find_message
00:8765 8087            	   499:   bra editor_find_problem
                        	   500: 
                        	   501: ;--------------------------------------------
                        	   502: ;  LIST / SAVE / FIND / REPLACE / MODIFY
                        	   503: ;
                        	   504: ;  This rather complex routine lists the source between from_line and to_line
                        	   505: ;   In the process it can show or omit line numbers  (omit for SAVE)
                        	   506: ;  Also, it can find the target text, and optionally replace it with the replacement text
                        	   507: ;  In find/replace mode the lines are not shown unless they had something found (unless
                        	   508: ;   the Quiet flag is set)
                        	   509: ;
                        	   510: ;--------------------------------------------
                        	   511: 
                        	   512: editor_replace:
00:8767 A920            	   513:   lda #EFLAG_REPLACE
00:8769 0910            	   514:   ora #EFLAG_FIND   ; makes things simpler later on
00:876B 85BC            	   515:   sta editor_flags
00:876D 800C            	   516:   bra editor_list
                        	   517: 
                        	   518: editor_find:
                        	   519: 
00:876F A910            	   520:   lda #EFLAG_FIND
00:8771 85BC            	   521:   sta editor_flags
00:8773 8006            	   522:   bra editor_list
                        	   523: 
                        	   524: editor_save
                        	   525: 
00:8775 A980            	   526:   lda #EFLAG_NO_LINE_NUMBERS
00:8777 0908            	   527:   ora #EFLAG_SAVE
00:8779 85BC            	   528:   sta editor_flags
                        	   529: 
                        	   530: ;
                        	   531: ;  main entry point - get the from and to lines
                        	   532: ;
                        	   533: editor_list:
00:877B 205285          	   534:   jsr editor_default_range
00:877E 207586          	   535:   jsr editor_get_range
                        	   536: 
                        	   537: ;
                        	   538: ;  turn the from_line into an address and put it into PCODE
                        	   539: ;
00:8781 A59E            	   540:   lda from_line
00:8783 85AC            	   541:   sta this_line
00:8785 A59F            	   542:   lda from_line+1
00:8787 85AD            	   543:   sta this_line+1
00:8789 209D8C          	   544:   jsr find_line    ; find the "from" line address (this_line in fact)
00:878C A5AE            	   545:   lda this_line_addr
00:878E 8523            	   546:   sta PCODE
00:8790 A5AF            	   547:   lda this_line_addr+1
00:8792 8524            	   548:   sta PCODE+1
00:8794 64B9            	   549:   stz find_count
00:8796 64BA            	   550:   stz find_count+1
                        	   551: 
                        	   552: ;
                        	   553: ;  for FIND and REPLACE, get the first delimiter
                        	   554: ;
00:8798 A5BC            	   555:   lda editor_flags
00:879A 2910            	   556:   and #EFLAG_FIND
00:879C D003            	   557:   bne editor_list_doing_find
00:879E 4C6B88          	   558:   jmp editor_list_not_find
                        	   559: 
                        	   560: editor_list_doing_find:
00:87A1 201887          	   561:   jsr editor_get_delimiter
                        	   562: ;
                        	   563: ;  token_next should now be the start of what we are searching for
                        	   564: ;
00:87A4 38              	   565:   sec
00:87A5 A58E            	   566:   lda token_start
00:87A7 E900            	   567:   sbc #<INBUF
00:87A9 85B0            	   568:   sta find_from
00:87AB B00B            	   569:   bcs editor_list_got_from_point ; delimiter should be a single byte
                        	   570: 
                        	   571: editor_find_bug:
00:87AD A214            	   572:   ldx #20  ; ERROR: bug
00:87AF 4CCD97          	   573:   jmp ERROR
                        	   574: 
00:87B2 4C1287          	   575: find_string_too_longJ         jmp find_string_too_long
00:87B5 4C4687          	   576: editor_no_closing_delimiterJ  jmp editor_no_closing_delimiter
                        	   577: 
                        	   578: editor_list_got_from_point:
                        	   579: 
                        	   580: ;
                        	   581: ;  Now find closing delimiter by a simple scan as we will pass who-knows-what on the way
                        	   582: ;
00:87B8 A6B0            	   583:   ldx find_from
                        	   584: editor_find_second_delimiter_loop:
00:87BA E8              	   585:   inx
00:87BB BD0002          	   586:   lda INBUF,x
00:87BE F0F5            	   587:   beq editor_no_closing_delimiterJ
00:87C0 C90A            	   588:   cmp #NL
00:87C2 F0F1            	   589:   beq editor_no_closing_delimiterJ
00:87C4 C5B4            	   590:   cmp find_delimiter
00:87C6 D0F2            	   591:   bne editor_find_second_delimiter_loop
                        	   592: 
                        	   593: ;
                        	   594: ;  found the closing delimiter
                        	   595: ;
00:87C8 86B1            	   596:   stx find_to
00:87CA E4B0            	   597:   cpx find_from
00:87CC F093            	   598:   beq editor_no_find_string
                        	   599: ;
                        	   600: ;  maximum 127 byte find string
                        	   601: ;
00:87CE 38              	   602:   sec
00:87CF A5B1            	   603:   lda find_to
00:87D1 E5B0            	   604:   sbc find_from
00:87D3 30DD            	   605:   bmi find_string_too_longJ
00:87D5 85B3            	   606:   sta find_len    ; save for later memory move calculations
                        	   607: 
00:87D7 A920            	   608:   lda #EFLAG_REPLACE
00:87D9 25BC            	   609:   and editor_flags
00:87DB F02A            	   610:   beq editor_find_get_flags
                        	   611: 
                        	   612: ;
                        	   613: ;  doing a replace - find second delimiter
                        	   614: ;
                        	   615: 
00:87DD 86B5            	   616:   stx rep_from
00:87DF E6B5            	   617:   inc rep_from    ; get past the delimiter
                        	   618: 
                        	   619: editor_find_third_delimiter_loop:
00:87E1 E8              	   620:   inx
00:87E2 BD0002          	   621:   lda INBUF,x
00:87E5 F0CE            	   622:   beq editor_no_closing_delimiterJ
00:87E7 C90A            	   623:   cmp #NL
00:87E9 F0CA            	   624:   beq editor_no_closing_delimiterJ
00:87EB C5B4            	   625:   cmp find_delimiter
00:87ED D0F2            	   626:   bne editor_find_third_delimiter_loop
                        	   627: 
                        	   628: ;
                        	   629: ;  found the replacement closing delimiter
00:87EF 86B6            	   630:   stx rep_to
                        	   631: 
                        	   632: ;
                        	   633: ;  maximum 127 byte replacement string
                        	   634: ;
00:87F1 38              	   635:   sec
00:87F2 A5B6            	   636:   lda rep_to
00:87F4 E5B5            	   637:   sbc rep_from
00:87F6 30BA            	   638:   bmi find_string_too_longJ
                        	   639: 
                        	   640: ;
                        	   641: ;  now find the signed difference between the find and replace strings
                        	   642: ;  namely: (rep_to - rep_from) - find_len
                        	   643: ;
00:87F8 64B8            	   644:   stz rep_diff+1
00:87FA 38              	   645:   sec
00:87FB A5B6            	   646:   lda rep_to
00:87FD E5B5            	   647:   sbc rep_from
00:87FF E5B3            	   648:   sbc find_len
00:8801 85B7            	   649:   sta rep_diff
00:8803 1002            	   650:   bpl editor_find_get_flags
00:8805 C6B8            	   651:   dec rep_diff+1   ; make that $ff
                        	   652: 
                        	   653: ;
                        	   654: ; get any find/replace flags
                        	   655: ;
                        	   656: editor_find_get_flags:
00:8807 64BD            	   657:   stz find_flags
                        	   658: 
                        	   659: editor_flags_loop:
00:8809 E8              	   660:   inx
00:880A BD0002          	   661:   lda INBUF,X
00:880D C90A            	   662:   cmp #NL
00:880F F042            	   663:   beq editor_list_fix_target_string
00:8811 204A81          	   664:   jsr isspace
00:8814 B0F3            	   665:   bcs editor_flags_loop
00:8816 202D90          	   666:   jsr MAKE_UPPER
00:8819 C951            	   667:   cmp #'Q'
00:881B D00A            	   668:   bne editor_flags1
00:881D A904            	   669:   lda #FFLAG_QUIET
00:881F 04BD            	   670:   tsb find_flags
00:8821 A980            	   671:   lda #EFLAG_NO_LINE_NUMBERS
00:8823 04BC            	   672:   tsb editor_flags
00:8825 80E2            	   673:   bra editor_flags_loop
                        	   674: editor_flags1:
00:8827 C947            	   675:   cmp #'G'
00:8829 D006            	   676:   bne editor_flags2
00:882B A902            	   677:   lda #FFLAG_GLOBAL
00:882D 04BD            	   678:   tsb find_flags
00:882F 80D8            	   679:   bra editor_flags_loop
                        	   680: editor_flags2:
00:8831 C949            	   681:   cmp #'I'
00:8833 D006            	   682:   bne editor_flags3
00:8835 A901            	   683:   lda #FFLAG_IGNORE_CASE
00:8837 04BD            	   684:   tsb find_flags
00:8839 80CE            	   685:   bra editor_flags_loop
                        	   686: editor_flags3:
00:883B A945            	   687:   lda #<bad_flag_message
00:883D A288            	   688:   ldx #>bad_flag_message
00:883F 202682          	   689:   jsr print
00:8842 4CCC82          	   690:   jmp main_prompt
                        	   691: 
00:8845 556E6B6E6F776E20	   692: bad_flag_message: asciiz "Unknown flag\n"
00:884D 666C61670A
00:8852 00
                        	   693: 
                        	   694: editor_list_fix_target_string:
                        	   695: 
00:8853 A901            	   696:   lda #FFLAG_IGNORE_CASE
00:8855 25BD            	   697:   and find_flags
00:8857 F015            	   698:   beq editor_list_get_on_with_it
                        	   699: 
                        	   700: ;
                        	   701: ;  for case insensitive compare force target to be upper case
                        	   702: ;
00:8859 A6B0            	   703:   ldx find_from
                        	   704: editor_list_fixup_loop:
00:885B E4B1            	   705:   cpx find_to
00:885D F00F            	   706:   beq editor_list_get_on_with_it
00:885F BD0002          	   707:   lda INBUF,X
00:8862 202D90          	   708:   jsr MAKE_UPPER
00:8865 9D0002          	   709:   sta INBUF,X
00:8868 E8              	   710:   inx
00:8869 80F0            	   711:   bra editor_list_fixup_loop
                        	   712: 
                        	   713: 
                        	   714: editor_list_not_find:
                        	   715: ;
                        	   716: ;  we should have no more tokens now
                        	   717: ;
00:886B 205886          	   718:   jsr editor_check_no_more
                        	   719: 
                        	   720: editor_list_get_on_with_it:
                        	   721: ;
                        	   722: ;  make sure current_line is correct
                        	   723: ;
00:886E A59E            	   724:   lda from_line
00:8870 85A2            	   725:   sta current_line
00:8872 A59F            	   726:   lda from_line+1
00:8874 85A3            	   727:   sta current_line+1
                        	   728: 
                        	   729: ;
                        	   730: ;  exit immediately if no source from here on
                        	   731: ;
00:8876 A000            	   732:   ldy #0
00:8878 B123            	   733:   lda (PCODE),Y
00:887A D003            	   734:   bne editor_list_have_source
00:887C 4C9A89          	   735:   jmp editor_list_done
                        	   736: 
                        	   737: editor_list_have_source:
00:887F A901            	   738:   lda #EFLAG_SHOW_LINE
00:8881 04BC            	   739:   tsb editor_flags
00:8883 8006            	   740:   bra editor_list_loop
                        	   741: 
00:8885 4C9A89          	   742: editor_list_doneJ jmp editor_list_done
00:8888 4C5C89          	   743: editor_list_no_line_numberJ jmp editor_list_no_line_number
                        	   744: 
                        	   745: editor_list_loop:
00:888B A58B            	   746:   lda serial_in_byte_received
00:888D C903            	   747:   cmp  #KEY_ABORT
00:888F F021            	   748:   beq  editor_list_aborted
00:8891 64BB            	   749:   stz  found_this_line
00:8893 A000            	   750:   ldy #0
00:8895 B123            	   751:   lda (PCODE),Y
00:8897 F0EC            	   752:   beq editor_list_doneJ
00:8899 A5BC            	   753:   lda editor_flags
00:889B 2901            	   754:   and #EFLAG_SHOW_LINE
00:889D F0E9            	   755:   beq  editor_list_no_line_numberJ
00:889F A5BC            	   756:   lda editor_flags
00:88A1 2908            	   757:   and #EFLAG_SAVE
00:88A3 D0E3            	   758:   bne editor_list_no_line_numberJ
                        	   759: ;
                        	   760: ;  At this exact point we know we are at the start of a line
                        	   761: ;  and we aren't doing a Save. Now, if we are doing a Find then
                        	   762: ;  we need to know if this line (from here to the next newline)
                        	   763: ;  matches our find string, and if not, to skip it
                        	   764: 
00:88A5 A940            	   765:   lda #EFLAG_SUPPRESS_NEWLINE
00:88A7 14BC            	   766:   trb editor_flags              ; we can show newlines now
                        	   767: 
00:88A9 A5BC            	   768:   lda editor_flags
00:88AB 2910            	   769:   and #EFLAG_FIND
00:88AD D010            	   770:   bne editor_find_or_replacing
                        	   771: 
00:88AF 4C4F89          	   772:   jmp  editor_list_not_finding
                        	   773: 
                        	   774: ;
                        	   775: ;  Here when Ctrl+C pressed
                        	   776: ;
                        	   777: editor_list_aborted:
00:88B2 A232            	   778:   ldx #50
00:88B4 A000            	   779:   ldy #0
00:88B6 203E91          	   780:   jsr delay   ; 50 ms delay to allow serial to settle
00:88B9 209192          	   781:   jsr CROUT
00:88BC 4C9A89          	   782:   jmp editor_list_done
                        	   783: 
                        	   784: editor_find_or_replacing:
                        	   785: 
                        	   786: ;
                        	   787: ;  here if finding or replacing
                        	   788: ;
                        	   789: 
00:88BF A900            	   790:   lda #0
                        	   791: 
                        	   792: ;
                        	   793: ;  we come back here for multiple replacements with a new starting pos
                        	   794: ;
                        	   795: editor_replacement_loop:
00:88C1 85B2            	   796:   sta find_pos    ; searching line from beginning (or not, if doing a multiple replace)
                        	   797: 
                        	   798: editor_find_loop:
00:88C3 A6B0            	   799:   ldx find_from   ; out target string position in INBUF
00:88C5 A4B2            	   800:   ldy find_pos    ; where we are on the line
                        	   801: editor_find_inner_loop:
00:88C7 E4B1            	   802:   cpx find_to     ; reached end of target, found the string!
00:88C9 F037            	   803:   beq editor_find_found_it
00:88CB B123            	   804:   lda (PCODE),Y
00:88CD C90A            	   805:   cmp #NL
00:88CF F01B            	   806:   beq editor_find_no_match ; hit end of line without matching
                        	   807: 
                        	   808: ;
                        	   809: ;  force to upper-case if required
                        	   810: ;
00:88D1 48              	   811:   pha
00:88D2 A901            	   812:   lda #FFLAG_IGNORE_CASE
00:88D4 25BD            	   813:   and find_flags
00:88D6 F006            	   814:   beq editor_find_case_sensitive
00:88D8 68              	   815:   pla
00:88D9 202D90          	   816:   jsr MAKE_UPPER
00:88DC 8001            	   817:   bra editor_find_test_character
                        	   818: editor_find_case_sensitive:
00:88DE 68              	   819:   pla
                        	   820: editor_find_test_character:
00:88DF DD0002          	   821:   cmp INBUF,X     ; does source byte match target byte?
00:88E2 D004            	   822:   bne editor_find_skip_this
00:88E4 C8              	   823:   iny
00:88E5 E8              	   824:   inx
00:88E6 80DF            	   825:   bra editor_find_inner_loop
                        	   826: 
                        	   827: editor_find_skip_this:
00:88E8 E6B2            	   828:   inc find_pos
00:88EA D0D7            	   829:   bne editor_find_loop  ; if it wraps, give up
                        	   830: 
                        	   831: ;
                        	   832: ;  we are at the newline without a match, increment PCODE to match
                        	   833: ;  where we are and go onto newline processing
                        	   834: ;
                        	   835: editor_find_no_match:
00:88EC A5BB            	   836:    lda found_this_line
00:88EE D05F            	   837:    bne editor_list_not_finding
00:88F0 18              	   838:    clc
00:88F1 98              	   839:    tya
00:88F2 6523            	   840:    adc PCODE
00:88F4 8523            	   841:    sta PCODE
00:88F6 A900            	   842:    lda #0
00:88F8 6524            	   843:    adc PCODE+1
00:88FA 8524            	   844:    sta PCODE+1
00:88FC A940            	   845:    lda #EFLAG_SUPPRESS_NEWLINE
00:88FE 04BC            	   846:    tsb editor_flags
00:8900 8062            	   847:    bra editor_newline_processing
                        	   848: 
                        	   849: ;
                        	   850: ;  here when find succeeded
                        	   851: ;
                        	   852: editor_find_found_it:
00:8902 E6B9            	   853:   inc find_count
00:8904 D002            	   854:   bne editor_find_found_it1
00:8906 E6BA            	   855:   inc find_count+1
                        	   856: editor_find_found_it1:
00:8908 A901            	   857:   lda #1
00:890A 85BB            	   858:   sta found_this_line
00:890C A920            	   859:   lda #EFLAG_REPLACE
00:890E 25BC            	   860:   and editor_flags
00:8910 D00E            	   861:   bne editor_do_the_replace
                        	   862: 
00:8912 A902            	   863:   lda #FFLAG_GLOBAL
00:8914 25BD            	   864:   and find_flags
00:8916 F037            	   865:   beq editor_list_not_finding   ; one replace is enough
                        	   866: 
                        	   867: ;
                        	   868: ;  add the find length to Y (moving past what we just found)
                        	   869: ;
                        	   870: ;
00:8918 18              	   871:   clc
00:8919 A5B2            	   872:   lda find_pos
00:891B 65B3            	   873:   adc find_len
00:891D 4CC188          	   874:   jmp editor_replacement_loop
                        	   875: 
                        	   876: ;
                        	   877: ;  here when replacing
                        	   878: ;
                        	   879: editor_do_the_replace:
00:8920 A908            	   880:   lda #FLAG_VALID_COMPILE   ; compile or assemble no longer valid
00:8922 0910            	   881:   ora #FLAG_VALID_ASSEMBLE
00:8924 14BE            	   882:   trb system_flags
                        	   883: 
00:8926 A5B7            	   884:   lda rep_diff ; same length?
00:8928 F003            	   885:   beq editor_easy_replace
00:892A 4CBA89          	   886:   jmp editor_do_replace
                        	   887: 
                        	   888: editor_easy_replace:
00:892D A4B2            	   889:   ldy find_pos
00:892F A6B5            	   890:   ldx rep_from
                        	   891: editor_easy_replace_loop:
00:8931 E4B6            	   892:   cpx rep_to
00:8933 F009            	   893:   beq editor_easy_replace_done
00:8935 BD0002          	   894:   lda INBUF,x
00:8938 9123            	   895:   sta (PCODE),y
00:893A C8              	   896:   iny
00:893B E8              	   897:   inx
00:893C D0F3            	   898:   bne editor_easy_replace_loop  ; keep replacing
                        	   899: 
                        	   900: editor_easy_replace_done:
00:893E A902            	   901:   lda #FFLAG_GLOBAL
00:8940 25BD            	   902:   and find_flags
00:8942 F00B            	   903:   beq editor_list_not_finding   ; one replace is enough
                        	   904: 
                        	   905: ;
                        	   906: ;  add the replacement length to Y (moving past what we just replaced)
                        	   907: ;   the replacement length is rep_to - rep_from
                        	   908: ;
00:8944 18              	   909:   clc
00:8945 A5B2            	   910:   lda find_pos
00:8947 65B6            	   911:   adc rep_to
00:8949 38              	   912:   sec
00:894A E5B5            	   913:   sbc rep_from
00:894C 4CC188          	   914:   jmp editor_replacement_loop
                        	   915: 
                        	   916: ;
                        	   917: ;
                        	   918: ;  display the line number
                        	   919: ;
                        	   920: editor_list_not_finding:
00:894F A901            	   921:   lda #EFLAG_SHOW_LINE
00:8951 14BC            	   922:   trb editor_flags      ; cancel flag until next newline
00:8953 A980            	   923:   lda #EFLAG_NO_LINE_NUMBERS
00:8955 25BC            	   924:   and editor_flags
00:8957 D003            	   925:   bne editor_list_no_line_number
00:8959 205F8C          	   926:   jsr show_current_line_number
                        	   927: 
                        	   928: editor_list_no_line_number:
00:895C A000            	   929:   ldy  #0
00:895E B123            	   930:   lda  (PCODE),Y
00:8960 C90A            	   931:   cmp  #NL
00:8962 D022            	   932:   bne  editor_list_not_newline
                        	   933: 
                        	   934: editor_newline_processing:
00:8964 A901            	   935:   lda  #EFLAG_SHOW_LINE
00:8966 04BC            	   936:   tsb  editor_flags
00:8968 E6A2            	   937:   inc  current_line
00:896A D002            	   938:   bne  editor_list_check_to_line
00:896C E6A3            	   939:   inc  current_line+1
                        	   940: 
                        	   941: ;
                        	   942: ;  see if we hit the wanted "to" line
                        	   943: ;
                        	   944: editor_list_check_to_line:
00:896E A5A3            	   945:   lda  current_line+1
00:8970 C5A1            	   946:   cmp  to_line+1
00:8972 900A            	   947:   bcc  editor_list_check_to_line_ok
00:8974 D024            	   948:   bne  editor_list_done
00:8976 A5A2            	   949:   lda  current_line
00:8978 C5A0            	   950:   cmp  to_line
00:897A 9002            	   951:   bcc  editor_list_check_to_line_ok
00:897C D01C            	   952:   bne  editor_list_done
                        	   953: 
                        	   954: editor_list_check_to_line_ok:
                        	   955: 
00:897E A940            	   956:   lda #EFLAG_SUPPRESS_NEWLINE
00:8980 25BC            	   957:   and editor_flags
00:8982 D00D            	   958:   bne editor_list_skip_newline
00:8984 A90A            	   959:   lda #NL   ; put the newline back
                        	   960: 
                        	   961: ;
                        	   962: ;  just echo the character, and increment the memory address
                        	   963: ;
                        	   964: editor_list_not_newline:
00:8986 AA              	   965:   tax
00:8987 A904            	   966:   lda #FFLAG_QUIET
00:8989 25BD            	   967:   and find_flags
00:898B D004            	   968:   bne editor_list_skip_newline
00:898D 8A              	   969:   txa
00:898E 20EE92          	   970:   jsr PRCHAR
                        	   971: 
                        	   972: editor_list_skip_newline:
00:8991 E623            	   973:   inc PCODE
00:8993 D002            	   974:   bne editor_list_loopJ
00:8995 E624            	   975:   inc PCODE+1
                        	   976: 
                        	   977: editor_list_loopJ:
00:8997 4C8B88          	   978:   jmp editor_list_loop
                        	   979: 
                        	   980: editor_list_done:
00:899A 209192          	   981:   jsr CROUT
                        	   982: 
00:899D A5B9            	   983:   lda find_count
00:899F 05BA            	   984:   ora find_count+1
00:89A1 F014            	   985:   beq  editor_list_completely_done
00:89A3 A5B9            	   986:   lda find_count
00:89A5 8500            	   987:   sta REG
00:89A7 A5BA            	   988:   lda find_count+1
00:89A9 8501            	   989:   sta REG+1
00:89AB 6402            	   990:   stz REGB
00:89AD 20BB91          	   991:   jsr display_in_decimal
00:89B0 A9C7            	   992:   lda #<found_message
00:89B2 A286            	   993:   ldx #>found_message
00:89B4 202682          	   994:   jsr print
                        	   995: 
                        	   996: editor_list_completely_done:
00:89B7 4CCC82          	   997:   jmp main_prompt
                        	   998: 
                        	   999: ;
                        	  1000: ;  This if for replacing when the lengths differ
                        	  1001: ;
                        	  1002: editor_do_replace:
                        	  1003: ;
                        	  1004: ; add our current find_pos to PCODE to get where we are in memory
                        	  1005: ;
00:89BA 18              	  1006:   clc
00:89BB A523            	  1007:   lda  PCODE
00:89BD 48              	  1008:   pha   ; save where we currently are
00:89BE 65B2            	  1009:   adc  find_pos
00:89C0 85A6            	  1010:   sta  mem_move_src
00:89C2 A524            	  1011:   lda  PCODE+1
00:89C4 48              	  1012:   pha
00:89C5 6900            	  1013:   adc  #0
00:89C7 85A7            	  1014:   sta  mem_move_src+1
                        	  1015: 
                        	  1016: ;
                        	  1017: ;  add the source string length as we don't need to copy that
                        	  1018: ;
00:89C9 18              	  1019:   clc
00:89CA A5A6            	  1020:   lda mem_move_src
00:89CC 65B3            	  1021:   adc find_len
00:89CE 85A6            	  1022:   sta mem_move_src
00:89D0 A5A7            	  1023:   lda mem_move_src+1
00:89D2 6900            	  1024:   adc #0
00:89D4 85A7            	  1025:   sta mem_move_src+1
                        	  1026: 
                        	  1027: ;
                        	  1028: ;  the move destination is the source plus the replacement length
                        	  1029: ;   (ie. a gap of the difference in bytes)
                        	  1030: 
00:89D6 18              	  1031:   clc
00:89D7 A5A6            	  1032:   lda mem_move_src
00:89D9 65B7            	  1033:   adc rep_diff
00:89DB 85A8            	  1034:   sta mem_move_dest
00:89DD A5A7            	  1035:   lda mem_move_src+1
00:89DF 65B8            	  1036:   adc rep_diff+1
00:89E1 85A9            	  1037:   sta mem_move_dest+1
                        	  1038: 
                        	  1039: 
00:89E3 20D18C          	  1040:   jsr find_source_end   ; goes into PCODE
                        	  1041: ;
                        	  1042: ;  the length to move will be (the end of the source) - (the start of the move)
                        	  1043: ;
00:89E6 38              	  1044:   sec
00:89E7 A523            	  1045:   lda PCODE
00:89E9 E5A6            	  1046:   sbc mem_move_src
00:89EB 85AA            	  1047:   sta mem_move_len
00:89ED A524            	  1048:   lda PCODE+1
00:89EF E5A7            	  1049:   sbc mem_move_src+1
00:89F1 85AB            	  1050:   sta mem_move_len+1
                        	  1051: 
00:89F3 A5B8            	  1052:   lda rep_diff+1
00:89F5 3005            	  1053:   bmi editor_do_replace_smaller
00:89F7 20A681          	  1054:   jsr moveup      ; replacing with larger string
00:89FA 8003            	  1055:   bra editor_do_replace_copy_done
                        	  1056: 
                        	  1057: editor_do_replace_smaller:
00:89FC 207A81          	  1058:   jsr movedown    ; replacing with smaller string
                        	  1059: 
                        	  1060: editor_do_replace_copy_done:
                        	  1061: ;
                        	  1062: ;  get the current source address back
                        	  1063: ;
00:89FF 68              	  1064:   pla
00:8A00 8524            	  1065:   sta  PCODE+1
00:8A02 68              	  1066:   pla
00:8A03 8523            	  1067:   sta  PCODE
00:8A05 4C2D89          	  1068:   jmp  editor_easy_replace    ; now move in new string
                        	  1069: 
                        	  1070: 
00:8A08 456E74657220736F	  1071: load_message asciiz "Enter source, terminate with Esc\n"
00:8A10 757263652C207465
00:8A18 726D696E61746520
00:8A20 7769746820457363
00:8A28 0A
00:8A29 00
                        	  1072: 
                        	  1073: ;--------------------------------------------
                        	  1074: ;  INSERT / LOAD
                        	  1075: ;--------------------------------------------
                        	  1076: editor_load:
                        	  1077: 
00:8A2A A904            	  1078:   lda #EFLAG_LOAD
00:8A2C 85BC            	  1079:   sta editor_flags
                        	  1080: 
                        	  1081: editor_insert:
00:8A2E 207A85          	  1082:   jsr editor_get_number
00:8A31 9015            	  1083:   bcc editor_insert_at_start
                        	  1084: 
                        	  1085:   ;
                        	  1086:   ; I really want to insert AFTER this line so I'll add 1 to whatever line number they gave
                        	  1087:   ; To insert at the start use Insert without a line number
                        	  1088:   ;
00:8A33 18              	  1089:   clc
00:8A34 A594            	  1090:   lda token_value
00:8A36 6901            	  1091:   adc #1
00:8A38 85AC            	  1092:   sta this_line
00:8A3A A595            	  1093:   lda token_value+1
00:8A3C 6900            	  1094:   adc #0
00:8A3E 85AD            	  1095:   sta this_line+1
                        	  1096: 
00:8A40 205886          	  1097:   jsr editor_check_no_more
00:8A43 209D8C          	  1098:   jsr find_line    ; find the "from" line address
00:8A46 800E            	  1099:   bra editor_insert_common
                        	  1100: 
                        	  1101: editor_insert_at_start:
00:8A48 A900            	  1102:   lda #<TEXT_START
00:8A4A 85AE            	  1103:   sta this_line_addr
00:8A4C A903            	  1104:   lda #>TEXT_START
00:8A4E 85AF            	  1105:   sta this_line_addr+1
00:8A50 A901            	  1106:   lda #1
00:8A52 85A2            	  1107:   sta current_line    ; current line number (1)
00:8A54 64A3            	  1108:   stz current_line+1
                        	  1109: 
                        	  1110: editor_insert_common:
00:8A56 20D18C          	  1111:   jsr find_source_end
                        	  1112: 
                        	  1113: ;
                        	  1114: ;  move existing source to end of RAM
                        	  1115: ;
00:8A59 38              	  1116:   sec
00:8A5A A523            	  1117:   lda PCODE
00:8A5C E5AE            	  1118:   sbc this_line_addr
00:8A5E 85AA            	  1119:   sta mem_move_len
00:8A60 A524            	  1120:   lda PCODE+1
00:8A62 E5AF            	  1121:   sbc this_line_addr+1
00:8A64 85AB            	  1122:   sta mem_move_len+1
                        	  1123: 
                        	  1124: ;
                        	  1125: ;  find where to move to
                        	  1126: ;
00:8A66 38              	  1127:   sec
00:8A67 A9FF            	  1128:   lda #<HIGHEST_RAM
00:8A69 E5AA            	  1129:   sbc mem_move_len
00:8A6B 85A8            	  1130:   sta mem_move_dest
00:8A6D 85A4            	  1131:   sta insert_limit
00:8A6F A93F            	  1132:   lda #>HIGHEST_RAM
00:8A71 E5AB            	  1133:   sbc mem_move_len+1
00:8A73 85A9            	  1134:   sta mem_move_dest+1
00:8A75 85A5            	  1135:   sta insert_limit+1
                        	  1136: 
                        	  1137: ;
                        	  1138: ;  the source of the move
                        	  1139: ;
00:8A77 A5AE            	  1140:   lda this_line_addr
00:8A79 85A6            	  1141:   sta mem_move_src
00:8A7B A5AF            	  1142:   lda this_line_addr+1
00:8A7D 85A7            	  1143:   sta mem_move_src+1
                        	  1144: 
00:8A7F 20A681          	  1145:   jsr moveup
                        	  1146: 
                        	  1147: ;
                        	  1148: ;  put input at from_line_addr
                        	  1149: ;
                        	  1150: 
00:8A82 A5AE            	  1151:   lda this_line_addr
00:8A84 8523            	  1152:   sta PCODE
00:8A86 A5AF            	  1153:   lda this_line_addr+1
00:8A88 8524            	  1154:   sta PCODE+1
                        	  1155: 
00:8A8A A908            	  1156:   lda  #<load_message
00:8A8C A28A            	  1157:   ldx  #>load_message
00:8A8E 202682          	  1158:   jsr  print
                        	  1159: 
                        	  1160: ;
                        	  1161: ;  show the first line number
                        	  1162: ;
                        	  1163: 
00:8A91 A901            	  1164:   lda #EFLAG_SHOW_LINE
00:8A93 04BC            	  1165:   tsb editor_flags
00:8A95 A000            	  1166:   ldy #0    ; offset from PCODE for inserting (should always be zero)
00:8A97 A200            	  1167:   ldx #0    ; last character we inserted
                        	  1168: 
                        	  1169: editor_insert_loop:
00:8A99 A904            	  1170:   lda #EFLAG_LOAD         ; no line numbers on load
00:8A9B 25BC            	  1171:   and editor_flags
00:8A9D D00B            	  1172:   bne editor_insert_no_line_number
                        	  1173: 
00:8A9F A5BC            	  1174:   lda editor_flags
00:8AA1 2901            	  1175:   and #EFLAG_SHOW_LINE
00:8AA3 F005            	  1176:   beq  editor_insert_no_line_number
                        	  1177: ;
                        	  1178: ;  display the line number
                        	  1179: ;
                        	  1180: 
00:8AA5 64BC            	  1181:   stz editor_flags      ; cancel flag until next newline
00:8AA7 205F8C          	  1182:   jsr show_current_line_number
                        	  1183: 
                        	  1184: editor_insert_no_line_number:
00:8AAA 200EC9          	  1185:   jsr  CHRIN
00:8AAD C90D            	  1186:   cmp  #CR                          ; carriage-return?
00:8AAF F0F9            	  1187:   beq  editor_insert_no_line_number ; yes, ignore
00:8AB1 C91B            	  1188:   cmp  #END_EDITOR_INPUT            ; Esc?
00:8AB3 F04F            	  1189:   beq  editor_insert_done
00:8AB5 C908            	  1190:   cmp  #BACKSPACE
00:8AB7 F029            	  1191:   beq  editor_insert_backspace
00:8AB9 C90A            	  1192:   cmp  #NL
00:8ABB D00C            	  1193:   bne  editor_insert_not_newline
00:8ABD A901            	  1194:   lda  #EFLAG_SHOW_LINE
00:8ABF 04BC            	  1195:   tsb  editor_flags
00:8AC1 A90A            	  1196:   lda  #NL            ; get the newline back
00:8AC3 E6A2            	  1197:   inc  current_line
00:8AC5 D002            	  1198:   bne  editor_insert_not_newline
00:8AC7 E6A3            	  1199:   inc  current_line+1
                        	  1200: editor_insert_not_newline:
00:8AC9 9123            	  1201:   sta  (PCODE),y
00:8ACB AA              	  1202:   tax                ; for detecting final newline
00:8ACC E623            	  1203:   inc  PCODE
00:8ACE D002            	  1204:   bne  editor_insert_loop1
00:8AD0 E624            	  1205:   inc  PCODE+1
                        	  1206: 
                        	  1207: editor_insert_loop1:
00:8AD2 A5A5            	  1208:   lda  insert_limit+1
00:8AD4 C524            	  1209:   cmp  PCODE+1
00:8AD6 B0C1            	  1210:   bcs  editor_insert_loop   ; carry is SET if we didn't borrow
00:8AD8 D056            	  1211:   bne  editor_too_full
00:8ADA A5A4            	  1212:   lda  insert_limit
00:8ADC C523            	  1213:   cmp  PCODE
00:8ADE F050            	  1214:   beq  editor_too_full
00:8AE0 80B7            	  1215:   bra  editor_insert_loop
                        	  1216: 
                        	  1217: ;
                        	  1218: ;  backspace reduces our pointer by one, unless we are at the start
                        	  1219: ;
                        	  1220: editor_insert_backspace:
00:8AE2 A523            	  1221:   lda PCODE
00:8AE4 C5AE            	  1222:   cmp this_line_addr
00:8AE6 D006            	  1223:   bne editor_insert_backspace_not_at_start
00:8AE8 A524            	  1224:   lda PCODE+1
00:8AEA C5AF            	  1225:   cmp this_line_addr+1
00:8AEC F0AB            	  1226:   beq editor_insert_loop    ; at start, ignore backspace
                        	  1227: 
                        	  1228: editor_insert_backspace_not_at_start:
00:8AEE 38              	  1229:   sec                       ; move source pointer back one
00:8AEF A523            	  1230:   lda PCODE
00:8AF1 E901            	  1231:   sbc #1
00:8AF3 8523            	  1232:   sta PCODE
00:8AF5 A524            	  1233:   lda PCODE+1
00:8AF7 E900            	  1234:   sbc #0
00:8AF9 8524            	  1235:   sta PCODE+1
00:8AFB B123            	  1236:   lda (PCODE),y
00:8AFD AA              	  1237:   tax                      ; this is now the last character we inserted
                        	  1238: ;
                        	  1239: ;  however we don't want them backspacing over a previous line, so if we detect a newline
                        	  1240: ;  just go back up and put it back (and increment PCODE back to where it was)
                        	  1241: ;
00:8AFE C90A            	  1242:   cmp #NL
00:8B00 F0C7            	  1243:   beq editor_insert_not_newline
00:8B02 8095            	  1244:   bra editor_insert_loop
                        	  1245: 
                        	  1246: editor_insert_done:
00:8B04 8A              	  1247:   txa
00:8B05 F00E            	  1248:   beq editor_insert_done_with_newline   ; nothing got inserted at all
00:8B07 C90A            	  1249:   cmp #NL
00:8B09 F00A            	  1250:   beq editor_insert_done_with_newline  ; skip inserting a newline if we just got a newline
                        	  1251: ;
                        	  1252: ;  They finished inserting, but without a newline ... add one
                        	  1253: ;
00:8B0B A90A            	  1254:   lda #NL
00:8B0D 9123            	  1255:   sta (PCODE),y
00:8B0F E623            	  1256:   inc PCODE
00:8B11 D002            	  1257:   bne editor_insert_done_with_newline
00:8B13 E624            	  1258:   inc PCODE+1
                        	  1259: 
                        	  1260: ;
                        	  1261: ;  they are done - copy the rest back to the end of where they just inserted
                        	  1262: ;
                        	  1263: editor_insert_done_with_newline:
                        	  1264: 
00:8B15 64BE            	  1265:   stz system_flags     ; compile is not valid any more
                        	  1266: 
00:8B17 A523            	  1267:   lda PCODE
00:8B19 85A8            	  1268:   sta mem_move_dest
00:8B1B A524            	  1269:   lda PCODE+1
00:8B1D 85A9            	  1270:   sta mem_move_dest+1
                        	  1271: 
00:8B1F A5A4            	  1272:   lda insert_limit
00:8B21 85A6            	  1273:   sta mem_move_src
00:8B23 A5A5            	  1274:   lda insert_limit+1
00:8B25 85A7            	  1275:   sta mem_move_src+1
                        	  1276: 
00:8B27 207A81          	  1277:   jsr movedown
                        	  1278: 
00:8B2A 209192          	  1279:   jsr CROUT   ; put a newline after the ESC character
00:8B2D 4CCC82          	  1280:   jmp main_prompt
                        	  1281: 
                        	  1282: editor_too_full:
00:8B30 A95B            	  1283:   lda #<memory_full
00:8B32 A28B            	  1284:   ldx #>memory_full
00:8B34 202682          	  1285:   jsr print
                        	  1286: ;
                        	  1287: ;  consume input so it isn't mistaken for a command
                        	  1288: ;
                        	  1289: editor_too_full_loop:
00:8B37 200EC9          	  1290:   jsr CHRIN
00:8B3A C91B            	  1291:   cmp #END_EDITOR_INPUT
00:8B3C D0F9            	  1292:   bne editor_too_full_loop
                        	  1293: ;
                        	  1294: ;  another message, they may miss the first one during a bulk load
                        	  1295: ;
00:8B3E A976            	  1296:   lda #<memory_filled_up
00:8B40 A28B            	  1297:   ldx #>memory_filled_up
00:8B42 202682          	  1298:   jsr print
00:8B45 4C048B          	  1299:   jmp editor_insert_done
                        	  1300: 
00:8B48 4E6F2072616E6765	  1301: editor_no_lines  asciiz "No range supplied\n"
00:8B50 20737570706C6965
00:8B58 640A
00:8B5A 00
00:8B5B 0A0A4D656D6F7279	  1302: memory_full      asciiz "\n\nMemory full - press Esc\n"
00:8B63 2066756C6C202D20
00:8B6B 7072657373204573
00:8B73 630A
00:8B75 00
00:8B76 0A0A4E6F20726F6F	  1303: memory_filled_up asciiz "\n\nNo room for source during load/input\n\n"
00:8B7E 6D20666F7220736F
00:8B86 7572636520647572
00:8B8E 696E67206C6F6164
00:8B96 2F696E7075740A0A
00:8B9E 00
                        	  1304: 
                        	  1305: ;
                        	  1306: ;  subroutine to check we got a range for certain actions
                        	  1307: ;
                        	  1308: editor_argument_check:
00:8B9F A000            	  1309:   ldy #0
                        	  1310: ;
                        	  1311: ;  skip spaces to make sure we got a range
                        	  1312: ;
                        	  1313: editor_argument_check_loop:
00:8BA1 B18E            	  1314:   lda (token_start),y
00:8BA3 F00C            	  1315:   beq editor_argument_check_failed
00:8BA5 C90A            	  1316:   cmp #NL
00:8BA7 F008            	  1317:   beq editor_argument_check_failed
00:8BA9 204A81          	  1318:   jsr isspace
00:8BAC 900D            	  1319:   bcc editor_argument_check_got_argument
00:8BAE C8              	  1320:   iny
00:8BAF D0F0            	  1321:   bne editor_argument_check_loop
                        	  1322: 
                        	  1323: ;
                        	  1324: ;  only found spaces, not good enough
                        	  1325: ;
                        	  1326: editor_argument_check_failed:
00:8BB1 A948            	  1327:   lda #<editor_no_lines
00:8BB3 A28B            	  1328:   ldx #>editor_no_lines
00:8BB5 202682          	  1329:   jsr print
00:8BB8 4CCC82          	  1330:   jmp  main_prompt
                        	  1331: 
                        	  1332: editor_argument_check_got_argument:
00:8BBB 60              	  1333:   rts
                        	  1334: 
                        	  1335: 
                        	  1336: ;--------------------------------------------
                        	  1337: ;  DELETE
                        	  1338: ;--------------------------------------------
                        	  1339: editor_delete:
                        	  1340: ;
                        	  1341: ;  default to no lines
                        	  1342: ;
00:8BBC 649E            	  1343:   stz from_line
00:8BBE 649F            	  1344:   stz from_line+1
00:8BC0 64A0            	  1345:   stz to_line
00:8BC2 64A1            	  1346:   stz to_line+1
                        	  1347: 
00:8BC4 64B9            	  1348:   stz find_count      ; delete count in this case
00:8BC6 64BA            	  1349:   stz find_count+1
00:8BC8 209F8B          	  1350:   jsr editor_argument_check ; cannot get away with no arguments
                        	  1351: 
00:8BCB 207586          	  1352:   jsr editor_get_range
00:8BCE 205886          	  1353:   jsr editor_check_no_more
                        	  1354: 
00:8BD1 A59E            	  1355:   lda from_line
00:8BD3 85AC            	  1356:   sta this_line
00:8BD5 A59F            	  1357:   lda from_line+1
00:8BD7 85AD            	  1358:   sta this_line+1
00:8BD9 209D8C          	  1359:   jsr find_line       ; find the "from" line address
00:8BDC A5AE            	  1360:   lda this_line_addr  ; that becomes the destination of the move
00:8BDE 85A8            	  1361:   sta mem_move_dest
00:8BE0 A5AF            	  1362:   lda this_line_addr+1
00:8BE2 85A9            	  1363:   sta mem_move_dest+1
00:8BE4 64AA            	  1364:   stz mem_move_len
00:8BE6 64AB            	  1365:   stz mem_move_len+1
                        	  1366: ;
                        	  1367: ;  now we'll work our way up until we get to the to_line, however we'll
                        	  1368: ;  add one because we want the final address to actually be the start of
                        	  1369: ;  the NEXT line
                        	  1370: ;
00:8BE8 18              	  1371:   clc
00:8BE9 A5A0            	  1372:   lda to_line
00:8BEB 6901            	  1373:   adc #1
00:8BED 85AC            	  1374:   sta this_line
00:8BEF A5A1            	  1375:   lda to_line+1
00:8BF1 6900            	  1376:   adc #0
00:8BF3 85AD            	  1377:   sta this_line+1
00:8BF5 20AB8C          	  1378:   jsr find_line_loop    ; find the "to" line address
00:8BF8 A5AE            	  1379:   lda this_line_addr  ; that becomes the destination of the move
00:8BFA 85A6            	  1380:   sta mem_move_src
00:8BFC A5AF            	  1381:   lda this_line_addr+1
00:8BFE 85A7            	  1382:   sta mem_move_src+1
                        	  1383: 
                        	  1384: ;
                        	  1385: ;  count how many lines we delete by counting newlines from
                        	  1386: ;   mem_move_dest to mem_move_src
                        	  1387: ;
                        	  1388: 
00:8C00 A5A8            	  1389:   lda mem_move_dest
00:8C02 8523            	  1390:   sta PCODE
00:8C04 A5A9            	  1391:   lda mem_move_dest+1
00:8C06 8524            	  1392:   sta PCODE+1
00:8C08 A000            	  1393:   ldy #0
                        	  1394: 
                        	  1395: editor_delete_line_count_loop:
00:8C0A A523            	  1396:   lda PCODE
00:8C0C C5A6            	  1397:   cmp mem_move_src
00:8C0E D006            	  1398:   bne editor_delete_line_count_not_done
00:8C10 A524            	  1399:   lda PCODE+1
00:8C12 C5A7            	  1400:   cmp mem_move_src+1
00:8C14 F014            	  1401:   beq editor_delete_line_count_done
                        	  1402: 
                        	  1403: editor_delete_line_count_not_done:
00:8C16 B123            	  1404:   lda (PCODE),y
00:8C18 C90A            	  1405:   cmp #NL
00:8C1A D006            	  1406:   bne editor_delete_line_count_not_newline
00:8C1C E6B9            	  1407:   inc find_count
00:8C1E D002            	  1408:   bne editor_delete_line_count_not_newline
00:8C20 E6BA            	  1409:   inc find_count+1
                        	  1410: editor_delete_line_count_not_newline:
00:8C22 E623            	  1411:   inc PCODE
00:8C24 D0E4            	  1412:   bne editor_delete_line_count_loop
00:8C26 E624            	  1413:   inc PCODE+1
00:8C28 80E0            	  1414:   bra editor_delete_line_count_loop
                        	  1415: 
                        	  1416: ;
                        	  1417: ;  now find where the source ends
                        	  1418: ;  PCODE will now be at the first line to not be deleted
                        	  1419: ;
                        	  1420: editor_delete_line_count_done:
                        	  1421: 
00:8C2A 20D98C          	  1422:   jsr find_source_end_loop
00:8C2D 38              	  1423:   sec
00:8C2E A523            	  1424:   lda PCODE
00:8C30 E5AE            	  1425:   sbc this_line_addr
00:8C32 85AA            	  1426:   sta mem_move_len
00:8C34 A524            	  1427:   lda PCODE+1
00:8C36 E5AF            	  1428:   sbc this_line_addr+1
00:8C38 85AB            	  1429:   sta mem_move_len+1
00:8C3A 207A81          	  1430:   jsr movedown  ; that should do it
                        	  1431: 
00:8C3D A5B9            	  1432:   lda find_count
00:8C3F 8500            	  1433:   sta REG
00:8C41 A5BA            	  1434:   lda find_count+1
00:8C43 8501            	  1435:   sta REG+1
00:8C45 6402            	  1436:   stz REGB
00:8C47 20BB91          	  1437:   jsr display_in_decimal
00:8C4A A954            	  1438:   lda #<lines_deleted_message
00:8C4C A28C            	  1439:   ldx #>lines_deleted_message
00:8C4E 202682          	  1440:   jsr print
00:8C51 4CCC82          	  1441:   jmp main_prompt
                        	  1442: 
00:8C54 2064656C65746564	  1443: lines_deleted_message asciiz " deleted.\n"
00:8C5C 2E0A
00:8C5E 00
                        	  1444: 
                        	  1445: ;--------------------------------------------
                        	  1446: ;  show current line number with leading spaces
                        	  1447: ;--------------------------------------------
                        	  1448: show_current_line_number:
00:8C5F 48              	  1449:   pha
00:8C60 DA              	  1450:   phx
00:8C61 5A              	  1451:   phy
                        	  1452: ;
                        	  1453: ;  get the line number into REG ready for printing
                        	  1454: ;
00:8C62 A5A2            	  1455:   lda current_line
00:8C64 8500            	  1456:   sta REG
00:8C66 A6A3            	  1457:   ldx current_line+1
00:8C68 8601            	  1458:   stx REG+1
00:8C6A A000            	  1459:   ldy #0        ; count of leading spaces
00:8C6C 8402            	  1460:   sty REGB
00:8C6E E003            	  1461:   cpx #>1000    ; if the number is >= 1000 don't print any spaces
00:8C70 9006            	  1462:   bcc line_number_lt_1000
00:8C72 D013            	  1463:   bne line_number_output_spaces
00:8C74 C9E8            	  1464:   cmp #<1000
00:8C76 B00F            	  1465:   bcs line_number_output_spaces
                        	  1466: line_number_lt_1000:
00:8C78 C8              	  1467:   iny           ; output one space
00:8C79 E000            	  1468:   cpx  #0       ; if line number > 255 then one space is all we need
00:8C7B D00A            	  1469:   bne  line_number_output_spaces
00:8C7D C964            	  1470:   cmp  #100     ; if line number >= 100 then one space is all we need
00:8C7F B006            	  1471:   bcs  line_number_output_spaces
00:8C81 C8              	  1472:   iny           ; output two spaces
00:8C82 C90A            	  1473:   cmp  #10      ; if line number >= 10 then two spaces are all we need
00:8C84 B001            	  1474:   bcs  line_number_output_spaces
00:8C86 C8              	  1475:   iny           ; output three spaces
                        	  1476: line_number_output_spaces:
00:8C87 C000            	  1477:   cpy #0            ; leading spaces in front of line number
00:8C89 F008            	  1478:   beq  show_current_line_number_done
00:8C8B 5A              	  1479:   phy
00:8C8C 201C93          	  1480:   jsr  PUTSP      ; output the space
00:8C8F 7A              	  1481:   ply
00:8C90 88              	  1482:   dey             ; count them
00:8C91 D0F4            	  1483:   bne  line_number_output_spaces  ; more spaces to go
                        	  1484: show_current_line_number_done:
00:8C93 20BB91          	  1485:   jsr  display_in_decimal    ; now the actual number
00:8C96 201C93          	  1486:   jsr  PUTSP      ; and a space after it
00:8C99 7A              	  1487:   ply
00:8C9A FA              	  1488:   plx
00:8C9B 68              	  1489:   pla
00:8C9C 60              	  1490:   rts
                        	  1491: 
                        	  1492: ;--------------------------------------------
                        	  1493: ;  find_line
                        	  1494: ;
                        	  1495: ;  finds address of this_line in memory - returns in this_line_addr
                        	  1496: ;--------------------------------------------
                        	  1497: find_line:
00:8C9D A901            	  1498:   lda #1
00:8C9F 85A2            	  1499:   sta current_line    ; current line number (1)
00:8CA1 64A3            	  1500:   stz current_line+1
00:8CA3 A900            	  1501:   lda #<TEXT_START   ; start at start of source
00:8CA5 85AE            	  1502:   sta this_line_addr
00:8CA7 A903            	  1503:   lda #>TEXT_START
00:8CA9 85AF            	  1504:   sta this_line_addr+1
                        	  1505: find_line_loop:
00:8CAB A000            	  1506:   ldy #0
00:8CAD A5A2            	  1507:   lda current_line
00:8CAF C5AC            	  1508:   cmp this_line
00:8CB1 D007            	  1509:   bne find_line_next
00:8CB3 A5A3            	  1510:   lda current_line+1
00:8CB5 C5AD            	  1511:   cmp this_line+1
00:8CB7 D001            	  1512:   bne find_line_next
00:8CB9 60              	  1513:   rts
                        	  1514: find_line_next:
00:8CBA B1AE            	  1515:   lda (this_line_addr),Y
00:8CBC F012            	  1516:   beq find_line_eof
00:8CBE C90A            	  1517:   cmp #NL
00:8CC0 D006            	  1518:   bne find_line_same_line
00:8CC2 E6A2            	  1519:   inc current_line       ; add 1 to our line number counter
00:8CC4 D002            	  1520:   bne find_line_same_line
00:8CC6 E6A3            	  1521:   inc current_line+1
                        	  1522: find_line_same_line:
00:8CC8 E6AE            	  1523:   inc this_line_addr     ; onto next address - which means that a newline
00:8CCA D0DF            	  1524:   bne find_line_loop     ; will actually end up being the start of the new
00:8CCC E6AF            	  1525:   inc this_line_addr+1   ; line, which is what we want
00:8CCE 80DB            	  1526:   bra find_line_loop
                        	  1527: find_line_eof:           ; we are pointing to 0x00 - make that the address
00:8CD0 60              	  1528:   rts
                        	  1529: 
                        	  1530: 
                        	  1531: 
                        	  1532: ;***********************************************
                        	  1533: ; Find text end
                        	  1534: ;***********************************************
                        	  1535: find_source_end:
00:8CD1 A900            	  1536:   lda  #<TEXT_START        ; start at start of source
00:8CD3 8523            	  1537:   sta  PCODE
00:8CD5 A903            	  1538:   lda  #>TEXT_START
00:8CD7 8524            	  1539:   sta  PCODE+1
                        	  1540: find_source_end_loop =  *
00:8CD9 A000            	  1541:   ldy  #0
00:8CDB B123            	  1542:   lda  (PCODE),Y             ; keep going until 0x00 indicates end of source
00:8CDD F008            	  1543:   beq  find_source_end_wrap
00:8CDF E623            	  1544:   inc  PCODE
00:8CE1 D0F6            	  1545:   bne  find_source_end_loop
00:8CE3 E624            	  1546:   inc  PCODE+1
00:8CE5 80F2            	  1547:   bra  find_source_end_loop
                        	  1548: ;
                        	  1549: ;  include final 0x00
                        	  1550: ;
                        	  1551: find_source_end_wrap =  *
00:8CE7 E623            	  1552:   inc  PCODE
00:8CE9 D002            	  1553:   bne  find_source_end_done
00:8CEB E624            	  1554:   inc  PCODE+1
                        	  1555: find_source_end_done =  *
00:8CED 60              	  1556:   rts
                        	  1557: 
                        	  1558: ;
                        	  1559: ;  testing BRK handling
                        	  1560: ;
00:8CEE 0A526573756D6564	  1561: brk_resumed asciiz "\nResumed after BRK\n"
00:8CF6 2061667465722042
00:8CFE 524B0A
00:8D01 00
                        	  1562: 
                        	  1563: editor_test:
00:8D02 A912            	  1564:   lda #$12
00:8D04 A223            	  1565:   ldx #$23
00:8D06 A042            	  1566:   ldy #$42
00:8D08 C912            	  1567:   cmp #$12
00:8D0A 00              	  1568:   brk
00:8D0B 99              	  1569:   dfb $99   ; break number
00:8D0C A9EE            	  1570:   lda #<brk_resumed
00:8D0E A28C            	  1571:   ldx #>brk_resumed
00:8D10 202682          	  1572:   jsr print
00:8D13 60              	  1573:   rts
                        	  1574: 
                        	  1575: ;
                        	  1576: ;  memory dump
                        	  1577: ;
                        	  1578: editor_memory:
00:8D14 209F8B          	  1579:   jsr editor_argument_check  ; check they supplied some sort of range
00:8D17 205285          	  1580:   jsr editor_default_range
00:8D1A A902            	  1581:   lda #EFLAG_ALLOW_ZERO_FROM
00:8D1C 85BC            	  1582:   sta editor_flags
00:8D1E 207586          	  1583:   jsr editor_get_range
00:8D21 205886          	  1584:   jsr editor_check_no_more
00:8D24 64A2            	  1585:   stz current_line      ; count of bytes shown
00:8D26 A59E            	  1586:   lda from_line
00:8D28 85AE            	  1587:   sta this_line_addr
00:8D2A A59F            	  1588:   lda from_line+1
00:8D2C 85AF            	  1589:   sta this_line_addr+1
                        	  1590: 
                        	  1591: editor_memory_loop:
00:8D2E A58B            	  1592:   lda serial_in_byte_received
00:8D30 C903            	  1593:   cmp  #KEY_ABORT
00:8D32 F056            	  1594:   beq  editor_memory_aborted
                        	  1595: 
00:8D34 A5A2            	  1596:   lda current_line
00:8D36 D017            	  1597:   bne editor_memory_loop1
                        	  1598: ;
                        	  1599: ;  show address
                        	  1600: ;
00:8D38 A924            	  1601:   lda #'$'
00:8D3A 201894          	  1602:   jsr COUT
00:8D3D A59F            	  1603:   lda from_line+1
00:8D3F 200693          	  1604:   jsr PRBYTE
00:8D42 A59E            	  1605:   lda from_line
00:8D44 200693          	  1606:   jsr PRBYTE
00:8D47 A93A            	  1607:   lda #':'
00:8D49 201894          	  1608:   jsr COUT
00:8D4C 201C93          	  1609:   jsr PUTSP
                        	  1610: editor_memory_loop1:
00:8D4F A000            	  1611:   ldy #0
00:8D51 B19E            	  1612:   lda (from_line),Y
00:8D53 200693          	  1613:   jsr PRBYTE
00:8D56 201C93          	  1614:   jsr PUTSP
00:8D59 E6A2            	  1615:   inc current_line
00:8D5B E69E            	  1616:   inc from_line
00:8D5D D002            	  1617:   bne editor_memory_loop2
00:8D5F E69F            	  1618:   inc from_line+1
                        	  1619: editor_memory_loop2:
                        	  1620: ;
                        	  1621: ;  if we wrap around back to zero, stop
                        	  1622: ;
00:8D61 A59E            	  1623:   lda from_line
00:8D63 059F            	  1624:   ora from_line+1
00:8D65 F020            	  1625:   beq editor_memory_done
00:8D67 A59F            	  1626:   lda from_line+1
00:8D69 C5A1            	  1627:   cmp to_line+1
00:8D6B 900A            	  1628:   bcc editor_memory_loop3   ; less than
00:8D6D D018            	  1629:   bne editor_memory_done    ; greater than
00:8D6F A59E            	  1630:   lda from_line             ; equal, so try low-order byte
00:8D71 C5A0            	  1631:   cmp to_line
00:8D73 9002            	  1632:   bcc editor_memory_loop3   ; less than
00:8D75 D010            	  1633:   bne editor_memory_done    ; greater than
                        	  1634: editor_memory_loop3:
00:8D77 A5A2            	  1635:   lda current_line
00:8D79 C910            	  1636:   cmp #16
00:8D7B 90B1            	  1637:   bcc editor_memory_loop
00:8D7D 201C93          	  1638:   jsr PUTSP
00:8D80 20908D          	  1639:   jsr editor_memory_show_ascii
00:8D83 64A2            	  1640:   stz current_line      ; count of bytes shown
00:8D85 80A7            	  1641:   bra editor_memory_loop
                        	  1642: 
                        	  1643: editor_memory_done:
00:8D87 20908D          	  1644:   jsr editor_memory_show_ascii
                        	  1645: editor_memory_aborted:
00:8D8A 209192          	  1646:   jsr CROUT
00:8D8D 4CCC82          	  1647:   jmp  main_prompt
                        	  1648: 
                        	  1649: editor_memory_show_ascii:
                        	  1650: ;
                        	  1651: ;  now the ASCII equivalents
                        	  1652: ;
00:8D90 A000            	  1653:   ldy #0
                        	  1654: editor_memory_ascii:
00:8D92 B1AE            	  1655:   lda (this_line_addr),Y
00:8D94 C920            	  1656:   cmp #$20
00:8D96 B002            	  1657:   bcs editor_memory_not_control
00:8D98 8004            	  1658:   bra editor_memory_show_dot
                        	  1659: editor_memory_not_control:
00:8D9A C97F            	  1660:   cmp #$7F
00:8D9C 9002            	  1661:   bcc editor_memory_not_high
                        	  1662: editor_memory_show_dot
00:8D9E A92E            	  1663:   lda #'.'
                        	  1664: editor_memory_not_high:
00:8DA0 201894          	  1665:   jsr COUT
00:8DA3 201C93          	  1666:   jsr PUTSP
00:8DA6 C8              	  1667:   iny
00:8DA7 C6A2            	  1668:   dec current_line
00:8DA9 D0E7            	  1669:   bne editor_memory_ascii
                        	  1670: ;
                        	  1671: ;  adjust the ASCII printing address
                        	  1672: ;
00:8DAB A59E            	  1673:   lda from_line
00:8DAD 85AE            	  1674:   sta this_line_addr
00:8DAF A59F            	  1675:   lda from_line+1
00:8DB1 85AF            	  1676:   sta this_line_addr+1
                        	  1677: 
00:8DB3 209192          	  1678:   jsr CROUT
00:8DB6 60              	  1679:   rts
                        	  1680: 
                        	  1681: 
                        	  1682: 
                        	  1683: 
00:8DB7 4164647220507265	  1684: symbol_table_message asciiz "Addr Prev L  T Dsp  Ar Da Ln Name\n"
00:8DBF 76204C2020542044
00:8DC7 7370202041722044
00:8DCF 61204C6E204E616D
00:8DD7 650A
00:8DD9 00
                        	  1685: 
                        	  1686: editor_symbol_table_list  = *
00:8DDA A9B7            	  1687:   lda #<symbol_table_message
00:8DDC A28D            	  1688:   ldx #>symbol_table_message
00:8DDE 202682          	  1689:   jsr print
                        	  1690: 
00:8DE1 A532            	  1691:   lda  ENDSYM+1    ; get the end of the symbol table
00:8DE3 8541            	  1692:   sta  SYMITM+1    ; make it the current symbol
00:8DE5 A531            	  1693:   lda  ENDSYM
00:8DE7 800B            	  1694:   bra  ST_SYMTBL_LIST_CHECK
                        	  1695: 
                        	  1696: ST_SYMTBL_LIST_NEXT =  *
00:8DE9 A000            	  1697:   ldy  #SYMPRV
00:8DEB B140            	  1698:   lda  (SYMITM),Y
00:8DED AA              	  1699:   tax
00:8DEE C8              	  1700:   iny
00:8DEF B140            	  1701:   lda  (SYMITM),Y
00:8DF1 8541            	  1702:   sta  SYMITM+1   ; previous link
00:8DF3 8A              	  1703:   txa
                        	  1704: ;
                        	  1705: ;  go to the previous symbol table item
                        	  1706: ;
                        	  1707: ST_SYMTBL_LIST_CHECK     =  *
00:8DF4 8540            	  1708:   sta  SYMITM
00:8DF6 C9FF            	  1709:   cmp  #<SYMBOL_TABLE_START
00:8DF8 D009            	  1710:   bne  ST_SYMTBL_LIST_LINE
00:8DFA A541            	  1711:   lda  SYMITM+1
00:8DFC C93F            	  1712:   cmp  #>SYMBOL_TABLE_START
00:8DFE D003            	  1713:   bne  ST_SYMTBL_LIST_LINE       ; more to go
00:8E00 4C898E          	  1714:   jmp  ST_SYMTBL_LIST_DONE       ; finished if symitm and symitm+1 are both zero
                        	  1715: 
                        	  1716: ST_SYMTBL_LIST_LINE = *
00:8E03 A541            	  1717:   lda  SYMITM+1
00:8E05 200693          	  1718:   jsr  PRBYTE
00:8E08 A540            	  1719:   lda  SYMITM
00:8E0A 200693          	  1720:   jsr  PRBYTE
00:8E0D A920            	  1721:   lda  #' '
00:8E0F 20EE92          	  1722:   jsr  PRCHAR
00:8E12 A001            	  1723:   ldy  #SYMPRV+1
00:8E14 B140            	  1724:   lda  (SYMITM),Y
00:8E16 200693          	  1725:   jsr  PRBYTE
00:8E19 88              	  1726:   dey
00:8E1A B140            	  1727:   lda  (SYMITM),Y
00:8E1C 200693          	  1728:   jsr  PRBYTE
00:8E1F A920            	  1729:   lda  #' '
00:8E21 20EE92          	  1730:   jsr  PRCHAR
00:8E24 A002            	  1731:   ldy  #SYMLVL
00:8E26 B140            	  1732:   lda  (SYMITM),Y  ; level
00:8E28 200693          	  1733:   jsr  PRBYTE
00:8E2B A920            	  1734:   lda  #' '
00:8E2D 20EE92          	  1735:   jsr  PRCHAR
00:8E30 A003            	  1736:   ldy  #SYMTYP
00:8E32 B140            	  1737:   lda  (SYMITM),Y  ; type
00:8E34 20EE92          	  1738:   jsr  PRCHAR
00:8E37 A920            	  1739:   lda  #' '
00:8E39 20EE92          	  1740:   jsr  PRCHAR
00:8E3C A004            	  1741:   ldy  #SYMDSP
00:8E3E C8              	  1742:   iny
00:8E3F B140            	  1743:   lda  (SYMITM),Y  ; displacement
00:8E41 200693          	  1744:   jsr  PRBYTE
00:8E44 88              	  1745:   dey
00:8E45 B140            	  1746:   lda  (SYMITM),Y  ; displacement
00:8E47 200693          	  1747:   jsr  PRBYTE
00:8E4A A920            	  1748:   lda  #' '
00:8E4C 20EE92          	  1749:   jsr  PRCHAR
00:8E4F A006            	  1750:   ldy  #SYMARG
00:8E51 B140            	  1751:   lda  (SYMITM),Y  ; argument count
00:8E53 200693          	  1752:   jsr  PRBYTE
00:8E56 A920            	  1753:   lda  #' '
00:8E58 20EE92          	  1754:   jsr  PRCHAR
00:8E5B A008            	  1755:   ldy  #SYMDAT
00:8E5D B140            	  1756:   lda  (SYMITM),Y  ; data type
00:8E5F 200693          	  1757:   jsr  PRBYTE
00:8E62 A920            	  1758:   lda  #' '
00:8E64 20EE92          	  1759:   jsr  PRCHAR
00:8E67 A009            	  1760:   ldy  #SYMLEN
00:8E69 B140            	  1761:   lda  (SYMITM),Y  ; length
00:8E6B 48              	  1762:   pha
00:8E6C 200693          	  1763:   jsr  PRBYTE
00:8E6F A920            	  1764:   lda  #' '
00:8E71 20EE92          	  1765:   jsr  PRCHAR
00:8E74 A00A            	  1766:   ldy  #SYMNAM
00:8E76 68              	  1767:   pla
00:8E77 AA              	  1768:   tax
                        	  1769: ST_SYMTBL_LIST_NAME = *
00:8E78 B140            	  1770:   lda  (SYMITM),Y  ; name
00:8E7A 5A              	  1771:   phy
00:8E7B 20EE92          	  1772:   jsr  PRCHAR
00:8E7E 7A              	  1773:   ply
00:8E7F C8              	  1774:   iny
00:8E80 CA              	  1775:   dex
00:8E81 D0F5            	  1776:   bne ST_SYMTBL_LIST_NAME
00:8E83 209192          	  1777:   jsr CROUT
00:8E86 4CE98D          	  1778:   jmp ST_SYMTBL_LIST_NEXT
                        	  1779: 
                        	  1780: ST_SYMTBL_LIST_DONE = *
                        	  1781: 
00:8E89 4CCC82          	  1782:   jmp main_prompt
                        	  1783: 
                        	  1784: 
00:8E8C 446F6E650A      	  1785: recover_done asciiz "Done\n"
00:8E91 00
00:8E92 4E6F74206E656564	  1786: recover_not_needed asciiz "Not needed\n"
00:8E9A 65640A
00:8E9D 00
                        	  1787: 
                        	  1788: ;
                        	  1789: ; Recover: if the first byte of the source is 0x00, change it to a space
                        	  1790: ;
                        	  1791: editor_recover:
00:8E9E 205886          	  1792:   jsr editor_check_no_more
00:8EA1 A900            	  1793:   lda  #<TEXT_START
00:8EA3 8540            	  1794:   sta  FROM
00:8EA5 A903            	  1795:   lda  #>TEXT_START
00:8EA7 8541            	  1796:   sta  FROM+1
00:8EA9 A000            	  1797:   ldy  #0
00:8EAB B140            	  1798:   lda  (FROM),Y
00:8EAD D00E            	  1799:   bne  editor_recover_not_needed
00:8EAF A920            	  1800:   lda  #' '
00:8EB1 9140            	  1801:   sta  (FROM),Y
00:8EB3 A98C            	  1802:   lda #<recover_done
00:8EB5 A28E            	  1803:   ldx #>recover_done
00:8EB7 202682          	  1804:   jsr print
00:8EBA 4CCC82          	  1805:   jmp main_prompt
                        	  1806: 
                        	  1807: editor_recover_not_needed:
00:8EBD A992            	  1808:   lda #<recover_not_needed
00:8EBF A28E            	  1809:   ldx #>recover_not_needed
00:8EC1 202682          	  1810:   jsr print
00:8EC4 4CCC82          	  1811:   jmp main_prompt
                        	  1812: 
                        	  1813: 
                        	  1814: editor_debug:
00:8EC7 205886          	  1815:   jsr editor_check_no_more
00:8ECA A901            	  1816:   lda #1
00:8ECC 8549            	  1817:   sta  DBGFLG
00:8ECE 852E            	  1818:   sta  DCODE
00:8ED0 4CD493          	  1819:   jmp  CHK_RUN
                        	  1820: 
                        	  1821: editor_trace:
00:8ED3 205886          	  1822:   jsr editor_check_no_more
00:8ED6 A980            	  1823:   lda  #$80
00:8ED8 8549            	  1824:   sta  DBGFLG
00:8EDA 852E            	  1825:   sta  DCODE
00:8EDC 4CD493          	  1826:   jmp  CHK_RUN
                        	  1827: 
                        	  1828: 
                        	  1829: editor_info  = *
00:8EDF 205886          	  1830:   jsr editor_check_no_more
00:8EE2 205B8F          	  1831:   jsr show_source_start
00:8EE5 20338F          	  1832:   jsr show_source_end
00:8EE8 20EC90          	  1833:   jsr crc_source
00:8EEB 4CCC82          	  1834:   jmp main_prompt
                        	  1835: 
                        	  1836: editor_compile:
00:8EEE 205886          	  1837:   jsr editor_check_no_more
00:8EF1 A900            	  1838:   lda  #0
00:8EF3 8542            	  1839:   sta  SYNTAX
00:8EF5 4C45BA          	  1840:   jmp  COMPIL
                        	  1841: 
                        	  1842: editor_syntax:
00:8EF8 205886          	  1843:   jsr editor_check_no_more
00:8EFB A901            	  1844:   lda #1
00:8EFD 8542            	  1845:   sta  SYNTAX
00:8EFF 4C45BA          	  1846:   jmp  COMPIL
                        	  1847: 
                        	  1848: editor_run:
00:8F02 205886          	  1849:   jsr editor_check_no_more
00:8F05 A900            	  1850:   lda  #0
00:8F07 8549            	  1851:   sta  DBGFLG
00:8F09 852E            	  1852:   sta  DCODE
00:8F0B 4CD493          	  1853:   jmp  CHK_RUN
                        	  1854: 
                        	  1855:   ;
                        	  1856: show_symbol_table_end:
00:8F0E A979            	  1857:   lda  #<symbol_table_ended_message    ; Symbol table ended at
00:8F10 A293            	  1858:   ldx  #>symbol_table_ended_message
00:8F12 202682          	  1859:   jsr  print
00:8F15 A532            	  1860:   lda  ENDSYM+1
00:8F17 200693          	  1861:   jsr  PRBYTE
00:8F1A A531            	  1862:   lda  ENDSYM
00:8F1C 20BB93          	  1863:   jsr  PRBYTECR
00:8F1F 60              	  1864:   rts
                        	  1865: 
                        	  1866: 
00:8F20 536F757263652065	  1867: source_ended_message asciiz "Source ends   at $"
00:8F28 6E64732020206174
00:8F30 2024
00:8F32 00
                        	  1868: show_source_end:
00:8F33 A920            	  1869:   lda #<source_ended_message
00:8F35 A28F            	  1870:   ldx #>source_ended_message
00:8F37 202682          	  1871:   jsr print
00:8F3A 20D18C          	  1872:   jsr find_source_end
00:8F3D A524            	  1873:   lda PCODE+1
00:8F3F 200693          	  1874:   jsr PRBYTE
00:8F42 A523            	  1875:   lda PCODE
00:8F44 20BB93          	  1876:   jsr PRBYTECR
00:8F47 60              	  1877:   rts
                        	  1878: 
00:8F48 536F757263652073	  1879: source_starts_message asciiz "Source starts at $"    ; source starts at
00:8F50 7461727473206174
00:8F58 2024
00:8F5A 00
                        	  1880: show_source_start:
00:8F5B A948            	  1881:   lda #<source_starts_message
00:8F5D A28F            	  1882:   ldx #>source_starts_message
00:8F5F 202682          	  1883:   jsr print
00:8F62 A903            	  1884:   lda #>TEXT_START
00:8F64 200693          	  1885:   jsr PRBYTE
00:8F67 A900            	  1886:   lda #<TEXT_START
00:8F69 20BB93          	  1887:   jsr PRBYTECR
00:8F6C 60              	  1888:   rts
                        	  1889: 
                        	  1890: editor_assemble:
00:8F6D 205886          	  1891:   jsr editor_check_no_more
00:8F70 4CAB98          	  1892:   jmp ASSEMBLE
                        	  1893: 
                        	  1894: 
                        	  1895: 
                        	  1896: 
                        	  1897: ;16-bit number comparison...
                        	  1898: ;
                        	  1899: ;         lda #>x               ; MSB of 1st number
                        	  1900: ;         cmp #>y               ; MSB of 2nd number
                        	  1901: ;         bcc islower           ; X < Y
                        	  1902: ;
                        	  1903: ;         bne ishigher          ; X > Y
                        	  1904: ;
                        	  1905: ;         lda #<x               ; LSB of 1st number
                        	  1906: ;         cmp #<y               ; LSB of 2nd number
                        	  1907: ;         bcc islower           ; X < Y
                        	  1908: ;
                        	  1909: ;         beq issame            ; X = Y
                        	  1910: ;
                        	  1911: ;         bne ishigher          ; X > Y
                        	  1912: ;
                        	  1913: ;
                        	  1914: 

Source: "gpascal.asm"
                        	   176:   .include "utilities.inc"

Source: "utilities.inc"
                        	     1: ;
                        	     2: ;  function to look up a handler for a word (eg. assembler directive)
                        	     3: ;
                        	     4: ;  word in SRCE
                        	     5: ;
                        	     6: ;  table of words/handlers in DEST
                        	     7: ;
                        	     8: ;  length of word in A
                        	     9: ;
                        	    10: ;  see makeHandler for making the table
                        	    11: ;
                        	    12: ;  Basically:
                        	    13: ;    asciiz "foo"
                        	    14: ;    word   foo_handler
                        	    15: ;
                        	    16: ;  In other words:
                        	    17: ;    makeHandler "foo",foo_handler
                        	    18: ;
                        	    19: ;  Returns with carry set if no match, otherwise calls the handler which should clear carry
                        	    20: ;
                        	    21: 
                        	    22: handlerLookup:
00:8F73 8598            	    23:   sta token_work    ; save length
                        	    24: 
                        	    25: ;
                        	    26: ;  find the length of the word
                        	    27: ;
                        	    28: handler_loop:
00:8F75 A000            	    29:   ldy #0
00:8F77 B103            	    30:   lda (DEST),y
00:8F79 F036            	    31:   beq handlers_done
                        	    32: handler_find_length:
00:8F7B B103            	    33:   lda (DEST),y
00:8F7D F005            	    34:   beq handler_found_length
00:8F7F C8              	    35:   iny
00:8F80 F02F            	    36:   beq handlers_done   ; sanity clause
00:8F82 80F7            	    37:   bra handler_find_length
                        	    38: handler_found_length:
                        	    39: 
                        	    40: ;  lda #'i'
                        	    41: ;  jsr ass_debug_point
                        	    42: 
00:8F84 C498            	    43:   cpy token_work
00:8F86 F010            	    44:   beq handler_same_length
                        	    45: ;
                        	    46: ;  not the same length, or no match on the string
                        	    47: ;
                        	    48: handler_next:
00:8F88 98              	    49:   tya
00:8F89 18              	    50:   clc
00:8F8A 6903            	    51:   adc #3  ; skip the 0x00 and the execution address
00:8F8C 6503            	    52:   adc DEST
00:8F8E 8503            	    53:   sta DEST
00:8F90 A504            	    54:   lda DEST+1
00:8F92 6900            	    55:   adc #0
00:8F94 8504            	    56:   sta DEST+1
00:8F96 80DD            	    57:   bra handler_loop
                        	    58: 
                        	    59: handler_same_length:
                        	    60: 
                        	    61: ;  lda #'j'
                        	    62: ;  jsr ass_debug_point
                        	    63: 
00:8F98 5A              	    64:   phy  ; save the length
00:8F99 209692          	    65:   jsr COMSTL
00:8F9C F003            	    66:   beq  handler_found_directive
00:8F9E 7A              	    67:   ply
00:8F9F 80E7            	    68:   bra handler_next
                        	    69: handler_found_directive:
00:8FA1 7A              	    70:   ply  ; get the length back
00:8FA2 C8              	    71:   iny  ; skip past the 0x00 byte
00:8FA3 B103            	    72:   lda (DEST),y
00:8FA5 8599            	    73:   sta token_work+1
00:8FA7 C8              	    74:   iny
00:8FA8 B103            	    75:   lda (DEST),y
00:8FAA 859A            	    76:   sta token_work+2
00:8FAC 20B38F          	    77:   jsr call_handler
00:8FAF 18              	    78:   clc
00:8FB0 60              	    79:   rts
                        	    80: 
                        	    81: handlers_done:
                        	    82: ;  lda #'h'
                        	    83: ;  jsr ass_debug_point
00:8FB1 38              	    84:   sec     ; error flag
00:8FB2 60              	    85:   rts
                        	    86: 
                        	    87: call_handler:
                        	    88: ;  lda #'g'
                        	    89: ;  jsr ass_debug_point
                        	    90: 
00:8FB3 6C9900          	    91:   jmp (token_work+1)   ; do handler - it will RTS for us
                        	    92: 
                        	    93: 
                        	    94: ;
                        	    95: ;  function to look up a handler for a word on a partial match (eg. editor command)
                        	    96: ;
                        	    97: ;  word in SRCE
                        	    98: ;
                        	    99: ;  table of words/handlers in DEST - in UPPER CASE
                        	   100: ;
                        	   101: ;  length of word in A
                        	   102: ;
                        	   103: ;  see makeHandler for making the table
                        	   104: ;
                        	   105: ;  Basically:
                        	   106: ;    asciiz "FOO"
                        	   107: ;    word   foo_handler
                        	   108: ;
                        	   109: ;  In other words:
                        	   110: ;    makeHandler "FOO",foo_handler
                        	   111: ;
                        	   112: ;  Returns if no match, otherwise jumps to the handler and thus doesn't return
                        	   113: ;
                        	   114: 
                        	   115: partial_handler_Lookup:
00:8FB6 8598            	   116:   sta token_work    ; save length
                        	   117: ;
                        	   118: ;  here for a new table item
                        	   119: ;
                        	   120: partial_handler_next_item:
00:8FB8 A000            	   121:   ldy #0
00:8FBA B103            	   122:   lda (DEST),y
00:8FBC F03C            	   123:   beq partial_handler_done
00:8FBE A698            	   124:   ldx token_work        ; source length
                        	   125: partial_handler_next_loop:
                        	   126: ;
                        	   127: ;  ensure the nth character matches until the source runs out
                        	   128: ;
00:8FC0 B100            	   129:   lda (SRCE),y
00:8FC2 202D90          	   130:   jsr MAKE_UPPER
00:8FC5 D103            	   131:   cmp (DEST),y
00:8FC7 D006            	   132:   bne partial_handler_next
00:8FC9 C8              	   133:   iny
00:8FCA CA              	   134:   dex     ; one less count
00:8FCB F019            	   135:   beq partial_handler_found_directive ; source has finished and we found the directive
00:8FCD 80F1            	   136:   bra partial_handler_next_loop       ; try matching the next one
                        	   137: ;
                        	   138: ;  no match on the string - advance Y to the end of the destination string
                        	   139: ;
                        	   140: partial_handler_next:
00:8FCF B103            	   141:   lda (DEST),y
00:8FD1 F003            	   142:   beq partial_handler_next_found_item_length
00:8FD3 C8              	   143:   iny
00:8FD4 80F9            	   144:   bra partial_handler_next
                        	   145: partial_handler_next_found_item_length:
00:8FD6 98              	   146:   tya     ; length of the word in the table
00:8FD7 18              	   147:   clc
00:8FD8 6903            	   148:   adc #3  ; skip the 0x00 and the execution address
00:8FDA 6503            	   149:   adc DEST
00:8FDC 8503            	   150:   sta DEST
00:8FDE A504            	   151:   lda DEST+1
00:8FE0 6900            	   152:   adc #0
00:8FE2 8504            	   153:   sta DEST+1
00:8FE4 80D2            	   154:   bra partial_handler_next_item
                        	   155: 
                        	   156: partial_handler_found_directive:
00:8FE6 B103            	   157:   lda (DEST),y
00:8FE8 F003            	   158:   beq partial_handler_skipped_string
00:8FEA C8              	   159:   iny
00:8FEB 80F9            	   160:   bra partial_handler_found_directive
                        	   161: partial_handler_skipped_string:
00:8FED C8              	   162:   iny  ; skip past the 0x00 byte
00:8FEE B103            	   163:   lda (DEST),y
00:8FF0 8599            	   164:   sta token_work+1
00:8FF2 C8              	   165:   iny
00:8FF3 B103            	   166:   lda (DEST),y
00:8FF5 859A            	   167:   sta token_work+2
00:8FF7 6C9900          	   168:   jmp (token_work+1)   ; do partial_partial_handler_ - it will RTS for us
                        	   169: 
                        	   170: partial_handler_done:
00:8FFA 60              	   171:   rts
                        	   172: 
                        	   173: ;***********************************************
                        	   174: ; JUMP ON TOKEN
                        	   175: ; X/Y = START OF TABLE
                        	   176: ; END OF TABLE IS A NULL
                        	   177: ; A = TOKEN
                        	   178: ;***********************************************
                        	   179: TKNJMP   =  *
00:8FFB 8600            	   180:          stx  REG     ; save table address
00:8FFD 8401            	   181:          sty  REG+1
                        	   182: 
00:8FFF 202D90          	   183:          jsr MAKE_UPPER
00:9002 AA              	   184:          tax          ; save the token
                        	   185: JMP1     =  *
00:9003 A000            	   186:          ldy  #0
00:9005 B100            	   187:          lda  (REG),Y
00:9007 D002            	   188:          bne  JMP2
                        	   189: ; failed to find the token
00:9009 8A              	   190:          txa          ; retore the token
00:900A 60              	   191:          rts
                        	   192: JMP2     =  *
00:900B 8A              	   193:          txa          ; get token back
00:900C D100            	   194:          cmp  (REG),Y
00:900E D010            	   195:          bne  JMP3    ; branch if not found
00:9010 68              	   196:          pla
00:9011 68              	   197:          pla          ; remove return address for TKNJMP call
00:9012 C8              	   198:          iny          ; move Y on to routine address
00:9013 B100            	   199:          lda  (REG),Y ; get low order byte of routine
00:9015 8503            	   200:          sta  REG2
00:9017 C8              	   201:          iny          ; next byte
00:9018 B100            	   202:          lda  (REG),Y ; get high order byte
00:901A 8504            	   203:          sta  REG2+1
00:901C 8A              	   204:          txa          ; get token back
00:901D 6C0300          	   205:          jmp  (REG2)  ; go to routine
                        	   206: JMP3     =  *
00:9020 A500            	   207:          lda  REG     ; skip this token sequence
00:9022 18              	   208:          clc
00:9023 6903            	   209:          adc  #3
00:9025 8500            	   210:          sta  REG
00:9027 90DA            	   211:          bcc  JMP1
00:9029 E601            	   212:          inc  REG+1
00:902B 80D6            	   213:          bra  JMP1    ; try again
                        	   214: 
                        	   215: ;
                        	   216: 
                        	   217: 
                        	   218: ;***********************************************
                        	   219: ;
                        	   220: ; Case conversion
                        	   221: ;
                        	   222: ;***********************************************
                        	   223: 
                        	   224: 
                        	   225: MAKE_UPPER = *
00:902D C97B            	   226:          CMP  #('z'+1)
00:902F B006            	   227:          BCS  MAKE_UPPER_DONE
00:9031 C961            	   228:          CMP  #'a'
00:9033 9002            	   229:          BCC  MAKE_UPPER_DONE
00:9035 E920            	   230:          SBC  #$20  ; make upper-case - we want carry set so there is no borrow
                        	   231: MAKE_UPPER_DONE = *
00:9037 60              	   232:          RTS
                        	   233: 
                        	   234: MAKE_LOWER = *
00:9038 C941            	   235:          CMP  #'A'
00:903A 9006            	   236:          BCC  MAKE_LOWER_DONE
00:903C C95B            	   237:          CMP  #('Z'+1)
00:903E B002            	   238:          BCS  MAKE_LOWER_DONE
00:9040 6920            	   239:          ADC  #$20  ; make upper-case - we want carry clear so there is no carry
                        	   240: MAKE_LOWER_DONE = *
00:9042 60              	   241:          RTS
                        	   242: 
                        	   243: 
                        	   244: ;
                        	   245: ;  generate the next random number
                        	   246: ;
                        	   247: gen_random:
00:9043 0609            	   248:     asl random
00:9045 260A            	   249:     rol random+1
00:9047 260B            	   250:     rol random+2
00:9049 260C            	   251:     rol random+3
00:904B 9018            	   252:     bcc gen_random1
00:904D A509            	   253:     lda random
00:904F 49B7            	   254:     eor #$B7
00:9051 8509            	   255:     sta random
00:9053 A50A            	   256:     lda random+1
00:9055 491D            	   257:     eor #$1D
00:9057 850A            	   258:     sta random+1
00:9059 A50B            	   259:     lda random+2
00:905B 49C1            	   260:     eor #$C1
00:905D 850B            	   261:     sta random+2
00:905F A50C            	   262:     lda random+3
00:9061 4904            	   263:     eor #$04
00:9063 850C            	   264:     sta random+3
                        	   265: gen_random1:
00:9065 60              	   266:     rts
                        	   267: 
                        	   268: 
                        	   269: 
                        	   270: ;
                        	   271: ;  From: http://www.6502.org/source/integers/crc-more.html
                        	   272: ;
                        	   273: ;   jacksum  -a crc:16,1021,FFFF,false,false,0 -X SOME_FILE
                        	   274: ;
                        	   275: ;   https://jacksum.net/en/index.html
                        	   276: ;
                        	   277: ;   With a starting CRC of $FFFF, the binary string $01 $02 $03 $04 should evaluate to $89C3.
                        	   278: ;
                        	   279: ;   Start at crc_addr, for crc_num bytes
                        	   280: ;
                        	   281: crc16 = *
                        	   282: ;
                        	   283: ;  initialise CRC
                        	   284: ;
00:9066 A9FF            	   285:   lda #$FF
00:9068 8506            	   286:   sta crc_val
00:906A 8507            	   287:   sta crc_val+1
00:906C A503            	   288:   lda crc_num
00:906E 0504            	   289:   ora crc_num+1
00:9070 F01B            	   290:   beq crc_done
                        	   291: 
                        	   292: ;
                        	   293: ;  here for each byte
                        	   294: ;
                        	   295: crc16_loop  = *
00:9072 A000            	   296:   ldy #0
00:9074 B100            	   297:   lda (crc_addr),y  ; get next byte
00:9076 208E90          	   298:   jsr crc_byte
                        	   299:   ;
                        	   300:   ;  onto next address
                        	   301:   ;
00:9079 E600            	   302:   inc crc_addr
00:907B D002            	   303:   bne crc16_next
00:907D E601            	   304:   inc crc_addr+1       ; Step to next byte
                        	   305: crc16_next:
                        	   306:   ;
                        	   307:   ; now do a 16-bit decrement
                        	   308:   ;
00:907F A503            	   309:   LDA crc_num
00:9081 D002            	   310:   BNE crc16_skip    ; decrement the high-order byte if we are about to wrap
00:9083 C604            	   311:   DEC crc_num+1
                        	   312: crc16_skip:
00:9085 C603            	   313:   DEC crc_num       ; decrement the low-order byte
00:9087 D0E9            	   314:   BNE crc16_loop    ; not zero, keep going
00:9089 A504            	   315:   LDA crc_num+1     ; are we zero here too?
00:908B D0E5            	   316:   BNE crc16_loop    ; not yet
                        	   317: 
                        	   318: crc_done:
00:908D 60              	   319:   rts
                        	   320: 
                        	   321: ;
                        	   322: ;  do a CRC of one byte (in A) updating crc_val
                        	   323: ;
                        	   324: crc_byte = *
00:908E 4507            	   325:   eor crc_val+1     ; A contained the data
00:9090 8507            	   326:   sta crc_val+1     ; XOR it into high byte
00:9092 4A              	   327:   lsr               ; right shift A 4 bits
00:9093 4A              	   328:   lsr               ; to make top of x^12 term
00:9094 4A              	   329:   lsr               ; ($1...)
00:9095 4A              	   330:   lsr
00:9096 AA              	   331:   tax               ; save it
00:9097 0A              	   332:   asl               ; then make top of x^5 term
00:9098 4506            	   333:   eor crc_val       ; and XOR that with low byte
00:909A 8506            	   334:   sta crc_val       ; and save
00:909C 8A              	   335:   txa               ; restore partial term
00:909D 4507            	   336:   eor crc_val+1     ; and update high byte
00:909F 8507            	   337:   sta crc_val+1     ; and save
00:90A1 0A              	   338:   asl               ; left shift three
00:90A2 0A              	   339:   asl               ; the rest of the terms
00:90A3 0A              	   340:   asl               ; have feedback from x^12
00:90A4 AA              	   341:   tax               ; save bottom of x^12
00:90A5 0A              	   342:   asl               ; left shift two more
00:90A6 0A              	   343:   asl               ; watch the carry flag
00:90A7 4507            	   344:   eor crc_val+1     ; bottom of x^5 ($..2.)
00:90A9 A8              	   345:   tay               ; save high byte
00:90AA 8A              	   346:   txa               ; fetch temp value
00:90AB 2A              	   347:   rol               ; bottom of x^12, middle of x^5!
00:90AC 4506            	   348:   eor crc_val       ; finally update low byte
00:90AE 8507            	   349:   sta crc_val+1     ; then swap high and low bytes
00:90B0 8406            	   350:   sty crc_val
00:90B2 60              	   351:   rts
                        	   352: 
                        	   353: 
                        	   354: crc_helper = *
00:90B3 5A              	   355:   phy
00:90B4 DA              	   356:   phx
00:90B5 208E90          	   357:   jsr crc_byte
00:90B8 E603            	   358:   inc crc_num
00:90BA D002            	   359:   bne crc_helper1
00:90BC E604            	   360:   inc crc_num+1
                        	   361: crc_helper1:
00:90BE FA              	   362:   plx
00:90BF 7A              	   363:   ply
00:90C0 60              	   364:   rts
                        	   365: 
00:90C1 536F757263652043	   366: crc_message asciiz "Source CRC       $"               ; source CRC
00:90C9 5243202020202020
00:90D1 2024
00:90D3 00
00:90D4 536F75726365206C	   367: source_length_message asciiz "Source length: "    ; source length
00:90DC 656E6774683A20
00:90E3 00
00:90E4 2062797465730A  	   368: bytes_message asciiz " bytes\n"
00:90EB 00
                        	   369: 
                        	   370: crc_source = *
00:90EC 20D18C          	   371:   jsr find_source_end
                        	   372: 
                        	   373: ;
                        	   374: ;  move existing source to end of RAM
                        	   375: ;
00:90EF 18              	   376:   clc             ; don't count the final 0x00 byte
00:90F0 A523            	   377:   lda PCODE
00:90F2 E900            	   378:   sbc #<TEXT_START
00:90F4 8503            	   379:   sta crc_num
00:90F6 A524            	   380:   lda PCODE+1
00:90F8 E903            	   381:   sbc #>TEXT_START
00:90FA 8504            	   382:   sta crc_num+1
                        	   383: ;
                        	   384: ;  Show the length of the source
                        	   385: ;
00:90FC A9D4            	   386:   lda #<source_length_message
00:90FE A290            	   387:   ldx #>source_length_message
00:9100 202682          	   388:   jsr print
00:9103 A503            	   389:   lda crc_num
00:9105 8500            	   390:   sta REG
00:9107 A504            	   391:   lda crc_num+1
00:9109 8501            	   392:   sta REG+1
00:910B 6402            	   393:   stz REGB
00:910D 20BB91          	   394:   jsr display_in_decimal
00:9110 A9E4            	   395:   lda #<bytes_message
00:9112 A290            	   396:   ldx #>bytes_message
00:9114 202682          	   397:   jsr print
                        	   398: 
                        	   399: ;
                        	   400: ;  now the CRC
                        	   401: ;
00:9117 A900            	   402:   lda #<TEXT_START
00:9119 8500            	   403:   sta crc_addr
00:911B A903            	   404:   lda #>TEXT_START
00:911D 8501            	   405:   sta crc_addr+1
00:911F 206690          	   406:   jsr crc16
00:9122 A9C1            	   407:   lda  #<crc_message            ;  source CRC
00:9124 A290            	   408:   ldx  #>crc_message            ;
00:9126 202682          	   409:   jsr  print
00:9129 A507            	   410:   lda crc_val+1
00:912B 200693          	   411:   jsr PRBYTE
00:912E A506            	   412:   lda crc_val
00:9130 20BB93          	   413:   jsr PRBYTECR
00:9133 60              	   414:   rts
                        	   415: 
                        	   416: 
                        	   417: ;
                        	   418: ;  delays for roughly 1 ms - changes no registers
                        	   419: ;
                        	   420: delay_1ms = *
00:9134 DA              	   421:          phx
00:9135 A26C            	   422:          ldx #108
                        	   423: delay_1ms_loop:
00:9137 EA              	   424:          nop
00:9138 EA              	   425:          nop
00:9139 CA              	   426:          dex
00:913A D0FB            	   427:          bne delay_1ms_loop
00:913C FA              	   428:          plx
00:913D 60              	   429:          rts
                        	   430: 
                        	   431: ;
                        	   432: ; delay for YYXX ms (Y = high-order byte, X = lo-order byte)
                        	   433: ;  maximum delay 0x7FFF, that is 32767 ms
                        	   434: ;  Changes X and Y
                        	   435: ;
                        	   436: delay = *
00:913E 203491          	   437:   jsr delay_1ms
00:9141 CA              	   438:   dex
00:9142 D0FA            	   439:   bne delay
00:9144 88              	   440:   dey
00:9145 10F7            	   441:   bpl delay
00:9147 60              	   442:   rts
                        	   443: 
                        	   444: 
                        	   445: ;--------------------------------------------------------------------------
                        	   446: ;
                        	   447: ;  BINARY TO DECIMAL CONVERSION
                        	   448: ;
                        	   449: ;  This works as follows:
                        	   450: ;
                        	   451: ;  1. First the number is checked if it is negative (sign bit set).
                        	   452: ;  2. If so, a "-" is output and the number subtracted from zero to make it positive.
                        	   453: ;  3. Our next step is to set a BCD (binary coded decimal) output area to all zeroes.
                        	   454: ;      In BCD, the number 1234 is actually stored as 0x1234.
                        	   455: ;      With BCD mode turned on in the processor, doing adds results in an early carry
                        	   456: ;      so that numbers add "the decimal way" rather than the binary way.
                        	   457: ;  4. Then we a loop of 24 iterations (one for each bit) which adds the appropriate number from bcd_table
                        	   458: ;      if that bit was set in the original value.
                        	   459: ;  5. The function bcd_unpack is then called to convert the BCD format into ASCII format. It takes each
                        	   460: ;     nibble and adds 0x30 ('0') to it, and saves that in bcd_result.
                        	   461: ;  6. At this stage bcd_result has a 8-digit ASCII number in it.
                        	   462: ;  7. We then skip leading zeroes in bcd_result.
                        	   463: ;  8. Finally the remaining digits in bcd_result are output.
                        	   464: ;
                        	   465: ;
                        	   466: ;   I'm not sure where the idea for this came from. There was no Internet when this was written in 1979
                        	   467: ;   so it is possibly (probably) my own.
                        	   468: ;   My original implementation, although similar, was more complex than this one, which I found at:
                        	   469: ;              http://www.6502.org/source/integers/hex2dec.htm
                        	   470: ;
                        	   471: ;   Other suggestions for binary to decimal conversion I found recently do not employ this method. One
                        	   472: ;   technique (as described by Ben Eater here: https://www.youtube.com/watch?v=v3-a-zqKfgA ) is to
                        	   473: ;   repeatedly divide by 10 and use the remainder as the digit. This has to be done until the result of
                        	   474: ;   the division is zero. Dividing a 3-byte number by 10 on an 8-bit machine is not particularly fast,
                        	   475: ;   as it involves an inner loop of 24 iterations (one for each bit) and this would have to be done for
                        	   476: ;   each digit, so the number of loops of 24 iterations would increase for each digit. Therefore an
                        	   477: ;   8-digit number (like 80000000) would take 144 iterations in the divide loop. Then the digits have to
                        	   478: ;   be reversed because the remainder gives you the low-order decimal digit first.
                        	   479: ;
                        	   480: ;   Another technique is the "Double dabble" routine.
                        	   481: ;
                        	   482: ;     https://en.wikipedia.org/wiki/Double_dabble
                        	   483: ;
                        	   484: ;   The method below seems fairly efficient, as the inner loop only does anything substantial if a
                        	   485: ;     1-bit is detected. Thus large numbers can be produced quite efficiently, however it would be a
                        	   486: ;     bit slower if the input number had a lot of 1-bits set.
                        	   487: ;
                        	   488: ;   Considering that this is only used when outputting to serial, itself a slow process, speed is not
                        	   489: ;   really the issue here.
                        	   490: ;
                        	   491: ;   - Nick Gammon
                        	   492: ;
                        	   493: ;
                        	   494: ;--------------------------------------------------------------------------
                        	   495: ;
                        	   496: ; Converts BCD to ASCII
                        	   497: ;
                        	   498: bcd_unpack:
00:9148 48              	   499:   pha  ; save the number for later
                        	   500: ;
                        	   501: ;  shift right 4 bits
                        	   502: ;
00:9149 4A              	   503:   lsr A
00:914A 4A              	   504:   lsr A
00:914B 4A              	   505:   lsr A
00:914C 4A              	   506:   lsr A
00:914D 0930            	   507:   ora #'0'          ; make printable
00:914F 9560            	   508:   sta bcd_result,X  ; save in bcd_result
00:9151 E8              	   509:   inx
00:9152 68              	   510:   pla               ; get the original character back
00:9153 290F            	   511:   and #$0F          ; take low-order bits and make printable
00:9155 0930            	   512:   ora #'0'
00:9157 9560            	   513:   sta bcd_result,X  ; save in bcd_result
00:9159 E8              	   514:   inx
00:915A 60              	   515:   rts               ; done!
                        	   516: 
                        	   517: ;
                        	   518: ;
                        	   519: ; Table for adding into the BCD result.
                        	   520: ;
                        	   521: bcd_table  =  *
00:915B 00              	   522:   dfb $00,$00,$00,$01   ; 0000001
00:915C 00
00:915D 00
00:915E 01
00:915F 00              	   523:   dfb $00,$00,$00,$02   ; 0000002
00:9160 00
00:9161 00
00:9162 02
00:9163 00              	   524:   dfb $00,$00,$00,$04   ; 0000004
00:9164 00
00:9165 00
00:9166 04
00:9167 00              	   525:   dfb $00,$00,$00,$08   ; 0000008
00:9168 00
00:9169 00
00:916A 08
00:916B 00              	   526:   dfb $00,$00,$00,$16   ; 0000016
00:916C 00
00:916D 00
00:916E 16
00:916F 00              	   527:   dfb $00,$00,$00,$32   ; 0000032
00:9170 00
00:9171 00
00:9172 32
00:9173 00              	   528:   dfb $00,$00,$00,$64   ; 0000064
00:9174 00
00:9175 00
00:9176 64
00:9177 00              	   529:   dfb $00,$00,$01,$28   ; 0000128
00:9178 00
00:9179 01
00:917A 28
00:917B 00              	   530:   dfb $00,$00,$02,$56   ; 0000256
00:917C 00
00:917D 02
00:917E 56
00:917F 00              	   531:   dfb $00,$00,$05,$12   ; 0000512
00:9180 00
00:9181 05
00:9182 12
00:9183 00              	   532:   dfb $00,$00,$10,$24   ; 0001024
00:9184 00
00:9185 10
00:9186 24
00:9187 00              	   533:   dfb $00,$00,$20,$48   ; 0002048
00:9188 00
00:9189 20
00:918A 48
00:918B 00              	   534:   dfb $00,$00,$40,$96   ; 0004096
00:918C 00
00:918D 40
00:918E 96
00:918F 00              	   535:   dfb $00,$00,$81,$92   ; 0008192
00:9190 00
00:9191 81
00:9192 92
00:9193 00              	   536:   dfb $00,$01,$63,$84   ; 0016384
00:9194 01
00:9195 63
00:9196 84
00:9197 00              	   537:   dfb $00,$03,$27,$68   ; 0032768
00:9198 03
00:9199 27
00:919A 68
00:919B 00              	   538:   dfb $00,$06,$55,$36   ; 0065536
00:919C 06
00:919D 55
00:919E 36
00:919F 00              	   539:   dfb $00,$13,$10,$72   ; 0131072
00:91A0 13
00:91A1 10
00:91A2 72
00:91A3 00              	   540:   dfb $00,$26,$21,$44   ; 0262144
00:91A4 26
00:91A5 21
00:91A6 44
00:91A7 00              	   541:   dfb $00,$52,$42,$88   ; 0524288
00:91A8 52
00:91A9 42
00:91AA 88
00:91AB 01              	   542:   dfb $01,$04,$85,$76   ; 1048576
00:91AC 04
00:91AD 85
00:91AE 76
00:91AF 02              	   543:   dfb $02,$09,$71,$52   ; 2097152
00:91B0 09
00:91B1 71
00:91B2 52
00:91B3 04              	   544:   dfb $04,$19,$43,$04   ; 4194304
00:91B4 19
00:91B5 43
00:91B6 04
00:91B7 08              	   545:   dfb $08,$38,$86,$08   ; 8388608
00:91B8 38
00:91B9 86
00:91BA 08
                        	   546: 
                        	   547: ;--------------------------------------------------------------------------
                        	   548: ; display_in_decimal - start here - VALUE will be zero after this is executed
                        	   549: ;--------------------------------------------------------------------------
                        	   550: 
                        	   551: display_in_decimal  =  *
00:91BB A502            	   552:   lda  VALUE+2
00:91BD 1008            	   553:   bpl  bcd_positive
                        	   554: ;
                        	   555: ;  if the number is negative, output a minus sign and make it positive
                        	   556: ;
00:91BF A92D            	   557:   lda  #'-'
00:91C1 201894          	   558:   jsr  COUT
00:91C4 201BAC          	   559:   jsr  exp_unary_minus
                        	   560: ;
                        	   561: ;  number is now positive
                        	   562: ;
                        	   563: bcd_positive:
                        	   564: 
00:91C7 20E491          	   565:   jsr binary_to_decimal   ; do the conversion
                        	   566: 
00:91CA A207            	   567:   ldx  #7         ; zero suppress count (always keep the last zero)
00:91CC A000            	   568:   ldy  #0
                        	   569: ;
                        	   570: ;  this is skipping the leading zeroes
                        	   571: ;
                        	   572: bcd_skip_zeroes:
00:91CE B96000          	   573:   lda  bcd_result,Y
00:91D1 C930            	   574:   cmp  #'0'
00:91D3 D004            	   575:   bne  bcd_output_digit
00:91D5 C8              	   576:   iny
00:91D6 CA              	   577:   dex
00:91D7 D0F5            	   578:   bne  bcd_skip_zeroes
                        	   579: ;
                        	   580: ;  now we have a non-zero, start outputting them
                        	   581: ;
                        	   582: ;  Y points to how far we are through bcd_result
                        	   583: ;  X is how many digits to go
                        	   584: ;
                        	   585: bcd_output_digit:
00:91D9 B96000          	   586:   lda  bcd_result,Y
00:91DC 201894          	   587:   jsr  COUT
00:91DF C8              	   588:   iny
00:91E0 CA              	   589:   dex
00:91E1 10F6            	   590:   bpl  bcd_output_digit
                        	   591: ;
                        	   592: ;  done!
                        	   593: ;
00:91E3 60              	   594:   rts
                        	   595: 
                        	   596: ;--------------------------------------------------------------------------
                        	   597: ;
                        	   598: ;  Binary to decimal routine: Converts VALUE into bcd_result (8 digits)
                        	   599: ;
                        	   600: ;  See: http://www.6502.org/source/integers/hex2dec.htm
                        	   601: ;
                        	   602: ;  - VALUE will be zero after this is executed
                        	   603: ;
                        	   604: ;--------------------------------------------------------------------------
                        	   605: binary_to_decimal:
00:91E4 F8              	   606:   sed                 ; decimal mode for adds below
00:91E5 645C            	   607:   stz  bcd_work       ; zero our result area (4 bytes = 8 digits)
00:91E7 645D            	   608:   stz  bcd_work+1
00:91E9 645E            	   609:   stz  bcd_work+2
00:91EB 645F            	   610:   stz  bcd_work+3
                        	   611: 
00:91ED A25C            	   612:   ldx  #(4*23)        ; X points to the start of the highest entry
                        	   613: 
                        	   614: binary_to_decimal_loop:
00:91EF 0600            	   615:   asl VALUE      ;  shift out high-order bit into Carry
00:91F1 2601            	   616:   rol VALUE+1
00:91F3 2602            	   617:   rol VALUE+2
00:91F5 901D            	   618:   bcc binary_to_decimal_next  ; if carry clear, no add needs to be done
                        	   619: ;
                        	   620: ;  that bit was set, so add the appropriate BCD number from the table (eg. 1, 2, 4, 8, 16 and so on)
                        	   621: ;
00:91F7 18              	   622:   clc
00:91F8 A55C            	   623:   lda bcd_work
00:91FA 7D5E91          	   624:   adc bcd_table+3,X
00:91FD 855C            	   625:   sta bcd_work
00:91FF A55D            	   626:   lda bcd_work+1
00:9201 7D5D91          	   627:   adc bcd_table+2,X
00:9204 855D            	   628:   sta bcd_work+1
00:9206 A55E            	   629:   lda bcd_work+2
00:9208 7D5C91          	   630:   adc bcd_table+1,X
00:920B 855E            	   631:   sta bcd_work+2
00:920D A55F            	   632:   lda bcd_work+3
00:920F 7D5B91          	   633:   adc bcd_table,X
00:9212 855F            	   634:   sta bcd_work+3
                        	   635: 
                        	   636: binary_to_decimal_next:
00:9214 CA              	   637:   dex      ; back to the previous table item
00:9215 CA              	   638:   dex
00:9216 CA              	   639:   dex
00:9217 CA              	   640:   dex
00:9218 10D5            	   641:   bpl binary_to_decimal_loop
00:921A D8              	   642:   cld     ; decimal mode off
                        	   643: 
                        	   644: 
                        	   645: ;
                        	   646: ;  convert BCD to ASCII - note that UNPACK increments x by two each time
                        	   647: ;    - the results are in bcd_result - an 8-character field
                        	   648: ;
                        	   649: ;  We unpack the high-order bytes first, naturally
                        	   650: ;
00:921B A200            	   651:   ldx  #0
00:921D A55F            	   652:   lda  bcd_work+3
00:921F 204891          	   653:   jsr  bcd_unpack
00:9222 A55E            	   654:   lda  bcd_work+2
00:9224 204891          	   655:   jsr  bcd_unpack
00:9227 A55D            	   656:   lda  bcd_work+1
00:9229 204891          	   657:   jsr  bcd_unpack
00:922C A55C            	   658:   lda  bcd_work
00:922E 204891          	   659:   jsr  bcd_unpack
00:9231 60              	   660:   rts
                        	   661: 
00:9232 4E6F20736F757263	   662: NOSCE    asciiz  'No source file.\n'   ; No source file
00:923A 652066696C652E0A
00:9242 00
                        	   663: 
                        	   664: ;***********************************************
                        	   665: ;
                        	   666: ; Initialize a compile or assembly
                        	   667: ;
                        	   668: ;***********************************************
                        	   669: 
                        	   670: 
                        	   671: INIT     =  *
                        	   672: ;
                        	   673: ;  set up symbol table pointer
                        	   674: ;
                        	   675: 
00:9243 A93F            	   676:   lda  #>SYMBOL_TABLE_START
00:9245 8532            	   677:   sta  ENDSYM+1
00:9247 8530            	   678:   sta  STARTSYM+1
00:9249 A9FF            	   679:   lda  #<SYMBOL_TABLE_START
00:924B 8531            	   680:   sta  ENDSYM
00:924D 852F            	   681:   sta  STARTSYM
                        	   682: 
                        	   683: INIT_SECOND_PASS:   ; for assembler
                        	   684: 
00:924F A900            	   685:   lda  #0
00:9251 851D            	   686:   sta  LIST            ; not listing
00:9253 8522            	   687:   sta  LEVEL           ; variable level zero
00:9255 852E            	   688:   sta  DCODE
00:9257 853F            	   689:   sta  RUNNING         ; not running
00:9259 8539            	   690:   sta  PRCITM
00:925B 853A            	   691:   sta  PRCITM+1
00:925D 8502            	   692:   sta  REGB
00:925F 8593            	   693:   sta  token_type
00:9261 64BE            	   694:   stz  system_flags
00:9263 A901            	   695:   lda #1
00:9265 85A2            	   696:   sta  current_line        ; we are currently on line 1
00:9267 64A3            	   697:   stz  current_line+1
                        	   698: 
                        	   699: ;
                        	   700: ;  set up for reading first byte of source
                        	   701: ;
00:9269 A900            	   702:   lda  #<TEXT_START
00:926B 858E            	   703:   sta  token_start
00:926D 859C            	   704:   sta  token_line_start
00:926F A903            	   705:   lda  #>TEXT_START
00:9271 858F            	   706:   sta  token_start+1
00:9273 859D            	   707:   sta  token_line_start+1
00:9275 20D18C          	   708:   jsr  find_source_end
00:9278 A523            	   709:   lda  PCODE
00:927A 8525            	   710:   sta  ACT_PCDA
00:927C A524            	   711:   lda  PCODE+1
00:927E 8526            	   712:   sta  ACT_PCDA+1
00:9280 A000            	   713:   ldy  #0
00:9282 B18E            	   714:   lda  (token_start),y
00:9284 D00A            	   715:   bne  INIT9
00:9286 A932            	   716:   lda  #<NOSCE
00:9288 A292            	   717:   ldx  #>NOSCE
00:928A 202682          	   718:   jsr  print                      ; No source file
00:928D 4CCC82          	   719:   jmp  main_prompt
00:9290 60              	   720: INIT9    rts
                        	   721: 
                        	   722: 
                        	   723: 
                        	   724: 
                        	   725: ;
                        	   726: CROUT    =  *             ; show a newline
00:9291 A90A            	   727:   lda  #NL         ; was a carriage-return in legacy, now is newline
00:9293 4C1894          	   728:   jmp  COUT
                        	   729: ;
                        	   730: ;***********************************************
                        	   731: ; COMPARE STRING - compare SRCE to DEST, assumes DEST is upper-case
                        	   732: ;                - length in Y (therefore max 255 characters)
                        	   733: ;                - zero flag set if match (therefore do a BEQ to see if strings match)
                        	   734: ;***********************************************
                        	   735: COMSTL   =  *
00:9296 88              	   736:          dey
00:9297 300A            	   737:          bmi  COMS8
00:9299 B100            	   738:          lda  (SRCE),Y
00:929B 202D90          	   739:          jsr MAKE_UPPER
00:929E D103            	   740:          cmp  (DEST),Y
00:92A0 F0F4            	   741:          beq  COMSTL
00:92A2 60              	   742: COMS9    rts             ; NOT EQUAL
00:92A3 A900            	   743: COMS8    lda  #0
00:92A5 60              	   744:          rts             ; EQUAL
                        	   745: 
                        	   746: ;***********************************************
                        	   747: ; DISPLAY A LINE
                        	   748: ;
                        	   749: 
                        	   750: ;
                        	   751: ; DISPLAY IN HEX
                        	   752: ;
00:92A6 200693          	   753: DISHX    jsr  PRBYTE
00:92A9 4C1C93          	   754:          jmp  PUTSP
                        	   755: ;
                        	   756: 
                        	   757: ;***********************************************
                        	   758: ; DISPLAY PCODE ADDRESS
                        	   759: ;***********************************************
                        	   760: DISPAD   =  *
00:92AC A52E            	   761:          lda  DCODE
00:92AE F017            	   762:          beq  DISPAD2
                        	   763: DISPAD1  =  *
00:92B0 A928            	   764:          lda  #'('
00:92B2 201894          	   765:          jsr  COUT
00:92B5 A524            	   766:          lda  PCODE+1
00:92B7 200693          	   767:          jsr  PRBYTE
00:92BA A523            	   768:          lda  PCODE
00:92BC 200693          	   769:          jsr  PRBYTE
00:92BF A929            	   770:          lda  #')'
00:92C1 201894          	   771:          jsr  COUT
00:92C4 4C1C93          	   772:          jmp  PUTSP
00:92C7 60              	   773: DISPAD2  rts
                        	   774: ;
                        	   775: 
                        	   776: ;***********************************************
                        	   777: ; PUSH 'WORK' ONTO STACK
                        	   778: ;***********************************************
                        	   779: PSHWRK   =  *
00:92C8 8536            	   780:          sta  BSAVE
00:92CA 68              	   781:          pla
00:92CB AA              	   782:          tax
00:92CC 68              	   783:          pla
00:92CD A8              	   784:          tay
00:92CE A538            	   785:          lda  WORK+1
00:92D0 48              	   786:          pha
00:92D1 A537            	   787:          lda  WORK
00:92D3 48              	   788:          pha
00:92D4 98              	   789:          tya
00:92D5 48              	   790:          pha
00:92D6 8A              	   791:          txa
00:92D7 48              	   792:          pha
00:92D8 A536            	   793:          lda  BSAVE
00:92DA 60              	   794: PSH9     rts
                        	   795: ;
                        	   796: ;***********************************************
                        	   797: ; PULL 'WORK' FROM STACK
                        	   798: ;***********************************************
                        	   799: PULWRK   =  *
00:92DB 8536            	   800:          sta  BSAVE
00:92DD 68              	   801:          pla
00:92DE AA              	   802:          tax
00:92DF 68              	   803:          pla
00:92E0 A8              	   804:          tay
00:92E1 68              	   805:          pla
00:92E2 8537            	   806:          sta  WORK
00:92E4 68              	   807:          pla
00:92E5 8538            	   808:          sta  WORK+1
00:92E7 98              	   809:          tya
00:92E8 48              	   810:          pha
00:92E9 8A              	   811:          txa
00:92EA 48              	   812:          pha
00:92EB A536            	   813:          lda  BSAVE
00:92ED 60              	   814:          rts
                        	   815: ;
                        	   816: ;***********************************************
                        	   817: ; PRINTING SUBROUTINES
                        	   818: ; Control characters print with a ^ in front of them, eg. ^A
                        	   819: ;***********************************************
                        	   820: PRCHAR   =  *
00:92EE 48              	   821:   pha
00:92EF C90A            	   822:   cmp #NL
00:92F1 F00E            	   823:   beq prchar_not_control
00:92F3 C920            	   824:   cmp #$20
00:92F5 B00A            	   825:   bcs prchar_not_control
00:92F7 48              	   826:   pha
00:92F8 A95E            	   827:   lda #'^'
00:92FA 201894          	   828:   jsr COUT
00:92FD 68              	   829:   pla
00:92FE 18              	   830:   clc
00:92FF 6940            	   831:   adc #$40  ; make 0x01 print as ^A
                        	   832: prchar_not_control:
00:9301 201894          	   833:   jsr  COUT
00:9304 68              	   834:   pla
00:9305 60              	   835:   rts
                        	   836: ;
                        	   837: ; Prints A in hex
                        	   838: ;
                        	   839: PRBYTE:
00:9306 48              	   840:   pha
00:9307 4A              	   841:   lsr
00:9308 4A              	   842:   lsr
00:9309 4A              	   843:   lsr
00:930A 4A              	   844:   lsr
00:930B 201193          	   845:   jsr  PRHEXZ    ; first nibble
00:930E 68              	   846:   pla            ; now do other nibble
                        	   847: PRHEX:
00:930F 290F            	   848:   and  #$0F
                        	   849: PRHEXZ:
00:9311 0930            	   850:   ora  #'0'
00:9313 C93A            	   851:   cmp  #'0' + $0A
00:9315 9002            	   852:   bcc  PRHEX1
00:9317 6926            	   853:   adc  #$26  ; (carry is set: adding 7 to make 0x0a become 'a')
                        	   854: PRHEX1:
00:9319 4CEE92          	   855:   jmp  PRCHAR
                        	   856: ;
                        	   857: PUTSP    =  *
00:931C A920            	   858:   lda  #' '
00:931E 80F9            	   859:   bra  PRHEX1
                        	   860: ;
                        	   861: ;
                        	   862: ;  PT - put text
                        	   863: ;   Low-order address in A, high-order address in X, count in Y
                        	   864: ;
                        	   865: ;
                        	   866: PT:
00:9320 8503            	   867:   sta  REG2
00:9322 8604            	   868:   stx  REG2+1
00:9324 98              	   869:   tya    ; count of bytes to print
00:9325 AA              	   870:   tax    ; put that into X
00:9326 A000            	   871:   ldy  #0
                        	   872: PT6:
00:9328 B103            	   873:   lda  (REG2),Y    ; next character
00:932A 201894          	   874:   jsr COUT         ; show it
00:932D C8              	   875:   iny
00:932E CA              	   876:   dex
00:932F D0F7            	   877:   bne  PT6
00:9331 60              	   878:   rts
                        	   879: ;
                        	   880: ;
                        	   881: ;
                        	   882: ;---- token_address --> WORK
                        	   883: ;
                        	   884: TKNWRK   =  *
00:9332 48              	   885:          PHA
00:9333 A590            	   886:          LDA  token_address
00:9335 8537            	   887:          STA  WORK
00:9337 A591            	   888:          LDA  token_address+1
00:9339 8538            	   889:          STA  WORK+1
00:933B 68              	   890:          PLA
00:933C 60              	   891:          RTS
                        	   892: ;
                        	   893: ;---- WORK --> token_address
                        	   894: ;
                        	   895: WRKTKN   =  *
00:933D 48              	   896:          PHA
00:933E A537            	   897:          LDA  WORK
00:9340 8590            	   898:          STA  token_address
00:9342 A538            	   899:          LDA  WORK+1
00:9344 8591            	   900:          STA  token_address+1
00:9346 68              	   901:          PLA
00:9347 60              	   902:          RTS
                        	   903: ;
                        	   904: 
                        	   905: 
                        	   906: ;***********************************************
                        	   907: ; MENU, FILE HANDLING
                        	   908: ;***********************************************
                        	   909: ;
00:9348 502D636F64657320	   910: pcodes_ended_message        asciiz  "P-codes ended at $"
00:9350 656E646564206174
00:9358 2024
00:935A 00
00:935B 436F6D70696C6520	   911: compile_finished_message    asciiz  "Compile finished: No errors.\n"
00:9363 66696E6973686564
00:936B 3A204E6F20657272
00:9373 6F72732E0A
00:9378 00
00:9379 53796D626F6C2074	   912: symbol_table_ended_message  asciiz "Symbol table ended at $"
00:9381 61626C6520656E64
00:9389 65642061742024
00:9390 00
00:9391 4E6F2076616C6964	   913: no_valid_compile_message    asciiz  'No valid compile or assemble done before\n'
00:9399 20636F6D70696C65
00:93A1 206F722061737365
00:93A9 6D626C6520646F6E
00:93B1 65206265666F7265
00:93B9 0A
00:93BA 00
                        	   914: ;
                        	   915: PRBYTECR =  *
00:93BB 200693          	   916:          JSR  PRBYTE
00:93BE 4C9192          	   917:          JMP  CROUT
                        	   918: ;
                        	   919: ;
                        	   920: ;
                        	   921: CHK_VAL  =  *
00:93C1 A908            	   922:          LDA  #FLAG_VALID_COMPILE
00:93C3 0910            	   923:          ORA  #FLAG_VALID_ASSEMBLE
00:93C5 25BE            	   924:          and  system_flags
00:93C7 D00A            	   925:          BNE  CHK_VAL9
00:93C9 A991            	   926:          LDA  #<no_valid_compile_message    ; No valid Compile or Assemble done before
00:93CB A293            	   927:          LDX  #>no_valid_compile_message
00:93CD 202682          	   928:          JSR  print
00:93D0 4CCC82          	   929:          JMP  main_prompt
                        	   930: CHK_VAL9 =  *
                        	   931: BELL1X   =  *          ; no bell yet
00:93D3 60              	   932:          RTS
                        	   933: ;
00:93D4 20C193          	   934: CHK_RUN  JSR  CHK_VAL
00:93D7 A910            	   935:          lda  #FLAG_VALID_ASSEMBLE
00:93D9 25BE            	   936:          and  system_flags
00:93DB D003            	   937:          bne  run_assembler
00:93DD 4C5BAE          	   938:          JMP  INTERP
                        	   939: run_assembler:
00:93E0 20E693          	   940:          jsr call_assembler
00:93E3 4CF7AE          	   941:          JMP  EX_FINISHD
                        	   942: ;
                        	   943: ;  let's assume they put a RTS at the end of their code
                        	   944: ;
                        	   945: call_assembler:
00:93E6 A9E9            	   946:          LDA  #<running_message   ; Running
00:93E8 A2AD            	   947:          LDX  #>running_message
00:93EA 202682          	   948:          JSR  print
00:93ED 6C2500          	   949:          JMP (ACT_PCDA)
                        	   950: 
                        	   951: ;
                        	   952: 
                        	   953: ;
                        	   954: ; Get a line, read byte by byte until we get a newline, store in INBUF
                        	   955: ;   returns length in Y - handles backspace, ignores carriage-return
                        	   956: ;
                        	   957: GET_LINE =  *
                        	   958: GETLN1   =  *
00:93F0 A000            	   959:   ldy  #0
                        	   960: GET1:
00:93F2 200EC9          	   961:   jsr  CHRIN
00:93F5 C90D            	   962:   cmp  #CR       ; carriage-return?
00:93F7 F0F9            	   963:   beq  GET1       ; ignore it
00:93F9 990002          	   964:   sta  INBUF,Y    ; SAVE IN BUFFER
00:93FC C8              	   965:   iny
00:93FD F016            	   966:   beq  GETLN_OVERFLOW       ; overflow
00:93FF C90A            	   967:   cmp  #NL        ; END OF LINE?
00:9401 F00C            	   968:   beq  GET3       ; yes
00:9403 C908            	   969:   cmp  #BACKSPACE ; backspace?
00:9405 D0EB            	   970:   bne  GET1       ; no - keep adding to buffer
                        	   971: ;
                        	   972: ;  here for backspace
                        	   973: ;
00:9407 88              	   974:   dey  ; get rid of backspace
00:9408 88              	   975:   dey  ; get rid of character we backspaced over
00:9409 C0FF            	   976:   cpy  #$FF
00:940B F0E3            	   977:   beq  GETLN1   ; if Y underflowed, go back to zero
00:940D 80E3            	   978:   bra GET1
                        	   979: 
                        	   980: GET3:
00:940F A900            	   981:   lda  #0
00:9411 990002          	   982:   sta  INBUF,Y    ; turn newline into 0x00
00:9414 60              	   983:   rts             ; RETURN
                        	   984: ;
                        	   985: ;  here on INBUF overflow
                        	   986: ;
                        	   987: GETLN_OVERFLOW:
00:9415 88              	   988:   dey           ; get back to 255 (last byte)
00:9416 80F7            	   989:   bra  GET3     ; store a zero there
                        	   990: 
                        	   991: 
                        	   992: ;
                        	   993: ;  output a character - saves all registers
                        	   994: ;
                        	   995: COUT:
00:9418 48              	   996:   pha
00:9419 DA              	   997:   phx
00:941A 5A              	   998:   phy
00:941B 202294          	   999:   jsr COUT_CALL   ; call the current outputting routine
00:941E 7A              	  1000:   ply
00:941F FA              	  1001:   plx
00:9420 68              	  1002:   pla
00:9421 60              	  1003:   rts
                        	  1004: 
                        	  1005: 
                        	  1006: COUT_CALL:
00:9422 6C1700          	  1007:   jmp (write_function)
                        	  1008: 
                        	  1009: 

Source: "gpascal.asm"
                        	   177:   .include "errors.inc"

Source: "errors.inc"
                        	     1: 
                        	     2: errors_table:
00:9425 4D656D6F72792066	     3:   asciiz "Memory full"                               ;  1
00:942D 756C6C
00:9430 00
00:9431 436F6E7374616E74	     4:   asciiz "Constant expected"                         ;  2
00:9439 2065787065637465
00:9441 64
00:9442 00
00:9443 3D20657870656374	     5:   asciiz "= expected"                                ;  3
00:944B 6564
00:944D 00
00:944E 4964656E74696669	     6:   asciiz "Identifier expected"                       ;  4
00:9456 6572206578706563
00:945E 746564
00:9461 00
00:9462 2C206F72203A2065	     7:   asciiz ", or : expected"                           ;  5
00:946A 78706563746564
00:9471 00
00:9472 427567          	     8:   asciiz "Bug"                                       ;  6
00:9475 00
00:9476 2A29206F72207D20	     9:   asciiz "*) or } expected"                          ;  7
00:947E 6578706563746564
00:9486 00
00:9487 496E636F72726563	    10:   asciiz "Incorrect string"                          ;  8
00:948F 7420737472696E67
00:9497 00
00:9498 2E20657870656374	    11:   asciiz ". expected"                                ;  9
00:94A0 6564
00:94A2 00
00:94A3 3B20657870656374	    12:   asciiz "; expected"                                ; 10
00:94AB 6564
00:94AD 00
00:94AE 556E6465636C6172	    13:   asciiz "Undeclared identifier"                     ; 11
00:94B6 6564206964656E74
00:94BE 6966696572
00:94C3 00
00:94C4 496C6C6567616C20	    14:   asciiz "Illegal identifier"                        ; 12
00:94CC 6964656E74696669
00:94D4 6572
00:94D6 00
00:94D7 3A3D206578706563	    15:   asciiz ":= expected"                               ; 13
00:94DF 746564
00:94E2 00
00:94E3 4C69746572616C20	    16:   asciiz "Literal string of zero length"             ; 14
00:94EB 737472696E67206F
00:94F3 66207A65726F206C
00:94FB 656E677468
00:9500 00
00:9501 436F6D70696C6572	    17:   asciiz "Compiler limits exceeded"                  ; 15
00:9509 206C696D69747320
00:9511 6578636565646564
00:9519 00
00:951A 5448454E20657870	    18:   asciiz "THEN expected"                             ; 16
00:9522 6563746564
00:9527 00
00:9528 3B206F7220454E44	    19:   asciiz "; or END expected"                         ; 17
00:9530 2065787065637465
00:9538 64
00:9539 00
00:953A 444F206578706563	    20:   asciiz "DO expected"                               ; 18
00:9542 746564
00:9545 00
00:9546 496E636F72726563	    21:   asciiz "Incorrect symbol"                          ; 19
00:954E 742073796D626F6C
00:9556 00
00:9557 427567          	    22:   asciiz "Bug"                                       ; 20
00:955A 00
00:955B 557365206F662070	    23:   asciiz "Use of procedure identifier in expression" ; 21
00:9563 726F636564757265
00:956B 206964656E746966
00:9573 69657220696E2065
00:957B 787072657373696F
00:9583 6E
00:9584 00
00:9585 2920657870656374	    24:   asciiz ") expected"                                ; 22
00:958D 6564
00:958F 00
00:9590 496C6C6567616C20	    25:   asciiz "Illegal factor"                            ; 23
00:9598 666163746F72
00:959E 00
00:959F 54797065206D6973	    26:   asciiz "Type mismatch"                             ; 24
00:95A7 6D61746368
00:95AC 00
00:95AD 424547494E206578	    27:   asciiz "BEGIN expected"                            ; 25
00:95B5 706563746564
00:95BB 00
00:95BC 4F46206578706563	    28:   asciiz "OF expected"                               ; 26
00:95C4 746564
00:95C7 00
00:95C8 537461636B206675	    29:   asciiz "Stack full"                                ; 27
00:95D0 6C6C
00:95D2 00
00:95D3 544F206F7220444F	    30:   asciiz "TO or DOWNTO expected"                     ; 28
00:95DB 574E544F20657870
00:95E3 6563746564
00:95E8 00
00:95E9 537472696E67206C	    31:   asciiz "String literal too big"                    ; 29
00:95F1 69746572616C2074
00:95F9 6F6F20626967
00:95FF 00
00:9600 4E756D626572206F	    32:   asciiz "Number out of range"                       ; 30
00:9608 7574206F66207261
00:9610 6E6765
00:9613 00
00:9614 2820657870656374	    33:   asciiz "( expected"                                ; 31
00:961C 6564
00:961E 00
00:961F 2C20657870656374	    34:   asciiz ", expected"                                ; 32
00:9627 6564
00:9629 00
00:962A 5B20657870656374	    35:   asciiz "[ expected"                                ; 33
00:9632 6564
00:9634 00
00:9635 5D20657870656374	    36:   asciiz "] expected"                                ; 34
00:963D 6564
00:963F 00
00:9640 506172616D657465	    37:   asciiz "Parameters mismatched"                     ; 35
00:9648 7273206D69736D61
00:9650 7463686564
00:9655 00
00:9656 4461746120747970	    38:   asciiz "Data type not recognised"                  ; 36
00:965E 65206E6F74207265
00:9666 636F676E69736564
00:966E 00
00:966F 53796D626F6C2074	    39:   asciiz "Symbol table full"                         ; 37
00:9677 61626C652066756C
00:967F 6C
00:9680 00
00:9681 4475706C69636174	    40:   asciiz "Duplicate identifier"                      ; 38
00:9689 65206964656E7469
00:9691 66696572
00:9695 00
00:9696 56616C7565206578	    41:   asciiz "Value expected"                            ; 39
00:969E 706563746564
00:96A4 00
00:96A5 496C6C6567616C20	    42:   asciiz "Illegal opcode"                            ; 40
00:96AD 6F70636F6465
00:96B3 00
00:96B4 496C6C6567616C20	    43:   asciiz "Illegal addressing mode"                   ; 41
00:96BC 6164647265737369
00:96C4 6E67206D6F6465
00:96CB 00
00:96CC 4272616E6368206F	    44:   asciiz "Branch out of range"                       ; 42
00:96D4 7574206F66207261
00:96DC 6E6765
00:96DF 00
00:96E0 4E656564207A6572	    45:   asciiz "Need zero page address"                    ; 43
00:96E8 6F20706167652061
00:96F0 646472657373
00:96F6 00
00:96F7 4F706572616E6420	    46:   asciiz "Operand too large"                         ; 44
00:96FF 746F6F206C617267
00:9707 65
00:9708 00
00:9709 53796D626F6C2061	    47:   asciiz "Symbol address changed"                    ; 45
00:9711 6464726573732063
00:9719 68616E676564
00:971F 00
00:9720 4578707265737369	    48:   asciiz "Expression too complex"                    ; 46
00:9728 6F6E20746F6F2063
00:9730 6F6D706C6578
00:9736 00
00:9737 4469766964652062	    49:   asciiz "Divide by zero"                            ; 47
00:973F 79207A65726F
00:9745 00
00:9746 4C6162656C207265	    50:   asciiz "Label required"                            ; 48
00:974E 717569726564
00:9754 00
00:9755 53796D626F6C2074	    51:   asciiz "Symbol table in use"                       ; 49
00:975D 61626C6520696E20
00:9765 757365
00:9768 00
00:9769 4E6F204C4344    	    52:   asciiz "No LCD"                                    ; 50
00:976F 00
00:9770 436F646520616C72	    53:   asciiz "Code already generated"                    ; 51
00:9778 656164792067656E
00:9780 657261746564
00:9786 00
                        	    54: assertion_failed_message:   ; used by Pascal assert function
00:9787 417373657274696F	    55:   asciiz "Assertion failed"                          ; 52
00:978F 6E206661696C6564
00:9797 00
00:9798 557365206F662066	    56:   asciiz "Use of function identifier in statement"   ; 53
00:97A0 756E6374696F6E20
00:97A8 6964656E74696669
00:97B0 657220696E207374
00:97B8 6174656D656E74
00:97BF 00
00:97C0 00              	    57:   dfb 0
                        	    58: 
                        	    59: ;***********************************************
                        	    60: ; DISPLAY ERROR - this does not return to the caller
                        	    61: ;  but to main_prompt
                        	    62: ;  Error number in X
                        	    63: ;***********************************************
00:97C1 2A2A2A204572726F	    64: ERRLIT   asciiz  '*** Error: '
00:97C9 723A20
00:97CC 00
                        	    65: 
00:97CD 8635            	    66: ERROR    stx  ERRNO
00:97CF A53F            	    67:          lda  RUNNING
00:97D1 F003            	    68:          beq  ERR7
00:97D3 4C0A98          	    69:          jmp  ERR6
                        	    70: ERR7     =  *
00:97D6 A51D            	    71:          lda  LIST
00:97D8 D006            	    72:          bne  ERR1
00:97DA 209192          	    73:          jsr  CROUT
00:97DD 206298          	    74:          jsr  show_current_line
                        	    75: ERR1     =  *
00:97E0 A590            	    76:          lda  token_address
00:97E2 38              	    77:          sec
00:97E3 E59C            	    78:          sbc  token_line_start  ; TODO: what about high-order byte?
00:97E5 48              	    79:          pha             ; CHARS UP TO ERROR POINT
00:97E6 A9C1            	    80:          lda  #<ERRLIT   ; *** Error
00:97E8 A297            	    81:          ldx  #>ERRLIT
00:97EA 202682          	    82:          jsr  print
00:97ED 68              	    83:          pla
00:97EE 18              	    84:          clc
00:97EF 6901            	    85:          adc   #1
00:97F1 8545            	    86:          sta  TEMP       ; BYTES TO ERROR POINT
00:97F3 AA              	    87:          tax
                        	    88: ERR3     =  *
00:97F4 201C93          	    89:          jsr  PUTSP
00:97F7 CA              	    90:          dex
00:97F8 D0FA            	    91:          bne  ERR3
00:97FA A95E            	    92:          lda  #'^'
00:97FC 201894          	    93:          jsr  COUT
00:97FF 209192          	    94:          jsr  CROUT
00:9802 A209            	    95:          ldx  #9
                        	    96: ERR5     =  *
00:9804 201C93          	    97:          jsr  PUTSP
00:9807 CA              	    98:          dex
00:9808 D0FA            	    99:          bne  ERR5
                        	   100: ERR6     =  *
00:980A A925            	   101:   lda #<errors_table
00:980C 8500            	   102:   sta REG
00:980E A994            	   103:   lda #>errors_table
00:9810 8501            	   104:   sta REG+1
00:9812 A200            	   105:   ldx #0
00:9814 A000            	   106:   ldy #0
                        	   107: error_next:
00:9816 E8              	   108:   inx
                        	   109: error_loop:
00:9817 E435            	   110:   cpx ERRNO
00:9819 F02A            	   111:   beq error_found
                        	   112: error_find_next:
00:981B B100            	   113:   lda (REG),Y
00:981D 48              	   114:   pha
00:981E E600            	   115:   inc REG
00:9820 D002            	   116:   bne error1
00:9822 E601            	   117:   inc REG+1
                        	   118: error1:
00:9824 68              	   119:   pla           ; get the previous byte
00:9825 D0F4            	   120:   bne error_find_next
00:9827 B100            	   121:   lda (REG),Y   ; a null after a null?
00:9829 F002            	   122:   beq error_not_found
00:982B 80E9            	   123:   bra error_next  ; we got a null, so add 1 to our current error number (X)
                        	   124: 
                        	   125: error_not_found:
00:982D A952            	   126:   lda #<error_not_found_message
00:982F A298            	   127:   ldx #>error_not_found_message
00:9831 202682          	   128:   jsr print
00:9834 A535            	   129:   lda ERRNO
00:9836 8500            	   130:   sta REG
00:9838 6401            	   131:   stz REG+1
00:983A 6402            	   132:   stz REGB
00:983C 20BB91          	   133:   jsr display_in_decimal
00:983F 209192          	   134:   jsr CROUT
00:9842 4CCC82          	   135:   jmp main_prompt
                        	   136: 
                        	   137: error_found:
00:9845 A500            	   138:   lda REG
00:9847 A601            	   139:   ldx REG+1
00:9849 202682          	   140:   jsr print
00:984C 209192          	   141:   jsr CROUT
00:984F 4CCC82          	   142:   jmp  main_prompt
                        	   143: 
00:9852 556E6B6E6F776E20	   144: error_not_found_message asciiz "Unknown error: "
00:985A 6572726F723A20
00:9861 00
                        	   145: 
                        	   146: show_current_line:
00:9862 A928            	   147:   lda #'('
00:9864 201894          	   148:   jsr COUT
00:9867 A524            	   149:   lda PCODE+1
00:9869 200693          	   150:   jsr PRBYTE
00:986C A523            	   151:   lda PCODE
00:986E 200693          	   152:   jsr PRBYTE
00:9871 A929            	   153:   lda #')'
00:9873 201894          	   154:   jsr COUT
00:9876 201C93          	   155:   jsr PUTSP
00:9879 205F8C          	   156:   jsr show_current_line_number
00:987C A59C            	   157:   lda token_line_start
00:987E 85A6            	   158:   sta mem_move_src
00:9880 A59D            	   159:   lda token_line_start+1
00:9882 85A7            	   160:   sta mem_move_src+1
                        	   161: 
                        	   162: show_current_line_loop:
00:9884 A000            	   163:   ldy #0
00:9886 B1A6            	   164:   lda (mem_move_src),Y
00:9888 F01D            	   165:   beq show_current_line_done
00:988A C90A            	   166:   cmp #NL
00:988C F019            	   167:   beq show_current_line_done
00:988E C920            	   168:   cmp #$20
00:9890 B00A            	   169:   bcs show_current_line_loop_print_one_character
00:9892 48              	   170:   pha
00:9893 A95E            	   171:   lda #'^'
00:9895 201894          	   172:   jsr COUT
00:9898 68              	   173:   pla
00:9899 18              	   174:   clc
00:989A 6940            	   175:   adc #$40  ; make 0x01 print as ^A
                        	   176: show_current_line_loop_print_one_character:
00:989C 201894          	   177:   jsr COUT    ; show that byte
00:989F E6A6            	   178:   inc mem_move_src
00:98A1 D0E1            	   179:   bne show_current_line_loop
00:98A3 E6A7            	   180:   inc mem_move_src+1
00:98A5 80DD            	   181:   bra show_current_line_loop
                        	   182: 
                        	   183: show_current_line_done:
00:98A7 209192          	   184:   jsr CROUT
00:98AA 60              	   185:   rts
                        	   186: 

Source: "gpascal.asm"
                        	   178:   .include "assembler.inc"

Source: "assembler.inc"
                        	     1: ;***********************************************
                        	     2: ;
                        	     3: ; Assembler
                        	     4: ;
                        	     5: ;***********************************************
                        	     6: 
                        	     7: ;***********************************************
                        	     8: ; Assembler operand types
                        	     9: ;***********************************************
                        	    10: 
                        	    11: ASS_OPERAND_ABSOLUTE                           =  1      ; a
                        	    12: ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT          =  2      ; (a,x)
                        	    13: ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X            =  3      ; a,x
                        	    14: ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y            =  4      ; a,y
                        	    15: ASS_OPERAND_ABSOLUTE_INDIRECT                  =  5      ; (a)
                        	    16: ASS_OPERAND_ACCUMULATOR_A                      =  6      ; A
                        	    17: ASS_OPERAND_IMMEDIATE                          =  7      ; #
                        	    18: ASS_OPERAND_IMPLIED                            =  8      ; i
                        	    19: ASS_OPERAND_PROGRAM_COUNTER_RELATIVE           =  9      ; r
                        	    20: ASS_OPERAND_STACK                              = 10      ; s
                        	    21: ASS_OPERAND_ZERO_PAGE                          = 11      ; zp
                        	    22: ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT         = 12      ; (zp,x)
                        	    23: ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X           = 13      ; zp,x
                        	    24: ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y           = 14      ; zp,y
                        	    25: ASS_OPERAND_ZERO_PAGE_INDIRECT                 = 15      ; (zp)
                        	    26: ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y  = 16      ; (zp),y
                        	    27: ASS_OPERAND_STRING                             = 17      ; "But does it get goat's blood out?"
                        	    28: ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE             = 18      ; zp,r
                        	    29: 
                        	    30: ;
                        	    31: ;  Entry point for assembler
                        	    32: ;
                        	    33: ASSEMBLE:
                        	    34: 
00:98AB A2FF            	    35:    ldx  #NEW_STK
00:98AD 9A              	    36:    txs    ; set stack back to 0xFF
00:98AE 6476            	    37:    stz  ASS_PASS  ; first pass
00:98B0 204392          	    38:    jsr  INIT       ; sets up pointers, calls LINE
00:98B3 2089AA          	    39:    jsr  add_assembler_library_functions  ; add our inbuilt functions to the symbol table
00:98B6 8005            	    40:    bra  ASSEMBLE_PASS
                        	    41: 
                        	    42: ASSEMBLE_SECOND_PASS:
00:98B8 E676            	    43:    inc  ASS_PASS
00:98BA 204F92          	    44:    jsr  INIT_SECOND_PASS    ; don't re-initialise the symbol table
                        	    45: ASSEMBLE_PASS:
00:98BD 64A2            	    46:    stz  current_line  ; we'll got for zero, not one
                        	    47: 
00:98BF A902            	    48:    lda  #FLAG_ASSEMBLING
00:98C1 04BE            	    49:    tsb  system_flags
                        	    50: 
                        	    51: ;
                        	    52: ;  no listing yet
                        	    53: ;
00:98C3 642E            	    54:    stz  DCODE
00:98C5 641D            	    55:    stz  LIST
00:98C7 6442            	    56:    stz  SYNTAX
00:98C9 6482            	    57:    stz  show_symbols
                        	    58: ;
                        	    59: ; zero line count
                        	    60: ;
00:98CB 6419            	    61:    stz  LINE_CNT
00:98CD 641A            	    62:    stz  LINE_CNT+1
                        	    63: 
                        	    64: ;
                        	    65: ;  and emitted bytes count
                        	    66: ;
00:98CF 6477            	    67:    stz ass_emit_bytes
00:98D1 6478            	    68:    stz ass_emit_bytes+1
                        	    69: 
                        	    70: ;
                        	    71: ; no previous token
                        	    72: ;
00:98D3 6493            	    73:    stz  token_type
00:98D5 800E            	    74:    bra ass_line
                        	    75: 
                        	    76: ass_finish_line:
00:98D7 A593            	    77:    lda token_type
00:98D9 C90A            	    78:    cmp #NL
00:98DB F008            	    79:    beq ass_line
00:98DD A213            	    80:    ldx #19    ; Incorrect Symbol
00:98DF 4C0D9F          	    81:    jmp ass_error
                        	    82: 
                        	    83: ass_done_jump:
00:98E2 4CE09B          	    84:    jmp ass_done
                        	    85: ;
                        	    86: ;  here for the start of a line
                        	    87: ;
                        	    88: ass_line:
00:98E5 A576            	    89:   lda ASS_PASS    ; only showing codes on 2nd pass
00:98E7 F00B            	    90:   beq ass_line1
00:98E9 A56F            	    91:   lda ASS_EMIT_COUNT  ; only need a newline if we actually output a code
00:98EB F007            	    92:   beq ass_line1
00:98ED A52E            	    93:   lda DCODE           ; is showing codes on?
00:98EF F003            	    94:   beq ass_line1
00:98F1 209192          	    95:   jsr CROUT
                        	    96: ass_line1:
00:98F4 A000            	    97:   ldy #0
00:98F6 B18E            	    98:   lda (token_start),y ; quick test so we don't list a non-existent line
00:98F8 F0E8            	    99:   beq ass_done_jump
                        	   100: 
00:98FA A58E            	   101:   lda token_start
00:98FC 859C            	   102:   sta token_line_start
00:98FE A58F            	   103:   lda token_start+1
00:9900 859D            	   104:   sta token_line_start+1
00:9902 202CCA          	   105:   jsr token_line        ; list the next line
                        	   106: 
00:9905 646B            	   107:   stz ASS_OPERAND   ; no operand yet
00:9907 646F            	   108:   stz ASS_EMIT_COUNT
00:9909 6483            	   109:   stz ass_current_label
00:990B 6484            	   110:   stz ass_current_label+1
                        	   111: 
00:990D 208CC9          	   112:   jsr get_token
                        	   113: 
00:9910 C949            	   114:   cmp #TOKEN_IDENTIFIER  ; could be a label if in column 1
00:9912 F011            	   115:   beq ass_identifier
00:9914 C93D            	   116:   cmp #'='               ; = directive is OK
00:9916 F00D            	   117:   beq ass_identifier
                        	   118: 
00:9918 C90A            	   119:   cmp #NL
00:991A F0C9            	   120:   beq ass_line
                        	   121: 
00:991C C900            	   122:   cmp #0
00:991E F0C2            	   123:   beq ass_done_jump
                        	   124: 
                        	   125: ass_bad_identifier:
00:9920 A204            	   126:   ldx #4      ; Identifier expected
00:9922 4C0D9F          	   127:   JMP ass_error
                        	   128: 
                        	   129: ass_identifier:
                        	   130: 
                        	   131: ;
                        	   132: ;  if the identifier is at the start of the line, it is a label, not an opcode
                        	   133: ;
00:9925 A590            	   134:   lda token_address
00:9927 C59C            	   135:   cmp token_line_start
00:9929 D063            	   136:   bne ass_opcode
00:992B A591            	   137:   lda token_address+1
00:992D C59D            	   138:   cmp token_line_start+1
00:992F D05D            	   139:   bne ass_opcode
                        	   140: 
00:9931 A593            	   141:   lda token_type         ; can't have = as an identifier
00:9933 C93D            	   142:   cmp #'='               ; or "="
00:9935 F0E9            	   143:   beq ass_bad_identifier
                        	   144: 
                        	   145: ;
                        	   146: ;  here for label - on the first pass, add it to the symbol table, on the second pass look it up
                        	   147: ;
00:9937 A576            	   148:   lda ASS_PASS
00:9939 D014            	   149:   bne ass_lookup_existing_label
                        	   150: ;
                        	   151: ;  here for first pass
                        	   152: ;
00:993B 2035BA          	   153:   jsr CHKDUP
                        	   154: ;
                        	   155: ; not a duplicate - add it
                        	   156: ;
00:993E A523            	   157:   lda PCODE
00:9940 8594            	   158:   sta token_value
00:9942 A524            	   159:   lda PCODE+1
00:9944 8595            	   160:   sta token_value+1
00:9946 6496            	   161:   stz token_value+2
00:9948 A943            	   162:   lda #SYMBOL_CONSTANT
00:994A 208EB9          	   163:   jsr ADDSYM
00:994D 8016            	   164:   bra ass_added_symbol
                        	   165: 
                        	   166: ;
                        	   167: ;  here for second pass
                        	   168: ;
                        	   169: ass_lookup_existing_label:
00:994F 2012B9          	   170:   jsr SEARCH  ; look it up
00:9952 D005            	   171:   bne ass_lookup_save_address  ; it should be!
00:9954 A206            	   172:   ldx #6  ; ERROR: bug
00:9956 4C0D9F          	   173:   jmp ass_error
                        	   174: 
                        	   175: ass_lookup_save_address:
00:9959 A594            	   176:   lda token_value
00:995B 8573            	   177:   sta ASS_VALUE
00:995D A595            	   178:   lda token_value+1
00:995F 8574            	   179:   sta ASS_VALUE+1
00:9961 A596            	   180:   lda token_value+2
00:9963 8575            	   181:   sta ASS_VALUE+2
                        	   182: 
                        	   183: ;
                        	   184: ;  the symbol has either been added, or looked up to make sure it is still there
                        	   185: ;
                        	   186: ass_added_symbol:
                        	   187: 
                        	   188: ;
                        	   189: ;  remember its address in case we have an EQU directive
                        	   190: ;
00:9965 A540            	   191:   lda SYMITM
00:9967 8583            	   192:   sta ass_current_label
00:9969 A541            	   193:   lda SYMITM+1
00:996B 8584            	   194:   sta ass_current_label+1
                        	   195: 
                        	   196: ;
                        	   197: ;  get whatever is after the label
                        	   198: ;
00:996D 208CC9          	   199:   jsr get_token
00:9970 C93A            	   200:   cmp #':'
00:9972 D003            	   201:   bne ass_not_colon
00:9974 208CC9          	   202:   jsr get_token  ; skip the colon
                        	   203: ass_not_colon:
00:9977 C90A            	   204:   cmp #NL     ; newline means this is just a label line
00:9979 D003            	   205:   bne ass_not_colon2
00:997B 4CD798          	   206:   jmp ass_finish_line
                        	   207: 
                        	   208: ass_not_colon2:
00:997E C949            	   209:   cmp #TOKEN_IDENTIFIER  ; should be an opcode now
00:9980 F00C            	   210:   beq ass_opcode
00:9982 C93D            	   211:   cmp #'='               ; = directive is OK
00:9984 F008            	   212:   beq ass_opcode
                        	   213: 
                        	   214: ass_illegal_opcode:
00:9986 200693          	   215:   jsr PRBYTE
00:9989 A228            	   216:   ldx #40      ; ERROR: illegal opcode
00:998B 4C0D9F          	   217:   JMP ass_error
                        	   218: 
                        	   219: ass_opcode:
                        	   220: 
                        	   221: ;
                        	   222: ;  this will be our assembler mnemonic or directive so save its start point and length
                        	   223: ;
                        	   224: 
00:998E A690            	   225:   ldx token_address
00:9990 866C            	   226:   stx OPCODE
00:9992 A691            	   227:   ldx token_address+1
00:9994 866D            	   228:   stx OPCODE+1
00:9996 A692            	   229:   ldx token_length
00:9998 866E            	   230:   stx OPCODE_LEN
                        	   231: 
                        	   232: ;
                        	   233: ;  if we had a label on the line, check its address hasn't changed (on the second pass)
                        	   234: ;   UNLESS it is an EQU directive in which case it probably did change
                        	   235: ;
00:999A A576            	   236:   lda ASS_PASS
00:999C F046            	   237:   beq ass_opcode2
00:999E A583            	   238:   lda ass_current_label
00:99A0 0584            	   239:   ora ass_current_label+1   ; was there a label?
00:99A2 F040            	   240:   beq ass_opcode2    ; nope
00:99A4 A593            	   241:   lda token_type
00:99A6 C93D            	   242:   cmp #'='
00:99A8 F03A            	   243:   beq ass_opcode2   ; don't check on "=" directive
00:99AA A592            	   244:   lda token_length
00:99AC C903            	   245:   cmp #3
00:99AE D034            	   246:   bne ass_opcode2   ; can't be EQU
                        	   247: ;
                        	   248: ; this is truly crap, but I am feeling lazy
                        	   249: ;
00:99B0 A000            	   250:   ldy #0
00:99B2 B190            	   251:   lda (token_address),y
00:99B4 202D90          	   252:   jsr MAKE_UPPER
00:99B7 C945            	   253:   cmp #'E'
00:99B9 D014            	   254:   bne ass_check_label_changed
00:99BB C8              	   255:   iny
00:99BC B190            	   256:   lda (token_address),y
00:99BE 202D90          	   257:   jsr MAKE_UPPER
00:99C1 C951            	   258:   cmp #'Q'
00:99C3 D00A            	   259:   bne ass_check_label_changed
00:99C5 C8              	   260:   iny
00:99C6 B190            	   261:   lda (token_address),y
00:99C8 202D90          	   262:   jsr MAKE_UPPER
00:99CB C955            	   263:   cmp #'U'
00:99CD F015            	   264:   beq ass_opcode2
                        	   265: 
                        	   266: ;
                        	   267: ;  we looked up the label earlier, when it was the current token,
                        	   268: ;   and we saved its value in ASS_VALUE
                        	   269: ;
                        	   270: 
                        	   271: ass_check_label_changed:
00:99CF A523            	   272:   lda PCODE
00:99D1 C573            	   273:   cmp ASS_VALUE
00:99D3 D00A            	   274:   bne ass_symbol_address_changed
00:99D5 A524            	   275:   lda PCODE+1
00:99D7 C574            	   276:   cmp ASS_VALUE+1
00:99D9 D004            	   277:   bne ass_symbol_address_changed
00:99DB A575            	   278:   lda ASS_VALUE+2   ; 3rd byte should be zero
00:99DD F005            	   279:   beq ass_opcode2
                        	   280: 
                        	   281: ass_symbol_address_changed:
00:99DF A22D            	   282:   ldx #45     ; ERROR: Symbol address changed
00:99E1 4C0D9F          	   283:   jmp ass_error
                        	   284: 
                        	   285: 
                        	   286: 
                        	   287: ass_opcode2:
                        	   288: ;
                        	   289: ;  look up operand
                        	   290: ;
                        	   291: 
00:99E4 208CC9          	   292:   jsr get_token
00:99E7 C90A            	   293:   cmp #NL           ; or end of line?
00:99E9 D00D            	   294:   bne ass_operand
                        	   295: 
                        	   296: ;
                        	   297: ;  here when the opcode is followed by (spaces) or a newline
                        	   298: ;
00:99EB A908            	   299:   lda #ASS_OPERAND_IMPLIED
00:99ED 856B            	   300:   sta ASS_OPERAND
00:99EF 20379B          	   301:   jsr opcode_lookup
00:99F2 20239C          	   302:   jsr ass_check_no_more_tokens
                        	   303: ass_finish_lineJ:
00:99F5 4CD798          	   304:   jmp ass_finish_line
                        	   305: 
                        	   306: ass_operand:
00:99F8 C923            	   307:   cmp #'#'  ; immediate?
00:99FA F01B            	   308:   beq ass_immediate
00:99FC C928            	   309:   cmp #'('  ; indirect?
00:99FE F02A            	   310:   beq ass_indirect
00:9A00 C949            	   311:   cmp #TOKEN_IDENTIFIER
00:9A02 F02F            	   312:   beq ass_identifier_operand
00:9A04 C922            	   313:   cmp #TOKEN_STRING
00:9A06 F002            	   314:   beq ass_string
                        	   315: ;
                        	   316: ;  here for some kind of numeric address
                        	   317: ;
00:9A08 804A            	   318:   bra ass_operand_value
                        	   319: 
                        	   320: ;
                        	   321: ;  Here for a string as an operand, should be a compiler directive, eg.  ASC "Hello, world"
                        	   322: ;
                        	   323: ass_string:
00:9A0A A911            	   324:   lda #ASS_OPERAND_STRING
00:9A0C 856B            	   325:   sta ASS_OPERAND
00:9A0E 20379B          	   326:   jsr opcode_lookup
00:9A11 208CC9          	   327:   jsr get_token  ; NOW get the next token
00:9A14 4CD798          	   328:   jmp ass_finish_line
                        	   329: 
                        	   330: ;
                        	   331: ;  immediate, that is:  #<expression>
                        	   332: ;
                        	   333: ass_immediate:
00:9A17 A907            	   334:   lda #ASS_OPERAND_IMMEDIATE
00:9A19 856B            	   335:   sta ASS_OPERAND
00:9A1B 208CC9          	   336:   jsr get_token
00:9A1E 203A9D          	   337:   jsr ass_get_value
00:9A21 20239C          	   338:   jsr ass_check_no_more_tokens
00:9A24 20379B          	   339:   jsr opcode_lookup
00:9A27 4CD798          	   340:   jmp ass_finish_line
                        	   341: 
                        	   342: ;
                        	   343: ;  indirect, that is: (expression) OR (expression,X) OR (expression),Y
                        	   344: ;
                        	   345: ass_indirect:
00:9A2A A905            	   346:   lda #ASS_OPERAND_ABSOLUTE_INDIRECT  ; first guess
00:9A2C 856B            	   347:   sta ASS_OPERAND
00:9A2E 208CC9          	   348:   jsr get_token    ; skip the bracket
00:9A31 8021            	   349:   bra ass_operand_value
                        	   350: 
                        	   351: ;
                        	   352: ;  some sort of identifier, possibly the start of an expression or maybe just "A"
                        	   353: ;
                        	   354: ass_identifier_operand:
                        	   355: 
                        	   356: ;
                        	   357: ;  see if the operand is just the letter "A"
                        	   358: ;
00:9A33 A592            	   359:   lda token_length
00:9A35 C901            	   360:   cmp #1
00:9A37 D01B            	   361:   bne ass_operand_value
00:9A39 A000            	   362:   ldy #0
00:9A3B B190            	   363:   lda (token_address),Y
00:9A3D 202D90          	   364:   jsr MAKE_UPPER
00:9A40 C941            	   365:   cmp #'A'
00:9A42 D010            	   366:   bne ass_operand_value
00:9A44 A906            	   367:   lda #ASS_OPERAND_ACCUMULATOR_A
00:9A46 856B            	   368:   sta ASS_OPERAND
00:9A48 208CC9          	   369:   jsr get_token  ; skip past A
00:9A4B 20239C          	   370:   jsr ass_check_no_more_tokens
00:9A4E 20379B          	   371:   jsr opcode_lookup
00:9A51 4CD798          	   372:   jmp ass_finish_line
                        	   373: 
                        	   374: ;
                        	   375: ;  a number or identifier - evaluate as an expression
                        	   376: ;
                        	   377: ass_operand_value:
                        	   378: 
00:9A54 A593            	   379:   lda token_type ; get token back
00:9A56 203A9D          	   380:   jsr ass_get_value  ; should have some sort of address now in VALUE
                        	   381: ;
                        	   382: ;  we come back with the first non-value token loaded in TOKEN
                        	   383: ;  now see if we originally had a bracket, so this must be one of those indirect things
                        	   384: ;
00:9A59 A56B            	   385:   lda ASS_OPERAND
00:9A5B C905            	   386:   cmp #ASS_OPERAND_ABSOLUTE_INDIRECT
00:9A5D D02D            	   387:   bne ass_value_not_indirectJ
00:9A5F A593            	   388:   lda token_type   ; now we should have a comma or a bracket
00:9A61 C929            	   389:   cmp #')'
00:9A63 F02F            	   390:   beq ass_indirect_with_bracket
                        	   391: ;
                        	   392: ;  We had an opening bracket but not a closing bracket. Must be a comma then
                        	   393: ;
                        	   394: 
00:9A65 A92C            	   395:   lda #','
00:9A67 A220            	   396:   ldx #32  ; ERROR: , expected
00:9A69 209ECF          	   397:   jsr CHKTKN
                        	   398: ;
                        	   399: ;  now we must have X
                        	   400: ;
00:9A6C 20D09A          	   401:   jsr ass_check_we_have_x_or_y
00:9A6F 901E            	   402:   bcc ass_bad_indirect
00:9A71 C958            	   403:   cmp #'X'
00:9A73 D01A            	   404:   bne ass_bad_indirect
00:9A75 A902            	   405:   lda #ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
00:9A77 856B            	   406:   sta ASS_OPERAND
00:9A79 A929            	   407:   lda #')'
00:9A7B A216            	   408:   ldx #22  ; ERROR: ) expected
00:9A7D 208ECF          	   409:   jsr GETCHK
00:9A80 208CC9          	   410:   jsr get_token
00:9A83 20239C          	   411:   jsr ass_check_no_more_tokens
00:9A86 20379B          	   412:   jsr opcode_lookup
00:9A89 4CD798          	   413:   jmp ass_finish_line
                        	   414: 
00:9A8C 4CEE9A          	   415: ass_value_not_indirectJ jmp ass_value_not_indirect
                        	   416: 
                        	   417: ass_bad_indirect:
00:9A8F A229            	   418:   ldx #41  ; ERROR: illegal addressing mode
00:9A91 4C0D9F          	   419:   jmp ass_error
                        	   420: 
                        	   421: 
                        	   422: ;
                        	   423: ;  we have some sort of indirect expression followed by a bracket, so see if there is ",Y" after it
                        	   424: ;
                        	   425: ass_indirect_with_bracket:
                        	   426: ;
                        	   427: ;  can only be (a), (zp) or (zp),y
                        	   428: ;
00:9A94 208CC9          	   429:   jsr get_token
00:9A97 C92C            	   430:   cmp #','
00:9A99 F00D            	   431:   beq ass_zp_indirect_indexed
00:9A9B 20239C          	   432:   jsr ass_check_no_more_tokens
00:9A9E A905            	   433:   lda #ASS_OPERAND_ABSOLUTE_INDIRECT
00:9AA0 856B            	   434:   sta ASS_OPERAND
00:9AA2 20379B          	   435:   jsr opcode_lookup
00:9AA5 4CD798          	   436:   jmp ass_finish_line
                        	   437: 
                        	   438: 
                        	   439: ;
                        	   440: ;  For indirect followed by a comma, we must have Y and nothing else
                        	   441: ;  Also, the operand must be a zero-page address
                        	   442: ;
                        	   443: ass_zp_indirect_indexed:
00:9AA8 20D09A          	   444:   jsr ass_check_we_have_x_or_y
00:9AAB 90E2            	   445:   bcc ass_bad_indirect
00:9AAD C959            	   446:   cmp #'Y'
00:9AAF D0DE            	   447:   bne ass_bad_indirect
00:9AB1 A574            	   448:   lda ASS_VALUE+1
00:9AB3 D014            	   449:   bne ass_bad_zp_indirect_indexed
00:9AB5 A575            	   450:   lda ASS_VALUE+2
00:9AB7 D010            	   451:   bne ass_bad_zp_indirect_indexed
00:9AB9 A910            	   452:   lda #ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
00:9ABB 856B            	   453:   sta ASS_OPERAND
00:9ABD 208CC9          	   454:   jsr get_token  ; skip the Y
00:9AC0 20239C          	   455:   jsr ass_check_no_more_tokens
00:9AC3 20379B          	   456:   jsr opcode_lookup
00:9AC6 4CD798          	   457:   jmp ass_finish_line
                        	   458: 
                        	   459: ass_bad_zp_indirect_indexed:
00:9AC9 A22B            	   460:   ldx #43
00:9ACB 4C0D9F          	   461:   jmp ass_error
                        	   462: 
                        	   463: ass_not_x_or_y:
00:9ACE 18              	   464:   clc
00:9ACF 60              	   465:   rts
                        	   466: 
                        	   467: ;
                        	   468: ;  we had (<expression>),<something> so check that <something> is X or Y
                        	   469: ;   sets carry if it is
                        	   470: ;
                        	   471: ass_check_we_have_x_or_y:
00:9AD0 208CC9          	   472:   jsr get_token
00:9AD3 C949            	   473:   cmp #TOKEN_IDENTIFIER
00:9AD5 D0F7            	   474:   bne ass_not_x_or_y
00:9AD7 A592            	   475:   lda token_length
00:9AD9 C901            	   476:   cmp #1
00:9ADB D0F1            	   477:   bne ass_not_x_or_y
00:9ADD A000            	   478:   ldy #0
00:9ADF B190            	   479:   lda (token_address),y
00:9AE1 202D90          	   480:   jsr MAKE_UPPER
00:9AE4 C959            	   481:   cmp #'Y'
00:9AE6 F004            	   482:   beq ass_check_we_have_x_or_y_ok
00:9AE8 C958            	   483:   cmp #'X'
00:9AEA D0E2            	   484:   bne ass_not_x_or_y
                        	   485: ass_check_we_have_x_or_y_ok:
00:9AEC 38              	   486:   sec
00:9AED 60              	   487:   rts
                        	   488: 
                        	   489: ;
                        	   490: ;  we had a non-indirect expression, so was it followed by a comma?
                        	   491: ;
                        	   492: 
                        	   493: ass_value_not_indirect:
00:9AEE A593            	   494:   lda token_type
00:9AF0 C92C            	   495:   cmp #','
00:9AF2 F00D            	   496:   beq ass_indexed
00:9AF4 A901            	   497:   lda #ASS_OPERAND_ABSOLUTE
00:9AF6 856B            	   498:   sta ASS_OPERAND
                        	   499: ass_value_done:
00:9AF8 20239C          	   500:   jsr ass_check_no_more_tokens
00:9AFB 20379B          	   501:   jsr opcode_lookup
00:9AFE 4CD798          	   502:   jmp ass_finish_line
                        	   503: 
                        	   504: ;
                        	   505: ;  <expression>,X or <expression>,Y is what we are expecting here
                        	   506: ;
                        	   507: ;  OR: in the case of BBR0 ... BBR7 and BBS0 ... BBS7 : another expression
                        	   508: ;
                        	   509: 
                        	   510: ass_indexed:
                        	   511: ;
                        	   512: ;  save the value in case we find a second one
                        	   513: ;
                        	   514: ;  checking for another one may change VALUE so we do this now
                        	   515: ;
00:9B01 A500            	   516:   lda VALUE
00:9B03 8506            	   517:   sta REMAIN
00:9B05 A501            	   518:   lda VALUE+1
00:9B07 8507            	   519:   sta REMAIN+1
00:9B09 A502            	   520:   lda VALUE+2
00:9B0B 8508            	   521:   sta REMAIN+2
00:9B0D 20D09A          	   522:   jsr ass_check_we_have_x_or_y
00:9B10 9016            	   523:   bcc ass_absolute_another_value
00:9B12 C958            	   524:   cmp #'X'
00:9B14 F009            	   525:   beq ass_indexed_x
00:9B16 A904            	   526:   lda #ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
00:9B18 856B            	   527:   sta ASS_OPERAND
00:9B1A 208CC9          	   528:   jsr get_token ; skip the Y
00:9B1D 80D9            	   529:   bra ass_value_done
                        	   530: ass_indexed_x:
00:9B1F A903            	   531:   lda #ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
00:9B21 856B            	   532:   sta ASS_OPERAND
00:9B23 208CC9          	   533:   jsr get_token ; skip the X
00:9B26 80D0            	   534:   bra ass_value_done
                        	   535: 
                        	   536: ;
                        	   537: ;  this is hopefully something like BBR0 $42,foo
                        	   538: ;   so we need to evaluate foo
                        	   539: ;
                        	   540: ass_absolute_another_value:
00:9B28 A593            	   541:   lda token_type ; get token back
00:9B2A 203A9D          	   542:   jsr ass_get_value  ; should have some sort of address now in VALUE
                        	   543: ;  jsr ass_check_no_more_tokens
00:9B2D A912            	   544:   lda #ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE
00:9B2F 856B            	   545:   sta ASS_OPERAND
00:9B31 20379B          	   546:   jsr opcode_lookup
00:9B34 4CD798          	   547:   jmp ass_finish_line
                        	   548: 
                        	   549: 
                        	   550: ;
                        	   551: ;  look up opcode
                        	   552: ;
                        	   553: opcode_lookup:
                        	   554:   ; the opcode we are looking up
00:9B37 A56C            	   555:   lda OPCODE
00:9B39 8500            	   556:   sta SRCE
00:9B3B A56D            	   557:   lda OPCODE+1
00:9B3D 8501            	   558:   sta SRCE+1
00:9B3F 6472            	   559:   stz ASS_COUNT   ; count of matches
                        	   560: ;
                        	   561: ;  get the address of our table of tables
                        	   562: ;
00:9B41 A981            	   563:   lda #<OPCODE_LOOKUP_TABLE
00:9B43 8570            	   564:   sta ASS_OPCODE_WORK
00:9B45 A99F            	   565:   lda #>OPCODE_LOOKUP_TABLE
00:9B47 8571            	   566:   sta ASS_OPCODE_WORK+1
                        	   567: opcode_lookup_loop:
00:9B49 A000            	   568:   ldy #OPCODE_LOOKUP_OPCODE_LENGTH
00:9B4B B170            	   569:   lda (ASS_OPCODE_WORK),Y       ; get opcode length
00:9B4D F058            	   570:   beq opcode_lookup_loop_done   ; end of table
00:9B4F C56E            	   571:   cmp OPCODE_LEN                ; right length?
00:9B51 F00F            	   572:   beq opcode_lookup_correct_length ; yes
                        	   573: ;
                        	   574: ; no, try the next table item
                        	   575: ;
                        	   576: opcode_lookup_next_table:
00:9B53 18              	   577:   clc
00:9B54 A570            	   578:   lda ASS_OPCODE_WORK
00:9B56 6906            	   579:   adc #OPCODE_LOOKUP_TABLE_SIZE  ; onto next item
00:9B58 8570            	   580:   sta ASS_OPCODE_WORK
00:9B5A A571            	   581:   lda ASS_OPCODE_WORK+1
00:9B5C 6900            	   582:   adc #0
00:9B5E 8571            	   583:   sta ASS_OPCODE_WORK+1
00:9B60 80E7            	   584:   bra opcode_lookup_loop
                        	   585: opcode_lookup_correct_length:
00:9B62 A002            	   586:   ldy #OPCODE_LOOKUP_OPCODE_TABLE
00:9B64 B170            	   587:   lda (ASS_OPCODE_WORK),Y ; get table address low-order byte
00:9B66 8503            	   588:   sta DEST
00:9B68 C8              	   589:   iny
00:9B69 B170            	   590:   lda (ASS_OPCODE_WORK),Y ; get table address high-order byte
00:9B6B 8504            	   591:   sta DEST+1
00:9B6D 20AB9E          	   592:   jsr ass_lookup_loop
00:9B70 90E1            	   593:   bcc opcode_lookup_next_table  ; not found
00:9B72 AA              	   594:   tax   ; save the machine code byte
00:9B73 E672            	   595:   inc ASS_COUNT
00:9B75 A001            	   596:   ldy #OPCODE_LOOKUP_OPERAND_TYPE
00:9B77 A56B            	   597:   lda ASS_OPERAND         ; get wanted type of operand?
00:9B79 D170            	   598:   cmp (ASS_OPCODE_WORK),Y ; compare to operand type in table
00:9B7B F013            	   599:   beq opcode_lookup_correct_operand  ; yes
00:9B7D C906            	   600:   cmp #ASS_OPERAND_ACCUMULATOR_A  ; see if in range 1 to 5
00:9B7F B0D2            	   601:   bcs opcode_lookup_next_table
                        	   602: ;
                        	   603: ;  so if we have a so-called ASS_OPERAND_ABSOLUTE (with various indexing modes)
                        	   604: ;  see if we can match on ASS_OPERAND_ZERO_PAGE by adding 10 to the operand type
                        	   605: ;  - also applies to all the absolute modes (1 to 5)
                        	   606: ;
00:9B81 18              	   607:   clc
00:9B82 690A            	   608:   adc #10
00:9B84 D170            	   609:   cmp (ASS_OPCODE_WORK),Y
00:9B86 D0CB            	   610:   bne opcode_lookup_next_table
                        	   611: ;
                        	   612: ;  plus, the operand has to be in the zero page
                        	   613: ;
00:9B88 A574            	   614:   lda ASS_VALUE+1
00:9B8A D0C7            	   615:   bne opcode_lookup_next_table
00:9B8C A575            	   616:   lda ASS_VALUE+2
00:9B8E D0C3            	   617:   bne opcode_lookup_next_table
                        	   618: opcode_lookup_correct_operand:
00:9B90 8A              	   619:   txa   ; get the byte to emit back
                        	   620: 
                        	   621: ;
                        	   622: ; we have a match! emit the opcode
                        	   623: ;
00:9B91 20CF9E          	   624:   jsr ass_emit            ; emit it
00:9B94 A004            	   625:   ldy #OPCODE_LOOKUP_HANDLER  ; offset of handler
00:9B96 B170            	   626:   lda (ASS_OPCODE_WORK),Y ; get opcode handler address low-order byte
00:9B98 AA              	   627:   tax
00:9B99 C8              	   628:   iny
00:9B9A B170            	   629:   lda (ASS_OPCODE_WORK),Y ; get opcode handler address high-order byte
00:9B9C F008            	   630:   beq opcode_lookup_no_handler
00:9B9E 8571            	   631:   sta ASS_OPCODE_WORK+1
00:9BA0 8A              	   632:   txa
00:9BA1 8570            	   633:   sta ASS_OPCODE_WORK
00:9BA3 6C7000          	   634:   jmp (ASS_OPCODE_WORK)   ; do handler - it will RTS for us
                        	   635: 
                        	   636: opcode_lookup_no_handler:
                        	   637: ; put nothing here as it won't be done if there is a handler
00:9BA6 60              	   638:   rts    ; done!
                        	   639: 
                        	   640: opcode_lookup_loop_done:
                        	   641: ;
                        	   642: ;  look for assembler directives
                        	   643: ;
00:9BA7 A924            	   644:   lda #<DIRECTIVES
00:9BA9 8503            	   645:   sta DEST
00:9BAB A9A0            	   646:   lda #>DIRECTIVES
00:9BAD 8504            	   647:   sta DEST+1
00:9BAF A56E            	   648:   lda OPCODE_LEN
                        	   649: 
                        	   650: ;  pha
                        	   651: ;   lda #'c'
                        	   652: ;   jsr ass_debug_point
                        	   653: ;   pla
                        	   654: 
00:9BB1 20738F          	   655:   jsr handlerLookup
00:9BB4 9029            	   656:   bcc opcode_lookup_ok
                        	   657: 
                        	   658: ;   lda #'d'
                        	   659: ;   jsr ass_debug_point
                        	   660: 
                        	   661: ;
                        	   662: ;  here for unknown opcode
                        	   663: ;
00:9BB6 A56C            	   664:   lda OPCODE
00:9BB8 8590            	   665:   sta token_address
00:9BBA A56D            	   666:   lda OPCODE+1
00:9BBC 8591            	   667:   sta token_address+1
00:9BBE A56E            	   668:   lda OPCODE_LEN
00:9BC0 8592            	   669:   sta token_length
                        	   670: 
                        	   671: ;
                        	   672: ;  if we NEVER found a match, this is an illegal opcode
                        	   673: ;
00:9BC2 A921            	   674:   lda #'!'
00:9BC4 201894          	   675:   jsr COUT
00:9BC7 A66E            	   676:   ldx OPCODE_LEN
00:9BC9 A000            	   677:   ldy #0
                        	   678: wtf_loop:
00:9BCB B16C            	   679:    lda (OPCODE),Y
00:9BCD 201894          	   680:    jsr COUT
00:9BD0 C8              	   681:    iny
00:9BD1 CA              	   682:    dex
00:9BD2 D0F7            	   683:    bne wtf_loop
                        	   684: 
                        	   685: 
00:9BD4 A228            	   686:   ldx  #40    ; illegal opcode
00:9BD6 A572            	   687:   lda ASS_COUNT
00:9BD8 F002            	   688:   beq opcode_lookup_loop_unknown
                        	   689: ;
                        	   690: ;  if we found a match, but not for this addressing mode, they used an illegal mode
                        	   691: ;
00:9BDA A229            	   692:   ldx  #41   ; illegal addressing mode
                        	   693: opcode_lookup_loop_unknown:
00:9BDC 4C0D9F          	   694:   JMP  ass_error
                        	   695: 
                        	   696: opcode_lookup_ok:
                        	   697: 
                        	   698: ;   lda #'e'
                        	   699: ; jsr ass_debug_point
                        	   700: 
00:9BDF 60              	   701:   rts
                        	   702: 
                        	   703: ass_done:
00:9BE0 209192          	   704:   jsr  CROUT
00:9BE3 A576            	   705:   LDA  ASS_PASS
00:9BE5 D003            	   706:   bne  ass_done_second_pass
00:9BE7 4CB898          	   707:   jmp  ASSEMBLE_SECOND_PASS
                        	   708: ass_done_second_pass:
00:9BEA A905            	   709:   LDA  #<ass_done_message  ; Assemble finished: No Errors
00:9BEC A29C            	   710:   LDX  #>ass_done_message
00:9BEE 202682          	   711:   JSR  print
00:9BF1 A910            	   712:   lda  #FLAG_VALID_ASSEMBLE
00:9BF3 04BE            	   713:   tsb  system_flags
00:9BF5 200E8F          	   714:   jsr  show_symbol_table_end
00:9BF8 20338F          	   715:   jsr  show_source_end
00:9BFB A582            	   716:   lda  show_symbols
00:9BFD F003            	   717:   beq  ass_done1
00:9BFF 20C8A5          	   718:   jsr  list_symbols
                        	   719: ass_done1:
00:9C02 4CCC82          	   720:   JMP  main_prompt
                        	   721: 
00:9C05 417373656D626C65	   722: ass_done_message asciiz "Assemble finished: No errors\n"
00:9C0D 2066696E69736865
00:9C15 643A204E6F206572
00:9C1D 726F72730A
00:9C22 00
                        	   723: 
                        	   724: ass_check_no_more_tokens:
00:9C23 A593            	   725:   lda token_type
00:9C25 C90A            	   726:   cmp #NL           ; or end of line?
00:9C27 F005            	   727:   beq ass_check_no_more_tokens_ok
00:9C29 A213            	   728:   ldx #19    ; ERROR: incorrect symbol
00:9C2B 4C0D9F          	   729:   jmp ass_error
                        	   730: 
                        	   731: ass_check_no_more_tokens_ok:
00:9C2E 60              	   732:   rts
                        	   733: 
                        	   734: ;
                        	   735: ;  push a 3-byte value (in VALUE) onto the evaluation stack
                        	   736: ;    changes A and Y
                        	   737: ;
                        	   738: exp_push_value = *
00:9C2F A57B            	   739:   lda exp_value_stack_count
00:9C31 C9FF            	   740:   cmp #$FF
00:9C33 D005            	   741:   bne exp_push_value_ok
                        	   742: exp_push_value_memory_full:
00:9C35 A22E            	   743:   ldx #46   ; ERROR: Expression too complex
00:9C37 4C0D9F          	   744:   jmp ass_error
                        	   745: exp_push_value_ok:
00:9C3A E67B            	   746:   inc exp_value_stack_count
00:9C3C 38              	   747:   sec
00:9C3D A579            	   748:   lda exp_value_stack
00:9C3F E903            	   749:   sbc #3
00:9C41 8579            	   750:   sta exp_value_stack
00:9C43 A57A            	   751:   lda exp_value_stack+1
00:9C45 E900            	   752:   sbc #0
00:9C47 857A            	   753:   sta exp_value_stack+1
                        	   754: ;
                        	   755: ;  has our expression value fallen down into our P-codes?
                        	   756: ;
                        	   757: ;  This doesn't work if the output (PCODE) has been relocated to above
                        	   758: ;  the symbol table and I can't think of an easy solution, so let's ignore
                        	   759: ;  it and hope it doesn't happen.
                        	   760: ;
                        	   761: ;
                        	   762: ; lda  PCODE+1               ; see if P-codes full
                        	   763: ; cmp  exp_value_stack+1     ; in other words, have we hit the symbol table?
                        	   764: ; bcc  exp_push_value_not_full      ; less than
                        	   765: ; bne  exp_push_value_memory_full   ; greater than
                        	   766: ; lda  PCODE
                        	   767: ; cmp  exp_value_stack
                        	   768: ; bcs  exp_push_value_memory_full   ; BGE
                        	   769: 
                        	   770: exp_push_value_not_full:
00:9C49 A000            	   771:   ldy #0
00:9C4B A500            	   772:   lda VALUE
00:9C4D 9179            	   773:   sta (exp_value_stack),y
00:9C4F C8              	   774:   iny
00:9C50 A501            	   775:   lda VALUE+1
00:9C52 9179            	   776:   sta (exp_value_stack),y
00:9C54 C8              	   777:   iny
00:9C55 A502            	   778:   lda VALUE+2
00:9C57 9179            	   779:   sta (exp_value_stack),y
00:9C59 60              	   780:   rts
                        	   781: 
                        	   782: ;
                        	   783: ;  pop a 3-byte value (into VALUE) from the evaluation stack
                        	   784: ;    changes A and Y
                        	   785: ;
                        	   786: exp_pop_value = *
00:9C5A A57B            	   787:   lda exp_value_stack_count
00:9C5C D005            	   788:   bne exp_pop_value_ok
00:9C5E A217            	   789:   ldx #23    ; ERROR: illegal factor
00:9C60 4C0D9F          	   790:   jmp ass_error
                        	   791: exp_pop_value_ok:
00:9C63 C67B            	   792:   dec exp_value_stack_count
00:9C65 A000            	   793:   ldy #0
00:9C67 B179            	   794:   lda (exp_value_stack),y
00:9C69 8500            	   795:   sta VALUE
00:9C6B C8              	   796:   iny
00:9C6C B179            	   797:   lda (exp_value_stack),y
00:9C6E 8501            	   798:   sta VALUE+1
00:9C70 C8              	   799:   iny
00:9C71 B179            	   800:   lda (exp_value_stack),y
00:9C73 8502            	   801:   sta VALUE+2
00:9C75 18              	   802:   clc
00:9C76 A579            	   803:   lda exp_value_stack
00:9C78 6903            	   804:   adc #3
00:9C7A 8579            	   805:   sta exp_value_stack
00:9C7C A57A            	   806:   lda exp_value_stack+1
00:9C7E 6900            	   807:   adc #0
00:9C80 857A            	   808:   sta exp_value_stack+1
00:9C82 60              	   809:   rts
                        	   810: 
                        	   811: ;
                        	   812: ;  I needed a work area for operators, and initially used INBUF however that got
                        	   813: ;  repurposed for managing strings (in particular handling \Xnn and double quotes)
                        	   814: ;  so now I am using the memory at the current PCODE address as a work area.
                        	   815: ;  It is only needed during expression evaluation, and should hopefully be available.
                        	   816: ;
                        	   817: ;
                        	   818: ;  push an operator (A) onto the operator stack
                        	   819: ;   changes X and Y
                        	   820: ;
                        	   821: exp_push_operator:
00:9C83 A67C            	   822:   ldx exp_operator_stack_count
00:9C85 E0FA            	   823:   cpx #250  ; make sure we don't overflow our operator stack
00:9C87 9005            	   824:   bcc exp_push_operator_ok
00:9C89 A22E            	   825:   ldx #46   ; ERROR: Expression too complex
00:9C8B 4C0D9F          	   826:   jmp ass_error
                        	   827: exp_push_operator_ok:
00:9C8E E67C            	   828:   inc exp_operator_stack_count  ; add, then store
00:9C90 A47C            	   829:   ldy exp_operator_stack_count
00:9C92 9123            	   830:   sta (PCODE),Y
00:9C94 60              	   831:   rts
                        	   832: 
                        	   833: ;
                        	   834: ;  pop an operator (into A) from the operator stack
                        	   835: ;   changes X and Y
                        	   836: ;
                        	   837: exp_pop_operator:
00:9C95 A67C            	   838:   ldx exp_operator_stack_count
00:9C97 D005            	   839:   bne exp_pop_operator_ok
00:9C99 A217            	   840:   ldx #23   ; ERROR: Illegal factor
00:9C9B 4C0D9F          	   841:   jmp ass_error
                        	   842: exp_pop_operator_ok:
00:9C9E A47C            	   843:   ldy exp_operator_stack_count  ; retrieve, then decrement
00:9CA0 B123            	   844:   lda (PCODE),Y
00:9CA2 C67C            	   845:   dec exp_operator_stack_count
00:9CA4 60              	   846:   rts
                        	   847: 
                        	   848: ;
                        	   849: ;  get an operator (into A) from the operator stack (without removing it)
                        	   850: ;   changes X and Y
                        	   851: ;
                        	   852: exp_get_operator:
00:9CA5 A67C            	   853:   ldx exp_operator_stack_count
00:9CA7 D005            	   854:   bne exp_get_operator_ok
00:9CA9 A217            	   855:   ldx #23   ; ERROR: Illegal factor
00:9CAB 4C0D9F          	   856:   jmp ass_error
                        	   857: exp_get_operator_ok:
00:9CAE A47C            	   858:   ldy exp_operator_stack_count
00:9CB0 B123            	   859:   lda (PCODE),Y
00:9CB2 60              	   860:   rts
                        	   861: 
                        	   862:  .macro makePrecedenceTable ; table of operators, precedence, handler
                        	   863:    dfb   \1
                        	   864:    dfb   \2
                        	   865:    word  \3
                        	   866:  .endmacro
                        	   867: 
                        	   868: ; cannot have more than 64 entries because we index into this with X
                        	   869: exp_precedence_table:
                        	   870:   makePrecedenceTable '~', 1, exp_negate
00:9CB3 7E              	     1M    dfb   '~'
00:9CB4 01              	     2M    dfb   1
00:9CB5 FAAB            	     3M    word  exp_negate
                        	   871:   makePrecedenceTable '!', 1, exp_not
00:9CB7 21              	     1M    dfb   '!'
00:9CB8 01              	     2M    dfb   1
00:9CB9 0DAC            	     3M    word  exp_not
                        	   872:   makePrecedenceTable TOKEN_UNARY_MINUS, 1, exp_unary_minus
00:9CBB 4D              	     1M    dfb   TOKEN_UNARY_MINUS
00:9CBC 01              	     2M    dfb   1
00:9CBD 1BAC            	     3M    word  exp_unary_minus
                        	   873:   makePrecedenceTable TOKEN_LOW_BYTE, 1, exp_low_byte
00:9CBF 56              	     1M    dfb   TOKEN_LOW_BYTE
00:9CC0 01              	     2M    dfb   1
00:9CC1 2FAC            	     3M    word  exp_low_byte
                        	   874:   makePrecedenceTable TOKEN_HIGH_BYTE, 1, exp_high_byte
00:9CC3 57              	     1M    dfb   TOKEN_HIGH_BYTE
00:9CC4 01              	     2M    dfb   1
00:9CC5 34AC            	     3M    word  exp_high_byte
                        	   875:   makePrecedenceTable TOKEN_SHIFT_LEFT, 2, exp_shift_left
00:9CC7 4C              	     1M    dfb   TOKEN_SHIFT_LEFT
00:9CC8 02              	     2M    dfb   2
00:9CC9 C8AB            	     3M    word  exp_shift_left
                        	   876:   makePrecedenceTable TOKEN_SHIFT_RIGHT, 2, exp_shift_right
00:9CCB 52              	     1M    dfb   TOKEN_SHIFT_RIGHT
00:9CCC 02              	     2M    dfb   2
00:9CCD E1AB            	     3M    word  exp_shift_right
                        	   877:   makePrecedenceTable '&', 3, exp_bitwise_and
00:9CCF 26              	     1M    dfb   '&'
00:9CD0 03              	     2M    dfb   3
00:9CD1 77AB            	     3M    word  exp_bitwise_and
                        	   878:   makePrecedenceTable '^', 4, exp_bitwise_xor
00:9CD3 5E              	     1M    dfb   '^'
00:9CD4 04              	     2M    dfb   4
00:9CD5 8CAB            	     3M    word  exp_bitwise_xor
                        	   879:   makePrecedenceTable '|', 5, exp_bitwise_or
00:9CD7 7C              	     1M    dfb   '|'
00:9CD8 05              	     2M    dfb   5
00:9CD9 62AB            	     3M    word  exp_bitwise_or
                        	   880:   makePrecedenceTable '*', 6, exp_multiply
00:9CDB 2A              	     1M    dfb   '*'
00:9CDC 06              	     2M    dfb   6
00:9CDD A2AC            	     3M    word  exp_multiply
                        	   881:   makePrecedenceTable '/', 6, exp_divide
00:9CDF 2F              	     1M    dfb   '/'
00:9CE0 06              	     2M    dfb   6
00:9CE1 DBAC            	     3M    word  exp_divide
                        	   882:   makePrecedenceTable '%', 6, exp_modulo
00:9CE3 25              	     1M    dfb   '%'
00:9CE4 06              	     2M    dfb   6
00:9CE5 3BAD            	     3M    word  exp_modulo
                        	   883:   makePrecedenceTable '+', 7, exp_add
00:9CE7 2B              	     1M    dfb   '+'
00:9CE8 07              	     2M    dfb   7
00:9CE9 D4AA            	     3M    word  exp_add
                        	   884:   makePrecedenceTable '-', 7, exp_subtract
00:9CEB 2D              	     1M    dfb   '-'
00:9CEC 07              	     2M    dfb   7
00:9CED E8AA            	     3M    word  exp_subtract
                        	   885:   makePrecedenceTable '<', 8, exp_less_than
00:9CEF 3C              	     1M    dfb   '<'
00:9CF0 08              	     2M    dfb   8
00:9CF1 36AB            	     3M    word  exp_less_than
                        	   886:   makePrecedenceTable '>', 8, exp_greater_than
00:9CF3 3E              	     1M    dfb   '>'
00:9CF4 08              	     2M    dfb   8
00:9CF5 3DAB            	     3M    word  exp_greater_than
                        	   887:   makePrecedenceTable TOKEN_LEQ, 8, exp_leq
00:9CF7 80              	     1M    dfb   TOKEN_LEQ
00:9CF8 08              	     2M    dfb   8
00:9CF9 4CAB            	     3M    word  exp_leq
                        	   888:   makePrecedenceTable TOKEN_GEQ, 8, exp_geq
00:9CFB 81              	     1M    dfb   TOKEN_GEQ
00:9CFC 08              	     2M    dfb   8
00:9CFD 5BAB            	     3M    word  exp_geq
                        	   889:   makePrecedenceTable TOKEN_EQUALITY, 9, exp_eql
00:9CFF 45              	     1M    dfb   TOKEN_EQUALITY
00:9D00 09              	     2M    dfb   9
00:9D01 0EAB            	     3M    word  exp_eql
                        	   890:   makePrecedenceTable TOKEN_NEQ, 9, exp_neq     ; <>
00:9D03 55              	     1M    dfb   TOKEN_NEQ
00:9D04 09              	     2M    dfb   9
00:9D05 22AB            	     3M    word  exp_neq     
                        	   891:   makePrecedenceTable TOKEN_INEQUALITY, 9, exp_neq  ; !=
00:9D07 5A              	     1M    dfb   TOKEN_INEQUALITY
00:9D08 09              	     2M    dfb   9
00:9D09 22AB            	     3M    word  exp_neq  
                        	   892:   makePrecedenceTable TOKEN_LOGICAL_AND, 10, exp_logical_and
00:9D0B 58              	     1M    dfb   TOKEN_LOGICAL_AND
00:9D0C 0A              	     2M    dfb   10
00:9D0D B6AB            	     3M    word  exp_logical_and
                        	   893:   makePrecedenceTable TOKEN_LOGICAL_OR, 11, exp_logical_or
00:9D0F 59              	     1M    dfb   TOKEN_LOGICAL_OR
00:9D10 0B              	     2M    dfb   11
00:9D11 A7AB            	     3M    word  exp_logical_or
                        	   894: 
                        	   895: exp_precedence_table_end = *
                        	   896: 
                        	   897: ;
                        	   898: ;  finds precedence of operator in A, returns it in Y (returns 0 if not found)
                        	   899: ;    changes X, A
                        	   900: ;  also stores the operator evaluation function (eg. exp_add) in exp_evaluation_function
                        	   901: ;
                        	   902: exp_get_precedence:
00:9D13 A200            	   903:   ldx #0
                        	   904: exp_get_precedence_loop:
00:9D15 DDB39C          	   905:   cmp exp_precedence_table,x
00:9D18 F00F            	   906:   beq exp_get_precedence_found
00:9D1A E8              	   907:   inx   ; skip operator
00:9D1B E8              	   908:   inx   ; skip precedence
00:9D1C E8              	   909:   inx   ; skip evaluation function
00:9D1D E8              	   910:   inx   ;  (2 bytes)
00:9D1E E060            	   911:   cpx #exp_precedence_table_end - exp_precedence_table
00:9D20 90F3            	   912:   bcc exp_get_precedence_loop
00:9D22 A000            	   913:   ldy #0
00:9D24 647F            	   914:   stz exp_evaluation_function
00:9D26 6480            	   915:   stz exp_evaluation_function+1
00:9D28 60              	   916:   rts
                        	   917: exp_get_precedence_found:
00:9D29 E8              	   918:   inx
00:9D2A BCB39C          	   919:   ldy exp_precedence_table,x
00:9D2D E8              	   920:   inx
00:9D2E BDB39C          	   921:   lda exp_precedence_table,x
00:9D31 857F            	   922:   sta exp_evaluation_function
00:9D33 E8              	   923:   inx
00:9D34 BDB39C          	   924:   lda exp_precedence_table,x
00:9D37 8580            	   925:   sta exp_evaluation_function+1
00:9D39 60              	   926:   rts
                        	   927: 
                        	   928: ;
                        	   929: ;  Convert an expression into a value
                        	   930: ;
                        	   931: ;   Ideas from https://www.geeksforgeeks.org/expression-evaluation/
                        	   932: ;
                        	   933: ass_get_value:
                        	   934: ;
                        	   935: ;  set up expression evaluation stack
                        	   936: ;
00:9D3A 647B            	   937:   stz exp_value_stack_count
00:9D3C 647C            	   938:   stz exp_operator_stack_count
00:9D3E A531            	   939:   lda ENDSYM
00:9D40 8579            	   940:   sta exp_value_stack
00:9D42 A532            	   941:   lda ENDSYM+1
00:9D44 857A            	   942:   sta exp_value_stack+1
                        	   943: 
00:9D46 6473            	   944:   stz ASS_VALUE
00:9D48 6474            	   945:   stz ASS_VALUE+1
00:9D4A 6475            	   946:   stz ASS_VALUE+2
00:9D4C A901            	   947:   lda #1
00:9D4E 8581            	   948:   sta exp_unary_ok  ; unary operators can appear at the start of the expression
00:9D50 A593            	   949:   lda token_type
                        	   950: ;  jsr START_TRACE
                        	   951: ;
                        	   952: ;  one token lookahead
                        	   953: ;
00:9D52 8003            	   954:   bra ass_expression_loop_initial
                        	   955: 
                        	   956: ;
                        	   957: ;  1.1 Get the next token
                        	   958: ;
                        	   959: ass_expression_loop:
00:9D54 208CC9          	   960:   jsr get_token
                        	   961: ass_expression_loop_initial:
                        	   962: 
                        	   963: ;
                        	   964: ;  1.2.1 If it's a number, push onto the value stack
                        	   965: ;
00:9D57 C94E            	   966:   cmp #TOKEN_NUMBER
00:9D59 D013            	   967:   bne ass_expression_loop1a
                        	   968: ass_expression_number:
00:9D5B A594            	   969:   lda token_value
00:9D5D 8500            	   970:   sta VALUE
00:9D5F A595            	   971:   lda token_value+1
00:9D61 8501            	   972:   sta VALUE+1
00:9D63 A596            	   973:   lda token_value+2
00:9D65 8502            	   974:   sta VALUE+2
00:9D67 202F9C          	   975:   jsr exp_push_value
00:9D6A 6481            	   976:   stz exp_unary_ok          ; don't have unary operators after numbers
00:9D6C 80E6            	   977:   bra ass_expression_loop
                        	   978: ;
                        	   979: ;  if it's a string and only 1 or 2 bytes, consider as a number
                        	   980: ;
                        	   981: ass_expression_loop1a:
00:9D6E C922            	   982:   cmp #TOKEN_STRING
00:9D70 D013            	   983:   bne ass_expression_loop1
00:9D72 A592            	   984:   lda token_length
00:9D74 C903            	   985:   cmp #3
00:9D76 B008            	   986:   bcs ass_expression_not_small_string  ; too long?
                        	   987: ;
                        	   988: ;  one or two character string - is this an immediate operand?
                        	   989: ;
00:9D78 A56B            	   990:   lda ASS_OPERAND
00:9D7A C907            	   991:   cmp #ASS_OPERAND_IMMEDIATE
00:9D7C D002            	   992:   bne ass_expression_not_small_string
00:9D7E 80DB            	   993:   bra ass_expression_number   ; treat as a number (its value should be in VALUE)
                        	   994: 
                        	   995: ass_expression_not_small_string:
00:9D80 A21D            	   996:   ldx #29     ; string literal too big
00:9D82 4C0D9F          	   997:   jmp ass_error
                        	   998: 
                        	   999: ;
                        	  1000: ;  1.2.2 If it's an identifier, get its value and push onto the value stack
                        	  1001: ;
                        	  1002: ass_expression_loop1:
00:9D85 C949            	  1003:   cmp #TOKEN_IDENTIFIER
00:9D87 D029            	  1004:   bne ass_expression_loop2
00:9D89 6481            	  1005:   stz exp_unary_ok          ; don't have unary operators after identifiers
                        	  1006: 
00:9D8B 2012B9          	  1007:   jsr SEARCH    ; should be in symbol table as a constant, and the value in VALUE
00:9D8E D011            	  1008:   bne ass_expression_found_value
00:9D90 A576            	  1009:   lda ASS_PASS
00:9D92 F005            	  1010:   beq ass_label_not_found_yet
                        	  1011: 
                        	  1012: ;
                        	  1013: ; it's an error if it isn't there on the second pass
                        	  1014: ;
00:9D94 A20B            	  1015:   ldx #11  ; ERROR: Undeclared Identifier
00:9D96 4C0D9F          	  1016:   jmp ass_error
                        	  1017: 
                        	  1018: ;
                        	  1019: ;  label not found on first pass, make the value 0x6666 for now
                        	  1020: ;   - we don't want a zero-page address assumption because that
                        	  1021: ;     will throw out opcode lengths (it might assume a zero page opcode
                        	  1022: ;     which is shorter and then change it to a longer one)
                        	  1023: ;
                        	  1024: ass_label_not_found_yet:
00:9D99 A966            	  1025:   lda #$66
00:9D9B 8500            	  1026:   sta VALUE
00:9D9D 8501            	  1027:   sta VALUE+1
00:9D9F 6402            	  1028:   stz VALUE+2
                        	  1029: ass_expression_found_value:
00:9DA1 A594            	  1030:   lda token_value
00:9DA3 8500            	  1031:   sta VALUE
00:9DA5 A595            	  1032:   lda token_value+1
00:9DA7 8501            	  1033:   sta VALUE+1
00:9DA9 A596            	  1034:   lda token_value+2
00:9DAB 8502            	  1035:   sta VALUE+2
00:9DAD 202F9C          	  1036:   jsr exp_push_value
00:9DB0 80A2            	  1037:   bra ass_expression_loop
                        	  1038: 
                        	  1039: ;
                        	  1040: ; 1.2.3 If it's a left parenthesis: push it onto the operator stack.
                        	  1041: ;
                        	  1042: ass_expression_loop2:
00:9DB2 C928            	  1043:   cmp #'('
00:9DB4 D00B            	  1044:   bne ass_expression_loop3
00:9DB6 48              	  1045:   pha
00:9DB7 A901            	  1046:   lda  #1
00:9DB9 8581            	  1047:   sta exp_unary_ok          ; unary operators can follow left parentheses
00:9DBB 68              	  1048:   pla
                        	  1049: 
00:9DBC 20839C          	  1050:   jsr exp_push_operator
00:9DBF 8093            	  1051:   bra ass_expression_loop
                        	  1052: 
                        	  1053: ;
                        	  1054: ;  1.2.4 A right parenthesis:
                        	  1055: ;       1 While the thing on top of the operator stack is not a
                        	  1056: ;         left parenthesis,
                        	  1057: ;           1 Pop the operator from the operator stack.
                        	  1058: ;           2 Pop the value stack twice, getting two operands.
                        	  1059: ;           3 Apply the operator to the operands, in the correct order.
                        	  1060: ;           4 Push the result onto the value stack.
                        	  1061: ;        2 Pop the left parenthesis from the operator stack, and discard it.
                        	  1062: 
                        	  1063: 
                        	  1064: ass_expression_loop3:
00:9DC1 C929            	  1065:   cmp #')'
00:9DC3 D016            	  1066:   bne ass_expression_loop4
                        	  1067: ass_expression_loop3b:
                        	  1068: ;
                        	  1069: ;  a RH parenthesis with an empty operator stack is probably the end of the expression, eg. ($1234),x
                        	  1070: ;  where the ")" belongs to the indexed operand stuff and not the expression
                        	  1071: ;
00:9DC5 A57C            	  1072:   lda exp_operator_stack_count
00:9DC7 F078            	  1073:   beq exp_no_operators_left
00:9DC9 20A59C          	  1074:   jsr exp_get_operator
00:9DCC C928            	  1075:   cmp #'('
00:9DCE F005            	  1076:   beq ass_expression_loop3c
                        	  1077: ;
                        	  1078: ;  not a left parenthesis
                        	  1079: ;
                        	  1080: ass_expression_loop3a:
00:9DD0 20679E          	  1081:   jsr ass_expression_apply_operator ; pop the operator and two values, apply the operator and push the result
00:9DD3 80F0            	  1082:   bra ass_expression_loop3b          ; keep going until we don't have a left parenthesis
                        	  1083: 
                        	  1084: ass_expression_loop3c:
00:9DD5 20959C          	  1085:   jsr exp_pop_operator              ;  2 Pop the left parenthesis from the operator stack, and discard it.
                        	  1086: ass_expression_loopJ:
00:9DD8 4C549D          	  1087:   jmp ass_expression_loop
                        	  1088: 
                        	  1089: ;       1.2.5 An operator (call it thisOp):
                        	  1090: ;         1 While the operator stack is not empty, and the top thing on the
                        	  1091: ;           operator stack has the same or greater precedence as thisOp,
                        	  1092: ;           1 Pop the operator from the operator stack.
                        	  1093: ;           2 Pop the value stack twice, getting two operands.
                        	  1094: ;           3 Apply the operator to the operands, in the correct order.
                        	  1095: ;           4 Push the result onto the value stack.
                        	  1096: ;         2 Push thisOp onto the operator stack.
                        	  1097: 
                        	  1098: ass_expression_loop4:
                        	  1099: ;
                        	  1100: ;  look for unary operators
                        	  1101: ;
00:9DDB A681            	  1102:   ldx exp_unary_ok
00:9DDD F034            	  1103:   beq ass_expression_cannot_be_unary
00:9DDF C92D            	  1104:   cmp #'-'
00:9DE1 D006            	  1105:   bne ass_not_unary_minus
00:9DE3 A94D            	  1106:   lda #TOKEN_UNARY_MINUS
00:9DE5 8593            	  1107:   sta token_type
00:9DE7 802A            	  1108:   bra ass_expression_cannot_be_unary
                        	  1109: ass_not_unary_minus:
00:9DE9 C93C            	  1110:   cmp #'<'
00:9DEB D006            	  1111:   bne ass_not_unary_less_than
00:9DED A956            	  1112:   lda #TOKEN_LOW_BYTE
00:9DEF 8593            	  1113:   sta token_type
00:9DF1 8020            	  1114:   bra ass_expression_cannot_be_unary
                        	  1115: ass_not_unary_less_than:
00:9DF3 C93E            	  1116:   cmp #'>'
00:9DF5 D006            	  1117:   bne ass_not_unary_greater_than
00:9DF7 A957            	  1118:   lda #TOKEN_HIGH_BYTE
00:9DF9 8593            	  1119:   sta token_type
00:9DFB 8000            	  1120:   bra ass_not_unary_greater_than
                        	  1121: ass_not_unary_greater_than:
00:9DFD C92A            	  1122:   cmp #'*'
00:9DFF D012            	  1123:   bne ass_expression_cannot_be_unary
                        	  1124: ;
                        	  1125: ;  A '*' where a unary expression is allowed will be the current emit address (eg. foo = *)
                        	  1126: ;
00:9E01 A523            	  1127:   lda PCODE
00:9E03 8594            	  1128:   sta token_value
00:9E05 A524            	  1129:   lda PCODE+1
00:9E07 8595            	  1130:   sta token_value+1
00:9E09 6496            	  1131:   stz token_value+2
00:9E0B 6481            	  1132:   stz exp_unary_ok          ; don't have unary operators after numbers
00:9E0D A94E            	  1133:   lda #TOKEN_NUMBER
00:9E0F 8593            	  1134:   sta token_type            ; make get_token think a sign as a token on its own
00:9E11 808E            	  1135:   bra ass_expression_found_value
                        	  1136: 
                        	  1137: ass_expression_cannot_be_unary:
00:9E13 48              	  1138:   pha
00:9E14 A901            	  1139:   lda #1
00:9E16 8581            	  1140:   sta exp_unary_ok          ; can have unary operators after operators
00:9E18 68              	  1141:   pla
                        	  1142: 
00:9E19 20139D          	  1143:   jsr exp_get_precedence
00:9E1C 847E            	  1144:   sty exp_operator_precedence ; thisOp's precedence
00:9E1E C000            	  1145:   cpy #0
00:9E20 F01F            	  1146:   beq exp_no_operators_left
                        	  1147: 
                        	  1148: ass_expression_loop7:         ; 1 While the operator stack is not empty
00:9E22 A57C            	  1149:   lda exp_operator_stack_count
00:9E24 F013            	  1150:   beq ass_expression_loop6    ; stack empty
00:9E26 20A59C          	  1151:   jsr exp_get_operator    ; find the top thing on the operator stack
00:9E29 C928            	  1152:   cmp #'('                ; if a bracket, consider that low precedence
00:9E2B F00C            	  1153:   beq ass_expression_loop6
00:9E2D 20139D          	  1154:   jsr exp_get_precedence  ; and its precedence
00:9E30 C47E            	  1155:   cpy exp_operator_precedence
00:9E32 B005            	  1156:   bcs ass_expression_loop6  ; thing on top has less precedence (a higher value) than thisOp
00:9E34 20679E          	  1157:   jsr ass_expression_apply_operator  ; pop the operator and two values, apply the operator and push the result
00:9E37 80E9            	  1158:   bra ass_expression_loop7
                        	  1159: 
                        	  1160: ass_expression_loop6:
00:9E39 A593            	  1161:   lda token_type       ; thisOp
00:9E3B 20839C          	  1162:   jsr exp_push_operator
00:9E3E 4C549D          	  1163:   jmp ass_expression_loop
                        	  1164: 
                        	  1165: 
                        	  1166: ; 2. While the operator stack is not empty,
                        	  1167: ;     1 Pop the operator from the operator stack.
                        	  1168: ;     2 Pop the value stack twice, getting two operands.
                        	  1169: ;     3 Apply the operator to the operands, in the correct order.
                        	  1170: ;     4 Push the result onto the value stack.
                        	  1171: 
                        	  1172: 
                        	  1173: exp_no_operators_left:
00:9E41 A57C            	  1174:     lda exp_operator_stack_count
00:9E43 F005            	  1175:     beq exp_done
00:9E45 20679E          	  1176:     jsr ass_expression_apply_operator ; pop the operator and two values, apply the operator and push the result
00:9E48 80F7            	  1177:     bra exp_no_operators_left
                        	  1178: 
                        	  1179: exp_done:
00:9E4A A57B            	  1180:       lda exp_value_stack_count
00:9E4C C901            	  1181:       cmp #1
00:9E4E F005            	  1182:       beq exp_done_ok
                        	  1183: exp_done_error:
00:9E50 A217            	  1184:       ldx #23       ; ERROR: Illegal factor
00:9E52 4C0D9F          	  1185:       jmp ass_error
                        	  1186: 
                        	  1187: exp_done_ok:
00:9E55 A57C            	  1188:       lda exp_operator_stack_count
00:9E57 D0F7            	  1189:       bne exp_done_error
00:9E59 205A9C          	  1190:       jsr exp_pop_value   ; pop the finished value
00:9E5C A500            	  1191:       lda VALUE
00:9E5E 8573            	  1192:       sta ASS_VALUE
00:9E60 A501            	  1193:       lda VALUE+1
00:9E62 8574            	  1194:       sta ASS_VALUE+1
00:9E64 6475            	  1195:       stz ASS_VALUE+2   ; make high-order byte zero just in case
00:9E66 60              	  1196:       rts
                        	  1197: 
                        	  1198: ;
                        	  1199: ;
                        	  1200: ;     1 Pop the operator from the operator stack.
                        	  1201: ;     2 Pop the value stack twice, getting two operands.
                        	  1202: ;     3 Apply the operator to the operands, in the correct order.
                        	  1203: ;     4 Push the result onto the value stack.
                        	  1204: 
                        	  1205: ;
                        	  1206: ass_expression_apply_operator:
00:9E67 205A9C          	  1207:   jsr exp_pop_value         ; 2 Pop the value stack twice, getting two operands.
00:9E6A 20A59C          	  1208:   jsr exp_get_operator
00:9E6D C97E            	  1209:   cmp #'~'
00:9E6F F01F            	  1210:   beq ass_expression_unary
00:9E71 C921            	  1211:   cmp #'!'
00:9E73 F01B            	  1212:   beq ass_expression_unary
00:9E75 C94D            	  1213:   cmp #TOKEN_UNARY_MINUS
00:9E77 F017            	  1214:   beq ass_expression_unary
00:9E79 C956            	  1215:   cmp #TOKEN_LOW_BYTE
00:9E7B F013            	  1216:   beq ass_expression_unary
00:9E7D C957            	  1217:   cmp #TOKEN_HIGH_BYTE
00:9E7F F00F            	  1218:   beq ass_expression_unary
                        	  1219: 
                        	  1220: ;
                        	  1221: ;  if a binary operator get the second value
                        	  1222: ;
00:9E81 A500            	  1223:   lda VALUE                 ; copy top value to VALUE2
00:9E83 8503            	  1224:   sta VALUE2
00:9E85 A501            	  1225:   lda VALUE+1
00:9E87 8504            	  1226:   sta VALUE2+1
00:9E89 A502            	  1227:   lda VALUE+2
00:9E8B 8505            	  1228:   sta VALUE2+2
00:9E8D 205A9C          	  1229:   jsr exp_pop_value         ; second pop
                        	  1230: ass_expression_unary:
                        	  1231: 
                        	  1232: ;
                        	  1233: ;  now we have the top two values in VALUE (and VALUE2 in the case of binary operators)
                        	  1234: ;
00:9E90 20959C          	  1235:   jsr exp_pop_operator      ; 1 Pop the operator from the operator stack.
00:9E93 857D            	  1236:   sta exp_operator
00:9E95 20139D          	  1237:   jsr exp_get_precedence    ; find the evaluation function
00:9E98 C000            	  1238:   cpy #0
00:9E9A F0CB            	  1239:   beq ass_expression_apply_operator ; should not be here if the operator isn't in the table
00:9E9C 20A89E          	  1240:   jsr ass_evaluate_operator ; do the evaluation
00:9E9F 202F9C          	  1241:   jsr exp_push_value        ; 4 Push the result onto the value stack.
00:9EA2 60              	  1242:   rts
                        	  1243: 
                        	  1244: ass_expression_apply_operator_bug:
00:9EA3 A206            	  1245:   ldx #6
00:9EA5 4C0D9F          	  1246:   jmp ass_error
                        	  1247: 
                        	  1248: ass_evaluate_operator:
00:9EA8 6C7F00          	  1249:   jmp (exp_evaluation_function)
                        	  1250: 
                        	  1251: 
                        	  1252: ;
                        	  1253: ;  look up opcodes in a table
                        	  1254: ;  returns carry set if found, carry clear if not found
                        	  1255: ;
                        	  1256: ass_lookup_loop:
00:9EAB A46E            	  1257:   ldy OPCODE_LEN
00:9EAD 209692          	  1258:   jsr COMSTL
00:9EB0 F017            	  1259:   beq ass_opcode_found
                        	  1260: ;
                        	  1261: ;  add the opcode length, plus 1 to DEST
                        	  1262: ;
00:9EB2 18              	  1263:   clc
00:9EB3 A46E            	  1264:   ldy OPCODE_LEN
00:9EB5 C8              	  1265:   iny
00:9EB6 98              	  1266:   tya
00:9EB7 6503            	  1267:   adc DEST
00:9EB9 8503            	  1268:   sta DEST
00:9EBB A504            	  1269:   lda DEST+1
00:9EBD 6900            	  1270:   adc #0
00:9EBF 8504            	  1271:   sta DEST+1
                        	  1272: ;
                        	  1273: ;  end of table?
                        	  1274: ;
00:9EC1 A000            	  1275:   ldy #0
00:9EC3 B103            	  1276:   lda (DEST),Y
00:9EC5 D0E4            	  1277:   bne ass_lookup_loop   ; not yet
00:9EC7 18              	  1278:   clc
00:9EC8 60              	  1279:   rts
                        	  1280: 
                        	  1281: 
                        	  1282: ass_opcode_found:
00:9EC9 A46E            	  1283:   ldy OPCODE_LEN
00:9ECB B103            	  1284:   lda (DEST),Y
00:9ECD 38              	  1285:   sec   ; indicate found
00:9ECE 60              	  1286:   rts
                        	  1287: 
                        	  1288: ass_emit:
00:9ECF A476            	  1289:   ldy ASS_PASS
00:9ED1 F031            	  1290:   beq ass_emit3  ; only emit codes on 2nd pass
                        	  1291:   ;
                        	  1292:   ;  first time for this line of code, indent by two spaces
                        	  1293:   ;
00:9ED3 A46F            	  1294:   ldy ASS_EMIT_COUNT
00:9ED5 D00C            	  1295:   bne ass_emit2
00:9ED7 A42E            	  1296:   ldy DCODE
00:9ED9 F008            	  1297:   beq ass_emit2
00:9EDB 48              	  1298:   pha
00:9EDC 201C93          	  1299:   jsr PUTSP
00:9EDF 201C93          	  1300:   jsr PUTSP
00:9EE2 68              	  1301:   pla
                        	  1302: ass_emit2:
                        	  1303: ;
                        	  1304: ;  if this is the *first* byte we emitted, then make that the start address
                        	  1305: ;  for running the code. That is, if you relocate the code, the first byte
                        	  1306: ;  actually emitted will be considered the runtime address.
                        	  1307: ;
                        	  1308: ;  this lets you relocate code (eg. to $4500) and have it run from there if
                        	  1309: ;  you happen to hit Run.
                        	  1310: ;
00:9EE3 48              	  1311:   pha
00:9EE4 A577            	  1312:   lda ass_emit_bytes
00:9EE6 0578            	  1313:   ora ass_emit_bytes+1
00:9EE8 D008            	  1314:   bne ass_already_emitted
00:9EEA A523            	  1315:   lda PCODE
00:9EEC 8525            	  1316:   sta ACT_PCDA
00:9EEE A524            	  1317:   lda PCODE+1
00:9EF0 8526            	  1318:   sta ACT_PCDA+1
                        	  1319: ass_already_emitted:
00:9EF2 68              	  1320:   pla
                        	  1321: ;
                        	  1322: ;  write the byte to memory
                        	  1323: ;
00:9EF3 A000            	  1324:   ldy #0
00:9EF5 9123            	  1325:   sta (PCODE),Y
00:9EF7 E677            	  1326:   inc ass_emit_bytes
00:9EF9 D002            	  1327:   bne ass_emit4
00:9EFB E678            	  1328:   inc ass_emit_bytes+1
                        	  1329: ass_emit4:
                        	  1330: 
                        	  1331: ;
                        	  1332: ;  if displaying codes, show the emitted byte
                        	  1333: ;
00:9EFD A42E            	  1334:   ldy DCODE
00:9EFF F003            	  1335:   beq ass_emit3
00:9F01 20A692          	  1336:   jsr DISHX
                        	  1337: ;
                        	  1338: ;  increment the PCODE (output) address
                        	  1339: ;
                        	  1340: ass_emit3:
00:9F04 E623            	  1341:   inc PCODE
00:9F06 D002            	  1342:   bne ass_emit1
00:9F08 E624            	  1343:   inc PCODE+1
                        	  1344: ass_emit1:
00:9F0A E66F            	  1345:   inc ASS_EMIT_COUNT
00:9F0C 60              	  1346:   rts
                        	  1347: 
                        	  1348: ass_error:
00:9F0D A56F            	  1349:   lda ASS_EMIT_COUNT
00:9F0F F003            	  1350:   beq ass_error1
00:9F11 209192          	  1351:   jsr CROUT
                        	  1352: ass_error1:
00:9F14 4CCD97          	  1353:   jmp ERROR
                        	  1354: 
                        	  1355: ass_fixup_bbr_branch:
00:9F17 A507            	  1356:   lda REMAIN+1
00:9F19 D043            	  1357:   bne ass_emit_zero_page_too_high
00:9F1B A508            	  1358:   lda REMAIN+2
00:9F1D D03F            	  1359:   bne ass_emit_zero_page_too_high
00:9F1F A506            	  1360:   lda REMAIN
00:9F21 20CF9E          	  1361:   jsr ass_emit  ; output zero page address
                        	  1362: 
                        	  1363: ;
                        	  1364: ;  now fall down and emit the branch
                        	  1365: ;
                        	  1366: 
                        	  1367: ass_fixup_branch:
00:9F24 18              	  1368:   clc         ; I want to subtract one more, so I CLEAR carry <sigh>
00:9F25 A573            	  1369:   lda ASS_VALUE
00:9F27 E523            	  1370:   sbc PCODE
00:9F29 8573            	  1371:   sta ASS_VALUE
                        	  1372: 
00:9F2B A574            	  1373:   lda ASS_VALUE+1
00:9F2D E524            	  1374:   sbc PCODE+1
00:9F2F C9FF            	  1375:   cmp #$FF  ; backwards branch
00:9F31 F00A            	  1376:   beq ass_branch_backwards
00:9F33 C900            	  1377:   cmp #0
00:9F35 D010            	  1378:   bne ass_branch_out_of_range
00:9F37 A573            	  1379:   lda ASS_VALUE ; must be 0x00 to 0x7F
00:9F39 300C            	  1380:   bmi ass_branch_out_of_range
00:9F3B 8004            	  1381:   bra ass_branch_ok
                        	  1382: 
                        	  1383: ass_branch_backwards:
00:9F3D A573            	  1384:   lda ASS_VALUE   ; must be 0x80 to 0xFF
00:9F3F 1006            	  1385:   bpl ass_branch_out_of_range
                        	  1386: 
                        	  1387: ass_branch_ok:
00:9F41 A573            	  1388:   lda ASS_VALUE
00:9F43 20CF9E          	  1389:   jsr ass_emit  ; output relative address
00:9F46 60              	  1390:   rts
                        	  1391: 
                        	  1392: ass_branch_out_of_range:
00:9F47 A576            	  1393:   lda ASS_PASS
00:9F49 F0F6            	  1394:   beq ass_branch_ok   ; out of range is OK on first pass, we don't know how far the branch is
00:9F4B A22A            	  1395:   ldx #42
00:9F4D 4C0D9F          	  1396:   jmp ass_error  ; branch out of range
                        	  1397: 
                        	  1398: ass_emit_zero_page:
00:9F50 A574            	  1399:   lda ASS_VALUE+1
00:9F52 D00A            	  1400:   bne ass_emit_zero_page_too_high
00:9F54 A575            	  1401:   lda ASS_VALUE+2
00:9F56 D006            	  1402:   bne ass_emit_zero_page_too_high
00:9F58 A573            	  1403:   lda ASS_VALUE
00:9F5A 20CF9E          	  1404:   jsr ass_emit  ; output zero page address
00:9F5D 60              	  1405:   rts
                        	  1406: 
                        	  1407: 
                        	  1408: ass_emit_zero_page_too_high:
00:9F5E A22B            	  1409:   ldx #43       ; Need zero page address
00:9F60 4C0D9F          	  1410:   jmp ass_error
                        	  1411: 
                        	  1412: ass_emit_immediate:
00:9F63 A574            	  1413:   lda ASS_VALUE+1
00:9F65 D00A            	  1414:   bne ass_emit_immediate_too_high
00:9F67 A575            	  1415:   lda ASS_VALUE+2
00:9F69 D006            	  1416:   bne ass_emit_immediate_too_high
00:9F6B A573            	  1417:   lda ASS_VALUE
00:9F6D 20CF9E          	  1418:   jsr ass_emit  ; output immediate operand
00:9F70 60              	  1419:   rts
                        	  1420: 
                        	  1421: ass_emit_immediate_too_high:
00:9F71 A22C            	  1422:   ldx #44
00:9F73 4C0D9F          	  1423:   jmp ass_error
                        	  1424: 
                        	  1425: 
                        	  1426: ass_emit_absolute:
00:9F76 A573            	  1427:   lda ASS_VALUE
00:9F78 20CF9E          	  1428:   jsr ass_emit  ; output absolute address - low-order byte
00:9F7B A574            	  1429:   lda ASS_VALUE+1
00:9F7D 20CF9E          	  1430:   jsr ass_emit  ; output absolute address - high-order byte
00:9F80 60              	  1431:   rts
                        	  1432: 
                        	  1433: 
                        	  1434: ;------------------------------------
                        	  1435: ;  Opcode master table
                        	  1436: ;------------------------------------
                        	  1437: 
                        	  1438:    .macro makeOpcodeLookup ; table of opcodes, length of opcode, wanted operand type, special handler
                        	  1439:      dfb   \1
                        	  1440:      dfb   \2
                        	  1441:      word  \3
                        	  1442:      word   \4
                        	  1443:    .endmacro
                        	  1444: 
                        	  1445: ;
                        	  1446: ;  So, for an opcode to match, it has to:
                        	  1447: ;     a) be the right length (usually 3 or 4 characters)
                        	  1448: ;     b) have the right type of operand (eg. ASS_OPERAND_IMMEDIATE)
                        	  1449: ;     c) the opcode must match the name in the list
                        	  1450: ;
                        	  1451: ;   If those conditions are met we output the corresponding opcode,
                        	  1452: ;   return with the operand type in A
                        	  1453: ;
                        	  1454: ;   Otherwise, we return 0 in A
                        	  1455: ;
                        	  1456: 
                        	  1457: OPCODE_LOOKUP_OPCODE_LENGTH = 0
                        	  1458: OPCODE_LOOKUP_OPERAND_TYPE = 1
                        	  1459: OPCODE_LOOKUP_OPCODE_TABLE = 2    ; 2 bytes
                        	  1460: OPCODE_LOOKUP_HANDLER = 4         ; 2 bytes
                        	  1461: OPCODE_LOOKUP_TABLE_SIZE = 6      ; all of the above
                        	  1462: 
                        	  1463: OPCODE_LOOKUP_TABLE = *
                        	  1464: ;
                        	  1465: ;  zero-page opcodes go first as they are preferred if we are accessing a zero-page address
                        	  1466: ;
                        	  1467:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE, OPCODE_ASS_OPERAND_ZERO_PAGE, ass_emit_zero_page ; (11)
00:9F81 03              	     1M      dfb   3
00:9F82 0B              	     2M      dfb   ASS_OPERAND_ZERO_PAGE
00:9F83 0EA3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE
00:9F85 509F            	     4M      word   ass_emit_zero_page 
                        	  1468:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE, OPCODE_ASS_OPERAND_ZERO_PAGE_TOKENISED, ass_emit_zero_page ; (11)
00:9F87 01              	     1M      dfb   1
00:9F88 0B              	     2M      dfb   ASS_OPERAND_ZERO_PAGE
00:9F89 6FA3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_TOKENISED
00:9F8B 509F            	     4M      word   ass_emit_zero_page 
                        	  1469:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT, ass_em
00:9F8D 03              	     1M      dfb   3
00:9F8E 0C              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
00:9F8F 72A3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
00:9F91 509F            	     4M      word   ass_emit_zero_page 
                        	  1470:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT_TOKENIS
00:9F93 01              	     1M      dfb   1
00:9F94 0C              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
00:9F95 93A3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT_TOKENISED
00:9F97 509F            	     4M      word   ass_emit_zero_page 
                        	  1471:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X, ass_emit_z
00:9F99 03              	     1M      dfb   3
00:9F9A 0D              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
00:9F9B 96A3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
00:9F9D 509F            	     4M      word   ass_emit_zero_page 
                        	  1472:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X_TOKENISED, 
00:9F9F 01              	     1M      dfb   1
00:9FA0 0D              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
00:9FA1 DFA3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X_TOKENISED
00:9FA3 509F            	     4M      word   ass_emit_zero_page 
                        	  1473:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y, ass_emit_z
00:9FA5 03              	     1M      dfb   3
00:9FA6 0E              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
00:9FA7 E2A3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
00:9FA9 509F            	     4M      word   ass_emit_zero_page 
                        	  1474:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDIRECT, OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT, ass_emit_zero_page ; (
00:9FAB 03              	     1M      dfb   3
00:9FAC 0F              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDIRECT
00:9FAD EBA3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT
00:9FAF 509F            	     4M      word   ass_emit_zero_page 
                        	  1475:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE_INDIRECT, OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_TOKENISED, ass_emit_zer
00:9FB1 01              	     1M      dfb   1
00:9FB2 0F              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDIRECT
00:9FB3 0CA4            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_TOKENISED
00:9FB5 509F            	     4M      word   ass_emit_zero_page 
                        	  1476:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_
00:9FB7 03              	     1M      dfb   3
00:9FB8 10              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
00:9FB9 0FA4            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
00:9FBB 509F            	     4M      word   ass_emit_zero_page 
                        	  1477:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_
00:9FBD 01              	     1M      dfb   1
00:9FBE 10              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
00:9FBF 30A4            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y_TOKENISED
00:9FC1 509F            	     4M      word   ass_emit_zero_page 
                        	  1478: 
                        	  1479: ;
                        	  1480: ;  non zero-page opcodes
                        	  1481: ;
                        	  1482:     makeOpcodeLookup  4,  ASS_OPERAND_ABSOLUTE, OPCODE_4_CHAR_ZERO_PAGE,  ass_emit_zero_page  ; (11)
00:9FC3 04              	     1M      dfb   4
00:9FC4 01              	     2M      dfb   ASS_OPERAND_ABSOLUTE
00:9FC5 8AA1            	     3M      word  OPCODE_4_CHAR_ZERO_PAGE
00:9FC7 509F            	     4M      word   ass_emit_zero_page  
                        	  1483:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE, OPCODE_ASS_OPERAND_ABSOLUTE,  ass_emit_absolute  ; (1)
00:9FC9 03              	     1M      dfb   3
00:9FCA 01              	     2M      dfb   ASS_OPERAND_ABSOLUTE
00:9FCB DBA1            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE
00:9FCD 769F            	     4M      word   ass_emit_absolute  
                        	  1484:     makeOpcodeLookup  1,  ASS_OPERAND_ABSOLUTE, OPCODE_ASS_OPERAND_ABSOLUTE_TOKENISED,  ass_emit_absolute  ; (1)
00:9FCF 01              	     1M      dfb   1
00:9FD0 01              	     2M      dfb   ASS_OPERAND_ABSOLUTE
00:9FD1 44A2            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_TOKENISED
00:9FD3 769F            	     4M      word   ass_emit_absolute  
                        	  1485: 
                        	  1486:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT, ass_emit
00:9FD5 03              	     1M      dfb   3
00:9FD6 02              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
00:9FD7 47A2            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
00:9FD9 769F            	     4M      word   ass_emit_absolute 
                        	  1487:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X, ass_emit_abs
00:9FDB 03              	     1M      dfb   3
00:9FDC 03              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
00:9FDD 4CA2            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
00:9FDF 769F            	     4M      word   ass_emit_absolute 
                        	  1488:     makeOpcodeLookup  1,  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X_TOKENISED, as
00:9FE1 01              	     1M      dfb   1
00:9FE2 03              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
00:9FE3 91A2            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X_TOKENISED
00:9FE5 769F            	     4M      word   ass_emit_absolute 
                        	  1489:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y, ass_emit_abs
00:9FE7 03              	     1M      dfb   3
00:9FE8 04              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
00:9FE9 94A2            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
00:9FEB 769F            	     4M      word   ass_emit_absolute 
                        	  1490:     makeOpcodeLookup  1,  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y_TOKENISED, as
00:9FED 01              	     1M      dfb   1
00:9FEE 04              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
00:9FEF B9A2            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y_TOKENISED
00:9FF1 769F            	     4M      word   ass_emit_absolute 
                        	  1491:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDIRECT, OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT, ass_emit_absolute ; (5)
00:9FF3 03              	     1M      dfb   3
00:9FF4 05              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDIRECT
00:9FF5 D5A2            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT
00:9FF7 769F            	     4M      word   ass_emit_absolute 
                        	  1492:     makeOpcodeLookup  1,  ASS_OPERAND_ABSOLUTE_INDIRECT, OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED, ass_emit_absolute ; (5
00:9FF9 01              	     1M      dfb   1
00:9FFA 05              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDIRECT
00:9FFB 0BA3            	     3M      word  OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED
00:9FFD 769F            	     4M      word   ass_emit_absolute 
                        	  1493:     makeOpcodeLookup  3,  ASS_OPERAND_ACCUMULATOR_A, OPCODE_ASS_OPERAND_ACCUMULATOR_A, 0 ; (6)
00:9FFF 03              	     1M      dfb   3
00:A000 06              	     2M      dfb   ASS_OPERAND_ACCUMULATOR_A
00:A001 BCA2            	     3M      word  OPCODE_ASS_OPERAND_ACCUMULATOR_A
00:A003 0000            	     4M      word   0 
                        	  1494:     makeOpcodeLookup  3,  ASS_OPERAND_IMMEDIATE, OPCODE_ASS_OPERAND_IMMEDIATE, ass_emit_immediate ; (7)
00:A005 03              	     1M      dfb   3
00:A006 07              	     2M      dfb   ASS_OPERAND_IMMEDIATE
00:A007 DAA2            	     3M      word  OPCODE_ASS_OPERAND_IMMEDIATE
00:A009 639F            	     4M      word   ass_emit_immediate 
                        	  1495:     makeOpcodeLookup  1,  ASS_OPERAND_IMMEDIATE, OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED, ass_emit_immediate ; (7)
00:A00B 01              	     1M      dfb   1
00:A00C 07              	     2M      dfb   ASS_OPERAND_IMMEDIATE
00:A00D 0BA3            	     3M      word  OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED
00:A00F 639F            	     4M      word   ass_emit_immediate 
                        	  1496:     makeOpcodeLookup  3,  ASS_OPERAND_IMPLIED,  OPCODE_3_CHAR_IMPLIED,    0  ; (8) and (10)
00:A011 03              	     1M      dfb   3
00:A012 08              	     2M      dfb   ASS_OPERAND_IMPLIED
00:A013 0DA1            	     3M      word  OPCODE_3_CHAR_IMPLIED
00:A015 0000            	     4M      word   0  
                        	  1497:     makeOpcodeLookup  4,  ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE, OPCODE_4_CHAR_BRANCH,     ass_fixup_bbr_branch  ; (9)
00:A017 04              	     1M      dfb   4
00:A018 12              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE
00:A019 97A0            	     3M      word  OPCODE_4_CHAR_BRANCH
00:A01B 179F            	     4M      word   ass_fixup_bbr_branch  
                        	  1498:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE, OPCODE_3_CHAR_BRANCH,     ass_fixup_branch  ; (9)
00:A01D 03              	     1M      dfb   3
00:A01E 01              	     2M      dfb   ASS_OPERAND_ABSOLUTE
00:A01F E8A0            	     3M      word  OPCODE_3_CHAR_BRANCH
00:A021 249F            	     4M      word   ass_fixup_branch  
00:A023 00              	  1499:     dfb 0
                        	  1500: 
                        	  1501: 
                        	  1502: ;------------------------------------
                        	  1503: ;  directives
                        	  1504: ;------------------------------------
                        	  1505: 
                        	  1506: 
                        	  1507: DIRECTIVES = *
                        	  1508:   makeHandler "ASSERT",   asm_do_assert
00:A024 415353455254    	     1M    asciiz   "ASSERT"
00:A02A 00
00:A02B 33A4            	     2M    word  asm_do_assert
                        	  1509:   makeHandler "LIST",     asm_do_list
00:A02D 4C495354        	     1M    asciiz   "LIST"
00:A031 00
00:A032 4AA4            	     2M    word  asm_do_list
                        	  1510:   makeHandler "NOLIST",   asm_do_nolist
00:A034 4E4F4C495354    	     1M    asciiz   "NOLIST"
00:A03A 00
00:A03B 59A4            	     2M    word  asm_do_nolist
                        	  1511:   makeHandler "ASC",      asm_do_asc
00:A03D 415343          	     1M    asciiz   "ASC"
00:A040 00
00:A041 98A4            	     2M    word  asm_do_asc
                        	  1512:   makeHandler "ASCII",    asm_do_asc
00:A043 4153434949      	     1M    asciiz   "ASCII"
00:A048 00
00:A049 98A4            	     2M    word  asm_do_asc
                        	  1513:   makeHandler "ASCIIZ",   asm_do_string
00:A04B 41534349495A    	     1M    asciiz   "ASCIIZ"
00:A051 00
00:A052 B3A4            	     2M    word  asm_do_string
                        	  1514:   makeHandler "STRING",   asm_do_string
00:A054 535452494E47    	     1M    asciiz   "STRING"
00:A05A 00
00:A05B B3A4            	     2M    word  asm_do_string
                        	  1515:   makeHandler "EQU",      asm_do_equ
00:A05D 455155          	     1M    asciiz   "EQU"
00:A060 00
00:A061 BCA4            	     2M    word  asm_do_equ
                        	  1516:   makeHandler "=",        asm_do_equ
00:A063 3D              	     1M    asciiz   "="
00:A064 00
00:A065 BCA4            	     2M    word  asm_do_equ
                        	  1517:   makeHandler "ORG",      asm_do_org
00:A067 4F5247          	     1M    asciiz   "ORG"
00:A06A 00
00:A06B D9A4            	     2M    word  asm_do_org
                        	  1518:   makeHandler "DFB",      asm_do_dfb
00:A06D 444642          	     1M    asciiz   "DFB"
00:A070 00
00:A071 EDA4            	     2M    word  asm_do_dfb
                        	  1519:   makeHandler "DFW",      asm_do_dfw
00:A073 444657          	     1M    asciiz   "DFW"
00:A076 00
00:A077 2DA5            	     2M    word  asm_do_dfw
                        	  1520:   makeHandler "WORD",     asm_do_dfw
00:A079 574F5244        	     1M    asciiz   "WORD"
00:A07D 00
00:A07E 2DA5            	     2M    word  asm_do_dfw
                        	  1521:   makeHandler "BLK",      asm_do_blk
00:A080 424C4B          	     1M    asciiz   "BLK"
00:A083 00
00:A084 6AA5            	     2M    word  asm_do_blk
                        	  1522:   makeHandler "RESERVE",  asm_do_reserve
00:A086 52455345525645  	     1M    asciiz   "RESERVE"
00:A08D 00
00:A08E 88A5            	     2M    word  asm_do_reserve
                        	  1523:   makeHandler "SYM",      asm_do_sym
00:A090 53594D          	     1M    asciiz   "SYM"
00:A093 00
00:A094 A3A5            	     2M    word  asm_do_sym
                        	  1524: 
00:A096 00              	  1525:   dfb 0
                        	  1526: 
                        	  1527: ;------------------------------------
                        	  1528: ;  4-character branch opcodes
                        	  1529: ;------------------------------------
                        	  1530: 
                        	  1531: 
                        	  1532: OPCODE_4_CHAR_BRANCH = *
00:A097 42425230        	  1533:   asc "BBR0",$0F
00:A09B 0F
00:A09C 42425231        	  1534:   asc "BBR1",$1F
00:A0A0 1F
00:A0A1 42425232        	  1535:   asc "BBR2",$2F
00:A0A5 2F
00:A0A6 42425233        	  1536:   asc "BBR3",$3F
00:A0AA 3F
00:A0AB 42425234        	  1537:   asc "BBR4",$4F
00:A0AF 4F
00:A0B0 42425235        	  1538:   asc "BBR5",$5F
00:A0B4 5F
00:A0B5 42425236        	  1539:   asc "BBR6",$6F
00:A0B9 6F
00:A0BA 42425237        	  1540:   asc "BBR7",$7F
00:A0BE 7F
00:A0BF 42425330        	  1541:   asc "BBS0",$8F
00:A0C3 8F
00:A0C4 42425331        	  1542:   asc "BBS1",$9F
00:A0C8 9F
00:A0C9 42425332        	  1543:   asc "BBS2",$AF
00:A0CD AF
00:A0CE 42425333        	  1544:   asc "BBS3",$BF
00:A0D2 BF
00:A0D3 42425334        	  1545:   asc "BBS4",$CF
00:A0D7 CF
00:A0D8 42425335        	  1546:   asc "BBS5",$DF
00:A0DC DF
00:A0DD 42425336        	  1547:   asc "BBS6",$EF
00:A0E1 EF
00:A0E2 42425337        	  1548:   asc "BBS7",$FF
00:A0E6 FF
00:A0E7 00              	  1549:   dfb 0
                        	  1550: 
                        	  1551: ;------------------------------------
                        	  1552: ;  3-character branch opcodes
                        	  1553: ;------------------------------------
                        	  1554: 
                        	  1555: 
                        	  1556: OPCODE_3_CHAR_BRANCH = *
00:A0E8 424343          	  1557:   asc "BCC",$90
00:A0EB 90
00:A0EC 424353          	  1558:   asc "BCS",$B0
00:A0EF B0
00:A0F0 424551          	  1559:   asc "BEQ",$F0
00:A0F3 F0
00:A0F4 424D49          	  1560:   asc "BMI",$30
00:A0F7 30
00:A0F8 424E45          	  1561:   asc "BNE",$D0
00:A0FB D0
00:A0FC 42504C          	  1562:   asc "BPL",$10
00:A0FF 10
00:A100 425241          	  1563:   asc "BRA",$80
00:A103 80
00:A104 425643          	  1564:   asc "BVC",$50
00:A107 50
00:A108 425653          	  1565:   asc "BVS",$70
00:A10B 70
00:A10C 00              	  1566:   dfb 0
                        	  1567: 
                        	  1568: 
                        	  1569: ;------------------------------------
                        	  1570: ;  3-character implied opcodes (no operand)
                        	  1571: ;------------------------------------
                        	  1572: 
                        	  1573: OPCODE_3_CHAR_IMPLIED = *
00:A10D 42524B          	  1574:   asc "BRK",$00
00:A110 00
00:A111 434C43          	  1575:   asc "CLC",$18
00:A114 18
00:A115 434C44          	  1576:   asc "CLD",$D8
00:A118 D8
00:A119 434C49          	  1577:   asc "CLI",$58
00:A11C 58
00:A11D 434C56          	  1578:   asc "CLV",$B8
00:A120 B8
00:A121 444558          	  1579:   asc "DEX",$CA
00:A124 CA
00:A125 444559          	  1580:   asc "DEY",$88
00:A128 88
00:A129 494E58          	  1581:   asc "INX",$E8
00:A12C E8
00:A12D 494E59          	  1582:   asc "INY",$C8
00:A130 C8
00:A131 4E4F50          	  1583:   asc "NOP",$EA
00:A134 EA
00:A135 504841          	  1584:   asc "PHA",$48
00:A138 48
00:A139 504850          	  1585:   asc "PHP",$08
00:A13C 08
00:A13D 504858          	  1586:   asc "PHX",$DA
00:A140 DA
00:A141 504859          	  1587:   asc "PHY",$5A
00:A144 5A
00:A145 504C41          	  1588:   asc "PLA",$68
00:A148 68
00:A149 504C50          	  1589:   asc "PLP",$28
00:A14C 28
00:A14D 504C58          	  1590:   asc "PLX",$FA
00:A150 FA
00:A151 504C59          	  1591:   asc "PLY",$7A
00:A154 7A
00:A155 525449          	  1592:   asc "RTI",$40
00:A158 40
00:A159 525453          	  1593:   asc "RTS",$60
00:A15C 60
00:A15D 534543          	  1594:   asc "SEC",$38
00:A160 38
00:A161 534544          	  1595:   asc "SED",$F8
00:A164 F8
00:A165 534549          	  1596:   asc "SEI",$78
00:A168 78
00:A169 535450          	  1597:   asc "STP",$DB
00:A16C DB
00:A16D 544158          	  1598:   asc "TAX",$AA
00:A170 AA
00:A171 544159          	  1599:   asc "TAY",$A8
00:A174 A8
00:A175 545358          	  1600:   asc "TSX",$BA
00:A178 BA
00:A179 545841          	  1601:   asc "TXA",$8A
00:A17C 8A
00:A17D 545853          	  1602:   asc "TXS",$9A
00:A180 9A
00:A181 545941          	  1603:   asc "TYA",$98
00:A184 98
00:A185 574149          	  1604:   asc "WAI",$CB
00:A188 CB
00:A189 00              	  1605:   dfb 0
                        	  1606: 
                        	  1607: ;------------------------------------
                        	  1608: ;  4-character zero page opcodes (operand must be zero-page address)
                        	  1609: ;------------------------------------
                        	  1610: OPCODE_4_CHAR_ZERO_PAGE = *
00:A18A 534D4230        	  1611:   asc "SMB0",$87
00:A18E 87
00:A18F 534D4231        	  1612:   asc "SMB1",$97
00:A193 97
00:A194 534D4232        	  1613:   asc "SMB2",$A7
00:A198 A7
00:A199 534D4233        	  1614:   asc "SMB3",$B7
00:A19D B7
00:A19E 534D4234        	  1615:   asc "SMB4",$C7
00:A1A2 C7
00:A1A3 534D4235        	  1616:   asc "SMB5",$D7
00:A1A7 D7
00:A1A8 534D4236        	  1617:   asc "SMB6",$E7
00:A1AC E7
00:A1AD 534D4237        	  1618:   asc "SMB7",$F7
00:A1B1 F7
00:A1B2 524D4230        	  1619:   asc "RMB0",$07
00:A1B6 07
00:A1B7 524D4231        	  1620:   asc "RMB1",$17
00:A1BB 17
00:A1BC 524D4232        	  1621:   asc "RMB2",$27
00:A1C0 27
00:A1C1 524D4233        	  1622:   asc "RMB3",$37
00:A1C5 37
00:A1C6 524D4234        	  1623:   asc "RMB4",$47
00:A1CA 47
00:A1CB 524D4235        	  1624:   asc "RMB5",$57
00:A1CF 57
00:A1D0 524D4236        	  1625:   asc "RMB6",$67
00:A1D4 67
00:A1D5 524D4237        	  1626:   asc "RMB7",$77
00:A1D9 77
00:A1DA 00              	  1627:   dfb 0
                        	  1628: 
                        	  1629: ;------------------------------------
                        	  1630: ;  ASS_OPERAND_ABSOLUTE
                        	  1631: ;------------------------------------
                        	  1632: OPCODE_ASS_OPERAND_ABSOLUTE = *
00:A1DB 414443          	  1633:   asc "ADC",$6D
00:A1DE 6D
00:A1DF 414E44          	  1634:   asc "AND",$2D
00:A1E2 2D
00:A1E3 41534C          	  1635:   asc "ASL",$0E
00:A1E6 0E
00:A1E7 424954          	  1636:   asc "BIT",$2C
00:A1EA 2C
00:A1EB 434D50          	  1637:   asc "CMP",$CD
00:A1EE CD
00:A1EF 435058          	  1638:   asc "CPX",$EC
00:A1F2 EC
00:A1F3 435059          	  1639:   asc "CPY",$CC
00:A1F6 CC
00:A1F7 444543          	  1640:   asc "DEC",$CE
00:A1FA CE
00:A1FB 454F52          	  1641:   asc "EOR",$4D
00:A1FE 4D
00:A1FF 494E43          	  1642:   asc "INC",$EE
00:A202 EE
00:A203 4A4D50          	  1643:   asc "JMP",$4C
00:A206 4C
00:A207 4A5352          	  1644:   asc "JSR",$20
00:A20A 20
00:A20B 4C4441          	  1645:   asc "LDA",$AD
00:A20E AD
00:A20F 4C4458          	  1646:   asc "LDX",$AE
00:A212 AE
00:A213 4C4459          	  1647:   asc "LDY",$AC
00:A216 AC
00:A217 4C5352          	  1648:   asc "LSR",$4E
00:A21A 4E
00:A21B 4F5241          	  1649:   asc "ORA",$0D
00:A21E 0D
00:A21F 524F4C          	  1650:   asc "ROL",$2E
00:A222 2E
00:A223 524F52          	  1651:   asc "ROR",$6E
00:A226 6E
00:A227 534243          	  1652:   asc "SBC",$ED
00:A22A ED
00:A22B 535441          	  1653:   asc "STA",$8D
00:A22E 8D
00:A22F 535458          	  1654:   asc "STX",$8E
00:A232 8E
00:A233 535459          	  1655:   asc "STY",$8C
00:A236 8C
00:A237 53545A          	  1656:   asc "STZ",$9C
00:A23A 9C
00:A23B 545242          	  1657:   asc "TRB",$1C
00:A23E 1C
00:A23F 545342          	  1658:   asc "TSB",$0C
00:A242 0C
00:A243 00              	  1659:   dfb 0
                        	  1660: 
                        	  1661: ;------------------------------------
                        	  1662: ;  ASS_OPERAND_ABSOLUTE - for tokenised opcodes like AND
                        	  1663: ;------------------------------------
                        	  1664: OPCODE_ASS_OPERAND_ABSOLUTE_TOKENISED = *
00:A244 8D              	  1665:   dfb TOKEN_AND,$2D
00:A245 2D
00:A246 00              	  1666:   dfb 0
                        	  1667: 
                        	  1668: 
                        	  1669: ;------------------------------------
                        	  1670: ;  ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
                        	  1671: ;------------------------------------
                        	  1672: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT = *
00:A247 4A4D50          	  1673:   asc "JMP",$7C
00:A24A 7C
00:A24B 00              	  1674:   dfb 0
                        	  1675: 
                        	  1676: ;------------------------------------
                        	  1677: ;  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
                        	  1678: ;------------------------------------
                        	  1679: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X = *
00:A24C 414443          	  1680:   asc "ADC",$7D
00:A24F 7D
00:A250 414E44          	  1681:   asc "AND",$3D
00:A253 3D
00:A254 41534C          	  1682:   asc "ASL",$1E
00:A257 1E
00:A258 424954          	  1683:   asc "BIT",$3C
00:A25B 3C
00:A25C 434D50          	  1684:   asc "CMP",$DD
00:A25F DD
00:A260 444543          	  1685:   asc "DEC",$DE
00:A263 DE
00:A264 454F52          	  1686:   asc "EOR",$5D
00:A267 5D
00:A268 494E43          	  1687:   asc "INC",$FE
00:A26B FE
00:A26C 4C4441          	  1688:   asc "LDA",$BD
00:A26F BD
00:A270 4C4459          	  1689:   asc "LDY",$BC
00:A273 BC
00:A274 4C5352          	  1690:   asc "LSR",$5E
00:A277 5E
00:A278 4F5241          	  1691:   asc "ORA",$1D
00:A27B 1D
00:A27C 524F4C          	  1692:   asc "ROL",$3E
00:A27F 3E
00:A280 524F52          	  1693:   asc "ROR",$7E
00:A283 7E
00:A284 534243          	  1694:   asc "SBC",$FD
00:A287 FD
00:A288 535441          	  1695:   asc "STA",$9D
00:A28B 9D
00:A28C 53545A          	  1696:   asc "STZ",$9E
00:A28F 9E
00:A290 00              	  1697:   dfb 0
                        	  1698: 
                        	  1699: ;------------------------------------
                        	  1700: ;  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X - for tokenised opcodes like AND
                        	  1701: ;------------------------------------
                        	  1702: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X_TOKENISED = *
00:A291 8D              	  1703:   dfb TOKEN_AND,$3D
00:A292 3D
00:A293 00              	  1704:   dfb 0
                        	  1705: 
                        	  1706: ;------------------------------------
                        	  1707: ;  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
                        	  1708: ;------------------------------------
                        	  1709: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y = *
00:A294 414443          	  1710:   asc "ADC",$79
00:A297 79
00:A298 414E44          	  1711:   asc "AND",$39
00:A29B 39
00:A29C 434D50          	  1712:   asc "CMP",$D9
00:A29F D9
00:A2A0 454F52          	  1713:   asc "EOR",$59
00:A2A3 59
00:A2A4 4C4441          	  1714:   asc "LDA",$B9
00:A2A7 B9
00:A2A8 4C4458          	  1715:   asc "LDX",$BE
00:A2AB BE
00:A2AC 4F5241          	  1716:   asc "ORA",$19
00:A2AF 19
00:A2B0 534243          	  1717:   asc "SBC",$F9
00:A2B3 F9
00:A2B4 535441          	  1718:   asc "STA",$99
00:A2B7 99
00:A2B8 00              	  1719:   dfb 0
                        	  1720: 
                        	  1721: ;------------------------------------
                        	  1722: ;  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y - for tokenised opcodes like AND
                        	  1723: ;------------------------------------
                        	  1724: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y_TOKENISED = *
00:A2B9 8D              	  1725:   dfb TOKEN_AND,$39
00:A2BA 39
00:A2BB 00              	  1726:   dfb 0
                        	  1727: 
                        	  1728: ;------------------------------------
                        	  1729: ;  ASS_OPERAND_ACCUMULATOR_A
                        	  1730: ;------------------------------------
                        	  1731: OPCODE_ASS_OPERAND_ACCUMULATOR_A = *
00:A2BC 41534C          	  1732:   asc "ASL",$0A
00:A2BF 0A
00:A2C0 444543          	  1733:   asc "DEC",$3A
00:A2C3 3A
00:A2C4 494E43          	  1734:   asc "INC",$1A
00:A2C7 1A
00:A2C8 4C5352          	  1735:   asc "LSR",$4A
00:A2CB 4A
00:A2CC 524F4C          	  1736:   asc "ROL",$2A
00:A2CF 2A
00:A2D0 524F52          	  1737:   asc "ROR",$6A
00:A2D3 6A
00:A2D4 00              	  1738:   dfb 0
                        	  1739: 
                        	  1740: ;------------------------------------
                        	  1741: ;  ASS_OPERAND_ABSOLUTE_INDIRECT
                        	  1742: ;------------------------------------
                        	  1743: OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT = *
00:A2D5 4A4D50          	  1744:   asc "JMP",$6C
00:A2D8 6C
00:A2D9 00              	  1745:   dfb 0
                        	  1746: 
                        	  1747: ;------------------------------------
                        	  1748: ;  ASS_OPERAND_IMMEDIATE
                        	  1749: ;------------------------------------
                        	  1750: OPCODE_ASS_OPERAND_IMMEDIATE = *
00:A2DA 414443          	  1751:   asc "ADC",$69
00:A2DD 69
00:A2DE 414E44          	  1752:   asc "AND",$29
00:A2E1 29
00:A2E2 424954          	  1753:   asc "BIT",$89
00:A2E5 89
00:A2E6 434D50          	  1754:   asc "CMP",$C9
00:A2E9 C9
00:A2EA 435058          	  1755:   asc "CPX",$E0
00:A2ED E0
00:A2EE 435059          	  1756:   asc "CPY",$C0
00:A2F1 C0
00:A2F2 454F52          	  1757:   asc "EOR",$49
00:A2F5 49
00:A2F6 4C4441          	  1758:   asc "LDA",$A9
00:A2F9 A9
00:A2FA 4C4458          	  1759:   asc "LDX",$A2
00:A2FD A2
00:A2FE 4C4459          	  1760:   asc "LDY",$A0
00:A301 A0
00:A302 4F5241          	  1761:   asc "ORA",$09
00:A305 09
00:A306 534243          	  1762:   asc "SBC",$E9
00:A309 E9
00:A30A 00              	  1763:   dfb 0
                        	  1764: 
                        	  1765: ;------------------------------------
                        	  1766: ;  ASS_OPERAND_IMMEDIATE - for tokenised opcodes like AND
                        	  1767: ;------------------------------------
                        	  1768: OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED = *
00:A30B 8D              	  1769:   dfb TOKEN_AND,$29
00:A30C 29
00:A30D 00              	  1770:   dfb 0
                        	  1771: 
                        	  1772: ;------------------------------------
                        	  1773: ;  ASS_OPERAND_ZERO_PAGE
                        	  1774: ;------------------------------------
                        	  1775: OPCODE_ASS_OPERAND_ZERO_PAGE = *
00:A30E 414443          	  1776:   asc "ADC",$65
00:A311 65
00:A312 414E44          	  1777:   asc "AND",$25
00:A315 25
00:A316 41534C          	  1778:   asc "ASL",$06
00:A319 06
00:A31A 424954          	  1779:   asc "BIT",$24
00:A31D 24
00:A31E 434D50          	  1780:   asc "CMP",$C5
00:A321 C5
00:A322 435058          	  1781:   asc "CPX",$E4
00:A325 E4
00:A326 435059          	  1782:   asc "CPY",$C4
00:A329 C4
00:A32A 444543          	  1783:   asc "DEC",$C6
00:A32D C6
00:A32E 454F52          	  1784:   asc "EOR",$45
00:A331 45
00:A332 494E43          	  1785:   asc "INC",$E6
00:A335 E6
00:A336 4C4441          	  1786:   asc "LDA",$A5
00:A339 A5
00:A33A 4C4458          	  1787:   asc "LDX",$A6
00:A33D A6
00:A33E 4C4459          	  1788:   asc "LDY",$A4
00:A341 A4
00:A342 4C5352          	  1789:   asc "LSR",$46
00:A345 46
00:A346 4F5241          	  1790:   asc "ORA",$05
00:A349 05
00:A34A 524F4C          	  1791:   asc "ROL",$26
00:A34D 26
00:A34E 524F52          	  1792:   asc "ROR",$66
00:A351 66
00:A352 534243          	  1793:   asc "SBC",$E5
00:A355 E5
00:A356 535441          	  1794:   asc "STA",$85
00:A359 85
00:A35A 535458          	  1795:   asc "STX",$86
00:A35D 86
00:A35E 535459          	  1796:   asc "STY",$84
00:A361 84
00:A362 53545A          	  1797:   asc "STZ",$64
00:A365 64
00:A366 545242          	  1798:   asc "TRB",$14
00:A369 14
00:A36A 545342          	  1799:   asc "TSB",$04
00:A36D 04
00:A36E 00              	  1800:   dfb 0
                        	  1801: 
                        	  1802: ;------------------------------------
                        	  1803: ;  ASS_OPERAND_ZERO_PAGE  - for tokenised opcodes like AND
                        	  1804: ;------------------------------------
                        	  1805: OPCODE_ASS_OPERAND_ZERO_PAGE_TOKENISED = *
00:A36F 8D              	  1806:   dfb TOKEN_AND,$25
00:A370 25
00:A371 00              	  1807:   dfb 0
                        	  1808: 
                        	  1809: 
                        	  1810: ;------------------------------------
                        	  1811: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
                        	  1812: ;------------------------------------
                        	  1813: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT = *
00:A372 414443          	  1814:   asc "ADC",$61
00:A375 61
00:A376 414E44          	  1815:   asc "AND",$21
00:A379 21
00:A37A 434D50          	  1816:   asc "CMP",$C1
00:A37D C1
00:A37E 454F52          	  1817:   asc "EOR",$41
00:A381 41
00:A382 4C4441          	  1818:   asc "LDA",$A1
00:A385 A1
00:A386 4F5241          	  1819:   asc "ORA",$01
00:A389 01
00:A38A 534243          	  1820:   asc "SBC",$E1
00:A38D E1
00:A38E 535441          	  1821:   asc "STA",$81
00:A391 81
00:A392 00              	  1822:   dfb 0
                        	  1823: 
                        	  1824: ;------------------------------------
                        	  1825: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT  - for tokenised opcodes like AND
                        	  1826: ;------------------------------------
                        	  1827: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT_TOKENISED  = *
00:A393 8D              	  1828:   dfb TOKEN_AND,$21
00:A394 21
00:A395 00              	  1829:   dfb 0
                        	  1830: 
                        	  1831: 
                        	  1832: ;------------------------------------
                        	  1833: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
                        	  1834: ;------------------------------------
                        	  1835: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X = *
00:A396 414443          	  1836:   asc "ADC",$75
00:A399 75
00:A39A 414E44          	  1837:   asc "AND",$35
00:A39D 35
00:A39E 41534C          	  1838:   asc "ASL",$16
00:A3A1 16
00:A3A2 424954          	  1839:   asc "BIT",$34
00:A3A5 34
00:A3A6 434D50          	  1840:   asc "CMP",$D5
00:A3A9 D5
00:A3AA 444543          	  1841:   asc "DEC",$D6
00:A3AD D6
00:A3AE 454F52          	  1842:   asc "EOR",$55
00:A3B1 55
00:A3B2 494E43          	  1843:   asc "INC",$F6
00:A3B5 F6
00:A3B6 4C4441          	  1844:   asc "LDA",$B5
00:A3B9 B5
00:A3BA 4C4459          	  1845:   asc "LDY",$B4
00:A3BD B4
00:A3BE 4C5352          	  1846:   asc "LSR",$56
00:A3C1 56
00:A3C2 4F5241          	  1847:   asc "ORA",$15
00:A3C5 15
00:A3C6 524F4C          	  1848:   asc "ROL",$36
00:A3C9 36
00:A3CA 524F52          	  1849:   asc "ROR",$76
00:A3CD 76
00:A3CE 534243          	  1850:   asc "SBC",$F5
00:A3D1 F5
00:A3D2 535441          	  1851:   asc "STA",$95
00:A3D5 95
00:A3D6 535459          	  1852:   asc "STY",$94
00:A3D9 94
00:A3DA 53545A          	  1853:   asc "STZ",$74
00:A3DD 74
00:A3DE 00              	  1854:   dfb 0
                        	  1855: 
                        	  1856: ;------------------------------------
                        	  1857: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X  - for tokenised opcodes like AND
                        	  1858: ;------------------------------------
                        	  1859: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X_TOKENISED = *
00:A3DF 8D              	  1860:   dfb TOKEN_AND,$35
00:A3E0 35
00:A3E1 00              	  1861:   dfb 0
                        	  1862: 
                        	  1863: ;------------------------------------
                        	  1864: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
                        	  1865: ;------------------------------------
                        	  1866: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y = *
00:A3E2 4C4458          	  1867:   asc "LDX",$B6
00:A3E5 B6
00:A3E6 535458          	  1868:   asc "STX",$96
00:A3E9 96
00:A3EA 00              	  1869:   dfb 0
                        	  1870: 
                        	  1871: ;------------------------------------
                        	  1872: ;  ASS_OPERAND_ZERO_PAGE_INDIRECT
                        	  1873: ;------------------------------------
                        	  1874: OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT = *
00:A3EB 414443          	  1875:   asc "ADC",$72
00:A3EE 72
00:A3EF 414E44          	  1876:   asc "AND",$32
00:A3F2 32
00:A3F3 434D50          	  1877:   asc "CMP",$D2
00:A3F6 D2
00:A3F7 454F52          	  1878:   asc "EOR",$52
00:A3FA 52
00:A3FB 4C4441          	  1879:   asc "LDA",$B2
00:A3FE B2
00:A3FF 4F5241          	  1880:   asc "ORA",$12
00:A402 12
00:A403 534243          	  1881:   asc "SBC",$F2
00:A406 F2
00:A407 535441          	  1882:   asc "STA",$92
00:A40A 92
00:A40B 00              	  1883:   dfb 0
                        	  1884: 
                        	  1885: ;------------------------------------
                        	  1886: ;  ASS_OPERAND_ZERO_PAGE_INDIRECT  - for tokenised opcodes like AND
                        	  1887: ;------------------------------------
                        	  1888: OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_TOKENISED = *
00:A40C 8D              	  1889:   dfb TOKEN_AND,$32
00:A40D 32
00:A40E 00              	  1890:   dfb 0
                        	  1891: 
                        	  1892: ;------------------------------------
                        	  1893: ;  ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
                        	  1894: ;------------------------------------
                        	  1895: OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y = *
00:A40F 414443          	  1896:   asc "ADC",$71
00:A412 71
00:A413 414E44          	  1897:   asc "AND",$31
00:A416 31
00:A417 434D50          	  1898:   asc "CMP",$D1
00:A41A D1
00:A41B 454F52          	  1899:   asc "EOR",$51
00:A41E 51
00:A41F 4C4441          	  1900:   asc "LDA",$B1
00:A422 B1
00:A423 4F5241          	  1901:   asc "ORA",$11
00:A426 11
00:A427 534243          	  1902:   asc "SBC",$F1
00:A42A F1
00:A42B 535441          	  1903:   asc "STA",$91
00:A42E 91
00:A42F 00              	  1904:   dfb 0
                        	  1905: 
                        	  1906: ;------------------------------------
                        	  1907: ;  ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y - for tokenised opcodes like AND
                        	  1908: ;------------------------------------
                        	  1909: OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y_TOKENISED  = *
00:A430 8D              	  1910:   dfb TOKEN_AND,$31
00:A431 31
00:A432 00              	  1911:   dfb 0
                        	  1912: 
                        	  1913: 
                        	  1914: ; ---------------------------
                        	  1915: ; Compiler directives
                        	  1916: ; ---------------------------
                        	  1917: 
                        	  1918: ;
                        	  1919: ;  ASSERT <expression>  - raises an error if <expression> is zero
                        	  1920: ;
                        	  1921: asm_do_assert:
00:A433 A56B            	  1922:   lda ASS_OPERAND
00:A435 C901            	  1923:   cmp #ASS_OPERAND_ABSOLUTE
00:A437 D00E            	  1924:   bne asm_do_constant_expectedJ
00:A439 A500            	  1925:   lda VALUE
00:A43B 0501            	  1926:   ora VALUE+1
00:A43D 0502            	  1927:   ora VALUE+2
00:A43F F001            	  1928:   beq asm_do_assert_failed
00:A441 60              	  1929:   rts
                        	  1930: 
                        	  1931: asm_do_assert_failed:
00:A442 A234            	  1932:   ldx #52
00:A444 4C0D9F          	  1933:   jmp ass_error
                        	  1934: 
00:A447 4CDFA4          	  1935: asm_do_constant_expectedJ jmp asm_do_constant_expected
                        	  1936: 
                        	  1937: ;
                        	  1938: ; LIST (0= none, 1=source, 2=opcodes, 4=symbols, can OR these together)
                        	  1939: ; LIST  is the same as LIST 3
                        	  1940: 
                        	  1941: asm_do_list = *
                        	  1942: 
                        	  1943: ;   lda #'f'
                        	  1944: ;   jsr ass_debug_point
                        	  1945: 
00:A44A A56B            	  1946:   lda ASS_OPERAND
00:A44C C908            	  1947:   cmp #ASS_OPERAND_IMPLIED      ; implied (ie. no operand) will resolve to be the same as LIST 3
00:A44E F01A            	  1948:   beq asm_do_list_no_operand
00:A450 C901            	  1949:   cmp #ASS_OPERAND_ABSOLUTE
00:A452 F01A            	  1950:   beq asm_do_list_ok
00:A454 A202            	  1951:   ldx #2    ; ERROR: constant expected
00:A456 4C0D9F          	  1952:   jmp ass_error
                        	  1953: 
                        	  1954: ;
                        	  1955: ;  NOLIST is the same as LIST 0
                        	  1956: ;
                        	  1957: asm_do_nolist:
00:A459 A56B            	  1958:   lda ASS_OPERAND
00:A45B C908            	  1959:   cmp #ASS_OPERAND_IMPLIED
00:A45D F005            	  1960:   beq asm_do_nolist_ok              ; should have no operand
00:A45F A217            	  1961:   ldx #23   ; ERROR: Illegal factor
00:A461 4C0D9F          	  1962:   jmp ass_error
                        	  1963: asm_do_nolist_ok:
00:A464 A900            	  1964:   lda #0
00:A466 8500            	  1965:   sta VALUE
00:A468 8004            	  1966:   bra asm_do_list_ok
                        	  1967: 
                        	  1968: asm_do_list_no_operand:
00:A46A A903            	  1969:   lda #3
00:A46C 8573            	  1970:   sta ASS_VALUE
                        	  1971: asm_do_list_ok:
00:A46E A576            	  1972:   lda ASS_PASS
00:A470 F025            	  1973:   beq asm_do_list_first_pass  ; ignore on first pass
                        	  1974: 
                        	  1975: ;  lda ASS_VALUE
                        	  1976: ;  clc
                        	  1977: ;  adc #'0'
                        	  1978: ;  jsr ass_debug_point
                        	  1979: 
00:A472 A573            	  1980:   lda ASS_VALUE
00:A474 2901            	  1981:   and #$01
00:A476 F00C            	  1982:   beq asm_do_list_not    ; no listing wanted
00:A478 A904            	  1983:   lda #FLAG_LIST_SOURCE ; already listing?
00:A47A 25BE            	  1984:   and system_flags
00:A47C D00A            	  1985:   bne  asm_do_list1   ; yep
00:A47E A904            	  1986:   lda #FLAG_LIST_SOURCE
00:A480 04BE            	  1987:   tsb system_flags
                        	  1988: ;  jsr token_line        ; list the current line  TODO: don't know, I think it bumps the line number wrongly
00:A482 8004            	  1989:   bra asm_do_list1
                        	  1990: 
                        	  1991: ;
                        	  1992: ;  turn off list flag
                        	  1993: ;
                        	  1994: asm_do_list_not:
00:A484 A904            	  1995:   lda #FLAG_LIST_SOURCE
00:A486 14BE            	  1996:   trb system_flags
                        	  1997: 
                        	  1998: asm_do_list1:
                        	  1999: 
                        	  2000: 
00:A488 A573            	  2001:   lda ASS_VALUE
00:A48A 2902            	  2002:   and #$02
00:A48C 852E            	  2003:   sta DCODE
                        	  2004: 
                        	  2005: 
00:A48E A573            	  2006:   lda ASS_VALUE
00:A490 2904            	  2007:   and #$04
00:A492 8582            	  2008:   sta show_symbols
                        	  2009: ;
                        	  2010: ;  output a newline, to get past the asterisks
                        	  2011: ;
00:A494 209192          	  2012:   jsr CROUT
                        	  2013: asm_do_list_first_pass:
00:A497 60              	  2014:   rts
                        	  2015: 
                        	  2016: ;
                        	  2017: ;  ASC "String"
                        	  2018: ;
                        	  2019: asm_do_asc = *
00:A498 A56B            	  2020:   lda ASS_OPERAND
00:A49A C911            	  2021:   cmp #ASS_OPERAND_STRING
00:A49C F005            	  2022:   beq asm_do_asc_ok
00:A49E A208            	  2023:   ldx #8    ; ERROR: incorrect string
00:A4A0 4C0D9F          	  2024:   jmp ass_error
                        	  2025: ;
                        	  2026: ;  now emit the string
                        	  2027: ;
                        	  2028: asm_do_asc_ok:
00:A4A3 A000            	  2029:   ldy  #0
                        	  2030: asm_do_asc_loop:
00:A4A5 B90002          	  2031:   lda  INBUF,Y
00:A4A8 C8              	  2032:   iny         ; onto next character in the string
00:A4A9 5A              	  2033:   phy
00:A4AA 20CF9E          	  2034:   jsr ass_emit
00:A4AD 7A              	  2035:   ply
                        	  2036: 
                        	  2037: asm_do_asc_next:
00:A4AE C692            	  2038:   dec token_length
00:A4B0 D0F3            	  2039:   bne asm_do_asc_loop
00:A4B2 60              	  2040:   rts
                        	  2041: 
                        	  2042: 
                        	  2043: ;
                        	  2044: ;  ASCIIZ / STRING - output a string with a null terminator
                        	  2045: ;
                        	  2046: 
                        	  2047: asm_do_string:
00:A4B3 2098A4          	  2048:   jsr asm_do_asc    ; do the string
00:A4B6 A900            	  2049:   lda #0            ; and the terminator
00:A4B8 20CF9E          	  2050:   jsr ass_emit
00:A4BB 60              	  2051:   rts
                        	  2052: 
                        	  2053: 
                        	  2054: ;
                        	  2055: ;  EQU
                        	  2056: ;
                        	  2057: ;  The label, which must be present, takes on the value of the expression
                        	  2058: ;
                        	  2059: 
                        	  2060: asm_do_equ:
00:A4BC A56B            	  2061:   lda ASS_OPERAND
00:A4BE C901            	  2062:   cmp #ASS_OPERAND_ABSOLUTE
00:A4C0 D01D            	  2063:   bne asm_do_constant_expected
00:A4C2 A583            	  2064:   lda ass_current_label
00:A4C4 0584            	  2065:   ora ass_current_label+1
00:A4C6 D005            	  2066:   bne asm_do_equ_have_label
00:A4C8 A230            	  2067:   ldx #48    ; ERROR: label required
00:A4CA 4C0D9F          	  2068:   jmp ass_error
                        	  2069: 
                        	  2070: asm_do_equ_have_label:
00:A4CD A004            	  2071:   ldy #SYMDSP
00:A4CF A573            	  2072:   lda ASS_VALUE
00:A4D1 9183            	  2073:   sta (ass_current_label),y
00:A4D3 C8              	  2074:   iny
00:A4D4 A574            	  2075:   lda ASS_VALUE+1
00:A4D6 9183            	  2076:   sta (ass_current_label),y
00:A4D8 60              	  2077:   rts
                        	  2078: 
                        	  2079: ;
                        	  2080: ;  ORG
                        	  2081: ;
                        	  2082: ;  The program counter becomes the value of the expression
                        	  2083: ;
                        	  2084: 
                        	  2085: asm_do_org:
00:A4D9 A56B            	  2086:   lda ASS_OPERAND
00:A4DB C901            	  2087:   cmp #ASS_OPERAND_ABSOLUTE
00:A4DD F005            	  2088:   beq asm_do_org_ok
                        	  2089: asm_do_constant_expected:
00:A4DF A202            	  2090:   ldx #2    ; ERROR: constant expected
00:A4E1 4C0D9F          	  2091:   jmp ass_error
                        	  2092: 
                        	  2093: asm_do_org_ok:
00:A4E4 A573            	  2094:   lda ASS_VALUE
00:A4E6 8523            	  2095:   sta PCODE
00:A4E8 A574            	  2096:   lda ASS_VALUE+1
00:A4EA 8524            	  2097:   sta PCODE+1
00:A4EC 60              	  2098:   rts
                        	  2099: 
                        	  2100: ;
                        	  2101: ;  DFB - define one byte (value being the expression)
                        	  2102: ;
                        	  2103: 
                        	  2104: asm_do_dfb:
00:A4ED A56B            	  2105:   lda ASS_OPERAND
00:A4EF C912            	  2106:   cmp #ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE  ; multiple values?
00:A4F1 F008            	  2107:   beq asm_do_dfb_multiple
00:A4F3 C901            	  2108:   cmp #ASS_OPERAND_ABSOLUTE
00:A4F5 D0E8            	  2109:   bne asm_do_constant_expected
00:A4F7 201FA5          	  2110:   jsr asm_emit_one_byte
00:A4FA 60              	  2111:   rts
                        	  2112: 
                        	  2113: ;
                        	  2114: ;  so if we got here we thought we had two values (like a BBR0 $12,foo)
                        	  2115: ;  - the first is in REMAIN and the other in VALUE
                        	  2116: ;
                        	  2117: ;  let's emit REMAIN, then VALUE, then look for other values
                        	  2118: ;
                        	  2119: asm_do_dfb_multiple:
00:A4FB A507            	  2120:   lda REMAIN+1
00:A4FD D01B            	  2121:   bne asm_do_dfb_too_big
00:A4FF A508            	  2122:   lda REMAIN+2
00:A501 D017            	  2123:   bne asm_do_dfb_too_big
00:A503 A506            	  2124:   lda REMAIN
00:A505 20CF9E          	  2125:   jsr ass_emit  ; emit REMAIN
                        	  2126: asm_do_dfb_multiple_loop:
00:A508 201FA5          	  2127:   jsr asm_emit_one_byte  ; emit VALUE
00:A50B A593            	  2128:   lda token_type
00:A50D C92C            	  2129:   cmp #','      ; another?
00:A50F D008            	  2130:   bne asm_do_dfb_multiple_done
00:A511 208CC9          	  2131:   jsr get_token
00:A514 203A9D          	  2132:   jsr ass_get_value  ; should have some sort of address now in VALUE
00:A517 80EF            	  2133:   bra asm_do_dfb_multiple_loop
                        	  2134: 
                        	  2135: asm_do_dfb_multiple_done:
00:A519 60              	  2136:   rts
                        	  2137: 
                        	  2138: 
                        	  2139: asm_do_dfb_too_big:
00:A51A A22C            	  2140:   ldx #44
00:A51C 4C0D9F          	  2141:   jmp ass_error
                        	  2142: 
                        	  2143: asm_emit_one_byte:
00:A51F A574            	  2144:   lda ASS_VALUE+1
00:A521 D0F7            	  2145:   bne asm_do_dfb_too_big
00:A523 A575            	  2146:   lda ASS_VALUE+2
00:A525 D0F3            	  2147:   bne asm_do_dfb_too_big
00:A527 A573            	  2148:   lda ASS_VALUE
00:A529 20CF9E          	  2149:   jsr ass_emit
00:A52C 60              	  2150:   rts
                        	  2151: 
                        	  2152: 
                        	  2153: ;
                        	  2154: ;  DFW - define two bytes (value being the expression)
                        	  2155: ;
                        	  2156: 
                        	  2157: asm_do_dfw:
00:A52D A56B            	  2158:   lda ASS_OPERAND
00:A52F C912            	  2159:   cmp #ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE  ; multiple values?
00:A531 F008            	  2160:   beq asm_do_dfw_multiple
00:A533 C901            	  2161:   cmp #ASS_OPERAND_ABSOLUTE
00:A535 D0A8            	  2162:   bne asm_do_constant_expected
00:A537 205BA5          	  2163:   jsr asm_emit_two_bytes
00:A53A 60              	  2164:   rts
                        	  2165: 
                        	  2166: ;
                        	  2167: ;  so if we got here we thought we had two values (like a BBR0 $12,foo)
                        	  2168: ;  - the first is in REMAIN and the other in VALUE
                        	  2169: ;
                        	  2170: ;  let's emit REMAIN, then VALUE, then look for other values
                        	  2171: ;
                        	  2172: asm_do_dfw_multiple:
00:A53B A508            	  2173:   lda REMAIN+2
00:A53D D0DB            	  2174:   bne asm_do_dfb_too_big
00:A53F A506            	  2175:   lda REMAIN
00:A541 20CF9E          	  2176:   jsr ass_emit  ; emit REMAIN
00:A544 A507            	  2177:   lda REMAIN+1
00:A546 20CF9E          	  2178:   jsr ass_emit  ; emit REMAIN+1
                        	  2179: asm_do_dfw_multiple_loop:
00:A549 205BA5          	  2180:   jsr asm_emit_two_bytes  ; emit VALUE
00:A54C A593            	  2181:   lda token_type
00:A54E C92C            	  2182:   cmp #','      ; another?
00:A550 D008            	  2183:   bne asm_do_dfw_multiple_done
00:A552 208CC9          	  2184:   jsr get_token
00:A555 203A9D          	  2185:   jsr ass_get_value  ; should have some sort of address now in VALUE
00:A558 80EF            	  2186:   bra asm_do_dfw_multiple_loop
                        	  2187: 
                        	  2188: asm_do_dfw_multiple_done:
00:A55A 60              	  2189:   rts
                        	  2190: 
                        	  2191: 
                        	  2192: asm_emit_two_bytes:
00:A55B A575            	  2193:   lda ASS_VALUE+2
00:A55D D0BB            	  2194:   bne asm_do_dfb_too_big
00:A55F A573            	  2195:   lda ASS_VALUE
00:A561 20CF9E          	  2196:   jsr ass_emit
00:A564 A574            	  2197:   lda ASS_VALUE+1
00:A566 20CF9E          	  2198:   jsr ass_emit
00:A569 60              	  2199:   rts
                        	  2200: 
                        	  2201: 
                        	  2202: 
                        	  2203: ;
                        	  2204: ;  BLK - zero fill <expression> bytes (eg. BLK 5 output 5 zeroes)
                        	  2205: ;
                        	  2206: 
                        	  2207: asm_do_blk:
00:A56A A56B            	  2208:   lda ASS_OPERAND
00:A56C C901            	  2209:   cmp #ASS_OPERAND_ABSOLUTE
00:A56E D030            	  2210:   bne asm_do_constant_expectedJ2
00:A570 A575            	  2211:   lda ASS_VALUE+2
00:A572 D0A6            	  2212:   bne asm_do_dfb_too_big
                        	  2213: ;
                        	  2214: ; handle (obscure) case of them defining zero bytes
                        	  2215: ;
00:A574 A573            	  2216:   lda ASS_VALUE
00:A576 0574            	  2217:   ora ASS_VALUE+1
00:A578 F00D            	  2218:   beq asm_do_blk_done
                        	  2219: asm_do_blk_loop:
                        	  2220: ;
                        	  2221: ;  emit one zero
                        	  2222: ;
00:A57A A900            	  2223:   lda #0
00:A57C 20CF9E          	  2224:   jsr ass_emit
00:A57F C673            	  2225:   dec ASS_VALUE
00:A581 D0F7            	  2226:   bne asm_do_blk_loop
00:A583 C674            	  2227:   dec ASS_VALUE+1
00:A585 10F3            	  2228:   bpl asm_do_blk_loop
                        	  2229: asm_do_blk_done:
00:A587 60              	  2230:   rts
                        	  2231: 
                        	  2232: ;
                        	  2233: ;  RESERVE - reserve <expression> bytes without writing to them
                        	  2234: ;   useful for leaving a gap (eg. for zero-page variables)
                        	  2235: ;
                        	  2236: 
                        	  2237: asm_do_reserve:
00:A588 A56B            	  2238:   lda ASS_OPERAND
00:A58A C901            	  2239:   cmp #ASS_OPERAND_ABSOLUTE
00:A58C D012            	  2240:   bne asm_do_constant_expectedJ2
00:A58E A575            	  2241:   lda ASS_VALUE+2
00:A590 D088            	  2242:   bne asm_do_dfb_too_big
00:A592 18              	  2243:   clc
00:A593 A523            	  2244:   lda PCODE
00:A595 6573            	  2245:   adc ASS_VALUE
00:A597 8523            	  2246:   sta PCODE
00:A599 A524            	  2247:   lda PCODE+1
00:A59B 6574            	  2248:   adc ASS_VALUE+1
00:A59D 8524            	  2249:   sta PCODE+1
00:A59F 60              	  2250:   rts
                        	  2251: 
00:A5A0 4CDFA4          	  2252: asm_do_constant_expectedJ2 jmp asm_do_constant_expected
                        	  2253: 
                        	  2254: ;
                        	  2255: ;  SYM <address> symbol table relocation
                        	  2256: ;
                        	  2257: asm_do_sym:
00:A5A3 A56B            	  2258:   lda ASS_OPERAND
00:A5A5 C901            	  2259:   cmp #ASS_OPERAND_ABSOLUTE
00:A5A7 D0F7            	  2260:   bne asm_do_constant_expectedJ2
                        	  2261: ;
                        	  2262: ;  only relocate symbol table on the first pass
                        	  2263: ;
00:A5A9 A576            	  2264:   lda ASS_PASS
00:A5AB D00F            	  2265:   bne asm_do_sym_done
                        	  2266: 
00:A5AD A573            	  2267:   lda  ASS_VALUE
00:A5AF 8531            	  2268:   sta  ENDSYM
00:A5B1 852F            	  2269:   sta  STARTSYM
00:A5B3 A574            	  2270:   lda  ASS_VALUE+1
00:A5B5 8532            	  2271:   sta  ENDSYM+1        ; store symbol table address
00:A5B7 8530            	  2272:   sta  STARTSYM+1
                        	  2273: ;
                        	  2274: ;  put our library functions back into the symbol table
                        	  2275: ;
00:A5B9 2089AA          	  2276:   jsr  add_assembler_library_functions  ; add our inbuilt functions to the symbol table
                        	  2277: 
                        	  2278: asm_do_sym_done:
00:A5BC 60              	  2279:   rts
                        	  2280: ;
                        	  2281: 
                        	  2282: 
00:A5BD 41646472204E616D	  2283: info_message asciiz "Addr Name\n"
00:A5C5 650A
00:A5C7 00
                        	  2284: 
                        	  2285: list_symbols  = *
00:A5C8 A9BD            	  2286:          lda #<info_message
00:A5CA A2A5            	  2287:          ldx #>info_message
00:A5CC 202682          	  2288:          jsr print
                        	  2289: 
00:A5CF A532            	  2290:          lda  ENDSYM+1    ; get the end of the symbol table
00:A5D1 8541            	  2291:          sta  SYMITM+1    ; make it the current symbol
00:A5D3 A531            	  2292:          lda  ENDSYM
00:A5D5 800B            	  2293:          bra  list_symbols_check
                        	  2294: 
                        	  2295: list_symbols_next =  *
00:A5D7 A000            	  2296:          ldy  #SYMPRV
00:A5D9 B140            	  2297:          lda  (SYMITM),Y
00:A5DB AA              	  2298:          tax
00:A5DC C8              	  2299:          iny
00:A5DD B140            	  2300:          lda  (SYMITM),Y
00:A5DF 8541            	  2301:          sta  SYMITM+1   ; previous link
00:A5E1 8A              	  2302:          txa
                        	  2303: ;
                        	  2304: ;  go to the previous symbol table item
                        	  2305: ;
                        	  2306: list_symbols_check     =  *
00:A5E2 8540            	  2307:          sta  SYMITM
00:A5E4 C52F            	  2308:          cmp  STARTSYM
00:A5E6 D009            	  2309:          bne  list_symbols_line
00:A5E8 A541            	  2310:          lda  SYMITM+1
00:A5EA C530            	  2311:          cmp  STARTSYM+1
00:A5EC D003            	  2312:          bne  list_symbols_line       ; more to go
00:A5EE 4C1CA6          	  2313:          jmp  list_symbols_done       ; finished if symitm and symitm+1 are both zero
                        	  2314: 
                        	  2315: list_symbols_line = *
00:A5F1 A004            	  2316:          ldy  #SYMDSP
00:A5F3 C8              	  2317:          iny
00:A5F4 B140            	  2318:          lda  (SYMITM),Y  ; displacement
00:A5F6 200693          	  2319:          jsr  PRBYTE
00:A5F9 88              	  2320:          dey
00:A5FA B140            	  2321:          lda  (SYMITM),Y  ; displacement
00:A5FC 200693          	  2322:          jsr  PRBYTE
00:A5FF A920            	  2323:          lda  #' '
00:A601 20EE92          	  2324:          jsr  PRCHAR
00:A604 A009            	  2325:          ldy  #SYMLEN
00:A606 B140            	  2326:          lda  (SYMITM),Y  ; length
00:A608 AA              	  2327:          tax
00:A609 A00A            	  2328:          ldy  #SYMNAM
                        	  2329: list_symbols_name = *
00:A60B B140            	  2330:          lda  (SYMITM),Y  ; name
00:A60D 5A              	  2331:          phy
00:A60E 20EE92          	  2332:          jsr  PRCHAR
00:A611 7A              	  2333:          ply
00:A612 C8              	  2334:          iny
00:A613 CA              	  2335:          dex
00:A614 D0F5            	  2336:          bne list_symbols_name
00:A616 209192          	  2337:          jsr CROUT
00:A619 4CD7A5          	  2338:          jmp list_symbols_next
                        	  2339: 
                        	  2340: list_symbols_done = *
00:A61C 60              	  2341:          rts
                        	  2342: 
                        	  2343: assembler_library_functions_table:
                        	  2344: ;
                        	  2345: ;  put them in reverse alphabetic order so they come out in alphabetic
                        	  2346: ;  order if you request a symbols list
                        	  2347: ;
                        	  2348:   makeAsmLibraryFunction "write_to_serial",      write_to_serial
00:A61D 77726974655F746F	     1M      asciiz   "write_to_serial"
00:A625 5F73657269616C
00:A62C 00
00:A62D F8C8            	     2M      word     write_to_serial
                        	  2349:   makeAsmLibraryFunction "write_to_lcd",         write_to_lcd
00:A62F 77726974655F746F	     1M      asciiz   "write_to_lcd"
00:A637 5F6C6364
00:A63B 00
00:A63C 03C9            	     2M      word     write_to_lcd
                        	  2350:   makeAsmLibraryFunction "write_function",       write_function
00:A63E 77726974655F6675	     1M      asciiz   "write_function"
00:A646 6E6374696F6E
00:A64C 00
00:A64D 1700            	     2M      word     write_function
                        	  2351:   makeAsmLibraryFunction "write_char",           write_char
00:A64F 77726974655F6368	     1M      asciiz   "write_char"
00:A657 6172
00:A659 00
00:A65A 56C9            	     2M      word     write_char
                        	  2352:   makeAsmLibraryFunction "value",                VALUE
00:A65C 76616C7565      	     1M      asciiz   "value"
00:A661 00
00:A662 0000            	     2M      word     VALUE
                        	  2353:   makeAsmLibraryFunction "value2",               VALUE2
00:A664 76616C756532    	     1M      asciiz   "value2"
00:A66A 00
00:A66B 0300            	     2M      word     VALUE2
                        	  2354:   makeAsmLibraryFunction "typing_latency",       typing_latency
00:A66D 747970696E675F6C	     1M      asciiz   "typing_latency"
00:A675 6174656E6379
00:A67B 00
00:A67C 0D00            	     2M      word     typing_latency
                        	  2355:   makeAsmLibraryFunction "tknjmp",               TKNJMP
00:A67E 746B6E6A6D70    	     1M      asciiz   "tknjmp"
00:A684 00
00:A685 FB8F            	     2M      word     TKNJMP
                        	  2356:   makeAsmLibraryFunction "reset",                START
00:A687 7265736574      	     1M      asciiz   "reset"
00:A68C 00
00:A68D 28D1            	     2M      word     START
                        	  2357:   makeAsmLibraryFunction "srce",                 SRCE
00:A68F 73726365        	     1M      asciiz   "srce"
00:A693 00
00:A694 0000            	     2M      word     SRCE
                        	  2358:   makeAsmLibraryFunction "serial_print_message", serial_print_message
00:A696 73657269616C5F70	     1M      asciiz   "serial_print_message"
00:A69E 72696E745F6D6573
00:A6A6 73616765
00:A6AA 00
00:A6AB 7BC9            	     2M      word     serial_print_message
                        	  2359:   makeAsmLibraryFunction "serial_available",     serial_available
00:A6AD 73657269616C5F61	     1M      asciiz   "serial_available"
00:A6B5 7661696C61626C65
00:A6BD 00
00:A6BE 1FC9            	     2M      word     serial_available
                        	  2360:   makeAsmLibraryFunction "nmi",                  RESTART
00:A6C0 6E6D69          	     1M      asciiz   "nmi"
00:A6C3 00
00:A6C4 44D1            	     2M      word     RESTART
                        	  2361:   makeAsmLibraryFunction "remain",               REMAIN
00:A6C6 72656D61696E    	     1M      asciiz   "remain"
00:A6CC 00
00:A6CD 0600            	     2M      word     REMAIN
                        	  2362:   makeAsmLibraryFunction "random",               random
00:A6CF 72616E646F6D    	     1M      asciiz   "random"
00:A6D5 00
00:A6D6 0900            	     2M      word     random
                        	  2363:   makeAsmLibraryFunction "putsp",                PUTSP
00:A6D8 7075747370      	     1M      asciiz   "putsp"
00:A6DD 00
00:A6DE 1C93            	     2M      word     PUTSP
                        	  2364:   makeAsmLibraryFunction "print",                print
00:A6E0 7072696E74      	     1M      asciiz   "print"
00:A6E5 00
00:A6E6 2682            	     2M      word     print
                        	  2365:   makeAsmLibraryFunction "prchar",               PRCHAR
00:A6E8 707263686172    	     1M      asciiz   "prchar"
00:A6EE 00
00:A6EF EE92            	     2M      word     PRCHAR
                        	  2366:   makeAsmLibraryFunction "prbyte",               PRBYTE
00:A6F1 707262797465    	     1M      asciiz   "prbyte"
00:A6F7 00
00:A6F8 0693            	     2M      word     PRBYTE
                        	  2367:   makeAsmLibraryFunction "pinmode",              pinmode
00:A6FA 70696E6D6F6465  	     1M      asciiz   "pinmode"
00:A701 00
00:A702 7DC8            	     2M      word     pinmode
                        	  2368:   makeAsmLibraryFunction "lcd_wait",             lcd_wait
00:A704 6C63645F77616974	     1M      asciiz   "lcd_wait"
00:A70C 00
00:A70D 57B8            	     2M      word     lcd_wait
                        	  2369:   makeAsmLibraryFunction "lcd_second_line",      lcd_second_line
00:A70F 6C63645F7365636F	     1M      asciiz   "lcd_second_line"
00:A717 6E645F6C696E65
00:A71E 00
00:A71F EEB8            	     2M      word     lcd_second_line
                        	  2370:   makeAsmLibraryFunction "lcd_print_message",    lcd_print_message
00:A721 6C63645F7072696E	     1M      asciiz   "lcd_print_message"
00:A729 745F6D6573736167
00:A731 65
00:A732 00
00:A733 FEB8            	     2M      word     lcd_print_message
                        	  2371:   makeAsmLibraryFunction "lcd_print_char",       lcd_print_char
00:A735 6C63645F7072696E	     1M      asciiz   "lcd_print_char"
00:A73D 745F63686172
00:A743 00
00:A744 B4B8            	     2M      word     lcd_print_char
                        	  2372:   makeAsmLibraryFunction "lcd_instruction",      lcd_instruction
00:A746 6C63645F696E7374	     1M      asciiz   "lcd_instruction"
00:A74E 72756374696F6E
00:A755 00
00:A756 92B8            	     2M      word     lcd_instruction
                        	  2373:   makeAsmLibraryFunction "lcd_home",             lcd_home
00:A758 6C63645F686F6D65	     1M      asciiz   "lcd_home"
00:A760 00
00:A761 F6B8            	     2M      word     lcd_home
                        	  2374:   makeAsmLibraryFunction "lcd_get_address",      lcd_get_address
00:A763 6C63645F6765745F	     1M      asciiz   "lcd_get_address"
00:A76B 61646472657373
00:A772 00
00:A773 72B8            	     2M      word     lcd_get_address
                        	  2375:   makeAsmLibraryFunction "lcd_clear_display",    lcd_clear_display
00:A775 6C63645F636C6561	     1M      asciiz   "lcd_clear_display"
00:A77D 725F646973706C61
00:A785 79
00:A786 00
00:A787 E6B8            	     2M      word     lcd_clear_display
                        	  2376:   makeAsmLibraryFunction "isxdigit",             isxdigit
00:A789 6973786469676974	     1M      asciiz   "isxdigit"
00:A791 00
00:A792 3E81            	     2M      word     isxdigit
                        	  2377:   makeAsmLibraryFunction "isupper",              isupper
00:A794 69737570706572  	     1M      asciiz   "isupper"
00:A79B 00
00:A79C 0E81            	     2M      word     isupper
                        	  2378:   makeAsmLibraryFunction "isspace",              isspace
00:A79E 69737370616365  	     1M      asciiz   "isspace"
00:A7A5 00
00:A7A6 4A81            	     2M      word     isspace
                        	  2379:   makeAsmLibraryFunction "islower",              islower
00:A7A8 69736C6F776572  	     1M      asciiz   "islower"
00:A7AF 00
00:A7B0 1A81            	     2M      word     islower
                        	  2380:   makeAsmLibraryFunction "isdigit",              isdigit
00:A7B2 69736469676974  	     1M      asciiz   "isdigit"
00:A7B9 00
00:A7BA 3281            	     2M      word     isdigit
                        	  2381:   makeAsmLibraryFunction "iscntrl",              iscntrl
00:A7BC 6973636E74726C  	     1M      asciiz   "iscntrl"
00:A7C3 00
00:A7C4 5681            	     2M      word     iscntrl
                        	  2382:   makeAsmLibraryFunction "isalpha",              isalpha
00:A7C6 6973616C706861  	     1M      asciiz   "isalpha"
00:A7CD 00
00:A7CE 2681            	     2M      word     isalpha
                        	  2383:   makeAsmLibraryFunction "isalnum",              isalnum
00:A7D0 6973616C6E756D  	     1M      asciiz   "isalnum"
00:A7D7 00
00:A7D8 6281            	     2M      word     isalnum
                        	  2384:   makeAsmLibraryFunction "inbuf",                INBUF
00:A7DA 696E627566      	     1M      asciiz   "inbuf"
00:A7DF 00
00:A7E0 0002            	     2M      word     INBUF
                        	  2385:   makeAsmLibraryFunction "i2c_send_message",     i2c_send_message
00:A7E2 6932635F73656E64	     1M      asciiz   "i2c_send_message"
00:A7EA 5F6D657373616765
00:A7F2 00
00:A7F3 B3D0            	     2M      word     i2c_send_message
                        	  2386:   makeAsmLibraryFunction "i2c_receive_message",  i2c_receive_message
00:A7F5 6932635F72656365	     1M      asciiz   "i2c_receive_message"
00:A7FD 6976655F6D657373
00:A805 616765
00:A808 00
00:A809 DCD0            	     2M      word     i2c_receive_message
                        	  2387:   makeAsmLibraryFunction "i2c_init",             i2c_init
00:A80B 6932635F696E6974	     1M      asciiz   "i2c_init"
00:A813 00
00:A814 ADCF            	     2M      word     i2c_init
                        	  2388:   makeAsmLibraryFunction "hardware_init",        hardware_init
00:A816 6861726477617265	     1M      asciiz   "hardware_init"
00:A81E 5F696E6974
00:A823 00
00:A824 25C9            	     2M      word     hardware_init
                        	  2389:   makeAsmLibraryFunction "getin",                GETIN
00:A826 676574696E      	     1M      asciiz   "getin"
00:A82B 00
00:A82C 0EC9            	     2M      word     GETIN
                        	  2390:   makeAsmLibraryFunction "gen_random",           gen_random
00:A82E 67656E5F72616E64	     1M      asciiz   "gen_random"
00:A836 6F6D
00:A838 00
00:A839 4390            	     2M      word     gen_random
                        	  2391:   makeAsmLibraryFunction "exp_unary_minus",      exp_unary_minus
00:A83B 6578705F756E6172	     1M      asciiz   "exp_unary_minus"
00:A843 795F6D696E7573
00:A84A 00
00:A84B 1BAC            	     2M      word     exp_unary_minus
                        	  2392:   makeAsmLibraryFunction "exp_true",             exp_true
00:A84D 6578705F74727565	     1M      asciiz   "exp_true"
00:A855 00
00:A856 FEAA            	     2M      word     exp_true
                        	  2393:   makeAsmLibraryFunction "exp_subtract",         exp_subtract
00:A858 6578705F73756274	     1M      asciiz   "exp_subtract"
00:A860 72616374
00:A864 00
00:A865 E8AA            	     2M      word     exp_subtract
                        	  2394:   makeAsmLibraryFunction "exp_shift_right",      exp_shift_right
00:A867 6578705F73686966	     1M      asciiz   "exp_shift_right"
00:A86F 745F7269676874
00:A876 00
00:A877 E1AB            	     2M      word     exp_shift_right
                        	  2395:   makeAsmLibraryFunction "exp_shift_left",       exp_shift_left
00:A879 6578705F73686966	     1M      asciiz   "exp_shift_left"
00:A881 745F6C656674
00:A887 00
00:A888 C8AB            	     2M      word     exp_shift_left
                        	  2396:   makeAsmLibraryFunction "exp_not",              exp_not
00:A88A 6578705F6E6F74  	     1M      asciiz   "exp_not"
00:A891 00
00:A892 0DAC            	     2M      word     exp_not
                        	  2397:   makeAsmLibraryFunction "exp_neq",              exp_neq
00:A894 6578705F6E6571  	     1M      asciiz   "exp_neq"
00:A89B 00
00:A89C 22AB            	     2M      word     exp_neq
                        	  2398:   makeAsmLibraryFunction "exp_negate",           exp_negate
00:A89E 6578705F6E656761	     1M      asciiz   "exp_negate"
00:A8A6 7465
00:A8A8 00
00:A8A9 FAAB            	     2M      word     exp_negate
                        	  2399:   makeAsmLibraryFunction "exp_multiply",         exp_multiply
00:A8AB 6578705F6D756C74	     1M      asciiz   "exp_multiply"
00:A8B3 69706C79
00:A8B7 00
00:A8B8 A2AC            	     2M      word     exp_multiply
                        	  2400:   makeAsmLibraryFunction "exp_modulo",           exp_modulo
00:A8BA 6578705F6D6F6475	     1M      asciiz   "exp_modulo"
00:A8C2 6C6F
00:A8C4 00
00:A8C5 3BAD            	     2M      word     exp_modulo
                        	  2401:   makeAsmLibraryFunction "exp_low_byte",         exp_low_byte
00:A8C7 6578705F6C6F775F	     1M      asciiz   "exp_low_byte"
00:A8CF 62797465
00:A8D3 00
00:A8D4 2FAC            	     2M      word     exp_low_byte
                        	  2402:   makeAsmLibraryFunction "exp_logical_or",       exp_logical_or
00:A8D6 6578705F6C6F6769	     1M      asciiz   "exp_logical_or"
00:A8DE 63616C5F6F72
00:A8E4 00
00:A8E5 A7AB            	     2M      word     exp_logical_or
                        	  2403:   makeAsmLibraryFunction "exp_logical_and",      exp_logical_and
00:A8E7 6578705F6C6F6769	     1M      asciiz   "exp_logical_and"
00:A8EF 63616C5F616E64
00:A8F6 00
00:A8F7 B6AB            	     2M      word     exp_logical_and
                        	  2404:   makeAsmLibraryFunction "exp_less_than",        exp_less_than
00:A8F9 6578705F6C657373	     1M      asciiz   "exp_less_than"
00:A901 5F7468616E
00:A906 00
00:A907 36AB            	     2M      word     exp_less_than
                        	  2405:   makeAsmLibraryFunction "exp_leq",              exp_leq
00:A909 6578705F6C6571  	     1M      asciiz   "exp_leq"
00:A910 00
00:A911 4CAB            	     2M      word     exp_leq
                        	  2406:   makeAsmLibraryFunction "exp_high_byte",        exp_high_byte
00:A913 6578705F68696768	     1M      asciiz   "exp_high_byte"
00:A91B 5F62797465
00:A920 00
00:A921 34AC            	     2M      word     exp_high_byte
                        	  2407:   makeAsmLibraryFunction "exp_greater_than",     exp_greater_than
00:A923 6578705F67726561	     1M      asciiz   "exp_greater_than"
00:A92B 7465725F7468616E
00:A933 00
00:A934 3DAB            	     2M      word     exp_greater_than
                        	  2408:   makeAsmLibraryFunction "exp_geq",              exp_geq
00:A936 6578705F676571  	     1M      asciiz   "exp_geq"
00:A93D 00
00:A93E 5BAB            	     2M      word     exp_geq
                        	  2409:   makeAsmLibraryFunction "exp_false",            exp_false
00:A940 6578705F66616C73	     1M      asciiz   "exp_false"
00:A948 65
00:A949 00
00:A94A 07AB            	     2M      word     exp_false
                        	  2410:   makeAsmLibraryFunction "exp_eql",              exp_eql
00:A94C 6578705F65716C  	     1M      asciiz   "exp_eql"
00:A953 00
00:A954 0EAB            	     2M      word     exp_eql
                        	  2411:   makeAsmLibraryFunction "exp_divide",           exp_divide
00:A956 6578705F64697669	     1M      asciiz   "exp_divide"
00:A95E 6465
00:A960 00
00:A961 DBAC            	     2M      word     exp_divide
                        	  2412:   makeAsmLibraryFunction "exp_bitwise_xor",      exp_bitwise_xor
00:A963 6578705F62697477	     1M      asciiz   "exp_bitwise_xor"
00:A96B 6973655F786F72
00:A972 00
00:A973 8CAB            	     2M      word     exp_bitwise_xor
                        	  2413:   makeAsmLibraryFunction "exp_bitwise_or",       exp_bitwise_or
00:A975 6578705F62697477	     1M      asciiz   "exp_bitwise_or"
00:A97D 6973655F6F72
00:A983 00
00:A984 62AB            	     2M      word     exp_bitwise_or
                        	  2414:   makeAsmLibraryFunction "exp_bitwise_and",      exp_bitwise_and
00:A986 6578705F62697477	     1M      asciiz   "exp_bitwise_and"
00:A98E 6973655F616E64
00:A995 00
00:A996 77AB            	     2M      word     exp_bitwise_and
                        	  2415:   makeAsmLibraryFunction "exp_add",              exp_add
00:A998 6578705F616464  	     1M      asciiz   "exp_add"
00:A99F 00
00:A9A0 D4AA            	     2M      word     exp_add
                        	  2416:   makeAsmLibraryFunction "exp_abs_val",          exp_abs_val
00:A9A2 6578705F6162735F	     1M      asciiz   "exp_abs_val"
00:A9AA 76616C
00:A9AD 00
00:A9AE 3DAC            	     2M      word     exp_abs_val
                        	  2417:   makeAsmLibraryFunction "display_in_decimal",   display_in_decimal
00:A9B0 646973706C61795F	     1M      asciiz   "display_in_decimal"
00:A9B8 696E5F646563696D
00:A9C0 616C
00:A9C2 00
00:A9C3 BB91            	     2M      word     display_in_decimal
                        	  2418:   makeAsmLibraryFunction "digitalwrite",         digitalwrite
00:A9C5 6469676974616C77	     1M      asciiz   "digitalwrite"
00:A9CD 72697465
00:A9D1 00
00:A9D2 ACC8            	     2M      word     digitalwrite
                        	  2419:   makeAsmLibraryFunction "digitalread",          digitalread
00:A9D4 6469676974616C72	     1M      asciiz   "digitalread"
00:A9DC 656164
00:A9DF 00
00:A9E0 DBC8            	     2M      word     digitalread
                        	  2420:   makeAsmLibraryFunction "dest",                 DEST
00:A9E2 64657374        	     1M      asciiz   "dest"
00:A9E6 00
00:A9E7 0300            	     2M      word     DEST
                        	  2421:   makeAsmLibraryFunction "delay",                delay
00:A9E9 64656C6179      	     1M      asciiz   "delay"
00:A9EE 00
00:A9EF 3E91            	     2M      word     delay
                        	  2422:   makeAsmLibraryFunction "delay_1ms",            delay_1ms
00:A9F1 64656C61795F316D	     1M      asciiz   "delay_1ms"
00:A9F9 73
00:A9FA 00
00:A9FB 3491            	     2M      word     delay_1ms
                        	  2423:   makeAsmLibraryFunction "crout",                CROUT
00:A9FD 63726F7574      	     1M      asciiz   "crout"
00:AA02 00
00:AA03 9192            	     2M      word     CROUT
                        	  2424:   makeAsmLibraryFunction "crc_val",              crc_val
00:AA05 6372635F76616C  	     1M      asciiz   "crc_val"
00:AA0C 00
00:AA0D 0600            	     2M      word     crc_val
                        	  2425:   makeAsmLibraryFunction "crc_num",              crc_num
00:AA0F 6372635F6E756D  	     1M      asciiz   "crc_num"
00:AA16 00
00:AA17 0300            	     2M      word     crc_num
                        	  2426:   makeAsmLibraryFunction "crc_byte",             crc_byte
00:AA19 6372635F62797465	     1M      asciiz   "crc_byte"
00:AA21 00
00:AA22 8E90            	     2M      word     crc_byte
                        	  2427:   makeAsmLibraryFunction "crc_addr",             crc_addr
00:AA24 6372635F61646472	     1M      asciiz   "crc_addr"
00:AA2C 00
00:AA2D 0000            	     2M      word     crc_addr
                        	  2428:   makeAsmLibraryFunction "crc16",                crc16
00:AA2F 6372633136      	     1M      asciiz   "crc16"
00:AA34 00
00:AA35 6690            	     2M      word     crc16
                        	  2429:   makeAsmLibraryFunction "cout",                 COUT
00:AA37 636F7574        	     1M      asciiz   "cout"
00:AA3B 00
00:AA3C 1894            	     2M      word     COUT
                        	  2430:   makeAsmLibraryFunction "comstl",               COMSTL
00:AA3E 636F6D73746C    	     1M      asciiz   "comstl"
00:AA44 00
00:AA45 9692            	     2M      word     COMSTL
                        	  2431:   makeAsmLibraryFunction "call_y",               call_y
00:AA47 63616C6C5F79    	     1M      asciiz   "call_y"
00:AA4D 00
00:AA4E 1200            	     2M      word     call_y
                        	  2432:   makeAsmLibraryFunction "call_x",               call_x
00:AA50 63616C6C5F78    	     1M      asciiz   "call_x"
00:AA56 00
00:AA57 1100            	     2M      word     call_x
                        	  2433:   makeAsmLibraryFunction "call_s",               call_s
00:AA59 63616C6C5F73    	     1M      asciiz   "call_s"
00:AA5F 00
00:AA60 1400            	     2M      word     call_s
                        	  2434:   makeAsmLibraryFunction "call_p",               call_p
00:AA62 63616C6C5F70    	     1M      asciiz   "call_p"
00:AA68 00
00:AA69 1300            	     2M      word     call_p
                        	  2435:   makeAsmLibraryFunction "call_a",               call_a
00:AA6B 63616C6C5F61    	     1M      asciiz   "call_a"
00:AA71 00
00:AA72 1000            	     2M      word     call_a
                        	  2436:   makeAsmLibraryFunction "binary_to_decimal",    binary_to_decimal
00:AA74 62696E6172795F74	     1M      asciiz   "binary_to_decimal"
00:AA7C 6F5F646563696D61
00:AA84 6C
00:AA85 00
00:AA86 E491            	     2M      word     binary_to_decimal
                        	  2437: 
00:AA88 00              	  2438:   dfb 0   ; end of table
                        	  2439: 
                        	  2440: 
                        	  2441: add_assembler_library_functions:
00:AA89 A91D            	  2442:   lda #<assembler_library_functions_table
00:AA8B 8500            	  2443:   sta REG
00:AA8D A9A6            	  2444:   lda #>assembler_library_functions_table
00:AA8F 8501            	  2445:   sta REG+1
                        	  2446: add_assembler_library_functions_loop:
00:AA91 A000            	  2447:   ldy #0
00:AA93 B100            	  2448:   lda (REG),Y
00:AA95 F03C            	  2449:   beq add_assembler_library_functions_done
00:AA97 A500            	  2450:   lda REG
00:AA99 8590            	  2451:   sta token_address
00:AA9B A501            	  2452:   lda REG+1
00:AA9D 8591            	  2453:   sta token_address+1
00:AA9F 6492            	  2454:   stz token_length
                        	  2455: ;
                        	  2456: ;  find name length
                        	  2457: ;
                        	  2458: add_assembler_library_functions_name_loop
00:AAA1 C8              	  2459:   iny
00:AAA2 E692            	  2460:   inc token_length
00:AAA4 B100            	  2461:   lda (REG),Y
00:AAA6 D0F9            	  2462:   bne add_assembler_library_functions_name_loop
00:AAA8 5A              	  2463:   phy
00:AAA9 2035BA          	  2464:   jsr CHKDUP
00:AAAC A943            	  2465:   lda #SYMBOL_CONSTANT  ; add the symbol as a constant for now
00:AAAE 208EB9          	  2466:   jsr ADDSYM
00:AAB1 7A              	  2467:   ply
                        	  2468: 
00:AAB2 C8              	  2469:   iny             ; get next byte
00:AAB3 B100            	  2470:   lda (REG),Y     ; get function address low-byte
00:AAB5 5A              	  2471:   phy
00:AAB6 A004            	  2472:   ldy #SYMDSP
00:AAB8 9140            	  2473:   sta (SYMITM),Y  ; save function address low-byte
00:AABA 7A              	  2474:   ply
                        	  2475: 
00:AABB C8              	  2476:   iny             ; get next byte
00:AABC B100            	  2477:   lda (REG),Y     ; get function address high-byte
00:AABE 5A              	  2478:   phy
00:AABF A005            	  2479:   ldy #SYMDSP+1
00:AAC1 9140            	  2480:   sta (SYMITM),Y  ; save function address high-byte
00:AAC3 7A              	  2481:   ply
                        	  2482: 
00:AAC4 C8              	  2483:   iny         ; get past that last byte
00:AAC5 98              	  2484:   tya         ; move REG onto next entry
00:AAC6 18              	  2485:   clc
00:AAC7 6500            	  2486:   adc REG
00:AAC9 8500            	  2487:   sta REG
00:AACB A900            	  2488:   lda #0
00:AACD 6501            	  2489:   adc REG+1
00:AACF 8501            	  2490:   sta REG+1
00:AAD1 80BE            	  2491:   bra add_assembler_library_functions_loop
                        	  2492: 
                        	  2493: add_assembler_library_functions_done:
00:AAD3 60              	  2494:   rts
                        	  2495: 

Source: "gpascal.asm"
                        	   179:   .include "math.inc"

Source: "math.inc"
                        	     1: ;--------------------------------------------------
                        	     2: ; Maths routines. 3-byte operations on VALUE and VALUE2
                        	     3: ;
                        	     4: ;--------------------------------------------------
                        	     5: exp_add:
00:AAD4 18              	     6:   clc
00:AAD5 A500            	     7:   lda VALUE
00:AAD7 6503            	     8:   adc VALUE2
00:AAD9 8500            	     9:   sta VALUE
00:AADB A501            	    10:   lda VALUE+1
00:AADD 6504            	    11:   adc VALUE2+1
00:AADF 8501            	    12:   sta VALUE+1
00:AAE1 A502            	    13:   lda VALUE+2
00:AAE3 6505            	    14:   adc VALUE2+2
00:AAE5 8502            	    15:   sta VALUE+2
00:AAE7 60              	    16:   rts
                        	    17: 
                        	    18: ;
                        	    19: ;  subtract VALUE2 from VALUE, store in VALUE, also set the sign bit
                        	    20: ;   and put the low order two bytes in X and Y
                        	    21: ;
                        	    22: exp_subtract:
00:AAE8 38              	    23:   sec
00:AAE9 A500            	    24:   lda VALUE
00:AAEB E503            	    25:   sbc VALUE2
00:AAED 8500            	    26:   sta VALUE
00:AAEF A8              	    27:   tay
00:AAF0 A501            	    28:   lda VALUE+1
00:AAF2 E504            	    29:   sbc VALUE2+1
00:AAF4 AA              	    30:   tax
00:AAF5 8501            	    31:   sta VALUE+1
00:AAF7 A502            	    32:   lda VALUE+2
00:AAF9 E505            	    33:   sbc VALUE2+2
00:AAFB 8502            	    34:   sta VALUE+2
00:AAFD 60              	    35:   rts
                        	    36: 
                        	    37: exp_true:
00:AAFE A901            	    38:   lda #1
00:AB00 8500            	    39:   sta VALUE
00:AB02 6401            	    40:   stz VALUE+1
00:AB04 6402            	    41:   stz VALUE+2
00:AB06 60              	    42:   rts
                        	    43: 
                        	    44: exp_false:
00:AB07 6400            	    45:   stz VALUE
00:AB09 6401            	    46:   stz VALUE+1
00:AB0B 6402            	    47:   stz VALUE+2
00:AB0D 60              	    48:   rts
                        	    49: 
                        	    50: exp_eql:
00:AB0E A500            	    51:   lda VALUE
00:AB10 C503            	    52:   cmp VALUE2
00:AB12 D0F3            	    53:   bne exp_false
00:AB14 A501            	    54:   lda VALUE+1
00:AB16 C504            	    55:   cmp VALUE2+1
00:AB18 D0ED            	    56:   bne exp_false
00:AB1A A502            	    57:   lda VALUE+2
00:AB1C C505            	    58:   cmp VALUE2+2
00:AB1E D0E7            	    59:   bne exp_false
00:AB20 80DC            	    60:   bra exp_true
                        	    61: 
                        	    62: exp_neq:
00:AB22 A500            	    63:   lda VALUE
00:AB24 C503            	    64:   cmp VALUE2
00:AB26 D0D6            	    65:   bne exp_true
00:AB28 A501            	    66:   lda VALUE+1
00:AB2A C504            	    67:   cmp VALUE2+1
00:AB2C D0D0            	    68:   bne exp_true
00:AB2E A502            	    69:   lda VALUE+2
00:AB30 C505            	    70:   cmp VALUE2+2
00:AB32 D0CA            	    71:   bne exp_true
00:AB34 80D1            	    72:   bra exp_false
                        	    73: 
                        	    74: exp_less_than:
00:AB36 20E8AA          	    75:   jsr exp_subtract
00:AB39 30C3            	    76:   bmi exp_true
00:AB3B 10CA            	    77:   bpl exp_false
                        	    78: 
                        	    79: exp_greater_than:
00:AB3D 20E8AA          	    80:   jsr exp_subtract
00:AB40 30C5            	    81:   bmi exp_false
00:AB42 D0BA            	    82:   bne exp_true
00:AB44 98              	    83:   tya
00:AB45 D0B7            	    84:   bne exp_true
00:AB47 8A              	    85:   txa
00:AB48 D0B4            	    86:   bne exp_true
00:AB4A 10BB            	    87:   bpl exp_false
                        	    88: 
                        	    89: exp_leq:
00:AB4C 20E8AA          	    90:   jsr exp_subtract
00:AB4F 30AD            	    91:   bmi exp_true
00:AB51 D0B4            	    92:   bne exp_false
00:AB53 98              	    93:   tya
00:AB54 D0B1            	    94:   bne exp_false
00:AB56 8A              	    95:   txa
00:AB57 D0AE            	    96:   bne exp_false
00:AB59 10A3            	    97:   bpl exp_true
                        	    98: 
                        	    99: exp_geq:
00:AB5B 20E8AA          	   100:   jsr exp_subtract
00:AB5E 30A7            	   101:   bmi exp_false
00:AB60 109C            	   102:   bpl exp_true
                        	   103: 
                        	   104: exp_bitwise_or:
00:AB62 A500            	   105:   lda VALUE
00:AB64 0503            	   106:   ora VALUE2
00:AB66 8500            	   107:   sta VALUE
00:AB68 A8              	   108:   tay
00:AB69 A501            	   109:   lda VALUE+1
00:AB6B 0504            	   110:   ora VALUE2+1
00:AB6D 8501            	   111:   sta VALUE+1
00:AB6F AA              	   112:   tax
00:AB70 A502            	   113:   lda VALUE+2
00:AB72 0505            	   114:   ora VALUE2+2
00:AB74 8502            	   115:   sta VALUE+2
00:AB76 60              	   116:   rts
                        	   117: 
                        	   118: exp_bitwise_and:
00:AB77 A500            	   119:   lda VALUE
00:AB79 2503            	   120:   and VALUE2
00:AB7B 8500            	   121:   sta VALUE
00:AB7D A8              	   122:   tay
00:AB7E A501            	   123:   lda VALUE+1
00:AB80 2504            	   124:   and VALUE2+1
00:AB82 8501            	   125:   sta VALUE+1
00:AB84 AA              	   126:   tax
00:AB85 A502            	   127:   lda VALUE+2
00:AB87 2505            	   128:   and VALUE2+2
00:AB89 8502            	   129:   sta VALUE+2
00:AB8B 60              	   130:   rts
                        	   131: 
                        	   132: exp_bitwise_xor:
00:AB8C A500            	   133:   lda VALUE
00:AB8E 4503            	   134:   eor VALUE2
00:AB90 8500            	   135:   sta VALUE
00:AB92 A8              	   136:   tay
00:AB93 A501            	   137:   lda VALUE+1
00:AB95 4504            	   138:   eor VALUE2+1
00:AB97 8501            	   139:   sta VALUE+1
00:AB99 AA              	   140:   tax
00:AB9A A502            	   141:   lda VALUE+2
00:AB9C 4505            	   142:   eor VALUE2+2
00:AB9E 8502            	   143:   sta VALUE+2
00:ABA0 60              	   144:   rts
                        	   145: 
                        	   146: 
00:ABA1 4CFEAA          	   147: exp_trueJ jmp exp_true
00:ABA4 4C07AB          	   148: exp_falseJ jmp exp_false
                        	   149: 
                        	   150: exp_logical_or:
00:ABA7 2062AB          	   151:   jsr exp_bitwise_or
00:ABAA D0F5            	   152:   bne exp_trueJ
00:ABAC E000            	   153:   cpx #0
00:ABAE D0F1            	   154:   bne exp_trueJ
00:ABB0 C000            	   155:   cpy #0
00:ABB2 D0ED            	   156:   bne exp_trueJ
00:ABB4 80EE            	   157:   bra exp_falseJ
                        	   158: 
                        	   159: exp_logical_and:
00:ABB6 A500            	   160:   lda VALUE
00:ABB8 0501            	   161:   ora VALUE+1
00:ABBA 0502            	   162:   ora VALUE+2
00:ABBC F0E6            	   163:   beq exp_falseJ  ; if VALUE has all bits zero the logical "and" must be false
                        	   164: ;
                        	   165: ;  VALUE is non-zero, how about VALUE2?
                        	   166: ;
00:ABBE A503            	   167:   lda VALUE2
00:ABC0 0504            	   168:   ora VALUE2+1
00:ABC2 0505            	   169:   ora VALUE2+2
00:ABC4 F0DE            	   170:   beq exp_falseJ  ; if VALUE2 has all bits zero the logical "and" must be false
00:ABC6 80D9            	   171:   bra exp_trueJ   ; both are non-zero, therefore the result is true
                        	   172: 
                        	   173: exp_shift_left:
00:ABC8 A504            	   174:   lda VALUE2+1
00:ABCA 0505            	   175:   ora VALUE2+2
00:ABCC D0D6            	   176:   bne exp_falseJ  ; big shifts will return zero
00:ABCE A503            	   177:   lda VALUE2
00:ABD0 F00E            	   178:   beq exp_shift_left_done ; shift by zero? we are done then
00:ABD2 AA              	   179:   tax
00:ABD3 29E0            	   180:   and #$E0        ; maximum of 32 shifts
00:ABD5 D0CD            	   181:   bne exp_falseJ
                        	   182: exp_shift_left_loop:
00:ABD7 0600            	   183:   asl VALUE
00:ABD9 2601            	   184:   rol VALUE+1
00:ABDB 2602            	   185:   rol VALUE+2
00:ABDD CA              	   186:   dex
00:ABDE D0F7            	   187:   bne exp_shift_left_loop
                        	   188: exp_shift_left_done:
00:ABE0 60              	   189:   rts
                        	   190: 
                        	   191: exp_shift_right:
00:ABE1 A504            	   192:   lda VALUE2+1
00:ABE3 0505            	   193:   ora VALUE2+2
00:ABE5 D0BD            	   194:   bne exp_falseJ  ; big shifts will return zero
00:ABE7 A503            	   195:   lda VALUE2
00:ABE9 F00E            	   196:   beq exp_shift_right_done ; shift by zero? we are done then
00:ABEB AA              	   197:   tax
00:ABEC 29E0            	   198:   and #$E0        ; maximum of 32 shifts
00:ABEE D0B4            	   199:   bne exp_falseJ
                        	   200: exp_shift_right_loop:
00:ABF0 4602            	   201:   lsr VALUE+2
00:ABF2 6601            	   202:   ror VALUE+1
00:ABF4 6600            	   203:   ror VALUE
00:ABF6 CA              	   204:   dex
00:ABF7 D0F7            	   205:   bne exp_shift_right_loop
                        	   206: exp_shift_right_done:
00:ABF9 60              	   207:   rts
                        	   208: 
                        	   209: exp_negate:
00:ABFA A500            	   210:   lda VALUE
00:ABFC 49FF            	   211:   eor #$FF
00:ABFE 8500            	   212:   sta VALUE
00:AC00 A501            	   213:   lda VALUE+1
00:AC02 49FF            	   214:   eor #$FF
00:AC04 8501            	   215:   sta VALUE+1
00:AC06 A502            	   216:   lda VALUE+2
00:AC08 49FF            	   217:   eor #$FF
00:AC0A 8502            	   218:   sta VALUE+2
00:AC0C 60              	   219:   rts
                        	   220: 
                        	   221: exp_not:
00:AC0D A500            	   222:   lda VALUE
00:AC0F D093            	   223:   bne exp_falseJ
00:AC11 A501            	   224:   lda VALUE+1
00:AC13 D08F            	   225:   bne exp_falseJ
00:AC15 A502            	   226:   lda VALUE+2
00:AC17 D08B            	   227:   bne exp_falseJ
00:AC19 8086            	   228:   bra exp_trueJ
                        	   229: 
                        	   230: exp_unary_minus:
00:AC1B 38              	   231:   sec
00:AC1C A900            	   232:   lda #0
00:AC1E E500            	   233:   sbc VALUE
00:AC20 8500            	   234:   sta VALUE
00:AC22 A900            	   235:   lda #0
00:AC24 E501            	   236:   sbc VALUE+1
00:AC26 8501            	   237:   sta VALUE+1
00:AC28 A900            	   238:   lda #0
00:AC2A E502            	   239:   sbc VALUE+2
00:AC2C 8502            	   240:   sta VALUE+2
00:AC2E 60              	   241:   rts
                        	   242: 
                        	   243: 
                        	   244: exp_low_byte:
00:AC2F 6401            	   245:   stz VALUE+1
00:AC31 6402            	   246:   stz VALUE+2
00:AC33 60              	   247:   rts
                        	   248: 
                        	   249: exp_high_byte:
00:AC34 A501            	   250:   lda VALUE+1
00:AC36 8500            	   251:   sta VALUE
00:AC38 6401            	   252:   stz VALUE+1
00:AC3A 6402            	   253:   stz VALUE+2
00:AC3C 60              	   254:   rts
                        	   255: 
                        	   256: ;
                        	   257: ;  make VALUE positive
                        	   258: ;
                        	   259: exp_abs_val:
00:AC3D A502            	   260:   lda  VALUE+2  ; check high-order byte, see if negative
00:AC3F 1013            	   261:   bpl  exp_abs_val_done
                        	   262: exp_negate_val:
00:AC41 38              	   263:   sec
00:AC42 A900            	   264:   lda  #0
00:AC44 E500            	   265:   sbc  VALUE
00:AC46 8500            	   266:   sta  VALUE
00:AC48 A900            	   267:   lda  #0
00:AC4A E501            	   268:   sbc  VALUE+1
00:AC4C 8501            	   269:   sta  VALUE+1
00:AC4E A900            	   270:   lda  #0
00:AC50 E502            	   271:   sbc  VALUE+2
00:AC52 8502            	   272:   sta  VALUE+2
                        	   273: exp_abs_val_done:
00:AC54 60              	   274:   rts
                        	   275: 
                        	   276: ;
                        	   277: ;  make VALUE2 positive
                        	   278: ;
                        	   279: exp_abs_val2:
00:AC55 A505            	   280:   lda  VALUE2+2  ; check high-order byte, see if negative
00:AC57 1013            	   281:   bpl  exp_abs_val2_done
                        	   282: exp_negate_val2:
00:AC59 38              	   283:   sec
00:AC5A A900            	   284:   lda  #0
00:AC5C E503            	   285:   sbc  VALUE2
00:AC5E 8503            	   286:   sta  VALUE2
00:AC60 A900            	   287:   lda  #0
00:AC62 E504            	   288:   sbc  VALUE2+1
00:AC64 8504            	   289:   sta  VALUE2+1
00:AC66 A900            	   290:   lda  #0
00:AC68 E505            	   291:   sbc  VALUE2+2
00:AC6A 8505            	   292:   sta  VALUE2+2
                        	   293: exp_abs_val2_done:
00:AC6C 60              	   294:   rts
                        	   295: 
                        	   296: 
                        	   297: ZERRES:
00:AC6D A900            	   298:   lda  #0
00:AC6F 8552            	   299:   sta  RES
00:AC71 8553            	   300:   sta  RES+1
00:AC73 8554            	   301:   sta  RES+2
00:AC75 60              	   302:   rts
                        	   303: 
                        	   304: exp_find_sign:
00:AC76 206DAC          	   305:    jsr  ZERRES     ; zero result
00:AC79 A502            	   306:    lda  VALUE+2
00:AC7B 2980            	   307:    and  #$80
00:AC7D 855B            	   308:    sta  RMNDR
00:AC7F A505            	   309:    lda  VALUE2+2
00:AC81 2980            	   310:    and  #$80
00:AC83 455B            	   311:    eor  RMNDR
00:AC85 855B            	   312:    sta  RMNDR     ; RMNDR is 0x80 if the result needs to be negative
00:AC87 203DAC          	   313:    jsr  exp_abs_val
00:AC8A 2055AC          	   314:    jsr  exp_abs_val2
00:AC8D 60              	   315:    rts
                        	   316: ;
                        	   317: 
                        	   318: exp_fix_sign:
00:AC8E A55B            	   319:   lda  RMNDR
00:AC90 100F            	   320:   bpl  exp_fix_sign_done      ; nothing needs to be changed
00:AC92 38              	   321:   sec                         ; subtract result from zero
00:AC93 A900            	   322:   lda  #0
00:AC95 E552            	   323:   sbc  RES
00:AC97 AA              	   324:   tax
00:AC98 A900            	   325:   lda  #0
00:AC9A E553            	   326:   sbc  RES+1
00:AC9C A8              	   327:   tay
00:AC9D A900            	   328:   lda  #0
00:AC9F E554            	   329:   sbc  RES+2
                        	   330: exp_fix_sign_done:
00:ACA1 60              	   331:   rts
                        	   332: 
                        	   333: 
                        	   334: ;
                        	   335: ;  multiply VALUE1 by VALUE2 and store in VALUE
                        	   336: ;
                        	   337: ;  see: https://llx.com/Neil/a2/mult.html for a discussion
                        	   338: ;
                        	   339: 
                        	   340: exp_multiply:
00:ACA2 2076AC          	   341:   jsr exp_find_sign
00:ACA5 A218            	   342:   ldx  #24       ; for all 24 bits
                        	   343: exp_multiply_loop:
00:ACA7 0652            	   344:   asl  RES
00:ACA9 2653            	   345:   rol  RES+1
00:ACAB 2654            	   346:   rol  RES+2                    ; shift RES left one bit
00:ACAD 0600            	   347:   asl  VALUE
00:ACAF 2601            	   348:   rol  VALUE+1
00:ACB1 2602            	   349:   rol  VALUE+2                  ; shift one argument left one bit and get the low-order bit into carry
00:ACB3 9013            	   350:   bcc  exp_multiply_no_add      ; if no low-order bit, don't add anything
00:ACB5 18              	   351:   clc                           ; add the other argument to the result
00:ACB6 A503            	   352:   lda  VALUE2
00:ACB8 6552            	   353:   adc  RES
00:ACBA 8552            	   354:   sta  RES
00:ACBC A504            	   355:   lda  VALUE2+1
00:ACBE 6553            	   356:   adc  RES+1
00:ACC0 8553            	   357:   sta  RES+1
00:ACC2 A505            	   358:   lda  VALUE2+2
00:ACC4 6554            	   359:   adc  RES+2
00:ACC6 8554            	   360:   sta  RES+2
                        	   361: exp_multiply_no_add:
00:ACC8 CA              	   362:   dex                      ; count bits
00:ACC9 D0DC            	   363:   bne  exp_multiply_loop   ; go back if more to go
00:ACCB 208EAC          	   364:   jsr  exp_fix_sign
00:ACCE A552            	   365:   lda  RES
00:ACD0 8500            	   366:   sta  VALUE
00:ACD2 A553            	   367:   lda  RES+1
00:ACD4 8501            	   368:   sta  VALUE+1
00:ACD6 A554            	   369:   lda  RES+2
00:ACD8 8502            	   370:   sta  VALUE+2
00:ACDA 60              	   371:   rts
                        	   372: 
                        	   373: ;
                        	   374: ;  divide VALUE by VALUE2, store result in VALUE
                        	   375: ;
                        	   376: exp_divide:
00:ACDB 2076AC          	   377:   jsr exp_find_sign
                        	   378: 
00:ACDE A503            	   379:   lda  VALUE2
00:ACE0 0504            	   380:   ora  VALUE2+1
00:ACE2 0505            	   381:   ora  VALUE2+2
00:ACE4 D005            	   382:   bne  exp_divide_not_zero  ; check not dividing by zero
00:ACE6 A22F            	   383:   ldx  #47                  ; ERROR: divide by zero
00:ACE8 4C0D9F          	   384:   jmp  ass_error
                        	   385:   ;
                        	   386: exp_divide_not_zero:
00:ACEB 206DAC          	   387:   jsr  ZERRES     ; zero result (RES) - leaves zero in A register
00:ACEE 8506            	   388:   sta  REMAIN
00:ACF0 8507            	   389:   sta  REMAIN+1
00:ACF2 8508            	   390:   sta  REMAIN+2
00:ACF4 A918            	   391:   lda  #24       ; for all 24 bits of the operands ...
00:ACF6 858D            	   392:   sta  maths_work
                        	   393: exp_divide_loop:
00:ACF8 0600            	   394:   asl  VALUE
00:ACFA 2601            	   395:   rol  VALUE+1
00:ACFC 2602            	   396:   rol  VALUE+2    ; shift the dividend left one bit
00:ACFE 2606            	   397:   rol  REMAIN    ; the low-order bit of the dividend is shifted into the remainder
00:AD00 2607            	   398:   rol  REMAIN+1
00:AD02 2608            	   399:   rol  REMAIN+2
00:AD04 38              	   400:   sec
00:AD05 A506            	   401:   lda  REMAIN    ; do a trial subtraction of: remainder - divisor
00:AD07 E503            	   402:   sbc  VALUE2
00:AD09 AA              	   403:   tax
00:AD0A A507            	   404:   lda  REMAIN+1
00:AD0C E504            	   405:   sbc  VALUE2+1
00:AD0E A8              	   406:   tay
00:AD0F A508            	   407:   lda  REMAIN+2
00:AD11 E505            	   408:   sbc  VALUE2+2
00:AD13 300B            	   409:   bmi  exp_divide_subtraction_negative      ; if the subtraction fails (is negative) then discard the result
00:AD15 8508            	   410:   sta  REMAIN+2  ; if it succeeds then the result of the subtraction is our new remainder
00:AD17 98              	   411:   tya
00:AD18 8507            	   412:   sta  REMAIN+1
00:AD1A 8A              	   413:   txa
00:AD1B 8506            	   414:   sta  REMAIN
00:AD1D 38              	   415:   sec            ; shift a one-bit into the quotient
00:AD1E B001            	   416:   bcs  exp_divide_subtraction_positive
                        	   417: exp_divide_subtraction_negative:
00:AD20 18              	   418:   clc            ; here if subtraction failed, quotient (RES) gets a 0-bit shifted in
                        	   419: exp_divide_subtraction_positive:
00:AD21 2652            	   420:   rol  RES       ; the carry bit (from above) is shifted into the quotient
00:AD23 2653            	   421:   rol  RES+1
00:AD25 2654            	   422:   rol  RES+2
00:AD27 C68D            	   423:   dec  maths_work      ; one less bit to go
00:AD29 D0CD            	   424:   bne  exp_divide_loop      ; repeat until 24 bits done
00:AD2B 208EAC          	   425:   jsr  exp_fix_sign
00:AD2E A552            	   426:   lda  RES
00:AD30 8500            	   427:   sta  VALUE
00:AD32 A553            	   428:   lda  RES+1
00:AD34 8501            	   429:   sta  VALUE+1
00:AD36 A554            	   430:   lda  RES+2
00:AD38 8502            	   431:   sta  VALUE+2
00:AD3A 60              	   432:   rts
                        	   433: 
                        	   434: exp_modulo:
00:AD3B 20DBAC          	   435:   jsr exp_divide
00:AD3E A506            	   436:   lda REMAIN
00:AD40 8500            	   437:   sta VALUE
00:AD42 A507            	   438:   lda REMAIN+1
00:AD44 8501            	   439:   sta VALUE+1
00:AD46 A508            	   440:   lda REMAIN+2
00:AD48 8502            	   441:   sta VALUE+2
00:AD4A 60              	   442:   rts
                        	   443: 

Source: "gpascal.asm"
                        	   180:   .include "interpreter.inc"

Source: "interpreter.inc"
                        	     1: ;--------------------------------------------------
                        	     2: ; Runtime P-code interpreter
                        	     3: ;
                        	     4: ;--------------------------------------------------
                        	     5: 
                        	     6: 
                        	     7: ;--------------------------------
                        	     8: ; P-codes - these are generated in the compilation phase and looked up
                        	     9: ;           in execution_address_table at runtime
                        	    10: ;
                        	    11: ; Note: some P-codes must appear in sequence, eg. PCODE_STO and PCODE_STOC
                        	    12: ;       That is because one refers to integers (STO) and one refers to characters (STOC)
                        	    13: ;       The code in various places is virtually identical except it adds 1 to the P-code
                        	    14: ;       for characters. These generally are the Load/Store operations.
                        	    15: ;--------------------------------
                        	    16: 
                        	    17: ; Not implemented yet: $05, $13, $15, $39
                        	    18: 
                        	    19: ;                 Code            Description                         Arguments
                        	    20: ;                 ----            -----------------------------       -----------------------
                        	    21: PCODE_LIT     =   $00 ; Dec:  0 - Load constant                     - 3-byte literal (number)
                        	    22: PCODE_STACK   =   $01 ; Dec:  1 - Alter runtime stack to address    - 2-byte stack address
                        	    23: PCODE_NEG     =   $02 ; Dec:  2 - Unary minus 0 - (sp)              - none
                        	    24: PCODE_LIB_CALL =  $03 ; Dec:  3 - Call library function/procedure   - absolute address
                        	    25: PCODE_ADD     =   $04 ; Dec:  4 - Add (sp) to (sp - 1)              - none
                        	    26: PCODE_SUB     =   $06 ; Dec:  6 - Subtract (sp) from (sp - 1)       - none
                        	    27: PCODE_MUL     =   $08 ; Dec:  8 - Multiply (sp) * (sp - 1)          - none
                        	    28: PCODE_DIV     =   $0A ; Dec: 10 - Divide (sp - 1) / (sp)            - none
                        	    29: PCODE_MOD     =   $0B ; Dec: 11 - Modulus (sp - 1) MOD (sp)         - none
                        	    30: PCODE_ADRNN   =   $0C ; Dec: 12 - Address of integer                - level, displ
                        	    31: PCODE_ADRNC   =   $0D ; Dec: 13 - Address of character              - level, displ
                        	    32: PCODE_ADRAN   =   $0E ; Dec: 14 - Address of integer array          - level, displ
                        	    33: PCODE_ADRAC   =   $0F ; Dec: 15 - Address of character array        - level, displ
                        	    34: PCODE_EQL     =   $10 ; Dec: 16 - Test (sp - 1) == (sp)             - none
                        	    35: PCODE_FINISHD =   $11 ; Dec: 17 - Stop run (end program)            - none
                        	    36: PCODE_NEQ     =   $12 ; Dec: 18 - Test (sp - 1) != (sp)             - none
                        	    37: PCODE_LSS     =   $14 ; Dec: 20 - Test (sp - 1) < (sp)              - none
                        	    38: PCODE_GEQ     =   $16 ; Dec: 22 - Test (sp - 1) >= (sp)             - none
                        	    39: PCODE_GTR     =   $18 ; Dec: 24 - Test (sp - 1) > (sp)              - none
                        	    40: PCODE_LEQ     =   $19 ; Dec: 25 - Test (sp - 1) <= (sp)             - none
                        	    41: PCODE_ORR     =   $1A ; Dec: 26 - OR  (sp - 1) | (sp)               - none
                        	    42: PCODE_AND     =   $1B ; Dec: 27 - AND (sp - 1) & (sp)               - none
                        	    43: PCODE_INP     =   $1C ; Dec: 28 - Input number                      - none
                        	    44: PCODE_INPC    =   $1D ; Dec: 29 - Input character                   - none
                        	    45: PCODE_OUT     =   $1E ; Dec: 30 - Output number                     - none
                        	    46: PCODE_OUTC    =   $1F ; Dec: 31 - Output character                  - none
                        	    47: PCODE_EOR     =   $20 ; Dec: 32 - Not (sp) (logical negate)         - none
                        	    48: PCODE_OUH     =   $21 ; Dec: 33 - Output hex number                 - none
                        	    49: PCODE_SHL     =   $22 ; Dec: 34 - Shift left (sp) bits              - none
                        	    50: PCODE_OUS     =   $23 ; Dec: 35 - Output string                     - length, string
                        	    51: PCODE_SHR     =   $24 ; Dec: 36 - Shift right (sp) bits             - none
                        	    52: PCODE_INS     =   $25 ; Dec: 37 - Input string into array           - max, level, displ
                        	    53: PCODE_INC     =   $26 ; Dec: 38 - Increment (sp) by 1               - none
                        	    54: PCODE_CLL     =   $27 ; Dec: 39 - Relative procedure/function call  - level, relative address
                        	    55: PCODE_DEC     =   $28 ; Dec: 40 - Decrement (sp) by 1               - none
                        	    56: PCODE_RTN     =   $29 ; Dec: 41 - Procedure/function return         - none
                        	    57: PCODE_MOV     =   $2A ; Dec: 42 - Copy (sp) to (sp + 1)             - none
                        	    58: PCODE_CLA     =   $2B ; Dec: 43 - Call absolute address             - none
                        	    59: PCODE_LOD     =   $2C ; Dec: 44 - Load integer onto stack           - level, displ
                        	    60: PCODE_LODC    =   $2D ; Dec: 45 - Load character onto stack         - level, displ
                        	    61: PCODE_LDA     =   $2E ; Dec: 46 - Load absolute address integer     - none
                        	    62: PCODE_LDAC    =   $2F ; Dec: 47 - Load absolute address character   - none
                        	    63: PCODE_LDI     =   $30 ; Dec: 48 - Load integer indexed              - level, displ
                        	    64: PCODE_LDIC    =   $31 ; Dec: 49 - Load character indexed            - level, displ
                        	    65: PCODE_STO     =   $32 ; Dec: 50 - Store integer                     - level, displ
                        	    66: PCODE_STOC    =   $33 ; Dec: 51 - Store character                   - level, displ
                        	    67: PCODE_STA     =   $34 ; Dec: 52 - Store integer absolute address    - none
                        	    68: PCODE_STAC    =   $35 ; Dec: 53 - Store character absolute address  - none
                        	    69: PCODE_STI     =   $36 ; Dec: 54 - Store integer indexed             - level, displ
                        	    70: PCODE_STIC    =   $37 ; Dec: 55 - Store character indexed           - level, displ
                        	    71: PCODE_ABSCLL  =   $38 ; Dec: 56 - Absolute procedure/function call  - level, absolute address
                        	    72: PCODE_XOR     =   $3A ; Dec: 58 - XOR (sp - 1) ^ (sp)               - none
                        	    73: PCODE_INT     =   $3B ; Dec: 59 - Increment stack pointer           - increment
                        	    74: PCODE_JMP     =   $3C ; Dec: 60 - Jump unconditionally              - relative address
                        	    75: PCODE_JMZ     =   $3D ; Dec: 61 - Jump if (sp) zero                 - relative address
                        	    76: PCODE_JM1     =   $3E ; Dec: 62 - Jump if (sp) not zero             - relative address
                        	    77: PCODE_OUTCR   =   $40 ; Dec: 64 - Output a carriage-return          - none
                        	    78: PCODE_LCD_WRITE_NUM = $42 ; Dec: 66 - Write number to LCD           - none
                        	    79: PCODE_LCD_WRITE_STR = $43 ; Dec: 67 - Write string to LCD           - none
                        	    80: PCODE_LCD_WRITE_HEX = $44 ; Dec: 68 - Write hex number to LCD       - none
                        	    81: PCODE_LCD_WRITE_CHR = $45 ; Dec: 69 - Write character to LCD        - none
                        	    82: 
                        	    83: PCODE_LAST    =   PCODE_LCD_WRITE_CHR  ; PUT THIS LAST! (error check)                  -
                        	    84: 
                        	    85: ; 0x80 to 0xFF - Load low literal (onto stack), where literal is P-code with 8-bit clear (ie. P-code & 0x7F)
                        	    86: 
                        	    87: 
                        	    88: ;
                        	    89: ;  P-code execution routine lookup.
                        	    90: ;  For symbolic version see list above
                        	    91: ;
                        	    92: ;  Y is zero when starting to execute these routines
                        	    93: ;
                        	    94: execution_address_table  =  *
00:AD4B 7CB0            	    95:   word  EX_LIT             ; $00 = LIT      Load constant
00:AD4D 70B4            	    96:   word  EX_NEW_STACK       ; $01 =          Change stack to addr
00:AD4F 8EB0            	    97:   word  EX_NEG             ; $02 = NEG      Unary minus: 0 - (sp)
00:AD51 FCB5            	    98:   word  EX_LIB_CALL        ; $03 = LIB_CALL Library function call
00:AD53 97B0            	    99:   word  EX_ADD             ; $04 = ADD      Add (sp) to (sp - 1)
00:AD55 AAAF            	   100:   word  EX_INVINS          ; $05 =          NOT IMPLEMENTED
00:AD57 A0B0            	   101:   word  EX_SUB             ; $06 = SUB      Subtract (sp) from (sp - 1)
00:AD59 AAAF            	   102:   word  EX_INVINS          ; $07 =          NOT IMPLEMENTED
00:AD5B ACB0            	   103:   word  EX_MUL             ; $08 = MUL      Multiply (sp) * (sp - 1)
00:AD5D AAAF            	   104:   word  EX_INVINS          ; $09 =          NOT IMPLEMENTED
00:AD5F E7B0            	   105:   word  EX_DIV             ; $0A = DIV      Divide (sp - 1) / (sp)
00:AD61 BCB0            	   106:   word  EX_MOD             ; $0B = MOD      Modulus (sp - 1) MOD (sp)
00:AD63 5BB5            	   107:   word  EX_ADRNN           ; $0C = ADRNN    Address of integer
00:AD65 4BB5            	   108:   word  EX_ADRNC           ; $0D = ADRNC    Address of character
00:AD67 69B5            	   109:   word  EX_ADRAN           ; $0E = ADRAN    Address of integer array
00:AD69 6FB5            	   110:   word  EX_ADRAC           ; $0F = ADRAC    Address of character array
00:AD6B 04B1            	   111:   word  EX_EQL             ; $10 = EQL      Test (sp - 1) == (sp)
00:AD6D F7AE            	   112:   word  EX_FINISHD         ; $11 = FINISHD  Stop run (end program)
00:AD6F 1EB1            	   113:   word  EX_NEQ             ; $12 = NEQ      Test (sp - 1) != (sp)
00:AD71 AAAF            	   114:   word  EX_INVINS          ; $13 =          NOT IMPLEMENTED
00:AD73 27B1            	   115:   word  EX_LSS             ; $14 = LSS      Test (sp - 1) < (sp)
00:AD75 AAAF            	   116:   word  EX_INVINS          ; $15 =          NOT IMPLEMENTED
00:AD77 3FB1            	   117:   word  EX_GEQ             ; $16 = GEQ      Test (sp - 1) >= (sp)
00:AD79 AAAF            	   118:   word  EX_INVINS          ; $17 =          NOT IMPLEMENTED
00:AD7B 33B1            	   119:   word  EX_GTR             ; $18 = GTR      Test (sp - 1) > (sp)
00:AD7D 4BB1            	   120:   word  EX_LEQ             ; $19 = LEQ      Test (sp - 1) <= (sp)
00:AD7F 60B1            	   121:   word  EX_ORR             ; $1A = ORR      OR  (sp - 1) | (sp)
00:AD81 69B1            	   122:   word  EX_AND             ; $1B = AND      AND (sp - 1) & (sp)
00:AD83 E9B2            	   123:   word  EX_INP             ; $1C = INP      Input number
00:AD85 B1B4            	   124:   word  EX_INPC            ; $1D = INPC     Input character
00:AD87 29B3            	   125:   word  EX_OUT             ; $1E = OUT      Output number
00:AD89 CBB4            	   126:   word  EX_OUTC            ; $1F = OUTC     Output character
00:AD8B 72B1            	   127:   word  EX_EOR             ; $20 = EOR      Not (sp) (logical negate)
00:AD8D 3DB3            	   128:   word  EX_OUH             ; $21 = OUH      Output hex number
00:AD8F 7BB1            	   129:   word  EX_SHL             ; $22 = SHL      Shift left (sp) bits
00:AD91 5DB3            	   130:   word  EX_OUS             ; $23 = OUS      Output string
00:AD93 87B1            	   131:   word  EX_SHR             ; $24 = SHR      Shift right (sp) bits
00:AD95 EDB4            	   132:   word  EX_INS             ; $25 = INS      Input string into array
00:AD97 93B1            	   133:   word  EX_INC             ; $26 = INC      Increment (sp) by 1
00:AD99 97B3            	   134:   word  EX_CLL             ; $27 = CLL      Relative procedure/function call
00:AD9B ABB1            	   135:   word  EX_DEC             ; $28 = DEC      Decrement (sp) by 1
00:AD9D B0B2            	   136:   word  EX_RTN             ; $29 = RTN      Procedure/function return
00:AD9F C3B1            	   137:   word  EX_MOV             ; $2A = MOV      Copy (sp) to (sp + 1)
00:ADA1 26B4            	   138:   word  EX_CLA             ; $2B = CLA      Call absolute address
00:ADA3 E6B1            	   139:   word  EX_LOD             ; $2C = LOD      Load integer onto stack
00:ADA5 D4B1            	   140:   word  EX_LODC            ; $2D = LODC     Load character onto stack
00:ADA7 07B2            	   141:   word  EX_LDA             ; $2E = LDA      Load absolute address integer
00:ADA9 FCB1            	   142:   word  EX_LDAC            ; $2F = LDAC     Load absolute address character
00:ADAB 42B2            	   143:   word  EX_LDI             ; $30 = LDI      Load integer indexed
00:ADAD 3CB2            	   144:   word  EX_LDIC            ; $31 = LDIC     Load character indexed
00:ADAF 55B2            	   145:   word  EX_STO             ; $32 = STO      Store integer
00:ADB1 48B2            	   146:   word  EX_STOC            ; $33 = STOC     Store character
00:ADB3 68B2            	   147:   word  EX_STA             ; $34 = STA      Store integer absolute address
00:ADB5 7EB2            	   148:   word  EX_STAC            ; $35 = STAC     Store character absolute address
00:ADB7 95B2            	   149:   word  EX_STI             ; $36 = STI      Store integer indexed
00:ADB9 87B2            	   150:   word  EX_STIC            ; $37 = STIC     Store character indexed
00:ADBB 90B3            	   151:   word  EX_ABSCLL          ; $38 = ABSCLL   Absolute procedure/function call
00:ADBD AAAF            	   152:   word  EX_INVINS          ; $39 =          NOT IMPLEMENTED
00:ADBF 57B1            	   153:   word  EX_XOR             ; $3A = XOR      XOR (sp - 1) ^ (sp)
00:ADC1 46B4            	   154:   word  EX_INT             ; $3B = INT      Increment stack pointer
00:ADC3 82B4            	   155:   word  EX_JMP             ; $3C = JMP      Jump unconditionally
00:ADC5 95B4            	   156:   word  EX_JMZ             ; $3D = JMZ      Jump if (sp) zero
00:ADC7 A6B4            	   157:   word  EX_JM1             ; $3E = JM1      Jump if (sp) not zero
00:ADC9 AAAF            	   158:   word  EX_INVINS          ; $3F =          NOT IMPLEMENTED
00:ADCB 57AF            	   159:   word  EX_OUTCR           ; $40 = OUTCR    Output a carriage-return
00:ADCD AAAF            	   160:   word  EX_INVINS          ; $41 =          NOT IMPLEMENTED
00:ADCF 2EB3            	   161:   word  EX_LCD_WRITE_NUM   ; $42 = LCD_WRITE_NUM  Write number to LCD
00:ADD1 62B3            	   162:   word  EX_LCD_WRITE_STR   ; $43 = LCD_WRITE_STR  Write string to LCD
00:ADD3 42B3            	   163:   word  EX_LCD_WRITE_HEX   ; $44 = LCD_WRITE_HEX  Write hex to LCD
00:ADD5 D0B4            	   164:   word  EX_LCD_WRITE_CHR   ; $45 = LCD_WRITE_CHR  Write character to LCD
                        	   165: 
                        	   166: ;--------------------------------------------------------------------------
                        	   167: ;
                        	   168: ;  STACK FRAMES
                        	   169: ;
                        	   170: ;  The compiler can't know where variables are actually going to be stored because
                        	   171: ;  they will be relative to the (interpreter) stack (not the processor stack) which
                        	   172: ;  is an unknown address because procedures/functions can be called directly or from
                        	   173: ;  other procedures/functions.
                        	   174: ;
                        	   175: ;  Hence variables are referenced to BASE which is the base of the current stack frame,
                        	   176: ;  thus a variable will be a certain offset from that. However in the case of nested
                        	   177: ;  calls we need to go back to a previous stack frame. That is what the 6-byte "stack
                        	   178: ;  frame linkage data" is about.
                        	   179: ;
                        	   180: ;  Variables are referred to by a "level difference" and a displacement. For the current
                        	   181: ;  procedure the level difference will be zero, and thus the variable will be BASE +
                        	   182: ;  the offset for this particular variable.
                        	   183: ;
                        	   184: ;  For variables in earlier procedures/functions (ones which called this one) there will
                        	   185: ;  be a level difference, being the depth (lexically) between the called function and the
                        	   186: ;  one with the variable. For example, if foo calls bar, and bar recurses five times, foo
                        	   187: ;  and bar are still only one level apart, from the point of view of accessing foo's
                        	   188: ;  variables.
                        	   189: ;
                        	   190: ;  Thus, to find an address we need to "walk" back through the STATIC stack frame links
                        	   191: ;  (bytes 5 and 6 of the stack frame data) to find the appropriate stack frame, and then
                        	   192: ;  take the offset from that.
                        	   193: ;
                        	   194: ;  However for recursive calls, once a recursed call ends, we need to get back the stack
                        	   195: ;  frame of the caller, which will be different from the static frame. So, to restore the
                        	   196: ;  stack frame after a procedure/function ends, we must take the DYNAMIC stack frame address
                        	   197: ;  (bytes 3 and 4 of the stack frame data) to get back the previous stack frame. In fact,
                        	   198: ;  all procedures/functions do this, it's just that the static and dynamic stack frames will
                        	   199: ;  be the same if the procedure/function does not recurse.
                        	   200: ;
                        	   201: ;  Finally, the return address (in the P-codes) for the procedure/function call is also
                        	   202: ;  stored in the stack frame data (bytes 1 and 2 of the stack frame data) so that, after
                        	   203: ;  doing a return, we can restore the P-code address to the PCODE variable after the call.
                        	   204: ;
                        	   205: ;  When a procedure/function is called these 6 bytes are pushed onto the stack. Then, for
                        	   206: ;  some reason, the code moves the stack pointer back 6 (adds to it). Then as part of the
                        	   207: ;  procedure/function initialisation the stack pointer has 6 or 9 added to it, to allow
                        	   208: ;  for not overwriting this stack frame data, and in the case of functions, the extra 3
                        	   209: ;  bytes are for the returned value.
                        	   210: ;
                        	   211: ;  Note that the stack grows downwards, as it starts at "high memory" (whatever that is
                        	   212: ;  defined as, and grows downwards, taking the gap between the end of the P-codes and the
                        	   213: ;  end of memory.
                        	   214: ;
                        	   215: ;  Then the function will add additional spaces to the stack (ie. by subtracting from the
                        	   216: ;  stack pointer) to make room for variables declared in that procedure/function. Now we
                        	   217: ;  are ready to push data onto the stack as part of normal expression evalution. It follows
                        	   218: ;  from this that variables initially have undefined values, as they will contain whatever
                        	   219: ;  happened to be in the stack when this space was allocated.
                        	   220: ;
                        	   221: ;  The function GETADR resolves these addresses by starting with BASE, the stack frame base
                        	   222: ;  for the current procedure/function, and then using the static stack frame link to load a
                        	   223: ;  (temporary) new base, and repeating that until the level difference is zero. Then it adds
                        	   224: ;  the offset of the wanted variable to the stack base to derive the actual variable address.
                        	   225: ;
                        	   226: ;--------------------------------------------------------------------------
                        	   227: 
                        	   228: 
                        	   229: ;
00:ADD7 20537461636B3A20	   230: DM1               asciiz  ' Stack: '
00:ADDF 00
00:ADE0 20426173653A2020	   231: DM2               asciiz  ' Base:  '
00:ADE8 00
00:ADE9 52756E6E696E670A	   232: running_message   asciiz  'Running\n'
00:ADF1 00
                        	   233: 
                        	   234: ;
                        	   235: DEBUG    =  *
00:ADF2 20AC92          	   236: DB11     jsr  DISPAD    ; display P-code address
00:ADF5 A523            	   237:          lda  PCODE
00:ADF7 8537            	   238:          sta  WORK
00:ADF9 A524            	   239:          lda  PCODE+1
00:ADFB 8538            	   240:          sta  WORK+1
00:ADFD A204            	   241:          ldx  #4
00:ADFF 20BBAE          	   242:          jsr  display_x_characters      ; display 4 bytes from WORK (ie. the P-codes)
00:AE02 209192          	   243:          jsr  CROUT
00:AE05 A649            	   244:          ldx  DBGFLG
00:AE07 3051            	   245:          bmi  DEBUG_DONE        ; trace only
00:AE09 A9D7            	   246:          lda  #<DM1             ; ' Stack: '
00:AE0B A2AD            	   247:          ldx  #>DM1
00:AE0D 202682          	   248:          jsr  print
00:AE10 A532            	   249:          lda  T+1
00:AE12 200693          	   250:          jsr  PRBYTE        ; display the stack pointer address
00:AE15 A531            	   251:          lda  T
00:AE17 20A692          	   252:          jsr  DISHX         ; display hex and a space after
00:AE1A A93D            	   253:          lda  #'='
00:AE1C 201894          	   254:          jsr  COUT
00:AE1F A531            	   255:          lda  T
00:AE21 8537            	   256:          sta  WORK
00:AE23 A532            	   257:          lda  T+1
00:AE25 8538            	   258:          sta  WORK+1
00:AE27 A209            	   259:          ldx  #9         ; show 9 bytes on stack, namely 3 variables
00:AE29 20BBAE          	   260:          jsr  display_x_characters
00:AE2C 209192          	   261:          jsr  CROUT
00:AE2F A9E0            	   262:          lda  #<DM2       ; ' Base:  '
00:AE31 A2AD            	   263:          ldx  #>DM2
00:AE33 202682          	   264:          jsr  print
00:AE36 A53C            	   265:          lda  BASE+1
00:AE38 200693          	   266:          jsr  PRBYTE      ; display the base pointer address
00:AE3B A53B            	   267:          lda  BASE
00:AE3D 20A692          	   268:          jsr  DISHX
00:AE40 A93D            	   269:          lda  #'='
00:AE42 201894          	   270:          jsr  COUT
00:AE45 A53B            	   271:          lda  BASE
00:AE47 38              	   272:          sec
00:AE48 E906            	   273:          sbc  #6    ; the linkage data is 6 bytes below the base
00:AE4A 8537            	   274:          sta  WORK
00:AE4C A53C            	   275:          lda  BASE+1
00:AE4E E900            	   276:          sbc  #0
00:AE50 8538            	   277:          sta  WORK+1
00:AE52 A206            	   278:          ldx  #6    ; show 6 bytes of base linkage data (return, dynamic link, static link)
00:AE54 20BBAE          	   279:          jsr  display_x_characters
00:AE57 4C9192          	   280:          jmp  CROUT
                        	   281: 
00:AE5A 60              	   282: DEBUG_DONE rts
                        	   283: 
                        	   284: 
                        	   285: ;***********************************************
                        	   286: ; Interpreter initialization
                        	   287: ;***********************************************
                        	   288: 
                        	   289: INTERP   =  *
00:AE5B 08              	   290:   php
00:AE5C 68              	   291:   pla
00:AE5D 8513            	   292:   sta  call_p   ; make sure call_p has some reasonable value in it
                        	   293: ;
                        	   294: ;  Move the start of where the P-codes start into PCODE (our first P-code)
                        	   295: ;
00:AE5F A525            	   296:   lda  ACT_PCDA
00:AE61 8523            	   297:   sta  PCODE
00:AE63 A526            	   298:   lda  ACT_PCDA+1
00:AE65 8524            	   299:   sta  PCODE+1
                        	   300: ;
                        	   301: ;  Running message
                        	   302: ;
00:AE67 A9E9            	   303:   lda  #<running_message   ; Running
00:AE69 A2AD            	   304:   ldx  #>running_message
00:AE6B 202682          	   305:   jsr  print
                        	   306: ;
                        	   307: ;  Running flag
                        	   308: ;
00:AE6E A00C            	   309:   ldy  #$0C
00:AE70 843F            	   310:   sty  RUNNING
                        	   311: ;
                        	   312: ;  Set up the runtime stack pointer which is also our first stack frame base
                        	   313: ;
00:AE72 A9FF            	   314:   lda  #<HIGHEST_RAM
00:AE74 8531            	   315:   sta  T
00:AE76 853B            	   316:   sta  BASE
00:AE78 A93F            	   317:   lda  #>HIGHEST_RAM
00:AE7A 8532            	   318:   sta  T+1
00:AE7C 853C            	   319:   sta  BASE+1
                        	   320: 
00:AE7E 4C6CAF          	   321:   jmp  MAIN ; start interpreting
                        	   322: ;
                        	   323: ;
                        	   324: ;
                        	   325: 
                        	   326: 
                        	   327: ;***********************************************
                        	   328: ;  INTERPRETER
                        	   329: ;***********************************************
                        	   330: 
                        	   331: ;
                        	   332: ;
00:AE81 496C6C6567616C20	   333: DM5      asciiz  "Illegal instruction\n"
00:AE89 696E737472756374
00:AE91 696F6E0A
00:AE95 00
00:AE96 427265616B202E2E	   334: DM6      asciiz  'Break ...\n'
00:AE9E 2E0A
00:AEA0 00
00:AEA1 4572726F72206F63	   335: DM7      asciiz  "Error occurred at P-code "
00:AEA9 6375727265642061
00:AEB1 7420502D636F6465
00:AEB9 20
00:AEBA 00
                        	   336: 
                        	   337: ;
                        	   338: ; DISPLAY (X) CHARACTERS FROM (WORK)
                        	   339: ;
                        	   340: display_x_characters:
00:AEBB 8A              	   341:          txa
00:AEBC 48              	   342:          pha
00:AEBD 201C93          	   343:          jsr  PUTSP
00:AEC0 68              	   344:          pla
00:AEC1 AA              	   345:          tax
00:AEC2 A000            	   346: DIS5     ldy  #0
00:AEC4 B137            	   347:          lda  (WORK),Y
00:AEC6 E637            	   348:          inc  WORK
00:AEC8 D002            	   349:          bne  DIS5_A
00:AECA E638            	   350:          inc  WORK+1
                        	   351: DIS5_A   =  *
00:AECC A8              	   352:          tay
00:AECD 8A              	   353:          txa
00:AECE 48              	   354:          pha
00:AECF 98              	   355:          tya
00:AED0 20A692          	   356:          jsr  DISHX
00:AED3 68              	   357:          pla
00:AED4 AA              	   358:          tax
00:AED5 CA              	   359:          dex
00:AED6 D0EA            	   360:          bne  DIS5
00:AED8 60              	   361:          rts
                        	   362: 
                        	   363: ;
                        	   364: ; Ding a bell - however we don't have it on this board
                        	   365: ;
                        	   366: BELL1    =  *
00:AED9 48              	   367:          pha
00:AEDA A900            	   368:          lda  #0
00:AEDC 853F            	   369:          sta  RUNNING
00:AEDE 209192          	   370:          jsr  CROUT
00:AEE1 68              	   371:          pla
00:AEE2 60              	   372:          rts
                        	   373: ;
                        	   374: ;
00:AEE3 20D9AE          	   375: RUNERR   jsr  BELL1
00:AEE6 A9A1            	   376:          lda  #<DM7  ; Error occurred at P-code
00:AEE8 A2AE            	   377:          ldx  #>DM7
00:AEEA 202682          	   378:          jsr  print
00:AEED A54E            	   379:          lda  LASTP+1
00:AEEF 200693          	   380:          jsr  PRBYTE
00:AEF2 A54D            	   381:          lda  LASTP
00:AEF4 20A692          	   382:          jsr  DISHX
                        	   383: EX_FINISHD  =  *
00:AEF7 A900            	   384:          lda  #0
00:AEF9 209192          	   385:          jsr  CROUT
00:AEFC A90E            	   386:          lda  #<FIN_MSG
00:AEFE A2AF            	   387:          ldx  #>FIN_MSG
00:AF00 202682          	   388:          jsr  print
00:AF03 648B            	   389:          stz  serial_in_byte_received  ; get rid of read-ahead
00:AF05 200EC9          	   390:          jsr  GETIN      ; wait till message seen
00:AF08 209192          	   391:          jsr  CROUT      ; output a newline in case they press space or something
00:AF0B 4C44D1          	   392:          jmp  RESTART
                        	   393: ;
00:AF0E 52756E2066696E69	   394: FIN_MSG  asciiz  'Run finished - press a key ...'
00:AF16 73686564202D2070
00:AF1E 726573732061206B
00:AF26 6579202E2E2E
00:AF2C 00
                        	   395: ;
                        	   396: ;
                        	   397: CHK_KBD  =  *
00:AF2D C90E            	   398:          cmp  #KEY_STOP_TRACE       ; Ctrl+N - stop tracing
00:AF2F D008            	   399:          bne  CHK_NOTN
00:AF31 648B            	   400:          stz  serial_in_byte_received
00:AF33 A900            	   401:          lda  #0
00:AF35 8549            	   402:          sta  DBGFLG
00:AF37 38              	   403:          sec
00:AF38 60              	   404:          rts
00:AF39 C914            	   405: CHK_NOTN cmp  #KEY_TRACE      ; Ctrl+T - start tracing
00:AF3B D00A            	   406:          bne  CHK_NOTT
00:AF3D 648B            	   407:          stz  serial_in_byte_received
00:AF3F A980            	   408:          lda  #$80
00:AF41 8549            	   409:          sta  DBGFLG
00:AF43 852E            	   410:          sta  DCODE
00:AF45 38              	   411:          sec
00:AF46 60              	   412:          rts
00:AF47 C904            	   413: CHK_NOTT cmp  #KEY_DEBUG      ; Ctrl+D - start debugging
00:AF49 D00A            	   414:          bne  CHK_NOTD
00:AF4B 648B            	   415:          stz  serial_in_byte_received
00:AF4D A901            	   416:          lda  #1
00:AF4F 8549            	   417:          sta  DBGFLG
00:AF51 852E            	   418:          sta  DCODE
00:AF53 38              	   419:          sec
00:AF54 60              	   420:          rts
00:AF55 18              	   421: CHK_NOTD clc
00:AF56 60              	   422:          rts
                        	   423: ;
                        	   424: EX_OUTCR    =  *
00:AF57 209192          	   425:   jsr  CROUT      ; OUTPUT C/R
00:AF5A 4C6CAF          	   426:   jmp  MAIN
                        	   427: ;
                        	   428: ;  Here for a "low literal" - a P-code with the 0x80 bit set. Clear that bit and push
                        	   429: ;   the resulting number onto the stack
                        	   430: ;
                        	   431: LOWLIT:
00:AF5D E623            	   432:   inc  PCODE     ; increment P-code past the low literal
00:AF5F D002            	   433:   bne  LOWLIT1
00:AF61 E624            	   434:   inc  PCODE+1
                        	   435: LOWLIT1:
00:AF63 8401            	   436:   sty  REG+1     ; Y and REGB were cleared below
00:AF65 297F            	   437:   and  #$7F
00:AF67 8500            	   438:   sta  REG
                        	   439: ;
                        	   440: ;  fall down to push this value
                        	   441: ;
                        	   442: 
                        	   443: 
                        	   444: ;
                        	   445: ; Push previous result (REG) and then drop down to do the next instruction
                        	   446: ;
                        	   447: MAINP:
00:AF69 2049B0          	   448:  jsr  PSHTOP    ; push REG onto stack and go back to MAIN
                        	   449: 
                        	   450: ;
                        	   451: ;  Main interpreter loop - each instruction jumps back here (or to MAINP above if it
                        	   452: ;              needs to push a previous calculation result)
                        	   453: ;
                        	   454: MAIN:
00:AF6C A549            	   455:   lda  DBGFLG   ; debugging?
00:AF6E F003            	   456:   beq  MAIN_2   ; no
00:AF70 20F2AD          	   457:   jsr  DEBUG    ; yes - show debug info
                        	   458: MAIN_2   =  *
                        	   459: ; check if key pressed here, to abort, or turn on/off tracing or debugging
00:AF73 A58B            	   460:   lda  serial_in_byte_received
00:AF75 F00A            	   461:   beq  MAIN_OK
00:AF77 C903            	   462:   cmp  #KEY_ABORT
00:AF79 D003            	   463:   bne  MAIN_NOT_ABORT
00:AF7B 4CF7AE          	   464:   jmp  EX_FINISHD
                        	   465: MAIN_NOT_ABORT = *
00:AF7E 202DAF          	   466:   jsr  CHK_KBD          ; check for turning on trace, debug, etc.
                        	   467: MAIN_OK  =  *
00:AF81 A523            	   468:   lda  PCODE             ; save P-code address as LASTP (for errors I presume)
00:AF83 854D            	   469:   sta  LASTP
00:AF85 A524            	   470:   lda  PCODE+1
00:AF87 854E            	   471:   sta  LASTP+1
                        	   472: ;
                        	   473: ;  now grab the P-code
                        	   474: ;
00:AF89 A000            	   475:   ldy  #0
00:AF8B 8402            	   476:   sty  REGB
00:AF8D B123            	   477:   lda  (PCODE),Y         ; get the P-code from the P-codes
00:AF8F 30CC            	   478:   bmi  LOWLIT            ; low literal - just handle it
00:AF91 C946            	   479:   cmp  #PCODE_LAST+1
00:AF93 B015            	   480:   bcs  EX_INVINS         ; error if off end of table
                        	   481: ;
                        	   482: ;  increment past this P-code
                        	   483: ;
                        	   484: MAIN_5   =  *
00:AF95 E623            	   485:   inc  PCODE
00:AF97 D002            	   486:   bne  MAIN_1
00:AF99 E624            	   487:   inc  PCODE+1
                        	   488: ;
                        	   489: ;  grab the execution handler from the execution_address_table
                        	   490: ;
                        	   491: MAIN_1   =  *
00:AF9B 0A              	   492:   asl  A             ; double the P-code because each address takes 2 bytes
00:AF9C AA              	   493:   tax
00:AF9D BD4BAD          	   494:   lda  execution_address_table,X      ; otherwise get the execution address
00:AFA0 8537            	   495:   sta  WORK
00:AFA2 BD4CAD          	   496:   lda  execution_address_table+1,X    ; and the high-order byte
00:AFA5 8538            	   497:   sta  WORK+1
00:AFA7 6C3700          	   498:   jmp  (WORK)        ; execute the appropriate P-code implementation routine
                        	   499: 
                        	   500: ;
                        	   501: NOTIMP   =  *
                        	   502: EX_INVINS   =  *
00:AFAA A981            	   503:          LDA  #<DM5   ; Illegal Instruction
00:AFAC A2AE            	   504:          LDX  #>DM5
                        	   505: NOTIM1   =  *
00:AFAE 202682          	   506:          JSR  print
00:AFB1 4CE3AE          	   507:          JMP  RUNERR
                        	   508: ;
                        	   509: BREAK    =  *
00:AFB4 A996            	   510:          LDA  #<DM6  ; Break ...
00:AFB6 A2AE            	   511:          LDX  #>DM6
00:AFB8 4CAEAF          	   512:          JMP  NOTIM1
                        	   513: 
                        	   514: 
00:AFBB A000            	   515: GETADR   LDY  #0
00:AFBD B123            	   516:          LDA  (PCODE),Y     ; level
00:AFBF 854B            	   517:          STA  COUNT1        ; count of levels to work through
00:AFC1 A53C            	   518:          LDA  BASE+1        ; start with our stack base address
00:AFC3 A63B            	   519:          LDX  BASE
                        	   520: GET2     =  *
00:AFC5 853E            	   521:          STA  DATA+1        ; our data is relative to the stack base
00:AFC7 863D            	   522:          STX  DATA
00:AFC9 A8              	   523:          TAY
00:AFCA A54B            	   524:          LDA  COUNT1        ; any levels left?
00:AFCC F018            	   525:          BEQ  GETADR1       ; no, we can continue
00:AFCE 38              	   526:          SEC                ; yes
00:AFCF 8A              	   527:          TXA                ; subtract 2 from the base to get the static link
00:AFD0 E902            	   528:          SBC  #2
00:AFD2 8537            	   529:          STA  WORK
00:AFD4 98              	   530:          TYA
00:AFD5 E900            	   531:          SBC  #0
00:AFD7 8538            	   532:          STA  WORK+1        ; BASE - 2 -> WORK
00:AFD9 A000            	   533:          LDY  #0
00:AFDB B137            	   534:          LDA  (WORK),Y      ; grab contents of BASE-2
00:AFDD C8              	   535:          INY
00:AFDE AA              	   536:          TAX
00:AFDF B137            	   537:          LDA  (WORK),Y
00:AFE1 C64B            	   538:          DEC  COUNT1        ; one less level
00:AFE3 4CC5AF          	   539:          JMP  GET2          ; keep going until we used all levels
                        	   540: 
                        	   541: GETADR1     =  *
00:AFE6 A001            	   542:          LDY  #1            ; now get the offset
00:AFE8 18              	   543:          CLC
00:AFE9 B123            	   544:          LDA  (PCODE),Y     ; offset low-order byte
00:AFEB 653D            	   545:          ADC  DATA          ; add base
00:AFED 853D            	   546:          STA  DATA
00:AFEF C8              	   547:          INY
00:AFF0 B123            	   548:          LDA  (PCODE),Y     ; offset high-order byte
00:AFF2 653E            	   549:          ADC  DATA+1        ; add base
00:AFF4 853E            	   550:          STA  DATA+1        ; DATA now holds the data address
00:AFF6 A523            	   551:          LDA  PCODE         ; add 3 to PCODE to skip level and offset
00:AFF8 18              	   552:          CLC
00:AFF9 6903            	   553:          ADC  #3
00:AFFB 8523            	   554:          STA  PCODE
00:AFFD 9002            	   555:          BCC  GET1_A
00:AFFF E624            	   556:          INC  PCODE+1
                        	   557: GET1_A   =  *
00:B001 60              	   558:          RTS                ; done - we can use DATA to access whatever-it-is
                        	   559: 
                        	   560: ;
                        	   561: ;  Pull the top item on the runtime stack into REG (aka VALUE)
                        	   562: ;
                        	   563: PULTOP   =  *
00:B002 A000            	   564:          LDY  #0
00:B004 B131            	   565:          LDA  (T),Y
00:B006 8500            	   566:          STA  REG
00:B008 C8              	   567:          INY
00:B009 B131            	   568:          LDA  (T),Y
00:B00B 8501            	   569:          STA  REG+1
00:B00D C8              	   570:          INY
00:B00E B131            	   571:          LDA  (T),Y
00:B010 8502            	   572:          STA  REGB
00:B012 A531            	   573:          LDA  T
00:B014 18              	   574:          CLC      ; add 3 to the stack because we removed one integer from it
00:B015 6903            	   575:          ADC  #3
00:B017 8531            	   576:          STA  T
00:B019 9002            	   577:          BCC  PUL_END
00:B01B E632            	   578:          INC  T+1
                        	   579: PUL_END  =  *
00:B01D A500            	   580:          LDA  REG
00:B01F A601            	   581:          LDX  REG+1
00:B021 A402            	   582:          LDY  REGB
00:B023 60              	   583:          RTS
                        	   584: 
00:B024 2002B0          	   585: PULBOTH  JSR  PULTOP     ; Pulls both of them - do one and then fall through to do the other
                        	   586: 
                        	   587: ;
                        	   588: ;  Pull the top item on the runtime stack into REG2 (aka VALUE2)
                        	   589: ;
                        	   590: PULTOP2  =  *
00:B027 A000            	   591:          LDY  #0
00:B029 B131            	   592:          LDA  (T),Y
00:B02B 8503            	   593:          STA  REG2
00:B02D C8              	   594:          INY
00:B02E B131            	   595:          LDA  (T),Y
00:B030 8504            	   596:          STA  REG2+1
00:B032 C8              	   597:          INY
00:B033 B131            	   598:          LDA  (T),Y
00:B035 8505            	   599:          STA  REG2B
00:B037 A531            	   600:          LDA  T
00:B039 18              	   601:          CLC         ; add 3 to the stack because we removed one integer from it
00:B03A 6903            	   602:          ADC  #3
00:B03C 8531            	   603:          STA  T
00:B03E 9002            	   604:          BCC  PUL2_END
00:B040 E632            	   605:          INC  T+1
                        	   606: PUL2_END =  *
00:B042 A503            	   607:          LDA  REG2
00:B044 A604            	   608:          LDX  REG2+1
00:B046 A405            	   609:          LDY  REG2B
00:B048 60              	   610:          RTS
                        	   611: 
                        	   612: ;
                        	   613: ;  Push REG (aka VALUE) onto the runtime stack
                        	   614: ;
                        	   615: PSHTOP   =  *
00:B049 38              	   616:          SEC        ;  subtract 3 from the stack because we are about to add one integer to it
00:B04A A531            	   617:          LDA  T
00:B04C E903            	   618:          SBC  #3
00:B04E 8531            	   619:          STA  T
00:B050 B002            	   620:          BCS  PSH1
00:B052 C632            	   621:          DEC  T+1
                        	   622: PSH1     =  *
00:B054 A000            	   623:          LDY  #0
00:B056 A500            	   624:          LDA  REG
00:B058 9131            	   625:          STA  (T),Y
00:B05A C8              	   626:          INY
00:B05B A501            	   627:          LDA  REG+1
00:B05D 9131            	   628:          STA  (T),Y
00:B05F C8              	   629:          INY
00:B060 A502            	   630:          LDA  REGB
00:B062 9131            	   631:          STA  (T),Y
00:B064 60              	   632:          RTS
                        	   633: ;
                        	   634: ;  get a literal (2 bytes) from the P-codes and put it into REG
                        	   635: ;
                        	   636: GETLIT   =  *
00:B065 A000            	   637:   ldy  #0
00:B067 B123            	   638:   lda  (PCODE),Y
00:B069 8500            	   639:   sta  REG
00:B06B C8              	   640:   iny
00:B06C B123            	   641:   lda  (PCODE),Y
00:B06E 8501            	   642:   sta  REG+1
00:B070 A523            	   643:   lda  PCODE
00:B072 18              	   644:   clc         ; P-code address goes up by 2
00:B073 6902            	   645:   adc  #2
00:B075 8523            	   646:   sta  PCODE
00:B077 9002            	   647:   bcc  GET_END
00:B079 E624            	   648:   inc  PCODE+1
                        	   649: GET_END:
00:B07B 60              	   650:   rts
                        	   651: ;
                        	   652: ; load literal onto the stack (the literal is the next 3 bytes after the P-code)
                        	   653: ;
                        	   654: EX_LIT:
00:B07C 2065B0          	   655:   jsr  GETLIT   ; get the first 2 bytes
00:B07F A000            	   656:   ldy  #0
00:B081 B123            	   657:   lda  (PCODE),Y    ; now the third byte
00:B083 8502            	   658:   sta  REGB
00:B085 E623            	   659:   inc  PCODE
00:B087 D002            	   660:   bne  LIT1
00:B089 E624            	   661:   inc  PCODE+1
                        	   662: LIT1:
00:B08B 4C69AF          	   663:   jmp  MAINP    ; now we can push it
                        	   664: ;
                        	   665: ;  Negate (0 - (sp) )
                        	   666: ;
                        	   667: EX_NEG:
00:B08E 2002B0          	   668:   jsr PULTOP
00:B091 201BAC          	   669:   jsr exp_unary_minus
00:B094 4C69AF          	   670:   jmp MAINP
                        	   671: ;
                        	   672: ;  Add (sp) to (sp -1)
                        	   673: ;
                        	   674: EX_ADD:
00:B097 2024B0          	   675:   JSR  PULBOTH
00:B09A 20D4AA          	   676:   jsr  exp_add
00:B09D 4C69AF          	   677:   JMP  MAINP
                        	   678: ;
                        	   679: ;
                        	   680: ;  Add (sp) from (sp - 1)
                        	   681: ;
                        	   682: EX_SUB:
00:B0A0 2027B0          	   683:   JSR  PULTOP2
00:B0A3 2002B0          	   684:   jsr  PULTOP
00:B0A6 20E8AA          	   685:   jsr  exp_subtract
00:B0A9 4C69AF          	   686:   JMP  MAINP
                        	   687: ;
                        	   688: ;  Multiply (sp) by (sp - 1)
                        	   689: ;
                        	   690: EX_MUL:
00:B0AC 2024B0          	   691:   jsr PULBOTH
00:B0AF 20A2AC          	   692:   jsr exp_multiply
00:B0B2 4C69AF          	   693:   jmp MAINP
                        	   694: 
                        	   695: ;
                        	   696: ;  we will take the current key (and return to the user)
                        	   697: ;  and zero it out anyway, so that consumes the key
                        	   698: ;
                        	   699: EX_GETKEY   =  *
00:B0B5 A58B            	   700:   lda  serial_in_byte_received
00:B0B7 648B            	   701:   stz  serial_in_byte_received
00:B0B9 4C0FB1          	   702:   jmp  TRUE2
                        	   703: ;
                        	   704: ;  Modulus (remainder)
                        	   705: ;
                        	   706: EX_MOD:
00:B0BC 2027B0          	   707:   jsr PULTOP2
                        	   708: ;
                        	   709: ;  check for divide by zero because I want a run-time error message
                        	   710: ;
00:B0BF A503            	   711:   lda VALUE2
00:B0C1 0504            	   712:   ora VALUE2+1
00:B0C3 0505            	   713:   ora VALUE2+2
00:B0C5 F009            	   714:   beq EX_DIVIDE_BY_ZERO
00:B0C7 2002B0          	   715:   jsr PULTOP
00:B0CA 203BAD          	   716:   jsr exp_modulo
00:B0CD 4C69AF          	   717:   jmp MAINP
                        	   718: ;
                        	   719: 
                        	   720: EX_DIVIDE_BY_ZERO:
00:B0D0 A9D7            	   721:   lda  #<DIVBY0
00:B0D2 A2B0            	   722:   ldx  #>DIVBY0
00:B0D4 4CAEAF          	   723:   jmp  NOTIM1
                        	   724: 
00:B0D7 4469766964652062	   725: DIVBY0   asciiz  'Divide by zero\n'
00:B0DF 79207A65726F0A
00:B0E6 00
                        	   726: ;
                        	   727: ;  Divide (sp - 1) by (sp)
                        	   728: ;
                        	   729: EX_DIV:
00:B0E7 2027B0          	   730:   jsr PULTOP2
00:B0EA A503            	   731:   lda VALUE2
00:B0EC 0504            	   732:   ora VALUE2+1
00:B0EE 0505            	   733:   ora VALUE2+2
00:B0F0 F0DE            	   734:   beq EX_DIVIDE_BY_ZERO
00:B0F2 2002B0          	   735:   jsr PULTOP
00:B0F5 20DBAC          	   736:   jsr exp_divide
00:B0F8 4C69AF          	   737:   jmp MAINP
                        	   738: 
                        	   739: ;
                        	   740: ;  Absolute value of (sp)
                        	   741: ;
                        	   742: EX_ABS:
00:B0FB 2002B0          	   743:   jsr  PULTOP
00:B0FE 203DAC          	   744:   jsr exp_abs_val
00:B101 4C69AF          	   745:   jmp  MAINP
                        	   746: 
                        	   747: ; Equal
                        	   748: ;
                        	   749: EX_EQL:
00:B104 2024B0          	   750:   jsr PULBOTH
00:B107 200EAB          	   751:   jsr exp_eql
00:B10A 4C69AF          	   752:   jmp MAINP
                        	   753: 
                        	   754: ;
                        	   755: ;  Push 1
                        	   756: ;
                        	   757: TRUE:
00:B10D A901            	   758:   lda  #1
                        	   759: ;
                        	   760: ;  Push A into low-order byte, zero other two bytes
                        	   761: ;
                        	   762: TRUE2:
00:B10F 8500            	   763:   sta  REG
00:B111 A900            	   764:   lda  #0
00:B113 8501            	   765:   sta  REG+1
00:B115 8502            	   766:   sta  REGB
00:B117 4C69AF          	   767:   jmp  MAINP
                        	   768: 
                        	   769: ;
                        	   770: ;  Push 0
                        	   771: ;
                        	   772: FALSE:
00:B11A A900            	   773:   lda  #0
00:B11C 80F1            	   774:   bra TRUE2
                        	   775: ;
                        	   776: ;  Not equal
                        	   777: ;
                        	   778: EX_NEQ:
00:B11E 2024B0          	   779:     jsr PULBOTH
00:B121 2022AB          	   780:     jsr exp_neq
00:B124 4C69AF          	   781:     jmp MAINP
                        	   782: 
                        	   783: ;
                        	   784: ;  Less than
                        	   785: ;
                        	   786: EX_LSS:
00:B127 2027B0          	   787:   jsr PULTOP2
00:B12A 2002B0          	   788:   jsr PULTOP
00:B12D 2036AB          	   789:   jsr exp_less_than
00:B130 4C69AF          	   790:   jmp MAINP
                        	   791: 
                        	   792: ;
                        	   793: ;  Greater than
                        	   794: ;
                        	   795: EX_GTR:
00:B133 2027B0          	   796:   jsr PULTOP2
00:B136 2002B0          	   797:   jsr PULTOP
00:B139 203DAB          	   798:   jsr exp_greater_than
00:B13C 4C69AF          	   799:   jmp MAINP
                        	   800: 
                        	   801: ;
                        	   802: ;  Greater than or equal
                        	   803: ;
                        	   804: EX_GEQ:
00:B13F 2027B0          	   805:   jsr PULTOP2
00:B142 2002B0          	   806:   jsr PULTOP
00:B145 205BAB          	   807:   jsr exp_geq
00:B148 4C69AF          	   808:   jmp MAINP
                        	   809: 
                        	   810: ;
                        	   811: ;  Less than or equal
                        	   812: ;
                        	   813: EX_LEQ:
00:B14B 2027B0          	   814:   jsr PULTOP2
00:B14E 2002B0          	   815:   jsr PULTOP
00:B151 204CAB          	   816:   jsr exp_leq
00:B154 4C69AF          	   817:   jmp MAINP
                        	   818: 
                        	   819: ;
                        	   820: ;  Exclusive OR
                        	   821: ;
                        	   822: EX_XOR:
00:B157 2024B0          	   823:   jsr PULBOTH
00:B15A 208CAB          	   824:   jsr exp_bitwise_xor
00:B15D 4C69AF          	   825:   jmp MAINP
                        	   826: ;
                        	   827: ;  Or
                        	   828: ;
                        	   829: EX_ORR:
00:B160 2024B0          	   830:   jsr PULBOTH
00:B163 2062AB          	   831:   jsr exp_bitwise_or
00:B166 4C69AF          	   832:   jmp MAINP
                        	   833: 
                        	   834: ;
                        	   835: ;  And
                        	   836: ;
                        	   837: EX_AND:
00:B169 2024B0          	   838:   jsr  PULBOTH
00:B16C 2077AB          	   839:   jsr exp_bitwise_and
00:B16F 4C69AF          	   840:   jmp MAINP
                        	   841: 
                        	   842: ;
                        	   843: ;  Not
                        	   844: ;
                        	   845: EX_EOR:
00:B172 2002B0          	   846:   jsr PULTOP
00:B175 200DAC          	   847:   jsr exp_not
00:B178 4C69AF          	   848:   jmp MAINP
                        	   849: ;
                        	   850: ; Shift left
                        	   851: ;
                        	   852: EX_SHL:
00:B17B 2027B0          	   853:   jsr PULTOP2
00:B17E 2002B0          	   854:   jsr PULTOP
00:B181 20C8AB          	   855:   jsr exp_shift_left
00:B184 4C69AF          	   856:   jmp MAINP
                        	   857: 
                        	   858: ;
                        	   859: ;  Shift right
                        	   860: ;
                        	   861: EX_SHR:
00:B187 2027B0          	   862:   jsr PULTOP2
00:B18A 2002B0          	   863:   jsr PULTOP
00:B18D 20E1AB          	   864:   jsr exp_shift_right
00:B190 4C69AF          	   865:   jmp MAINP
                        	   866: 
                        	   867: ;
                        	   868: ;  increment number on top of stack by one
                        	   869: ;
                        	   870: EX_INC:
00:B193 18              	   871:   clc
00:B194 B131            	   872:   lda  (T),Y
00:B196 6901            	   873:   adc  #1
00:B198 9131            	   874:   sta  (T),Y
00:B19A C8              	   875:   iny
00:B19B B131            	   876:   lda  (T),Y
00:B19D 6900            	   877:   adc  #0
00:B19F 9131            	   878:   sta  (T),Y
00:B1A1 C8              	   879:   iny
00:B1A2 B131            	   880:   lda  (T),Y
00:B1A4 6900            	   881:   adc  #0
00:B1A6 9131            	   882:   sta  (T),Y
00:B1A8 4C6CAF          	   883:   jmp  MAIN
                        	   884: ;
                        	   885: ;  decrement number on top of stack by one
                        	   886: ;
                        	   887: 
                        	   888: EX_DEC:
00:B1AB 38              	   889:   sec
00:B1AC B131            	   890:   lda  (T),Y
00:B1AE E901            	   891:   sbc  #1
00:B1B0 9131            	   892:   sta  (T),Y
00:B1B2 C8              	   893:   iny
00:B1B3 B131            	   894:   lda  (T),Y
00:B1B5 E900            	   895:   sbc  #0
00:B1B7 9131            	   896:   sta  (T),Y
00:B1B9 C8              	   897:   iny
00:B1BA B131            	   898:   lda  (T),Y
00:B1BC E900            	   899:   sbc  #0
00:B1BE 9131            	   900:   sta  (T),Y
00:B1C0 4C6CAF          	   901:   jmp  MAIN
                        	   902: 
                        	   903: ;
                        	   904: ;  Copy (sp) to (sp + 1)
                        	   905: ;
                        	   906: EX_MOV:
00:B1C3 B131            	   907:   lda  (T),Y  ; get item at top of stack
00:B1C5 8500            	   908:   sta REG
00:B1C7 C8              	   909:   iny
00:B1C8 B131            	   910:   lda  (T),Y
00:B1CA 8501            	   911:   sta REG+1
00:B1CC C8              	   912:   iny
00:B1CD B131            	   913:   lda  (T),Y
00:B1CF 8502            	   914:   sta REGB
00:B1D1 4C69AF          	   915:   jmp MAINP   ; push it
                        	   916: 
                        	   917: ;
                        	   918: ;  Load a single-character value (variable) onto the stack
                        	   919: ;
                        	   920: 
                        	   921: EX_LODC:
00:B1D4 20BBAF          	   922:   jsr  GETADR
                        	   923: EX_LOD3:
00:B1D7 A002            	   924:   ldy  #2
                        	   925: EX_LOD3_A:
00:B1D9 A900            	   926:   lda  #0      ; since this is a character zero out the high-order bytes
00:B1DB 8501            	   927:   sta  REG+1
00:B1DD 8502            	   928:   sta  REGB
00:B1DF B13D            	   929:   lda  (DATA),Y  ; (DATA) contains the lower-order byte
00:B1E1 8500            	   930:   sta  REG       ; REG will be pushed
00:B1E3 4C69AF          	   931:   jmp  MAINP     ; push REG and go to MAIN
                        	   932: ;
                        	   933: ;  Load a 3-byte value (variable) onto the stack
                        	   934: ;
                        	   935: EX_LOD:
00:B1E6 20BBAF          	   936:   jsr  GETADR
                        	   937: EX_LOD2:
00:B1E9 A000            	   938:   ldy  #0
00:B1EB B13D            	   939:   lda  (DATA),Y    ; (DATA) contains the variable value
00:B1ED 8500            	   940:   sta  REG
00:B1EF C8              	   941:   iny
00:B1F0 B13D            	   942:   lda  (DATA),Y
00:B1F2 8501            	   943:   sta  REG+1
00:B1F4 C8              	   944:   iny
00:B1F5 B13D            	   945:   lda  (DATA),Y
00:B1F7 8502            	   946:   sta REGB
00:B1F9 4C69AF          	   947:   jmp MAINP   ; push it
                        	   948: 
                        	   949: ;
                        	   950: ;  Load absolute address character
                        	   951: ;
                        	   952: EX_LDAC:
00:B1FC 2002B0          	   953:   jsr  PULTOP
00:B1FF 853D            	   954:   sta  DATA
00:B201 863E            	   955:   stx  DATA+1
00:B203 A000            	   956:   ldy  #0
00:B205 F0D2            	   957:   beq  EX_LOD3_A
                        	   958: ;
                        	   959: ;  Load absolute address integer
                        	   960: ;
                        	   961: EX_LDA:
00:B207 2002B0          	   962:   jsr  PULTOP
00:B20A 853D            	   963:   sta  DATA
00:B20C 863E            	   964:   stx  DATA+1
00:B20E 4CE9B1          	   965:   jmp  EX_LOD2
                        	   966: ;
                        	   967: ;  Get address of indexed character
                        	   968: ;
                        	   969: GETIDC:
00:B211 2027B0          	   970:   jsr  PULTOP2    ; pull index into REG2
00:B214 20BBAF          	   971:   jsr  GETADR
00:B217 4C2EB2          	   972:   jmp  GETID2
                        	   973: ;
                        	   974: ;  Get address of indexed integer
                        	   975: ;
                        	   976: GETIDX   =  *
00:B21A 2027B0          	   977:   jsr  PULTOP2  ; pull index into REG2
00:B21D 0603            	   978:   asl  REG2     ; now multiply by 3
00:B21F 2604            	   979:   rol  REG2+1
00:B221 18              	   980:   clc
00:B222 6503            	   981:   adc  REG2
00:B224 8503            	   982:   sta  REG2
00:B226 8A              	   983:   txa
00:B227 6504            	   984:   adc  REG2+1
00:B229 8504            	   985:   sta  REG2+1     ; TIMES 3
00:B22B 20BBAF          	   986:   jsr  GETADR
                        	   987: ;
                        	   988: ;  Get address of indexed integer/character
                        	   989: ;
                        	   990: ;  It looks like arrays expand downwards
                        	   991: ;
                        	   992: GETID2:
00:B22E A53D            	   993:   lda  DATA     ; initial address
00:B230 38              	   994:   sec           ; subtract subscript
00:B231 E503            	   995:   sbc  REG2
00:B233 853D            	   996:   sta  DATA
00:B235 A53E            	   997:   lda  DATA+1
00:B237 E504            	   998:   sbc  REG2+1
00:B239 853E            	   999:   sta  DATA+1
00:B23B 60              	  1000:   rts
                        	  1001: ;
                        	  1002: ;  Load indexed character
                        	  1003: ;
                        	  1004: EX_LDIC:
00:B23C 2011B2          	  1005:   jsr  GETIDC
00:B23F 4CD7B1          	  1006:   jmp  EX_LOD3
                        	  1007: ;
                        	  1008: ;  Load indexed integer
                        	  1009: ;
                        	  1010: EX_LDI:
00:B242 201AB2          	  1011:   jsr  GETIDX
00:B245 4CE9B1          	  1012:   jmp  EX_LOD2
                        	  1013: ;
                        	  1014: ;  Store character
                        	  1015: ;
                        	  1016: EX_STOC:
00:B248 20BBAF          	  1017:   jsr  GETADR
00:B24B 2002B0          	  1018:   jsr  PULTOP
00:B24E A002            	  1019:   ldy  #2   ; why?
                        	  1020: EX_STO5:
00:B250 913D            	  1021:   sta  (DATA),Y
00:B252 4C6CAF          	  1022:   jmp  MAIN
                        	  1023: ;
                        	  1024: ;  Store integer
                        	  1025: ;
                        	  1026: EX_STO:
00:B255 20BBAF          	  1027:   jsr  GETADR   ; get its address
00:B258 2002B0          	  1028:   jsr  PULTOP   ; get the value to store
                        	  1029: EX_STO2:
00:B25B A000            	  1030:   ldy  #0
00:B25D 913D            	  1031:   sta  (DATA),Y
00:B25F C8              	  1032:   iny
00:B260 8A              	  1033:   txa
00:B261 913D            	  1034:   sta  (DATA),Y
00:B263 A502            	  1035:   lda  REGB
00:B265 C8              	  1036:   iny
00:B266 D0E8            	  1037:   bne  EX_STO5
                        	  1038: ;
                        	  1039: ;  Store integer at absolute address
                        	  1040: ;
                        	  1041: EX_STA:
00:B268 2024B0          	  1042:   jsr  PULBOTH  ; get address into REG2 and value into REG
00:B26B A000            	  1043:   ldy  #0
00:B26D A500            	  1044:   lda  REG
00:B26F 9103            	  1045:   sta  (REG2),Y
00:B271 C8              	  1046:   iny
00:B272 A501            	  1047:   lda  REG+1
00:B274 9103            	  1048:   sta  (REG2),Y
00:B276 C8              	  1049:   iny
00:B277 A502            	  1050:   lda  REGB
                        	  1051: EX_STA5:
00:B279 9103            	  1052:   sta  (REG2),Y
00:B27B 4C6CAF          	  1053:   jmp  MAIN
                        	  1054: ;
                        	  1055: ;  Store character at absolute address
                        	  1056: ;
                        	  1057: EX_STAC:
00:B27E 2024B0          	  1058:   jsr  PULBOTH  ; get address into REG2 and value into REG
00:B281 A500            	  1059:   lda  REG
00:B283 A000            	  1060:   ldy  #0
00:B285 F0F2            	  1061:   beq  EX_STA5
                        	  1062: ;
                        	  1063: ;     Store character indexed
                        	  1064: ;
                        	  1065: EX_STIC:
00:B287 2002B0          	  1066:   jsr  PULTOP
00:B28A 8545            	  1067:   sta  TEMP
00:B28C 2011B2          	  1068:   jsr  GETIDC
00:B28F A545            	  1069:   lda  TEMP
00:B291 A002            	  1070:   ldy  #2
00:B293 D0BB            	  1071:   bne  EX_STO5
                        	  1072: ;
                        	  1073: ;     Store integer indexed
                        	  1074: ;
                        	  1075: EX_STI :
00:B295 2002B0          	  1076:   jsr  PULTOP
00:B298 8545            	  1077:   sta  TEMP
00:B29A 8646            	  1078:   stx  TEMP+1
00:B29C 98              	  1079:   tya
00:B29D 48              	  1080:   pha
00:B29E 201AB2          	  1081:   jsr  GETIDX
00:B2A1 A000            	  1082:   ldy  #0
00:B2A3 A545            	  1083:   lda  TEMP
00:B2A5 913D            	  1084:   sta  (DATA),Y
00:B2A7 A546            	  1085:   lda  TEMP+1
00:B2A9 C8              	  1086:   iny
00:B2AA 913D            	  1087:   sta  (DATA),Y
00:B2AC 68              	  1088:   pla
00:B2AD C8              	  1089:   iny
00:B2AE D0A0            	  1090:   bne  EX_STO5
                        	  1091: ;
                        	  1092: ;  Procedure/function return
                        	  1093: ;
                        	  1094: ;  Stack frame linkage data:
                        	  1095: ;
                        	  1096: ;    (from low to high address)
                        	  1097: ;
                        	  1098: ;    Return address <-- P-code to return to when function/procedure exits
                        	  1099: ;    Dynamic link   <-- The previous stack frame from the earlier function call
                        	  1100: ;    Static link    <-- The stack frame of the previous static function
                        	  1101: ;
                        	  1102: ;  Static and dynamic links will be the same except for recursive calls.
                        	  1103: ;
                        	  1104: ;  To unwind the stack we have to go back to the previous dynamic link (on a return)
                        	  1105: ;
                        	  1106: ;  However to find variables in previous lexical declarations we have to use the static link.
                        	  1107: ;
                        	  1108: ;
                        	  1109: EX_RTN:
                        	  1110: ;
                        	  1111: ;  Subtract 6 from the base address, put result into WORK
                        	  1112: ;
00:B2B0 38              	  1113:   sec
00:B2B1 A53B            	  1114:   lda  BASE
00:B2B3 E906            	  1115:   sbc  #6
00:B2B5 8537            	  1116:   sta  WORK
00:B2B7 A53C            	  1117:   lda  BASE+1
00:B2B9 E900            	  1118:   sbc  #0
00:B2BB 8538            	  1119:   sta  WORK+1
                        	  1120: ;
                        	  1121: ;  The return address was at the bottom of BASE, so put that into PCODE
                        	  1122: ;
00:B2BD A000            	  1123:   ldy  #0
00:B2BF B137            	  1124:   lda  (WORK),Y
00:B2C1 8523            	  1125:   sta  PCODE
00:B2C3 C8              	  1126:   iny
00:B2C4 B137            	  1127:   lda  (WORK),Y
00:B2C6 8524            	  1128:   sta  PCODE+1
                        	  1129: 
                        	  1130: ;
                        	  1131: ;  The base address becomes our new top of runtime stack
                        	  1132: ;
00:B2C8 A53C            	  1133:   lda  BASE+1
00:B2CA 8532            	  1134:   sta  T+1
00:B2CC A53B            	  1135:   lda  BASE
00:B2CE 8531            	  1136:   sta  T
                        	  1137: ;
                        	  1138: ;  The dynamic stack frame address is 4 bytes down from the BASE - put that into WORK
                        	  1139: ;
00:B2D0 38              	  1140:   sec
00:B2D1 E904            	  1141:   sbc  #4
00:B2D3 8537            	  1142:   sta  WORK
00:B2D5 A53C            	  1143:   lda  BASE+1
00:B2D7 E900            	  1144:   sbc  #0
00:B2D9 8538            	  1145:   sta  WORK+1
                        	  1146: ;
                        	  1147: ;  Get the previous dynamic stack frame address and put it into BASE (in case of
                        	  1148: ;   recursive function calls)
                        	  1149: ;
00:B2DB A000            	  1150:   ldy  #0
00:B2DD B137            	  1151:   lda  (WORK),Y
00:B2DF 853B            	  1152:   sta  BASE
00:B2E1 C8              	  1153:   iny
00:B2E2 B137            	  1154:   lda  (WORK),Y
00:B2E4 853C            	  1155:   sta  BASE+1
                        	  1156: ;
                        	  1157: ;  Stack, base and Pcode all changed, ready for next instruction
                        	  1158: ;
00:B2E6 4C6CAF          	  1159:   jmp  MAIN
                        	  1160: 
                        	  1161: ;
                        	  1162: ; Input a number into a variable
                        	  1163: ;
                        	  1164: EX_INP      =  *
00:B2E9 A980            	  1165:   lda #$80
00:B2EB 853F            	  1166:   sta  RUNNING
00:B2ED 20F093          	  1167:   JSR  GET_LINE
00:B2F0 AD0002          	  1168:   lda  INBUF
00:B2F3 C903            	  1169:   cmp  #KEY_ABORT   ; check for aborting with Ctrl+C
00:B2F5 D003            	  1170:   bne  EX_INP_OK
00:B2F7 4C44B5          	  1171:   jmp  ex_input_aborted
                        	  1172: 
                        	  1173: EX_INP_OK:
00:B2FA A900            	  1174:   lda #<INBUF
00:B2FC 858E            	  1175:   sta token_start
00:B2FE A902            	  1176:   lda #>INBUF
00:B300 858F            	  1177:   sta token_start+1
00:B302 6493            	  1178:   stz token_type
00:B304 208CC9          	  1179:   jsr get_token
00:B307 C94E            	  1180:   cmp #TOKEN_NUMBER
00:B309 D016            	  1181:   bne BAD_INP
00:B30B A694            	  1182:   LDX  token_value
00:B30D A495            	  1183:   LDY  token_value+1
00:B30F A596            	  1184:   LDA  token_value+2
                        	  1185: INP3:
00:B311 8401            	  1186:   sty  REG+1
00:B313 8600            	  1187:   stx  REG
00:B315 8502            	  1188:   sta  REGB
00:B317 2049B0          	  1189:   jsr  PSHTOP
00:B31A A20C            	  1190:   ldx  #12
00:B31C 863F            	  1191:   stx  RUNNING
00:B31E 4C6CAF          	  1192:   jmp  MAIN
                        	  1193: ;
                        	  1194: ;  bad number: set it to $800000
                        	  1195: ;
                        	  1196: BAD_INP:
00:B321 A980            	  1197:   lda #$80
00:B323 A200            	  1198:   ldx #0
00:B325 A000            	  1199:   ldy #0
00:B327 F0E8            	  1200:   beq INP3
                        	  1201: ;
                        	  1202: ; write a number to output
                        	  1203: ;
                        	  1204: EX_OUT:
00:B329 20F8C8          	  1205:   jsr write_to_serial
00:B32C 8003            	  1206:   bra OUT_COMMON
                        	  1207: 
                        	  1208: EX_LCD_WRITE_NUM:
00:B32E 2003C9          	  1209:   jsr write_to_lcd
                        	  1210: 
                        	  1211: OUT_COMMON:
00:B331 2002B0          	  1212:   jsr  PULTOP
00:B334 20BB91          	  1213:   jsr  display_in_decimal
00:B337 20F8C8          	  1214:   jsr  write_to_serial
00:B33A 4C6CAF          	  1215:   jmp  MAIN
                        	  1216: ;
                        	  1217: ;
                        	  1218: ; Output 6 hex characters (3 bytes)
                        	  1219: ;
                        	  1220: EX_OUH:
00:B33D 20F8C8          	  1221:   jsr write_to_serial
00:B340 8003            	  1222:   bra EX_OUH_COMMON
                        	  1223: 
                        	  1224: EX_LCD_WRITE_HEX:
00:B342 2003C9          	  1225:   jsr write_to_lcd
                        	  1226: 
                        	  1227: EX_OUH_COMMON:
00:B345 2002B0          	  1228:   jsr  PULTOP
00:B348 A502            	  1229:   lda  REGB
00:B34A 200693          	  1230:   jsr  PRBYTE
00:B34D A501            	  1231:   lda  REG+1
00:B34F 200693          	  1232:   jsr  PRBYTE
00:B352 A500            	  1233:   lda  REG
00:B354 200693          	  1234:   jsr  PRBYTE
00:B357 20F8C8          	  1235:   jsr  write_to_serial
00:B35A 4C6CAF          	  1236:   jmp  MAIN
                        	  1237: ;
                        	  1238: ;  write a string to output
                        	  1239: ;
                        	  1240: EX_OUS      =  *
00:B35D 20F8C8          	  1241:   jsr write_to_serial
00:B360 8003            	  1242:   bra EX_OUS_COMMON
                        	  1243: 
                        	  1244: EX_LCD_WRITE_STR:
00:B362 2003C9          	  1245:   jsr write_to_lcd
                        	  1246: 
                        	  1247: EX_OUS_COMMON:
00:B365 A523            	  1248:   lda  PCODE
00:B367 18              	  1249:   clc
00:B368 6901            	  1250:   adc  #1
00:B36A 8537            	  1251:   sta  WORK
00:B36C A524            	  1252:   lda  PCODE+1
00:B36E 6900            	  1253:   adc  #0
00:B370 8538            	  1254:   sta  WORK+1
00:B372 B123            	  1255:   lda  (PCODE),Y
00:B374 854B            	  1256:   sta  COUNT1     ; NO. OF CHARS
00:B376 18              	  1257:   clc
00:B377 6901            	  1258:   adc  #1
00:B379 6523            	  1259:   adc  PCODE
00:B37B 8523            	  1260:   sta  PCODE
00:B37D 9002            	  1261:   bcc  EX_OUS1
00:B37F E624            	  1262:   inc  PCODE+1
                        	  1263: EX_OUS1:
00:B381 A537            	  1264:   lda  WORK
00:B383 A638            	  1265:   ldx  WORK+1
00:B385 A44B            	  1266:   ldy  COUNT1
00:B387 202093          	  1267:   jsr  PT
00:B38A 20F8C8          	  1268:   jsr write_to_serial
00:B38D 4C6CAF          	  1269:   jmp  MAIN
                        	  1270: 
                        	  1271: 
                        	  1272: 
                        	  1273: ;
                        	  1274: ;  Stack frame linkage data:
                        	  1275: ;
                        	  1276: ;    (from low to high address)
                        	  1277: ;
                        	  1278: ;    Return address <-- P-code to return to when function/procedure exits
                        	  1279: ;    Dynamic link   <-- The previous stack frame from the earlier function call
                        	  1280: ;    Static link    <-- The stack frame of the previous static function
                        	  1281: ;
                        	  1282: ;  Static and dynamic links will be the same except for recursive calls.
                        	  1283: ;
                        	  1284: ;  To unwind the stack we have to go back to the previous dynamic link (on a return)
                        	  1285: ;
                        	  1286: ;  However to find variables in previous lexical declarations we have to use the static link.
                        	  1287: ;
                        	  1288: ;
                        	  1289: ; Call absolute procedure - I don't think this is used in this version TBH
                        	  1290: ;
                        	  1291: ; Note: Y is zero when entering
                        	  1292: ;
                        	  1293: EX_ABSCLL   =  *
00:B390 8447            	  1294:   sty  CALL      ; zero out address to be called
00:B392 8448            	  1295:   sty  CALL+1    ; (offset therefore becomes absolute address)
00:B394 4C9FB3          	  1296:   jmp  EX_CLL_A
                        	  1297: ;
                        	  1298: ; Call relative procedure
                        	  1299: ;
                        	  1300: ; Note: Y is zero when entering
                        	  1301: ;
                        	  1302: EX_CLL      =  *
00:B397 A54D            	  1303:   lda  LASTP
00:B399 8547            	  1304:   sta  CALL
00:B39B A54E            	  1305:   lda  LASTP+1
00:B39D 8548            	  1306:   sta  CALL+1
                        	  1307: EX_CLL_A    =  *
00:B39F B123            	  1308:   lda  (PCODE),Y     ; level
00:B3A1 854B            	  1309:   sta  COUNT1
00:B3A3 C8              	  1310:   iny
00:B3A4 18              	  1311:   clc
00:B3A5 B123            	  1312:   lda  (PCODE),Y     ; relative address
00:B3A7 6547            	  1313:   adc  CALL          ; add to current P-code address
00:B3A9 8547            	  1314:   sta  CALL
00:B3AB C8              	  1315:   iny
00:B3AC B123            	  1316:   lda  (PCODE),Y
00:B3AE 6548            	  1317:   adc  CALL+1
00:B3B0 8548            	  1318:   sta  CALL+1
00:B3B2 A523            	  1319:   lda  PCODE         ; add 3 to P-code to bypass level / address
00:B3B4 18              	  1320:   clc                ; this will become our return address
00:B3B5 6903            	  1321:   adc  #3
00:B3B7 8523            	  1322:   sta  PCODE
00:B3B9 9002            	  1323:   bcc  EX_CLL4
00:B3BB E624            	  1324:   inc  PCODE+1
                        	  1325: EX_CLL4     =  *
00:B3BD A53C            	  1326:   lda  BASE+1
00:B3BF A63B            	  1327:   ldx  BASE
                        	  1328: EX_CLL2     =  *
00:B3C1 853E            	  1329:   sta  DATA+1      ; this was BASE
00:B3C3 863D            	  1330:   stx  DATA
00:B3C5 A8              	  1331:   tay
00:B3C6 A54B            	  1332:   lda  COUNT1      ; this was the level
00:B3C8 F018            	  1333:   beq  EX_CLL3
00:B3CA 38              	  1334:   sec
00:B3CB 8A              	  1335:   txa
00:B3CC E902            	  1336:   sbc  #2          ; subtract 2 from BASE, store in WORK
00:B3CE 8537            	  1337:   sta  WORK
00:B3D0 98              	  1338:   tya
00:B3D1 E900            	  1339:   sbc  #0
00:B3D3 8538            	  1340:   sta  WORK+1
00:B3D5 A000            	  1341:   ldy  #0
00:B3D7 B137            	  1342:   lda  (WORK),Y
00:B3D9 C8              	  1343:   iny
00:B3DA AA              	  1344:   tax
00:B3DB B137            	  1345:   lda  (WORK),Y
00:B3DD C64B            	  1346:   dec  COUNT1
00:B3DF 4CC1B3          	  1347:   jmp  EX_CLL2
                        	  1348: EX_CLL3     =  *
00:B3E2 A531            	  1349:   lda  T         ; our stack pointer
00:B3E4 8545            	  1350:   sta  TEMP      ; save it
00:B3E6 A532            	  1351:   lda  T+1
00:B3E8 8546            	  1352:   sta  TEMP+1
                        	  1353: ;
                        	  1354: ; this is as confusing as all-get-out but it looks like we
                        	  1355: ; are pushing onto the stack: DATA / BASE / PCODE (return address)
                        	  1356: ;  (which is why we saved T into TEMP so it didn't change during the pushes)
                        	  1357: ;
                        	  1358: 
00:B3EA A53D            	  1359:   lda  DATA      ; put DATA into REG
00:B3EC 8501            	  1360:   sta  REG+1
00:B3EE A53E            	  1361:   lda  DATA+1
00:B3F0 8502            	  1362:   sta  REGB
00:B3F2 A53C            	  1363:   lda  BASE+1
00:B3F4 8500            	  1364:   sta  REG
00:B3F6 2049B0          	  1365:   jsr  PSHTOP      ; push REG (DATA + BASE[1])
00:B3F9 A53B            	  1366:   lda  BASE
00:B3FB 8502            	  1367:   sta  REGB
00:B3FD A545            	  1368:   lda  TEMP        ; old stack pointer
00:B3FF 853B            	  1369:   sta  BASE        ; becomes BASE
00:B401 A546            	  1370:   lda  TEMP+1      ; ditto for other byte
00:B403 853C            	  1371:   sta  BASE+1
00:B405 A523            	  1372:   lda  PCODE       ; get ready to push current P-Code
00:B407 8500            	  1373:   sta  REG
00:B409 A524            	  1374:   lda  PCODE+1
00:B40B 8501            	  1375:   sta  REG+1
00:B40D 2049B0          	  1376:   jsr  PSHTOP     ; push REG (BASE[0] + PCODE)
00:B410 A547            	  1377:   lda  CALL       ; now get the address of the place we want to call
00:B412 8523            	  1378:   sta  PCODE      ; and put it into PCODE
00:B414 A548            	  1379:   lda  CALL+1
00:B416 8524            	  1380:   sta  PCODE+1
00:B418 18              	  1381:   clc             ; add 6 to the stack pointer because we later emit the code to INT 6 (leave room for base stuff)
00:B419 A531            	  1382:   lda  T
00:B41B 6906            	  1383:   adc  #6
00:B41D 8531            	  1384:   sta  T
00:B41F 9002            	  1385:   bcc  EX_CLL5
00:B421 E632            	  1386:   inc  T+1
                        	  1387: EX_CLL5     =  *
00:B423 4C6CAF          	  1388:   jmp  MAIN        ; we are done, MAIN will now go to the called subroutine
                        	  1389: ;
                        	  1390: ;  Here for calling machine code from Pascal
                        	  1391: ;
                        	  1392: EX_CLA:
00:B426 2002B0          	  1393:   jsr  PULTOP      ; pull the address to be called from the stack
00:B429 A513            	  1394:   lda  call_p      ; status register
00:B42B 48              	  1395:   pha
00:B42C A510            	  1396:   lda  call_a      ; A register
00:B42E A611            	  1397:   ldx  call_x      ; X register
00:B430 A412            	  1398:   ldy  call_y      ; Y register
00:B432 28              	  1399:   plp              ; get status register back
00:B433 2043B4          	  1400:   jsr  EX_CLL_JMP  ; call the subroutine
00:B436 08              	  1401:   php              ; save the status register
00:B437 8510            	  1402:   sta  call_a      ; store the A/X/Y register
00:B439 8611            	  1403:   stx  call_x
00:B43B 8412            	  1404:   sty  call_y
00:B43D 68              	  1405:   pla              ; get status register back
00:B43E 8513            	  1406:   sta  call_p      ; save it
00:B440 4C6CAF          	  1407:   jmp  MAIN        ; done!
                        	  1408: 
00:B443 6C0000          	  1409: EX_CLL_JMP  jmp  (REG)
                        	  1410: ;
                        	  1411: ;
                        	  1412: ; increment stack pointer (that is, subtract the literal from it, as it grows downwards)
                        	  1413: ;
                        	  1414: EX_INT:
00:B446 2065B0          	  1415:   jsr  GETLIT
00:B449 38              	  1416:   sec
00:B44A A531            	  1417:   lda  T
00:B44C E500            	  1418:   sbc  REG
00:B44E 8531            	  1419:   sta  T
00:B450 A532            	  1420:   lda  T+1
00:B452 E501            	  1421:   sbc  REG+1
00:B454 8532            	  1422:   sta  T+1
00:B456 C544            	  1423:   cmp  END_PCD+1
00:B458 9003            	  1424:   bcc  INT_ERR
00:B45A 4C6CAF          	  1425:   jmp  MAIN
                        	  1426: ;
                        	  1427: INT_ERR  =  *
00:B45D A964            	  1428:   lda  #<INT_ERRM    ; stack full
00:B45F A2B4            	  1429:   ldx  #>INT_ERRM
00:B461 4CAEAF          	  1430:   jmp  NOTIM1
                        	  1431: ;
00:B464 537461636B206675	  1432: INT_ERRM asciiz "Stack full\n"    ; stack full
00:B46C 6C6C0A
00:B46F 00
                        	  1433: ;
                        	  1434: 
                        	  1435: ;
                        	  1436: ;  Change the runtime stack to the address given (assuming stack is empty)
                        	  1437: ;   Done by the {%S nnnn} compiler directive.
                        	  1438: ;
                        	  1439: EX_NEW_STACK:
00:B470 2065B0          	  1440:   jsr GETLIT
00:B473 A500            	  1441:   lda REG
00:B475 8531            	  1442:   sta T
00:B477 853B            	  1443:   sta BASE
00:B479 A501            	  1444:   lda REG+1
00:B47B 8532            	  1445:   sta T+1
00:B47D 853C            	  1446:   sta BASE+1
00:B47F 4C6CAF          	  1447:   jmp MAIN
                        	  1448: 
                        	  1449: ;
                        	  1450: ;  Jump to the address following the P-code
                        	  1451: ;
                        	  1452: EX_JMP:
00:B482 2065B0          	  1453:   jsr  GETLIT   ; get the address
00:B485 18              	  1454:   clc
00:B486 A500            	  1455:   lda  REG
00:B488 654D            	  1456:   adc  LASTP
00:B48A 8523            	  1457:   sta  PCODE
00:B48C A501            	  1458:   lda  REG+1
00:B48E 654E            	  1459:   adc  LASTP+1
00:B490 8524            	  1460:   sta  PCODE+1
00:B492 4C6CAF          	  1461:   jmp  MAIN
                        	  1462: ;
                        	  1463: ;  Jump if the top of the stack is zero
                        	  1464: ;
                        	  1465: EX_JMZ:
00:B495 2002B0          	  1466:   jsr  PULTOP   ; puts REG into A
00:B498 0501            	  1467:   ora  REG+1
00:B49A 0502            	  1468:   ora  REGB
00:B49C D002            	  1469:   bne  EX_NOJUMP
00:B49E F0E2            	  1470:   beq  EX_JMP
                        	  1471: ;
                        	  1472: ;  Don't jump, just move past the address (TODO: just add 2?)
                        	  1473: ;
                        	  1474: EX_NOJUMP:
00:B4A0 2065B0          	  1475:   jsr  GETLIT
00:B4A3 4C6CAF          	  1476:   jmp  MAIN
                        	  1477: ;
                        	  1478: ;  Jump if the top of the stack is non-zero
                        	  1479: ;
                        	  1480: EX_JM1:
00:B4A6 2002B0          	  1481:   jsr  PULTOP    ; puts REG into A
00:B4A9 0501            	  1482:   ora  REG+1
00:B4AB 0502            	  1483:   ora  REGB
00:B4AD D0D3            	  1484:   bne  EX_JMP
00:B4AF F0EF            	  1485:   beq  EX_NOJUMP
                        	  1486: ;
                        	  1487: ;
                        	  1488: EX_INPC:
00:B4B1 200EC9          	  1489:   jsr GETIN
00:B4B4 C903            	  1490:   cmp  #KEY_ABORT   ; check for aborting with Ctrl+C
00:B4B6 D003            	  1491:   bne  EX_INPC_OK
00:B4B8 4C44B5          	  1492:   jmp  ex_input_aborted
                        	  1493: 
                        	  1494: EX_INPC_OK:
00:B4BB 202DAF          	  1495:   jsr CHK_KBD
00:B4BE B0F1            	  1496:   bcs EX_INPC
00:B4C0 8500            	  1497:   sta REG
00:B4C2 A900            	  1498:   lda #0
00:B4C4 8501            	  1499:   sta REG+1
00:B4C6 8502            	  1500:   sta REGB
00:B4C8 4C69AF          	  1501:   jmp  MAINP
                        	  1502: ;
                        	  1503: EX_OUTC:
00:B4CB 20F8C8          	  1504:   jsr write_to_serial
00:B4CE 8003            	  1505:   bra EX_OUTC_COMMON
                        	  1506: 
                        	  1507: EX_LCD_WRITE_CHR:
00:B4D0 2003C9          	  1508:   jsr write_to_lcd
                        	  1509: 
                        	  1510: EX_OUTC_COMMON:
00:B4D3 2002B0          	  1511:   jsr  PULTOP
00:B4D6 A500            	  1512:   lda  REG
00:B4D8 201894          	  1513:   jsr  COUT
00:B4DB 20F8C8          	  1514:   jsr write_to_serial
00:B4DE 4C6CAF          	  1515:   jmp  MAIN
                        	  1516:   ;
                        	  1517: 
                        	  1518: EX_LCDHOME:
00:B4E1 20F6B8          	  1519:   jsr lcd_home
00:B4E4 4C6CAF          	  1520:   JMP MAIN
                        	  1521: 
                        	  1522: 
                        	  1523: EX_LCDCLEAR:
00:B4E7 20E6B8          	  1524:   jsr lcd_clear_display
00:B4EA 4C6CAF          	  1525:   JMP MAIN
                        	  1526: 
                        	  1527: EX_INS      =  *
00:B4ED B123            	  1528:   lda  (PCODE),Y   ; wanted length
00:B4EF 8545            	  1529:   sta  TEMP
00:B4F1 E623            	  1530:   inc  PCODE
00:B4F3 D002            	  1531:   bne  EX_INS3
00:B4F5 E624            	  1532:   inc  PCODE+1
                        	  1533: EX_INS3     =  *
00:B4F7 20F093          	  1534:   jsr  GET_LINE
00:B4FA AD0002          	  1535:   lda  INBUF
00:B4FD C903            	  1536:   cmp  #KEY_ABORT     ; check for them aborting the run on input
00:B4FF F043            	  1537:   beq  ex_input_aborted
00:B501 202DAF          	  1538:   jsr  CHK_KBD
00:B504 B0F1            	  1539:   bcs  EX_INS3      ; we turned on/off tracing etc, ignore this line
00:B506 98              	  1540:   tya               ; length of line
00:B507 18              	  1541:   clc
00:B508 6901            	  1542:   adc  #1        ; why?
00:B50A C545            	  1543:   cmp  TEMP
00:B50C 9002            	  1544:   bcc  EX_INS1
00:B50E A545            	  1545:   lda  TEMP      ; use max allowed length rather than received length
                        	  1546: EX_INS1     =  *
00:B510 8546            	  1547:   sta  TEMP+1    ; this is the length we are copying
00:B512 20BBAF          	  1548:   jsr  GETADR    ; get address to put the line
00:B515 A003            	  1549:   ldy  #3        ; why?
00:B517 A200            	  1550:   ldx  #0
                        	  1551: ;
                        	  1552: ;  copying loop - arrays are stored downwards, so we subtract from DATA each time
                        	  1553: ;
                        	  1554: EX_INS2     =  *
00:B519 C63D            	  1555:   dec  DATA
00:B51B A53D            	  1556:   lda  DATA
00:B51D C9FF            	  1557:   cmp  #$FF
00:B51F D002            	  1558:   bne  EX_INS4
00:B521 C63E            	  1559:   dec  DATA+1
                        	  1560: EX_INS4     =  *
00:B523 BD0002          	  1561:   lda  INBUF,X
00:B526 913D            	  1562:   sta  (DATA),Y
00:B528 E8              	  1563:   inx
00:B529 C646            	  1564:   dec  TEMP+1      ; count of bytes to copy
00:B52B D0EC            	  1565:   bne  EX_INS2
00:B52D 4C6CAF          	  1566:   jmp  MAIN        ; stop now
                        	  1567:   ;
                        	  1568: 
00:B530 0A45786563757469	  1569: execution_aborted_message asciiz "\nExecution aborted\n"
00:B538 6F6E2061626F7274
00:B540 65640A
00:B543 00
                        	  1570: 
                        	  1571: ex_input_aborted:
00:B544 A930            	  1572:   lda #<execution_aborted_message
00:B546 A2B5            	  1573:   ldx #>execution_aborted_message
00:B548 4CAEAF          	  1574:   jmp NOTIM1
                        	  1575: ;
                        	  1576: ;
                        	  1577: EX_ADRNC    =  *
00:B54B 20BBAF          	  1578:   jsr  GETADR
                        	  1579: EX_ADRNC2   =  *
00:B54E A53D            	  1580:   lda  DATA
00:B550 18              	  1581:   clc
00:B551 6902            	  1582:   adc  #2
00:B553 853D            	  1583:   sta  DATA
00:B555 9007            	  1584:   bcc  EX_ADRN2
00:B557 E63E            	  1585:   inc  DATA+1
00:B559 B003            	  1586:   bcs  EX_ADRN2
                        	  1587: EX_ADRNN    =  *
00:B55B 20BBAF          	  1588:   jsr  GETADR
                        	  1589: EX_ADRN2    =  *
00:B55E A53D            	  1590:   lda  DATA
00:B560 8500            	  1591:   sta  REG
00:B562 A53E            	  1592:   lda  DATA+1
00:B564 8501            	  1593:   sta  REG+1
00:B566 4C69AF          	  1594:   jmp  MAINP
                        	  1595: ;
                        	  1596: EX_ADRAN    =  *
00:B569 201AB2          	  1597:   jsr  GETIDX
00:B56C 4C5EB5          	  1598:   jmp  EX_ADRN2
                        	  1599: ;
                        	  1600: EX_ADRAC    =  *
00:B56F 2011B2          	  1601:    jsr  GETIDC
00:B572 4C4EB5          	  1602:    jmp  EX_ADRNC2
                        	  1603: ;
                        	  1604: ;
                        	  1605: ;
                        	  1606: 
                        	  1607: 
                        	  1608: ;
                        	  1609: ;  DIGITALREAD (pin) pin:0 to 15; pushes 0 or 1
                        	  1610: ;
                        	  1611: EX_DIGITALREAD = *
00:B575 2002B0          	  1612:   jsr PULTOP  ; which pin
00:B578 20DBC8          	  1613:   jsr digitalread
00:B57B D003            	  1614:   bne EX_DIGITALREAD_ONE
00:B57D 4C1AB1          	  1615:   jmp FALSE
                        	  1616: EX_DIGITALREAD_ONE:
00:B580 4C0DB1          	  1617:   jmp TRUE    ; done
                        	  1618: 
                        	  1619: ;
                        	  1620: ;  LCDPOS (line, column)
                        	  1621: ;
                        	  1622: 
                        	  1623: EX_LCDPOS = *
00:B583 2002B0          	  1624:   jsr PULTOP   ; x
00:B586 290F            	  1625:   and #$0F     ; max 15
00:B588 858C            	  1626:   sta hardware_work  ; save it
00:B58A 2002B0          	  1627:   jsr PULTOP   ; y
00:B58D 2901            	  1628:   and #1       ; can be 0 or 1
00:B58F F002            	  1629:   beq EX_LCDPOS_1
00:B591 A940            	  1630:   lda #$40
                        	  1631: EX_LCDPOS_1:
00:B593 058C            	  1632:   ora hardware_work  ; or in the column
00:B595 0980            	  1633:   ora #$80     ; command to set the address
00:B597 2092B8          	  1634:   jsr lcd_instruction
00:B59A 4C6CAF          	  1635:   jmp MAIN
                        	  1636: 
                        	  1637: ;
                        	  1638: ;  RANDOM
                        	  1639: ;
                        	  1640: EX_RANDOM:
00:B59D 204390          	  1641:   jsr gen_random
00:B5A0 A509            	  1642:   lda random
00:B5A2 8500            	  1643:   sta REG
00:B5A4 A50A            	  1644:   lda random+1
00:B5A6 8501            	  1645:   sta REG+1
00:B5A8 A50B            	  1646:   lda random+2
00:B5AA 8502            	  1647:   sta REGB
00:B5AC 4C69AF          	  1648:   jmp MAINP
                        	  1649: 
                        	  1650: 
                        	  1651: ;
                        	  1652: ;  LATENCY
                        	  1653: ;
                        	  1654: EX_LATENCY:
00:B5AF A50D            	  1655:   lda typing_latency
00:B5B1 8500            	  1656:   sta REG
00:B5B3 A50E            	  1657:   lda typing_latency+1
00:B5B5 8501            	  1658:   sta REG+1
00:B5B7 A50F            	  1659:   lda typing_latency+2
00:B5B9 8502            	  1660:   sta REGB
00:B5BB 4C69AF          	  1661:   jmp MAINP
                        	  1662: 
                        	  1663: ; PULTOP puts stuff here thus:
                        	  1664: ;
                        	  1665: ;        LDA  REG
                        	  1666: ;        LDX  REG+1
                        	  1667: ;        LDY  REGB
                        	  1668: 
                        	  1669: EX_DELAY = *
00:B5BE 2002B0          	  1670:   JSR  PULTOP  ; get the time interval in ms
                        	  1671:   ; (Y = high-order byte, X = lo-order byte)
00:B5C1 A600            	  1672:   ldx REG
00:B5C3 A501            	  1673:   lda REG+1
00:B5C5 297F            	  1674:   and #$7F
00:B5C7 A8              	  1675:   tay
00:B5C8 203E91          	  1676:   jsr delay
00:B5CB 4C6CAF          	  1677:   jmp MAIN
                        	  1678: 
                        	  1679: ;
                        	  1680: ;  RANDOMSEED
                        	  1681: ;
                        	  1682: EX_RANDOMSEED = *
00:B5CE 2002B0          	  1683:   JSR  PULTOP  ; get the seed
00:B5D1 850A            	  1684:   sta random+1
00:B5D3 860B            	  1685:   stx random+2
00:B5D5 840C            	  1686:   sty random+3
00:B5D7 A9FF            	  1687:   lda #$FF     ; ensure seed has some 1 bits
00:B5D9 8509            	  1688:   sta random
00:B5DB 4C6CAF          	  1689:   jmp MAIN
                        	  1690: 
                        	  1691: ;
                        	  1692: ;  PINMODE (pin, mode) pin:0 to 15; mode: 0=read, 1=write
                        	  1693: ;
                        	  1694: EX_PINMODE = *
00:B5DE 2002B0          	  1695:   jsr PULTOP  ; the mode
00:B5E1 AA              	  1696:   tax         ; input or output?
00:B5E2 DA              	  1697:   phx         ; save the mode
00:B5E3 2002B0          	  1698:   jsr PULTOP  ; which pin
00:B5E6 FA              	  1699:   plx         ; get mode back
00:B5E7 207DC8          	  1700:   jsr pinmode ; pin in A, mode in X
00:B5EA 4C6CAF          	  1701:   jmp MAIN    ; done
                        	  1702: 
                        	  1703: ;
                        	  1704: ;  DIGITALWRITE (pin, value) pin:0 to 15; value: 0 or 1
                        	  1705: ;
                        	  1706: EX_DIGITALWRITE = *
00:B5ED 2002B0          	  1707:   jsr PULTOP  ; the value
00:B5F0 AA              	  1708:   tax         ;
00:B5F1 DA              	  1709:   phx         ; save the value
00:B5F2 2002B0          	  1710:   jsr PULTOP  ; which pin
00:B5F5 FA              	  1711:   plx         ; get mode back
00:B5F6 20ACC8          	  1712:   jsr digitalwrite ; pin in A, value in X
00:B5F9 4C6CAF          	  1713:   jmp MAIN    ; done
                        	  1714: 
                        	  1715: EX_LIB_CALL:
00:B5FC 2065B0          	  1716:   JSR  GETLIT
00:B5FF 6C0000          	  1717:   jmp  (REG)
                        	  1718: 
                        	  1719: ;
                        	  1720: ;  Assert (expression)
                        	  1721: ;
                        	  1722: 
                        	  1723: EX_ASSERT:
00:B602 2002B0          	  1724:   jsr PULTOP  ; the value
00:B605 A500            	  1725:   lda REG
00:B607 0501            	  1726:   ora REG+1
00:B609 0502            	  1727:   ora REGB
00:B60B D00A            	  1728:   bne EX_ASSERT_OK
00:B60D A987            	  1729:   lda #<assertion_failed_message  ; "Assertion failed"
00:B60F A297            	  1730:   ldx #>assertion_failed_message
00:B611 202682          	  1731:   jsr print
00:B614 4CE3AE          	  1732:   jmp RUNERR
                        	  1733: 
                        	  1734: EX_ASSERT_OK:
00:B617 4C6CAF          	  1735:   jmp MAIN
                        	  1736: 

Source: "gpascal.asm"
                        	   181:   .include "interrupts.inc"

Source: "interrupts.inc"
                        	     1: 
00:B61A 0A42524B20657865	     2: break_message     asciiz "\nBRK executed at address $"
00:B622 6375746564206174
00:B62A 2061646472657373
00:B632 2024
00:B634 00
00:B635 2C2041203D2024  	     3: a_equals_message  asciiz ", A = $"
00:B63C 00
00:B63D 2C2058203D2024  	     4: x_equals_message  asciiz ", X = $"
00:B644 00
00:B645 2C2059203D2024  	     5: y_equals_message  asciiz ", Y = $"
00:B64C 00
00:B64D 2C2050203D2024  	     6: p_equals_message  asciiz ", P = $"
00:B654 00
00:B655 2C2053203D2024  	     7: s_equals_message  asciiz ", S = $"
00:B65C 00
00:B65D 2C206964203D2024	     8: id_equals_message asciiz ", id = $"
00:B665 00
                        	     9: 
                        	    10: ;--------------------------------------------------
                        	    11: ;  IRQ - here on BRK interrupt
                        	    12: ;--------------------------------------------------
                        	    13: brk_executed:
00:B666 8412            	    14:   sty call_y    ; save Y - we didn't touch that
00:B668 8614            	    15:   stx call_s    ; X still has the stack pointer in it
00:B66A FA              	    16:   plx           ; get X back
00:B66B 8611            	    17:   stx call_x
00:B66D 68              	    18:   pla           ; get A back
00:B66E 8510            	    19:   sta call_a    ; save A
00:B670 68              	    20:   pla           ; get the processor flags from the stack
00:B671 8513            	    21:   sta call_p
00:B673 68              	    22:   pla           ; low-order address of BRK
00:B674 8515            	    23:   sta brk_address
00:B676 68              	    24:   pla           ; high order address of BRK
00:B677 8516            	    25:   sta brk_address+1
00:B679 58              	    26:   cli           ; allow interrupts now so we can print
                        	    27: 
                        	    28: ;
                        	    29: ;  display BRK info for the user
                        	    30: ;
                        	    31:   ;
                        	    32:   ;  subtract 2 from brk_address to get where it actually was
                        	    33:   ;
00:B67A 38              	    34:   sec
00:B67B A515            	    35:   lda brk_address
00:B67D E902            	    36:   sbc #2
00:B67F 8515            	    37:   sta brk_address
00:B681 A516            	    38:   lda brk_address+1
00:B683 E900            	    39:   sbc #0
00:B685 8516            	    40:   sta brk_address+1
00:B687 A91A            	    41:   lda #<break_message
00:B689 A2B6            	    42:   ldx #>break_message
00:B68B 202682          	    43:   jsr print
00:B68E A516            	    44:   lda brk_address+1
00:B690 200693          	    45:   jsr PRBYTE
00:B693 A515            	    46:   lda brk_address
00:B695 200693          	    47:   jsr PRBYTE
                        	    48: ;
                        	    49: ;  show A, X, Y, P, S
                        	    50: ;
00:B698 A935            	    51:   lda #<a_equals_message
00:B69A A2B6            	    52:   ldx #>a_equals_message
00:B69C 202682          	    53:   jsr print
00:B69F A510            	    54:   lda call_a
00:B6A1 200693          	    55:   jsr PRBYTE
00:B6A4 A93D            	    56:   lda #<x_equals_message
00:B6A6 A2B6            	    57:   ldx #>x_equals_message
00:B6A8 202682          	    58:   jsr print
00:B6AB A511            	    59:   lda call_x
00:B6AD 200693          	    60:   jsr PRBYTE
00:B6B0 A945            	    61:   lda #<y_equals_message
00:B6B2 A2B6            	    62:   ldx #>y_equals_message
00:B6B4 202682          	    63:   jsr print
00:B6B7 A512            	    64:   lda call_y
00:B6B9 200693          	    65:   jsr PRBYTE
00:B6BC A94D            	    66:   lda #<p_equals_message
00:B6BE A2B6            	    67:   ldx #>p_equals_message
00:B6C0 202682          	    68:   jsr print
00:B6C3 A513            	    69:   lda call_p
00:B6C5 200693          	    70:   jsr PRBYTE
00:B6C8 A955            	    71:   lda #<s_equals_message
00:B6CA A2B6            	    72:   ldx #>s_equals_message
00:B6CC 202682          	    73:   jsr print
00:B6CF A514            	    74:   lda call_s
00:B6D1 200693          	    75:   jsr PRBYTE
00:B6D4 A95D            	    76:   lda #<id_equals_message
00:B6D6 A2B6            	    77:   ldx #>id_equals_message
00:B6D8 202682          	    78:   jsr print
                        	    79: ;
                        	    80: ;  advance one byte to get the break ID (byte after the BRK)
                        	    81: ;
00:B6DB E615            	    82:   inc brk_address
00:B6DD D002            	    83:   bne brk_executed1
00:B6DF E616            	    84:   inc brk_address+1
                        	    85: brk_executed1:
00:B6E1 A000            	    86:   ldy #0
00:B6E3 B115            	    87:   lda (brk_address),Y
00:B6E5 200693          	    88:   jsr PRBYTE
                        	    89: ;
                        	    90: ;  put brk_address back to where we should resume from
                        	    91: ;
00:B6E8 E615            	    92:   inc brk_address
00:B6EA D002            	    93:   bne brk_executed2
00:B6EC E616            	    94:   inc brk_address+1
                        	    95: brk_executed2:
                        	    96: 
00:B6EE 209192          	    97:   jsr CROUT
                        	    98: ;
                        	    99: ;  display stack
                        	   100: ;
00:B6F1 A912            	   101:   lda #<stack_message
00:B6F3 A2B7            	   102:   ldx #>stack_message
00:B6F5 202682          	   103:   jsr print
00:B6F8 A514            	   104:   lda call_s
00:B6FA 18              	   105:   clc
00:B6FB 6906            	   106:   adc #6  ; the interrupt pushed 3 we pushed 2, plus the stack points to the first UNUSED spot
00:B6FD AA              	   107:   tax
                        	   108: brk_executed3:
00:B6FE BD0001          	   109:   lda $100,x
00:B701 DA              	   110:   phx
00:B702 200693          	   111:   jsr PRBYTE
00:B705 201C93          	   112:   jsr PUTSP
00:B708 FA              	   113:   plx
00:B709 E8              	   114:   inx
00:B70A D0F2            	   115:   bne brk_executed3
                        	   116: 
                        	   117: ;
                        	   118: ;  we are done now
                        	   119: ;
00:B70C 209192          	   120:   jsr CROUT
00:B70F 4CCC82          	   121:   jmp main_prompt
                        	   122: 
00:B712 537461636B3A20  	   123: stack_message asciiz "Stack: "
00:B719 00
                        	   124: 
00:B71A 4C66B6          	   125: brk_executedJ jmp brk_executed
                        	   126: 
                        	   127: ;--------------------------------------------------
                        	   128: ;  IRQ - here on maskable interrupt
                        	   129: ;--------------------------------------------------
                        	   130: 
                        	   131: irq:
00:B71D 48              	   132:   pha       ; save A and X
00:B71E DA              	   133:   phx
00:B71F BA              	   134:   tsx       ; get stack pointer
00:B720 E0FB            	   135:   cpx #$FB  ; should be lesss than $FB (since the interrupt pushed 3 and we pushed 2)
00:B722 9006            	   136:   bcc irq1
00:B724 A21B            	   137:   ldx #27   ; ERROR: stack full
00:B726 58              	   138:   cli       ; allow interrupts or error won't print
00:B727 4CCD97          	   139:   jmp ERROR
                        	   140: 
                        	   141: irq1:
00:B72A BD0301          	   142:   lda $103,X    ; this will be the processor flags on the stack (3 up from where we are now)
00:B72D 2910            	   143:   and #$10      ; check BRK flag
00:B72F D0E9            	   144:   bne brk_executedJ
                        	   145: ;
                        	   146: ;  here for a hardware IRQ
                        	   147: ;
00:B731 ADFD7F          	   148:   lda VIA_IFR
00:B734 2908            	   149:   and #VIA_FLAG_CB2        ; CB2 active edge
00:B736 D00A            	   150:   bne cb2_interrupt
                        	   151: 
00:B738 ADFD7F          	   152:   lda VIA_IFR
00:B73B 2940            	   153:   and #VIA_FLAG_TIMER1     ; Time out of T1
00:B73D D034            	   154:   bne timer1_interrupt
                        	   155: 
                        	   156: 
                        	   157: ;
                        	   158: ;  we shouldn't get here, and if we do we will probably just loop servicing the interrupt
                        	   159: ;
                        	   160:   .if SERIAL_DEBUGGING
                        	   161: 
                        	   162:     lda #SERIAL_SPARE2_MASK
                        	   163:     tsb VIA_PORTA
                        	   164:     trb VIA_PORTA
                        	   165: 
                        	   166:   .endif  ; SERIAL_DEBUGGING
                        	   167: 
00:B73F 4CA2B7          	   168:   jmp irq_done
                        	   169: 
                        	   170: ;
                        	   171: ;  here for incoming start bit
                        	   172: ;
                        	   173: cb2_interrupt:
                        	   174: 
00:B742 8DFE7F          	   175:   sta VIA_IER           ; turn off that interrupt
00:B745 8DFD7F          	   176:   sta VIA_IFR           ; indicate we noticed it
                        	   177: 
00:B748 DA              	   178:   phx
00:B749 5A              	   179:   phy
                        	   180: 
00:B74A A208            	   181:   ldx #8              ; count of bits
00:B74C A030            	   182:   ldy #SERIAL_DELAY1  ; delay interval for first bit (allow for code above) TODO - probably needs to be less now
                        	   183: serial_in_loop:
                        	   184: ;
                        	   185: ; wait for bit time to be up
                        	   186: ;
00:B74E 88              	   187:   dey
00:B74F D0FD            	   188:   bne serial_in_loop
                        	   189: 
                        	   190:   .if SERIAL_DEBUGGING
                        	   191:     lda #SERIAL_DEBUG1_MASK     ; toggle debug flag (2 cycles)
                        	   192:     tsb VIA_PORTA               ; (6 cycles)
                        	   193:     trb VIA_PORTA               ; (6 cycles)
                        	   194:   .else
00:B751 EA              	   195:     NOP    ; take the same time so the timing isn't thrown out
00:B752 EA              	   196:     NOP    ; 2 cycles each
00:B753 EA              	   197:     NOP
00:B754 EA              	   198:     NOP
00:B755 EA              	   199:     NOP
00:B756 EA              	   200:     NOP
00:B757 EA              	   201:     NOP    ; total of 14 cycles
                        	   202:   .endif  ; SERIAL_DEBUGGING
                        	   203: 
00:B758 ADF17F          	   204:   lda VIA_PORTA
00:B75B 6A              	   205:   ror A                 ; put incoming bit into carry
00:B75C 668A            	   206:   ror serial_in_byte    ; shift one bit in
00:B75E A023            	   207:   ldy #SERIAL_DELAY2    ; delay interval for remaining bits
00:B760 CA              	   208:   dex
00:B761 D0EB            	   209:   bne serial_in_loop
                        	   210: 
00:B763 7A              	   211:   ply
00:B764 FA              	   212:   plx
                        	   213: ;
                        	   214: ;  re-enable interrupts on the falling edge
                        	   215: ;
00:B765 A988            	   216:   lda #VIA_FLAG_ENABLE | VIA_FLAG_CB2
00:B767 8DFE7F          	   217:   sta VIA_IER
00:B76A 8DFD7F          	   218:   sta VIA_IFR   ; indicate we know about previous falling edges
                        	   219: 
                        	   220: ;
                        	   221: ;  move to place that we know it will be noticed
                        	   222: ;
00:B76D A58A            	   223:   lda serial_in_byte
00:B76F 858B            	   224:   sta serial_in_byte_received
                        	   225: 
00:B771 802F            	   226:   bra irq_done
                        	   227: 
                        	   228: ;
                        	   229: ;  here for time to send another outgoing bit
                        	   230: ;
                        	   231: timer1_interrupt :
                        	   232: 
00:B773 8DFD7F          	   233:   sta VIA_IFR           ; indicate we noticed it
00:B776 A589            	   234:   lda serial_out_bit    ; are we in fact sending a byte?
00:B778 F028            	   235:   beq irq_done          ; no, just exit
                        	   236: 
                        	   237:   .if SERIAL_DEBUGGING
                        	   238: 
                        	   239:   lda #SERIAL_DEBUG2_MASK     ; toggle debug flag (2 cycles)
                        	   240:   tsb VIA_PORTA               ; wash on   (6 cycles)
                        	   241:   trb VIA_PORTA               ; wash off  (6 cycles)
                        	   242:                               ; now, sand the floor
                        	   243:  .else
00:B77A EA              	   244:      NOP    ; take the same time so the timing isn't thrown out
00:B77B EA              	   245:      NOP    ; 2 cycles each
00:B77C EA              	   246:      NOP
00:B77D EA              	   247:      NOP
00:B77E EA              	   248:      NOP
00:B77F EA              	   249:      NOP
00:B780 EA              	   250:      NOP    ; total of 14 cycles
                        	   251:   .endif  ; SERIAL_DEBUGGING
                        	   252: 
00:B781 6688            	   253:   ror serial_out_byte+1  ; we don't care about the high-order bit
00:B783 6687            	   254:   ror serial_out_byte    ; get the low-order bit into Carry
00:B785 9007            	   255:   bcc write_zero
00:B787 A902            	   256:   lda #SERIAL_OUT_MASK   ; (send a 1 bit)
00:B789 0DF17F          	   257:   ora VIA_PORTA
00:B78C 8005            	   258:   bra serial_send_count_bits
                        	   259: 
                        	   260: write_zero:
00:B78E A9FD            	   261:   lda #~SERIAL_OUT_MASK  ; (send a 0 bit)
00:B790 2DF17F          	   262:   and VIA_PORTA
                        	   263: 
                        	   264: serial_send_count_bits:
00:B793 8DF17F          	   265:   sta VIA_PORTA          ; output this bit
00:B796 C689            	   266:   dec serial_out_bit     ; remember bit count for later
00:B798 D008            	   267:   bne irq_done
                        	   268: 
                        	   269: ; here when all bits have been sent
                        	   270: ; disable the timer as we don't need it any more
                        	   271: ; and this will be a flag that we can send another byte
                        	   272: 
00:B79A A940            	   273:   lda #VIA_FLAG_DISABLE | VIA_FLAG_TIMER1  ; cancel interrupt on T1 timeout
00:B79C 8DFE7F          	   274:   sta VIA_IER
00:B79F ADF47F          	   275:   lda VIA_T1C_L     ; clear interrupt flag
                        	   276: 
                        	   277: irq_done:
00:B7A2 FA              	   278:   plx   ; restore X
00:B7A3 68              	   279:   pla   ; restore A
00:B7A4 40              	   280:   rti
                        	   281: 

Source: "gpascal.asm"
                        	   182:   .include "lcd.inc"

Source: "lcd.inc"
                        	     1:   .if !EMULATOR
                        	     2:   .if LCD_SUPPORT
                        	     3: 
                        	     4: ;
                        	     5: ;  LCD stuff
                        	     6: ;
                        	     7: 
                        	     8: lcd_initialise:
                        	     9: ;
                        	    10: ;  LCD initialise
                        	    11: ;
                        	    12: 
00:B7A5 ADF37F          	    13:   lda VIA_DDRA
00:B7A8 09E0            	    14:   ora #(LCD_RW|LCD_RS|LCD_E)    ; set appropriate pins on Port A to output
00:B7AA 8DF37F          	    15:   sta VIA_DDRA
                        	    16: 
                        	    17:   ; see HD44780U documentation: "Initializing by Instruction" (page 46)
00:B7AD 2026B8          	    18:   jsr lcd_prepare_to_write_instruction
00:B7B0 A930            	    19:   lda #$30
00:B7B2 2086B8          	    20:   jsr lcd_write_instruction_nibble
                        	    21:   ; wait > 4.1 ms
00:B7B5 A214            	    22:   ldx #20
00:B7B7 A000            	    23:   ldy #0
00:B7B9 203E91          	    24:   jsr delay      ; 20 ms delay (in case of faster board clock speeds)
00:B7BC 2086B8          	    25:   jsr lcd_write_instruction_nibble
00:B7BF 203491          	    26:   jsr delay_1ms  ; do it 4 times in case of faster board clock speeds
00:B7C2 203491          	    27:   jsr delay_1ms
00:B7C5 203491          	    28:   jsr delay_1ms
00:B7C8 203491          	    29:   jsr delay_1ms
00:B7CB 2086B8          	    30:   jsr lcd_write_instruction_nibble
00:B7CE 203491          	    31:   jsr delay_1ms  ; do it 4 times in case of faster board clock speeds
00:B7D1 203491          	    32:   jsr delay_1ms
00:B7D4 203491          	    33:   jsr delay_1ms
00:B7D7 203491          	    34:   jsr delay_1ms
00:B7DA A920            	    35:   lda #$20    ; switch to 4-bit mode
00:B7DC 2086B8          	    36:   jsr lcd_write_instruction_nibble
00:B7DF 203491          	    37:   jsr delay_1ms  ; do it 4 times in case of faster board clock speeds
00:B7E2 203491          	    38:   jsr delay_1ms
00:B7E5 203491          	    39:   jsr delay_1ms
00:B7E8 203491          	    40:   jsr delay_1ms
                        	    41: ;
                        	    42: ;  now we can switch to sending 8-bits in two nibbles
                        	    43: ;
00:B7EB A928            	    44:   lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
00:B7ED 2092B8          	    45:   jsr lcd_instruction
00:B7F0 A90C            	    46:   lda #%00001100 ; DCB: Display on; cursor off; blink off
00:B7F2 2092B8          	    47:   jsr lcd_instruction
00:B7F5 A906            	    48:   lda #%00000110 ; Increment and shift cursor; don't shift display
00:B7F7 2092B8          	    49:   jsr lcd_instruction
00:B7FA 20E6B8          	    50:   jsr lcd_clear_display
00:B7FD 60              	    51:   rts
                        	    52: 
                        	    53: lcd_prepare_to_read_register:
00:B7FE ADF17F          	    54:   lda VIA_PORTA
00:B801 0940            	    55:   ora #LCD_RW             ; set RW bit  (ie. enable reading)
00:B803 295F            	    56:   and #<(~(LCD_RS|LCD_E)) ; Clear RS/E bits
00:B805 8DF17F          	    57:   sta VIA_PORTA
00:B808 ADF27F          	    58:   lda VIA_DDRB
00:B80B 290F            	    59:   and #$0F
00:B80D 8DF27F          	    60:   sta VIA_DDRB            ; we are reading from DDRB
00:B810 60              	    61:   rts
                        	    62: 
                        	    63: lcd_prepare_to_write_data:
00:B811 48              	    64:   pha
00:B812 ADF17F          	    65:   lda VIA_PORTA
00:B815 293F            	    66:   and #<(~(LCD_RW|LCD_E))  ; clear RW and E (enable writing)
00:B817 0920            	    67:   ora #LCD_RS              ; setting this means we write a character
00:B819 8DF17F          	    68:   sta VIA_PORTA
00:B81C ADF27F          	    69:   lda VIA_DDRB
00:B81F 09F0            	    70:   ora #$F0      ; Set high-order pins on port B to output
00:B821 8DF27F          	    71:   sta VIA_DDRB
00:B824 68              	    72:   pla
00:B825 60              	    73:   rts
                        	    74: 
                        	    75: lcd_prepare_to_write_instruction:
00:B826 48              	    76:   pha
00:B827 ADF17F          	    77:   lda VIA_PORTA
00:B82A 291F            	    78:   and #<(~(LCD_RW|LCD_RS|LCD_E))  ; clear RW, RS and E (enable writing)
00:B82C 8DF17F          	    79:   sta VIA_PORTA
00:B82F ADF27F          	    80:   lda VIA_DDRB
00:B832 09F0            	    81:   ora #$F0      ; Set high-order pins on port B to output
00:B834 8DF27F          	    82:   sta VIA_DDRB
00:B837 68              	    83:   pla
00:B838 60              	    84:   rts
                        	    85: 
                        	    86: lcd_set_enable:
00:B839 ADF17F          	    87:   lda VIA_PORTA
00:B83C 0980            	    88:   ora #LCD_E
00:B83E 8DF17F          	    89:   sta VIA_PORTA   ; Set enable (E)
00:B841 60              	    90:   rts
                        	    91: 
                        	    92: lcd_clear_enable:
00:B842 ADF17F          	    93:   lda VIA_PORTA
00:B845 297F            	    94:   and #<(~LCD_E)  ; Clear enable (E)
00:B847 8DF17F          	    95:   sta VIA_PORTA
00:B84A 60              	    96:   rts
                        	    97: 
                        	    98: lcd_read_instruction_nibble:
00:B84B 2039B8          	    99:   jsr lcd_set_enable
00:B84E ADF07F          	   100:   lda VIA_PORTB   ; read the data on port B
00:B851 48              	   101:   pha             ; save the data
00:B852 2042B8          	   102:   jsr lcd_clear_enable
00:B855 68              	   103:   pla             ; get the data back
00:B856 60              	   104:   rts
                        	   105: 
                        	   106: ;
                        	   107: ; wait until LCD is not busy
                        	   108: ;
                        	   109: lcd_wait:
00:B857 DA              	   110:   phx
00:B858 5A              	   111:   phy
00:B859 48              	   112:   pha
00:B85A 20FEB7          	   113:   jsr lcd_prepare_to_read_register
00:B85D A200            	   114:   ldx #0
                        	   115: lcdbusy:
                        	   116: ;
                        	   117: ;  timeout after 256 iterations of this loop so we don't hang
                        	   118: ;  if there is no LCD or it doesn't respond
                        	   119: ;
00:B85F CA              	   120:   dex
00:B860 F00C            	   121:   beq lcd_wait_timeout
00:B862 204BB8          	   122:   jsr lcd_read_instruction_nibble
00:B865 2980            	   123:   and #$80        ; get busy flag
00:B867 A8              	   124:   tay             ; save busy status
00:B868 204BB8          	   125:   jsr lcd_read_instruction_nibble   ; do second nibble
00:B86B 98              	   126:   tya             ; get busy status back
00:B86C D0F1            	   127:   bne lcdbusy     ; if busy go back
                        	   128: ;
                        	   129: ;  here when not busy any more
                        	   130: ;
                        	   131: lcd_wait_timeout:
00:B86E 68              	   132:   pla
00:B86F 7A              	   133:   ply
00:B870 FA              	   134:   plx
00:B871 60              	   135:   rts
                        	   136: 
                        	   137: ;
                        	   138: ;  Find the current LCD (cursor) address - useful for knowing
                        	   139: ;  if we exceed the limit of line 1
                        	   140: ;
                        	   141: lcd_get_address:
00:B872 20FEB7          	   142:   jsr lcd_prepare_to_read_register
00:B875 204BB8          	   143:   jsr lcd_read_instruction_nibble
00:B878 2970            	   144:   and #$70        ; ignore busy bit, mask out other junk
00:B87A 8586            	   145:   sta lcd_work
00:B87C 204BB8          	   146:   jsr lcd_read_instruction_nibble
00:B87F 4A              	   147:   lsr A   ; shift this lot into low-order bits
00:B880 4A              	   148:   lsr A
00:B881 4A              	   149:   lsr A
00:B882 4A              	   150:   lsr A
00:B883 0586            	   151:   ora lcd_work    ; get the high-order bits back
00:B885 60              	   152:   rts
                        	   153: 
                        	   154: lcd_write_instruction_nibble:
00:B886 48              	   155:   pha
00:B887 8DF07F          	   156:   sta VIA_PORTB         ; set up the data
00:B88A 2039B8          	   157:   jsr lcd_set_enable    ; toggle enable
00:B88D 2042B8          	   158:   jsr lcd_clear_enable
00:B890 68              	   159:   pla
00:B891 60              	   160:   rts
                        	   161: 
                        	   162: ;
                        	   163: ;  send an instruction to the LCD
                        	   164: ;
                        	   165: lcd_instruction:
00:B892 2057B8          	   166:   jsr lcd_wait
00:B895 2026B8          	   167:   jsr lcd_prepare_to_write_instruction
00:B898 2086B8          	   168:   jsr lcd_write_instruction_nibble
00:B89B 48              	   169:   pha
00:B89C 0A              	   170:   asl a   ; move the low-order bits into the high-order bits
00:B89D 0A              	   171:   asl a   ; because the high-order 4 bits are the active ones
00:B89E 0A              	   172:   asl a
00:B89F 0A              	   173:   asl a
00:B8A0 2086B8          	   174:   jsr lcd_write_instruction_nibble
00:B8A3 68              	   175:   pla
00:B8A4 60              	   176:   rts
                        	   177: 
                        	   178: lcd_data_nibble:
00:B8A5 48              	   179:   pha
00:B8A6 2011B8          	   180:   jsr lcd_prepare_to_write_data
00:B8A9 8DF07F          	   181:   sta VIA_PORTB
00:B8AC 2039B8          	   182:   jsr lcd_set_enable
00:B8AF 2042B8          	   183:   jsr lcd_clear_enable
00:B8B2 68              	   184:   pla
00:B8B3 60              	   185:   rts
                        	   186: 
                        	   187: ;
                        	   188: ;  print a character to the LCD
                        	   189: ;
                        	   190: lcd_print_char:
00:B8B4 2057B8          	   191:   jsr lcd_wait  ; wait for previous write to finish
00:B8B7 C90A            	   192:   cmp #NL
00:B8B9 D004            	   193:   bne lcd_print_not_newline ; newline jumps to 2nd line
00:B8BB 20EEB8          	   194:   jsr lcd_second_line       ; go to second line
00:B8BE 60              	   195:   rts                       ; and don't print the newline :)
                        	   196: 
                        	   197: lcd_print_not_newline:
00:B8BF 48              	   198:   pha                   ; save the character we want to print
00:B8C0 2072B8          	   199:   jsr lcd_get_address
00:B8C3 C910            	   200:   cmp #16         ; 16 characters on the first line
00:B8C5 900E            	   201:   bcc lcd_print_char_ok ; not there yet
00:B8C7 D005            	   202:   bne lcd_print_char_on_2nd_line  ; not < 16 and not == 16, must be > 16
                        	   203:   ; we have exactly 16, so drop down to address 64
00:B8C9 20EEB8          	   204:   jsr lcd_second_line  ; at char 16 go to 2nd line (address 64)
00:B8CC 8007            	   205:   bra lcd_print_char_ok
                        	   206: 
                        	   207: lcd_print_char_on_2nd_line:
00:B8CE C950            	   208:   cmp #80                  ; more than 16 characters on in 2nd line? (64 + 16)
00:B8D0 9003            	   209:   bcc lcd_print_char_ok    ; nah
00:B8D2 20E6B8          	   210:   jsr lcd_clear_display    ; yes, clear display then and start again
                        	   211: lcd_print_char_ok:
                        	   212: lcd_print_char_newline:
00:B8D5 2011B8          	   213:   jsr lcd_prepare_to_write_data
00:B8D8 68              	   214:   pla                      ; get the character back
00:B8D9 20A5B8          	   215:   jsr lcd_data_nibble
00:B8DC 48              	   216:   pha
00:B8DD 0A              	   217:   asl a     ; now send the low-order bits
00:B8DE 0A              	   218:   asl a
00:B8DF 0A              	   219:   asl a
00:B8E0 0A              	   220:   asl a
00:B8E1 20A5B8          	   221:   jsr lcd_data_nibble
00:B8E4 68              	   222:   pla
00:B8E5 60              	   223:   rts
                        	   224: 
                        	   225: lcd_clear_display:
00:B8E6 48              	   226:   pha
00:B8E7 A901            	   227:   lda #%00000001 ; Clear display
00:B8E9 2092B8          	   228:   jsr lcd_instruction
00:B8EC 68              	   229:   pla
00:B8ED 60              	   230:   rts
                        	   231: 
                        	   232: lcd_second_line:
00:B8EE 48              	   233:   pha
00:B8EF A9C0            	   234:   lda #$C0 ; set output address to 0x40 (set DDRAM address)
00:B8F1 2092B8          	   235:   jsr lcd_instruction
00:B8F4 68              	   236:   pla
00:B8F5 60              	   237:   rts
                        	   238: 
                        	   239: lcd_home:
00:B8F6 48              	   240:   pha
00:B8F7 A980            	   241:   lda #$80 ; set output address to 0 (set DDRAM address)
00:B8F9 2092B8          	   242:   jsr lcd_instruction
00:B8FC 68              	   243:   pla
00:B8FD 60              	   244:   rts
                        	   245: 
                        	   246: 
                        	   247: ;
                        	   248: ;  print null-terminated message on LCD, message in A (lo) and X (hi)
                        	   249: ;  returns the length of the message in Y
                        	   250: ;
                        	   251: lcd_print_message:
00:B8FE 8503            	   252:   sta REG2
00:B900 8604            	   253:   stx REG2+1
00:B902 A000            	   254:   ldy #0
00:B904 20E6B8          	   255:   jsr lcd_clear_display
                        	   256: lcd_print:
00:B907 B103            	   257:   lda (REG2),y
00:B909 F006            	   258:   beq lcd_print_done
00:B90B 20B4B8          	   259:   jsr lcd_print_char
00:B90E C8              	   260:   iny
00:B90F 80F6            	   261:   bra lcd_print
                        	   262: 
00:B911 60              	   263: lcd_print_done rts
                        	   264: 
                        	   265:   .else ; LCD_SUPPORT
                        	   266: 
                        	   267: lcd_print_char :
                        	   268: lcd_clear_display :
                        	   269: lcd_second_line:
                        	   270: lcd_print_message:
                        	   271: lcd_instruction:
                        	   272: lcd_get_address:
                        	   273: lcd_home:
                        	   274: lcd_wait:
                        	   275:     ldx #50     ; No LCD
                        	   276:     jmp ERROR
                        	   277: 
                        	   278: 
                        	   279:   .endif  ; (no) LCD_SUPPORT
                        	   280: 
                        	   281:   .endif  ; not emulator
                        	   282: 

Source: "gpascal.asm"
                        	   183:   .include "symbols.inc"

Source: "symbols.inc"
                        	     1: ;***********************************************
                        	     2: ; SYMBOL TABLE STUFF: Offsets from the start of a particular symbol
                        	     3: ; Stored as a linked list, where you search backwards so the more local one is found first
                        	     4: ;***********************************************
                        	     5: 
                        	     6: SYMPRV   =  0         ; address of previous symbol (for working backwards through symbols)
                        	     7: SYMLVL   =  2         ; nested level (eg. entering a procedure/function increments the level,
                        	     8:                       ;                   and leaving it decrements the level)
                        	     9:                       ; - used to detect duplicate symbols at the same level
                        	    10: SYMTYP   =  3         ; Symbol type: C = constant, V = variable, Y = function return value
                        	    11:                       ;              P = procedure, F = function, A = array
                        	    12:                       ;              p = library procedure, f = library function
                        	    13:                       ;  See defines below.
                        	    14: SYMDSP   =  4         ; if the symbol is a constant, what the value is (3 bytes)
                        	    15:                       ; if the symbol is a variable, array or function return then this is the offset (2 bytes)
                        	    16: SYMARG   =  6         ; if the symbol is a procedure/function, count of arguments (can be zero)
                        	    17: SYMSUB   =  6         ; MAX SUBSCRIPT+1 - for arrays, so this is the actual array length
                        	    18: SYMDAT   =  8         ; data type: 0 = integer, 1 = char
                        	    19: SYMLEN   =  9         ; length of the name, der
                        	    20: SYMNAM   =  10        ; name of symbol for SYMLEN characters, stored in upper-case
                        	    21: 
                        	    22: ;
                        	    23: ; Symbol types
                        	    24: ;
                        	    25: 
                        	    26: SYMBOL_CONSTANT          = 'C'
                        	    27: SYMBOL_VARIABLE          = 'V'
                        	    28: SYMBOL_FUNCTION_RETURN   = 'Y'
                        	    29: SYMBOL_PROCEDURE         = 'P'
                        	    30: SYMBOL_FUNCTION          = 'F'
                        	    31: SYMBOL_LIBRARY_PROCEDURE = 'Q'  ; library procedures and functions are implemented in assembler
                        	    32: SYMBOL_LIBRARY_FUNCTION  = 'R'
                        	    33: SYMBOL_ARRAY             = 'A'
                        	    34: 
                        	    35: 
                        	    36: 
                        	    37: ;
                        	    38: ;***********************************************
                        	    39: ;SEARCH SYMBOL TABLE - returns Z if not found (BEQ <not found>)
                        	    40: ;***********************************************
                        	    41: SEARCH   =  *
00:B912 A532            	    42:          lda  ENDSYM+1    ; get the end of the symbol table
00:B914 8541            	    43:          sta  SYMITM+1    ; make it the current symbol
00:B916 A531            	    44:          lda  ENDSYM
00:B918 800B            	    45:          bra  SEA1
                        	    46: 
                        	    47: SEA_NEXT =  *
00:B91A A000            	    48:          ldy  #SYMPRV
00:B91C B140            	    49:          lda  (SYMITM),Y
00:B91E AA              	    50:          tax
00:B91F C8              	    51:          iny
00:B920 B140            	    52:          lda  (SYMITM),Y
00:B922 8541            	    53:          sta  SYMITM+1   ; previous link
00:B924 8A              	    54:          txa
                        	    55: ;
                        	    56: ;  go to the previous symbol table item
                        	    57: ;
                        	    58: SEA1     =  *
00:B925 8540            	    59:          sta  SYMITM
00:B927 C52F            	    60:          cmp  STARTSYM
00:B929 D007            	    61:          bne  SEA2
00:B92B A541            	    62:          lda  SYMITM+1
00:B92D C530            	    63:          cmp  STARTSYM+1
00:B92F D001            	    64:          bne  SEA2       ; more to go
00:B931 60              	    65:          rts             ; finished if we are back at the start of the symbol table
                        	    66: 
                        	    67: SEA2     =  *
00:B932 A009            	    68:          ldy  #SYMLEN
00:B934 B140            	    69:          lda  (SYMITM),Y  ; get this item's length
00:B936 C592            	    70:          cmp  token_length      ; compare to the token legnth we got
00:B938 D0E0            	    71:          bne  SEA_NEXT    ; wrong length - try another
00:B93A A540            	    72:          lda  SYMITM      ; back to this symbol's start address
00:B93C 18              	    73:          clc
00:B93D 690A            	    74:          adc  #SYMNAM     ; add the offset of the name to it
00:B93F 8503            	    75:          sta  DEST
00:B941 A541            	    76:          lda  SYMITM+1
00:B943 6900            	    77:          adc  #0
00:B945 8504            	    78:          sta  DEST+1      ; the memory location of the symbol name is in DEST
00:B947 A590            	    79:          lda  token_address      ; now put the token's address into SRCE
00:B949 8500            	    80:          sta  SRCE
00:B94B A591            	    81:          lda  token_address+1
00:B94D 8501            	    82:          sta  SRCE+1
00:B94F A492            	    83:          ldy  token_length
00:B951 209692          	    84:          jsr  COMSTL      ; compare SRCE to DEST
00:B954 D0C4            	    85:          bne  SEA_NEXT    ; not that one - try another
00:B956 20CEBA          	    86:          jsr  GET_DAT     ; get the symbol's data type into DATTYP
00:B959 A002            	    87:          ldy  #SYMLVL     ; and level - why isn't this a function, huh?
00:B95B B140            	    88:          lda  (SYMITM),Y
00:B95D AA              	    89:          tax              ; level into X
00:B95E A003            	    90:          ldy  #SYMTYP
00:B960 B140            	    91:          lda  (SYMITM),Y  ; get type of symbol
00:B962 8536            	    92:          sta  BSAVE       ; symbol type -> BSAVE
00:B964 C943            	    93:          cmp  #SYMBOL_CONSTANT       ; constant?
00:B966 D013            	    94:          bne  SEA4        ; nah
                        	    95: ;
                        	    96: ;  symbol is a constant
                        	    97: ;
00:B968 A004            	    98:          ldy  #SYMDSP     ; if a constant, this is the value
00:B96A B140            	    99:          lda  (SYMITM),Y
00:B96C 8594            	   100:          sta  token_value
00:B96E C8              	   101:          iny
00:B96F B140            	   102:          lda  (SYMITM),Y
00:B971 8595            	   103:          sta  token_value+1
00:B973 C8              	   104:          iny
00:B974 B140            	   105:          lda  (SYMITM),Y
00:B976 8596            	   106:          sta  token_value+2     ; token_value (3 bytes) now has the value in it
00:B978 4C86B9          	   107:          jmp  SEA3
                        	   108: ;
                        	   109: ;  symbol is not a constant
                        	   110: ;
                        	   111: SEA4     =  *                           ; not constant
00:B97B C956            	   112:          cmp  #SYMBOL_VARIABLE          ; variable?
00:B97D F004            	   113:          beq  SEA5                      ; yes
00:B97F C959            	   114:          cmp  #SYMBOL_FUNCTION_RETURN   ; argument?
00:B981 D003            	   115:          bne  SEA3                      ; no - must be SYMBOL_ARRAY, SYMBOL_PROCEDURE or SYMBOL_FUNCTION
                        	   116: ;
                        	   117: ;  here for variables and function return values
                        	   118: ;
                        	   119: SEA5     =  *
00:B983 2029BB          	   120:          jsr  GET_OFF    ; get the variable's offset
                        	   121: SEA3     =  *
00:B986 A536            	   122:          lda  BSAVE      ; A now has the symbol type in it
                        	   123: 
                        	   124: ; Types are: SYMBOL_CONSTANT, SYMBOL_VARIABLE, SYMBOL_FUNCTION_RETURN,
                        	   125: ;            SYMBOL_PROCEDURE, SYMBOL_FUNCTION, SYMBOL_ARRAY
                        	   126: 
00:B988 60              	   127:          rts             ; SHOULD SET 'NEQ' FLAG
                        	   128: 
                        	   129: 
00:B989 A225            	   130: SYM_FULL ldx  #37     ; ERROR: Symbol table full
00:B98B 4CCD97          	   131:          jmp  ERROR
                        	   132: 
                        	   133: ;***********************************************
                        	   134: ; ADD SYMBOL TO SYMBOL TABLE - going downwards until we hit the P-codes
                        	   135: ;  A = the symbol type
                        	   136: ;***********************************************
                        	   137: ADDSYM   =  *
00:B98E 48              	   138:          pha            ; save the symbol type
                        	   139: 
00:B98F A631            	   140:          ldx  ENDSYM    ; get the end of the symbol table
00:B991 8640            	   141:          stx  SYMITM    ; make it the current symbol
00:B993 A632            	   142:          ldx  ENDSYM+1
00:B995 8641            	   143:          stx  SYMITM+1
                        	   144: ;
                        	   145: ;  since we are going downwards, we need to subtract the fixed size of a symbol table item,
                        	   146: ;  plus the symbol length, from SYMITM
                        	   147: ;
00:B997 38              	   148:          sec            ; first subtract the token length
00:B998 A540            	   149:          lda  SYMITM
00:B99A E592            	   150:          sbc  token_length
00:B99C 8540            	   151:          sta  SYMITM
00:B99E 8503            	   152:          sta  DEST      ; put this spot into DEST for copying the name
00:B9A0 A541            	   153:          lda  SYMITM+1
00:B9A2 E900            	   154:          sbc  #0
00:B9A4 8541            	   155:          sta  SYMITM+1
00:B9A6 8504            	   156:          sta  DEST+1
00:B9A8 38              	   157:          sec            ; and now the fixed size
00:B9A9 A540            	   158:          lda  SYMITM
00:B9AB E90A            	   159:          sbc  #SYMNAM
00:B9AD 8540            	   160:          sta  SYMITM
00:B9AF A541            	   161:          lda  SYMITM+1
00:B9B1 E900            	   162:          sbc  #0
00:B9B3 8541            	   163:          sta  SYMITM+1
                        	   164: ;
                        	   165: ;  check we haven't hit the P-codes
                        	   166: ;
00:B9B5 A902            	   167:          lda  #FLAG_ASSEMBLING
00:B9B7 25BE            	   168:          and  system_flags
00:B9B9 D008            	   169:          bne  ADDSYM_NOT_FULL
00:B9BB A524            	   170:          lda  PCODE+1
00:B9BD C541            	   171:          cmp  SYMITM+1
00:B9BF 9002            	   172:          bcc  ADDSYM_NOT_FULL   ; less than - ok
00:B9C1 80C6            	   173:          bra  SYM_FULL          ; greater than or equal (high-order byte) - uh oh
                        	   174: ;
                        	   175: ;  ah, for assembling it is a pain to know whether the symbol table has overflowed, so I'm going
                        	   176: ;  to ignore that as a problem for now. Checking against PCODE will not work if the assembler output
                        	   177: ;  has been relocated to above the symbol table, and the only other thing we can compare against is
                        	   178: ;  the end of the source which we don't necessarily know.
                        	   179: ;
                        	   180: ;
                        	   181: ;  now put the previous start in as the link for the previous one for this item
                        	   182: ;
                        	   183: ADDSYM_NOT_FULL:
00:B9C3 A000            	   184:          ldy  #SYMPRV
00:B9C5 A531            	   185:          lda  ENDSYM
00:B9C7 9140            	   186:          sta  (SYMITM),Y
00:B9C9 A532            	   187:          lda  ENDSYM+1
00:B9CB C8              	   188:          iny
00:B9CC 9140            	   189:          sta  (SYMITM),Y
                        	   190: ;
                        	   191: ;  SYMITM now becomes the start of the symbol table
                        	   192: ;
00:B9CE A540            	   193:          lda  SYMITM
00:B9D0 8531            	   194:          sta  ENDSYM
00:B9D2 A541            	   195:          lda  SYMITM+1
00:B9D4 8532            	   196:          sta  ENDSYM+1
                        	   197: ;
                        	   198: ;  OK, we should be done linking it in.
                        	   199: ;  SYMITM now points to this (as yet unfilled-in) item and the first two bytes now point to
                        	   200: ;   where the symbols previously ended
                        	   201: ;
00:B9D6 68              	   202:          pla                ; get symbol type back
00:B9D7 A003            	   203:          ldy  #SYMTYP
00:B9D9 9140            	   204:          sta  (SYMITM),Y    ; store the type which was in A
00:B9DB A002            	   205:          ldy  #SYMLVL
00:B9DD 48              	   206:          pha                ; save symbol type again
00:B9DE A522            	   207:          lda  LEVEL
00:B9E0 9140            	   208:          sta  (SYMITM),Y    ; store the level
00:B9E2 A009            	   209:          ldy  #SYMLEN
00:B9E4 A592            	   210:          lda  token_length
00:B9E6 9140            	   211:          sta  (SYMITM),Y    ; store the token length
00:B9E8 A8              	   212:          tay
00:B9E9 88              	   213:          dey                ; make zero-relative
                        	   214: ADD1     =  *               ; copy the name across, in upper case
00:B9EA B190            	   215:          lda  (token_address),Y
00:B9EC 202D90          	   216:          jsr  MAKE_UPPER
00:B9EF 9103            	   217:          sta  (DEST),Y
00:B9F1 88              	   218:          dey
00:B9F2 10F6            	   219:          bpl  ADD1      ; keep copying
                        	   220: 
                        	   221: ;
                        	   222: ;  we have added name to the table, now do the rest
                        	   223: ;
00:B9F4 68              	   224:          pla                     ; get symbol type back again
00:B9F5 AA              	   225:          tax                     ; symbol type
00:B9F6 C943            	   226:          cmp  #SYMBOL_CONSTANT   ; CONSTANT??
00:B9F8 D013            	   227:          bne  ADD4
                        	   228: ;
                        	   229: ;  constant
                        	   230: ;
00:B9FA A004            	   231:          ldy  #SYMDSP            ; put this token's value into SYMDSP offset from SYMITM (for 3 bytes)
00:B9FC A594            	   232:          lda  token_value
00:B9FE 9140            	   233:          sta  (SYMITM),Y
00:BA00 C8              	   234:          iny
00:BA01 A595            	   235:          lda  token_value+1
00:BA03 9140            	   236:          sta  (SYMITM),Y
00:BA05 C8              	   237:          iny
00:BA06 A596            	   238:          lda  token_value+2
00:BA08 9140            	   239:          sta  (SYMITM),Y
00:BA0A 4C29BA          	   240:          jmp  ADD9
                        	   241: ;
                        	   242: ;  not a constant
                        	   243: ;
                        	   244: ADD4     =  *
00:BA0D A008            	   245:          ldy  #SYMDAT
00:BA0F A901            	   246:          lda  #1            ; char type (?)
00:BA11 9140            	   247:          sta  (SYMITM),Y
00:BA13 8A              	   248:          txa                ; get symbol type back
00:BA14 C956            	   249:          cmp  #SYMBOL_VARIABLE
00:BA16 D011            	   250:          bne  ADD9
                        	   251: ;
                        	   252: ;  variable type
                        	   253: ;
00:BA18 A005            	   254:          ldy  #SYMDSP+1
00:BA1A A521            	   255:          lda  FRAME+1       ; save frame
00:BA1C 9140            	   256:          sta  (SYMITM),Y
00:BA1E 88              	   257:          dey
00:BA1F A520            	   258:          lda  FRAME
00:BA21 9140            	   259:          sta  (SYMITM),Y
00:BA23 E620            	   260:          inc  FRAME         ; add 1 to frame number
00:BA25 D002            	   261:          bne  ADD9
00:BA27 E621            	   262:          inc  FRAME+1
                        	   263: ADD9     =  *
00:BA29 60              	   264:          rts
                        	   265: ;
                        	   266: 
                        	   267: ;
                        	   268: LOOKUP   =  *
00:BA2A 2012B9          	   269:          JSR  SEARCH
00:BA2D D005            	   270:          BNE  LOOK1
00:BA2F A20B            	   271:          LDX  #11     ; ERROR: Undeclared Identifier
00:BA31 4CCD97          	   272:          jmp  ERROR
00:BA34 60              	   273: LOOK1    RTS
                        	   274: ;
00:BA35 2012B9          	   275: CHKDUP   JSR  SEARCH
00:BA38 F00A            	   276:          BEQ  DUP9
00:BA3A 8A              	   277:          TXA
00:BA3B C522            	   278:          CMP  LEVEL
00:BA3D D005            	   279:          BNE  DUP9
00:BA3F A226            	   280:          LDX  #38   ; ERROR: Duplicate Identifier
00:BA41 4CCD97          	   281:          jmp  ERROR
00:BA44 60              	   282: DUP9     RTS
                        	   283: 

Source: "gpascal.asm"
                        	   184:   .include "compiler.inc"

Source: "compiler.inc"
                        	     1: 
                        	     2: ;***********************************************
                        	     3: ; COMPILER
                        	     4: ;***********************************************
                        	     5: 
                        	     6: 
                        	     7: ;
                        	     8: ;
                        	     9: ;  Compiler directives:
                        	    10: ;
                        	    11: ;    {%L} - list during compile (source code and current P-code address)
                        	    12: ;    {%P} - show generated P-codes during compile - only works during compile (not syntax check)
                        	    13: ;    {%N} - stop listing during compile (cancels %L and %P)
                        	    14: ;    {%S <address>} - relocate symbol table to <address> - must be done before defining symbols
                        	    15: ;                     also generates an opcode to relocate the runtime stack
                        	    16: ;
                        	    17: ;   The % must directly follow the start of the comment.
                        	    18: ;
                        	    19: ;
                        	    20: ;  Comments:  (* some comment *) or { some comment }
                        	    21: ;             "(*" / "{", and "*)" / "}" are treated interchangeably so (* some comment } would work
                        	    22: ;  Comments cannot be nested.
                        	    23: ;
                        	    24: ;  Tips:
                        	    25: ;
                        	    26: ;   Procedures and functions must be declared at the START of a block, not in the middle.
                        	    27: ;   The order is important. CONST first, then VAR, then procedure/function declarations, then BEGIN
                        	    28: 
                        	    29: ;    eg.
                        	    30: ;
                        	    31: ;    const limit = 10;   { <-- this is the start of a block: CONST before VAR }
                        	    32: ;    var k: integer;     { we declare variables and constants here - BEFORE "begin" }
                        	    33: ;    line : array [100] of char;  { array }
                        	    34: ;    function foo;       { and functions and procedures - this is the start of another block}
                        	    35: ;    begin
                        	    36: ;      foo := 42         { assign to function return value }
                        	    37: ;    end;                { end of the function block - note semicolon }
                        	    38: ;    begin               { end of declarations - now we have the block statements }
                        	    39: ;     for k := 1 to limit do
                        	    40: ;       writeln ("square of ", k, " is ", k * k);
                        	    41: ;     write (foo)        { call function }
                        	    42: ;    end.
                        	    43: ;
                        	    44: ;    ARGUMENTS: If the procedure or function does not take arguments OMIT THE BRACKETS.
                        	    45: ;               Likewise, omit the brackets if you call the procedure or function (unlike C)
                        	    46: ;
                        	    47: ;    Semicolons SEPARATE statements, they don't terminate them.
                        	    48: ;
                        	    49: ; Warnings: * Functions which do not assign to the function return value give undefined results.
                        	    50: ;           * Multiplication discards high-order bits if result is too large.
                        	    51: ;           * Divide remainder is always positive (ie. MOD always gives a positive result, regardless of operand signs)
                        	    52: ;           * Function arguments are always integers and always return an integer.
                        	    53: ;           * One to three-byte strings can be used as integer constants
                        	    54: ;               eg. a := "abc"; write (a);   --> Result: 6513249 (ie. 0x636261 or "abc")
                        	    55: ;               The first character is the low-order byte in the number, explaining the above results.
                        	    56: ;           * Strings can start with single or double quotes, whatever starts the string must terminate it.
                        	    57: ;           * String literals can have the same character that started the string embedded, to do that put it twice.
                        	    58: ;             eg. 'Nick''s cat'
                        	    59: ;           * Array access it not range-checked.
                        	    60: ;           * Arrays start at zero. The array size declared is the maximum index (unlike C) so foo: array [10] of integ
                        	    61: ;               would declare an array of 11 elements, numbered from foo [0] to foo [10]
                        	    62: ;           * Maximum arguments to a procedure/function is 85 (255 / 3) due to internal coding
                        	    63: ;
                        	    64: 
                        	    65: 
                        	    66: ;
00:BA45 A2FF            	    67: COMPIL   LDX  #NEW_STK
00:BA47 9A              	    68:   txs    ; set stack back to 0xFF
                        	    69: 
00:BA48 204392          	    70:   jsr  INIT
00:BA4B A901            	    71:   lda  #FLAG_COMPILING
00:BA4D 04BE            	    72:   tsb  system_flags
00:BA4F 20B6C6          	    73:   jsr  add_pascal_library_functions
00:BA52 203ACF          	    74:   jsr  pas_get_token
00:BA55 2039C3          	    75:   jsr  BLOCK
00:BA58 A92E            	    76:   lda  #'.'
00:BA5A A209            	    77:   ldx  #9        ; ERROR: . expected
00:BA5C 209ECF          	    78:   jsr  CHKTKN
00:BA5F A900            	    79:   lda  #0
00:BA61 A213            	    80:   ldx  #19       ; ERROR: Incorrect Symbol
00:BA63 208ECF          	    81:   jsr  GETCHK
00:BA66 209192          	    82:   jsr  CROUT
00:BA69 A948            	    83:   lda  #<pcodes_ended_message  ; P-codes ended at
00:BA6B A293            	    84:   ldx  #>pcodes_ended_message
00:BA6D 202682          	    85:   jsr  print
00:BA70 A524            	    86:   lda  PCODE+1
00:BA72 8544            	    87:   sta  END_PCD+1
00:BA74 200693          	    88:   jsr  PRBYTE
00:BA77 A523            	    89:   lda  PCODE
00:BA79 8543            	    90:   sta  END_PCD
00:BA7B 20BB93          	    91:   jsr  PRBYTECR
00:BA7E 200E8F          	    92:   jsr  show_symbol_table_end
00:BA81 20338F          	    93:   jsr  show_source_end
                        	    94: 
00:BA84 A95B            	    95:   lda  #<compile_finished_message  ; <C>ompile finished: No Errors
00:BA86 A293            	    96:   ldx  #>compile_finished_message
00:BA88 202682          	    97:   jsr  print
00:BA8B A642            	    98:   ldx  SYNTAX
00:BA8D D004            	    99:   bne  END_CMP
00:BA8F A908            	   100:   lda  #FLAG_VALID_COMPILE
00:BA91 04BE            	   101:   tsb  system_flags
                        	   102: END_CMP  =  *
00:BA93 4CCC82          	   103:   jmp  main_prompt
                        	   104: ;
                        	   105: 
                        	   106: ;
                        	   107: CHKLHP   =  *
00:BA96 A928            	   108:          LDA  #'('
00:BA98 A21F            	   109:          LDX  #31     ; ERROR: ( expected
00:BA9A 4C8ECF          	   110:          JMP  GETCHK
                        	   111: ;
                        	   112: CHKRHP   =  *
00:BA9D A929            	   113:          LDA  #')'
00:BA9F A216            	   114:          LDX  #22     ; ERROR: ) expected
00:BAA1 209ECF          	   115:          JSR  CHKTKN
00:BAA4 4C3ACF          	   116:          JMP  pas_get_token
                        	   117: ;
                        	   118: GETSUB   =  *
00:BAA7 20B0BA          	   119:          JSR  CHKLHB
00:BAAA 20C1BD          	   120:          JSR  EXPRES
00:BAAD 4CBABA          	   121:          JMP  CHKRHB
                        	   122: ;
                        	   123: CHKLHB   =  *
00:BAB0 A95B            	   124:          LDA  #'['
00:BAB2 A221            	   125:          LDX  #33     ; ERROR: [ expected
00:BAB4 208ECF          	   126:          JSR  GETCHK
00:BAB7 4C3ACF          	   127:          JMP  pas_get_token
                        	   128: ;
                        	   129: CHKRHB   =  *
00:BABA A95D            	   130:          LDA  #']'
00:BABC A222            	   131:          LDX  #34     ; ERROR: ] expected
00:BABE 209ECF          	   132:          JSR  CHKTKN
00:BAC1 4C3ACF          	   133:          JMP  pas_get_token
                        	   134: ;
                        	   135: GET_LEV  =  *
00:BAC4 A522            	   136:          LDA  LEVEL
00:BAC6 A002            	   137:          LDY  #SYMLVL
00:BAC8 38              	   138:          SEC
00:BAC9 F140            	   139:          SBC  (SYMITM),Y
00:BACB 8527            	   140:          STA  DISPL
00:BACD 60              	   141:          RTS
                        	   142: ;
                        	   143: GET_DAT  =  *
00:BACE A008            	   144:          LDY  #SYMDAT
00:BAD0 B140            	   145:          LDA  (SYMITM),Y
00:BAD2 854A            	   146:          STA  DATTYP
00:BAD4 60              	   147:          RTS
                        	   148: ;
                        	   149: 
                        	   150: 
                        	   151: 
                        	   152: ; CONSTANT DEC
                        	   153: ;
                        	   154: CONDEC   =  *
00:BAD5 A949            	   155:          LDA  #TOKEN_IDENTIFIER
00:BAD7 A204            	   156:          LDX  #4        ; ERROR: Identifier expected
00:BAD9 209ECF          	   157:          JSR  CHKTKN
00:BADC 203293          	   158:          JSR  TKNWRK
00:BADF A592            	   159:          LDA  token_length
00:BAE1 48              	   160:          PHA
00:BAE2 A93D            	   161:          LDA  #'='
00:BAE4 A203            	   162:          LDX  #3        ; ERROR: = expected
00:BAE6 208ECF          	   163:          JSR  GETCHK
00:BAE9 203ACF          	   164:          JSR  pas_get_token
00:BAEC 20C8BB          	   165:          JSR  CONST
00:BAEF 203D93          	   166:          JSR  WRKTKN
00:BAF2 68              	   167:          PLA
00:BAF3 8592            	   168:          STA  token_length
00:BAF5 2035BA          	   169:          JSR  CHKDUP
00:BAF8 A943            	   170:          LDA  #SYMBOL_CONSTANT
00:BAFA 208EB9          	   171:          JSR  ADDSYM
00:BAFD 4C3ACF          	   172:          JMP  pas_get_token
                        	   173: ;
                        	   174: ;
                        	   175: ;--- SYMITM --> WORK
                        	   176: ;
                        	   177: SYMWRK   =  *
00:BB00 48              	   178:          PHA
00:BB01 A540            	   179:          LDA  SYMITM
00:BB03 8537            	   180:          STA  WORK
00:BB05 A541            	   181:          LDA  SYMITM+1
00:BB07 8538            	   182:          STA  WORK+1
00:BB09 68              	   183:          PLA
00:BB0A 60              	   184:          RTS
                        	   185: ;
                        	   186: ;--- WORK --> SYMITM
                        	   187: ;
                        	   188: WRKSYM   =  *
00:BB0B 48              	   189:          PHA
00:BB0C A537            	   190:          LDA  WORK
00:BB0E 8540            	   191:          STA  SYMITM
00:BB10 A538            	   192:          LDA  WORK+1
00:BB12 8541            	   193:          STA  SYMITM+1
00:BB14 68              	   194:          PLA
00:BB15 60              	   195:          RTS
                        	   196: ;
                        	   197: ; PUSH PCODE ONTO STACK
                        	   198: ;
                        	   199: PSHPCODE =  *
00:BB16 8536            	   200:          STA  BSAVE
00:BB18 68              	   201:          PLA
00:BB19 AA              	   202:          TAX
00:BB1A 68              	   203:          PLA
00:BB1B A8              	   204:          TAY
00:BB1C A524            	   205:          LDA  PCODE+1
00:BB1E 48              	   206:          PHA
00:BB1F A523            	   207:          LDA  PCODE
00:BB21 48              	   208:          PHA
00:BB22 98              	   209:          TYA
00:BB23 48              	   210:          PHA
00:BB24 8A              	   211:          TXA
00:BB25 48              	   212:          PHA
00:BB26 A536            	   213:          LDA  BSAVE
00:BB28 60              	   214:          RTS
                        	   215: ;
                        	   216: ;  Get the offset of this current symbol into OFFSET
                        	   217: ;
                        	   218: GET_OFF  =  *
00:BB29 48              	   219:          PHA
00:BB2A A004            	   220:          LDY  #SYMDSP
00:BB2C B140            	   221:          LDA  (SYMITM),Y
00:BB2E 8529            	   222:          STA  OFFSET
00:BB30 C8              	   223:          INY
00:BB31 B140            	   224:          LDA  (SYMITM),Y
00:BB33 852A            	   225:          STA  OFFSET+1
00:BB35 A003            	   226:          LDY  #SYMTYP
00:BB37 B140            	   227:          LDA  (SYMITM),Y
00:BB39 C956            	   228:          CMP  #SYMBOL_VARIABLE
00:BB3B F008            	   229:          BEQ  GETO_1
00:BB3D C941            	   230:          CMP  #SYMBOL_ARRAY
00:BB3F F004            	   231:          BEQ  GETO_1
00:BB41 C959            	   232:          CMP  #SYMBOL_FUNCTION_RETURN
00:BB43 D00D            	   233:          BNE  GETO_2
                        	   234: ;
                        	   235: ;  here if the symbol is a variable, array or function return value
                        	   236: ;   subtract the offset from -3
                        	   237: ;
                        	   238: GETO_1   =  *
00:BB45 38              	   239:          SEC
00:BB46 A9FD            	   240:          LDA  #$FD
00:BB48 E529            	   241:          SBC  OFFSET
00:BB4A 8529            	   242:          STA  OFFSET
00:BB4C A9FF            	   243:          LDA  #$FF
00:BB4E E52A            	   244:          SBC  OFFSET+1
00:BB50 852A            	   245:          STA  OFFSET+1
                        	   246: GETO_2   =  *
00:BB52 68              	   247:          PLA
00:BB53 60              	   248:          RTS
                        	   249: ;
                        	   250: GETEXPR  =  *
00:BB54 203ACF          	   251:          JSR  pas_get_token
00:BB57 4CC1BD          	   252:          JMP  EXPRES
                        	   253: ;
                        	   254: ;
                        	   255: PCD_WRKD =  *
00:BB5A 48              	   256:          PHA
00:BB5B A523            	   257:          LDA  PCODE
00:BB5D 8533            	   258:          STA  WORKD
00:BB5F A524            	   259:          LDA  PCODE+1
00:BB61 8534            	   260:          STA  WORKD+1
00:BB63 68              	   261:          PLA
00:BB64 60              	   262:          RTS
                        	   263: ;
                        	   264: WRK_OPND =  *
00:BB65 48              	   265:          PHA
00:BB66 A537            	   266:          LDA  WORK
00:BB68 852B            	   267:          STA  OPND
00:BB6A A538            	   268:          LDA  WORK+1
00:BB6C 852C            	   269:          STA  OPND+1
00:BB6E 68              	   270:          PLA
00:BB6F 60              	   271:          RTS
                        	   272: ;
                        	   273: WRKD_WRK =  *
00:BB70 48              	   274:          PHA
00:BB71 A533            	   275:          LDA  WORKD
00:BB73 8537            	   276:          STA  WORK
00:BB75 A534            	   277:          LDA  WORKD+1
00:BB77 8538            	   278:          STA  WORK+1
00:BB79 68              	   279:          PLA
00:BB7A 60              	   280:          RTS
                        	   281: ;
                        	   282: WRK_WRKD =  *
00:BB7B 48              	   283:          PHA
00:BB7C A537            	   284:          LDA  WORK
00:BB7E 8533            	   285:          STA  WORKD
00:BB80 A538            	   286:          LDA  WORK+1
00:BB82 8534            	   287:          STA  WORKD+1
00:BB84 68              	   288:          PLA
00:BB85 60              	   289:          RTS
                        	   290: ;
                        	   291: GET_COMM =  *
00:BB86 A92C            	   292:          LDA  #','
00:BB88 A220            	   293:          LDX  #32     ; ERROR: , expected
00:BB8A 4C9ECF          	   294:          JMP  CHKTKN
                        	   295: ;
                        	   296: GET_ITEM =  *
00:BB8D 2086BB          	   297:          JSR  GET_COMM   ; check for comma
00:BB90 4C54BB          	   298:          JMP  GETEXPR
                        	   299: ;
                        	   300: ;  Load (push) a constant (ie. a literal number)
                        	   301: ;
                        	   302: ;  Numbers in the range 0 to 0x7F are turned into a "low literal" which is a P-code
                        	   303: ;  with the 0x80 bit set. These then become a single-byte P-code which simply pushes
                        	   304: ;  that number onto the stack, thus saving having to have a 4-byte P-code being PCODE_LIT
                        	   305: ;  followed by a 3-byte number, 2 bytes of which would be zero.
                        	   306: ;
                        	   307: VAL_MOVE =  *
00:BB93 48              	   308:          PHA
00:BB94 18              	   309:          CLC
00:BB95 A594            	   310:          LDA  token_value
00:BB97 8527            	   311:          STA  DISPL   ; why?
00:BB99 1001            	   312:          BPL  VAL_1   ; is it 0x00 to 0x7F?
00:BB9B 38              	   313:          SEC          ; no, set carry bit
                        	   314: VAL_1    =  *
00:BB9C A595            	   315:          LDA  token_value+1
00:BB9E F001            	   316:          BEQ  VAL_2   ; is second byte 0x00?
00:BBA0 38              	   317:          SEC          ; no, set carry bit
                        	   318: VAL_2    =  *
00:BBA1 8529            	   319:          STA  OFFSET
00:BBA3 A596            	   320:          LDA  token_value+2
00:BBA5 852A            	   321:          STA  OFFSET+1
00:BBA7 F001            	   322:          BEQ  VAL_3   ; is third byte 0x00?
00:BBA9 38              	   323:          SEC          ; no, set carry bit
                        	   324: VAL_3    =  *
00:BBAA 9007            	   325:          BCC  VAL_5   ; did we ever set the carry bit?
00:BBAC A900            	   326:          LDA  #PCODE_LIT  ; yes, so just generate a "load literal"
00:BBAE 2079C7          	   327:          JSR  GENADR
00:BBB1 68              	   328:          PLA
00:BBB2 60              	   329:          RTS
                        	   330: VAL_5    =  *
00:BBB3 A594            	   331:          LDA  token_value   ; get the low-order byte back
00:BBB5 0980            	   332:          ORA  #$80    ; set the 0x80 bit as a flag
00:BBB7 2060C7          	   333:          JSR  GENNOP  ; output one P-code
00:BBBA 68              	   334:          PLA
00:BBBB 60              	   335:          RTS
                        	   336: ;
                        	   337: ;
                        	   338: CHK_STAK =  *
00:BBBC BA              	   339:          TSX
00:BBBD 8A              	   340:          TXA
00:BBBE C920            	   341:          CMP  #MAX_STK
00:BBC0 9001            	   342:          BCC  STK_FULL
00:BBC2 60              	   343:          RTS
                        	   344: STK_FULL =  *
00:BBC3 A21B            	   345: STK_ERR  LDX  #27     ; ERROR: Stack full
00:BBC5 4CCD97          	   346:          jmp  ERROR      ; FULL
                        	   347: ;
                        	   348: ;
                        	   349: ; CONST get the value into token_value
                        	   350: ;
                        	   351: CONST    =  *
00:BBC8 A593            	   352:          LDA  token_type
00:BBCA C94E            	   353:          CMP  #TOKEN_NUMBER
00:BBCC F01F            	   354:          BEQ  CONST9
00:BBCE C949            	   355:          CMP  #TOKEN_IDENTIFIER
00:BBD0 F00D            	   356:          BEQ  CONST1
00:BBD2 C922            	   357:          CMP  #TOKEN_STRING
00:BBD4 D00E            	   358:          BNE  CONST3
00:BBD6 A692            	   359:          LDX  token_length
00:BBD8 E004            	   360:          CPX  #4
00:BBDA 9011            	   361:          BCC  CONST9
00:BBDC 4C70BD          	   362:          JMP  FACERR1    ; STRING TOO BIG
00:BBDF 2012B9          	   363: CONST1   JSR  SEARCH
00:BBE2 D005            	   364:          BNE  CONST2
                        	   365: CONST3   =  *
00:BBE4 A202            	   366:          LDX  #2        ; ERROR: Constant expected
00:BBE6 4CCD97          	   367:          jmp  ERROR
00:BBE9 C943            	   368: CONST2   CMP  #SYMBOL_CONSTANT
00:BBEB D0F7            	   369:          BNE  CONST3
00:BBED 60              	   370: CONST9   RTS
                        	   371: ;
                        	   372: ; VARIABLE DEC
                        	   373: ;
00:BBEE A949            	   374: VARDEC   LDA  #TOKEN_IDENTIFIER
00:BBF0 A204            	   375:          LDX  #4      ; ERROR: Identifier expected
00:BBF2 209ECF          	   376:          JSR  CHKTKN
00:BBF5 2035BA          	   377:          JSR  CHKDUP
00:BBF8 A956            	   378:          LDA  #SYMBOL_VARIABLE
00:BBFA 208EB9          	   379:          JSR  ADDSYM
00:BBFD 4C3ACF          	   380:          JMP  pas_get_token
                        	   381: ;
                        	   382: ; SIMPLE EXPRESSION
                        	   383: ;
                        	   384: SIMEXP   =  *
00:BC00 A593            	   385:          LDA  token_type
00:BC02 C92B            	   386:          CMP  #'+'
00:BC04 F004            	   387:          BEQ  SIM1
00:BC06 C92D            	   388:          CMP  #'-'
00:BC08 D048            	   389:          BNE  SIM2
00:BC0A 48              	   390: SIM1     PHA
00:BC0B 203ACF          	   391:          JSR  pas_get_token
00:BC0E 2072BC          	   392:          JSR  TERM
00:BC11 68              	   393:          PLA
00:BC12 C92D            	   394:          CMP  #'-'
00:BC14 D005            	   395:          BNE  SIM3
00:BC16 A902            	   396:          LDA  #PCODE_NEG      ; NEG       Negate (sp)
00:BC18 2060C7          	   397:          JSR  GENNOP     ; NEGATE
00:BC1B A593            	   398: SIM3     LDA  token_type
00:BC1D C92B            	   399:          CMP  #'+'
00:BC1F F00D            	   400:          BEQ  SIM4
00:BC21 C92D            	   401:          CMP  #'-'
00:BC23 F009            	   402:          BEQ  SIM4
00:BC25 C98A            	   403:          CMP  #TOKEN_OR       ; OR
00:BC27 F005            	   404:          BEQ  SIM4
00:BC29 C9A4            	   405:          CMP  #TOKEN_XOR      ; XOR
00:BC2B F001            	   406:          BEQ  SIM4
00:BC2D 60              	   407:          RTS
00:BC2E 48              	   408: SIM4     PHA
00:BC2F 203ACF          	   409:          JSR  pas_get_token
00:BC32 2072BC          	   410:          JSR  TERM
00:BC35 68              	   411:          PLA
00:BC36 C92D            	   412:          CMP  #'-'
00:BC38 F010            	   413:          BEQ  SIM5
00:BC3A C92B            	   414:          CMP  #'+'
00:BC3C F010            	   415:          BEQ  SIM6
00:BC3E C9A4            	   416:          CMP  #TOKEN_XOR          ; XOR
00:BC40 F016            	   417:          BEQ  SIM8
00:BC42 A91A            	   418:          LDA  #PCODE_ORR          ; ORR       OR  (sp - 1) | (sp)
00:BC44 2060C7          	   419: SIM7     JSR  GENNOP
00:BC47 4C1BBC          	   420:          JMP  SIM3
00:BC4A A906            	   421: SIM5     LDA  #PCODE_SUB          ; MINUS
00:BC4C D0F6            	   422:          BNE  SIM7
00:BC4E A904            	   423: SIM6     LDA  #PCODE_ADD          ; PLUS
00:BC50 D0F2            	   424:          BNE  SIM7
00:BC52 2072BC          	   425: SIM2     JSR  TERM
00:BC55 4C1BBC          	   426:          JMP  SIM3
00:BC58 A93A            	   427: SIM8     LDA  #PCODE_XOR         ; XOR
00:BC5A D0E8            	   428:          BNE  SIM7
                        	   429: ;
                        	   430: ; TERM
                        	   431: ;
00:BC5C 2A              	   432: TERMT1   ASC    '*'
00:BC5D 7FBC            	   433:          word   TERM1
00:BC5F 8B              	   434:          DFB    TOKEN_DIV    ; div
00:BC60 7FBC            	   435:          word   TERM1
00:BC62 2F              	   436:          ASC    '/'
00:BC63 7FBC            	   437:          word   TERM1
00:BC65 8D              	   438:          DFB    TOKEN_AND    ; and
00:BC66 7FBC            	   439:          word   TERM1
00:BC68 8C              	   440:          DFB    TOKEN_MOD    ; mod
00:BC69 7FBC            	   441:          word   TERM1
00:BC6B 8E              	   442:          DFB    TOKEN_SHL    ; shl
00:BC6C 7FBC            	   443:          word   TERM1
00:BC6E 8F              	   444:          DFB    TOKEN_SHR    ; shr
00:BC6F 7FBC            	   445:          word   TERM1
00:BC71 00              	   446:          DFB    0
                        	   447: ;
00:BC72 20C0BC          	   448: TERM     JSR  FACTOR
00:BC75 A25C            	   449: TERM2    LDX  #<TERMT1
00:BC77 A0BC            	   450:          LDY  #>TERMT1
00:BC79 A593            	   451:          LDA  token_type
00:BC7B 20FB8F          	   452:          JSR  TKNJMP
00:BC7E 60              	   453:          RTS
                        	   454: ;
00:BC7F 48              	   455: TERM1    PHA
00:BC80 203ACF          	   456:          JSR  pas_get_token
00:BC83 20C0BC          	   457:          JSR  FACTOR
00:BC86 68              	   458:          PLA
00:BC87 A2AA            	   459:          LDX  #<TERMT3
00:BC89 A0BC            	   460:          LDY  #>TERMT3
00:BC8B 20FB8F          	   461:          JSR  TKNJMP
                        	   462: ;
00:BC8E A90A            	   463: TERM4    LDA  #PCODE_DIV       ; Divide (sp - 1) / (sp)
00:BC90 2060C7          	   464: TERM3    JSR  GENNOP
00:BC93 4C75BC          	   465:          JMP  TERM2
00:BC96 A91B            	   466: TERM5    LDA  #PCODE_AND        ; AND
00:BC98 D0F6            	   467:          BNE  TERM3
00:BC9A A90B            	   468: TERM6    LDA  #PCODE_MOD        ; MOD
00:BC9C D0F2            	   469:          BNE  TERM3
00:BC9E A922            	   470: TERM7    LDA  #PCODE_SHL       ; Shift left (sp) bits
00:BCA0 D0EE            	   471:          BNE  TERM3
00:BCA2 A924            	   472: TERM8    LDA  #PCODE_SHR       ; Shift right (sp) bits
00:BCA4 D0EA            	   473:          BNE  TERM3
00:BCA6 A908            	   474: TERM9    LDA  #PCODE_MUL        ; Multiply (sp) * (sp - 1)
00:BCA8 D0E6            	   475:          BNE  TERM3
                        	   476: ;
00:BCAA 8B              	   477: TERMT3   DFB    TOKEN_DIV     ; div
00:BCAB 8EBC            	   478:          word   TERM4
00:BCAD 2F              	   479:          ASC    '/'
00:BCAE 8EBC            	   480:          word   TERM4
00:BCB0 8D              	   481:          DFB    TOKEN_AND     ; and
00:BCB1 96BC            	   482:          word   TERM5
00:BCB3 8C              	   483:          DFB    TOKEN_MOD     ; mod
00:BCB4 9ABC            	   484:          word   TERM6
00:BCB6 8E              	   485:          DFB    TOKEN_SHL     ; shl
00:BCB7 9EBC            	   486:          word   TERM7
00:BCB9 8F              	   487:          DFB    TOKEN_SHR     ; shr
00:BCBA A2BC            	   488:          word   TERM8
00:BCBC 2A              	   489:          ASC    '*'
00:BCBD A6BC            	   490:          word   TERM9
00:BCBF 00              	   491:          DFB  0
                        	   492: ;
                        	   493: ; FACTOR
                        	   494: ;
00:BCC0 20BCBB          	   495: FACTOR   JSR  CHK_STAK
00:BCC3 A593            	   496:          LDA  token_type
00:BCC5 A2A8            	   497:          LDX  #<FACTB1
00:BCC7 A0BD            	   498:          LDY  #>FACTB1
00:BCC9 20FB8F          	   499:          JSR  TKNJMP
00:BCCC A217            	   500:          LDX  #23     ; ERROR: Illegal factor
00:BCCE 4CCD97          	   501:          jmp  ERROR
                        	   502: ;
00:BCD1 202ABA          	   503: IDENT    JSR  LOOKUP
00:BCD4 C950            	   504: IDENT1   CMP  #SYMBOL_PROCEDURE
00:BCD6 F004            	   505:          beq  IDENT1A
00:BCD8 C951            	   506:          CMP  #SYMBOL_LIBRARY_PROCEDURE
00:BCDA D005            	   507:          BNE  IDENT2
                        	   508: IDENT1A:
00:BCDC A215            	   509:          LDX  #21     ; ERROR: Use of procedure Identifier in expression
00:BCDE 4CCD97          	   510:          jmp  ERROR
00:BCE1 C959            	   511: IDENT2   CMP  #SYMBOL_FUNCTION_RETURN
00:BCE3 D015            	   512:          BNE  IDENT2A
00:BCE5 A000            	   513:          LDY  #SYMPRV      ; this symbol is actually the function return value symbol
00:BCE7 B140            	   514:          LDA  (SYMITM),Y   ; so go to the previous symbol which will be the function
00:BCE9 AA              	   515:          TAX               ; declaration symbol with the address of the function to be called
00:BCEA C8              	   516:          INY
00:BCEB B140            	   517:          LDA  (SYMITM),Y
00:BCED 8541            	   518:          STA  SYMITM+1
00:BCEF 8A              	   519:          TXA
00:BCF0 8540            	   520:          STA  SYMITM
00:BCF2 A980            	   521:          lda  #$80       ; push 0 onto the stack which will be the default function return value
00:BCF4 2060C7          	   522:          jsr  GENNOP     ; when the function returns this will be left on the top of the stack
00:BCF7 4C41C0          	   523:          JMP  FNCPRC     ; with the function's assigned value in it (or zero if nothing assigned);
                        	   524: 
00:BCFA C952            	   525: IDENT2A  CMP #SYMBOL_LIBRARY_FUNCTION
00:BCFC D003            	   526:          bne IDENT3
00:BCFE 4C10C7          	   527:          jmp  library_function_call
                        	   528: 
00:BD01 C941            	   529: IDENT3   CMP  #SYMBOL_ARRAY
00:BD03 F030            	   530:          BEQ  IDENT4
00:BD05 C943            	   531:          CMP  #SYMBOL_CONSTANT
00:BD07 D00E            	   532:          BNE  IDENT5
00:BD09 2093BB          	   533:          JSR  VAL_MOVE
00:BD0C 4C2ABD          	   534:          JMP  IDENT7
                        	   535: ;
                        	   536: ;   Here for address of integer variable
                        	   537: ;
00:BD0F A90C            	   538: FACAD1   LDA  #PCODE_ADRNN
00:BD11 2019BD          	   539:          JSR  IDENT5_A
00:BD14 4C9DBA          	   540:          JMP  CHKRHP
                        	   541: ;
00:BD17 A92C            	   542: IDENT5   LDA  #PCODE_LOD   ; load integer onto stack
00:BD19 48              	   543: IDENT5_A PHA
                        	   544: ;
00:BD1A 8636            	   545:          STX  BSAVE
00:BD1C A522            	   546:          LDA  LEVEL
00:BD1E 38              	   547:          SEC
00:BD1F E536            	   548:          SBC  BSAVE
00:BD21 8527            	   549:          STA  DISPL
00:BD23 68              	   550:          PLA
00:BD24 18              	   551: IDENT6   CLC
00:BD25 654A            	   552:          ADC  DATTYP
00:BD27 2079C7          	   553:          JSR  GENADR
00:BD2A 4C3ACF          	   554: IDENT7   JMP  pas_get_token
                        	   555: ;
00:BD2D A90E            	   556: FACAD2   LDA  #PCODE_ADRAN  ; address of integer array
00:BD2F 2037BD          	   557:          JSR  IDENT4_A
00:BD32 4C9DBA          	   558:          JMP  CHKRHP
                        	   559: ;
                        	   560: ;    Here for load indexed integer
                        	   561: ;
00:BD35 A930            	   562: IDENT4   LDA  #PCODE_LDI         ; Load integer indexed
00:BD37 48              	   563: IDENT4_A PHA
                        	   564: ;
00:BD38 2000BB          	   565:          JSR  SYMWRK
00:BD3B 20C892          	   566:          JSR  PSHWRK
00:BD3E 20A7BA          	   567:          JSR  GETSUB
00:BD41 20DB92          	   568:          JSR  PULWRK
00:BD44 200BBB          	   569:          JSR  WRKSYM
00:BD47 20CEBA          	   570:          JSR  GET_DAT
00:BD4A 20C4BA          	   571:          JSR  GET_LEV
00:BD4D 2029BB          	   572:          JSR  GET_OFF
00:BD50 68              	   573:          PLA
00:BD51 18              	   574:          CLC
00:BD52 654A            	   575:          ADC  DATTYP
00:BD54 4C79C7          	   576:          JMP  GENADR
                        	   577: ;
                        	   578: ; ADDRESS (IDENTIFIER)
                        	   579: ;
                        	   580: ;
                        	   581: FACADR   =  *
00:BD57 2096BA          	   582:          JSR  CHKLHP
00:BD5A 20A3CF          	   583:          JSR  GET_LOOK
00:BD5D C956            	   584:          CMP  #SYMBOL_VARIABLE
00:BD5F F0AE            	   585:          BEQ  FACAD1
00:BD61 C941            	   586:          CMP  #SYMBOL_ARRAY
00:BD63 F0C8            	   587:          BEQ  FACAD2
00:BD65 A217            	   588:          LDX  #23     ; ERROR: Illegal factor
00:BD67 4CCD97          	   589:          jmp  ERROR
                        	   590: ;
                        	   591: ;
00:BD6A A592            	   592: FACSTR   LDA  token_length
00:BD6C C904            	   593:          CMP  #4
00:BD6E 9005            	   594:          BCC  FACNUM    ; BLT
00:BD70 A21D            	   595: FACERR1  LDX  #29        ; ERROR: string literal too big
00:BD72 4CCD97          	   596:          jmp  ERROR
                        	   597: FACNUM   =  *
00:BD75 2093BB          	   598:          JSR  VAL_MOVE
00:BD78 4C2ABD          	   599:          JMP  IDENT7
                        	   600: ;
00:BD7B 2054BB          	   601: PAREN    JSR  GETEXPR
00:BD7E 4C9DBA          	   602:          JMP  CHKRHP
                        	   603: ;
00:BD81 A900            	   604: FACMEM   LDA  #0          ; add zero below to get PCODE_LDA
00:BD83 854A            	   605:          STA  DATTYP
00:BD85 F004            	   606:          BEQ  FACM2
00:BD87 A901            	   607: FACMMC   LDA  #1          ; add one below to get PCODE_LDAC
00:BD89 854A            	   608:          STA  DATTYP
00:BD8B A54A            	   609: FACM2    LDA  DATTYP
00:BD8D 48              	   610:          PHA
00:BD8E 20A7BA          	   611:          JSR  GETSUB
00:BD91 68              	   612:          PLA
00:BD92 18              	   613:          CLC
00:BD93 692E            	   614:          ADC  #PCODE_LDA    ; Load absolute address integer or PCODE_LDAC if we added 1
00:BD95 D008            	   615:          BNE  GENNOP1
                        	   616: ;
00:BD97 203ACF          	   617: FACNOT   JSR  pas_get_token
00:BD9A 20C0BC          	   618:          JSR  FACTOR
00:BD9D A920            	   619:          LDA  #PCODE_EOR     ; Not (sp) (logical negate)
00:BD9F 4C60C7          	   620: GENNOP1  JMP  GENNOP
                        	   621: ;
00:BDA2 2060C7          	   622: FACRND1  JSR  GENNOP
00:BDA5 4C3ACF          	   623:          JMP  pas_get_token
                        	   624: ;
                        	   625: ;
                        	   626: ;
00:BDA8 49              	   627: FACTB1   DFB    TOKEN_IDENTIFIER
00:BDA9 D1BC            	   628:          word   IDENT
00:BDAB 4E              	   629:          ASC    TOKEN_NUMBER
00:BDAC 75BD            	   630:          word   FACNUM
00:BDAE 22              	   631: FACTQT1  DFB    TOKEN_STRING        ; QUOTE SYMBOL
00:BDAF 6ABD            	   632:          word   FACSTR
00:BDB1 28              	   633:          ASC    '('
00:BDB2 7BBD            	   634:          word   PAREN
00:BDB4 91              	   635:          DFB    TOKEN_MEM
00:BDB5 81BD            	   636:          word   FACMEM     ; MEM
00:BDB7 90              	   637:          DFB    TOKEN_NOT
00:BDB8 97BD            	   638:          word   FACNOT
00:BDBA A2              	   639:          DFB    TOKEN_MEMC
00:BDBB 87BD            	   640:          word   FACMMC     ; MEMC
00:BDBD A9              	   641:          DFB    TOKEN_ADDRESS
00:BDBE 57BD            	   642:          word   FACADR
00:BDC0 00              	   643:          DFB  0
                        	   644: ;
                        	   645: ; EXPRESSION
                        	   646: ;
00:BDC1 20BCBB          	   647: EXPRES   JSR  CHK_STAK
00:BDC4 2000BC          	   648:          JSR  SIMEXP
00:BDC7 A593            	   649:          LDA  token_type
00:BDC9 A2D1            	   650:          LDX  #<EXPTB1
00:BDCB A0BD            	   651:          LDY  #>EXPTB1
00:BDCD 20FB8F          	   652:          JSR  TKNJMP
00:BDD0 60              	   653:          RTS
                        	   654: ;
00:BDD1 3D              	   655: EXPTB1   ASC    '='
00:BDD2 E4BD            	   656:          word   EXPR1
00:BDD4 55              	   657:          DFB    TOKEN_NEQ
00:BDD5 E4BD            	   658:          word   EXPR1
00:BDD7 3C              	   659:          ASC    '<'
00:BDD8 E4BD            	   660:          word   EXPR1
00:BDDA 80              	   661:          DFB    TOKEN_LEQ
00:BDDB E4BD            	   662:          word   EXPR1
00:BDDD 81              	   663:          DFB    TOKEN_GEQ
00:BDDE E4BD            	   664:          word   EXPR1
00:BDE0 3E              	   665:          ASC    '>'
00:BDE1 E4BD            	   666:          word   EXPR1
00:BDE3 00              	   667:          DFB  0
                        	   668: ;
00:BDE4 48              	   669: EXPR1    PHA
00:BDE5 203ACF          	   670:          JSR  pas_get_token
00:BDE8 2000BC          	   671:          JSR  SIMEXP
00:BDEB 68              	   672:          PLA
00:BDEC A2F3            	   673:          LDX  #<EXPTB3
00:BDEE A0BD            	   674:          LDY  #>EXPTB3
00:BDF0 20FB8F          	   675:          JSR  TKNJMP
                        	   676: ;
00:BDF3 3D              	   677: EXPTB3   ASC    '='
00:BDF4 06BE            	   678:          word   EXPR2
00:BDF6 55              	   679:          ASC    TOKEN_NEQ
00:BDF7 0CBE            	   680:          word   EXPR3
00:BDF9 3C              	   681:          ASC    '<'
00:BDFA 10BE            	   682:          word   EXPR4
00:BDFC 81              	   683:          DFB    TOKEN_GEQ
00:BDFD 14BE            	   684:          word   EXPR5
00:BDFF 3E              	   685:          ASC    '>'
00:BE00 18BE            	   686:          word   EXPR6
00:BE02 80              	   687:          DFB    TOKEN_LEQ
00:BE03 1CBE            	   688:          word   EXPR7
00:BE05 00              	   689:          DFB  0
                        	   690: ;
00:BE06 A910            	   691: EXPR2    LDA  #PCODE_EQL       ; EQL      Test (sp - 1) == (sp)
00:BE08 2060C7          	   692: EXPR8    JSR  GENNOP
00:BE0B 60              	   693:          RTS
00:BE0C A912            	   694: EXPR3    LDA  #PCODE_NEQ       ; NEQ      Test (sp - 1) != (sp)
00:BE0E D0F8            	   695:          BNE  EXPR8
00:BE10 A914            	   696: EXPR4    LDA  #PCODE_LSS       ; LSS      Test (sp - 1) < (sp)
00:BE12 D0F4            	   697:          BNE  EXPR8
00:BE14 A916            	   698: EXPR5    LDA  #PCODE_GEQ       ; GEQ      Test (sp - 1) >= (sp)
00:BE16 D0F0            	   699:          BNE  EXPR8
00:BE18 A918            	   700: EXPR6    LDA  #PCODE_GTR       ; GTR      Test (sp - 1) > (sp)
00:BE1A D0EC            	   701:          BNE  EXPR8
00:BE1C A919            	   702: EXPR7    LDA  #PCODE_LEQ       ; LEQ      Test (sp - 1) <= (sp)
00:BE1E D0E8            	   703:          BNE  EXPR8
                        	   704: ;
                        	   705: ; STATEMENT
                        	   706: ;
00:BE20 20BCBB          	   707: STMNT    JSR  CHK_STAK
00:BE23 A593            	   708:          LDA  token_type
00:BE25 A22D            	   709:          LDX  #<STMNT1
00:BE27 A0BE            	   710:          LDY  #>STMNT1
00:BE29 20FB8F          	   711:          JSR  TKNJMP
00:BE2C 60              	   712:          RTS
                        	   713: ;
00:BE2D 49              	   714: STMNT1   DFB    TOKEN_IDENTIFIER
00:BE2E 58BE            	   715:          word   ASSIGN
00:BE30 92              	   716:          DFB    TOKEN_IF
00:BE31 C8C0            	   717:          word   IF
00:BE33 9A              	   718:          DFB    TOKEN_FOR
00:BE34 2FC2            	   719:          word   FOR
00:BE36 96              	   720:          DFB    TOKEN_WHILE
00:BE37 42C1            	   721:          word   WHILE
00:BE39 95              	   722:          DFB    TOKEN_CASE
00:BE3A 74C1            	   723:          word   CASE
00:BE3C 98              	   724:          DFB    TOKEN_REPEAT
00:BE3D 1EC1            	   725:          word   REPEAT
00:BE3F 88              	   726:          DFB    TOKEN_BEGIN
00:BE40 08C1            	   727:          word   BEG
00:BE42 9E              	   728:          DFB    TOKEN_READ
00:BE43 70BF            	   729:          word   READ
00:BE45 9D              	   730:          DFB    TOKEN_WRITE
00:BE46 CEBE            	   731:          word   WRITE
00:BE48 91              	   732:          DFB    TOKEN_MEM
00:BE49 19C0            	   733:          word   MEM
00:BE4B 9F              	   734:          DFB    TOKEN_CALL
00:BE4C 34C0            	   735:          word   CALLSB
00:BE4E A2              	   736:          DFB    TOKEN_MEMC
00:BE4F 1EC0            	   737:          word   MEMC
00:BE51 FF              	   738:          DFB    TOKEN_WRITELN
00:BE52 BFBE            	   739:          word   WRITELN
00:BE54 F1              	   740:          DB     TOKEN_LCDWRITE
00:BE55 1FBF            	   741:          word   STMNT_WRITE_LCD
00:BE57 00              	   742:          DFB  0
                        	   743: ;
                        	   744: ; ASSIGNMENT - this is where we store an integer/char into a variable or array index
                        	   745: ;
00:BE58 202ABA          	   746: ASSIGN   JSR  LOOKUP
00:BE5B A267            	   747: ASS1     LDX  #<ASSTB1
00:BE5D A0BE            	   748:          LDY  #>ASSTB1
00:BE5F 20FB8F          	   749:          JSR  TKNJMP
00:BE62 A218            	   750:          LDX  #24     ; ERROR: Type mismatch
00:BE64 4CCD97          	   751:          jmp  ERROR
                        	   752: ;
00:BE67 41              	   753: ASSTB1   DFB   SYMBOL_ARRAY
00:BE68 82BE            	   754:          word  ASSARR
00:BE6A 56              	   755:          DFB   SYMBOL_VARIABLE
00:BE6B 94BE            	   756:          word  ASSVAR
00:BE6D 59              	   757:          DFB   SYMBOL_FUNCTION_RETURN
00:BE6E 94BE            	   758:          word  ASSVAR
00:BE70 50              	   759:          DFB   SYMBOL_PROCEDURE
00:BE71 41C0            	   760:          word  FNCPRC
00:BE73 51              	   761:          DFB   SYMBOL_LIBRARY_PROCEDURE
00:BE74 10C7            	   762:          word  library_function_call
00:BE76 46              	   763:          DFB   SYMBOL_FUNCTION
00:BE77 7DBE            	   764:          word  assign_bad_identifier
00:BE79 52              	   765:          DFB   SYMBOL_LIBRARY_FUNCTION
00:BE7A 7DBE            	   766:          word  assign_bad_identifier
00:BE7C 00              	   767:          DFB  0
                        	   768: 
                        	   769: assign_bad_identifier:
00:BE7D A235            	   770:           ldx #53   ; ERROR: Use of function identifier in statement
00:BE7F 4CCD97          	   771:           jmp ERROR
                        	   772: ;
00:BE82 2000BB          	   773: ASSARR   JSR  SYMWRK
00:BE85 20C892          	   774:          JSR  PSHWRK
00:BE88 A936            	   775:          LDA  #PCODE_STI    ; Store integer indexed
00:BE8A 18              	   776:          CLC
00:BE8B 654A            	   777:          ADC  DATTYP        ; A becomes PCODE_STIC (Store character indexed) if DATTYP == 1
00:BE8D 48              	   778:          PHA
00:BE8E 20A7BA          	   779:          JSR  GETSUB
00:BE91 4CA3BE          	   780:          JMP  ASS2
                        	   781: ;
00:BE94 2000BB          	   782: ASSVAR   JSR  SYMWRK
00:BE97 20C892          	   783:          JSR  PSHWRK
00:BE9A A932            	   784:          LDA  #PCODE_STO    ;  Store integer
00:BE9C 18              	   785:          CLC
00:BE9D 654A            	   786:          ADC  DATTYP        ; A becomes PCODE_STOC (Store character indexed) if DATTYP == 1
00:BE9F 48              	   787:          PHA
00:BEA0 203ACF          	   788:          JSR  pas_get_token
00:BEA3 A941            	   789: ASS2     LDA  #TOKEN_ASSIGN
00:BEA5 A20D            	   790:          LDX  #13       ; ERROR: := expected
00:BEA7 209ECF          	   791:          JSR  CHKTKN
00:BEAA 2054BB          	   792:          JSR  GETEXPR
00:BEAD 68              	   793:          PLA
00:BEAE 20DB92          	   794:          JSR  PULWRK
00:BEB1 200BBB          	   795:          JSR  WRKSYM
00:BEB4 48              	   796:          PHA
00:BEB5 20C4BA          	   797:          JSR  GET_LEV
00:BEB8 2029BB          	   798:          JSR  GET_OFF
00:BEBB 68              	   799:          PLA
00:BEBC 4C79C7          	   800:          JMP  GENADR
                        	   801: ;
                        	   802: 
                        	   803: ;
                        	   804: ;
                        	   805: ; WRITELN
                        	   806: ;
00:BEBF 203ACF          	   807: WRITELN  JSR  pas_get_token     ; SEE IF ( PRESENT
00:BEC2 C928            	   808:          CMP  #'('
00:BEC4 D003            	   809:          BNE  WRITELN9   ; NOPE
00:BEC6 20D1BE          	   810:          JSR  WRIT9
                        	   811: WRITELN9 =  *
00:BEC9 A940            	   812:          LDA  #PCODE_OUTCR   ; OUTPUT C/R
00:BECB 4C60C7          	   813:          JMP  GENNOP
                        	   814: ;
                        	   815: ;
                        	   816: ; WRITE
                        	   817: ;
00:BECE 2096BA          	   818: WRITE    JSR  CHKLHP
00:BED1 203ACF          	   819: WRIT9    JSR  pas_get_token
00:BED4 C922            	   820:          CMP  #TOKEN_STRING
00:BED6 D022            	   821:          BNE  WRIT1
00:BED8 A923            	   822:          LDA  #PCODE_OUS    ; Output string
00:BEDA 20E0BE          	   823:          JSR  W_STRING
00:BEDD 4C0ABF          	   824:          JMP  WRIT5
                        	   825: ;
                        	   826: W_STRING =  *
00:BEE0 2060C7          	   827:          JSR  GENNOP
00:BEE3 A592            	   828:          LDA  token_length
00:BEE5 2060C7          	   829:          JSR  GENNOP
00:BEE8 A000            	   830:          LDY  #0
00:BEEA B90002          	   831: WRIT2    LDA  INBUF,Y
00:BEED C8              	   832: WRIT10   INY
00:BEEE 5A              	   833:          phy
00:BEEF 2060C7          	   834:          JSR  GENNOP
00:BEF2 7A              	   835:          ply
00:BEF3 C692            	   836:          DEC  token_length
00:BEF5 D0F3            	   837:          BNE  WRIT2
00:BEF7 4C3ACF          	   838:          JMP  pas_get_token
                        	   839: ;
                        	   840: WRIT1    =  *          ; here if not string
00:BEFA C9AB            	   841:          CMP  #TOKEN_CHR       ; CHR?
00:BEFC F015            	   842:          BEQ  W_CHR      ; yes
00:BEFE C9AC            	   843:          CMP  #TOKEN_HEX       ; HEX?
00:BF00 F019            	   844:          BEQ  W_HEX      ; yes
00:BF02 20C1BD          	   845:          JSR  EXPRES     ; just ordinary number - get it
00:BF05 A91E            	   846:          LDA  #PCODE_OUT        ; OUT       Output number
00:BF07 2060C7          	   847:          JSR  GENNOP
00:BF0A A593            	   848: WRIT5    LDA  token_type
00:BF0C C92C            	   849:          CMP  #','
00:BF0E F0C1            	   850:          BEQ  WRIT9
00:BF10 4C9DBA          	   851:          JMP  CHKRHP
                        	   852: ;
                        	   853: ; here for write (chr(x))
                        	   854: ;
                        	   855: W_CHR    =  *
00:BF13 A91F            	   856:          LDA  #PCODE_OUTC   ; OUTC      Output character
                        	   857: W_CHR1   =  *
00:BF15 200FC0          	   858:          JSR  WAIT_1     ; process expression in parentheses
00:BF18 4C0ABF          	   859:          JMP  WRIT5      ; back for next item
                        	   860: ;
                        	   861: ; here for write (hex(x))
                        	   862: ;
                        	   863: W_HEX    =  *
00:BF1B A921            	   864:          LDA  #PCODE_OUH        ; OUH       Output hex number
00:BF1D D0F6            	   865:          BNE  W_CHR1
                        	   866: 
                        	   867: ;
                        	   868: ;
                        	   869: ; WRITELCD: can write number, string, hex or chr
                        	   870: ;
00:BF1F 2096BA          	   871: STMNT_WRITE_LCD    JSR  CHKLHP
00:BF22 203ACF          	   872: WRITE_LCD9    JSR  pas_get_token
00:BF25 C922            	   873:          CMP  #TOKEN_STRING
00:BF27 D022            	   874:          BNE  WRITE_LCD1
00:BF29 A943            	   875:          LDA  #PCODE_LCD_WRITE_STR    ; Output string
00:BF2B 2031BF          	   876:          JSR  WRITE_LCD_STRING
00:BF2E 4C5BBF          	   877:          JMP  WRITE_LCD5
                        	   878: ;
                        	   879: WRITE_LCD_STRING =  *
00:BF31 2060C7          	   880:          JSR  GENNOP
00:BF34 A592            	   881:          LDA  token_length
00:BF36 2060C7          	   882:          JSR  GENNOP
00:BF39 A000            	   883:          LDY  #0
00:BF3B B90002          	   884: WRITE_LCD2    LDA  INBUF,Y    ; strings are placed in INBUF during parsing
00:BF3E C8              	   885:          INY
00:BF3F 5A              	   886:          phy
00:BF40 2060C7          	   887:          JSR  GENNOP
00:BF43 7A              	   888:          ply
00:BF44 C692            	   889:          DEC  token_length
00:BF46 D0F3            	   890:          BNE  WRITE_LCD2
00:BF48 4C3ACF          	   891:          JMP  pas_get_token
                        	   892: ;
                        	   893: WRITE_LCD1    =  *            ; here if not string
00:BF4B C9AB            	   894:          CMP  #TOKEN_CHR      ; CHR?
00:BF4D F015            	   895:          BEQ  WRITE_LDC_CHR   ; yes
00:BF4F C9AC            	   896:          CMP  #TOKEN_HEX      ; HEX?
00:BF51 F019            	   897:          BEQ  WRITE_LDC_HEX   ; yes
00:BF53 20C1BD          	   898:          JSR  EXPRES          ; just ordinary number - get it
00:BF56 A942            	   899:          LDA  #PCODE_LCD_WRITE_NUM        ; OUT       Output number
00:BF58 2060C7          	   900:          JSR  GENNOP
00:BF5B A593            	   901: WRITE_LCD5    LDA  token_type
00:BF5D C92C            	   902:          CMP  #','
00:BF5F F0C1            	   903:          BEQ  WRITE_LCD9
00:BF61 4C9DBA          	   904:          JMP  CHKRHP
                        	   905: ;
                        	   906: ; here for lcdwrite (chr(x))
                        	   907: ;
                        	   908: WRITE_LDC_CHR    =  *
00:BF64 A945            	   909:          LDA  #PCODE_LCD_WRITE_CHR   ; OUTC     Output character
                        	   910: WRITE_LDC_CHR1   =  *
00:BF66 200FC0          	   911:          JSR  WAIT_1          ; process expression in parentheses
00:BF69 4C5BBF          	   912:          JMP  WRITE_LCD5      ; back for next item
                        	   913: ;
                        	   914: ; here for lcdwrite (hex(x))
                        	   915: ;
                        	   916: WRITE_LDC_HEX    =  *
00:BF6C A944            	   917:          LDA  #PCODE_LCD_WRITE_HEX        ; OUH       Output hex number
00:BF6E D0F6            	   918:          BNE  WRITE_LDC_CHR1
                        	   919: 
                        	   920: ;
                        	   921: ;
                        	   922: ; READ
                        	   923: ;
00:BF70 2096BA          	   924: READ     jsr  CHKLHP    ; check for "("
00:BF73 20A3CF          	   925: READ8    jsr  GET_LOOK
00:BF76 2000BB          	   926: READ2    jsr  SYMWRK      ; SYMITM --> WORK
00:BF79 20C892          	   927:          jsr  PSHWRK
00:BF7C A200            	   928:          ldx  #0
00:BF7E 864B            	   929:          stx  COUNT1      ; this will have 1 in it if we are reading into an array element
00:BF80 C941            	   930:          cmp  #SYMBOL_ARRAY
00:BF82 F03B            	   931:          beq  READ3
00:BF84 C956            	   932:          cmp  #SYMBOL_VARIABLE
00:BF86 F005            	   933:          beq  READ9
00:BF88 A20C            	   934:          ldx  #12     ; ERROR: Illegal Identifier
00:BF8A 4CCD97          	   935:          jmp  ERROR
                        	   936: 
00:BF8D 208CC9          	   937: READ9    jsr get_token
00:BF90 A91C            	   938: READ11   lda  #PCODE_INP  ; Input number
00:BF92 18              	   939:          clc
00:BF93 654A            	   940:          adc  DATTYP      ; becomes PCODE_INPC (input character) if DATTYP == 1
00:BF95 2060C7          	   941:          jsr  GENNOP
00:BF98 20DB92          	   942:          jsr  PULWRK
00:BF9B 200BBB          	   943:          jsr  WRKSYM      ; WORK --> SYMITM
00:BF9E 20CEBA          	   944:          jsr  GET_DAT
00:BFA1 20C4BA          	   945:          jsr  GET_LEV
00:BFA4 2029BB          	   946:          jsr  GET_OFF
00:BFA7 A932            	   947:          lda  #PCODE_STO    ; Store integer
00:BFA9 A64B            	   948:          ldx  COUNT1
00:BFAB F002            	   949:          beq  READ7
00:BFAD A936            	   950:          lda  #PCODE_STI    ; Store integer indexed
00:BFAF 18              	   951: READ7    clc
00:BFB0 654A            	   952:          adc  DATTYP        ; add 1 if a char to become PCODE_STOC / PCODE_STIC
00:BFB2 2079C7          	   953:          jsr  GENADR
00:BFB5 A593            	   954: READ7_A  lda  token_type
00:BFB7 C92C            	   955:          cmp  #','
00:BFB9 F0B8            	   956:          beq  READ8         ; get another variable to read into
                        	   957: ;
                        	   958: ;  done with READ statement
                        	   959: ;
00:BFBB 209DBA          	   960:          jsr  CHKRHP        ; check for ")"
00:BFBE 60              	   961:          rts
                        	   962: ;
                        	   963: ;  here for reading into an array
                        	   964: ;
00:BFBF A54A            	   965: READ3    lda  DATTYP
00:BFC1 48              	   966:          pha              ; push data type of array
00:BFC2 203ACF          	   967:          jsr  pas_get_token
00:BFC5 C95B            	   968:          cmp  #'['
00:BFC7 F025            	   969:          beq  READ3_A
00:BFC9 68              	   970:          pla            ; get back data type of array
00:BFCA 854A            	   971:          sta  DATTYP    ; 0 = integer, 1 = char
00:BFCC D005            	   972:          bne  READ3_B
00:BFCE A218            	   973:          ldx  #24       ; ERROR: Type mismatch (cannot read into array of integer)
00:BFD0 4CCD97          	   974:          jmp  ERROR
00:BFD3 20DB92          	   975: READ3_B  jsr  PULWRK
00:BFD6 200BBB          	   976:          jsr  WRKSYM     ; WORK --> SYMITM
00:BFD9 A925            	   977:          lda  #PCODE_INS        ; READ STRING - Input string into array
00:BFDB 2060C7          	   978:          jsr  GENNOP
00:BFDE 20C4BA          	   979:          jsr  GET_LEV
00:BFE1 2029BB          	   980:          jsr  GET_OFF
00:BFE4 A006            	   981:          ldy  #SYMSUB
00:BFE6 B140            	   982:          lda  (SYMITM),Y  ; maximum array size
00:BFE8 2079C7          	   983:          jsr  GENADR     ; A = length, not the P-code which we just output above
00:BFEB 4CB5BF          	   984:          jmp  READ7_A
                        	   985: ;
                        	   986: ;  read into subscripted item
                        	   987: ;
00:BFEE 2054BB          	   988: READ3_A  jsr  GETEXPR   ; subscript
00:BFF1 20BABA          	   989:          jsr  CHKRHB    ; check for "]"
00:BFF4 E64B            	   990:          inc  COUNT1    ; flag for reading into array element
00:BFF6 68              	   991:          pla            ; get back data type of array
00:BFF7 854A            	   992:          sta  DATTYP    ; save
00:BFF9 4C90BF          	   993:          jmp  READ11
                        	   994: ;
                        	   995: 
                        	   996: ;
                        	   997: ;
00:BFFC 2096BA          	   998: TWO_OP   JSR  CHKLHP
00:BFFF 2054BB          	   999:          JSR  GETEXPR
00:C002 208DBB          	  1000: ONE_OP2  JSR  GET_ITEM
00:C005 209DBA          	  1001: ONE_OP   JSR  CHKRHP
00:C008 68              	  1002:          PLA
00:C009 4C60C7          	  1003:          JMP  GENNOP
                        	  1004: 
                        	  1005: 
                        	  1006: 
00:C00C 4C60C7          	  1007: GENNOP2  JMP  GENNOP
                        	  1008: ;
                        	  1009: 
00:C00F 48              	  1010: WAIT_1   PHA
00:C010 2096BA          	  1011:          JSR  CHKLHP
00:C013 2054BB          	  1012:          JSR  GETEXPR
00:C016 4C05C0          	  1013:          JMP  ONE_OP
                        	  1014: ;
                        	  1015: ; MEM
                        	  1016: ;
00:C019 A900            	  1017: MEM      LDA  #0        ; integer
00:C01B 48              	  1018:          PHA
00:C01C F003            	  1019:          BEQ  MEM2
00:C01E A901            	  1020: MEMC     LDA  #1        ; character
00:C020 48              	  1021:          PHA
00:C021 20A7BA          	  1022: MEM2     JSR  GETSUB
00:C024 A941            	  1023:          LDA  #TOKEN_ASSIGN
00:C026 A20D            	  1024:          LDX  #13     ; ERROR: := expected
00:C028 209ECF          	  1025:          JSR  CHKTKN
00:C02B 2054BB          	  1026:          JSR  GETEXPR
00:C02E 68              	  1027:          PLA
00:C02F 18              	  1028:          CLC
00:C030 6934            	  1029:          ADC  #PCODE_STA     ; Store integer absolute address (or PCODE_STAC if A == 1)
00:C032 D0D8            	  1030:          BNE  GENNOP2
                        	  1031: ;
                        	  1032: ; CALL ABSOLUTE ADDRESS
                        	  1033: ;
00:C034 2096BA          	  1034: CALLSB   JSR  CHKLHP
00:C037 2054BB          	  1035:          JSR  GETEXPR
00:C03A 209DBA          	  1036:          JSR  CHKRHP
00:C03D A92B            	  1037:          LDA  #PCODE_CLA    ; Call absolute address
00:C03F D0CB            	  1038:          BNE  GENNOP2
                        	  1039: ;
                        	  1040: ; FUNCTION OR PROCEDURE CALL
                        	  1041: ;
00:C041 A900            	  1042: FNCPRC   LDA  #0
00:C043 854B            	  1043:          STA  COUNT1      ; number of arguments
00:C045 A006            	  1044:          LDY  #SYMARG
00:C047 B140            	  1045:          LDA  (SYMITM),Y
00:C049 F033            	  1046:          BEQ  FNC1
00:C04B 2096BA          	  1047:          JSR  CHKLHP
00:C04E A54B            	  1048: FNC2     LDA  COUNT1    ; save on stack in case the expression calls functions
00:C050 48              	  1049:          PHA
00:C051 2000BB          	  1050:          JSR  SYMWRK
00:C054 20C892          	  1051:          JSR  PSHWRK
00:C057 2054BB          	  1052:          JSR  GETEXPR
00:C05A 20DB92          	  1053:          JSR  PULWRK
00:C05D 200BBB          	  1054:          JSR  WRKSYM
00:C060 68              	  1055:          PLA            ; get number of arguments back
00:C061 854B            	  1056:          STA  COUNT1
00:C063 E64B            	  1057:          INC  COUNT1    ; add 1 for the one we just processed
00:C065 A593            	  1058:          LDA  token_type
00:C067 C92C            	  1059:          CMP  #','
00:C069 F0E3            	  1060:          BEQ  FNC2
00:C06B A54B            	  1061:          LDA  COUNT1
00:C06D A006            	  1062:          LDY  #SYMARG
00:C06F D140            	  1063:          CMP  (SYMITM),Y   ; check we got the right number of arguments
00:C071 F005            	  1064:          BEQ  FNC3
00:C073 A223            	  1065:          LDX  #35     ; ERROR: Parameters mismatched
00:C075 4CCD97          	  1066:          jmp  ERROR
00:C078 209DBA          	  1067: FNC3     JSR  CHKRHP
00:C07B 4C81C0          	  1068:          JMP  FNC5
00:C07E 203ACF          	  1069: FNC1     JSR  pas_get_token
00:C081 20C4BA          	  1070: FNC5     JSR  GET_LEV
00:C084 2029BB          	  1071:          JSR  GET_OFF
00:C087 A008            	  1072:          LDY  #SYMDAT
00:C089 B140            	  1073:          LDA  (SYMITM),Y
00:C08B D011            	  1074:          BNE  FNC5A
00:C08D A529            	  1075:          LDA  OFFSET
00:C08F 38              	  1076:          SEC
00:C090 E523            	  1077:          SBC  PCODE         ; calculate relative procedure address
00:C092 8529            	  1078:          STA  OFFSET
00:C094 A52A            	  1079:          LDA  OFFSET+1
00:C096 E524            	  1080:          SBC  PCODE+1
00:C098 852A            	  1081:          STA  OFFSET+1
00:C09A A927            	  1082:          LDA  #PCODE_CLL         ; Relative procedure/function call
00:C09C D002            	  1083:          BNE  FNC5B
00:C09E A938            	  1084: FNC5A    LDA  #PCODE_ABSCLL      ; Absolute procedure/function call
00:C0A0 2079C7          	  1085: FNC5B    JSR  GENADR
00:C0A3 A54B            	  1086:          LDA  COUNT1    ; number of arguments
00:C0A5 F01B            	  1087:          BEQ  FNC4
00:C0A7 A54B            	  1088:          LDA  COUNT1     ; TIMES 3
00:C0A9 0A              	  1089:          ASL             ; multiply by two then add one more COUNT1
00:C0AA B017            	  1090:          BCS  FNC6
00:C0AC 654B            	  1091:          ADC  COUNT1
00:C0AE 854B            	  1092:          STA  COUNT1
00:C0B0 B011            	  1093:          BCS  FNC6
00:C0B2 A900            	  1094:          LDA  #0
00:C0B4 38              	  1095:          SEC
00:C0B5 E54B            	  1096:          SBC  COUNT1
00:C0B7 852B            	  1097:          STA  OPND
00:C0B9 A9FF            	  1098:          LDA  #$FF
00:C0BB 852C            	  1099:          STA  OPND+1      ;  calculate: 0 - (number_of_arguments * 3)
00:C0BD A93B            	  1100:          LDA  #PCODE_INT     ; Increment stack pointer (allow for arguments)
00:C0BF 20E9C7          	  1101:          JSR  GENJMP
00:C0C2 60              	  1102: FNC4     RTS
00:C0C3 A20F            	  1103: FNC6     LDX  #15       ; ERROR: compiler limits exceeded
00:C0C5 4CCD97          	  1104:          jmp  ERROR
                        	  1105: ;
                        	  1106: ;
                        	  1107: ; IF
                        	  1108: ;
00:C0C8 2054BB          	  1109: IF       JSR  GETEXPR
00:C0CB A993            	  1110:          LDA  #TOKEN_THEN
00:C0CD A210            	  1111:          LDX  #16     ; ERROR: THEN expected
00:C0CF 209ECF          	  1112:          JSR  CHKTKN
00:C0D2 203ACF          	  1113:          JSR  pas_get_token
00:C0D5 2016BB          	  1114:          JSR  PSHPCODE
00:C0D8 A93D            	  1115:          LDA  #PCODE_JMZ     ; JMZ      Jump if (sp) zero
00:C0DA 20E3C7          	  1116:          JSR  GENNJM
00:C0DD 2020BE          	  1117:          JSR  STMNT
00:C0E0 A593            	  1118:          LDA  token_type
00:C0E2 C994            	  1119:          CMP  #TOKEN_ELSE       ; ELSE
00:C0E4 F007            	  1120:          BEQ  IF1
00:C0E6 20DB92          	  1121: IF2      JSR  PULWRK
00:C0E9 2017C8          	  1122:          JSR  FIXAD
00:C0EC 60              	  1123:          RTS
00:C0ED 20DB92          	  1124: IF1      JSR  PULWRK     ; HERE FOR ELSE
00:C0F0 207BBB          	  1125:          JSR  WRK_WRKD
00:C0F3 2016BB          	  1126:          JSR  PSHPCODE
00:C0F6 20E1C7          	  1127:          JSR  GENNJP
00:C0F9 2070BB          	  1128:          JSR  WRKD_WRK
00:C0FC 2017C8          	  1129:          JSR  FIXAD
00:C0FF 203ACF          	  1130:          JSR  pas_get_token
00:C102 2020BE          	  1131:          JSR  STMNT
00:C105 4CE6C0          	  1132:          JMP  IF2
                        	  1133: ;
                        	  1134: ; BEGIN
                        	  1135: ;
00:C108 203ACF          	  1136: BEG      JSR  pas_get_token
00:C10B 2020BE          	  1137:          JSR  STMNT
00:C10E A593            	  1138:          LDA  token_type
00:C110 C93B            	  1139:          CMP  #';'
00:C112 F0F4            	  1140:          BEQ  BEG
00:C114 A989            	  1141:          LDA  #TOKEN_END       ; END
00:C116 A211            	  1142:          LDX  #17         ; ERROR: ; or END expected
00:C118 209ECF          	  1143:          JSR  CHKTKN
00:C11B 4C3ACF          	  1144:          JMP  pas_get_token
                        	  1145: ;
                        	  1146: ; REPEAT
                        	  1147: ;
00:C11E 2016BB          	  1148: REPEAT   JSR  PSHPCODE
00:C121 203ACF          	  1149: REP1     JSR  pas_get_token
00:C124 2020BE          	  1150:          JSR  STMNT
00:C127 A593            	  1151:          LDA  token_type
00:C129 C93B            	  1152:          CMP  #';'
00:C12B F0F4            	  1153:          BEQ  REP1
00:C12D A999            	  1154:          LDA  #TOKEN_UNTIL
00:C12F A20A            	  1155:          LDX  #10           ; ERROR: ; expected
00:C131 209ECF          	  1156:          JSR  CHKTKN
00:C134 2054BB          	  1157:          JSR  GETEXPR
00:C137 20DB92          	  1158:          JSR  PULWRK
00:C13A 2065BB          	  1159:          JSR  WRK_OPND
00:C13D A93D            	  1160:          LDA  #PCODE_JMZ         ; JMZ      Jump if (sp) zero
00:C13F 4CCFC7          	  1161:          JMP  GENRJMP
                        	  1162: ;
                        	  1163: ; WHILE
                        	  1164: ;
00:C142 2016BB          	  1165: WHILE    JSR  PSHPCODE
00:C145 2054BB          	  1166:          JSR  GETEXPR
00:C148 2016BB          	  1167:          JSR  PSHPCODE
00:C14B A93D            	  1168:          LDA  #PCODE_JMZ       ; JMZ      Jump if (sp) zero
00:C14D 20E3C7          	  1169:          JSR  GENNJM
00:C150 A997            	  1170:          LDA  #TOKEN_DO
00:C152 A212            	  1171:          LDX  #18             ; ERROR: DO expected
00:C154 209ECF          	  1172:          JSR  CHKTKN
00:C157 203ACF          	  1173:          JSR  pas_get_token
00:C15A 2020BE          	  1174:          JSR  STMNT
00:C15D 20DB92          	  1175:          JSR  PULWRK
00:C160 207BBB          	  1176:          JSR  WRK_WRKD
00:C163 20DB92          	  1177:          JSR  PULWRK
00:C166 2065BB          	  1178:          JSR  WRK_OPND
00:C169 A93C            	  1179:          LDA  #PCODE_JMP     ; JMP      Jump unconditionally
00:C16B 20CFC7          	  1180:          JSR  GENRJMP
00:C16E 2070BB          	  1181:          JSR  WRKD_WRK
00:C171 4C17C8          	  1182:          JMP  FIXAD
                        	  1183: ;
                        	  1184: ; CASE
                        	  1185: ;
00:C174 2054BB          	  1186: CASE     JSR  GETEXPR
00:C177 A985            	  1187:          LDA  #TOKEN_OF       ; OF
00:C179 A21A            	  1188:          LDX  #26         ; ERROR: "of " expected
00:C17B 209ECF          	  1189:          JSR  CHKTKN
00:C17E A901            	  1190:          LDA  #1
00:C180 854B            	  1191:          STA  COUNT1
00:C182 A900            	  1192: CASE7    LDA  #0
00:C184 854C            	  1193:          STA  COUNT2
                        	  1194: CASE2    =  *
00:C186 A92A            	  1195:          LDA  #PCODE_MOV  ; make copy of selector:  MOV       Copy (sp) to (sp + 1)
00:C188 2060C7          	  1196:          JSR  GENNOP
00:C18B 2054BB          	  1197:          JSR  GETEXPR    ; next expression to compare
00:C18E A910            	  1198:          LDA  #PCODE_EQL       ;  EQL       Test (sp - 1) == (sp)
00:C190 2060C7          	  1199:          JSR  GENNOP
00:C193 A593            	  1200:          LDA  token_type
00:C195 C93A            	  1201:          CMP  #':'
00:C197 F014            	  1202:          BEQ  CASE1
00:C199 A92C            	  1203:          LDA  #','
00:C19B A205            	  1204:          LDX  #5      ; ERROR: , or : expected
00:C19D 209ECF          	  1205:          JSR  CHKTKN
00:C1A0 2016BB          	  1206:          JSR  PSHPCODE
00:C1A3 A93E            	  1207:          LDA  #PCODE_JM1     ; JM1      Jump if (sp) not zero
00:C1A5 20E3C7          	  1208:          JSR  GENNJM
00:C1A8 E64C            	  1209:          INC  COUNT2
00:C1AA 4C86C1          	  1210:          JMP  CASE2
00:C1AD 205ABB          	  1211: CASE1    JSR  PCD_WRKD
00:C1B0 A93D            	  1212:          LDA  #PCODE_JMZ     ; JMZ      Jump if (sp) zero
00:C1B2 20E3C7          	  1213:          JSR  GENNJM
00:C1B5 A54C            	  1214:          LDA  COUNT2
00:C1B7 F00A            	  1215:          BEQ  CASE3
00:C1B9 20DB92          	  1216: CASE4    JSR  PULWRK
00:C1BC 2017C8          	  1217:          JSR  FIXAD
00:C1BF C64C            	  1218:          DEC  COUNT2
00:C1C1 D0F6            	  1219:          BNE  CASE4
00:C1C3 2070BB          	  1220: CASE3    JSR  WRKD_WRK
00:C1C6 20C892          	  1221:          JSR  PSHWRK
00:C1C9 203ACF          	  1222:          JSR  pas_get_token
00:C1CC A54B            	  1223:          LDA  COUNT1
00:C1CE 48              	  1224:          PHA
00:C1CF 2020BE          	  1225:          JSR  STMNT
00:C1D2 68              	  1226:          PLA
00:C1D3 854B            	  1227:          STA  COUNT1
00:C1D5 A593            	  1228:          LDA  token_type
00:C1D7 C994            	  1229:          CMP  #TOKEN_ELSE       ; ELSE
00:C1D9 F01B            	  1230:          BEQ  CASE5
00:C1DB C93B            	  1231:          CMP  #';'
00:C1DD D035            	  1232:          BNE  CASE6
00:C1DF 205ABB          	  1233:          JSR  PCD_WRKD
00:C1E2 20E1C7          	  1234:          JSR  GENNJP
00:C1E5 20DB92          	  1235:          JSR  PULWRK
00:C1E8 2017C8          	  1236:          JSR  FIXAD
00:C1EB 2070BB          	  1237:          JSR  WRKD_WRK
00:C1EE 20C892          	  1238:          JSR  PSHWRK
00:C1F1 E64B            	  1239:          INC  COUNT1
00:C1F3 4C82C1          	  1240:          JMP  CASE7
00:C1F6 205ABB          	  1241: CASE5    JSR  PCD_WRKD
00:C1F9 20E1C7          	  1242:          JSR  GENNJP
00:C1FC 20DB92          	  1243:          JSR  PULWRK
00:C1FF 2017C8          	  1244:          JSR  FIXAD
00:C202 2070BB          	  1245:          JSR  WRKD_WRK
00:C205 20C892          	  1246:          JSR  PSHWRK
00:C208 203ACF          	  1247:          JSR  pas_get_token
00:C20B A54B            	  1248:          LDA  COUNT1
00:C20D 48              	  1249:          PHA
00:C20E 2020BE          	  1250:          JSR  STMNT
00:C211 68              	  1251:          PLA
00:C212 854B            	  1252:          STA  COUNT1
00:C214 A989            	  1253: CASE6    LDA  #TOKEN_END       ; END
00:C216 A211            	  1254:          LDX  #17         ; ERROR: ; or END expected
00:C218 209ECF          	  1255:          JSR  CHKTKN
00:C21B A54B            	  1256:          LDA  COUNT1
00:C21D F00A            	  1257:          BEQ  CASE8
00:C21F 20DB92          	  1258: CASE9    JSR  PULWRK
00:C222 2017C8          	  1259:          JSR  FIXAD
00:C225 C64B            	  1260:          DEC  COUNT1
00:C227 D0F6            	  1261:          BNE  CASE9
00:C229 20F5C2          	  1262: CASE8    JSR  FOR6
00:C22C 4C3ACF          	  1263:          JMP  pas_get_token
                        	  1264: ;
                        	  1265: ; FOR
                        	  1266: ;
00:C22F A949            	  1267: FOR      LDA  #TOKEN_IDENTIFIER
00:C231 A204            	  1268:          LDX  #4      ; ERROR:  Identifier expected
00:C233 208ECF          	  1269:          JSR  GETCHK
00:C236 202ABA          	  1270:          JSR  LOOKUP
00:C239 C956            	  1271: FOR1     CMP  #SYMBOL_VARIABLE
00:C23B F009            	  1272:          BEQ  FOR2
00:C23D C959            	  1273:          CMP  #SYMBOL_FUNCTION_RETURN
00:C23F F005            	  1274:          BEQ  FOR2
00:C241 A20C            	  1275:          LDX  #12   ; ERROR: Illegal Identifier
00:C243 4CCD97          	  1276:          jmp  ERROR
00:C246 2094BE          	  1277: FOR2     JSR  ASSVAR
00:C249 2000BB          	  1278:          JSR  SYMWRK
00:C24C A900            	  1279:          LDA  #0
00:C24E 854B            	  1280:          STA  COUNT1
00:C250 A593            	  1281:          LDA  token_type
00:C252 C99B            	  1282:          CMP  #TOKEN_TO       ; TO
00:C254 F009            	  1283:          BEQ  FOR3
00:C256 A99C            	  1284:          LDA  #TOKEN_DOWNTO       ; DOWNTO
00:C258 A21C            	  1285:          LDX  #28       ; ERROR: TO or DOWNTO expected
00:C25A 209ECF          	  1286:          JSR  CHKTKN
00:C25D C64B            	  1287:          DEC  COUNT1
00:C25F A54B            	  1288: FOR3     LDA  COUNT1
00:C261 48              	  1289:          PHA
00:C262 20C892          	  1290:          JSR  PSHWRK
00:C265 2054BB          	  1291:          JSR  GETEXPR
00:C268 20DB92          	  1292:          JSR  PULWRK
00:C26B 200BBB          	  1293:          JSR  WRKSYM
00:C26E 68              	  1294:          PLA
00:C26F 854B            	  1295:          STA  COUNT1
00:C271 2016BB          	  1296:          JSR  PSHPCODE
00:C274 A92A            	  1297:          LDA  #PCODE_MOV     ; MOV      Copy (sp) to (sp + 1)
00:C276 2060C7          	  1298:          JSR  GENNOP
00:C279 20C4BA          	  1299:          JSR  GET_LEV
00:C27C 2029BB          	  1300:          JSR  GET_OFF
00:C27F 20CEBA          	  1301:          JSR  GET_DAT
00:C282 18              	  1302:          CLC
00:C283 692C            	  1303:          ADC  #PCODE_LOD  ; Load integer onto stack or PCODE_LODC if a char
00:C285 2079C7          	  1304:          JSR  GENADR
00:C288 A916            	  1305:          LDA  #PCODE_GEQ        ; UP (GEQ): GEQ       Test (sp - 1) >= (sp)
00:C28A A64B            	  1306:          LDX  COUNT1
00:C28C F002            	  1307:          BEQ  FOR4
00:C28E A919            	  1308:          LDA  #PCODE_LEQ        ; DOWN (LEQ): LEQ       Test (sp - 1) <= (sp)
00:C290 2060C7          	  1309: FOR4     JSR  GENNOP
00:C293 2016BB          	  1310:          JSR  PSHPCODE
00:C296 A93D            	  1311:          LDA  #PCODE_JMZ       ;  JMZ       Jump if (sp) zero
00:C298 20E3C7          	  1312:          JSR  GENNJM
00:C29B A54B            	  1313:          LDA  COUNT1
00:C29D 48              	  1314:          PHA
00:C29E 2000BB          	  1315:          JSR  SYMWRK
00:C2A1 20C892          	  1316:          JSR  PSHWRK
00:C2A4 A997            	  1317:          LDA  #TOKEN_DO
00:C2A6 A212            	  1318:          LDX  #18       ; ERROR: DO expected
00:C2A8 209ECF          	  1319:          JSR  CHKTKN
00:C2AB 203ACF          	  1320:          JSR  pas_get_token
00:C2AE 2020BE          	  1321:          JSR  STMNT
00:C2B1 20DB92          	  1322:          JSR  PULWRK
00:C2B4 200BBB          	  1323:          JSR  WRKSYM
00:C2B7 20C4BA          	  1324:          JSR  GET_LEV
00:C2BA 20CEBA          	  1325:          JSR  GET_DAT
00:C2BD 2029BB          	  1326:          JSR  GET_OFF
00:C2C0 A54A            	  1327:          LDA  DATTYP
00:C2C2 18              	  1328:          CLC
00:C2C3 692C            	  1329:          ADC  #PCODE_LOD       ; LOD      Load integer onto stack
00:C2C5 2079C7          	  1330:          JSR  GENADR
00:C2C8 68              	  1331:          PLA
00:C2C9 854B            	  1332:          STA  COUNT1
00:C2CB A926            	  1333:          LDA  #PCODE_INC     ; INC      Increment (sp) by 1
00:C2CD A64B            	  1334:          LDX  COUNT1
00:C2CF F002            	  1335:          BEQ  FOR5
00:C2D1 A928            	  1336:          LDA  #PCODE_DEC        ; DEC       Decrement (sp) by 1
00:C2D3 2060C7          	  1337: FOR5     JSR  GENNOP
00:C2D6 A932            	  1338:          LDA  #PCODE_STO       ; STO      Store integer
00:C2D8 18              	  1339:          CLC
00:C2D9 654A            	  1340:          ADC  DATTYP          ; may become PCODE_STOC if a char
00:C2DB 2079C7          	  1341:          JSR  GENADR
00:C2DE 20DB92          	  1342:          JSR  PULWRK
00:C2E1 207BBB          	  1343:          JSR  WRK_WRKD
00:C2E4 20DB92          	  1344:          JSR  PULWRK
00:C2E7 2065BB          	  1345:          JSR  WRK_OPND
00:C2EA A93C            	  1346:          LDA  #PCODE_JMP       ; JMP      Jump unconditionally
00:C2EC 20CFC7          	  1347:          JSR  GENRJMP
00:C2EF 2070BB          	  1348:          JSR  WRKD_WRK
00:C2F2 2017C8          	  1349:          JSR  FIXAD
00:C2F5 A9FF            	  1350: FOR6     LDA  #$FF
00:C2F7 852C            	  1351:          STA  OPND+1
00:C2F9 A9FD            	  1352:          LDA  #$FD
00:C2FB 852B            	  1353:          STA  OPND
00:C2FD A93B            	  1354:          LDA  #PCODE_INT       ;  INT       Increment stack pointer
00:C2FF 4CE9C7          	  1355:          JMP  GENJMP
                        	  1356: 
                        	  1357: 
                        	  1358: ;***********************************************
                        	  1359: ; MORE OF THE COMPILER (PROCESSING A 'BLOCK')
                        	  1360: ;***********************************************
                        	  1361: 
                        	  1362: CHKGET   =  *
00:C302 209ECF          	  1363:          JSR  CHKTKN
00:C305 4C3ACF          	  1364:          JMP  pas_get_token
                        	  1365: ;
                        	  1366: ;  copy WORK to token_value
                        	  1367: ;
                        	  1368: WRK_VAL  =  *
00:C308 48              	  1369:          PHA
00:C309 A537            	  1370:          LDA  WORK
00:C30B 8594            	  1371:          STA  token_value
00:C30D A538            	  1372:          LDA  WORK+1
00:C30F 8595            	  1373:          STA  token_value+1
00:C311 68              	  1374:          PLA
00:C312 60              	  1375:          RTS
                        	  1376: ;
                        	  1377: ;  copy VALUE to WORK
                        	  1378: ;
                        	  1379: VAL_WRK  =  *
00:C313 48              	  1380:          PHA
00:C314 A594            	  1381:          LDA  token_value
00:C316 8537            	  1382:          STA  WORK
00:C318 A595            	  1383:          LDA  token_value+1
00:C31A 8538            	  1384:          STA  WORK+1
00:C31C 68              	  1385:          PLA
00:C31D 60              	  1386:          RTS
                        	  1387: ;
                        	  1388: ;  copy ENDSYM to WORK
                        	  1389: ;
                        	  1390: END_WRK  =  *
00:C31E 48              	  1391:          PHA
00:C31F A531            	  1392:          LDA  ENDSYM
00:C321 8537            	  1393:          STA  WORK
00:C323 A532            	  1394:          LDA  ENDSYM+1
00:C325 8538            	  1395:          STA  WORK+1
00:C327 68              	  1396:          PLA
00:C328 60              	  1397:          RTS
                        	  1398: ;
                        	  1399: ;***********************************************
                        	  1400: ;
                        	  1401: ;
                        	  1402: ; BLOCK
                        	  1403: ;
00:C329 82              	  1404: BLCKT1   DFB  TOKEN_CONST
00:C32A 80C3            	  1405:          word BLKCNS
00:C32C 83              	  1406: BLCKT2   DFB  TOKEN_VAR
00:C32D 97C3            	  1407:          word BLKVAR
00:C32F 86              	  1408: BLCKT3   DFB  TOKEN_PROCEDURE
00:C330 D4C4            	  1409:          word BLKPRC
00:C332 87              	  1410:          DFB  TOKEN_FUNCTION
00:C333 F4C4            	  1411:          word BLKFNC
00:C335 88              	  1412:          DFB  TOKEN_BEGIN
00:C336 BCC5            	  1413:          word BLKBEG
00:C338 00              	  1414:          DFB  0
                        	  1415: ;
                        	  1416: ;
00:C339 20BCBB          	  1417: BLOCK    JSR  CHK_STAK
00:C33C A900            	  1418:          LDA  #0
00:C33E 8521            	  1419:          STA  FRAME+1
00:C340 A906            	  1420:          LDA  #6
00:C342 8520            	  1421:          STA  FRAME
00:C344 A539            	  1422:          LDA  PRCITM
00:C346 8537            	  1423:          STA  WORK
00:C348 A63A            	  1424:          LDX  PRCITM+1
00:C34A 8638            	  1425:          STX  WORK+1
00:C34C 053A            	  1426:          ORA  PRCITM+1
00:C34E F014            	  1427:          BEQ  BLK1
                        	  1428: 
                        	  1429: ;
00:C350 A004            	  1430: BLK1A    LDY  #SYMDSP
00:C352 A523            	  1431:          LDA  PCODE
00:C354 9137            	  1432:          STA  (WORK),Y
00:C356 C8              	  1433:          INY
00:C357 A524            	  1434:          LDA  PCODE+1
00:C359 9137            	  1435:          STA  (WORK),Y
00:C35B A900            	  1436:          LDA  #0
00:C35D A008            	  1437:          LDY  #SYMDAT
00:C35F 9137            	  1438:          STA  (WORK),Y   ; FLAG RELATIVE PROCEDURE
00:C361 4C6CC3          	  1439:          JMP  BLK2
00:C364 A523            	  1440: BLK1     LDA  PCODE
00:C366 8537            	  1441:          STA  WORK
00:C368 A524            	  1442:          LDA  PCODE+1
00:C36A 8538            	  1443:          STA  WORK+1
00:C36C 20C892          	  1444: BLK2     JSR  PSHWRK
00:C36F 20E1C7          	  1445:          JSR  GENNJP
00:C372 A229            	  1446:          LDX  #<BLCKT1
00:C374 A0C3            	  1447:          LDY  #>BLCKT1
00:C376 A593            	  1448: BLK4     LDA  token_type
00:C378 20FB8F          	  1449:          JSR  TKNJMP
00:C37B A219            	  1450:          LDX  #25       ; ERROR: BEGIN expected
00:C37D 4CCD97          	  1451:          jmp  ERROR
                        	  1452: ;
                        	  1453: ;
                        	  1454: ; CONSTANT
                        	  1455: ;
00:C380 203ACF          	  1456: BLKCNS   JSR  pas_get_token
00:C383 20D5BA          	  1457: BLKCN1   JSR  CONDEC
00:C386 A93B            	  1458:          LDA  #';'
00:C388 A20A            	  1459:          LDX  #10       ; ERROR: ; expected
00:C38A 2002C3          	  1460:          JSR  CHKGET
00:C38D A22C            	  1461:          LDX  #<BLCKT2
00:C38F A0C3            	  1462:          LDY  #>BLCKT2
00:C391 20FB8F          	  1463:          JSR  TKNJMP
00:C394 4C83C3          	  1464:          JMP  BLKCN1
                        	  1465: ;
                        	  1466: ; VARIABLE
                        	  1467: ;
00:C397 A900            	  1468: BLKVAR   LDA  #0
00:C399 854B            	  1469:          STA  COUNT1
00:C39B 203ACF          	  1470: BLKVR1   JSR  pas_get_token
00:C39E 20EEBB          	  1471: BLKVR6   JSR  VARDEC    ; check we have an identifier, add it to the symbol table, get another token
00:C3A1 E64B            	  1472:          INC  COUNT1    ; how many variables in this declaration
00:C3A3 1003            	  1473:          BPL  BLKVR7
00:C3A5 4C15C4          	  1474:          JMP  BLKV13     ; ERROR  - compiler limits exceeded (more than 127 variables?)
00:C3A8 A593            	  1475: BLKVR7   LDA  token_type
00:C3AA C92C            	  1476:          CMP  #','
00:C3AC F0ED            	  1477:          BEQ  BLKVR1    ; back for another
00:C3AE A93A            	  1478:          LDA  #':'
00:C3B0 A205            	  1479:          LDX  #5        ; ERROR: , or : expected
00:C3B2 2002C3          	  1480:          JSR  CHKGET
00:C3B5 C984            	  1481:          CMP  #TOKEN_ARRAY   ; ARRAY
00:C3B7 F043            	  1482:          BEQ  BLKVR2
00:C3B9 C9FE            	  1483:          CMP  #TOKEN_INTEGER ; INTEGER
00:C3BB F00A            	  1484:          BEQ  BLKVR8
00:C3BD A9A1            	  1485:          LDA  #TOKEN_CHAR    ; CHAR
00:C3BF A224            	  1486:          LDX  #36            ; ERROR: Data Type not recognised
00:C3C1 209ECF          	  1487:          JSR  CHKTKN
00:C3C4 4CBCC4          	  1488:          JMP  BLKVR3
                        	  1489: 
                        	  1490: ;
                        	  1491: ;  integer variable
                        	  1492: ;
00:C3C7 2061C4          	  1493: BLKVR8   JSR  BLKVR9  ; subtract COUNT1 from FRAME, put WORK into VALUE, put ENDSYM into WORK
                        	  1494: BLKV10   = *
00:C3CA A008            	  1495:          LDY  #SYMDAT
00:C3CC A900            	  1496:          LDA  #0         ; INTEGER TYPE
00:C3CE 9137            	  1497:          STA  (WORK),Y
00:C3D0 A520            	  1498:          LDA  FRAME
00:C3D2 A004            	  1499:          LDY  #SYMDSP
00:C3D4 9137            	  1500:          STA  (WORK),Y
00:C3D6 C8              	  1501:          INY
00:C3D7 A521            	  1502:          LDA  FRAME+1
00:C3D9 9137            	  1503:          STA  (WORK),Y
00:C3DB 18              	  1504:          CLC
00:C3DC A520            	  1505:          LDA  FRAME
00:C3DE 6903            	  1506:          ADC  #3
00:C3E0 8520            	  1507:          STA  FRAME
00:C3E2 9002            	  1508:          BCC  BLKV10_A
00:C3E4 E621            	  1509:          INC  FRAME+1
                        	  1510: BLKV10_A =  *
00:C3E6 C64B            	  1511:          DEC  COUNT1
00:C3E8 D003            	  1512:          BNE  BLKV10_B
00:C3EA 4CBCC4          	  1513:          JMP  BLKVR3
                        	  1514: 
                        	  1515: BLKV10_B = *
                        	  1516: ;
                        	  1517: ;  more in the list, go to the previous symbol
                        	  1518: ;
00:C3ED A000            	  1519:          LDY  #SYMPRV
00:C3EF B137            	  1520:          LDA  (WORK),Y
00:C3F1 AA              	  1521:          TAX
00:C3F2 C8              	  1522:          INY
00:C3F3 B137            	  1523:          LDA  (WORK),Y
00:C3F5 8538            	  1524:          STA  WORK+1
00:C3F7 8A              	  1525:          TXA
00:C3F8 8537            	  1526:          STA  WORK       ; PREVIOUS ITEM
00:C3FA 80CE            	  1527:          BRA  BLKV10
                        	  1528: 
                        	  1529: ;
                        	  1530: ; ARRAY [ N ] OF ...
                        	  1531: ;
00:C3FC 20B0BA          	  1532: BLKVR2   JSR  CHKLHB
00:C3FF 20C8BB          	  1533:          JSR  CONST     ; get how many are in the array
00:C402 A596            	  1534:          LDA  token_value+2   ; can't be more than 65536
00:C404 D00F            	  1535:          BNE  BLKV13
00:C406 A594            	  1536:          LDA  token_value     ; add 1 to the count since array [3] of char means 4 elements
00:C408 18              	  1537:          CLC
00:C409 6901            	  1538:          ADC  #1
00:C40B 8594            	  1539:          STA  token_value
00:C40D A595            	  1540:          LDA  token_value+1
00:C40F 3004            	  1541:          BMI  BLKV13
00:C411 6900            	  1542:          ADC  #0
00:C413 1005            	  1543:          BPL  BLKVR4
00:C415 A20F            	  1544: BLKV13   LDX  #15       ; ERROR: compiler limits exceeded
00:C417 4CCD97          	  1545:          jmp  ERROR
00:C41A 8595            	  1546: BLKVR4   STA  token_value+1
00:C41C 2013C3          	  1547:          JSR  VAL_WRK   ; put the value (array count) in WORK
00:C41F 203ACF          	  1548:          JSR  pas_get_token
00:C422 20BABA          	  1549:          JSR  CHKRHB
00:C425 A901            	  1550:          LDA  #1        ; char
00:C427 854A            	  1551:          STA  DATTYP
00:C429 A985            	  1552:          LDA  #TOKEN_OF  ; OF
00:C42B A21A            	  1553:          LDX  #26        ; ERROR: "of " expected
00:C42D 2002C3          	  1554:          JSR  CHKGET
00:C430 C9FE            	  1555:          CMP  #TOKEN_INTEGER  ; INTEGER
00:C432 D020            	  1556:          BNE  BLKV11
00:C434 C64A            	  1557:          DEC  DATTYP    ; DATTYP of 0 is integer, and 1 is char
00:C436 2008C3          	  1558:          JSR  WRK_VAL   ; get the array count back into token_value
                        	  1559: ;
                        	  1560: ; MULTIPLY token_value BY 3
                        	  1561: ;
00:C439 A594            	  1562:          LDA  token_value
00:C43B A695            	  1563:          LDX  token_value+1
00:C43D 0694            	  1564:          ASL  token_value
00:C43F 2695            	  1565:          ROL  token_value+1
00:C441 B0D2            	  1566:          BCS  BLKV13
00:C443 6594            	  1567:          ADC  token_value
00:C445 8594            	  1568:          STA  token_value
00:C447 8A              	  1569:          TXA
00:C448 6595            	  1570:          ADC  token_value+1
00:C44A B0C9            	  1571:          BCS  BLKV13
00:C44C 8595            	  1572:          STA  token_value+1
00:C44E 2013C3          	  1573:          JSR  VAL_WRK     ; put the array count (times 3) back into WORK
00:C451 4C5BC4          	  1574:          JMP  BLKV12
                        	  1575:  ;
                        	  1576:  ;  here for array of char
                        	  1577:  ;
00:C454 A9A1            	  1578: BLKV11   LDA  #TOKEN_CHAR       ; CHAR
00:C456 A224            	  1579:          LDX  #36           ; ERROR: Data Type not recognised
00:C458 209ECF          	  1580:          JSR  CHKTKN
00:C45B 2061C4          	  1581: BLKV12   JSR  BLKVR9        ; we are COUNT1 frames back
00:C45E 4C7AC4          	  1582:          JMP  BLKVR5
                        	  1583: 
                        	  1584: BLKVR9   =  *
00:C461 A520            	  1585:          LDA  FRAME         ; subtract COUNT1 (the variable position) from the frame number
00:C463 38              	  1586:          SEC
00:C464 E54B            	  1587:          SBC  COUNT1
00:C466 8520            	  1588:          STA  FRAME
00:C468 A521            	  1589:          LDA  FRAME+1
00:C46A E900            	  1590:          SBC  #0
00:C46C 8521            	  1591:          STA  FRAME+1
00:C46E 2008C3          	  1592:          JSR  WRK_VAL     ; copy WORK to VALUE (array count, possibly multiplied by 3)
00:C471 A531            	  1593:          LDA  ENDSYM      ; end of symbol table into WORK
00:C473 8537            	  1594:          STA  WORK
00:C475 A532            	  1595:          LDA  ENDSYM+1
00:C477 8538            	  1596:          STA  WORK+1
00:C479 60              	  1597:          RTS
                        	  1598: 
                        	  1599: ;
                        	  1600: ;  we should be here with ENDSYM in WORK (for walking back through the symbol table for all the variables we just decla
                        	  1601: ;  COUNT1 will be the number of symbols we have to fix up
                        	  1602: ;
                        	  1603: BLKVR5   = *
00:C47A A003            	  1604:          ldy  #SYMTYP
00:C47C A941            	  1605:          lda  #SYMBOL_ARRAY
00:C47E 9137            	  1606:          sta  (WORK),Y    ; make symbol type array
00:C480 A004            	  1607:          ldy  #SYMDSP
00:C482 A520            	  1608:          lda  FRAME       ; FRAME is the displacement
00:C484 9137            	  1609:          sta  (WORK),Y
00:C486 C8              	  1610:          iny
00:C487 A521            	  1611:          lda  FRAME+1
00:C489 9137            	  1612:          sta  (WORK),Y
00:C48B A594            	  1613:          lda  token_value       ; array count (multiplied by 3 in the case of integers)
00:C48D 18              	  1614:          clc
00:C48E 6520            	  1615:          adc  FRAME       ; add to the stack frame address
00:C490 8520            	  1616:          sta  FRAME
00:C492 A595            	  1617:          lda  token_value+1
00:C494 6521            	  1618:          adc  FRAME+1
00:C496 8521            	  1619:          sta  FRAME+1
00:C498 A008            	  1620:          ldy  #SYMDAT
00:C49A A54A            	  1621:          lda  DATTYP       ; save the data type in the symbol
00:C49C 9137            	  1622:          sta  (WORK),Y
00:C49E A006            	  1623:          ldy  #SYMSUB
00:C4A0 A594            	  1624:          lda  token_value        ; max subscript + 1
00:C4A2 9137            	  1625:          sta  (WORK),Y
00:C4A4 A595            	  1626:          lda  token_value+1
00:C4A6 C8              	  1627:          iny
00:C4A7 9137            	  1628:          sta  (WORK),Y
00:C4A9 C64B            	  1629:          dec  COUNT1
00:C4AB F00F            	  1630:          beq  BLKVR3
                        	  1631: ;
                        	  1632: ;  onto the previous symbol
                        	  1633: ;
00:C4AD A000            	  1634:          ldy  #SYMPRV
00:C4AF B137            	  1635:          lda  (WORK),Y
00:C4B1 AA              	  1636:          tax
00:C4B2 C8              	  1637:          iny
00:C4B3 B137            	  1638:          lda  (WORK),Y
00:C4B5 8538            	  1639:          sta  WORK+1
00:C4B7 8A              	  1640:          txa
00:C4B8 8537            	  1641:          sta  WORK       ; PREVIOUS ITEM
00:C4BA 80BE            	  1642:          bra  BLKVR5
                        	  1643: ;
                        	  1644: ;  here at end of variable declaration (after INTEGER / CHAR)
                        	  1645: ;
00:C4BC A93B            	  1646: BLKVR3   LDA  #';'
00:C4BE A20A            	  1647:          LDX  #10       ; ERROR: ; expected
00:C4C0 208ECF          	  1648:          JSR  GETCHK
00:C4C3 203ACF          	  1649:          JSR  pas_get_token
00:C4C6 A22F            	  1650:          LDX  #<BLCKT3  ; now look for procedure / function / begin
00:C4C8 A0C3            	  1651:          LDY  #>BLCKT3
00:C4CA 20FB8F          	  1652:          JSR  TKNJMP    ; if not there, look for another variable declaration
00:C4CD A900            	  1653:          LDA  #0        ; zero variables in this list so far
00:C4CF 854B            	  1654:          STA  COUNT1
00:C4D1 4C9EC3          	  1655:          JMP  BLKVR6
                        	  1656: ;
                        	  1657: ; PROCEDURE DECLARATION
                        	  1658: ;
00:C4D4 A949            	  1659: BLKPRC   LDA  #'I'
00:C4D6 A204            	  1660:          LDX  #4         ; ERROR: Identifier expected
00:C4D8 208ECF          	  1661:          JSR  GETCHK
00:C4DB A900            	  1662:          LDA  #0
00:C4DD 854B            	  1663:          STA  COUNT1    ; no function return value
00:C4DF 2035BA          	  1664:          JSR  CHKDUP
00:C4E2 A950            	  1665:          LDA  #SYMBOL_PROCEDURE
00:C4E4 208EB9          	  1666:          JSR  ADDSYM
00:C4E7 E622            	  1667:          INC  LEVEL
00:C4E9 A540            	  1668:          LDA  SYMITM
00:C4EB 8539            	  1669:          STA  PRCITM    ; PRCITM is the symbol of the procedure/function
00:C4ED A541            	  1670:          LDA  SYMITM+1
00:C4EF 853A            	  1671:          STA  PRCITM+1
00:C4F1 4C16C5          	  1672:          JMP  BLKPR1
                        	  1673: ;
                        	  1674: ; FUNCTION DECLARATION
                        	  1675: ;
00:C4F4 A949            	  1676: BLKFNC   LDA  #TOKEN_IDENTIFIER
00:C4F6 A204            	  1677:          LDX  #4      ; ERROR: Identifier expected
00:C4F8 208ECF          	  1678:          JSR  GETCHK
00:C4FB 2035BA          	  1679:          JSR  CHKDUP
00:C4FE A946            	  1680:          LDA  #SYMBOL_FUNCTION
00:C500 208EB9          	  1681:          JSR  ADDSYM
00:C503 E622            	  1682:          INC  LEVEL
00:C505 A901            	  1683:          LDA  #1
00:C507 854B            	  1684:          STA  COUNT1    ; we have the function return as a symbol
00:C509 A540            	  1685:          LDA  SYMITM
00:C50B 8539            	  1686:          STA  PRCITM   ; PRCITM is the symbol of the procedure/function
00:C50D A541            	  1687:          LDA  SYMITM+1
00:C50F 853A            	  1688:          STA  PRCITM+1
00:C511 A959            	  1689:          LDA  #SYMBOL_FUNCTION_RETURN ; for assigning the results to
00:C513 208EB9          	  1690:          JSR  ADDSYM
                        	  1691: ;
                        	  1692: ; PROCEDURE AND FUNCTION COMMON CODE
                        	  1693: ;
00:C516 A54B            	  1694: BLKPR1   LDA  COUNT1
00:C518 854C            	  1695:          STA  COUNT2    ; remember if we had 0 or 1 extra symbols (function return)
00:C51A 201EC3          	  1696:          JSR  END_WRK
00:C51D 20C892          	  1697:          JSR  PSHWRK
00:C520 A520            	  1698:          LDA  FRAME
00:C522 8537            	  1699:          STA  WORK
00:C524 A521            	  1700:          LDA  FRAME+1
00:C526 8538            	  1701:          STA  WORK+1
00:C528 20C892          	  1702:          JSR  PSHWRK
00:C52B 203ACF          	  1703:          JSR  pas_get_token
00:C52E C928            	  1704:          CMP  #'('      ; opening bracket after procedure/function name?
00:C530 D016            	  1705:          BNE  BLKPR2
00:C532 203ACF          	  1706: BLKPR3   JSR  pas_get_token
00:C535 20EEBB          	  1707:          JSR  VARDEC
00:C538 E64B            	  1708:          INC  COUNT1    ; count arguments
00:C53A 1003            	  1709:          BPL  BLKPR6
00:C53C 4C15C4          	  1710:          JMP  BLKV13
00:C53F A593            	  1711: BLKPR6   LDA  token_type
00:C541 C92C            	  1712:          CMP  #','
00:C543 F0ED            	  1713:          BEQ  BLKPR3
00:C545 209DBA          	  1714:          JSR  CHKRHP
00:C548 A539            	  1715: BLKPR2   LDA  PRCITM      ; here after argument list, if any
00:C54A 8537            	  1716:          STA  WORK
00:C54C A53A            	  1717:          LDA  PRCITM+1
00:C54E 8538            	  1718:          STA  WORK+1
00:C550 A006            	  1719:          LDY  #SYMARG
00:C552 A54B            	  1720:          LDA  COUNT1
00:C554 38              	  1721:          SEC
00:C555 E54C            	  1722:          SBC  COUNT2      ; subtract 0 or 1 depending on if this is a function or not
00:C557 9137            	  1723:          STA  (WORK),Y    ; store the number of arguments to this procedure/function
00:C559 A93B            	  1724:          LDA  #';'
00:C55B A20A            	  1725:          LDX  #10         ; ERROR: ; expected
00:C55D 209ECF          	  1726:          JSR  CHKTKN
00:C560 A54B            	  1727:          LDA  COUNT1
00:C562 F02C            	  1728:          BEQ  BLKPR4
00:C564 201EC3          	  1729:          JSR  END_WRK     ; ENDSYM -> WORK
00:C567 A2FD            	  1730:          LDX  #$FD        ; X = -3
                        	  1731: ; WORK starts off pointing to the procedure/function symbol
                        	  1732: BLKPR5   = *
00:C569 A008            	  1733:          LDY  #SYMDAT
00:C56B A900            	  1734:          LDA  #0
00:C56D 9137            	  1735:          STA  (WORK),Y    ; data type = integer
00:C56F A004            	  1736:          LDY  #SYMDSP
00:C571 8A              	  1737:          TXA
00:C572 9137            	  1738:          STA  (WORK),Y
00:C574 38              	  1739:          SEC
00:C575 E903            	  1740:          SBC  #3
00:C577 AA              	  1741:          TAX
00:C578 A9FF            	  1742:          LDA  #$FF
00:C57A C8              	  1743:          INY
00:C57B 9137            	  1744:          STA  (WORK),Y
00:C57D C64B            	  1745:          DEC  COUNT1
00:C57F F00F            	  1746:          beq  BLKPR4
                        	  1747: ;
                        	  1748: ;  back to previous symbol
                        	  1749: ;
00:C581 A000            	  1750:          LDY  #SYMPRV
00:C583 B137            	  1751:          LDA  (WORK),Y
00:C585 48              	  1752:          PHA
00:C586 C8              	  1753:          INY
00:C587 B137            	  1754:          LDA  (WORK),Y
00:C589 8538            	  1755:          STA  WORK+1
00:C58B 68              	  1756:          PLA
00:C58C 8537            	  1757:          STA  WORK
00:C58E 80D9            	  1758:          bra  BLKPR5
00:C590 203ACF          	  1759: BLKPR4   JSR  pas_get_token
00:C593 2039C3          	  1760:          JSR  BLOCK
00:C596 C622            	  1761:          DEC  LEVEL
00:C598 20DB92          	  1762:          JSR  PULWRK
00:C59B A537            	  1763:          LDA  WORK
00:C59D 8520            	  1764:          STA  FRAME
00:C59F A538            	  1765:          LDA  WORK+1
00:C5A1 8521            	  1766:          STA  FRAME+1
00:C5A3 20DB92          	  1767:          JSR  PULWRK
00:C5A6 A537            	  1768:          LDA  WORK
00:C5A8 8531            	  1769:          STA  ENDSYM
00:C5AA A538            	  1770:          LDA  WORK+1
00:C5AC 8532            	  1771:          STA  ENDSYM+1
00:C5AE A93B            	  1772:          LDA  #';'
00:C5B0 A20A            	  1773:          LDX  #10       ; ERROR: ; expected
00:C5B2 2002C3          	  1774:          JSR  CHKGET
00:C5B5 A22F            	  1775:          LDX  #<BLCKT3
00:C5B7 A0C3            	  1776:          LDY  #>BLCKT3
00:C5B9 4C76C3          	  1777:          JMP  BLK4
                        	  1778: ;
                        	  1779: ; BEGIN (COMPOUND STATEMENT)
                        	  1780: ;
00:C5BC 203ACF          	  1781: BLKBEG   JSR  pas_get_token
00:C5BF 20DB92          	  1782:          JSR  PULWRK
00:C5C2 A522            	  1783:          LDA  LEVEL
00:C5C4 D006            	  1784:          BNE  BLKB1
00:C5C6 2017C8          	  1785: BLKB3    JSR  FIXAD
00:C5C9 4CE8C5          	  1786:          JMP  BLKB2
00:C5CC 200BBB          	  1787: BLKB1    JSR  WRKSYM
00:C5CF A004            	  1788:          LDY  #SYMDSP
00:C5D1 B140            	  1789:          LDA  (SYMITM),Y
00:C5D3 8537            	  1790:          STA  WORK
00:C5D5 C8              	  1791:          INY
00:C5D6 B140            	  1792:          LDA  (SYMITM),Y
00:C5D8 8538            	  1793:          STA  WORK+1
00:C5DA A004            	  1794:          LDY  #SYMDSP
00:C5DC A523            	  1795:          LDA  PCODE
00:C5DE 9140            	  1796:          STA  (SYMITM),Y
00:C5E0 A524            	  1797:          LDA  PCODE+1
00:C5E2 C8              	  1798:          INY
00:C5E3 9140            	  1799:          STA  (SYMITM),Y
00:C5E5 4CC6C5          	  1800:          JMP  BLKB3
00:C5E8 A520            	  1801: BLKB2    LDA  FRAME
00:C5EA 852B            	  1802:          STA  OPND
00:C5EC A521            	  1803:          LDA  FRAME+1
00:C5EE 852C            	  1804:          STA  OPND+1
00:C5F0 A93B            	  1805:          LDA  #PCODE_INT         ; INT      Increment stack pointer
00:C5F2 20E9C7          	  1806:          JSR  GENJMP
00:C5F5 2020BE          	  1807: BLKB5    JSR  STMNT
00:C5F8 A593            	  1808:          LDA  token_type
00:C5FA C93B            	  1809:          CMP  #';'
00:C5FC D006            	  1810:          BNE  BLKB4
00:C5FE 203ACF          	  1811:          JSR  pas_get_token
00:C601 4CF5C5          	  1812:          JMP  BLKB5
00:C604 A989            	  1813: BLKB4    LDA  #TOKEN_END       ; END
00:C606 A211            	  1814:          LDX  #17         ; ERROR: ; or END expected
00:C608 2002C3          	  1815:          JSR  CHKGET
00:C60B A929            	  1816:          LDA  #PCODE_RTN  ; OK - we are at the end of a block - this is a procedure/function return
00:C60D A622            	  1817:          LDX  LEVEL       ; OR - if we are at level 0, then that is the end of the program
00:C60F D002            	  1818:          BNE  BLKB6
00:C611 A911            	  1819:          LDA  #PCODE_FINISHD        ; Opcode: FINISHED  Stop run (end program)
                        	  1820: TEST1    =  *
00:C613 4C60C7          	  1821: BLKB6    JMP  GENNOP
                        	  1822: ;
                        	  1823: 
                        	  1824: 
                        	  1825: ;
                        	  1826: ;  Writing library functions is quite easy:
                        	  1827: ;
                        	  1828: ;   1. For each of the n arguments that they have (could be zero) do a PULTOP to get
                        	  1829: ;      that value from the runtime stack into REG. Or, PULTOP2 to get the value into REG2.
                        	  1830: ;      For two arguments you can do PULBOTH to get them into REG and REG2.
                        	  1831: ;   2. Do whatever the function/procedure is supposed to do with those arguments
                        	  1832: ;   3. If a procedure, you are finished: JMP MAIN
                        	  1833: ;      For a function, put the result into REG, and then JMP MAINP
                        	  1834: ;      - or - (equivalently): JSR PSHTOP, JMP MAIN
                        	  1835: ;
                        	  1836: ;  Note: PULTOP puts the value into REG and also: A, X and Y registers where A is the low-order
                        	  1837: ;        byte, X the middle byte, and Y the high-order byte.
                        	  1838: ;
                        	  1839: 
                        	  1840: ;                         Name           function or procedure   Args Execution address
                        	  1841: pascal_library_functions_table:
                        	  1842: ;
                        	  1843: ;    functions
                        	  1844: ;
                        	  1845:   makePasLibraryFunction "ABS",          SYMBOL_LIBRARY_FUNCTION,  1, EX_ABS
00:C616 414253          	     1M      asciiz   "ABS"
00:C619 00
00:C61A 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:C61B 01              	     3M      dfb      1
00:C61C FBB0            	     4M      word     EX_ABS
                        	  1846:   makePasLibraryFunction "DIGITALREAD",  SYMBOL_LIBRARY_FUNCTION,  1, EX_DIGITALREAD
00:C61E 4449474954414C52	     1M      asciiz   "DIGITALREAD"
00:C626 454144
00:C629 00
00:C62A 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:C62B 01              	     3M      dfb      1
00:C62C 75B5            	     4M      word     EX_DIGITALREAD
                        	  1847:   makePasLibraryFunction "GETKEY",       SYMBOL_LIBRARY_FUNCTION,  0, EX_GETKEY
00:C62E 4745544B4559    	     1M      asciiz   "GETKEY"
00:C634 00
00:C635 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:C636 00              	     3M      dfb      0
00:C637 B5B0            	     4M      word     EX_GETKEY
                        	  1848:   makePasLibraryFunction "RANDOM",       SYMBOL_LIBRARY_FUNCTION,  0, EX_RANDOM
00:C639 52414E444F4D    	     1M      asciiz   "RANDOM"
00:C63F 00
00:C640 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:C641 00              	     3M      dfb      0
00:C642 9DB5            	     4M      word     EX_RANDOM
                        	  1849:   makePasLibraryFunction "LATENCY",      SYMBOL_LIBRARY_FUNCTION,  0, EX_LATENCY
00:C644 4C4154454E4359  	     1M      asciiz   "LATENCY"
00:C64B 00
00:C64C 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:C64D 00              	     3M      dfb      0
00:C64E AFB5            	     4M      word     EX_LATENCY
                        	  1850: ;
                        	  1851: ;      procedures
                        	  1852: ;
                        	  1853:   makePasLibraryFunction "ASSERT",       SYMBOL_LIBRARY_PROCEDURE, 1, EX_ASSERT
00:C650 415353455254    	     1M      asciiz   "ASSERT"
00:C656 00
00:C657 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C658 01              	     3M      dfb      1
00:C659 02B6            	     4M      word     EX_ASSERT
                        	  1854:   makePasLibraryFunction "DELAY",        SYMBOL_LIBRARY_PROCEDURE, 1, EX_DELAY
00:C65B 44454C4159      	     1M      asciiz   "DELAY"
00:C660 00
00:C661 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C662 01              	     3M      dfb      1
00:C663 BEB5            	     4M      word     EX_DELAY
                        	  1855:   makePasLibraryFunction "DIGITALWRITE", SYMBOL_LIBRARY_PROCEDURE, 2, EX_DIGITALWRITE
00:C665 4449474954414C57	     1M      asciiz   "DIGITALWRITE"
00:C66D 52495445
00:C671 00
00:C672 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C673 02              	     3M      dfb      2
00:C674 EDB5            	     4M      word     EX_DIGITALWRITE
                        	  1856:   makePasLibraryFunction "LCDCLEAR",     SYMBOL_LIBRARY_PROCEDURE, 0, EX_LCDCLEAR
00:C676 4C4344434C454152	     1M      asciiz   "LCDCLEAR"
00:C67E 00
00:C67F 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C680 00              	     3M      dfb      0
00:C681 E7B4            	     4M      word     EX_LCDCLEAR
                        	  1857:   makePasLibraryFunction "LCDHOME",      SYMBOL_LIBRARY_PROCEDURE, 0, EX_LCDHOME
00:C683 4C4344484F4D45  	     1M      asciiz   "LCDHOME"
00:C68A 00
00:C68B 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C68C 00              	     3M      dfb      0
00:C68D E1B4            	     4M      word     EX_LCDHOME
                        	  1858:   makePasLibraryFunction "LCDPOS",       SYMBOL_LIBRARY_PROCEDURE, 2, EX_LCDPOS
00:C68F 4C4344504F53    	     1M      asciiz   "LCDPOS"
00:C695 00
00:C696 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C697 02              	     3M      dfb      2
00:C698 83B5            	     4M      word     EX_LCDPOS
                        	  1859:   makePasLibraryFunction "PINMODE",      SYMBOL_LIBRARY_PROCEDURE, 2, EX_PINMODE
00:C69A 50494E4D4F4445  	     1M      asciiz   "PINMODE"
00:C6A1 00
00:C6A2 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C6A3 02              	     3M      dfb      2
00:C6A4 DEB5            	     4M      word     EX_PINMODE
                        	  1860:   makePasLibraryFunction "RANDOMSEED",   SYMBOL_LIBRARY_PROCEDURE, 1, EX_RANDOMSEED
00:C6A6 52414E444F4D5345	     1M      asciiz   "RANDOMSEED"
00:C6AE 4544
00:C6B0 00
00:C6B1 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C6B2 01              	     3M      dfb      1
00:C6B3 CEB5            	     4M      word     EX_RANDOMSEED
00:C6B5 00              	  1861:   dfb 0   ; end of table
                        	  1862: 
                        	  1863: add_pascal_library_functions:
00:C6B6 A916            	  1864:   lda #<pascal_library_functions_table
00:C6B8 8500            	  1865:   sta REG
00:C6BA A9C6            	  1866:   lda #>pascal_library_functions_table
00:C6BC 8501            	  1867:   sta REG+1
                        	  1868: add_pascal_library_functions_loop:
00:C6BE A000            	  1869:   ldy #0
00:C6C0 B100            	  1870:   lda (REG),Y
00:C6C2 F04B            	  1871:   beq add_pascal_library_functions_done
00:C6C4 A500            	  1872:   lda REG
00:C6C6 8590            	  1873:   sta token_address
00:C6C8 A501            	  1874:   lda REG+1
00:C6CA 8591            	  1875:   sta token_address+1
00:C6CC 6492            	  1876:   stz token_length
                        	  1877: ;
                        	  1878: ;  find name length
                        	  1879: ;
                        	  1880: add_pascal_library_functions_name_loop
00:C6CE C8              	  1881:   iny
00:C6CF E692            	  1882:   inc token_length
00:C6D1 B100            	  1883:   lda (REG),Y
00:C6D3 D0F9            	  1884:   bne add_pascal_library_functions_name_loop
00:C6D5 5A              	  1885:   phy
00:C6D6 A943            	  1886:   lda #SYMBOL_CONSTANT  ; add the symbol as a constant for now
00:C6D8 208EB9          	  1887:   jsr ADDSYM
00:C6DB 7A              	  1888:   ply
                        	  1889: 
00:C6DC C8              	  1890:   iny             ; get past the 0x00
00:C6DD B100            	  1891:   lda (REG),Y     ; get symbol type
00:C6DF 5A              	  1892:   phy
00:C6E0 A003            	  1893:   ldy #SYMTYP
00:C6E2 9140            	  1894:   sta (SYMITM),Y  ; change symbol type to be correct
00:C6E4 7A              	  1895:   ply
                        	  1896: 
00:C6E5 C8              	  1897:   iny             ; get next byte
00:C6E6 B100            	  1898:   lda (REG),Y     ; get number of arguments
00:C6E8 5A              	  1899:   phy
00:C6E9 A006            	  1900:   ldy #SYMARG
00:C6EB 9140            	  1901:   sta (SYMITM),Y  ; save number of arguments
00:C6ED 7A              	  1902:   ply
                        	  1903: 
00:C6EE C8              	  1904:   iny             ; get next byte
00:C6EF B100            	  1905:   lda (REG),Y     ; get function address low-byte
00:C6F1 5A              	  1906:   phy
00:C6F2 A004            	  1907:   ldy #SYMDSP
00:C6F4 9140            	  1908:   sta (SYMITM),Y  ; save function address low-byte
00:C6F6 7A              	  1909:   ply
                        	  1910: 
00:C6F7 C8              	  1911:   iny             ; get next byte
00:C6F8 B100            	  1912:   lda (REG),Y     ; get function address high-byte
00:C6FA 5A              	  1913:   phy
00:C6FB A005            	  1914:   ldy #SYMDSP+1
00:C6FD 9140            	  1915:   sta (SYMITM),Y  ; save function address high-byte
00:C6FF 7A              	  1916:   ply
                        	  1917: 
00:C700 C8              	  1918:   iny         ; get past that last byte
00:C701 98              	  1919:   tya         ; move REG onto next entry
00:C702 18              	  1920:   clc
00:C703 6500            	  1921:   adc REG
00:C705 8500            	  1922:   sta REG
00:C707 A900            	  1923:   lda #0
00:C709 6501            	  1924:   adc REG+1
00:C70B 8501            	  1925:   sta REG+1
00:C70D 80AF            	  1926:   bra add_pascal_library_functions_loop
                        	  1927: 
                        	  1928: add_pascal_library_functions_done:
00:C70F 60              	  1929:   rts
                        	  1930: 
                        	  1931: 
                        	  1932: library_function_call:
                        	  1933: 
00:C710 A900            	  1934:   lda  #0
00:C712 854B            	  1935:   sta  COUNT1      ; number of arguments
00:C714 A006            	  1936:   ldy  #SYMARG
00:C716 B140            	  1937:   lda  (SYMITM),Y
00:C718 F032            	  1938:   beq  library_function_call_1
                        	  1939: 
                        	  1940: ;
                        	  1941: ;  here if it has arguments - push them on the stack
                        	  1942: ;
                        	  1943: 
00:C71A 2096BA          	  1944:   jsr  CHKLHP
                        	  1945: library_function_call_2
00:C71D A54B            	  1946:   lda  COUNT1    ; save on stack in case the expression calls functions
00:C71F 48              	  1947:   pha
00:C720 2000BB          	  1948:   jsr  SYMWRK
00:C723 20C892          	  1949:   jsr  PSHWRK
00:C726 2054BB          	  1950:   jsr  GETEXPR
00:C729 20DB92          	  1951:   jsr  PULWRK
00:C72C 200BBB          	  1952:   jsr  WRKSYM
00:C72F 68              	  1953:   pla            ; get number of arguments back
00:C730 854B            	  1954:   sta  COUNT1
00:C732 E64B            	  1955:   inc  COUNT1    ; add 1 for the one we just processed
00:C734 A593            	  1956:   lda  token_type
00:C736 C92C            	  1957:   cmp  #','
00:C738 F0E3            	  1958:   beq  library_function_call_2
                        	  1959: 
00:C73A A54B            	  1960:   lda  COUNT1
00:C73C A006            	  1961:   ldy  #SYMARG
00:C73E D140            	  1962:   cmp  (SYMITM),Y   ; check we got the right number of arguments
00:C740 F005            	  1963:   beq  library_function_call_3
                        	  1964: 
00:C742 A223            	  1965:   ldx  #35     ; ERROR: Parameters mismatched
00:C744 4CCD97          	  1966:   jmp  ERROR
                        	  1967: library_function_call_3:
00:C747 209DBA          	  1968:   jsr  CHKRHP
00:C74A 8003            	  1969:   bra  library_function_call_5
                        	  1970: 
                        	  1971: ;
                        	  1972: ;  here for no arguments
                        	  1973: ;
                        	  1974: 
                        	  1975: library_function_call_1:
00:C74C 203ACF          	  1976:   jsr  pas_get_token      ; one token look-ahead
                        	  1977: 
                        	  1978: library_function_call_5:
00:C74F A004            	  1979:   ldy  #SYMDSP
00:C751 B140            	  1980:   lda  (SYMITM),Y
00:C753 852B            	  1981:   sta  OPND
00:C755 C8              	  1982:   iny
00:C756 B140            	  1983:   lda  (SYMITM),Y
00:C758 852C            	  1984:   sta  OPND+1
00:C75A A903            	  1985:   lda  #PCODE_LIB_CALL
00:C75C 20E9C7          	  1986:   jsr  GENJMP
00:C75F 60              	  1987:   rts
                        	  1988: 
                        	  1989: 
                        	  1990: ;***********************************************
                        	  1991: ; GENERATE P-CODES - NO OPERANDS
                        	  1992: ;***********************************************
                        	  1993: GENNOP   =  *
00:C760 A442            	  1994:          LDY  SYNTAX
00:C762 D011            	  1995:          BNE  GEN1      ; no storing/displaying if syntax-only compile
00:C764 9123            	  1996:          STA  (PCODE),Y
00:C766 48              	  1997:          PHA
00:C767 20AC92          	  1998:          JSR  DISPAD
00:C76A 68              	  1999:          PLA
00:C76B A62E            	  2000:          LDX  DCODE
00:C76D F006            	  2001:          BEQ  GEN1
00:C76F 20A692          	  2002:          JSR  DISHX
00:C772 209192          	  2003:          JSR  CROUT
                        	  2004: GEN1     =  *
00:C775 A901            	  2005:          LDA  #1      ; 1-byte P-code
00:C777 D035            	  2006:          BNE  GEN2_B
                        	  2007: ;***********************************************
                        	  2008: ; GENERATE P-CODES - WITH ADDRESS (3-bytes stored in DISPL (1)/OFFSET(2))
                        	  2009: ;***********************************************
                        	  2010: GENADR   =  *
00:C779 A442            	  2011:          LDY  SYNTAX
00:C77B D02F            	  2012:          BNE  GEN2    ; no storing/displaying if syntax-only compile
00:C77D 9123            	  2013:          STA  (PCODE),Y
00:C77F 48              	  2014:          PHA
00:C780 A527            	  2015:          LDA  DISPL
00:C782 C8              	  2016:          INY
00:C783 9123            	  2017:          STA  (PCODE),Y
00:C785 A529            	  2018:          LDA  OFFSET
00:C787 C8              	  2019:          INY
00:C788 9123            	  2020:          STA  (PCODE),Y
00:C78A A52A            	  2021:          LDA  OFFSET+1
00:C78C C8              	  2022:          INY
00:C78D 9123            	  2023:          STA  (PCODE),Y
00:C78F 20AC92          	  2024:          JSR  DISPAD
00:C792 68              	  2025:          PLA
00:C793 A62E            	  2026:          LDX  DCODE
00:C795 F015            	  2027:          BEQ  GEN2
00:C797 20A692          	  2028:          JSR  DISHX
00:C79A A527            	  2029:          LDA  DISPL
00:C79C 20A692          	  2030:          JSR  DISHX
00:C79F A529            	  2031:          LDA  OFFSET
00:C7A1 20A692          	  2032:          JSR  DISHX
00:C7A4 A52A            	  2033:          LDA  OFFSET+1
00:C7A6 20A692          	  2034:          JSR  DISHX
00:C7A9 209192          	  2035:          JSR  CROUT
                        	  2036: GEN2     =  *
00:C7AC A904            	  2037:          LDA  #4      ; 4-byte P-code
                        	  2038: GEN2_B   =  *
00:C7AE 18              	  2039:          CLC
00:C7AF 6523            	  2040:          ADC  PCODE
00:C7B1 8523            	  2041:          STA  PCODE
00:C7B3 9002            	  2042:          BCC  GEN2_A
00:C7B5 E624            	  2043:          INC  PCODE+1
                        	  2044: GEN2_A   =  *
00:C7B7 A542            	  2045:          LDA  SYNTAX
00:C7B9 D013            	  2046:          BNE  GEN2_C      ; no storing/displaying if syntax-only compile
00:C7BB A524            	  2047:          LDA  PCODE+1     ; see if P-codes full
00:C7BD C532            	  2048:          CMP  ENDSYM+1   ; in other words, have we hit the symbol table?
00:C7BF 900D            	  2049:          BCC  GEN2_C      ; less than
00:C7C1 D006            	  2050:          BNE  GEN_FULL
00:C7C3 A523            	  2051:          LDA  PCODE
00:C7C5 C531            	  2052:          CMP  ENDSYM   ; TODO - what?
00:C7C7 9005            	  2053:          BCC  GEN2_C
00:C7C9 A201            	  2054: GEN_FULL LDX  #1         ; MEM FULL
00:C7CB 4CCD97          	  2055:          jmp  ERROR
                        	  2056: GEN2_C   =  *
00:C7CE 60              	  2057: DISP9    RTS
                        	  2058: ;***********************************************
                        	  2059: ; GENERATE P-CODES - JUMP ADDRESS (relative to current P-code address in OPND)
                        	  2060: ;***********************************************
                        	  2061: GENRJMP  =  *
00:C7CF 48              	  2062:          PHA
00:C7D0 A52B            	  2063:          LDA  OPND
00:C7D2 38              	  2064:          SEC
00:C7D3 E523            	  2065:          SBC  PCODE
00:C7D5 852B            	  2066:          STA  OPND      ; subtract P-code address to find difference
00:C7D7 A52C            	  2067:          LDA  OPND+1
00:C7D9 E524            	  2068:          SBC  PCODE+1
00:C7DB 852C            	  2069:          STA  OPND+1
00:C7DD 68              	  2070:          PLA
00:C7DE 4CE9C7          	  2071:          JMP  GENJMP
                        	  2072: ;
                        	  2073: GENNJP   =  *
00:C7E1 A93C            	  2074:          LDA  #PCODE_JMP       ; JMP
                        	  2075: 
                        	  2076: ; Generate jump, P-code is in "A" register (eg. PCODE_JMZ, PCODE_JM1)
                        	  2077: ;
                        	  2078: ;  Note: the destination here is 0000, however FIXAD will be called later to fix up
                        	  2079: ;        the jump, once we know what the destination will be (ie. further down the code)
                        	  2080: ;
00:C7E3 A200            	  2081: GENNJM   LDX  #0
00:C7E5 862B            	  2082:          STX  OPND
00:C7E7 862C            	  2083:          STX  OPND+1
                        	  2084: ;
                        	  2085: ;***********************************************
                        	  2086: ; GENERATE P-CODES - JUMP ADDRESS (absolute address in OPND)
                        	  2087: ;   also used in other places, like increment stack address
                        	  2088: ;***********************************************
                        	  2089: GENJMP   =  *
00:C7E9 A442            	  2090:          LDY  SYNTAX
00:C7EB D025            	  2091:          BNE  GEN3     ; no storing/displaying if syntax-only compile
00:C7ED 9123            	  2092:          STA  (PCODE),Y
00:C7EF 48              	  2093:          PHA
00:C7F0 A52B            	  2094:          LDA  OPND
00:C7F2 C8              	  2095:          INY
00:C7F3 9123            	  2096:          STA  (PCODE),Y
00:C7F5 A52C            	  2097:          LDA  OPND+1
00:C7F7 C8              	  2098:          INY
00:C7F8 9123            	  2099:          STA  (PCODE),Y
00:C7FA 20AC92          	  2100:          JSR  DISPAD
00:C7FD 68              	  2101:          PLA
00:C7FE A62E            	  2102:          LDX  DCODE
00:C800 F010            	  2103:          BEQ  GEN3
00:C802 20A692          	  2104:          JSR  DISHX
00:C805 A52B            	  2105:          LDA  OPND
00:C807 20A692          	  2106:          JSR  DISHX
00:C80A A52C            	  2107:          LDA  OPND+1
00:C80C 20A692          	  2108:          JSR  DISHX
00:C80F 209192          	  2109:          JSR  CROUT
                        	  2110: GEN3     =  *
00:C812 A903            	  2111:          LDA  #3        ; 3-byte P-code
00:C814 4CAEC7          	  2112:          JMP  GEN2_B
                        	  2113: 
                        	  2114: ;***********************************************
                        	  2115: ; FIXUP ADDRESSES
                        	  2116: ;***********************************************
                        	  2117: FIXAD    =  *
00:C817 A442            	  2118:          LDY  SYNTAX
00:C819 D039            	  2119:          BNE  FIXAD1
00:C81B A001            	  2120:          LDY  #1
00:C81D A523            	  2121:          LDA  PCODE
00:C81F 38              	  2122:          SEC
00:C820 E537            	  2123:          SBC  WORK
00:C822 9137            	  2124:          STA  (WORK),Y
00:C824 C8              	  2125:          INY
00:C825 A524            	  2126:          LDA  PCODE+1
00:C827 E538            	  2127:          SBC  WORK+1
00:C829 9137            	  2128:          STA  (WORK),Y
00:C82B A52E            	  2129:          LDA  DCODE
00:C82D F025            	  2130:          BEQ  FIXAD1
00:C82F A955            	  2131:          LDA  #<FIXM1
00:C831 A2C8            	  2132:          LDX  #>FIXM1
00:C833 202682          	  2133:          JSR  print
00:C836 A538            	  2134:          LDA  WORK+1
00:C838 200693          	  2135:          JSR  PRBYTE
00:C83B A537            	  2136:          LDA  WORK
00:C83D 20A692          	  2137:          JSR  DISHX
00:C840 A95E            	  2138:          LDA  #<FIXM2
00:C842 A2C8            	  2139:          LDX  #>FIXM2
00:C844 202682          	  2140:          JSR  print
00:C847 A524            	  2141:          LDA  PCODE+1
00:C849 200693          	  2142:          JSR  PRBYTE
00:C84C A523            	  2143:          LDA  PCODE
00:C84E 20A692          	  2144:          JSR  DISHX
00:C851 4C9192          	  2145:          JMP  CROUT
00:C854 60              	  2146: FIXAD1    rts
                        	  2147: 
00:C855 4A756D7020617420	  2148: FIXM1    asciiz  'Jump at '
00:C85D 00
00:C85E 6368616E67656420	  2149: FIXM2    asciiz  'changed to '   ; changed to
00:C866 746F20
00:C869 00
                        	  2150: 
                        	  2151: 

Source: "gpascal.asm"
                        	   185:   .include "hardware.inc"

Source: "hardware.inc"
                        	     1: 
                        	     2: ; VIA - Versatile Interface Adapter (W65C22) hardware
                        	     3: 
                        	     4: VIA_PORTB   = $7FF0   ; input/output register "B"
                        	     5: VIA_PORTA   = $7FF1   ; input/output register "A"
                        	     6: VIA_DDRB    = $7FF2   ; data direction register "B"
                        	     7: VIA_DDRA    = $7FF3   ; data direction register "A"
                        	     8: VIA_T1C_L   = $7FF4   ; T1 write: latch (L), read: counter (L)
                        	     9: VIA_T1C_H   = $7FF5   ; T1 high_order counter
                        	    10: VIA_T1L_L   = $7FF6   ; T1 low_order latches
                        	    11: VIA_T1L_H   = $7FF7   ; T1 high_order latches
                        	    12: VIA_T2C_L   = $7FF8   ; T2 write: latch (L), read: counter (L)
                        	    13: VIA_T2C_H   = $7FF9   ; T2 high_order counter
                        	    14: VIA_SR      = $7FFA   ; shift register
                        	    15: VIA_ACR     = $7FFB   ; auxilliary control register
                        	    16: VIA_PCR     = $7FFC   ; peripheral control register
                        	    17: VIA_IFR     = $7FFD   ; interrupt flag register
                        	    18: VIA_IER     = $7FFE   ; interrupt enable register
                        	    19: 
                        	    20: VIA_FLAG_ENABLE   = %10000000 ; high-order bit set enables the flag
                        	    21: VIA_FLAG_DISABLE  = %00000000 ; high-order bit clear disables the flag
                        	    22: VIA_FLAG_TIMER1   = %01000000
                        	    23: VIA_FLAG_TIMER2   = %00100000
                        	    24: VIA_FLAG_CB1      = %00010000
                        	    25: VIA_FLAG_CB2      = %00001000
                        	    26: VIA_FLAG_SHIFT    = %00000100
                        	    27: VIA_FLAG_CA1      = %00000010
                        	    28: VIA_FLAG_CA2      = %00000001
                        	    29: 
                        	    30: ;
                        	    31: ; VIA Port A pin masks
                        	    32: ;
                        	    33: 
                        	    34: SERIAL_IN_MASK     = %00000001   ; serial in on PA0 (also connect to CB2) (to FTDI TxD pin - pin 4)
                        	    35: SERIAL_OUT_MASK    = %00000010   ; serial out on PA1 (to FTDI RxD pin - pin 5)
                        	    36: SERIAL_DEBUG1_MASK = %00000100   ; serial debugging on PA2
                        	    37: SERIAL_DEBUG2_MASK = %00001000   ; serial debugging on PA3
                        	    38: SERIAL_SPARE2_MASK = %00010000   ; spare VIA pins (PA4)
                        	    39: 
                        	    40: 
                        	    41: ;***********************************************
                        	    42: ;  Functions added for Ben's Board
                        	    43: ;***********************************************
                        	    44: 
                        	    45: ;
                        	    46: ;  Converts a pin number in the range 0 to 15 to a mask
                        	    47: ;  eg. 00000001, 00000010, 00000100 and so on
                        	    48: ;
                        	    49: ;  Returns mask in Y
                        	    50: ;
                        	    51: ;  Returns with Z set if the range was 0 to 7 an
                        	    52: ;  and Z clear if the range was 8 to 15
                        	    53: ;
                        	    54: pin_number_to_mask = *
00:C86A 48              	    55:   pha         ; save for a moment
00:C86B 2907            	    56:   and #$7     ; make in range 0 to 7
00:C86D A8              	    57:   tay
00:C86E A901            	    58:   lda #1      ; initial mask
                        	    59: pin_number_to_mask_loop:
00:C870 C000            	    60:   cpy #0
00:C872 F004            	    61:   beq pin_number_to_mask_done
00:C874 0A              	    62:   asl A
00:C875 88              	    63:   dey
00:C876 80F8            	    64:   bra pin_number_to_mask_loop
                        	    65: pin_number_to_mask_done:
00:C878 A8              	    66:   tay         ; save mask in Y
00:C879 68              	    67:   pla
00:C87A 2908            	    68:   and #$8     ; DDRA or DDRB ?
00:C87C 60              	    69:   rts
                        	    70: 
                        	    71: ;
                        	    72: ;  pin in A, mode in X
                        	    73: ;
                        	    74: pinmode:
00:C87D 868C            	    75:   stx hardware_work ; input or output
00:C87F 206AC8          	    76:   jsr pin_number_to_mask  ; convert to appropriate mask bit
00:C882 D00A            	    77:   bne pinmode_B        ; Z is clear if it is DDRB
00:C884 A9F3            	    78:   lda #<VIA_DDRA
00:C886 8500            	    79:   sta REG
00:C888 A97F            	    80:   lda #>VIA_DDRA
00:C88A 8501            	    81:   sta REG+1
00:C88C 8008            	    82:   bra pinmode_C
                        	    83: pinmode_B:
00:C88E A9F2            	    84:   lda #<VIA_DDRB
00:C890 8500            	    85:   sta REG
00:C892 A97F            	    86:   lda #>VIA_DDRB
00:C894 8501            	    87:   sta REG+1
                        	    88: ;
                        	    89: ;  The DDR register is now in REG
                        	    90: ;
                        	    91: pinmode_C:
00:C896 A58C            	    92:   lda hardware_work     ; input or output?
00:C898 D00A            	    93:   bne pinmode_OUTPUT
                        	    94: ;
                        	    95: ;  here to set input mode
                        	    96: ;
00:C89A 98              	    97:   tya       ; get the mask back
00:C89B A000            	    98:   ldy #0
00:C89D 49FF            	    99:   eor #$FF  ; negate the mask
00:C89F 3100            	   100:   and (REG),y
00:C8A1 9100            	   101:   sta (REG),y
00:C8A3 60              	   102:   rts       ; done
                        	   103: ;
                        	   104: ;  here to set output mode
                        	   105: ;
                        	   106: pinmode_OUTPUT:
00:C8A4 98              	   107:   tya          ; get the mask back
00:C8A5 A000            	   108:   ldy #0
00:C8A7 1100            	   109:   ora (REG),y  ; or in with the existing DDR register
00:C8A9 9100            	   110:   sta (REG),y  ; and write it back
00:C8AB 60              	   111:   rts          ; done
                        	   112: 
                        	   113: 
                        	   114: ;
                        	   115: ;  DIGITALWRITE (pin, value) pin:0 to 15; value: 0 or 1 : pin in A, mode in X
                        	   116: ;
                        	   117: digitalwrite = *
00:C8AC 868C            	   118:   stx hardware_work ; save what to write (0 or 1)
00:C8AE 206AC8          	   119:   jsr pin_number_to_mask  ; convert to appropriate mask bit
00:C8B1 D00A            	   120:   bne digitalwrite_B        ; Z is clear if it is PORTB
00:C8B3 A9F1            	   121:   lda #<VIA_PORTA
00:C8B5 8500            	   122:   sta REG
00:C8B7 A97F            	   123:   lda #>VIA_PORTA
00:C8B9 8501            	   124:   sta REG+1
00:C8BB 8008            	   125:   bra digitalwrite_C
                        	   126: digitalwrite_B:
00:C8BD A9F0            	   127:   lda #<VIA_PORTB
00:C8BF 8500            	   128:   sta REG
00:C8C1 A97F            	   129:   lda #>VIA_PORTB
00:C8C3 8501            	   130:   sta REG+1
                        	   131: ;
                        	   132: ;  The PORT register is now in REG
                        	   133: ;
                        	   134: digitalwrite_C:
00:C8C5 A58C            	   135:   lda hardware_work
00:C8C7 D00A            	   136:   bne digitalwrite_ONE  ; any non-zero value is writing a 1
                        	   137: ;
                        	   138: ;  here to write a zero
                        	   139: ;
00:C8C9 98              	   140:   tya
00:C8CA A000            	   141:   ldy #0
00:C8CC 49FF            	   142:   eor #$FF  ; negate the mask
00:C8CE 3100            	   143:   and (REG),y
00:C8D0 9100            	   144:   sta (REG),y
00:C8D2 60              	   145:   rts       ; done
                        	   146: 
                        	   147: ;
                        	   148: ;  here to write a one
                        	   149: ;
                        	   150: digitalwrite_ONE:
00:C8D3 98              	   151:   tya          ; get the mask back
00:C8D4 A000            	   152:   ldy #0
00:C8D6 1100            	   153:   ora (REG),y  ; or in with the existing DDR register
00:C8D8 9100            	   154:   sta (REG),y  ; and write it back
00:C8DA 60              	   155:   rts          ; done
                        	   156: 
                        	   157: 
                        	   158: ;
                        	   159: ;  DIGITALREAD (pin) pin:0 to 15; Pin to read is in in A. returns or non-zero in A.
                        	   160: ;
                        	   161: digitalread = *
00:C8DB 206AC8          	   162:   jsr pin_number_to_mask  ; convert to appropriate mask bit
00:C8DE D00A            	   163:   bne digitalread_B        ; Z is clear if it is PORTB
00:C8E0 A9F1            	   164:   lda #<VIA_PORTA
00:C8E2 8500            	   165:   sta REG
00:C8E4 A97F            	   166:   lda #>VIA_PORTA
00:C8E6 8501            	   167:   sta REG+1
00:C8E8 8008            	   168:   bra digitalread_C
                        	   169: digitalread_B:
00:C8EA A9F0            	   170:   lda #<VIA_PORTB
00:C8EC 8500            	   171:   sta REG
00:C8EE A97F            	   172:   lda #>VIA_PORTB
00:C8F0 8501            	   173:   sta REG+1
                        	   174: ;
                        	   175: ;  The PORT register is now in REG
                        	   176: ;
                        	   177: digitalread_C:
00:C8F2 98              	   178:   tya         ; get the mask back
00:C8F3 A000            	   179:   ldy #0
00:C8F5 3100            	   180:   and (REG),y ; get that bit
00:C8F7 60              	   181:   rts
                        	   182: 
                        	   183: 
                        	   184: 
                        	   185: ;
                        	   186: ;  Functions to change where writing is done
                        	   187: ;
                        	   188: write_to_serial:
00:C8F8 48              	   189:   pha
00:C8F9 A956            	   190:   lda  #<write_char
00:C8FB 8517            	   191:   sta  write_function
00:C8FD A9C9            	   192:   lda  #>write_char
00:C8FF 8518            	   193:   sta  write_function+1
00:C901 68              	   194:   pla
00:C902 60              	   195:   rts
                        	   196: 
                        	   197: write_to_lcd:
00:C903 48              	   198:   pha
00:C904 A9B4            	   199:   lda  #<lcd_print_char
00:C906 8517            	   200:   sta  write_function
00:C908 A9B8            	   201:   lda  #>lcd_print_char
00:C90A 8518            	   202:   sta  write_function+1
00:C90C 68              	   203:   pla
00:C90D 60              	   204:   rts
                        	   205: 
                        	   206: 
                        	   207: 
                        	   208: ; ---------------------------
                        	   209: ; Simulate kernel interfaces
                        	   210: ; ---------------------------
                        	   211: ; We interface by reading/writing to special
                        	   212: ; RAM that is implemented in the emulator
                        	   213: 
                        	   214: 
                        	   215: 
                        	   216:     .if EMULATOR
                        	   217: 
                        	   218: ;
                        	   219: ;  Emulator testing
                        	   220: ;
                        	   221: CHRIN    =  *
                        	   222:          lda  $7F22
                        	   223:          rts
                        	   224: 
                        	   225: write_char   =  *
                        	   226:          sta  $7F23
                        	   227:          rts
                        	   228: 
                        	   229: 
                        	   230: GETIN    =  *
                        	   231:          lda  $7F29
                        	   232:          rts
                        	   233: 
                        	   234: hardware_init rts
                        	   235: 
                        	   236: ;
                        	   237: ;  put debug number in A
                        	   238: ;
                        	   239: EMULATOR_DEBUG = *
                        	   240:          sta $7F46
                        	   241:          rts
                        	   242: 
                        	   243: START_TRACE = *
                        	   244:          sta $7F47
                        	   245:          rts
                        	   246: 
                        	   247: STOP_TRACE = *
                        	   248:          sta $7F48
                        	   249:          rts
                        	   250: ;
                        	   251: ;  not applicable in emulator
                        	   252: ;
                        	   253: lcd_print_message   rts
                        	   254: lcd_clear_display   rts
                        	   255: lcd_print_char      rts
                        	   256: lcd_second_line     rts
                        	   257: lcd_instruction     rts
                        	   258: lcd_get_address     rts
                        	   259: lcd_wait            rts
                        	   260: lcd_home            rts
                        	   261: lcd_initialise      rts
                        	   262: serial_available    rts
                        	   263: serial_print_message rts
                        	   264: 
                        	   265:   .else
                        	   266: 
                        	   267: ;
                        	   268: ;  Ben's Board
                        	   269: ;
                        	   270: 
                        	   271: ;
                        	   272: ;  typing_latency could be used as a seed for the random number generator
                        	   273: ;    - the exact time between keypresses would be somewhat unpredictable
                        	   274: ;
                        	   275: CHRIN  = *
                        	   276: GETIN    =  *
00:C90E E60D            	   277:          inc typing_latency
00:C910 D006            	   278:          bne GETIN1
00:C912 E60E            	   279:          inc typing_latency+1
00:C914 D002            	   280:          bne GETIN1
00:C916 E60F            	   281:          inc typing_latency+2
                        	   282: GETIN1:
00:C918 A58B            	   283:          lda serial_in_byte_received
00:C91A F0F2            	   284:          beq GETIN    ; nothing yet
00:C91C 648B            	   285:          stz serial_in_byte_received
00:C91E 60              	   286:          rts
                        	   287: 
                        	   288: serial_available = *
00:C91F A58B            	   289:          lda serial_in_byte_received
00:C921 60              	   290:          rts
                        	   291: 
                        	   292: 
00:C922 60              	   293: EMULATOR_DEBUG rts
00:C923 60              	   294: START_TRACE rts
00:C924 60              	   295: STOP_TRACE rts
                        	   296: 
                        	   297: 
                        	   298: ;
                        	   299: ;  set up serial hardware
                        	   300: ;
                        	   301: 
                        	   302: hardware_init:
                        	   303: 
00:C925 A902            	   304:   lda #SERIAL_OUT_MASK  ; set 1 bit (idle serial comms), and others to zero
00:C927 8DF17F          	   305:   sta VIA_PORTA
                        	   306: 
                        	   307:   ; set output enable bits
00:C92A A91E            	   308:   lda #(SERIAL_OUT_MASK | SERIAL_DEBUG1_MASK | SERIAL_DEBUG2_MASK | SERIAL_SPARE2_MASK)
00:C92C 8DF37F          	   309:   sta VIA_DDRA
                        	   310: 
00:C92F A940            	   311:   lda #%01000000      ; continuous interrupts on T1
00:C931 8DFB7F          	   312:   sta VIA_ACR
                        	   313: 
00:C934 A900            	   314:   lda #0              ; Input-negative active edge
00:C936 8DFC7F          	   315:   sta VIA_PCR
                        	   316: 
00:C939 A9D0            	   317:   lda #<BIT_INTERVAL  ; ie. baud rate interval
00:C93B 8DF47F          	   318:   sta VIA_T1C_L       ; for sending bits
00:C93E A900            	   319:   lda #>BIT_INTERVAL
00:C940 8DF57F          	   320:   sta VIA_T1C_H       ; this starts the counter
                        	   321: 
                        	   322:   ; set up for serial input
                        	   323: 
00:C943 A988            	   324:   lda #VIA_FLAG_ENABLE | VIA_FLAG_CB2  ; interrupt on CB2 falling edge
00:C945 8DFE7F          	   325:   sta VIA_IER
                        	   326: 
00:C948 A9FF            	   327:   lda #$FF         ; clear all interrupt flags
00:C94A 8DFD7F          	   328:   sta VIA_IFR
                        	   329: 
                        	   330:   .if LCD_SUPPORT
00:C94D 20A5B7          	   331:   jsr lcd_initialise
                        	   332:   .endif
                        	   333: 
00:C950 648A            	   334:   stz serial_in_byte    ; non-zero means an interrupt put in incoming byte there
00:C952 6489            	   335:   stz serial_out_bit
                        	   336: 
00:C954 58              	   337:   cli         ; enable interrupts
00:C955 60              	   338:   rts
                        	   339: 
                        	   340: 
                        	   341: ;
                        	   342: ;  Write a character (in A) to the serial port.
                        	   343: ;   Interrupts MUST be enabled for this to work!
                        	   344: ;
                        	   345: write_char:
00:C956 48              	   346:   pha                   ; save original character
00:C957 0A              	   347:   asl a                 ; shift in a zero which will be the start bit
00:C958 8587            	   348:   sta serial_out_byte
00:C95A A9FF            	   349:   lda #0xff             ; will become the stop bit(s)
00:C95C 2A              	   350:   rol a                 ; rotate in the high-order bit from the data byte
00:C95D 8588            	   351:   sta serial_out_byte+1
00:C95F A90B            	   352:   lda #11               ; 8 data bits, one start bit, two stop bits
00:C961 8589            	   353:   sta serial_out_bit    ; number of bits to shift out
00:C963 A9D0            	   354:   lda #<BIT_INTERVAL    ; ie. baud rate interval
00:C965 8DF47F          	   355:   sta VIA_T1C_L         ; for sending bits
00:C968 A900            	   356:   lda #>BIT_INTERVAL
00:C96A 8DF57F          	   357:   sta VIA_T1C_H         ; this starts the counter
00:C96D A9C0            	   358:   lda #VIA_FLAG_ENABLE | VIA_FLAG_TIMER1  ; interrupt on T1 timeout
00:C96F 8DFE7F          	   359:   sta VIA_IER
                        	   360: 
                        	   361: ;
                        	   362: ; wait for this byte to finish - otherwise it might interfere with many things
                        	   363: ;
                        	   364: 
                        	   365: write_char_loop:
00:C972 ADFE7F          	   366:   lda VIA_IER
00:C975 2940            	   367:   and #VIA_FLAG_TIMER1  ; are T1 interrupts enabled?
00:C977 D0F9            	   368:   bne write_char_loop   ; loop until this character sent
00:C979 68              	   369:   pla                   ; get character back
00:C97A 60              	   370:   rts
                        	   371: 
                        	   372: 
                        	   373: ;
                        	   374: ;  sends null-terminated message to serial port, message in A (lo) and X (hi)
                        	   375: ;  returns the length of the message in Y
                        	   376: ;
                        	   377: serial_print_message:
00:C97B 8503            	   378:   sta REG2
00:C97D 8604            	   379:   stx REG2+1
00:C97F A000            	   380:   ldy #0
                        	   381: serial_print:
00:C981 B103            	   382:   lda (REG2),y
00:C983 F006            	   383:   beq serial_print_done
00:C985 2056C9          	   384:   jsr write_char
00:C988 C8              	   385:   iny
00:C989 80F6            	   386:   bra serial_print
                        	   387: 
00:C98B 60              	   388: serial_print_done rts
                        	   389: 
                        	   390:   .endif  ; not EMULATOR
                        	   391: 
                        	   392: 

Source: "gpascal.asm"
                        	   186:   .include "gtoken.inc"

Source: "gtoken.inc"
                        	     1: ;
                        	     2: ;  get_token
                        	     3: ;
                        	     4: ;  Gets a lexical token from the specified address.
                        	     5: ;
                        	     6: ;  - Start parsing at token_start (this should be the first character of the token)
                        	     7: ;  - The first found character (after spaces, comments, newlines) is in token_address
                        	     8: ;      - this is mainly used for knowing what the identifier is so we can put it in the symbol table
                        	     9: ;      - strings are put into INBUF after processing, so token_address is not as useful in that case
                        	    10: ;  - The length is in token_length (in the case of strings, this is the processed length)
                        	    11: ;  - The type is in token_type - zero would mean end of file
                        	    12: ;
                        	    13: ;  The types are one of the token codes below
                        	    14: ;
                        	    15: ;  Tokens which start with a letter and are possibly followed by letters, numbers, and
                        	    16: ;    the underscore character become TOKEN_IDENTIFIER.
                        	    17: ;
                        	    18: ;  Tokens starting with a number (TOKEN_NUMBER) are parsed for the value which is placed into token_value.
                        	    19: ;
                        	    20: ;  Tokens starting with a single or double quote are parsed for the internal string (TOKEN_STRING)
                        	    21: ;  which is placed in INBUF. The internal string has internal double-quotes turned
                        	    22: ;  into single quotes, and sequences like \n or \x42 turned into their appropriate characters.
                        	    23: ;
                        	    24: ;  String tokens which are up to 3 bytes long also have the 3 bytes placed into token_value.
                        	    25: ;
                        	    26: ;  Hex and binary tokens are parsed for their value which is placed into token_value.
                        	    27: ;
                        	    28: ;  Various 2-character tokens are given their own code (eg. <> == != := << >> and so on).
                        	    29: ;
                        	    30: ;  Spaces and comments are skipped, however Pascal directives inside comments are processed
                        	    31: ;
                        	    32: ;  Newlines are skipped in Pascal but returned as a token in assembler (ASSEMBLING == true)
                        	    33: ;  If newlines are skipped then token_line is called to handle listing the line (the line
                        	    34: ;   we are about to process, not the previous line)
                        	    35: ;
                        	    36: ; Rewritten in February 2022 to be easier to read and have well-defined work variables (zero-page variables)
                        	    37: 
                        	    38: ; multi-byte token codes (single byte tokens are themselves)
                        	    39: 
                        	    40: TOKEN_ASSIGN     = 'A'   ; :=
                        	    41: TOKEN_IDENTIFIER = 'I'   ; alpha-numeric identifiers
                        	    42: TOKEN_NUMBER     = 'N'   ; numbers
                        	    43: TOKEN_STRING     = '"'   ; string literal
                        	    44: TOKEN_LEQ        = $80   ; <=
                        	    45: TOKEN_GEQ        = $81   ; >=
                        	    46: TOKEN_NEQ        = 'U'   ; <>
                        	    47: 
                        	    48: ;
                        	    49: ;  the ones below are used in the assembler
                        	    50: ;
                        	    51: TOKEN_EQUALITY    = 'E'     ; ==
                        	    52: TOKEN_SHIFT_LEFT  = 'L'     ; <<
                        	    53: TOKEN_SHIFT_RIGHT = 'R'     ; >>
                        	    54: TOKEN_UNARY_MINUS = 'M'     ; -
                        	    55: TOKEN_LOW_BYTE    = 'V'     ; eg. lda #<foo
                        	    56: TOKEN_HIGH_BYTE   = 'W'     ; eg. lda #>foo
                        	    57: TOKEN_LOGICAL_AND = 'X'     ; &&
                        	    58: TOKEN_LOGICAL_OR  = 'Y'     ; ||
                        	    59: TOKEN_INEQUALITY  = 'Z'     ; !=
                        	    60: 
                        	    61: 
                        	    62: get_token:
00:C98C A593            	    63:   lda token_type      ; remember previous token for checking if + or - stand on their own
00:C98E 8598            	    64:   sta token_work
                        	    65: get_token_loop:
00:C990 A000            	    66:   ldy #0              ; offset into the token address
00:C992 8497            	    67:   sty token_sign      ; Y is zero at this point
00:C994 8494            	    68:   sty token_value     ; no value yet
00:C996 8495            	    69:   sty token_value+1
00:C998 8496            	    70:   sty token_value+2
                        	    71: 
                        	    72: gc_skip_spaces:
00:C99A B18E            	    73:   lda (token_start),y
00:C99C F034            	    74:   beq gc_done         ; 0x00 means end, so return it WITHOUT incrementing the pointer
00:C99E C90A            	    75:   cmp #NL             ; newline need special handling
00:C9A0 F00D            	    76:   beq gc_newline
00:C9A2 204A81          	    77:   jsr isspace
00:C9A5 9043            	    78:   bcc gc_not_space
00:C9A7 E68E            	    79:   inc token_start     ; increment pointer because spaces can be any length
00:C9A9 D0EF            	    80:   bne gc_skip_spaces
00:C9AB E68F            	    81:   inc token_start+1
00:C9AD 80EB            	    82:   bra gc_skip_spaces
                        	    83: 
                        	    84: ;
                        	    85: ;  got a newline - if assembling, return that so we know where lines end
                        	    86: ;  otherwise just call token_line to display the next line and press on looking
                        	    87: ;  for tokens.
                        	    88: ;
                        	    89: gc_newline:
00:C9AF A902            	    90:   lda #FLAG_ASSEMBLING
00:C9B1 25BE            	    91:   and system_flags
00:C9B3 D014            	    92:   bne gc_newline_assembling    ; return the newline as a token
00:C9B5 C8              	    93:   iny              ; length in Y (ie. one)
00:C9B6 E68E            	    94:   inc token_start
00:C9B8 D002            	    95:   bne gc_newline1
00:C9BA E68F            	    96:   inc token_start+1
                        	    97: gc_newline1:
00:C9BC A58E            	    98:   lda token_start
00:C9BE 859C            	    99:   sta token_line_start
00:C9C0 A58F            	   100:   lda token_start+1
00:C9C2 859D            	   101:   sta token_line_start+1
00:C9C4 202CCA          	   102:   jsr token_line        ; list the next line
00:C9C7 80C7            	   103:   bra get_token_loop    ; look for another token
                        	   104: 
                        	   105: gc_newline_assembling:
00:C9C9 A90A            	   106:   lda #NL       ; get the newline back
00:C9CB 4CD0C9          	   107:   jmp gc_single_byte_token
                        	   108: 
                        	   109: ;
                        	   110: ;  wrap up getting a token:
                        	   111: ;
                        	   112: ;   - save the type
                        	   113: ;   - save the current address as token_address
                        	   114: ;   - add the length to token_start ready for next time
                        	   115: ;
                        	   116: gc_single_byte_already_known:
00:C9CE A593            	   117:   lda token_type        ; get back saved token type
                        	   118: gc_single_byte_token:
00:C9D0 A001            	   119:   ldy #1
                        	   120: gc_done:
00:C9D2 8492            	   121:   sty token_length      ; Y has our length
00:C9D4 8593            	   122:   sta token_type        ; A has our type
00:C9D6 18              	   123:   clc
00:C9D7 A58E            	   124:   lda token_start
00:C9D9 8590            	   125:   sta token_address     ; save the starting address of the token
00:C9DB 6592            	   126:   adc token_length      ; now add its length
00:C9DD 858E            	   127:   sta token_start       ; that gives the ending address
                        	   128: 
00:C9DF A58F            	   129:   lda token_start+1     ; repeat for high-order byte
00:C9E1 8591            	   130:   sta token_address+1
00:C9E3 6900            	   131:   adc #0
00:C9E5 858F            	   132:   sta token_start+1
                        	   133: 
00:C9E7 A593            	   134:   lda token_type        ; get token type back into A
00:C9E9 60              	   135:   rts
                        	   136: 
                        	   137: ;
                        	   138: ;  not a space (or newline) so this must be the actual start of it
                        	   139: ;
                        	   140: 
                        	   141: gc_not_space:
                        	   142: 
                        	   143: ;
                        	   144: ;  first look for classes of characters (ie. alpha, numeric)
                        	   145: ;
00:C9EA 202681          	   146:   jsr isalpha
00:C9ED 9026            	   147:   bcc gc_not_alpha
                        	   148: 
                        	   149: ;
                        	   150: ;  find end of identifier
                        	   151: ;
                        	   152: gc_alpha_loop:
00:C9EF C8              	   153:   iny
00:C9F0 D005            	   154:   bne gc_alpha_ok   ; if it becomes zero now, we have 256+ long identifier
00:C9F2 A20C            	   155:   ldx #12       ; ERROR: Illegal Identifier (too long)
00:C9F4 4CCD97          	   156:   jmp ERROR
                        	   157: 
                        	   158: gc_alpha_ok:
00:C9F7 A940            	   159:   lda #FLAG_ONLY_ALPHA
00:C9F9 24BE            	   160:   bit system_flags
00:C9FB D00F            	   161:   bne gc_alpha_alpha_only
00:C9FD B18E            	   162:   lda (token_start),y
00:C9FF 206281          	   163:   jsr isalnum
00:CA02 B0EB            	   164:   bcs gc_alpha_loop
00:CA04 C95F            	   165:   cmp #'_'
00:CA06 F0E7            	   166:   beq gc_alpha_loop
                        	   167: 
                        	   168: ;
                        	   169: ; end of identifier
                        	   170: ;
                        	   171: gc_alpha_done:
00:CA08 A949            	   172:   lda #TOKEN_IDENTIFIER
00:CA0A 80C6            	   173:   bra gc_done
                        	   174: 
                        	   175: 
                        	   176: gc_alpha_alpha_only:
00:CA0C B18E            	   177:   lda (token_start),y
00:CA0E 202681          	   178:   jsr isalpha
00:CA11 B0DC            	   179:   bcs gc_alpha_loop
00:CA13 80F3            	   180:   bra gc_alpha_done
                        	   181: 
                        	   182: ;
                        	   183: ; now see if it is a digit
                        	   184: ;
                        	   185: gc_not_alpha:
00:CA15 203281          	   186:   jsr isdigit
00:CA18 9007            	   187:   bcc gc_not_digit
                        	   188: 
00:CA1A 207BCA          	   189:   jsr atoi
00:CA1D A94E            	   190:   lda  #TOKEN_NUMBER
00:CA1F 80B1            	   191:   bra  gc_done
                        	   192: 
                        	   193: ;
                        	   194: ;  not alpha and not digit - so let's consider:
                        	   195: ;   * prefixes: $ for hex and % for binary
                        	   196: ;   *  + or - in front of numbers or on their own
                        	   197: ;   * single character tokens, eg. =, (, ) and so on
                        	   198: ;   * double-character tokens, eg. ==, >= << and so on
                        	   199: ;   * strings, eg. "foo"
                        	   200: ;
                        	   201: ;  we'll do a jump on the first character
                        	   202: ;
                        	   203: gc_not_digit:
00:CA21 8593            	   204:   sta token_type            ; remember it in case of possible two-byte sequences
00:CA23 A209            	   205:   ldx #<gtoken_table
00:CA25 A0CB            	   206:   ldy #>gtoken_table
00:CA27 20FB8F          	   207:   jsr TKNJMP
00:CA2A 80A2            	   208:   bra gc_single_byte_already_known  ; it is what it is
                        	   209: 
                        	   210: ;
                        	   211: ;  here when get_token discovers a newline - print the next line if wanted
                        	   212: ;
                        	   213: 
                        	   214: token_line:
                        	   215: ;
                        	   216: ;  count lines
                        	   217: ;
00:CA2C E6A2            	   218:   inc current_line
00:CA2E D002            	   219:   bne token_line1
00:CA30 E6A3            	   220:   inc current_line+1
                        	   221: token_line1:
                        	   222: ;
                        	   223: ;  compiling or assembling?
                        	   224: ;
00:CA32 A901            	   225:   lda #FLAG_COMPILING
00:CA34 0902            	   226:   ora #FLAG_ASSEMBLING
00:CA36 25BE            	   227:   and system_flags
00:CA38 F040            	   228:   beq token_line_done ; no - no listing
                        	   229: ;
                        	   230: ;  listing wanted?
                        	   231: ;
00:CA3A A904            	   232:   lda #FLAG_LIST_SOURCE
00:CA3C 25BE            	   233:   and system_flags
00:CA3E D00D            	   234:   bne token_line_listing ; yes
                        	   235: 
                        	   236: ;
                        	   237: ;  no listing - show an asterisk every 15 lines
                        	   238: ;
00:CA40 A5A2            	   239:   lda current_line
00:CA42 290F            	   240:   and #$0F
00:CA44 D034            	   241:   bne token_line_done
00:CA46 A92A            	   242:   lda #'*'
00:CA48 201894          	   243:   jsr COUT
00:CA4B 802D            	   244:   bra token_line_done
                        	   245: 
                        	   246: token_line_listing:
00:CA4D A52E            	   247:   lda DCODE
00:CA4F 48              	   248:   pha
00:CA50 A901            	   249:   lda #1
00:CA52 852E            	   250:   sta DCODE
00:CA54 20AC92          	   251:   jsr DISPAD
00:CA57 68              	   252:   pla
00:CA58 852E            	   253:   sta DCODE
00:CA5A 205F8C          	   254:   jsr show_current_line_number
                        	   255: 
00:CA5D A59C            	   256:   lda token_line_start
00:CA5F 8598            	   257:   sta token_work
00:CA61 A59D            	   258:   lda token_line_start+1
00:CA63 8599            	   259:   sta token_work+1
                        	   260: 
                        	   261: token_line_loop:
00:CA65 A000            	   262:   ldy #0
00:CA67 B198            	   263:   lda (token_work),Y
00:CA69 F00F            	   264:   beq token_line_done
00:CA6B 48              	   265:   pha
00:CA6C 201894          	   266:   jsr COUT
00:CA6F E698            	   267:   inc token_work
00:CA71 D002            	   268:   bne token_line_loop1
00:CA73 E699            	   269:   inc token_work+1
                        	   270: token_line_loop1:
00:CA75 68              	   271:   pla
00:CA76 C90A            	   272:   cmp #NL
00:CA78 D0EB            	   273:   bne token_line_loop
                        	   274: 
                        	   275: token_line_done:
00:CA7A 60              	   276:   rts
                        	   277: 
                        	   278: 
                        	   279: ;
                        	   280: ;  atoi
                        	   281: ;
                        	   282: ; get a decimal number - returns carry flag set if bad number and running
                        	   283: ;   (if compiling and a bad number gives an error)
                        	   284: ;
                        	   285: ;  token_start : the start address of the number
                        	   286: ;  Y : offset into token_start
                        	   287: ;  token_sign : non-zero if negative
                        	   288: ;
                        	   289: ;  returns: token_value  and carry clear (if no error)
                        	   290: ;           carry set if error (for use at runtime)
                        	   291: ;           Y at offset of first non-numeric character
                        	   292: 
                        	   293: atoi:
00:CA7B 38              	   294:   sec
00:CA7C E930            	   295:   sbc  #'0'   ;  ; subtract out ASCII stuff, save first digit
00:CA7E 8594            	   296:   sta  token_value
00:CA80 6495            	   297:   stz  token_value+1
00:CA82 6496            	   298:   stz  token_value+2
                        	   299: atoi_loop    =  *
00:CA84 C8              	   300:   iny
00:CA85 B18E            	   301:   lda  (token_start),y
00:CA87 203281          	   302:   jsr  isdigit
00:CA8A B009            	   303:   bcs  atoi_more      ; more digits
                        	   304: ;
                        	   305: ; end of number - make negative if we got a sign earlier
                        	   306: ;
00:CA8C A597            	   307:   lda  token_sign
00:CA8E F003            	   308:   beq  atoi_positive    ; not signed
                        	   309: ;
                        	   310: ;  make negative
                        	   311: ;
00:CA90 20F5CA          	   312:   jsr negate_token_value
                        	   313: ;
                        	   314: ;  done! clear carry and return
                        	   315: ;
                        	   316: atoi_positive:
00:CA93 18              	   317:   clc                   ; indicate no error for numeric conversion
00:CA94 60              	   318:   rts
                        	   319: ;
                        	   320: ;  Multiply previous value by 10, add in new digit
                        	   321: ;
                        	   322: atoi_more    =  *
00:CA95 38              	   323:   sec
00:CA96 E930            	   324:   sbc  #'0'
00:CA98 859B            	   325:   sta  token_digit
00:CA9A 0694            	   326:   asl  token_value         ; multiply token_value by 2
00:CA9C 2695            	   327:   rol  token_value+1
00:CA9E 2696            	   328:   rol  token_value+2
00:CAA0 3048            	   329:   bmi  atoi_error
                        	   330: 
00:CAA2 A594            	   331:   lda  token_value         ; save token_value*2 in token_work
00:CAA4 8598            	   332:   sta  token_work
00:CAA6 A595            	   333:   lda  token_value+1
00:CAA8 8599            	   334:   sta  token_work+1
00:CAAA A596            	   335:   lda  token_value+2
00:CAAC 859A            	   336:   sta  token_work+2
                        	   337: 
00:CAAE 0694            	   338:   asl  token_value         ; now token_value is multiplied by 4
00:CAB0 2695            	   339:   rol  token_value+1
00:CAB2 2696            	   340:   rol  token_value+2
00:CAB4 3034            	   341:   bmi  atoi_error
                        	   342: 
00:CAB6 0694            	   343:   asl  token_value         ; now token_value is multiplied by 8
00:CAB8 2695            	   344:   rol  token_value+1
00:CABA 2696            	   345:   rol  token_value+2
00:CABC 302C            	   346:   bmi  atoi_error
                        	   347: 
00:CABE A598            	   348:   lda  token_work          ; now add back in token_value*2 (giving token_value*10)
00:CAC0 6594            	   349:   adc  token_value
00:CAC2 8594            	   350:   sta  token_value
00:CAC4 A599            	   351:   lda  token_work+1
00:CAC6 6595            	   352:   adc  token_value+1
00:CAC8 8595            	   353:   sta  token_value+1
00:CACA A59A            	   354:   lda  token_work+2
00:CACC 6596            	   355:   adc  token_value+2
00:CACE 8596            	   356:   sta  token_value+2
00:CAD0 3018            	   357:   bmi  atoi_error      ; if negative, the number was too big
00:CAD2 18              	   358:   clc
00:CAD3 A594            	   359:   lda  token_value     ; now take the value and add in our new digit
00:CAD5 659B            	   360:   adc  token_digit
00:CAD7 8594            	   361:   sta  token_value
00:CAD9 A900            	   362:   lda #0
00:CADB 6595            	   363:   adc  token_value+1   ; increment next byte if necessary
00:CADD 8595            	   364:   sta  token_value+1
00:CADF A900            	   365:   lda #0
00:CAE1 6596            	   366:   adc  token_value+2
00:CAE3 8596            	   367:   sta  token_value+2
00:CAE5 3003            	   368:   bmi  atoi_error
00:CAE7 4C84CA          	   369:   jmp  atoi_loop     ; onwards for next digit
                        	   370: 
                        	   371: atoi_error    =  *
00:CAEA A53F            	   372:   lda  RUNNING
00:CAEC 1002            	   373:   bpl  atoi_not_running
00:CAEE 38              	   374:   sec             ; otherwise set carry and return
00:CAEF 60              	   375:   rts
                        	   376: atoi_not_running  =  *
00:CAF0 A21E            	   377:   ldx  #30       ; ERROR: Number out of Range
00:CAF2 4CCD97          	   378:   jmp  ERROR
                        	   379: 
                        	   380: ;
                        	   381: ;  for negative numbers, subtract token_value from zero
                        	   382: ;
                        	   383: negate_token_value:
00:CAF5 38              	   384:   sec
00:CAF6 A900            	   385:   lda  #0
00:CAF8 E594            	   386:   sbc  token_value
00:CAFA 8594            	   387:   sta  token_value
00:CAFC A900            	   388:   lda  #0
00:CAFE E595            	   389:   sbc  token_value+1
00:CB00 8595            	   390:   sta  token_value+1
00:CB02 A900            	   391:   lda  #0
00:CB04 E596            	   392:   sbc  token_value+2
00:CB06 8596            	   393:   sta  token_value+2
00:CB08 60              	   394:   rts
                        	   395: 
                        	   396: 
                        	   397: gtoken_table:
                        	   398:   tknjmpItem '(',gc_lh_paren
00:CB09 28              	     1M    dfb   '('
00:CB0A 51CB            	     2M    word  gc_lh_paren
                        	   399:   tknjmpItem '{',gc_lh_brace
00:CB0C 7B              	     1M    dfb   '{'
00:CB0D 4DCB            	     2M    word  gc_lh_brace
                        	   400:   tknjmpItem '"',gc_quote
00:CB0F 22              	     1M    dfb   '"'
00:CB10 40CC            	     2M    word  gc_quote
                        	   401:   tknjmpItem SINGLE_QUOTE,gc_quote
00:CB12 27              	     1M    dfb   SINGLE_QUOTE
00:CB13 40CC            	     2M    word  gc_quote
                        	   402:   tknjmpItem '$',gc_dollar
00:CB15 24              	     1M    dfb   '$'
00:CB16 0ECD            	     2M    word  gc_dollar
                        	   403:   tknjmpItem '%',gc_percent
00:CB18 25              	     1M    dfb   '%'
00:CB19 68CD            	     2M    word  gc_percent
                        	   404:   tknjmpItem ':',gc_colon
00:CB1B 3A              	     1M    dfb   ':'
00:CB1C 92CD            	     2M    word  gc_colon
                        	   405:   tknjmpItem '<',gc_less_than
00:CB1E 3C              	     1M    dfb   '<'
00:CB1F A3CD            	     2M    word  gc_less_than
                        	   406:   tknjmpItem '>',gc_greater_than
00:CB21 3E              	     1M    dfb   '>'
00:CB22 C6CD            	     2M    word  gc_greater_than
                        	   407:   tknjmpItem '-',gc_minus
00:CB24 2D              	     1M    dfb   '-'
00:CB25 E0CD            	     2M    word  gc_minus
                        	   408:   tknjmpItem '+',gc_plus
00:CB27 2B              	     1M    dfb   '+'
00:CB28 E2CD            	     2M    word  gc_plus
                        	   409:   tknjmpItem '&',gc_ampersand
00:CB2A 26              	     1M    dfb   '&'
00:CB2B 01CE            	     2M    word  gc_ampersand
                        	   410:   tknjmpItem '|',gc_bar
00:CB2D 7C              	     1M    dfb   '|'
00:CB2E 12CE            	     2M    word  gc_bar
                        	   411:   tknjmpItem '=',gc_equals
00:CB30 3D              	     1M    dfb   '='
00:CB31 23CE            	     2M    word  gc_equals
                        	   412:   tknjmpItem '!',gc_bang
00:CB33 21              	     1M    dfb   '!'
00:CB34 34CE            	     2M    word  gc_bang
                        	   413:   tknjmpItem ';',gc_semicolon
00:CB36 3B              	     1M    dfb   ';'
00:CB37 07CC            	     2M    word  gc_semicolon
00:CB39 00              	   414:   dfb        0   ; end of table
                        	   415: 
                        	   416: gtoken_directive_table:
                        	   417:   tknjmpItem 'S',gc_directive_symbols
00:CB3A 53              	     1M    dfb   'S'
00:CB3B B9CB            	     2M    word  gc_directive_symbols
                        	   418:   tknjmpItem 'L',gc_directive_list
00:CB3D 4C              	     1M    dfb   'L'
00:CB3E F1CB            	     2M    word  gc_directive_list
                        	   419:   tknjmpItem 'P',gc_directive_pcodes
00:CB40 50              	     1M    dfb   'P'
00:CB41 F8CB            	     2M    word  gc_directive_pcodes
                        	   420:   tknjmpItem 'N',gc_directive_nolist
00:CB43 4E              	     1M    dfb   'N'
00:CB44 FECB            	     2M    word  gc_directive_nolist
00:CB46 00              	   421:   dfb        0
                        	   422: 
                        	   423: ; single byte token, in A
00:CB47 4CD0C9          	   424: gc_single_byte_tokenJ jmp gc_single_byte_token
                        	   425: ; single byte token in token_type
00:CB4A 4CCEC9          	   426: gc_single_byte_already_knownJ jmp gc_single_byte_already_known
                        	   427: 
                        	   428: gc_lh_brace:
00:CB4D A000            	   429:   ldy #0
00:CB4F 800E            	   430:   bra gc_pascal_comment
                        	   431: gc_lh_paren:
00:CB51 A902            	   432:   lda #FLAG_ASSEMBLING
00:CB53 25BE            	   433:   and system_flags
00:CB55 D0F3            	   434:   bne gc_single_byte_already_knownJ
00:CB57 A001            	   435:   ldy #1
00:CB59 B18E            	   436:   lda (token_start),Y
00:CB5B C92A            	   437:   cmp #'*'      ; was it: (* ?
00:CB5D D0EB            	   438:   bne gc_single_byte_already_knownJ  ; nope
                        	   439: 
                        	   440: ;
                        	   441: ;  Y will be 0 or 1 depending on the sort of starting comment
                        	   442: ;  first look for % which indicates a compiler directive
                        	   443: ;
                        	   444: gc_pascal_comment:
00:CB5F C8              	   445:   iny
00:CB60 B18E            	   446:   lda (token_start),Y
00:CB62 C925            	   447:   cmp #'%'   ; directive?
00:CB64 D018            	   448:   bne gc_pascal_comment_find_end
00:CB66 C8              	   449:   iny
00:CB67 B18E            	   450:   lda (token_start),Y ; get the directive: S, L, P or N
00:CB69 48              	   451:   pha   ; save the directive for now
00:CB6A 98              	   452:   tya
                        	   453: ;
                        	   454: ;  make token_start point to where we are up to, so we can skip the comment, even if it is long
                        	   455: ;
00:CB6B 38              	   456:   sec               ; I actually want to be one past where the directive letter is
00:CB6C 658E            	   457:   adc token_start
00:CB6E 858E            	   458:   sta token_start
00:CB70 A900            	   459:   lda #0
00:CB72 658F            	   460:   adc token_start+1
00:CB74 858F            	   461:   sta token_start+1
00:CB76 68              	   462:   pla   ; get the directive back
00:CB77 A23A            	   463:   ldx #<gtoken_directive_table
00:CB79 A0CB            	   464:   ldy #>gtoken_directive_table
00:CB7B 20FB8F          	   465:   jsr TKNJMP  ; do the directive handler
                        	   466: ;
                        	   467: ;  fall through if not found and just find the end of the comment
                        	   468: ;
                        	   469: 
                        	   470: gc_pascal_comment_find_end:
00:CB7E A000            	   471:   ldy #0    ; we normalised token_start to be where we want to start
00:CB80 B18E            	   472:   lda (token_start),Y
00:CB82 D005            	   473:   bne gc_comment_not_eof
00:CB84 A207            	   474:   ldx  #7           ; NO } FOUND
00:CB86 4CCD97          	   475:   jmp  ERROR
                        	   476: gc_comment_not_eof:
00:CB89 C90A            	   477:   cmp #NL
00:CB8B D005            	   478:   bne gc_comment_not_newline
00:CB8D 202CCA          	   479:   jsr token_line    ; handle the newline (we can't be assembling or we wouldn't be here)
00:CB90 800F            	   480:   bra gc_comment_keep_looking
                        	   481: gc_comment_not_newline:
00:CB92 C97D            	   482:   cmp #'}'
00:CB94 F013            	   483:   beq gc_comment_found_end
00:CB96 C92A            	   484:   cmp #'*'
00:CB98 D007            	   485:   bne gc_comment_keep_looking
00:CB9A C8              	   486:   iny
00:CB9B B18E            	   487:   lda (token_start),Y
00:CB9D C929            	   488:   cmp #')'
00:CB9F F008            	   489:   beq gc_comment_found_end
                        	   490: 
                        	   491: ;
                        	   492: ;  skip this byte and keep looking for the end of comment
                        	   493: ;
                        	   494: gc_comment_keep_looking:
00:CBA1 E68E            	   495:   inc token_start
00:CBA3 D0D9            	   496:   bne gc_pascal_comment_find_end
00:CBA5 E68F            	   497:   inc token_start+1
00:CBA7 80D5            	   498:   bra gc_pascal_comment_find_end
                        	   499: 
                        	   500: ;
                        	   501: ;  found end of comment, so move token_start to this character
                        	   502: ;   (the one past the end of the comment) and try again for a token
                        	   503: ;
                        	   504: gc_comment_found_end:
00:CBA9 C8              	   505:   iny   ; get past end of comment
00:CBAA 98              	   506:   tya
00:CBAB 18              	   507:   clc
00:CBAC 658E            	   508:   adc token_start
00:CBAE 858E            	   509:   sta token_start
00:CBB0 A900            	   510:   lda #0
00:CBB2 658F            	   511:   adc token_start+1
00:CBB4 858F            	   512:   sta token_start+1
00:CBB6 4C90C9          	   513:   jmp get_token_loop
                        	   514: 
                        	   515: ;
                        	   516: ;  {%S $nnnn}
                        	   517: ;  symbol table relocation
                        	   518: ;
                        	   519: gc_directive_symbols:
00:CBB9 2090C9          	   520:    jsr  get_token_loop     ; re-call get_token to find the address
00:CBBC C94E            	   521:    cmp  #TOKEN_NUMBER ; number?
00:CBBE F005            	   522:    beq  gc_directive_symbols_ok      ; yes
00:CBC0 A202            	   523:    ldx  #2
00:CBC2 4CCD97          	   524:    jmp  ERROR      ; 'Constant expected'
                        	   525: 
                        	   526: gc_directive_symbols_ok:
                        	   527:   ;
                        	   528:   ;  check we haven't generated any code
                        	   529:   ;
00:CBC5 A523            	   530:   lda PCODE
00:CBC7 C525            	   531:   cmp ACT_PCDA
00:CBC9 D021            	   532:   bne gc_directive_symbols_too_late
00:CBCB A524            	   533:   lda PCODE+1
00:CBCD C526            	   534:   cmp ACT_PCDA+1
00:CBCF D01B            	   535:   bne gc_directive_symbols_too_late
                        	   536: 
00:CBD1 A594            	   537:   lda  token_value
00:CBD3 8531            	   538:   sta  ENDSYM
00:CBD5 852F            	   539:   sta  STARTSYM
00:CBD7 852B            	   540:   sta  OPND
00:CBD9 A595            	   541:   lda  token_value+1
00:CBDB 8532            	   542:   sta  ENDSYM+1        ; store symbol table address
00:CBDD 8530            	   543:   sta  STARTSYM+1
00:CBDF 852C            	   544:   sta  OPND+1
00:CBE1 A901            	   545:   lda  #PCODE_STACK    ; change runtime stack
00:CBE3 20E9C7          	   546:   jsr  GENJMP
                        	   547: ;
                        	   548: ;  put the library functions back
                        	   549: ;
00:CBE6 20B6C6          	   550:   jsr  add_pascal_library_functions
                        	   551: 
00:CBE9 4C7ECB          	   552:   jmp  gc_pascal_comment_find_end     ; go back and find the end of the comment
                        	   553: ;
                        	   554: 
                        	   555: gc_directive_symbols_too_late:
00:CBEC A233            	   556:   ldx #51        ; code already generated
00:CBEE 4CCD97          	   557:   JMP  ERROR
                        	   558: 
                        	   559: 
                        	   560: ;
                        	   561: ;  {%L} - list source
                        	   562: ;
                        	   563: gc_directive_list:
00:CBF1 A904            	   564:   lda #FLAG_LIST_SOURCE
00:CBF3 04BE            	   565:   tsb system_flags
00:CBF5 4C7ECB          	   566:   jmp gc_pascal_comment_find_end
                        	   567: 
                        	   568: ;
                        	   569: ;  {%P} - list source and P-codes
                        	   570: ;
                        	   571: gc_directive_pcodes:
00:CBF8 A901            	   572:   lda #1
00:CBFA 852E            	   573:   sta DCODE
00:CBFC 80F3            	   574:   bra gc_directive_list   ; also list source
                        	   575: ;
                        	   576: ;  {%N} - do not list source or P-codes
                        	   577: ;
                        	   578: gc_directive_nolist:
00:CBFE A904            	   579:   lda #FLAG_LIST_SOURCE
00:CC00 14BE            	   580:   trb system_flags    ; clear both of the above flags
00:CC02 642E            	   581:   stz DCODE
00:CC04 4C7ECB          	   582:   jmp gc_pascal_comment_find_end
                        	   583: 
                        	   584: ;
                        	   585: ;  semicolons start comments in the assembler
                        	   586: ;
                        	   587: gc_semicolon:
00:CC07 A902            	   588:   lda #FLAG_ASSEMBLING
00:CC09 25BE            	   589:   and system_flags
00:CC0B D003            	   590:   bne gc_assembler_comment_find_end
00:CC0D 4CCEC9          	   591:   jmp gc_single_byte_already_known
                        	   592: 
                        	   593: gc_assembler_comment_find_end:
00:CC10 A000            	   594:   ldy #0
00:CC12 B18E            	   595:   lda (token_start),Y
00:CC14 D005            	   596:   bne gc_assembler_comment_not_eof
00:CC16 A90A            	   597:   lda #NL
00:CC18 8593            	   598:   sta token_type
00:CC1A 60              	   599:   rts     ; exit without incrementing token_start
                        	   600: 
                        	   601: gc_assembler_comment_not_eof:
00:CC1B C90A            	   602:   cmp #NL
00:CC1D D003            	   603:   bne gc_assembler_comment_keep_looking
00:CC1F 4CD0C9          	   604:   jmp gc_single_byte_token
                        	   605: ;
                        	   606: ;  skip this byte and keep looking for the newline at the end of comment
                        	   607: ;
                        	   608: gc_assembler_comment_keep_looking:
00:CC22 E68E            	   609:   inc token_start
00:CC24 D0EA            	   610:   bne gc_assembler_comment_find_end
00:CC26 E68F            	   611:   inc token_start+1
00:CC28 80E6            	   612:   bra gc_assembler_comment_find_end
                        	   613: 
                        	   614: 
                        	   615: gc_backslash_tokens:
00:CC2A 41              	   616:          DFB  'A',$07  ; bell ($07)
00:CC2B 07
00:CC2C 42              	   617:          DFB  'B',$08  ; backspace ($08)
00:CC2D 08
00:CC2E 45              	   618:          DFB  'E',$1B  ; escape  (0x1B)
00:CC2F 1B
00:CC30 46              	   619:          DFB  'F',$0C  ; formfeed ($0C)
00:CC31 0C
00:CC32 4E              	   620:          DFB  'N',$0A  ; newline  (0x0A)
00:CC33 0A
00:CC34 52              	   621:          DFB  'R',$0D  ; carriage return (0x0D)
00:CC35 0D
00:CC36 54              	   622:          DFB  'T',$09  ; horizontal tab (0x09)
00:CC37 09
00:CC38 56              	   623:          DFB  'V',$0B  ; vertical tab (0x0B)
00:CC39 0B
00:CC3A 5C              	   624:          DFB  $5C,$5C  ; backslash
00:CC3B 5C
00:CC3C 22              	   625:          DFB  '"','"'  ; double quote
00:CC3D 22
00:CC3E 27              	   626:          DFB  SINGLE_QUOTE,SINGLE_QUOTE  ; single quote
00:CC3F 27
                        	   627: gc_backslash_tokens_end = *
                        	   628: gc_backslash_tokens_length = gc_backslash_tokens_end - gc_backslash_tokens
                        	   629: 
                        	   630: ;
                        	   631: ;  quoted string
                        	   632: ;
                        	   633: ;  resolve double quotes and backslash sequences and store it in INBUF
                        	   634: ;
                        	   635: ;
                        	   636: gc_quote:
00:CC40 8598            	   637:   sta token_work    ; remember which sort
00:CC42 A000            	   638:   ldy #0            ; back to the start
00:CC44 6492            	   639:   stz token_length  ; zero-length string so far
00:CC46 A58E            	   640:   lda token_start
00:CC48 8590            	   641:   sta token_address   ; save the starting address of the token (not that it matters too much)
00:CC4A A58F            	   642:   lda token_start+1   ; repeat for high-order byte
00:CC4C 8591            	   643:   sta token_address+1
                        	   644: 
                        	   645: gc_quote_loop:
00:CC4E C8              	   646:   iny                 ; onto next character
00:CC4F B18E            	   647:   lda (token_start),Y ; get the next character in the string
00:CC51 F004            	   648:   beq gc_quote_bad
00:CC53 C90A            	   649:   cmp  #NL
00:CC55 D005            	   650:   bne  gc_quote_loop_not_end_of_line
                        	   651: 
                        	   652: gc_quote_bad:
00:CC57 A208            	   653:   ldx  #8         ; MISSING QUOTE: Incorrect string
00:CC59 4CCD97          	   654:   jmp  ERROR
                        	   655: 
                        	   656: gc_quote_loop_not_end_of_line:
00:CC5C C598            	   657:   cmp  token_work  ; same as start quote?
00:CC5E D037            	   658:   bne  gc_quote_not_finished       ; no
00:CC60 C8              	   659:   iny
00:CC61 B18E            	   660:   lda (token_start),Y ; see if another quote follows
00:CC63 C598            	   661:   cmp  token_work
00:CC65 F05A            	   662:   beq  gc_quote_not_backslash      ; embedded quote (ie. two quotes in a row)? Store a single quote symbol
                        	   663:   ;
                        	   664:   ;  here at end of quoted string
                        	   665:   ;
00:CC67 8498            	   666:   sty  token_work  ; remember how far through our input we are
00:CC69 A003            	   667:   ldy  #3          ; OK, we have the final quote, so is the string <= 3 characters long?
00:CC6B C492            	   668:   cpy  token_length
00:CC6D 9002            	   669:   bcc  gc_quote_long_string   ; BLT - no
00:CC6F A492            	   670:   ldy  token_length           ; yes - load its actual length into Y (ie. 0, 1, 2, 3)
                        	   671: gc_quote_long_string:
00:CC71 88              	   672:   dey      ; zero-relative
00:CC72 3008            	   673:   bmi  gc_quote_copied_value   ; keep going into the length done
00:CC74 B90002          	   674:   lda  INBUF,Y   ; store the (up to) 3 bytes into VALUE as the token value
00:CC77 999400          	   675:   sta  token_value,Y
00:CC7A D0F5            	   676:   bne  gc_quote_long_string   ; keep going until we hit the 0x00 at the end
                        	   677: 
                        	   678: gc_quote_copied_value:
00:CC7C A592            	   679:   lda  token_length    ; now see how long it is?
00:CC7E D005            	   680:   bne  gc_quote_done     ; don't allow zero length strings
00:CC80 A20E            	   681:   ldx  #14        ; BAD STRING: literal string of zero length
00:CC82 4CCD97          	   682:   jmp  ERROR
                        	   683: 
                        	   684: gc_quote_done:
00:CC85 18              	   685:   clc
00:CC86 A58E            	   686:   lda token_start       ; bump up our token_start address to past the quoted string
00:CC88 6598            	   687:   adc token_work        ; now add its (actual) length, not the length afer mucking around
00:CC8A 858E            	   688:   sta token_start       ; that gives the ending address
00:CC8C A58F            	   689:   lda token_start+1   ; repeat for high-order byte
00:CC8E 6900            	   690:   adc #0
00:CC90 858F            	   691:   sta token_start+1
00:CC92 A922            	   692:   lda  #TOKEN_STRING   ; it's a string token
00:CC94 8593            	   693:   sta  token_type
00:CC96 60              	   694:   rts
                        	   695: 
                        	   696: 
                        	   697: gc_quote_not_finished:
00:CC97 C95C            	   698:   cmp #$5C    ; backslash?
00:CC99 D026            	   699:   bne  gc_quote_not_backslash
                        	   700: ;
                        	   701: ;  backslash - see what follows
                        	   702: ;
00:CC9B C8              	   703:   iny
00:CC9C B18E            	   704:   lda (token_start),Y ; the character after the backslash
00:CC9E F0B7            	   705:   beq gc_quote_bad    ; nothing? bad
00:CCA0 202D90          	   706:   jsr MAKE_UPPER
00:CCA3 C958            	   707:   cmp #'X'
00:CCA5 F038            	   708:   beq gc_quote_hex_character
00:CCA7 A200            	   709:   ldx #0
                        	   710: gc_quote_backslash_loop:
00:CCA9 DD2ACC          	   711:   cmp gc_backslash_tokens,X
00:CCAC F00F            	   712:   beq gc_quote_found_backslash_character   ; good match
00:CCAE E8              	   713:   inx
00:CCAF E8              	   714:   inx
00:CCB0 E016            	   715:   cpx #gc_backslash_tokens_length
00:CCB2 90F5            	   716:   bcc gc_quote_backslash_loop
                        	   717: gc_quote_bad_string:
00:CCB4 A208            	   718:   ldx #8
00:CCB6 4CCD97          	   719:   jmp ERROR   ; ERROR: Incorrect string
                        	   720: 
                        	   721: gc_quote_hex_character_done:
00:CCB9 A594            	   722:   lda token_value
00:CCBB 8004            	   723:   bra gc_quote_not_backslash
                        	   724: 
                        	   725: gc_quote_found_backslash_character:
00:CCBD E8              	   726:   inx
00:CCBE BD2ACC          	   727:   lda gc_backslash_tokens,X  ; get its replacement
                        	   728: 
                        	   729: gc_quote_not_backslash:
00:CCC1 A692            	   730:   ldx  token_length
00:CCC3 9D0002          	   731:   sta  INBUF,x           ; store it in INBUF
00:CCC6 E692            	   732:   inc  token_length
00:CCC8 F003            	   733:   beq  gc_quote_too_long
00:CCCA 4C4ECC          	   734:   jmp  gc_quote_loop     ; keep adding to string
                        	   735: 
                        	   736: 
                        	   737: gc_quote_too_long:
                        	   738:   ;            string over 255 characters long - error!
00:CCCD A21D            	   739:   ldx   #29  ; ERROR: string literal too big
00:CCCF 4CCD97          	   740:   jmp  ERROR
                        	   741: 
                        	   742: ;
                        	   743: ;  "fix" a hex digit by making it upper-case, then subtracting 7 if it is A-F
                        	   744: ;   then subtracting '0' so we get a number in the range 0x00 to 0x0F in A
                        	   745: ;
                        	   746: gc_fix_hex:
00:CCD2 202D90          	   747:   jsr  MAKE_UPPER
00:CCD5 C941            	   748:   cmp  #'A'
00:CCD7 9002            	   749:   bcc  gc_fix_hex_not_a_to_f
00:CCD9 E907            	   750:   sbc  #7
                        	   751: gc_fix_hex_not_a_to_f:
00:CCDB 38              	   752:   sec
00:CCDC E930            	   753:   sbc  #'0'
00:CCDE 60              	   754:   rts
                        	   755: 
                        	   756: gc_quote_hex_character:
00:CCDF C8              	   757:   iny
00:CCE0 F0EB            	   758:   beq  gc_quote_too_long
00:CCE2 B18E            	   759:   lda  (token_start),Y ; the character after the backslash
00:CCE4 203E81          	   760:   jsr  isxdigit
00:CCE7 90CB            	   761:   bcc  gc_quote_bad_string  ; what? should be hex
00:CCE9 20D2CC          	   762:   jsr  gc_fix_hex
00:CCEC 8594            	   763:   sta  token_value  ; first nibble
00:CCEE C8              	   764:   iny
00:CCEF F0DC            	   765:   beq  gc_quote_too_long
00:CCF1 B18E            	   766:   lda  (token_start),Y ; a second hex character?
00:CCF3 F0BF            	   767:   beq  gc_quote_bad_string
00:CCF5 203E81          	   768:   jsr  isxdigit
00:CCF8 9011            	   769:   bcc  gc_quote_hex_character_one_only
00:CCFA 20D2CC          	   770:   jsr  gc_fix_hex
00:CCFD 0694            	   771:   asl  token_value    ; shift existing value 4 bits left
00:CCFF 0694            	   772:   asl  token_value
00:CD01 0694            	   773:   asl  token_value
00:CD03 0694            	   774:   asl  token_value
00:CD05 0594            	   775:   ora  token_value
00:CD07 8594            	   776:   sta  token_value
00:CD09 80AE            	   777:   bra  gc_quote_hex_character_done
                        	   778: 
                        	   779: gc_quote_hex_character_one_only:
00:CD0B 88              	   780:   dey         ; undo add since we didn't find another hex character
00:CD0C 80AB            	   781:   bra gc_quote_hex_character_done
                        	   782: 
                        	   783: ;
                        	   784: ;  $nnnnnn where nnnnnn is one or more hex digits
                        	   785: ;    if no hex digits, then it is the token '$'
                        	   786: ;
                        	   787: gc_dollar:
00:CD0E A001            	   788:   ldy  #1    ; start with the character after the dollar
00:CD10 B18E            	   789:   lda  (token_start),Y ; followed by a hex character?
00:CD12 203E81          	   790:   jsr  isxdigit
00:CD15 B003            	   791:   bcs  gc_hex_literal
00:CD17 4CCEC9          	   792:   jmp  gc_single_byte_already_known
                        	   793: 
                        	   794: gc_hex_literal:
00:CD1A 20D2CC          	   795:   jsr gc_fix_hex
00:CD1D 8594            	   796:   sta token_value       ; store the first digit
00:CD1F 6495            	   797:   stz token_value+1
00:CD21 6496            	   798:   stz token_value+2
                        	   799: gc_hex_loop:
00:CD23 C8              	   800:   iny
00:CD24 B18E            	   801:   lda (token_start),Y ; followed by another hex character?
00:CD26 203E81          	   802:   jsr isxdigit
00:CD29 9033            	   803:   bcc gc_hex_done
00:CD2B 20D2CC          	   804:   jsr gc_fix_hex
                        	   805: ;
                        	   806: ;  shift the existing value left 4 bits to make room for the new nibble
                        	   807: ;
00:CD2E 0694            	   808:   asl  token_value        ; token_value shifted left 1 bit
00:CD30 2695            	   809:   rol  token_value+1
00:CD32 2696            	   810:   rol  token_value+2
00:CD34 B02D            	   811:   bcs  gc_hex_too_big
00:CD36 0694            	   812:   asl  token_value        ; token_value shifted left 2 bits
00:CD38 2695            	   813:   rol  token_value+1
00:CD3A 2696            	   814:   rol  token_value+2
00:CD3C B025            	   815:   bcs  gc_hex_too_big
00:CD3E 0694            	   816:   asl  token_value        ; token_value shifted left 3 bits
00:CD40 2695            	   817:   rol  token_value+1
00:CD42 2696            	   818:   rol  token_value+2
00:CD44 B01D            	   819:   bcs  gc_hex_too_big
00:CD46 0694            	   820:   asl  token_value        ; token_value shifted left 4 bits
00:CD48 2695            	   821:   rol  token_value+1
00:CD4A 2696            	   822:   rol  token_value+2
00:CD4C B015            	   823:   bcs  gc_hex_too_big
00:CD4E 6594            	   824:   adc  token_value        ; now add in this last digit (carry will be clear)
00:CD50 8594            	   825:   sta  token_value        ; store the new result
00:CD52 90CF            	   826:   bcc  gc_hex_loop
00:CD54 E695            	   827:   inc  token_value+1
00:CD56 90CB            	   828:   bcc  gc_hex_loop
00:CD58 E695            	   829:   inc  token_value+1
00:CD5A B007            	   830:   bcs  gc_hex_too_big
00:CD5C 80C5            	   831:   bra  gc_hex_loop
                        	   832: 
                        	   833: gc_hex_done:
00:CD5E A94E            	   834:   lda #TOKEN_NUMBER
00:CD60 4CD2C9          	   835:   jmp gc_done
                        	   836: 
                        	   837: gc_hex_too_big:
00:CD63 A21E            	   838:   ldx  #30       ; ERROR: Number out of Range
00:CD65 4CCD97          	   839:   jmp  ERROR
                        	   840: 
                        	   841: ;
                        	   842: ;  %nnnnnn where nnnnnn is one or more binary digits
                        	   843: ;    if no binary digits, then it is the token '%'
                        	   844: ;
                        	   845: 
                        	   846: gc_percent:
00:CD68 A001            	   847:   ldy  #1    ; start with the character after the %
00:CD6A B18E            	   848:   lda  (token_start),Y ; followed by a binary character?
00:CD6C 206E81          	   849:   jsr  isbinary
00:CD6F B003            	   850:   bcs  gc_binary_literal
00:CD71 4CCEC9          	   851:   jmp  gc_single_byte_already_known
                        	   852: 
                        	   853: gc_binary_literal:
00:CD74 E930            	   854:   sbc #'0'              ; we know carry is set
00:CD76 8594            	   855:   sta token_value       ; store the first digit
00:CD78 6495            	   856:   stz token_value+1
00:CD7A 6496            	   857:   stz token_value+2
                        	   858: gc_binary_loop:
00:CD7C C8              	   859:   iny
00:CD7D B18E            	   860:   lda (token_start),Y ; followed by another binary character?
00:CD7F 206E81          	   861:   jsr isbinary
00:CD82 90DA            	   862:   bcc gc_hex_done
00:CD84 E930            	   863:   sbc #'0'              ; we know carry is set
                        	   864: 
00:CD86 6A              	   865:   ror A   ; get the new bit into Carry
00:CD87 2694            	   866:   rol token_value
00:CD89 2695            	   867:   rol token_value+1
00:CD8B 2696            	   868:   rol token_value+2
00:CD8D 90ED            	   869:   bcc gc_binary_loop
00:CD8F 4C63CD          	   870:   jmp gc_hex_too_big   ; number too large
                        	   871: 
                        	   872: ;
                        	   873: ;  token : might be :=
                        	   874: ;
                        	   875: gc_colon:
00:CD92 A001            	   876:   ldy  #1               ; get the next character
00:CD94 B18E            	   877:   lda  (token_start),Y  ; followed by = ?
00:CD96 C93D            	   878:   cmp  #'='
00:CD98 F003            	   879:   beq  gc_assign
00:CD9A 4CCEC9          	   880:   jmp  gc_single_byte_already_known
                        	   881: 
                        	   882: gc_assign:
00:CD9D A941            	   883:   lda #TOKEN_ASSIGN
00:CD9F C8              	   884:   iny
00:CDA0 4CD2C9          	   885:   jmp gc_done
                        	   886: 
                        	   887: ;
                        	   888: ;  token: < might be <=, <>, <<
                        	   889: ;
                        	   890: gc_less_than:
00:CDA3 A001            	   891:   ldy  #1               ; get the next character
00:CDA5 B18E            	   892:   lda  (token_start),Y  ; followed by = ?
00:CDA7 C8              	   893:   iny                   ; make it a 2-byte token
00:CDA8 C93D            	   894:   cmp  #'='
00:CDAA F00B            	   895:   beq  gc_leq
00:CDAC C93E            	   896:   cmp  #'>'
00:CDAE F00C            	   897:   beq  gc_neq
00:CDB0 C93C            	   898:   cmp  #'<'
00:CDB2 F00D            	   899:   beq  gc_shift_left
00:CDB4 4CCEC9          	   900:   jmp  gc_single_byte_already_known
                        	   901: 
                        	   902: gc_leq:
00:CDB7 A980            	   903:   lda #TOKEN_LEQ
00:CDB9 4CD2C9          	   904:   jmp gc_done
                        	   905: 
                        	   906: gc_neq:
00:CDBC A955            	   907:   lda #TOKEN_NEQ
00:CDBE 4CD2C9          	   908:   jmp gc_done
                        	   909: 
                        	   910: gc_shift_left:
00:CDC1 A94C            	   911:   lda #TOKEN_SHIFT_LEFT
00:CDC3 4CD2C9          	   912:   jmp gc_done
                        	   913: 
                        	   914: ;
                        	   915: ;  token: > might be <>=, >>
                        	   916: ;
                        	   917: gc_greater_than:
00:CDC6 A001            	   918:   ldy  #1               ; get the next character
00:CDC8 B18E            	   919:   lda  (token_start),Y  ; followed by = ?
00:CDCA C8              	   920:   iny                   ; make it a 2-byte token
00:CDCB C93D            	   921:   cmp  #'='
00:CDCD F007            	   922:   beq  gc_geq
00:CDCF C93E            	   923:   cmp  #'>'
00:CDD1 F008            	   924:   beq  gc_shift_right
                        	   925: 
                        	   926: gc_single_byte_already_knownJ2:
00:CDD3 4CCEC9          	   927:   jmp  gc_single_byte_already_known
                        	   928: 
                        	   929: gc_geq:
00:CDD6 A981            	   930:   lda #TOKEN_GEQ
00:CDD8 4CD2C9          	   931:   jmp gc_done
                        	   932: 
                        	   933: gc_shift_right:
00:CDDB A952            	   934:   lda #TOKEN_SHIFT_RIGHT
00:CDDD 4CD2C9          	   935:   jmp gc_done
                        	   936: 
                        	   937: 
                        	   938: ;
                        	   939: ;  minus and plus sign
                        	   940: ;
                        	   941: 
                        	   942: gc_minus:
00:CDE0 8597            	   943:   sta token_sign
                        	   944: gc_plus:
                        	   945: 
                        	   946: ;
                        	   947: ;  new stuff - treat a sign as a token on its own if the previous token was one of:
                        	   948: ;    a) a number
                        	   949: ;    b) an identifier
                        	   950: ;    c) a RH bracket
                        	   951: ;
                        	   952: ;  So, for example: 2+3 is three tokens, but 2+-5 is also three, as the -5 becomes one token
                        	   953: ;
00:CDE2 A598            	   954:   lda  token_work            ; saved previous token on entry to get_token
00:CDE4 C94E            	   955:   cmp  #TOKEN_NUMBER
00:CDE6 F0EB            	   956:   beq  gc_single_byte_already_knownJ2
00:CDE8 C949            	   957:   cmp  #TOKEN_IDENTIFIER
00:CDEA F0E7            	   958:   beq  gc_single_byte_already_knownJ2
00:CDEC C929            	   959:   cmp  #')'
00:CDEE F0E3            	   960:   beq  gc_single_byte_already_knownJ2
                        	   961: ;
                        	   962: ;  if not, see if this is a signed number (ie. it is directly followed by a digit)
                        	   963: ;
00:CDF0 A001            	   964:   ldy  #1               ; get the next character
00:CDF2 B18E            	   965:   lda  (token_start),Y  ; followed by a digit?
00:CDF4 203281          	   966:   jsr  isdigit
00:CDF7 90DA            	   967:   bcc  gc_single_byte_already_knownJ2
00:CDF9 207BCA          	   968:   jsr atoi
00:CDFC A94E            	   969:   lda  #TOKEN_NUMBER
00:CDFE 4CD2C9          	   970:   jmp  gc_done
                        	   971: 
                        	   972: 
                        	   973: ;
                        	   974: ;  token: & might be &&
                        	   975: ;
                        	   976: gc_ampersand:
00:CE01 A001            	   977:   ldy  #1               ; get the next character
00:CE03 B18E            	   978:   lda  (token_start),Y  ; followed by & ?
00:CE05 C926            	   979:   cmp  #'&'
00:CE07 F003            	   980:   beq  gc_logical_and
00:CE09 4CCEC9          	   981:   jmp  gc_single_byte_already_known
                        	   982: 
                        	   983: gc_logical_and:
00:CE0C A958            	   984:   lda #TOKEN_LOGICAL_AND
00:CE0E C8              	   985:   iny
00:CE0F 4CD2C9          	   986:   jmp gc_done
                        	   987: 
                        	   988: ;
                        	   989: ;  token: | might be ||
                        	   990: ;
                        	   991: gc_bar:
00:CE12 A001            	   992:   ldy  #1               ; get the next character
00:CE14 B18E            	   993:   lda  (token_start),Y  ; followed by | ?
00:CE16 C97C            	   994:   cmp  #'|'
00:CE18 F003            	   995:   beq  gc_logical_or
00:CE1A 4CCEC9          	   996:   jmp  gc_single_byte_already_known
                        	   997: 
                        	   998: gc_logical_or:
00:CE1D A959            	   999:   lda #TOKEN_LOGICAL_OR
00:CE1F C8              	  1000:   iny
00:CE20 4CD2C9          	  1001:   jmp gc_done
                        	  1002: 
                        	  1003: ;
                        	  1004: ;  token: = might be ==
                        	  1005: ;
                        	  1006: gc_equals:
00:CE23 A001            	  1007:   ldy  #1               ; get the next character
00:CE25 B18E            	  1008:   lda  (token_start),Y  ; followed by = ?
00:CE27 C93D            	  1009:   cmp  #'='
00:CE29 F003            	  1010:   beq  gc_equality
00:CE2B 4CCEC9          	  1011:   jmp  gc_single_byte_already_known
                        	  1012: 
                        	  1013: gc_equality:
00:CE2E A945            	  1014:   lda #TOKEN_EQUALITY
00:CE30 C8              	  1015:   iny
00:CE31 4CD2C9          	  1016:   jmp gc_done
                        	  1017: 
                        	  1018: ;
                        	  1019: ;  token: ! might be !=
                        	  1020: ;
                        	  1021: gc_bang:
00:CE34 A001            	  1022:   ldy  #1               ; get the next character
00:CE36 B18E            	  1023:   lda  (token_start),Y  ; followed by = ?
00:CE38 C93D            	  1024:   cmp  #'='
00:CE3A F003            	  1025:   beq  gc_inequality
00:CE3C 4CCEC9          	  1026:   jmp  gc_single_byte_already_known
                        	  1027: 
                        	  1028: gc_inequality:
00:CE3F A95A            	  1029:   lda #TOKEN_INEQUALITY
00:CE41 C8              	  1030:   iny
00:CE42 4CD2C9          	  1031:   jmp gc_done
                        	  1032: 
                        	  1033: 
                        	  1034: 
                        	  1035: ; Pascal tokens
                        	  1036: 
                        	  1037: TOKEN_CONST     = $82
                        	  1038: TOKEN_VAR       = $83
                        	  1039: TOKEN_ARRAY     = $84
                        	  1040: TOKEN_OF        = $85
                        	  1041: TOKEN_PROCEDURE = $86
                        	  1042: TOKEN_FUNCTION  = $87
                        	  1043: TOKEN_BEGIN     = $88
                        	  1044: TOKEN_END       = $89
                        	  1045: TOKEN_OR        = $8A
                        	  1046: TOKEN_DIV       = $8B
                        	  1047: TOKEN_MOD       = $8C
                        	  1048: TOKEN_AND       = $8D
                        	  1049: TOKEN_SHL       = $8E
                        	  1050: TOKEN_SHR       = $8F
                        	  1051: TOKEN_NOT       = $90
                        	  1052: TOKEN_MEM       = $91
                        	  1053: TOKEN_IF        = $92
                        	  1054: TOKEN_THEN      = $93
                        	  1055: TOKEN_ELSE      = $94
                        	  1056: TOKEN_CASE      = $95
                        	  1057: TOKEN_WHILE     = $96
                        	  1058: TOKEN_DO        = $97
                        	  1059: TOKEN_REPEAT    = $98
                        	  1060: TOKEN_UNTIL     = $99
                        	  1061: TOKEN_FOR       = $9A
                        	  1062: TOKEN_TO        = $9B
                        	  1063: TOKEN_DOWNTO    = $9C
                        	  1064: TOKEN_WRITE     = $9D
                        	  1065: TOKEN_READ      = $9E
                        	  1066: TOKEN_CALL      = $9F
                        	  1067: TOKEN_CHAR      = $A1
                        	  1068: TOKEN_MEMC      = $A2
                        	  1069: TOKEN_XOR       = $A4
                        	  1070: TOKEN_ADDRESS   = $A9
                        	  1071: TOKEN_CHR       = $AB
                        	  1072: TOKEN_HEX       = $AC
                        	  1073: ; $B0 to $DE used by message tokens
                        	  1074: TOKEN_LCDWRITE  = $F1
                        	  1075: TOKEN_INTEGER   = $FE
                        	  1076: TOKEN_WRITELN   = $FF
                        	  1077: 
                        	  1078: 
                        	  1079: 
                        	  1080: ; RESERVED WORD TABLE
                        	  1081: ;
                        	  1082: ;***********************************************
                        	  1083:          .macro makeToken  ; MACRO DEFINITION FOR TOKENS: Length, token number, token name
                        	  1084:          DFB  \1
                        	  1085:          DFB  \2
                        	  1086:          text  \3
                        	  1087:          .endmacro           ; END OF MACRO
                        	  1088: 
                        	  1089: ;
                        	  1090: ; Reserved words are identified internally by their code (eg. $86 for PROCEDURE)
                        	  1091: ;
                        	  1092: ;  They are also stored "tokenised" and expanded out when you list the source
                        	  1093: ;
                        	  1094: ; Other tokens are:
                        	  1095: ;  * Punctuation (eg. "<", ">", "=", ".", "(", ")", "$", "+", "-"
                        	  1096: ;  * Identifiers: "I"        (eg. MY_VARIABLE)
                        	  1097: ;  * Constant numbers: "N"   (eg. -1234 and $1234)
                        	  1098: ;  * Literal strings:  '"' (quote symbol)  (eg. "Nick")
                        	  1099: ;  * Double-character punctuation:
                        	  1100: ;       <= : $80
                        	  1101: ;       >= : $81
                        	  1102: ;       Unequal (<>) : "U"
                        	  1103: ;       Assignment (:=) : "A"
                        	  1104: ;
                        	  1105: ; Comments are skipped: (* some comment *)
                        	  1106: ;
                        	  1107: ;
                        	  1108: ; However comments can have compiler directives embedded, eg. (*%A $4000) - put P-codes at $4000
                        	  1109: ;    (*%L*) - list during compile
                        	  1110: ;    (*%N*) - stop listing during compile (cancels %L and %P)
                        	  1111: ;    (*%P*) - show P-codes during compile
                        	  1112: ;    (*%A  $nnnn *) - put P-codes at address $nnnn - must be at START of program
                        	  1113: ;
                        	  1114: ;
                        	  1115: 
                        	  1116: ;              Length   Code             Name
                        	  1117: ;                  --   --------------- ---------------
                        	  1118: RSVWRD   =  *
                        	  1119:    makeToken   5, TOKEN_CONST     ,"CONST"
00:CE45 05              	     1M          DFB  5
00:CE46 82              	     2M          DFB  TOKEN_CONST     
00:CE47 434F4E5354      	     3M          text  "CONST"
                        	  1120:    makeToken   3, TOKEN_VAR       ,"VAR"
00:CE4C 03              	     1M          DFB  3
00:CE4D 83              	     2M          DFB  TOKEN_VAR       
00:CE4E 564152          	     3M          text  "VAR"
                        	  1121:    makeToken   5, TOKEN_ARRAY     ,"ARRAY"
00:CE51 05              	     1M          DFB  5
00:CE52 84              	     2M          DFB  TOKEN_ARRAY     
00:CE53 4152524159      	     3M          text  "ARRAY"
                        	  1122:    makeToken   2, TOKEN_OF        ,"OF"
00:CE58 02              	     1M          DFB  2
00:CE59 85              	     2M          DFB  TOKEN_OF        
00:CE5A 4F46            	     3M          text  "OF"
                        	  1123:    makeToken   9, TOKEN_PROCEDURE ,"PROCEDURE"
00:CE5C 09              	     1M          DFB  9
00:CE5D 86              	     2M          DFB  TOKEN_PROCEDURE 
00:CE5E 50524F4345445552	     3M          text  "PROCEDURE"
00:CE66 45
                        	  1124:    makeToken   8, TOKEN_FUNCTION  ,"FUNCTION"
00:CE67 08              	     1M          DFB  8
00:CE68 87              	     2M          DFB  TOKEN_FUNCTION  
00:CE69 46554E4354494F4E	     3M          text  "FUNCTION"
                        	  1125:    makeToken   5, TOKEN_BEGIN     ,"BEGIN"
00:CE71 05              	     1M          DFB  5
00:CE72 88              	     2M          DFB  TOKEN_BEGIN     
00:CE73 424547494E      	     3M          text  "BEGIN"
                        	  1126:    makeToken   3, TOKEN_END       ,"END"
00:CE78 03              	     1M          DFB  3
00:CE79 89              	     2M          DFB  TOKEN_END       
00:CE7A 454E44          	     3M          text  "END"
                        	  1127:    makeToken   2, TOKEN_OR        ,"OR"
00:CE7D 02              	     1M          DFB  2
00:CE7E 8A              	     2M          DFB  TOKEN_OR        
00:CE7F 4F52            	     3M          text  "OR"
                        	  1128:    makeToken   3, TOKEN_DIV       ,"DIV"
00:CE81 03              	     1M          DFB  3
00:CE82 8B              	     2M          DFB  TOKEN_DIV       
00:CE83 444956          	     3M          text  "DIV"
                        	  1129:    makeToken   3, TOKEN_MOD       ,"MOD"
00:CE86 03              	     1M          DFB  3
00:CE87 8C              	     2M          DFB  TOKEN_MOD       
00:CE88 4D4F44          	     3M          text  "MOD"
                        	  1130:    makeToken   3, TOKEN_AND       ,"AND"
00:CE8B 03              	     1M          DFB  3
00:CE8C 8D              	     2M          DFB  TOKEN_AND       
00:CE8D 414E44          	     3M          text  "AND"
                        	  1131:    makeToken   3, TOKEN_SHL       ,"SHL"
00:CE90 03              	     1M          DFB  3
00:CE91 8E              	     2M          DFB  TOKEN_SHL       
00:CE92 53484C          	     3M          text  "SHL"
                        	  1132:    makeToken   3, TOKEN_SHR       ,"SHR"
00:CE95 03              	     1M          DFB  3
00:CE96 8F              	     2M          DFB  TOKEN_SHR       
00:CE97 534852          	     3M          text  "SHR"
                        	  1133:    makeToken   3, TOKEN_NOT       ,"NOT"
00:CE9A 03              	     1M          DFB  3
00:CE9B 90              	     2M          DFB  TOKEN_NOT       
00:CE9C 4E4F54          	     3M          text  "NOT"
                        	  1134:    makeToken   3, TOKEN_MEM       ,"MEM"
00:CE9F 03              	     1M          DFB  3
00:CEA0 91              	     2M          DFB  TOKEN_MEM       
00:CEA1 4D454D          	     3M          text  "MEM"
                        	  1135:    makeToken   2, TOKEN_IF        ,"IF"
00:CEA4 02              	     1M          DFB  2
00:CEA5 92              	     2M          DFB  TOKEN_IF        
00:CEA6 4946            	     3M          text  "IF"
                        	  1136:    makeToken   4, TOKEN_THEN      ,"THEN"
00:CEA8 04              	     1M          DFB  4
00:CEA9 93              	     2M          DFB  TOKEN_THEN      
00:CEAA 5448454E        	     3M          text  "THEN"
                        	  1137:    makeToken   4, TOKEN_ELSE      ,"ELSE"
00:CEAE 04              	     1M          DFB  4
00:CEAF 94              	     2M          DFB  TOKEN_ELSE      
00:CEB0 454C5345        	     3M          text  "ELSE"
                        	  1138:    makeToken   4, TOKEN_CASE      ,"CASE"
00:CEB4 04              	     1M          DFB  4
00:CEB5 95              	     2M          DFB  TOKEN_CASE      
00:CEB6 43415345        	     3M          text  "CASE"
                        	  1139:    makeToken   5, TOKEN_WHILE     ,"WHILE"
00:CEBA 05              	     1M          DFB  5
00:CEBB 96              	     2M          DFB  TOKEN_WHILE     
00:CEBC 5748494C45      	     3M          text  "WHILE"
                        	  1140:    makeToken   2, TOKEN_DO        ,"DO"
00:CEC1 02              	     1M          DFB  2
00:CEC2 97              	     2M          DFB  TOKEN_DO        
00:CEC3 444F            	     3M          text  "DO"
                        	  1141:    makeToken   6, TOKEN_REPEAT    ,"REPEAT"
00:CEC5 06              	     1M          DFB  6
00:CEC6 98              	     2M          DFB  TOKEN_REPEAT    
00:CEC7 524550454154    	     3M          text  "REPEAT"
                        	  1142:    makeToken   5, TOKEN_UNTIL     ,"UNTIL"
00:CECD 05              	     1M          DFB  5
00:CECE 99              	     2M          DFB  TOKEN_UNTIL     
00:CECF 554E54494C      	     3M          text  "UNTIL"
                        	  1143:    makeToken   3, TOKEN_FOR       ,"FOR"
00:CED4 03              	     1M          DFB  3
00:CED5 9A              	     2M          DFB  TOKEN_FOR       
00:CED6 464F52          	     3M          text  "FOR"
                        	  1144:    makeToken   2, TOKEN_TO        ,"TO"
00:CED9 02              	     1M          DFB  2
00:CEDA 9B              	     2M          DFB  TOKEN_TO        
00:CEDB 544F            	     3M          text  "TO"
                        	  1145:    makeToken   6, TOKEN_DOWNTO    ,"DOWNTO"
00:CEDD 06              	     1M          DFB  6
00:CEDE 9C              	     2M          DFB  TOKEN_DOWNTO    
00:CEDF 444F574E544F    	     3M          text  "DOWNTO"
                        	  1146:    makeToken   5, TOKEN_WRITE     ,"WRITE"
00:CEE5 05              	     1M          DFB  5
00:CEE6 9D              	     2M          DFB  TOKEN_WRITE     
00:CEE7 5752495445      	     3M          text  "WRITE"
                        	  1147:    makeToken   4, TOKEN_READ      ,"READ"
00:CEEC 04              	     1M          DFB  4
00:CEED 9E              	     2M          DFB  TOKEN_READ      
00:CEEE 52454144        	     3M          text  "READ"
                        	  1148:    makeToken   4, TOKEN_CALL      ,"CALL"
00:CEF2 04              	     1M          DFB  4
00:CEF3 9F              	     2M          DFB  TOKEN_CALL      
00:CEF4 43414C4C        	     3M          text  "CALL"
                        	  1149:    makeToken   4, TOKEN_CHAR      ,"CHAR"
00:CEF8 04              	     1M          DFB  4
00:CEF9 A1              	     2M          DFB  TOKEN_CHAR      
00:CEFA 43484152        	     3M          text  "CHAR"
                        	  1150:    makeToken   4, TOKEN_MEMC      ,"MEMC"
00:CEFE 04              	     1M          DFB  4
00:CEFF A2              	     2M          DFB  TOKEN_MEMC      
00:CF00 4D454D43        	     3M          text  "MEMC"
                        	  1151:    makeToken   3, TOKEN_XOR       ,"XOR"
00:CF04 03              	     1M          DFB  3
00:CF05 A4              	     2M          DFB  TOKEN_XOR       
00:CF06 584F52          	     3M          text  "XOR"
                        	  1152:    makeToken   7, TOKEN_ADDRESS   ,"ADDRESS"
00:CF09 07              	     1M          DFB  7
00:CF0A A9              	     2M          DFB  TOKEN_ADDRESS   
00:CF0B 41444452455353  	     3M          text  "ADDRESS"
                        	  1153:    makeToken   3, TOKEN_CHR       ,"CHR"
00:CF12 03              	     1M          DFB  3
00:CF13 AB              	     2M          DFB  TOKEN_CHR       
00:CF14 434852          	     3M          text  "CHR"
                        	  1154:    makeToken   3, TOKEN_HEX       ,"HEX"
00:CF17 03              	     1M          DFB  3
00:CF18 AC              	     2M          DFB  TOKEN_HEX       
00:CF19 484558          	     3M          text  "HEX"
                        	  1155:    makeToken   7, TOKEN_INTEGER   ,"INTEGER"
00:CF1C 07              	     1M          DFB  7
00:CF1D FE              	     2M          DFB  TOKEN_INTEGER   
00:CF1E 494E5445474552  	     3M          text  "INTEGER"
                        	  1156:    makeToken   7, TOKEN_WRITELN   ,"WRITELN"
00:CF25 07              	     1M          DFB  7
00:CF26 FF              	     2M          DFB  TOKEN_WRITELN   
00:CF27 57524954454C4E  	     3M          text  "WRITELN"
                        	  1157:    makeToken   8, TOKEN_LCDWRITE  ,"LCDWRITE"
00:CF2E 08              	     1M          DFB  8
00:CF2F F1              	     2M          DFB  TOKEN_LCDWRITE  
00:CF30 4C43445752495445	     3M          text  "LCDWRITE"
                        	  1158: 
                        	  1159: 
00:CF38 00              	  1160: RSVEND   DFB  0,0        ; END OF TABLE
00:CF39 00
                        	  1161: ;
                        	  1162: 
                        	  1163: ;
                        	  1164: ;  Pascal get_token
                        	  1165: ;
                        	  1166: ;  Used in the Pascal section. Does a get_token, and then if an identifier is found tries to look
                        	  1167: ;  it up.
                        	  1168: ;
                        	  1169: pas_get_token:
00:CF3A 208CC9          	  1170:   jsr get_token
00:CF3D F004            	  1171:   beq pas_get_token_eof   ; branch to make sure Z flag stays set
00:CF3F C949            	  1172:   cmp #TOKEN_IDENTIFIER
00:CF41 F001            	  1173:   beq pas_gc_identifier
                        	  1174: pas_get_token_eof:
00:CF43 60              	  1175:   rts
                        	  1176: ;
                        	  1177: ;  here if get_token got an identifier
                        	  1178: ;
                        	  1179: pas_gc_identifier:
00:CF44 A945            	  1180:   lda  #<RSVWRD
00:CF46 8598            	  1181:   sta  token_work
00:CF48 A9CE            	  1182:   lda  #>RSVWRD
00:CF4A 8599            	  1183:   sta  token_work+1
                        	  1184: pas_gc_loop:
00:CF4C A000            	  1185:   ldy  #0
00:CF4E B198            	  1186:   lda  (token_work),Y
00:CF50 D003            	  1187:   bne  pas_gc_more        ; MORE TO GO
00:CF52 A949            	  1188:   lda  #TOKEN_IDENTIFIER
00:CF54 60              	  1189:   rts
                        	  1190: ;
                        	  1191: ; SEARCH for RESERVED WORD
                        	  1192: ;
                        	  1193: pas_gc_more:
00:CF55 B198            	  1194:   lda  (token_work),Y     ; length of word in table
00:CF57 C592            	  1195:   cmp  token_length       ; same?
00:CF59 D022            	  1196:   bne  pas_gc_no_match    ; no - can't be it then
00:CF5B A8              	  1197:   tay                     ; length
00:CF5C A590            	  1198:   lda  token_address      ; put token start address into SRCE
00:CF5E 8500            	  1199:   sta  SRCE
00:CF60 A591            	  1200:   lda  token_address+1
00:CF62 8501            	  1201:   sta  SRCE+1
00:CF64 A598            	  1202:   lda  token_work         ; put current token_work+2 into DEST
00:CF66 18              	  1203:   clc
00:CF67 6902            	  1204:   adc  #2
00:CF69 8503            	  1205:   sta  DEST
00:CF6B A599            	  1206:   lda  token_work+1
00:CF6D 6900            	  1207:   adc  #0
00:CF6F 8504            	  1208:   sta  DEST+1
00:CF71 200182          	  1209:   jsr  str_ic_compare
00:CF74 D007            	  1210:   bne  pas_gc_no_match      ; NOT FOUND
00:CF76 A001            	  1211:   ldy  #1
00:CF78 B198            	  1212:   lda  (token_work),Y
00:CF7A 8593            	  1213:   sta  token_type
00:CF7C 60              	  1214:   rts
                        	  1215: pas_gc_no_match    =  *
00:CF7D A000            	  1216:   ldy  #0
00:CF7F B198            	  1217:   lda  (token_work),Y     ; token_work points to reserved word entry
00:CF81 18              	  1218:   clc
00:CF82 6902            	  1219:   adc  #2         ; add 2 to bypass length and code
00:CF84 6598            	  1220:   adc  token_work
00:CF86 8598            	  1221:   sta  token_work         ; put it back
00:CF88 90C2            	  1222:   bcc  pas_gc_loop
00:CF8A E699            	  1223:   inc  token_work+1       ; handle overflow
00:CF8C 80BE            	  1224:   bra  pas_gc_loop     ; try for another
                        	  1225: 
                        	  1226: 
                        	  1227: 
                        	  1228: ;***********************************************
                        	  1229: ; GET A TOKEN - CHECK THAT IT
                        	  1230: ; IS THE SAME AS IN "A", IF NOT
                        	  1231: ; CALL ERROR "X"
                        	  1232: ;***********************************************
                        	  1233: GETCHK:
00:CF8E DA              	  1234:   phx   ; save error number
00:CF8F 48              	  1235:   pha   ; save wanted token type
00:CF90 203ACF          	  1236:   jsr pas_get_token
00:CF93 68              	  1237:   pla   ; get it back
00:CF94 C593            	  1238:   cmp token_type
00:CF96 F004            	  1239:   beq CHKOK
00:CF98 FA              	  1240:   plx   ; get error number back
                        	  1241: CHKNOK   =  *
00:CF99 4CCD97          	  1242:   jmp ERROR
                        	  1243: CHKOK    =  *
00:CF9C FA              	  1244:   plx   ; get error number back
00:CF9D 60              	  1245:   rts
                        	  1246: 
                        	  1247: ;***********************************************
                        	  1248: ; CHECK TOKEN AGREES WITH "A",
                        	  1249: ; IF NOT, GIVE ERROR "X"
                        	  1250: ;***********************************************
                        	  1251: CHKTKN:
00:CF9E C593            	  1252:   cmp  token_type
00:CFA0 D0F7            	  1253:   bne  CHKNOK
00:CFA2 60              	  1254:   rts
                        	  1255: 
                        	  1256: ;***********************************************
                        	  1257: ;
                        	  1258: ; GET NEXT TOKEN - MUST BE IDENTIFIER
                        	  1259: ; THEN LOOK IT UP IN SYMBOL TABLE
                        	  1260: ;***********************************************
                        	  1261: 
                        	  1262: GET_LOOK:
00:CFA3 A949            	  1263:   lda  #TOKEN_IDENTIFIER
00:CFA5 A204            	  1264:   ldx  #4      ; ERROR: Identifier expected
00:CFA7 208ECF          	  1265:   jsr  GETCHK
00:CFAA 4C2ABA          	  1266:   jmp  LOOKUP
                        	  1267: 

Source: "gpascal.asm"
                        	   187:   .include "i2c.inc"

Source: "i2c.inc"
                        	     1: ;
                        	     2: ;  I2C interface routines
                        	     3: ;
                        	     4: ; Author: Nick Gammon
                        	     5: ; Date: 2 March 2022
                        	     6: 
                        	     7: ; PROTOCOL
                        	     8: ;
                        	     9: ;  BUS NOT BUSY: Both data and clock lines remain HIGH.
                        	    10: ;
                        	    11: ;  START DATA TRANSFER: A change in the state of the data line, from HIGH to LOW, while the clock is
                        	    12: ;  HIGH, defines a START condition.
                        	    13: ;
                        	    14: ;  STOP DATA TRANSFER: A change in the state of the data line, from LOW to HIGH, while the clock line
                        	    15: ;  is HIGH, defines the STOP condition.
                        	    16: ;
                        	    17: ;  DATA VALID: The state of the data line represents valid data when, after a START condition, the data
                        	    18: ;  line is stable for the duration of the HIGH period of the clock signal. The data on the line must be
                        	    19: ;  changed during the LOW period of the clock signal. There is one clock pulse per bit of data.
                        	    20: ;  Each data transfer is initiated with a START co ndition and terminated with a STOP condition. The
                        	    21: ;  number of data bytes transferred between START and STOP conditions is not limited, and is
                        	    22: ;  determined by the master device. The information is transferred byte-wise and each receiver
                        	    23: ;  acknowledges with a ninth bit.
                        	    24: ;
                        	    25: ;  CLOCK STRETCHING
                        	    26: ;
                        	    27: ;  If a slave wants us to wait, or another master is attempting to take over the bus, SCL will not go
                        	    28: ;  high immediately after we set it to input (high impedance) so we therefore wait until SCL is in
                        	    29: ;  fact high before proceeding.
                        	    30: ;
                        	    31: ;  ARBITRATION
                        	    32: ;
                        	    33: ;  If two masters are attempting to write to the bus we can detect that as soon as one of them writes
                        	    34: ;  a one, but reads back a zero. This indicates that another master wrote the zero. The master that
                        	    35: ;  read back the one then abandons its attempt to write (to try again later).
                        	    36: ;
                        	    37: ;  Since, up to this point, both have read back what they wrote, the bus is not corrupted.
                        	    38: ;
                        	    39: 
                        	    40: 
                        	    41: ; Configuration of which VIA ports are used by SCL and SDA
                        	    42: 
                        	    43: I2C_SCL     = %00000100   ; SCL (serial clock) - PA2
                        	    44: I2C_SDA     = %00001000   ; SDA (serial data)  - PA3
                        	    45: 
                        	    46: I2C_PORT    = VIA_PORTA   ; PORT A
                        	    47: I2C_DDR     = VIA_DDRA    ; DDR  A
                        	    48: 
                        	    49: ;
                        	    50: ;  Initialise hardware for I2C comms.
                        	    51: ;
                        	    52: ;  Set SCL and SDA to high, however make the ports input for now
                        	    53: ;
                        	    54: i2c_init:
                        	    55: 
                        	    56: ;
                        	    57: ;  Set ports to low
                        	    58: ;
00:CFAD A90C            	    59:   lda #I2C_SCL | I2C_SDA
00:CFAF 1CF17F          	    60:   trb I2C_PORT
                        	    61: 
                        	    62: ;
                        	    63: ;  Set ports to input
                        	    64: ;
                        	    65: 
00:CFB2 A90C            	    66:   lda #I2C_SCL | I2C_SDA
00:CFB4 1CF37F          	    67:   trb I2C_DDR
                        	    68: 
                        	    69: 
00:CFB7 60              	    70:   rts
                        	    71: 
                        	    72: ;---------------------------------------------
                        	    73: ;  delay between clock bits - could make shorter if using a 1 MHz clock
                        	    74: ;---------------------------------------------
                        	    75: i2c_delay:
00:CFB8 EA              	    76:     nop
00:CFB9 EA              	    77:     nop
00:CFBA EA              	    78:     nop
00:CFBB 60              	    79:     rts
                        	    80: 
                        	    81: ;---------------------------------------------
                        	    82: ;  toggle the SCL line from low to high and back again
                        	    83: ;---------------------------------------------
                        	    84: i2c_toggle_clock:
00:CFBC A904            	    85:   lda #I2C_SCL
00:CFBE 1CF37F          	    86:   trb I2C_DDR      ; SCL high
00:CFC1 20B8CF          	    87:   jsr i2c_delay
                        	    88: ;
                        	    89: ;  check if the slave wants us to wait by pulling the clock low
                        	    90: ;
                        	    91: i2c_toggle_clock_wait:
00:CFC4 ADF17F          	    92:   lda I2C_PORT
00:CFC7 2904            	    93:   and #I2C_SCL
00:CFC9 F0F9            	    94:   beq i2c_toggle_clock_wait   ; should be high, but is low
                        	    95: ;
                        	    96: ;  we let the clock go high, and it actually IS high, so we can proceed
                        	    97: ;
00:CFCB 0CF37F          	    98:   tsb I2C_DDR       ; SCL low
00:CFCE A908            	    99:   lda #I2C_SDA      ; immediately set SDA to low
00:CFD0 1CF37F          	   100:   trb I2C_DDR
00:CFD3 20B8CF          	   101:   jsr i2c_delay
00:CFD6 60              	   102:   rts
                        	   103: 
                        	   104: ;---------------------------------------------
                        	   105: ;
                        	   106: ;  Begin transmission: send a start condition
                        	   107: ;
                        	   108: ;  Slave address in A, read/write bit in low-order bit
                        	   109: ;    0 = write, 1 = read
                        	   110: ;
                        	   111: ;  Sets carry if OK
                        	   112: ;
                        	   113: ;  START CONDITION:
                        	   114: ;
                        	   115: ;  A change in the state of the data line, from HIGH to LOW, while the clock is HIGH
                        	   116: ;---------------------------------------------
                        	   117: 
                        	   118: i2c_begin_transmission:
                        	   119: 
00:CFD7 48              	   120:   pha             ; save address
                        	   121: 
00:CFD8 20ADCF          	   122:   jsr i2c_init    ; set ports to low, and ports to input
                        	   123: 
                        	   124: ;
                        	   125: ;  Check if SDA or SCL are in use (low) - if so, wait until they are not
                        	   126: ;
                        	   127: i2c_begin_transmission_loop:
00:CFDB A908            	   128:   lda #I2C_SDA
00:CFDD 2DF17F          	   129:   and I2C_PORT
00:CFE0 F0F9            	   130:   beq i2c_begin_transmission_loop
00:CFE2 A904            	   131:   lda #I2C_SCL
00:CFE4 2DF17F          	   132:   and I2C_PORT
00:CFE7 F0F2            	   133:   beq i2c_begin_transmission_loop
                        	   134: 
                        	   135: ;
                        	   136: ;  The start condition pulls SDA low but SCL stays high
                        	   137: ;
                        	   138: 
00:CFE9 A908            	   139:   lda #I2C_SDA
00:CFEB 0CF37F          	   140:   tsb I2C_DDR
00:CFEE 20B8CF          	   141:   jsr i2c_delay
                        	   142: 
                        	   143: ;
                        	   144: ;  But now we pull SCL low ready for clocking out bits
                        	   145: ;
                        	   146: 
00:CFF1 A904            	   147:   lda #I2C_SCL
00:CFF3 0CF37F          	   148:   tsb I2C_DDR
00:CFF6 20B8CF          	   149:   jsr i2c_delay
                        	   150: 
00:CFF9 68              	   151:   pla   ; get address back
                        	   152: 
00:CFFA 20FECF          	   153:   jsr i2c_write
                        	   154: 
00:CFFD 60              	   155:   rts
                        	   156: 
                        	   157: ;---------------------------------------------
                        	   158: ;
                        	   159: ;  I2C write: send 8 data bits, wait for acknowledge
                        	   160: ;
                        	   161: ;---------------------------------------------
                        	   162: 
                        	   163: i2c_write:
00:CFFE A208            	   164:   ldx #8  ; count of bits
00:D000 A8              	   165:   tay
                        	   166: 
                        	   167: i2c_write_loop:
00:D001 98              	   168:   tya
00:D002 2A              	   169:   rol a   ; get bit to write into carry
00:D003 A8              	   170:   tay
                        	   171: 
00:D004 B007            	   172:   bcs i2c_write_one
                        	   173: ;
                        	   174: ;  write a zero by setting SDA to output
                        	   175: ;
00:D006 A908            	   176:   lda #I2C_SDA
00:D008 0CF37F          	   177:   tsb I2C_DDR
00:D00B 800B            	   178:   bra i2c_write_clock
                        	   179: ;
                        	   180: ;  write a one by setting SDA to input
                        	   181: ;
                        	   182: i2c_write_one:
00:D00D A908            	   183:   lda #I2C_SDA
00:D00F 1CF37F          	   184:   trb I2C_DDR
                        	   185: ;
                        	   186: ;  if SDA is not high, another master has taken control of the bus, abandon this write
                        	   187: ;
00:D012 EA              	   188:   nop
00:D013 2DF17F          	   189:   and I2C_PORT
00:D016 F028            	   190:   beq i2c_write_lost_arbitration   ; error return, give up
                        	   191: 
                        	   192: ;---------------------------------------------
                        	   193: ;
                        	   194: ;  toggle clock
                        	   195: ;
                        	   196: ;---------------------------------------------
                        	   197: i2c_write_clock:
00:D018 20BCCF          	   198:   jsr i2c_toggle_clock
                        	   199: ;
                        	   200: ;  back for another bit?
                        	   201: ;
00:D01B CA              	   202:   dex
00:D01C D0E3            	   203:   bne i2c_write_loop
                        	   204: 
                        	   205:   ;---------------------------------------------
                        	   206:   ;  wait for acknowledge bit
                        	   207:   ;---------------------------------------------
                        	   208: 
                        	   209:   ;
                        	   210:   ;  make SDA input and see if it is pulled low
                        	   211:   ;
                        	   212: 
00:D01E A908            	   213:   lda #I2C_SDA
00:D020 1CF37F          	   214:   trb I2C_DDR         ; SDA to input
                        	   215: 
00:D023 A904            	   216:   lda #I2C_SCL        ; clock high
00:D025 1CF37F          	   217:   trb I2C_DDR
                        	   218: 
                        	   219: ;
                        	   220: ;  check if the slave wants us to wait by pulling the clock low
                        	   221: ;
                        	   222: i2c_write_clock_wait:
00:D028 ADF17F          	   223:   lda I2C_PORT
00:D02B 2904            	   224:   and #I2C_SCL
00:D02D F0F9            	   225:   beq i2c_write_clock_wait   ; should be high, but is low
                        	   226: 
00:D02F 20B8CF          	   227:   jsr i2c_delay       ; give it time to respond
                        	   228: 
00:D032 A908            	   229:   lda #I2C_SDA
00:D034 2DF17F          	   230:   and I2C_PORT        ; read SDA
                        	   231: 
00:D037 AA              	   232:   tax                 ; save result for a moment
00:D038 A904            	   233:   lda #I2C_SCL        ; clock low
00:D03A 0CF37F          	   234:   tsb I2C_DDR
                        	   235: 
00:D03D 8A              	   236:   txa             ; get ack/nak bit back
                        	   237: 
00:D03E F002            	   238:   beq i2c_write_got_ack
                        	   239: 
                        	   240: i2c_write_lost_arbitration:
00:D040 18              	   241:   clc   ; error return
00:D041 60              	   242:   rts
                        	   243: 
                        	   244: i2c_write_got_ack:
00:D042 38              	   245:   sec   ; carry means OK
00:D043 60              	   246:   rts
                        	   247: 
                        	   248: 
                        	   249: ;---------------------------------------------
                        	   250: ;
                        	   251: ;  I2C read: receive 8 data bits, then acknowledge unless hardware_work is zero
                        	   252: ;    hardware_work will be the count of outstanding bytes to be sent
                        	   253: ;    on the last bit we NAK it to tell the sender not to send any more
                        	   254: ;
                        	   255: ;---------------------------------------------
                        	   256: 
                        	   257: i2c_read:
00:D044 A208            	   258:   ldx #8  ; count of bits
00:D046 A000            	   259:   ldy #0  ; current result
                        	   260: 
00:D048 A908            	   261:   lda #I2C_SDA
00:D04A 1CF37F          	   262:   trb I2C_DDR         ; SDA to input
                        	   263: 
                        	   264: i2c_read_loop:
                        	   265: 
00:D04D A904            	   266:   lda #I2C_SCL        ; clock high
00:D04F 1CF37F          	   267:   trb I2C_DDR
00:D052 20B8CF          	   268:   jsr i2c_delay       ; give it time to respond
                        	   269: 
00:D055 A908            	   270:   lda #I2C_SDA
00:D057 2DF17F          	   271:   and I2C_PORT        ; read SDA
00:D05A F006            	   272:   beq i2c_read_zero
                        	   273: ;
                        	   274: ;  read a 1
                        	   275: ;
00:D05C 98              	   276:   tya       ; get previous result
00:D05D 38              	   277:   sec
00:D05E 2A              	   278:   rol a     ; rotate in a one-bit
00:D05F A8              	   279:   tay       ; keep for later
00:D060 8004            	   280:   bra i2c_read_next
                        	   281: 
                        	   282: ;
                        	   283: ;  read a 0
                        	   284: ;
                        	   285: i2c_read_zero:
00:D062 98              	   286:   tya       ; get previous result
00:D063 18              	   287:   clc
00:D064 2A              	   288:   rol a     ; rotate in a zero-bit
00:D065 A8              	   289:   tay       ; keep for later
                        	   290: 
                        	   291: i2c_read_next:
                        	   292: 
00:D066 A904            	   293:   lda #I2C_SCL        ; clock low
00:D068 0CF37F          	   294:   tsb I2C_DDR
00:D06B 20B8CF          	   295:   jsr i2c_delay       ; give it time to respond
                        	   296: 
                        	   297: ;
                        	   298: ;  back for another bit?
                        	   299: ;
00:D06E CA              	   300:   dex
00:D06F D0DC            	   301:   bne i2c_read_loop
                        	   302: 
00:D071 A58C            	   303:   lda hardware_work   ; NAK on last read so they stop sending
00:D073 F007            	   304:   beq i2c_read_nak
                        	   305: 
00:D075 A908            	   306:   lda #I2C_SDA
00:D077 0CF37F          	   307:   tsb I2C_DDR         ; pull SDA low to ACK the byte
00:D07A 8005            	   308:   bra i2c_read_ack_or_nak
                        	   309: 
                        	   310: i2c_read_nak:
00:D07C A908            	   311:   lda #I2C_SDA
00:D07E 1CF37F          	   312:   trb I2C_DDR         ; pull SDA high to NAK the final byte
                        	   313: 
                        	   314: i2c_read_ack_or_nak:
                        	   315: 
00:D081 A904            	   316:   lda #I2C_SCL        ; clock high
00:D083 1CF37F          	   317:   trb I2C_DDR
                        	   318: 
                        	   319: ;
                        	   320: ;  check if the slave wants us to wait by pulling the clock low
                        	   321: ;   (clock stretching)
                        	   322: ;
                        	   323: 
                        	   324: i2c_read_ack_or_nak_wait:
00:D086 ADF17F          	   325:   lda I2C_PORT
00:D089 2904            	   326:   and #I2C_SCL
00:D08B F0F9            	   327:   beq i2c_read_ack_or_nak_wait   ; should be high, but is low
                        	   328: 
00:D08D 20B8CF          	   329:   jsr i2c_delay       ; give it time to respond
                        	   330: 
00:D090 A904            	   331:   lda #I2C_SCL        ; clock low
00:D092 0CF37F          	   332:   tsb I2C_DDR
00:D095 20B8CF          	   333:   jsr i2c_delay
                        	   334: 
                        	   335: i2c_read_done:
                        	   336: 
00:D098 98              	   337:   tya                 ; result in A
00:D099 60              	   338:   rts
                        	   339: 
                        	   340: 
                        	   341: ;---------------------------------------------
                        	   342: ;  end transmission - send stop condition
                        	   343: ;
                        	   344: ;  STOP CONDITION:
                        	   345: ;
                        	   346: ;  A change in the state of the data line, from LOW to HIGH, while the clock is HIGH
                        	   347: ;---------------------------------------------
                        	   348: 
                        	   349: i2c_end_transmission:
                        	   350: 
                        	   351: ;
                        	   352: ;  make sure SDA is low, otherwise it can't transition low to high
                        	   353: ;
00:D09A A908            	   354:   lda #I2C_SDA
00:D09C 0CF37F          	   355:   tsb I2C_DDR
                        	   356: 
00:D09F 20B8CF          	   357:   jsr i2c_delay
                        	   358: 
                        	   359: ;
                        	   360: ;  Set SCL to input so it floats high
                        	   361: ;
00:D0A2 A904            	   362:   lda #I2C_SCL
00:D0A4 1CF37F          	   363:   trb I2C_DDR
                        	   364: 
00:D0A7 20B8CF          	   365:   jsr i2c_delay
                        	   366: 
                        	   367: ;
                        	   368: ;  Now with SCL high, set SDA to input so it also floats high
                        	   369: ;
00:D0AA A908            	   370:   lda #I2C_SDA
00:D0AC 1CF37F          	   371:   trb I2C_DDR
                        	   372: 
00:D0AF 20B8CF          	   373:   jsr i2c_delay
                        	   374: 
                        	   375: ;
                        	   376: ;  Both SDA and SCL are now high (by the pull-up resistors) so we are done
                        	   377: ;
00:D0B2 60              	   378:   rts
                        	   379: 
                        	   380: ;---------------------------------------------
                        	   381: ;
                        	   382: ;  Send a message, address in A (excluding write bit)
                        	   383: ;  Message in (VALUE)
                        	   384: ;  Length in Y
                        	   385: ;  Returns carry set on success, carry clear on failure
                        	   386: ;
                        	   387: ;---------------------------------------------
                        	   388: i2c_send_message:
00:D0B3 848C            	   389:   sty hardware_work
00:D0B5 0A              	   390:   asl A     ; move zero into write bit
00:D0B6 20D7CF          	   391:   jsr i2c_begin_transmission
00:D0B9 901C            	   392:   bcc i2c_send_message_fail
                        	   393: 
                        	   394: ;
                        	   395: ;  send each byte
                        	   396: ;
                        	   397: i2c_send_message_loop:
00:D0BB A58C            	   398:   lda hardware_work           ; number of bytes to go
00:D0BD F013            	   399:   beq i2c_send_message_done
00:D0BF C68C            	   400:   dec hardware_work
00:D0C1 A000            	   401:   ldy #0
00:D0C3 B100            	   402:   lda (VALUE),Y
00:D0C5 20FECF          	   403:   jsr i2c_write
00:D0C8 900D            	   404:   bcc i2c_send_message_fail
00:D0CA E600            	   405:   inc VALUE
00:D0CC D0ED            	   406:   bne i2c_send_message_loop
00:D0CE E601            	   407:   inc VALUE+1
00:D0D0 80E9            	   408:   bra i2c_send_message_loop
                        	   409: ;
                        	   410: ;  sending done
                        	   411: ;
                        	   412: i2c_send_message_done:
00:D0D2 209AD0          	   413:   jsr i2c_end_transmission
00:D0D5 38              	   414:   sec
00:D0D6 60              	   415:   rts
                        	   416: ;
                        	   417: ;  sending failure
                        	   418: ;
                        	   419: i2c_send_message_fail:
00:D0D7 209AD0          	   420:   jsr i2c_end_transmission
00:D0DA 18              	   421:   clc
00:D0DB 60              	   422:   rts
                        	   423: 
                        	   424: ;---------------------------------------------
                        	   425: ;
                        	   426: ;  Receive messave, slave address in A (excluding write bit)
                        	   427: ;  Message in (VALUE)
                        	   428: ;  Length in Y
                        	   429: ;---------------------------------------------
                        	   430: 
                        	   431: i2c_receive_message:
00:D0DC 848C            	   432:   sty hardware_work
00:D0DE 38              	   433:   sec
00:D0DF 2A              	   434:   rol A   ; move one into write bit (so it is read mode)
00:D0E0 20D7CF          	   435:   jsr i2c_begin_transmission
00:D0E3 901F            	   436:   bcc i2c_receive_message_fail
                        	   437: 
                        	   438: ;
                        	   439: ;  put serial data (SDA) into input mode so we can read from it
                        	   440: ;
00:D0E5 A908            	   441:   lda #I2C_SDA
00:D0E7 1CF37F          	   442:   trb I2C_DDR
                        	   443: 
                        	   444: ;
                        	   445: ;  receive each byte
                        	   446: ;
                        	   447: i2c_receive_message_loop:
00:D0EA A58C            	   448:   lda hardware_work           ; number of bytes to go
00:D0EC F011            	   449:   beq i2c_receive_message_done
00:D0EE C68C            	   450:   dec hardware_work
00:D0F0 2044D0          	   451:   jsr i2c_read
00:D0F3 A000            	   452:   ldy #0
00:D0F5 9100            	   453:   sta (VALUE),Y
00:D0F7 E600            	   454:   inc VALUE
00:D0F9 D0EF            	   455:   bne i2c_receive_message_loop
00:D0FB E601            	   456:   inc VALUE+1
00:D0FD 80EB            	   457:   bra i2c_receive_message_loop
                        	   458: ;
                        	   459: ;  receiving done
                        	   460: ;
                        	   461: i2c_receive_message_done:
00:D0FF 209AD0          	   462:   jsr i2c_end_transmission
00:D102 38              	   463:   sec
00:D103 60              	   464:   rts
                        	   465: ;
                        	   466: ;  receiving failure
                        	   467: ;
                        	   468: i2c_receive_message_fail:
00:D104 209AD0          	   469:   jsr i2c_end_transmission
00:D107 18              	   470:   clc
00:D108 60              	   471:   rts
                        	   472: 
                        	   473: 

Source: "gpascal.asm"
                        	   188: 
                        	   189: 
                        	   190:   .if LCD_SUPPORT
00:D109 4E69636B27732047	   191: LCD_welcome asciiz "Nick's G-Pascal\nCompiler v4.01"
00:D111 2D50617363616C0A
00:D119 436F6D70696C6572
00:D121 2076342E3031
00:D127 00
                        	   192:   .endif
                        	   193: 
                        	   194: ;
                        	   195: ; here for cold start - clear text file to null etc. etc.
                        	   196: ;
                        	   197: START    =  *
00:D128 D8              	   198:   cld             ; cancel decimal mode
00:D129 78              	   199:   sei             ; no interrupts yet
00:D12A A9FF            	   200:   lda #$FF
00:D12C 8509            	   201:   sta random      ; initialise random numbers
00:D12E 850A            	   202:   sta random+1
00:D130 850B            	   203:   sta random+2
00:D132 850C            	   204:   sta random+3
                        	   205: ;
                        	   206: ;  Put 0x00 at start of source
                        	   207: ;
00:D134 A900            	   208:   lda  #<TEXT_START
00:D136 8500            	   209:   sta  REG
00:D138 A903            	   210:   lda  #>TEXT_START
00:D13A 8501            	   211:   sta  REG+1
00:D13C A900            	   212:   lda  #0
00:D13E A8              	   213:   tay
00:D13F 9100            	   214:   sta  (REG),Y     ; null edit file
00:D141 84BE            	   215:   sty  system_flags
00:D143 AA              	   216:   tax
                        	   217: ;
                        	   218: ;  now do rest of initialization
                        	   219: ;
                        	   220: RESTART  =  *
00:D144 A2FF            	   221:   ldx  #NEW_STK
00:D146 9A              	   222:   txs             ; reset stack
00:D147 58              	   223:   cli             ; allow interrupts after a NMI
00:D148 D8              	   224:   cld             ; cancel decimal mode
00:D149 2025C9          	   225:   jsr hardware_init
                        	   226: 
                        	   227: ;
                        	   228: REST1    =  *
                        	   229:   .if LCD_SUPPORT
                        	   230:     ;
                        	   231:     ;  put message on the LCD screen to prove it is working
                        	   232:     ;
00:D14C A909            	   233:     lda  #<LCD_welcome  ; G-pascal compiler
00:D14E A2D1            	   234:     ldx  #>LCD_welcome
00:D150 20FEB8          	   235:     jsr lcd_print_message
                        	   236:   .endif
                        	   237: 
                        	   238: ;
                        	   239: ;  now direct output to the serial port
                        	   240: ;
00:D153 20F8C8          	   241:   jsr  write_to_serial   ; set up outputting function
00:D156 A900            	   242:   lda  #0
00:D158 853F            	   243:   sta  RUNNING
00:D15A 4CC582          	   244:   jmp  main_start    ; go to "shell"
                        	   245: 
                        	   246: 
                        	   247: ;
                        	   248: ;  processor hardware vectors
                        	   249: ;
                        	   250:   .org $FFFA
01:FFFA 44D1            	   251:   .word RESTART   ; non-maskable interrupt (NMI)
01:FFFC 28D1            	   252:   .word START     ; reset vector
01:FFFE 1DB7            	   253:   .word irq       ; maskable interrupt (IRQ)
                        	   254: 


Symbols by name:
ACT_PCDA                         S:0025
ADD1                             E:B9EA
ADD4                             E:BA0D
ADD9                             E:BA29
ADDSYM                           E:B98E
ADDSYM_NOT_FULL                  A:B9C3
ASS1                             A:BE5B
ASS2                             A:BEA3
ASSARR                           A:BE82
ASSEMBLE                         A:98AB
ASSEMBLE_PASS                    A:98BD
ASSEMBLE_SECOND_PASS             A:98B8
ASSIGN                           A:BE58
ASSTB1                           A:BE67
ASSVAR                           A:BE94
ASS_COUNT                        S:0072
ASS_EMIT_COUNT                   S:006F
ASS_OPCODE_WORK                  S:0070
ASS_OPERAND                      S:006B
ASS_OPERAND_ABSOLUTE             E:0001
ASS_OPERAND_ABSOLUTE_INDEXED_IN  E:0002
ASS_OPERAND_ABSOLUTE_INDEXED_WI  E:0003
ASS_OPERAND_ABSOLUTE_INDEXED_WI  E:0004
ASS_OPERAND_ABSOLUTE_INDIRECT    E:0005
ASS_OPERAND_ACCUMULATOR_A        E:0006
ASS_OPERAND_IMMEDIATE            E:0007
ASS_OPERAND_IMPLIED              E:0008
ASS_OPERAND_STRING               E:0011
ASS_OPERAND_ZERO_PAGE            E:000B
ASS_OPERAND_ZERO_PAGE_AND_ABSOL  E:0012
ASS_OPERAND_ZERO_PAGE_INDEXED_I  E:000C
ASS_OPERAND_ZERO_PAGE_INDEXED_W  E:000D
ASS_OPERAND_ZERO_PAGE_INDEXED_W  E:000E
ASS_OPERAND_ZERO_PAGE_INDIRECT   E:000F
ASS_OPERAND_ZERO_PAGE_INDIRECT_  E:0010
ASS_PASS                         S:0076
ASS_VALUE                        S:0073
BACKSPACE                        E:0008
BAD_INP                          A:B321
BASE                             S:003B
BAUD_RATE                        E:12C0
BEG                              A:C108
BELL1                            E:AED9
BIT_INTERVAL                     E:00D0
BLCKT1                           A:C329
BLCKT2                           A:C32C
BLCKT3                           A:C32F
BLK1                             A:C364
BLK1A                            A:C350
BLK2                             A:C36C
BLK4                             A:C376
BLKB1                            A:C5CC
BLKB2                            A:C5E8
BLKB3                            A:C5C6
BLKB4                            A:C604
BLKB5                            A:C5F5
BLKB6                            A:C613
BLKBEG                           A:C5BC
BLKCN1                           A:C383
BLKCNS                           A:C380
BLKFNC                           A:C4F4
BLKPR1                           A:C516
BLKPR2                           A:C548
BLKPR3                           A:C532
BLKPR4                           A:C590
BLKPR5                           E:C569
BLKPR6                           A:C53F
BLKPRC                           A:C4D4
BLKV10                           E:C3CA
BLKV10_A                         E:C3E6
BLKV10_B                         E:C3ED
BLKV11                           A:C454
BLKV12                           A:C45B
BLKV13                           A:C415
BLKVAR                           A:C397
BLKVR1                           A:C39B
BLKVR2                           A:C3FC
BLKVR3                           A:C4BC
BLKVR4                           A:C41A
BLKVR5                           E:C47A
BLKVR6                           A:C39E
BLKVR7                           A:C3A8
BLKVR8                           A:C3C7
BLKVR9                           E:C461
BLOCK                            A:C339
BSAVE                            S:0036
CALL                             S:0047
CALLSB                           A:C034
CASE                             A:C174
CASE1                            A:C1AD
CASE2                            E:C186
CASE3                            A:C1C3
CASE4                            A:C1B9
CASE5                            A:C1F6
CASE6                            A:C214
CASE7                            A:C182
CASE8                            A:C229
CASE9                            A:C21F
CHKDUP                           A:BA35
CHKGET                           E:C302
CHKLHB                           E:BAB0
CHKLHP                           E:BA96
CHKNOK                           E:CF99
CHKOK                            E:CF9C
CHKRHB                           E:BABA
CHKRHP                           E:BA9D
CHKTKN                           A:CF9E
CHK_KBD                          E:AF2D
CHK_NOTD                         A:AF55
CHK_NOTN                         A:AF39
CHK_NOTT                         A:AF47
CHK_RUN                          A:93D4
CHK_STAK                         E:BBBC
CHK_VAL                          E:93C1
CHK_VAL9                         E:93D3
CHRIN                            E:C90E
CLOCK_RATE                       E:4240
COMPIL                           A:BA45
COMS8                            A:92A3
COMS9                            A:92A2
COMSTL                           E:9296
CONDEC                           E:BAD5
CONST                            E:BBC8
CONST1                           A:BBDF
CONST2                           A:BBE9
CONST3                           E:BBE4
CONST9                           A:BBED
COUNT1                           S:004B
COUNT2                           S:004C
COUT                             A:9418
COUT_CALL                        A:9422
CR                               E:000D
CROUT                            E:9291
DATA                             S:003D
DATTYP                           S:004A
DB11                             A:ADF2
DBGFLG                           S:0049
DCODE                            S:002E
DEBUG                            E:ADF2
DEBUG_DONE                       A:AE5A
DEST                             E:0003
DIRECTIVES                       E:A024
DIS5                             A:AEC2
DIS5_A                           E:AECC
DISHX                            A:92A6
DISP9                            A:C7CE
DISPAD                           E:92AC
DISPAD2                          A:92C7
DISPL                            S:0027
DIVBY0                           A:B0D7
DM1                              A:ADD7
DM2                              A:ADE0
DM5                              A:AE81
DM6                              A:AE96
DM7                              A:AEA1
DUP9                             A:BA44
EFLAG_ALLOW_ZERO_FROM            E:0002
EFLAG_FIND                       E:0010
EFLAG_LOAD                       E:0004
EFLAG_NO_LINE_NUMBERS            E:0080
EFLAG_REPLACE                    E:0020
EFLAG_SAVE                       E:0008
EFLAG_SHOW_LINE                  E:0001
EFLAG_SUPPRESS_NEWLINE           E:0040
EMULATOR                         E:0000
EMULATOR_DEBUG                   A:C922
ENDSYM                           S:0031
END_CMP                          E:BA93
END_EDITOR_INPUT                 E:001B
END_PCD                          S:0043
END_WRK                          E:C31E
ERR1                             E:97E0
ERR3                             E:97F4
ERR5                             E:9804
ERR6                             E:980A
ERR7                             E:97D6
ERRLIT                           A:97C1
ERRNO                            S:0035
ERROR                            A:97CD
EXPR1                            A:BDE4
EXPR2                            A:BE06
EXPR3                            A:BE0C
EXPR4                            A:BE10
EXPR5                            A:BE14
EXPR6                            A:BE18
EXPR7                            A:BE1C
EXPR8                            A:BE08
EXPRES                           A:BDC1
EXPTB1                           A:BDD1
EXPTB3                           A:BDF3
EX_ABS                           A:B0FB
EX_ABSCLL                        E:B390
EX_ADD                           A:B097
EX_ADRAC                         E:B56F
EX_ADRAN                         E:B569
EX_ADRN2                         E:B55E
EX_ADRNC                         E:B54B
EX_ADRNC2                        E:B54E
EX_ADRNN                         E:B55B
EX_AND                           A:B169
EX_ASSERT                        A:B602
EX_ASSERT_OK                     A:B617
EX_CLA                           A:B426
EX_CLL                           E:B397
EX_CLL2                          E:B3C1
EX_CLL3                          E:B3E2
EX_CLL4                          E:B3BD
EX_CLL5                          E:B423
EX_CLL_A                         E:B39F
EX_CLL_JMP                       A:B443
EX_DEC                           A:B1AB
EX_DELAY                         E:B5BE
EX_DIGITALREAD                   E:B575
EX_DIGITALREAD_ONE               A:B580
EX_DIGITALWRITE                  E:B5ED
EX_DIV                           A:B0E7
EX_DIVIDE_BY_ZERO                A:B0D0
EX_EOR                           A:B172
EX_EQL                           A:B104
EX_FINISHD                       E:AEF7
EX_GEQ                           A:B13F
EX_GETKEY                        E:B0B5
EX_GTR                           A:B133
EX_INC                           A:B193
EX_INP                           E:B2E9
EX_INPC                          A:B4B1
EX_INPC_OK                       A:B4BB
EX_INP_OK                        A:B2FA
EX_INS                           E:B4ED
EX_INS1                          E:B510
EX_INS2                          E:B519
EX_INS3                          E:B4F7
EX_INS4                          E:B523
EX_INT                           A:B446
EX_INVINS                        E:AFAA
EX_JM1                           A:B4A6
EX_JMP                           A:B482
EX_JMZ                           A:B495
EX_LATENCY                       A:B5AF
EX_LCDCLEAR                      A:B4E7
EX_LCDHOME                       A:B4E1
EX_LCDPOS                        E:B583
EX_LCDPOS_1                      A:B593
EX_LCD_WRITE_CHR                 A:B4D0
EX_LCD_WRITE_HEX                 A:B342
EX_LCD_WRITE_NUM                 A:B32E
EX_LCD_WRITE_STR                 A:B362
EX_LDA                           A:B207
EX_LDAC                          A:B1FC
EX_LDI                           A:B242
EX_LDIC                          A:B23C
EX_LEQ                           A:B14B
EX_LIB_CALL                      A:B5FC
EX_LIT                           A:B07C
EX_LOD                           A:B1E6
EX_LOD2                          A:B1E9
EX_LOD3                          A:B1D7
EX_LOD3_A                        A:B1D9
EX_LODC                          A:B1D4
EX_LSS                           A:B127
EX_MOD                           A:B0BC
EX_MOV                           A:B1C3
EX_MUL                           A:B0AC
EX_NEG                           A:B08E
EX_NEQ                           A:B11E
EX_NEW_STACK                     A:B470
EX_NOJUMP                        A:B4A0
EX_ORR                           A:B160
EX_OUH                           A:B33D
EX_OUH_COMMON                    A:B345
EX_OUS                           E:B35D
EX_OUS1                          A:B381
EX_OUS_COMMON                    A:B365
EX_OUT                           A:B329
EX_OUTC                          A:B4CB
EX_OUTCR                         E:AF57
EX_OUTC_COMMON                   A:B4D3
EX_PINMODE                       E:B5DE
EX_RANDOM                        A:B59D
EX_RANDOMSEED                    E:B5CE
EX_RTN                           A:B2B0
EX_SHL                           A:B17B
EX_SHR                           A:B187
EX_STA                           A:B268
EX_STA5                          A:B279
EX_STAC                          A:B27E
EX_STI                           A:B295
EX_STIC                          A:B287
EX_STO                           A:B255
EX_STO2                          A:B25B
EX_STO5                          A:B250
EX_STOC                          A:B248
EX_SUB                           A:B0A0
EX_XOR                           A:B157
FACAD1                           A:BD0F
FACAD2                           A:BD2D
FACADR                           E:BD57
FACERR1                          A:BD70
FACM2                            A:BD8B
FACMEM                           A:BD81
FACMMC                           A:BD87
FACNOT                           A:BD97
FACNUM                           E:BD75
FACRND1                          A:BDA2
FACSTR                           A:BD6A
FACTB1                           A:BDA8
FACTOR                           A:BCC0
FACTQT1                          A:BDAE
FALSE                            A:B11A
FFLAG_GLOBAL                     E:0002
FFLAG_IGNORE_CASE                E:0001
FFLAG_QUIET                      E:0004
FIN_MSG                          A:AF0E
FIXAD                            E:C817
FIXAD1                           A:C854
FIXM1                            A:C855
FIXM2                            A:C85E
FLAG_ABORTED                     E:0080
FLAG_ASSEMBLING                  E:0002
FLAG_COMPILING                   E:0001
FLAG_LIST_SOURCE                 E:0004
FLAG_ONLY_ALPHA                  E:0040
FLAG_VALID_ASSEMBLE              E:0010
FLAG_VALID_COMPILE               E:0008
FNC1                             A:C07E
FNC2                             A:C04E
FNC3                             A:C078
FNC4                             A:C0C2
FNC5                             A:C081
FNC5A                            A:C09E
FNC5B                            A:C0A0
FNC6                             A:C0C3
FNCPRC                           A:C041
FOR                              A:C22F
FOR1                             A:C239
FOR2                             A:C246
FOR3                             A:C25F
FOR4                             A:C290
FOR5                             A:C2D3
FOR6                             A:C2F5
FRAME                            S:0020
FROM                             E:0040
GEN1                             E:C775
GEN2                             E:C7AC
GEN2_A                           E:C7B7
GEN2_B                           E:C7AE
GEN2_C                           E:C7CE
GEN3                             E:C812
GENADR                           E:C779
GENJMP                           E:C7E9
GENNJM                           A:C7E3
GENNJP                           E:C7E1
GENNOP                           E:C760
GENNOP1                          A:BD9F
GENNOP2                          A:C00C
GENRJMP                          E:C7CF
GEN_FULL                         A:C7C9
GET1                             A:93F2
GET1_A                           E:B001
GET2                             E:AFC5
GET3                             A:940F
GETADR                           A:AFBB
GETADR1                          E:AFE6
GETCHK                           A:CF8E
GETEXPR                          E:BB54
GETID2                           A:B22E
GETIDC                           A:B211
GETIDX                           E:B21A
GETIN                            E:C90E
GETIN1                           A:C918
GETLIT                           E:B065
GETLN1                           E:93F0
GETLN_OVERFLOW                   A:9415
GETO_1                           E:BB45
GETO_2                           E:BB52
GETSUB                           E:BAA7
GET_COMM                         E:BB86
GET_DAT                          E:BACE
GET_END                          A:B07B
GET_ITEM                         E:BB8D
GET_LEV                          E:BAC4
GET_LINE                         E:93F0
GET_LOOK                         A:CFA3
GET_OFF                          E:BB29
HIGHEST_RAM                      E:3FFF
I2C_DDR                          E:7FF3
I2C_PORT                         E:7FF1
I2C_SCL                          E:0004
I2C_SDA                          E:0008
IDENT                            A:BCD1
IDENT1                           A:BCD4
IDENT1A                          A:BCDC
IDENT2                           A:BCE1
IDENT2A                          A:BCFA
IDENT3                           A:BD01
IDENT4                           A:BD35
IDENT4_A                         A:BD37
IDENT5                           A:BD17
IDENT5_A                         A:BD19
IDENT6                           A:BD24
IDENT7                           A:BD2A
IF                               A:C0C8
IF1                              A:C0ED
IF2                              A:C0E6
INBUF                            S:0200
INBUF_SIZE                       E:0100
INIT                             E:9243
INIT9                            A:9290
INIT_SECOND_PASS                 A:924F
INP3                             A:B311
INTERP                           E:AE5B
INT_ERR                          E:B45D
INT_ERRM                         A:B464
JMP1                             E:9003
JMP2                             E:900B
JMP3                             E:9020
KEY_ABORT                        E:0003
KEY_DEBUG                        E:0004
KEY_STOP_TRACE                   E:000E
KEY_TRACE                        E:0014
LASTP                            S:004D
LCD_E                            E:0080
LCD_RS                           E:0020
LCD_RW                           E:0040
LCD_SUPPORT                      E:0001
LCD_welcome                      A:D109
LEVEL                            S:0022
LINE_CNT                         S:0019
LIST                             S:001D
LIT1                             A:B08B
LOOK1                            A:BA34
LOOKUP                           E:BA2A
LOWLIT                           A:AF5D
LOWLIT1                          A:AF63
MAIN                             A:AF6C
MAINP                            A:AF69
MAIN_1                           E:AF9B
MAIN_2                           E:AF73
MAIN_NOT_ABORT                   E:AF7E
MAIN_OK                          E:AF81
MAKE_LOWER_DONE                  E:9042
MAKE_UPPER                       E:902D
MAKE_UPPER_DONE                  E:9037
MAX_STK                          E:0020
MCAND                            S:0055
MEM                              A:C019
MEM2                             A:C021
MEMC                             A:C01E
NEW_STK                          E:00FF
NL                               E:000A
NOSCE                            A:9232
NOTIM1                           E:AFAE
OFFSET                           S:0029
ONE_OP                           A:C005
ONE_OP2                          A:C002
OPCODE                           S:006C
OPCODE_3_CHAR_BRANCH             E:A0E8
OPCODE_3_CHAR_IMPLIED            E:A10D
OPCODE_4_CHAR_BRANCH             E:A097
OPCODE_4_CHAR_ZERO_PAGE          E:A18A
OPCODE_ASS_OPERAND_ABSOLUTE      E:A1DB
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A247
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A24C
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A291
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A294
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A2B9
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A2D5
OPCODE_ASS_OPERAND_ABSOLUTE_TOK  E:A244
OPCODE_ASS_OPERAND_ACCUMULATOR_  E:A2BC
OPCODE_ASS_OPERAND_IMMEDIATE     E:A2DA
OPCODE_ASS_OPERAND_IMMEDIATE_TO  E:A30B
OPCODE_ASS_OPERAND_ZERO_PAGE     E:A30E
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A372
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A393
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A396
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A3DF
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A3E2
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A3EB
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A40F
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A430
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A40C
OPCODE_ASS_OPERAND_ZERO_PAGE_TO  E:A36F
OPCODE_LEN                       S:006E
OPCODE_LOOKUP_HANDLER            E:0004
OPCODE_LOOKUP_OPCODE_LENGTH      E:0000
OPCODE_LOOKUP_OPCODE_TABLE       E:0002
OPCODE_LOOKUP_OPERAND_TYPE       E:0001
OPCODE_LOOKUP_TABLE              E:9F81
OPCODE_LOOKUP_TABLE_SIZE         E:0006
OPND                             S:002B
OUT_COMMON                       A:B331
PAREN                            A:BD7B
PCD_WRKD                         E:BB5A
PCODE                            S:0023
PCODE_ABSCLL                     E:0038
PCODE_ADD                        E:0004
PCODE_ADRAN                      E:000E
PCODE_ADRNN                      E:000C
PCODE_AND                        E:001B
PCODE_CLA                        E:002B
PCODE_CLL                        E:0027
PCODE_DEC                        E:0028
PCODE_DIV                        E:000A
PCODE_EOR                        E:0020
PCODE_EQL                        E:0010
PCODE_FINISHD                    E:0011
PCODE_GEQ                        E:0016
PCODE_GTR                        E:0018
PCODE_INC                        E:0026
PCODE_INP                        E:001C
PCODE_INS                        E:0025
PCODE_INT                        E:003B
PCODE_JM1                        E:003E
PCODE_JMP                        E:003C
PCODE_JMZ                        E:003D
PCODE_LAST                       E:0045
PCODE_LCD_WRITE_CHR              E:0045
PCODE_LCD_WRITE_HEX              E:0044
PCODE_LCD_WRITE_NUM              E:0042
PCODE_LCD_WRITE_STR              E:0043
PCODE_LDA                        E:002E
PCODE_LDI                        E:0030
PCODE_LEQ                        E:0019
PCODE_LIB_CALL                   E:0003
PCODE_LIT                        E:0000
PCODE_LOD                        E:002C
PCODE_LSS                        E:0014
PCODE_MOD                        E:000B
PCODE_MOV                        E:002A
PCODE_MUL                        E:0008
PCODE_NEG                        E:0002
PCODE_NEQ                        E:0012
PCODE_ORR                        E:001A
PCODE_OUH                        E:0021
PCODE_OUS                        E:0023
PCODE_OUT                        E:001E
PCODE_OUTC                       E:001F
PCODE_OUTCR                      E:0040
PCODE_RTN                        E:0029
PCODE_SHL                        E:0022
PCODE_SHR                        E:0024
PCODE_STA                        E:0034
PCODE_STACK                      E:0001
PCODE_STI                        E:0036
PCODE_STO                        E:0032
PCODE_SUB                        E:0006
PCODE_XOR                        E:003A
PRBYTE                           A:9306
PRBYTECR                         E:93BB
PRCHAR                           E:92EE
PRCITM                           S:0039
PRHEX                            A:930F
PRHEX1                           A:9319
PRHEXZ                           A:9311
PSH1                             E:B054
PSH9                             A:92DA
PSHPCODE                         E:BB16
PSHTOP                           E:B049
PSHWRK                           E:92C8
PT                               A:9320
PT6                              A:9328
PUL2_END                         E:B042
PULBOTH                          A:B024
PULTOP                           E:B002
PULTOP2                          E:B027
PULWRK                           E:92DB
PUL_END                          E:B01D
PUTSP                            E:931C
READ                             A:BF70
READ11                           A:BF90
READ2                            A:BF76
READ3                            A:BFBF
READ3_A                          A:BFEE
READ3_B                          A:BFD3
READ7                            A:BFAF
READ7_A                          A:BFB5
READ8                            A:BF73
READ9                            A:BF8D
REG                              E:0000
REG2                             E:0003
REG2B                            E:0005
REGB                             E:0002
REMAIN                           S:0006
REP1                             A:C121
REPEAT                           A:C11E
RES                              S:0052
RESTART                          E:D144
RMNDR                            S:005B
RSVEND                           A:CF38
RSVWRD                           E:CE45
RUNERR                           A:AEE3
RUNNING                          S:003F
SEA1                             E:B925
SEA2                             E:B932
SEA3                             E:B986
SEA4                             E:B97B
SEA5                             E:B983
SEARCH                           E:B912
SEA_NEXT                         E:B91A
SERIAL_DEBUG1_MASK               E:0004
SERIAL_DEBUG2_MASK               E:0008
SERIAL_DEBUGGING                 E:0000
SERIAL_DELAY1                    E:0030
SERIAL_DELAY2                    E:0023
SERIAL_OUT_MASK                  E:0002
SERIAL_SPARE2_MASK               E:0010
SIM1                             A:BC0A
SIM2                             A:BC52
SIM3                             A:BC1B
SIM4                             A:BC2E
SIM5                             A:BC4A
SIM6                             A:BC4E
SIM7                             A:BC44
SIM8                             A:BC58
SIMEXP                           E:BC00
SINGLE_QUOTE                     E:0027
SRCE                             E:0000
START                            E:D128
STARTSYM                         S:002F
START_OF_ROM                     E:8000
START_TRACE                      A:C923
STK_ERR                          A:BBC3
STK_FULL                         E:BBC3
STMNT                            A:BE20
STMNT1                           A:BE2D
STMNT_WRITE_LCD                  A:BF1F
STOP_TRACE                       A:C924
ST_SYMTBL_LIST_CHECK             E:8DF4
ST_SYMTBL_LIST_DONE              E:8E89
ST_SYMTBL_LIST_LINE              E:8E03
ST_SYMTBL_LIST_NAME              E:8E78
ST_SYMTBL_LIST_NEXT              E:8DE9
SYMARG                           E:0006
SYMBOL_ARRAY                     E:0041
SYMBOL_CONSTANT                  E:0043
SYMBOL_FUNCTION                  E:0046
SYMBOL_FUNCTION_RETURN           E:0059
SYMBOL_LIBRARY_FUNCTION          E:0052
SYMBOL_LIBRARY_PROCEDURE         E:0051
SYMBOL_PROCEDURE                 E:0050
SYMBOL_TABLE_START               E:3FFF
SYMBOL_VARIABLE                  E:0056
SYMDAT                           E:0008
SYMDSP                           E:0004
SYMITM                           S:0040
SYMLEN                           E:0009
SYMLVL                           E:0002
SYMNAM                           E:000A
SYMPRV                           E:0000
SYMSUB                           E:0006
SYMTYP                           E:0003
SYMWRK                           E:BB00
SYM_FULL                         A:B989
SYNTAX                           S:0042
T                                E:0031
TEMP                             S:0045
TERM                             A:BC72
TERM1                            A:BC7F
TERM2                            A:BC75
TERM3                            A:BC90
TERM4                            A:BC8E
TERM5                            A:BC96
TERM6                            A:BC9A
TERM7                            A:BC9E
TERM8                            A:BCA2
TERM9                            A:BCA6
TERMT1                           A:BC5C
TERMT3                           A:BCAA
TEXT_START                       E:0300
TKNJMP                           E:8FFB
TKNWRK                           E:9332
TOKEN_ADDRESS                    E:00A9
TOKEN_AND                        E:008D
TOKEN_ARRAY                      E:0084
TOKEN_ASSIGN                     E:0041
TOKEN_BEGIN                      E:0088
TOKEN_CALL                       E:009F
TOKEN_CASE                       E:0095
TOKEN_CHAR                       E:00A1
TOKEN_CHR                        E:00AB
TOKEN_CONST                      E:0082
TOKEN_DIV                        E:008B
TOKEN_DO                         E:0097
TOKEN_DOWNTO                     E:009C
TOKEN_ELSE                       E:0094
TOKEN_END                        E:0089
TOKEN_EQUALITY                   E:0045
TOKEN_FOR                        E:009A
TOKEN_FUNCTION                   E:0087
TOKEN_GEQ                        E:0081
TOKEN_HEX                        E:00AC
TOKEN_HIGH_BYTE                  E:0057
TOKEN_IDENTIFIER                 E:0049
TOKEN_IF                         E:0092
TOKEN_INEQUALITY                 E:005A
TOKEN_INTEGER                    E:00FE
TOKEN_LCDWRITE                   E:00F1
TOKEN_LEQ                        E:0080
TOKEN_LOGICAL_AND                E:0058
TOKEN_LOGICAL_OR                 E:0059
TOKEN_LOW_BYTE                   E:0056
TOKEN_MEM                        E:0091
TOKEN_MEMC                       E:00A2
TOKEN_MOD                        E:008C
TOKEN_NEQ                        E:0055
TOKEN_NOT                        E:0090
TOKEN_NUMBER                     E:004E
TOKEN_OF                         E:0085
TOKEN_OR                         E:008A
TOKEN_PROCEDURE                  E:0086
TOKEN_READ                       E:009E
TOKEN_REPEAT                     E:0098
TOKEN_SHIFT_LEFT                 E:004C
TOKEN_SHIFT_RIGHT                E:0052
TOKEN_SHL                        E:008E
TOKEN_SHR                        E:008F
TOKEN_STRING                     E:0022
TOKEN_THEN                       E:0093
TOKEN_TO                         E:009B
TOKEN_UNARY_MINUS                E:004D
TOKEN_UNTIL                      E:0099
TOKEN_VAR                        E:0083
TOKEN_WHILE                      E:0096
TOKEN_WRITE                      E:009D
TOKEN_WRITELN                    E:00FF
TOKEN_XOR                        E:00A4
TRUE                             A:B10D
TRUE2                            A:B10F
TWO_OP                           A:BFFC
VALUE                            S:0000
VALUE2                           S:0003
VAL_1                            E:BB9C
VAL_2                            E:BBA1
VAL_3                            E:BBAA
VAL_5                            E:BBB3
VAL_MOVE                         E:BB93
VAL_WRK                          E:C313
VARDEC                           A:BBEE
VIA_ACR                          E:7FFB
VIA_DDRA                         E:7FF3
VIA_DDRB                         E:7FF2
VIA_FLAG_CB2                     E:0008
VIA_FLAG_DISABLE                 E:0000
VIA_FLAG_ENABLE                  E:0080
VIA_FLAG_TIMER1                  E:0040
VIA_IER                          E:7FFE
VIA_IFR                          E:7FFD
VIA_PCR                          E:7FFC
VIA_PORTA                        E:7FF1
VIA_PORTB                        E:7FF0
VIA_T1C_H                        E:7FF5
VIA_T1C_L                        E:7FF4
WAIT_1                           A:C00F
WHILE                            A:C142
WORK                             S:0037
WORKD                            S:0033
WRIT1                            E:BEFA
WRIT10                           A:BEED
WRIT2                            A:BEEA
WRIT5                            A:BF0A
WRIT9                            A:BED1
WRITE                            A:BECE
WRITELN                          A:BEBF
WRITELN9                         E:BEC9
WRITE_LCD1                       E:BF4B
WRITE_LCD2                       A:BF3B
WRITE_LCD5                       A:BF5B
WRITE_LCD9                       A:BF22
WRITE_LCD_STRING                 E:BF31
WRITE_LDC_CHR                    E:BF64
WRITE_LDC_CHR1                   E:BF66
WRITE_LDC_HEX                    E:BF6C
WRKD_WRK                         E:BB70
WRKSYM                           E:BB0B
WRKTKN                           E:933D
WRK_OPND                         E:BB65
WRK_VAL                          E:C308
WRK_WRKD                         E:BB7B
W_CHR                            E:BF13
W_CHR1                           E:BF15
W_HEX                            E:BF1B
W_STRING                         E:BEE0
ZERRES                           A:AC6D
a_equals_message                 A:B635
add_assembler_library_functions  A:AA89
add_assembler_library_functions  A:AAD3
add_assembler_library_functions  A:AA91
add_assembler_library_functions  A:AAA1
add_pascal_library_functions     A:C6B6
add_pascal_library_functions_do  A:C70F
add_pascal_library_functions_lo  A:C6BE
add_pascal_library_functions_na  A:C6CE
asm_do_asc                       E:A498
asm_do_asc_loop                  A:A4A5
asm_do_asc_next                  A:A4AE
asm_do_asc_ok                    A:A4A3
asm_do_assert                    A:A433
asm_do_assert_failed             A:A442
asm_do_blk                       A:A56A
asm_do_blk_done                  A:A587
asm_do_blk_loop                  A:A57A
asm_do_constant_expected         A:A4DF
asm_do_constant_expectedJ        A:A447
asm_do_constant_expectedJ2       A:A5A0
asm_do_dfb                       A:A4ED
asm_do_dfb_multiple              A:A4FB
asm_do_dfb_multiple_done         A:A519
asm_do_dfb_multiple_loop         A:A508
asm_do_dfb_too_big               A:A51A
asm_do_dfw                       A:A52D
asm_do_dfw_multiple              A:A53B
asm_do_dfw_multiple_done         A:A55A
asm_do_dfw_multiple_loop         A:A549
asm_do_equ                       A:A4BC
asm_do_equ_have_label            A:A4CD
asm_do_list                      E:A44A
asm_do_list1                     A:A488
asm_do_list_first_pass           A:A497
asm_do_list_no_operand           A:A46A
asm_do_list_not                  A:A484
asm_do_list_ok                   A:A46E
asm_do_nolist                    A:A459
asm_do_nolist_ok                 A:A464
asm_do_org                       A:A4D9
asm_do_org_ok                    A:A4E4
asm_do_reserve                   A:A588
asm_do_string                    A:A4B3
asm_do_sym                       A:A5A3
asm_do_sym_done                  A:A5BC
asm_emit_one_byte                A:A51F
asm_emit_two_bytes               A:A55B
ass_absolute_another_value       A:9B28
ass_added_symbol                 A:9965
ass_already_emitted              A:9EF2
ass_bad_identifier               A:9920
ass_bad_indirect                 A:9A8F
ass_bad_zp_indirect_indexed      A:9AC9
ass_branch_backwards             A:9F3D
ass_branch_ok                    A:9F41
ass_branch_out_of_range          A:9F47
ass_check_label_changed          A:99CF
ass_check_no_more_tokens         A:9C23
ass_check_no_more_tokens_ok      A:9C2E
ass_check_we_have_x_or_y         A:9AD0
ass_check_we_have_x_or_y_ok      A:9AEC
ass_current_label                S:0083
ass_done                         A:9BE0
ass_done1                        A:9C02
ass_done_jump                    A:98E2
ass_done_message                 A:9C05
ass_done_second_pass             A:9BEA
ass_emit                         A:9ECF
ass_emit1                        A:9F0A
ass_emit2                        A:9EE3
ass_emit3                        A:9F04
ass_emit4                        A:9EFD
ass_emit_absolute                A:9F76
ass_emit_bytes                   S:0077
ass_emit_immediate               A:9F63
ass_emit_immediate_too_high      A:9F71
ass_emit_zero_page               A:9F50
ass_emit_zero_page_too_high      A:9F5E
ass_error                        A:9F0D
ass_error1                       A:9F14
ass_evaluate_operator            A:9EA8
ass_expression_apply_operator    A:9E67
ass_expression_apply_operator_b  A:9EA3
ass_expression_cannot_be_unary   A:9E13
ass_expression_found_value       A:9DA1
ass_expression_loop              A:9D54
ass_expression_loop1             A:9D85
ass_expression_loop1a            A:9D6E
ass_expression_loop2             A:9DB2
ass_expression_loop3             A:9DC1
ass_expression_loop3a            A:9DD0
ass_expression_loop3b            A:9DC5
ass_expression_loop3c            A:9DD5
ass_expression_loop4             A:9DDB
ass_expression_loop6             A:9E39
ass_expression_loop7             A:9E22
ass_expression_loopJ             A:9DD8
ass_expression_loop_initial      A:9D57
ass_expression_not_small_string  A:9D80
ass_expression_number            A:9D5B
ass_expression_unary             A:9E90
ass_finish_line                  A:98D7
ass_finish_lineJ                 A:99F5
ass_fixup_bbr_branch             A:9F17
ass_fixup_branch                 A:9F24
ass_get_value                    A:9D3A
ass_identifier                   A:9925
ass_identifier_operand           A:9A33
ass_illegal_opcode               A:9986
ass_immediate                    A:9A17
ass_indexed                      A:9B01
ass_indexed_x                    A:9B1F
ass_indirect                     A:9A2A
ass_indirect_with_bracket        A:9A94
ass_label_not_found_yet          A:9D99
ass_line                         A:98E5
ass_line1                        A:98F4
ass_lookup_existing_label        A:994F
ass_lookup_loop                  A:9EAB
ass_lookup_save_address          A:9959
ass_not_colon                    A:9977
ass_not_colon2                   A:997E
ass_not_unary_greater_than       A:9DFD
ass_not_unary_less_than          A:9DF3
ass_not_unary_minus              A:9DE9
ass_not_x_or_y                   A:9ACE
ass_opcode                       A:998E
ass_opcode2                      A:99E4
ass_opcode_found                 A:9EC9
ass_operand                      A:99F8
ass_operand_value                A:9A54
ass_string                       A:9A0A
ass_symbol_address_changed       A:99DF
ass_value_done                   A:9AF8
ass_value_not_indirect           A:9AEE
ass_value_not_indirectJ          A:9A8C
ass_zp_indirect_indexed          A:9AA8
assembler_library_functions_tab  A:A61D
assertion_failed_message         A:9787
assign_bad_identifier            A:BE7D
atoi                             A:CA7B
atoi_error                       E:CAEA
atoi_loop                        E:CA84
atoi_more                        E:CA95
atoi_not_running                 E:CAF0
atoi_positive                    A:CA93
bad_command                      A:82A2
bad_delimiter_message            A:86DB
bad_flag_message                 A:8845
bcd_output_digit                 A:91D9
bcd_positive                     A:91C7
bcd_result                       S:0060
bcd_skip_zeroes                  A:91CE
bcd_table                        E:915B
bcd_unpack                       A:9148
bcd_work                         S:005C
binary_to_decimal                A:91E4
binary_to_decimal_loop           A:91EF
binary_to_decimal_next           A:9214
break_message                    A:B61A
brk_address                      S:0015
brk_executed                     A:B666
brk_executed1                    A:B6E1
brk_executed2                    A:B6EE
brk_executed3                    A:B6FE
brk_executedJ                    A:B71A
brk_resumed                      A:8CEE
bytes_message                    A:90E4
call_a                           S:0010
call_assembler                   A:93E6
call_handler                     A:8FB3
call_p                           S:0013
call_s                           S:0014
call_x                           S:0011
call_y                           S:0012
cb2_interrupt                    A:B742
character_types_table            E:8006
compile_finished_message         A:935B
crc16                            E:9066
crc16_loop                       E:9072
crc16_next                       A:907F
crc16_skip                       A:9085
crc_addr                         E:0000
crc_byte                         E:908E
crc_done                         A:908D
crc_helper1                      A:90BE
crc_message                      A:90C1
crc_num                          E:0003
crc_source                       E:90EC
crc_val                          E:0006
current_line                     S:00A2
delay                            E:913E
delay_1ms                        E:9134
delay_1ms_loop                   A:9137
digitalread                      E:C8DB
digitalread_B                    A:C8EA
digitalread_C                    A:C8F2
digitalwrite                     E:C8AC
digitalwrite_B                   A:C8BD
digitalwrite_C                   A:C8C5
digitalwrite_ONE                 A:C8D3
display_in_decimal               E:91BB
display_x_characters             A:AEBB
editor_argument_check            A:8B9F
editor_argument_check_failed     A:8BB1
editor_argument_check_got_argum  A:8BBB
editor_argument_check_loop       A:8BA1
editor_assemble                  A:8F6D
editor_bad_delimiter             A:86EA
editor_bad_number                A:8570
editor_bad_range                 A:862B
editor_bad_rangeJ                A:86C4
editor_check_no_more             A:8658
editor_check_no_more_failed      A:866A
editor_check_no_more_loop        A:865A
editor_check_no_more_ok          A:8674
editor_compile                   A:8EEE
editor_debug                     A:8EC7
editor_default_range             A:8552
editor_delete                    A:8BBC
editor_delete_line_count_done    A:8C2A
editor_delete_line_count_loop    A:8C0A
editor_delete_line_count_not_do  A:8C16
editor_delete_line_count_not_ne  A:8C22
editor_do_replace                A:89BA
editor_do_replace_copy_done      A:89FF
editor_do_replace_smaller        A:89FC
editor_do_the_replace            A:8920
editor_easy_replace              A:892D
editor_easy_replace_done         A:893E
editor_easy_replace_loop         A:8931
editor_find                      A:876F
editor_find_bug                  A:87AD
editor_find_case_sensitive       A:88DE
editor_find_found_it             A:8902
editor_find_found_it1            A:8908
editor_find_get_flags            A:8807
editor_find_inner_loop           A:88C7
editor_find_loop                 A:88C3
editor_find_no_match             A:88EC
editor_find_or_replacing         A:88BF
editor_find_problem              A:86EE
editor_find_second_delimiter_lo  A:87BA
editor_find_skip_this            A:88E8
editor_find_test_character       A:88DF
editor_find_third_delimiter_loo  A:87E1
editor_flags                     S:00BC
editor_flags1                    A:8827
editor_flags2                    A:8831
editor_flags3                    A:883B
editor_flags_loop                A:8809
editor_get_delimiter             A:8718
editor_get_number                A:857A
editor_get_number_done           A:85E2
editor_get_number_end            A:85E6
editor_get_number_none           A:85E4
editor_get_number_not_identifie  A:85BC
editor_get_number_ok             A:85D2
editor_get_range                 A:8675
editor_get_range_done            A:86C3
editor_get_range_hyphen          A:86AB
editor_get_range_number          A:86B0
editor_handlers                  A:8330
editor_help                      A:8533
editor_help_done                 A:854F
editor_help_info                 A:83BE
editor_help_loop                 A:853E
editor_info                      E:8EDF
editor_insert                    A:8A2E
editor_insert_at_start           A:8A48
editor_insert_backspace          A:8AE2
editor_insert_backspace_not_at_  A:8AEE
editor_insert_common             A:8A56
editor_insert_done               A:8B04
editor_insert_done_with_newline  A:8B15
editor_insert_loop               A:8A99
editor_insert_loop1              A:8AD2
editor_insert_no_line_number     A:8AAA
editor_insert_not_newline        A:8AC9
editor_line_number_too_big       A:8612
editor_list                      A:877B
editor_list_aborted              A:88B2
editor_list_check_to_line        A:896E
editor_list_check_to_line_ok     A:897E
editor_list_completely_done      A:89B7
editor_list_doing_find           A:87A1
editor_list_done                 A:899A
editor_list_doneJ                A:8885
editor_list_fix_target_string    A:8853
editor_list_fixup_loop           A:885B
editor_list_get_on_with_it       A:886E
editor_list_got_from_point       A:87B8
editor_list_have_source          A:887F
editor_list_loop                 A:888B
editor_list_loopJ                A:8997
editor_list_no_line_number       A:895C
editor_list_no_line_numberJ      A:8888
editor_list_not_find             A:886B
editor_list_not_finding          A:894F
editor_list_not_newline          A:8986
editor_list_skip_newline         A:8991
editor_load                      A:8A2A
editor_memory                    A:8D14
editor_memory_aborted            A:8D8A
editor_memory_ascii              A:8D92
editor_memory_done               A:8D87
editor_memory_loop               A:8D2E
editor_memory_loop1              A:8D4F
editor_memory_loop2              A:8D61
editor_memory_loop3              A:8D77
editor_memory_not_control        A:8D9A
editor_memory_not_high           A:8DA0
editor_memory_show_ascii         A:8D90
editor_memory_show_dot           A:8D9E
editor_newline_processing        A:8964
editor_no_closing_delimiter      A:8746
editor_no_closing_delimiterJ     A:87B5
editor_no_closing_delimiter_mes  A:8730
editor_no_find_string            A:8761
editor_no_lines                  A:8B48
editor_recover                   A:8E9E
editor_recover_not_needed        A:8EBD
editor_replace                   A:8767
editor_replacement_loop          A:88C1
editor_run                       A:8F02
editor_save                      A:8775
editor_syntax                    A:8EF8
editor_test                      A:8D02
editor_too_full                  A:8B30
editor_too_full_loop             A:8B37
editor_trace                     A:8ED3
error1                           A:9824
error_find_next                  A:981B
error_found                      A:9845
error_loop                       A:9817
error_next                       A:9816
error_not_found                  A:982D
error_not_found_message          A:9852
errors_table                     A:9425
ex_input_aborted                 A:B544
execution_aborted_message        A:B530
execution_address_table          E:AD4B
exp_abs_val                      A:AC3D
exp_abs_val2                     A:AC55
exp_abs_val2_done                A:AC6C
exp_abs_val_done                 A:AC54
exp_add                          A:AAD4
exp_bitwise_and                  A:AB77
exp_bitwise_or                   A:AB62
exp_bitwise_xor                  A:AB8C
exp_divide                       A:ACDB
exp_divide_loop                  A:ACF8
exp_divide_not_zero              A:ACEB
exp_divide_subtraction_negative  A:AD20
exp_divide_subtraction_positive  A:AD21
exp_done                         A:9E4A
exp_done_error                   A:9E50
exp_done_ok                      A:9E55
exp_eql                          A:AB0E
exp_evaluation_function          S:007F
exp_false                        A:AB07
exp_falseJ                       A:ABA4
exp_find_sign                    A:AC76
exp_fix_sign                     A:AC8E
exp_fix_sign_done                A:ACA1
exp_geq                          A:AB5B
exp_get_operator                 A:9CA5
exp_get_operator_ok              A:9CAE
exp_get_precedence               A:9D13
exp_get_precedence_found         A:9D29
exp_get_precedence_loop          A:9D15
exp_greater_than                 A:AB3D
exp_high_byte                    A:AC34
exp_leq                          A:AB4C
exp_less_than                    A:AB36
exp_logical_and                  A:ABB6
exp_logical_or                   A:ABA7
exp_low_byte                     A:AC2F
exp_modulo                       A:AD3B
exp_multiply                     A:ACA2
exp_multiply_loop                A:ACA7
exp_multiply_no_add              A:ACC8
exp_negate                       A:ABFA
exp_negate_val                   A:AC41
exp_negate_val2                  A:AC59
exp_neq                          A:AB22
exp_no_operators_left            A:9E41
exp_not                          A:AC0D
exp_operator                     S:007D
exp_operator_precedence          S:007E
exp_operator_stack_count         S:007C
exp_pop_operator                 A:9C95
exp_pop_operator_ok              A:9C9E
exp_pop_value                    E:9C5A
exp_pop_value_ok                 A:9C63
exp_precedence_table             A:9CB3
exp_precedence_table_end         E:9D13
exp_push_operator                A:9C83
exp_push_operator_ok             A:9C8E
exp_push_value                   E:9C2F
exp_push_value_memory_full       A:9C35
exp_push_value_not_full          A:9C49
exp_push_value_ok                A:9C3A
exp_shift_left                   A:ABC8
exp_shift_left_done              A:ABE0
exp_shift_left_loop              A:ABD7
exp_shift_right                  A:ABE1
exp_shift_right_done             A:ABF9
exp_shift_right_loop             A:ABF0
exp_subtract                     A:AAE8
exp_true                         A:AAFE
exp_trueJ                        A:ABA1
exp_unary_minus                  A:AC1B
exp_unary_ok                     S:0081
exp_value_stack                  S:0079
exp_value_stack_count            S:007B
find_count                       S:00B9
find_delimiter                   S:00B4
find_flags                       S:00BD
find_from                        S:00B0
find_len                         S:00B3
find_line                        A:8C9D
find_line_eof                    A:8CD0
find_line_loop                   A:8CAB
find_line_next                   A:8CBA
find_line_same_line              A:8CC8
find_pos                         S:00B2
find_source_end                  A:8CD1
find_source_end_done             E:8CED
find_source_end_loop             E:8CD9
find_source_end_wrap             E:8CE7
find_string_too_long             A:8712
find_string_too_longJ            A:87B2
find_string_too_long_message     A:86F4
find_to                          S:00B1
found_message                    A:86C7
found_this_line                  S:00BB
from_line                        S:009E
from_msg                         A:86CF
gc_alpha_alpha_only              A:CA0C
gc_alpha_done                    A:CA08
gc_alpha_loop                    A:C9EF
gc_alpha_ok                      A:C9F7
gc_ampersand                     A:CE01
gc_assembler_comment_find_end    A:CC10
gc_assembler_comment_keep_looki  A:CC22
gc_assembler_comment_not_eof     A:CC1B
gc_assign                        A:CD9D
gc_backslash_tokens              A:CC2A
gc_backslash_tokens_end          E:CC40
gc_backslash_tokens_length       E:0016
gc_bang                          A:CE34
gc_bar                           A:CE12
gc_binary_literal                A:CD74
gc_binary_loop                   A:CD7C
gc_colon                         A:CD92
gc_comment_found_end             A:CBA9
gc_comment_keep_looking          A:CBA1
gc_comment_not_eof               A:CB89
gc_comment_not_newline           A:CB92
gc_directive_list                A:CBF1
gc_directive_nolist              A:CBFE
gc_directive_pcodes              A:CBF8
gc_directive_symbols             A:CBB9
gc_directive_symbols_ok          A:CBC5
gc_directive_symbols_too_late    A:CBEC
gc_dollar                        A:CD0E
gc_done                          A:C9D2
gc_equality                      A:CE2E
gc_equals                        A:CE23
gc_fix_hex                       A:CCD2
gc_fix_hex_not_a_to_f            A:CCDB
gc_geq                           A:CDD6
gc_greater_than                  A:CDC6
gc_hex_done                      A:CD5E
gc_hex_literal                   A:CD1A
gc_hex_loop                      A:CD23
gc_hex_too_big                   A:CD63
gc_inequality                    A:CE3F
gc_leq                           A:CDB7
gc_less_than                     A:CDA3
gc_lh_brace                      A:CB4D
gc_lh_paren                      A:CB51
gc_logical_and                   A:CE0C
gc_logical_or                    A:CE1D
gc_minus                         A:CDE0
gc_neq                           A:CDBC
gc_newline                       A:C9AF
gc_newline1                      A:C9BC
gc_newline_assembling            A:C9C9
gc_not_alpha                     A:CA15
gc_not_digit                     A:CA21
gc_not_space                     A:C9EA
gc_pascal_comment                A:CB5F
gc_pascal_comment_find_end       A:CB7E
gc_percent                       A:CD68
gc_plus                          A:CDE2
gc_quote                         A:CC40
gc_quote_backslash_loop          A:CCA9
gc_quote_bad                     A:CC57
gc_quote_bad_string              A:CCB4
gc_quote_copied_value            A:CC7C
gc_quote_done                    A:CC85
gc_quote_found_backslash_charac  A:CCBD
gc_quote_hex_character           A:CCDF
gc_quote_hex_character_done      A:CCB9
gc_quote_hex_character_one_only  A:CD0B
gc_quote_long_string             A:CC71
gc_quote_loop                    A:CC4E
gc_quote_loop_not_end_of_line    A:CC5C
gc_quote_not_backslash           A:CCC1
gc_quote_not_finished            A:CC97
gc_quote_too_long                A:CCCD
gc_semicolon                     A:CC07
gc_shift_left                    A:CDC1
gc_shift_right                   A:CDDB
gc_single_byte_already_known     A:C9CE
gc_single_byte_already_knownJ    A:CB4A
gc_single_byte_already_knownJ2   A:CDD3
gc_single_byte_token             A:C9D0
gc_single_byte_tokenJ            A:CB47
gc_skip_spaces                   A:C99A
gen_random                       A:9043
gen_random1                      A:9065
get_token                        A:C98C
get_token_loop                   A:C990
gtoken_directive_table           A:CB3A
gtoken_table                     A:CB09
handlerLookup                    A:8F73
handler_find_length              A:8F7B
handler_found_directive          A:8FA1
handler_found_length             A:8F84
handler_loop                     A:8F75
handler_next                     A:8F88
handler_same_length              A:8F98
handlers_done                    A:8FB1
hardware_init                    A:C925
hardware_work                    S:008C
i2c_begin_transmission           A:CFD7
i2c_begin_transmission_loop      A:CFDB
i2c_delay                        A:CFB8
i2c_end_transmission             A:D09A
i2c_init                         A:CFAD
i2c_read                         A:D044
i2c_read_ack_or_nak              A:D081
i2c_read_ack_or_nak_wait         A:D086
i2c_read_done                    A:D098
i2c_read_loop                    A:D04D
i2c_read_nak                     A:D07C
i2c_read_next                    A:D066
i2c_read_zero                    A:D062
i2c_receive_message              A:D0DC
i2c_receive_message_done         A:D0FF
i2c_receive_message_fail         A:D104
i2c_receive_message_loop         A:D0EA
i2c_send_message                 A:D0B3
i2c_send_message_done            A:D0D2
i2c_send_message_fail            A:D0D7
i2c_send_message_loop            A:D0BB
i2c_toggle_clock                 A:CFBC
i2c_toggle_clock_wait            A:CFC4
i2c_write                        A:CFFE
i2c_write_clock                  A:D018
i2c_write_clock_wait             A:D028
i2c_write_got_ack                A:D042
i2c_write_loop                   A:D001
i2c_write_lost_arbitration       A:D040
i2c_write_one                    A:D00D
id_equals_message                A:B65D
info_message                     A:A5BD
insert_limit                     S:00A4
introduction                     A:8255
irq                              A:B71D
irq1                             A:B72A
irq_done                         A:B7A2
is_xxx_fail                      A:8106
is_xxx_pass                      A:810A
isalnum                          E:8162
isalpha                          E:8126
isbin                            A:8176
isbinary                         E:816E
iscntrl                          E:8156
isdigit                          E:8132
islower                          E:811A
isspace                          E:814A
isupper                          E:810E
isxdigit                         E:813E
lcd_clear_display                A:B8E6
lcd_clear_enable                 A:B842
lcd_data_nibble                  A:B8A5
lcd_get_address                  A:B872
lcd_home                         A:B8F6
lcd_initialise                   A:B7A5
lcd_instruction                  A:B892
lcd_prepare_to_read_register     A:B7FE
lcd_prepare_to_write_data        A:B811
lcd_prepare_to_write_instructio  A:B826
lcd_print                        A:B907
lcd_print_char                   A:B8B4
lcd_print_char_newline           A:B8D5
lcd_print_char_ok                A:B8D5
lcd_print_char_on_2nd_line       A:B8CE
lcd_print_done                   A:B911
lcd_print_message                A:B8FE
lcd_print_not_newline            A:B8BF
lcd_read_instruction_nibble      A:B84B
lcd_second_line                  A:B8EE
lcd_set_enable                   A:B839
lcd_wait                         A:B857
lcd_wait_timeout                 A:B86E
lcd_work                         S:0086
lcd_write_instruction_nibble     A:B886
lcdbusy                          A:B85F
library_function_call            A:C710
library_function_call_1          A:C74C
library_function_call_2          A:C71D
library_function_call_3          A:C747
library_function_call_5          A:C74F
line_number_lt_1000              A:8C78
line_number_output_spaces        A:8C87
lines_deleted_message            A:8C54
list_symbols                     E:A5C8
list_symbols_check               E:A5E2
list_symbols_done                E:A61C
list_symbols_line                E:A5F1
list_symbols_name                E:A60B
list_symbols_next                E:A5D7
load_message                     A:8A08
m_alnum                          E:0080
m_alpha                          E:0004
m_cntrl                          E:0040
m_digit                          E:0008
m_lower                          E:0002
m_space                          E:0020
m_upper                          E:0001
m_xdigit                         E:0010
main_loop                        A:82E6
main_loop_not_run                A:8312
main_prompt                      A:82CC
main_start                       A:82C5
maths_work                       S:008D
mem_move_dest                    S:00A8
mem_move_len                     S:00AA
mem_move_src                     S:00A6
memory_filled_up                 A:8B76
memory_full                      A:8B5B
movedown                         A:817A
movedown1                        A:819D
movedown2                        A:8190
movedown_done                    A:819C
movedown_loop                    A:8186
moveup                           A:81A6
moveup3                          A:81D8
moveup_done                      A:81E4
moveup_loop                      A:81CE
moveup_next                      E:81E5
negate_token_value               A:CAF5
no_find_message                  A:874C
no_valid_compile_message         A:9391
notbin                           A:8178
number_bad_range_message         A:861C
number_expected_message          A:855F
number_too_large_message         A:85F3
opcode_lookup                    A:9B37
opcode_lookup_correct_length     A:9B62
opcode_lookup_correct_operand    A:9B90
opcode_lookup_loop               A:9B49
opcode_lookup_loop_done          A:9BA7
opcode_lookup_loop_unknown       A:9BDC
opcode_lookup_next_table         A:9B53
opcode_lookup_no_handler         A:9BA6
opcode_lookup_ok                 A:9BDF
p_equals_message                 A:B64D
partial_handler_Lookup           A:8FB6
partial_handler_done             A:8FFA
partial_handler_found_directive  A:8FE6
partial_handler_next             A:8FCF
partial_handler_next_found_item  A:8FD6
partial_handler_next_item        A:8FB8
partial_handler_next_loop        A:8FC0
partial_handler_skipped_string   A:8FED
pas_gc_identifier                A:CF44
pas_gc_loop                      A:CF4C
pas_gc_more                      A:CF55
pas_gc_no_match                  E:CF7D
pas_get_token                    A:CF3A
pas_get_token_eof                A:CF43
pascal_library_functions_table   A:C616
pcodes_ended_message             A:9348
pin_number_to_mask               E:C86A
pin_number_to_mask_done          A:C878
pin_number_to_mask_loop          A:C870
pinmode                          A:C87D
pinmode_B                        A:C88E
pinmode_C                        A:C896
pinmode_OUTPUT                   A:C8A4
prchar_not_control               A:9301
print                            A:8226
print_done                       A:824C
print_loop                       A:8234
print_not_abort                  A:8242
prompt                           A:829F
random                           S:0009
recover_done                     A:8E8C
recover_not_needed               A:8E92
rep_diff                         S:00B7
rep_from                         S:00B5
rep_to                           S:00B6
run_assembler                    A:93E0
running_message                  A:ADE9
s_equals_message                 A:B655
serial_available                 E:C91F
serial_in_byte                   S:008A
serial_in_byte_received          S:008B
serial_in_loop                   A:B74E
serial_out_bit                   S:0089
serial_out_byte                  S:0087
serial_print                     A:C981
serial_print_done                A:C98B
serial_print_message             A:C97B
serial_send_count_bits           A:B793
show_current_line                A:9862
show_current_line_done           A:98A7
show_current_line_loop           A:9884
show_current_line_loop_print_on  A:989C
show_current_line_number         A:8C5F
show_current_line_number_done    A:8C93
show_source_end                  A:8F33
show_source_start                A:8F5B
show_symbol_table_end            A:8F0E
show_symbols                     S:0082
source_ended_message             A:8F20
source_length_message            A:90D4
source_starts_message            A:8F48
stack_message                    A:B712
str_compare                      A:81F0
str_compare_done                 A:81FE
str_ic_compare                   A:8201
str_ic_compare_done              A:8223
str_ic_compare_fixed_dest        A:821E
str_ic_compare_fixed_srce        A:8210
str_work                         S:0085
symbol_table_ended_message       A:9379
symbol_table_message             A:8DB7
system_flags                     S:00BE
this_line                        S:00AC
this_line_addr                   S:00AE
timer1_interrupt                 A:B773
to_line                          S:00A0
to_msg                           A:86D6
token_address                    S:0090
token_digit                      S:009B
token_length                     S:0092
token_line                       A:CA2C
token_line1                      A:CA32
token_line_done                  A:CA7A
token_line_listing               A:CA4D
token_line_loop                  A:CA65
token_line_loop1                 A:CA75
token_line_start                 S:009C
token_sign                       S:0097
token_start                      S:008E
token_type                       S:0093
token_value                      S:0094
token_work                       S:0098
too_much_on_line                 A:8635
typing_latency                   S:000D
write_char                       A:C956
write_char_loop                  A:C972
write_function                   S:0017
write_to_lcd                     A:C903
write_to_serial                  A:C8F8
write_zero                       A:B78E
wtf_loop                         A:9BCB
x_equals_message                 A:B63D
y_equals_message                 A:B645

Symbols by value:
0000 EMULATOR
0000 OPCODE_LOOKUP_OPCODE_LENGTH
0000 PCODE_LIT
0000 REG
0000 SERIAL_DEBUGGING
0000 SRCE
0000 SYMPRV
0000 VALUE
0000 VIA_FLAG_DISABLE
0000 crc_addr
0001 ASS_OPERAND_ABSOLUTE
0001 EFLAG_SHOW_LINE
0001 FFLAG_IGNORE_CASE
0001 FLAG_COMPILING
0001 LCD_SUPPORT
0001 OPCODE_LOOKUP_OPERAND_TYPE
0001 PCODE_STACK
0001 m_upper
0002 ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
0002 EFLAG_ALLOW_ZERO_FROM
0002 FFLAG_GLOBAL
0002 FLAG_ASSEMBLING
0002 OPCODE_LOOKUP_OPCODE_TABLE
0002 PCODE_NEG
0002 REGB
0002 SERIAL_OUT_MASK
0002 SYMLVL
0002 m_lower
0003 ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
0003 DEST
0003 KEY_ABORT
0003 PCODE_LIB_CALL
0003 REG2
0003 SYMTYP
0003 VALUE2
0003 crc_num
0004 ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
0004 EFLAG_LOAD
0004 FFLAG_QUIET
0004 FLAG_LIST_SOURCE
0004 I2C_SCL
0004 KEY_DEBUG
0004 OPCODE_LOOKUP_HANDLER
0004 PCODE_ADD
0004 SERIAL_DEBUG1_MASK
0004 SYMDSP
0004 m_alpha
0005 ASS_OPERAND_ABSOLUTE_INDIRECT
0005 REG2B
0006 ASS_OPERAND_ACCUMULATOR_A
0006 OPCODE_LOOKUP_TABLE_SIZE
0006 PCODE_SUB
0006 REMAIN
0006 SYMARG
0006 SYMSUB
0006 crc_val
0007 ASS_OPERAND_IMMEDIATE
0008 ASS_OPERAND_IMPLIED
0008 BACKSPACE
0008 EFLAG_SAVE
0008 FLAG_VALID_COMPILE
0008 I2C_SDA
0008 PCODE_MUL
0008 SERIAL_DEBUG2_MASK
0008 SYMDAT
0008 VIA_FLAG_CB2
0008 m_digit
0009 SYMLEN
0009 random
000A NL
000A PCODE_DIV
000A SYMNAM
000B ASS_OPERAND_ZERO_PAGE
000B PCODE_MOD
000C ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
000C PCODE_ADRNN
000D ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
000D CR
000D typing_latency
000E ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
000E KEY_STOP_TRACE
000E PCODE_ADRAN
000F ASS_OPERAND_ZERO_PAGE_INDIRECT
0010 ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
0010 EFLAG_FIND
0010 FLAG_VALID_ASSEMBLE
0010 PCODE_EQL
0010 SERIAL_SPARE2_MASK
0010 call_a
0010 m_xdigit
0011 ASS_OPERAND_STRING
0011 PCODE_FINISHD
0011 call_x
0012 ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE
0012 PCODE_NEQ
0012 call_y
0013 call_p
0014 KEY_TRACE
0014 PCODE_LSS
0014 call_s
0015 brk_address
0016 PCODE_GEQ
0016 gc_backslash_tokens_length
0017 write_function
0018 PCODE_GTR
0019 LINE_CNT
0019 PCODE_LEQ
001A PCODE_ORR
001B END_EDITOR_INPUT
001B PCODE_AND
001C PCODE_INP
001D LIST
001E PCODE_OUT
001F PCODE_OUTC
0020 EFLAG_REPLACE
0020 FRAME
0020 LCD_RS
0020 MAX_STK
0020 PCODE_EOR
0020 m_space
0021 PCODE_OUH
0022 LEVEL
0022 PCODE_SHL
0022 TOKEN_STRING
0023 PCODE
0023 PCODE_OUS
0023 SERIAL_DELAY2
0024 PCODE_SHR
0025 ACT_PCDA
0025 PCODE_INS
0026 PCODE_INC
0027 DISPL
0027 PCODE_CLL
0027 SINGLE_QUOTE
0028 PCODE_DEC
0029 OFFSET
0029 PCODE_RTN
002A PCODE_MOV
002B OPND
002B PCODE_CLA
002C PCODE_LOD
002E DCODE
002E PCODE_LDA
002F STARTSYM
0030 PCODE_LDI
0030 SERIAL_DELAY1
0031 ENDSYM
0031 T
0032 PCODE_STO
0033 WORKD
0034 PCODE_STA
0035 ERRNO
0036 BSAVE
0036 PCODE_STI
0037 WORK
0038 PCODE_ABSCLL
0039 PRCITM
003A PCODE_XOR
003B BASE
003B PCODE_INT
003C PCODE_JMP
003D DATA
003D PCODE_JMZ
003E PCODE_JM1
003F RUNNING
0040 EFLAG_SUPPRESS_NEWLINE
0040 FLAG_ONLY_ALPHA
0040 FROM
0040 LCD_RW
0040 PCODE_OUTCR
0040 SYMITM
0040 VIA_FLAG_TIMER1
0040 m_cntrl
0041 SYMBOL_ARRAY
0041 TOKEN_ASSIGN
0042 PCODE_LCD_WRITE_NUM
0042 SYNTAX
0043 END_PCD
0043 PCODE_LCD_WRITE_STR
0043 SYMBOL_CONSTANT
0044 PCODE_LCD_WRITE_HEX
0045 PCODE_LAST
0045 PCODE_LCD_WRITE_CHR
0045 TEMP
0045 TOKEN_EQUALITY
0046 SYMBOL_FUNCTION
0047 CALL
0049 DBGFLG
0049 TOKEN_IDENTIFIER
004A DATTYP
004B COUNT1
004C COUNT2
004C TOKEN_SHIFT_LEFT
004D LASTP
004D TOKEN_UNARY_MINUS
004E TOKEN_NUMBER
0050 SYMBOL_PROCEDURE
0051 SYMBOL_LIBRARY_PROCEDURE
0052 RES
0052 SYMBOL_LIBRARY_FUNCTION
0052 TOKEN_SHIFT_RIGHT
0055 MCAND
0055 TOKEN_NEQ
0056 SYMBOL_VARIABLE
0056 TOKEN_LOW_BYTE
0057 TOKEN_HIGH_BYTE
0058 TOKEN_LOGICAL_AND
0059 SYMBOL_FUNCTION_RETURN
0059 TOKEN_LOGICAL_OR
005A TOKEN_INEQUALITY
005B RMNDR
005C bcd_work
0060 bcd_result
006B ASS_OPERAND
006C OPCODE
006E OPCODE_LEN
006F ASS_EMIT_COUNT
0070 ASS_OPCODE_WORK
0072 ASS_COUNT
0073 ASS_VALUE
0076 ASS_PASS
0077 ass_emit_bytes
0079 exp_value_stack
007B exp_value_stack_count
007C exp_operator_stack_count
007D exp_operator
007E exp_operator_precedence
007F exp_evaluation_function
0080 EFLAG_NO_LINE_NUMBERS
0080 FLAG_ABORTED
0080 LCD_E
0080 TOKEN_LEQ
0080 VIA_FLAG_ENABLE
0080 m_alnum
0081 TOKEN_GEQ
0081 exp_unary_ok
0082 TOKEN_CONST
0082 show_symbols
0083 TOKEN_VAR
0083 ass_current_label
0084 TOKEN_ARRAY
0085 TOKEN_OF
0085 str_work
0086 TOKEN_PROCEDURE
0086 lcd_work
0087 TOKEN_FUNCTION
0087 serial_out_byte
0088 TOKEN_BEGIN
0089 TOKEN_END
0089 serial_out_bit
008A TOKEN_OR
008A serial_in_byte
008B TOKEN_DIV
008B serial_in_byte_received
008C TOKEN_MOD
008C hardware_work
008D TOKEN_AND
008D maths_work
008E TOKEN_SHL
008E token_start
008F TOKEN_SHR
0090 TOKEN_NOT
0090 token_address
0091 TOKEN_MEM
0092 TOKEN_IF
0092 token_length
0093 TOKEN_THEN
0093 token_type
0094 TOKEN_ELSE
0094 token_value
0095 TOKEN_CASE
0096 TOKEN_WHILE
0097 TOKEN_DO
0097 token_sign
0098 TOKEN_REPEAT
0098 token_work
0099 TOKEN_UNTIL
009A TOKEN_FOR
009B TOKEN_TO
009B token_digit
009C TOKEN_DOWNTO
009C token_line_start
009D TOKEN_WRITE
009E TOKEN_READ
009E from_line
009F TOKEN_CALL
00A0 to_line
00A1 TOKEN_CHAR
00A2 TOKEN_MEMC
00A2 current_line
00A4 TOKEN_XOR
00A4 insert_limit
00A6 mem_move_src
00A8 mem_move_dest
00A9 TOKEN_ADDRESS
00AA mem_move_len
00AB TOKEN_CHR
00AC TOKEN_HEX
00AC this_line
00AE this_line_addr
00B0 find_from
00B1 find_to
00B2 find_pos
00B3 find_len
00B4 find_delimiter
00B5 rep_from
00B6 rep_to
00B7 rep_diff
00B9 find_count
00BB found_this_line
00BC editor_flags
00BD find_flags
00BE system_flags
00D0 BIT_INTERVAL
00F1 TOKEN_LCDWRITE
00FE TOKEN_INTEGER
00FF NEW_STK
00FF TOKEN_WRITELN
0100 INBUF_SIZE
0200 INBUF
0300 TEXT_START
12C0 BAUD_RATE
3FFF HIGHEST_RAM
3FFF SYMBOL_TABLE_START
7FF0 VIA_PORTB
7FF1 I2C_PORT
7FF1 VIA_PORTA
7FF2 VIA_DDRB
7FF3 I2C_DDR
7FF3 VIA_DDRA
7FF4 VIA_T1C_L
7FF5 VIA_T1C_H
7FFB VIA_ACR
7FFC VIA_PCR
7FFD VIA_IFR
7FFE VIA_IER
8000 START_OF_ROM
8006 character_types_table
8106 is_xxx_fail
810A is_xxx_pass
810E isupper
811A islower
8126 isalpha
8132 isdigit
813E isxdigit
814A isspace
8156 iscntrl
8162 isalnum
816E isbinary
8176 isbin
8178 notbin
817A movedown
8186 movedown_loop
8190 movedown2
819C movedown_done
819D movedown1
81A6 moveup
81CE moveup_loop
81D8 moveup3
81E4 moveup_done
81E5 moveup_next
81F0 str_compare
81FE str_compare_done
8201 str_ic_compare
8210 str_ic_compare_fixed_srce
821E str_ic_compare_fixed_dest
8223 str_ic_compare_done
8226 print
8234 print_loop
8242 print_not_abort
824C print_done
8255 introduction
829F prompt
82A2 bad_command
82C5 main_start
82CC main_prompt
82E6 main_loop
8312 main_loop_not_run
8330 editor_handlers
83BE editor_help_info
8533 editor_help
853E editor_help_loop
854F editor_help_done
8552 editor_default_range
855F number_expected_message
8570 editor_bad_number
857A editor_get_number
85BC editor_get_number_not_identifier
85D2 editor_get_number_ok
85E2 editor_get_number_done
85E4 editor_get_number_none
85E6 editor_get_number_end
85F3 number_too_large_message
8612 editor_line_number_too_big
861C number_bad_range_message
862B editor_bad_range
8635 too_much_on_line
8658 editor_check_no_more
865A editor_check_no_more_loop
866A editor_check_no_more_failed
8674 editor_check_no_more_ok
8675 editor_get_range
86AB editor_get_range_hyphen
86B0 editor_get_range_number
86C3 editor_get_range_done
86C4 editor_bad_rangeJ
86C7 found_message
86CF from_msg
86D6 to_msg
86DB bad_delimiter_message
86EA editor_bad_delimiter
86EE editor_find_problem
86F4 find_string_too_long_message
8712 find_string_too_long
8718 editor_get_delimiter
8730 editor_no_closing_delimiter_message
8746 editor_no_closing_delimiter
874C no_find_message
8761 editor_no_find_string
8767 editor_replace
876F editor_find
8775 editor_save
877B editor_list
87A1 editor_list_doing_find
87AD editor_find_bug
87B2 find_string_too_longJ
87B5 editor_no_closing_delimiterJ
87B8 editor_list_got_from_point
87BA editor_find_second_delimiter_loop
87E1 editor_find_third_delimiter_loop
8807 editor_find_get_flags
8809 editor_flags_loop
8827 editor_flags1
8831 editor_flags2
883B editor_flags3
8845 bad_flag_message
8853 editor_list_fix_target_string
885B editor_list_fixup_loop
886B editor_list_not_find
886E editor_list_get_on_with_it
887F editor_list_have_source
8885 editor_list_doneJ
8888 editor_list_no_line_numberJ
888B editor_list_loop
88B2 editor_list_aborted
88BF editor_find_or_replacing
88C1 editor_replacement_loop
88C3 editor_find_loop
88C7 editor_find_inner_loop
88DE editor_find_case_sensitive
88DF editor_find_test_character
88E8 editor_find_skip_this
88EC editor_find_no_match
8902 editor_find_found_it
8908 editor_find_found_it1
8920 editor_do_the_replace
892D editor_easy_replace
8931 editor_easy_replace_loop
893E editor_easy_replace_done
894F editor_list_not_finding
895C editor_list_no_line_number
8964 editor_newline_processing
896E editor_list_check_to_line
897E editor_list_check_to_line_ok
8986 editor_list_not_newline
8991 editor_list_skip_newline
8997 editor_list_loopJ
899A editor_list_done
89B7 editor_list_completely_done
89BA editor_do_replace
89FC editor_do_replace_smaller
89FF editor_do_replace_copy_done
8A08 load_message
8A2A editor_load
8A2E editor_insert
8A48 editor_insert_at_start
8A56 editor_insert_common
8A99 editor_insert_loop
8AAA editor_insert_no_line_number
8AC9 editor_insert_not_newline
8AD2 editor_insert_loop1
8AE2 editor_insert_backspace
8AEE editor_insert_backspace_not_at_start
8B04 editor_insert_done
8B15 editor_insert_done_with_newline
8B30 editor_too_full
8B37 editor_too_full_loop
8B48 editor_no_lines
8B5B memory_full
8B76 memory_filled_up
8B9F editor_argument_check
8BA1 editor_argument_check_loop
8BB1 editor_argument_check_failed
8BBB editor_argument_check_got_argument
8BBC editor_delete
8C0A editor_delete_line_count_loop
8C16 editor_delete_line_count_not_done
8C22 editor_delete_line_count_not_newline
8C2A editor_delete_line_count_done
8C54 lines_deleted_message
8C5F show_current_line_number
8C78 line_number_lt_1000
8C87 line_number_output_spaces
8C93 show_current_line_number_done
8C9D find_line
8CAB find_line_loop
8CBA find_line_next
8CC8 find_line_same_line
8CD0 find_line_eof
8CD1 find_source_end
8CD9 find_source_end_loop
8CE7 find_source_end_wrap
8CED find_source_end_done
8CEE brk_resumed
8D02 editor_test
8D14 editor_memory
8D2E editor_memory_loop
8D4F editor_memory_loop1
8D61 editor_memory_loop2
8D77 editor_memory_loop3
8D87 editor_memory_done
8D8A editor_memory_aborted
8D90 editor_memory_show_ascii
8D92 editor_memory_ascii
8D9A editor_memory_not_control
8D9E editor_memory_show_dot
8DA0 editor_memory_not_high
8DB7 symbol_table_message
8DE9 ST_SYMTBL_LIST_NEXT
8DF4 ST_SYMTBL_LIST_CHECK
8E03 ST_SYMTBL_LIST_LINE
8E78 ST_SYMTBL_LIST_NAME
8E89 ST_SYMTBL_LIST_DONE
8E8C recover_done
8E92 recover_not_needed
8E9E editor_recover
8EBD editor_recover_not_needed
8EC7 editor_debug
8ED3 editor_trace
8EDF editor_info
8EEE editor_compile
8EF8 editor_syntax
8F02 editor_run
8F0E show_symbol_table_end
8F20 source_ended_message
8F33 show_source_end
8F48 source_starts_message
8F5B show_source_start
8F6D editor_assemble
8F73 handlerLookup
8F75 handler_loop
8F7B handler_find_length
8F84 handler_found_length
8F88 handler_next
8F98 handler_same_length
8FA1 handler_found_directive
8FB1 handlers_done
8FB3 call_handler
8FB6 partial_handler_Lookup
8FB8 partial_handler_next_item
8FC0 partial_handler_next_loop
8FCF partial_handler_next
8FD6 partial_handler_next_found_item_length
8FE6 partial_handler_found_directive
8FED partial_handler_skipped_string
8FFA partial_handler_done
8FFB TKNJMP
9003 JMP1
900B JMP2
9020 JMP3
902D MAKE_UPPER
9037 MAKE_UPPER_DONE
9042 MAKE_LOWER_DONE
9043 gen_random
9065 gen_random1
9066 crc16
9072 crc16_loop
907F crc16_next
9085 crc16_skip
908D crc_done
908E crc_byte
90BE crc_helper1
90C1 crc_message
90D4 source_length_message
90E4 bytes_message
90EC crc_source
9134 delay_1ms
9137 delay_1ms_loop
913E delay
9148 bcd_unpack
915B bcd_table
91BB display_in_decimal
91C7 bcd_positive
91CE bcd_skip_zeroes
91D9 bcd_output_digit
91E4 binary_to_decimal
91EF binary_to_decimal_loop
9214 binary_to_decimal_next
9232 NOSCE
9243 INIT
924F INIT_SECOND_PASS
9290 INIT9
9291 CROUT
9296 COMSTL
92A2 COMS9
92A3 COMS8
92A6 DISHX
92AC DISPAD
92C7 DISPAD2
92C8 PSHWRK
92DA PSH9
92DB PULWRK
92EE PRCHAR
9301 prchar_not_control
9306 PRBYTE
930F PRHEX
9311 PRHEXZ
9319 PRHEX1
931C PUTSP
9320 PT
9328 PT6
9332 TKNWRK
933D WRKTKN
9348 pcodes_ended_message
935B compile_finished_message
9379 symbol_table_ended_message
9391 no_valid_compile_message
93BB PRBYTECR
93C1 CHK_VAL
93D3 CHK_VAL9
93D4 CHK_RUN
93E0 run_assembler
93E6 call_assembler
93F0 GETLN1
93F0 GET_LINE
93F2 GET1
940F GET3
9415 GETLN_OVERFLOW
9418 COUT
9422 COUT_CALL
9425 errors_table
9787 assertion_failed_message
97C1 ERRLIT
97CD ERROR
97D6 ERR7
97E0 ERR1
97F4 ERR3
9804 ERR5
980A ERR6
9816 error_next
9817 error_loop
981B error_find_next
9824 error1
982D error_not_found
9845 error_found
9852 error_not_found_message
9862 show_current_line
9884 show_current_line_loop
989C show_current_line_loop_print_one_character
98A7 show_current_line_done
98AB ASSEMBLE
98B8 ASSEMBLE_SECOND_PASS
98BD ASSEMBLE_PASS
98D7 ass_finish_line
98E2 ass_done_jump
98E5 ass_line
98F4 ass_line1
9920 ass_bad_identifier
9925 ass_identifier
994F ass_lookup_existing_label
9959 ass_lookup_save_address
9965 ass_added_symbol
9977 ass_not_colon
997E ass_not_colon2
9986 ass_illegal_opcode
998E ass_opcode
99CF ass_check_label_changed
99DF ass_symbol_address_changed
99E4 ass_opcode2
99F5 ass_finish_lineJ
99F8 ass_operand
9A0A ass_string
9A17 ass_immediate
9A2A ass_indirect
9A33 ass_identifier_operand
9A54 ass_operand_value
9A8C ass_value_not_indirectJ
9A8F ass_bad_indirect
9A94 ass_indirect_with_bracket
9AA8 ass_zp_indirect_indexed
9AC9 ass_bad_zp_indirect_indexed
9ACE ass_not_x_or_y
9AD0 ass_check_we_have_x_or_y
9AEC ass_check_we_have_x_or_y_ok
9AEE ass_value_not_indirect
9AF8 ass_value_done
9B01 ass_indexed
9B1F ass_indexed_x
9B28 ass_absolute_another_value
9B37 opcode_lookup
9B49 opcode_lookup_loop
9B53 opcode_lookup_next_table
9B62 opcode_lookup_correct_length
9B90 opcode_lookup_correct_operand
9BA6 opcode_lookup_no_handler
9BA7 opcode_lookup_loop_done
9BCB wtf_loop
9BDC opcode_lookup_loop_unknown
9BDF opcode_lookup_ok
9BE0 ass_done
9BEA ass_done_second_pass
9C02 ass_done1
9C05 ass_done_message
9C23 ass_check_no_more_tokens
9C2E ass_check_no_more_tokens_ok
9C2F exp_push_value
9C35 exp_push_value_memory_full
9C3A exp_push_value_ok
9C49 exp_push_value_not_full
9C5A exp_pop_value
9C63 exp_pop_value_ok
9C83 exp_push_operator
9C8E exp_push_operator_ok
9C95 exp_pop_operator
9C9E exp_pop_operator_ok
9CA5 exp_get_operator
9CAE exp_get_operator_ok
9CB3 exp_precedence_table
9D13 exp_get_precedence
9D13 exp_precedence_table_end
9D15 exp_get_precedence_loop
9D29 exp_get_precedence_found
9D3A ass_get_value
9D54 ass_expression_loop
9D57 ass_expression_loop_initial
9D5B ass_expression_number
9D6E ass_expression_loop1a
9D80 ass_expression_not_small_string
9D85 ass_expression_loop1
9D99 ass_label_not_found_yet
9DA1 ass_expression_found_value
9DB2 ass_expression_loop2
9DC1 ass_expression_loop3
9DC5 ass_expression_loop3b
9DD0 ass_expression_loop3a
9DD5 ass_expression_loop3c
9DD8 ass_expression_loopJ
9DDB ass_expression_loop4
9DE9 ass_not_unary_minus
9DF3 ass_not_unary_less_than
9DFD ass_not_unary_greater_than
9E13 ass_expression_cannot_be_unary
9E22 ass_expression_loop7
9E39 ass_expression_loop6
9E41 exp_no_operators_left
9E4A exp_done
9E50 exp_done_error
9E55 exp_done_ok
9E67 ass_expression_apply_operator
9E90 ass_expression_unary
9EA3 ass_expression_apply_operator_bug
9EA8 ass_evaluate_operator
9EAB ass_lookup_loop
9EC9 ass_opcode_found
9ECF ass_emit
9EE3 ass_emit2
9EF2 ass_already_emitted
9EFD ass_emit4
9F04 ass_emit3
9F0A ass_emit1
9F0D ass_error
9F14 ass_error1
9F17 ass_fixup_bbr_branch
9F24 ass_fixup_branch
9F3D ass_branch_backwards
9F41 ass_branch_ok
9F47 ass_branch_out_of_range
9F50 ass_emit_zero_page
9F5E ass_emit_zero_page_too_high
9F63 ass_emit_immediate
9F71 ass_emit_immediate_too_high
9F76 ass_emit_absolute
9F81 OPCODE_LOOKUP_TABLE
A024 DIRECTIVES
A097 OPCODE_4_CHAR_BRANCH
A0E8 OPCODE_3_CHAR_BRANCH
A10D OPCODE_3_CHAR_IMPLIED
A18A OPCODE_4_CHAR_ZERO_PAGE
A1DB OPCODE_ASS_OPERAND_ABSOLUTE
A244 OPCODE_ASS_OPERAND_ABSOLUTE_TOKENISED
A247 OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
A24C OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
A291 OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X_TOKENISED
A294 OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
A2B9 OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y_TOKENISED
A2BC OPCODE_ASS_OPERAND_ACCUMULATOR_A
A2D5 OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT
A2DA OPCODE_ASS_OPERAND_IMMEDIATE
A30B OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED
A30E OPCODE_ASS_OPERAND_ZERO_PAGE
A36F OPCODE_ASS_OPERAND_ZERO_PAGE_TOKENISED
A372 OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
A393 OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT_TOKENISED
A396 OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
A3DF OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X_TOKENISED
A3E2 OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
A3EB OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT
A40C OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_TOKENISED
A40F OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
A430 OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y_TOKENISED
A433 asm_do_assert
A442 asm_do_assert_failed
A447 asm_do_constant_expectedJ
A44A asm_do_list
A459 asm_do_nolist
A464 asm_do_nolist_ok
A46A asm_do_list_no_operand
A46E asm_do_list_ok
A484 asm_do_list_not
A488 asm_do_list1
A497 asm_do_list_first_pass
A498 asm_do_asc
A4A3 asm_do_asc_ok
A4A5 asm_do_asc_loop
A4AE asm_do_asc_next
A4B3 asm_do_string
A4BC asm_do_equ
A4CD asm_do_equ_have_label
A4D9 asm_do_org
A4DF asm_do_constant_expected
A4E4 asm_do_org_ok
A4ED asm_do_dfb
A4FB asm_do_dfb_multiple
A508 asm_do_dfb_multiple_loop
A519 asm_do_dfb_multiple_done
A51A asm_do_dfb_too_big
A51F asm_emit_one_byte
A52D asm_do_dfw
A53B asm_do_dfw_multiple
A549 asm_do_dfw_multiple_loop
A55A asm_do_dfw_multiple_done
A55B asm_emit_two_bytes
A56A asm_do_blk
A57A asm_do_blk_loop
A587 asm_do_blk_done
A588 asm_do_reserve
A5A0 asm_do_constant_expectedJ2
A5A3 asm_do_sym
A5BC asm_do_sym_done
A5BD info_message
A5C8 list_symbols
A5D7 list_symbols_next
A5E2 list_symbols_check
A5F1 list_symbols_line
A60B list_symbols_name
A61C list_symbols_done
A61D assembler_library_functions_table
AA89 add_assembler_library_functions
AA91 add_assembler_library_functions_loop
AAA1 add_assembler_library_functions_name_loop
AAD3 add_assembler_library_functions_done
AAD4 exp_add
AAE8 exp_subtract
AAFE exp_true
AB07 exp_false
AB0E exp_eql
AB22 exp_neq
AB36 exp_less_than
AB3D exp_greater_than
AB4C exp_leq
AB5B exp_geq
AB62 exp_bitwise_or
AB77 exp_bitwise_and
AB8C exp_bitwise_xor
ABA1 exp_trueJ
ABA4 exp_falseJ
ABA7 exp_logical_or
ABB6 exp_logical_and
ABC8 exp_shift_left
ABD7 exp_shift_left_loop
ABE0 exp_shift_left_done
ABE1 exp_shift_right
ABF0 exp_shift_right_loop
ABF9 exp_shift_right_done
ABFA exp_negate
AC0D exp_not
AC1B exp_unary_minus
AC2F exp_low_byte
AC34 exp_high_byte
AC3D exp_abs_val
AC41 exp_negate_val
AC54 exp_abs_val_done
AC55 exp_abs_val2
AC59 exp_negate_val2
AC6C exp_abs_val2_done
AC6D ZERRES
AC76 exp_find_sign
AC8E exp_fix_sign
ACA1 exp_fix_sign_done
ACA2 exp_multiply
ACA7 exp_multiply_loop
ACC8 exp_multiply_no_add
ACDB exp_divide
ACEB exp_divide_not_zero
ACF8 exp_divide_loop
AD20 exp_divide_subtraction_negative
AD21 exp_divide_subtraction_positive
AD3B exp_modulo
AD4B execution_address_table
ADD7 DM1
ADE0 DM2
ADE9 running_message
ADF2 DB11
ADF2 DEBUG
AE5A DEBUG_DONE
AE5B INTERP
AE81 DM5
AE96 DM6
AEA1 DM7
AEBB display_x_characters
AEC2 DIS5
AECC DIS5_A
AED9 BELL1
AEE3 RUNERR
AEF7 EX_FINISHD
AF0E FIN_MSG
AF2D CHK_KBD
AF39 CHK_NOTN
AF47 CHK_NOTT
AF55 CHK_NOTD
AF57 EX_OUTCR
AF5D LOWLIT
AF63 LOWLIT1
AF69 MAINP
AF6C MAIN
AF73 MAIN_2
AF7E MAIN_NOT_ABORT
AF81 MAIN_OK
AF9B MAIN_1
AFAA EX_INVINS
AFAE NOTIM1
AFBB GETADR
AFC5 GET2
AFE6 GETADR1
B001 GET1_A
B002 PULTOP
B01D PUL_END
B024 PULBOTH
B027 PULTOP2
B042 PUL2_END
B049 PSHTOP
B054 PSH1
B065 GETLIT
B07B GET_END
B07C EX_LIT
B08B LIT1
B08E EX_NEG
B097 EX_ADD
B0A0 EX_SUB
B0AC EX_MUL
B0B5 EX_GETKEY
B0BC EX_MOD
B0D0 EX_DIVIDE_BY_ZERO
B0D7 DIVBY0
B0E7 EX_DIV
B0FB EX_ABS
B104 EX_EQL
B10D TRUE
B10F TRUE2
B11A FALSE
B11E EX_NEQ
B127 EX_LSS
B133 EX_GTR
B13F EX_GEQ
B14B EX_LEQ
B157 EX_XOR
B160 EX_ORR
B169 EX_AND
B172 EX_EOR
B17B EX_SHL
B187 EX_SHR
B193 EX_INC
B1AB EX_DEC
B1C3 EX_MOV
B1D4 EX_LODC
B1D7 EX_LOD3
B1D9 EX_LOD3_A
B1E6 EX_LOD
B1E9 EX_LOD2
B1FC EX_LDAC
B207 EX_LDA
B211 GETIDC
B21A GETIDX
B22E GETID2
B23C EX_LDIC
B242 EX_LDI
B248 EX_STOC
B250 EX_STO5
B255 EX_STO
B25B EX_STO2
B268 EX_STA
B279 EX_STA5
B27E EX_STAC
B287 EX_STIC
B295 EX_STI
B2B0 EX_RTN
B2E9 EX_INP
B2FA EX_INP_OK
B311 INP3
B321 BAD_INP
B329 EX_OUT
B32E EX_LCD_WRITE_NUM
B331 OUT_COMMON
B33D EX_OUH
B342 EX_LCD_WRITE_HEX
B345 EX_OUH_COMMON
B35D EX_OUS
B362 EX_LCD_WRITE_STR
B365 EX_OUS_COMMON
B381 EX_OUS1
B390 EX_ABSCLL
B397 EX_CLL
B39F EX_CLL_A
B3BD EX_CLL4
B3C1 EX_CLL2
B3E2 EX_CLL3
B423 EX_CLL5
B426 EX_CLA
B443 EX_CLL_JMP
B446 EX_INT
B45D INT_ERR
B464 INT_ERRM
B470 EX_NEW_STACK
B482 EX_JMP
B495 EX_JMZ
B4A0 EX_NOJUMP
B4A6 EX_JM1
B4B1 EX_INPC
B4BB EX_INPC_OK
B4CB EX_OUTC
B4D0 EX_LCD_WRITE_CHR
B4D3 EX_OUTC_COMMON
B4E1 EX_LCDHOME
B4E7 EX_LCDCLEAR
B4ED EX_INS
B4F7 EX_INS3
B510 EX_INS1
B519 EX_INS2
B523 EX_INS4
B530 execution_aborted_message
B544 ex_input_aborted
B54B EX_ADRNC
B54E EX_ADRNC2
B55B EX_ADRNN
B55E EX_ADRN2
B569 EX_ADRAN
B56F EX_ADRAC
B575 EX_DIGITALREAD
B580 EX_DIGITALREAD_ONE
B583 EX_LCDPOS
B593 EX_LCDPOS_1
B59D EX_RANDOM
B5AF EX_LATENCY
B5BE EX_DELAY
B5CE EX_RANDOMSEED
B5DE EX_PINMODE
B5ED EX_DIGITALWRITE
B5FC EX_LIB_CALL
B602 EX_ASSERT
B617 EX_ASSERT_OK
B61A break_message
B635 a_equals_message
B63D x_equals_message
B645 y_equals_message
B64D p_equals_message
B655 s_equals_message
B65D id_equals_message
B666 brk_executed
B6E1 brk_executed1
B6EE brk_executed2
B6FE brk_executed3
B712 stack_message
B71A brk_executedJ
B71D irq
B72A irq1
B742 cb2_interrupt
B74E serial_in_loop
B773 timer1_interrupt
B78E write_zero
B793 serial_send_count_bits
B7A2 irq_done
B7A5 lcd_initialise
B7FE lcd_prepare_to_read_register
B811 lcd_prepare_to_write_data
B826 lcd_prepare_to_write_instruction
B839 lcd_set_enable
B842 lcd_clear_enable
B84B lcd_read_instruction_nibble
B857 lcd_wait
B85F lcdbusy
B86E lcd_wait_timeout
B872 lcd_get_address
B886 lcd_write_instruction_nibble
B892 lcd_instruction
B8A5 lcd_data_nibble
B8B4 lcd_print_char
B8BF lcd_print_not_newline
B8CE lcd_print_char_on_2nd_line
B8D5 lcd_print_char_newline
B8D5 lcd_print_char_ok
B8E6 lcd_clear_display
B8EE lcd_second_line
B8F6 lcd_home
B8FE lcd_print_message
B907 lcd_print
B911 lcd_print_done
B912 SEARCH
B91A SEA_NEXT
B925 SEA1
B932 SEA2
B97B SEA4
B983 SEA5
B986 SEA3
B989 SYM_FULL
B98E ADDSYM
B9C3 ADDSYM_NOT_FULL
B9EA ADD1
BA0D ADD4
BA29 ADD9
BA2A LOOKUP
BA34 LOOK1
BA35 CHKDUP
BA44 DUP9
BA45 COMPIL
BA93 END_CMP
BA96 CHKLHP
BA9D CHKRHP
BAA7 GETSUB
BAB0 CHKLHB
BABA CHKRHB
BAC4 GET_LEV
BACE GET_DAT
BAD5 CONDEC
BB00 SYMWRK
BB0B WRKSYM
BB16 PSHPCODE
BB29 GET_OFF
BB45 GETO_1
BB52 GETO_2
BB54 GETEXPR
BB5A PCD_WRKD
BB65 WRK_OPND
BB70 WRKD_WRK
BB7B WRK_WRKD
BB86 GET_COMM
BB8D GET_ITEM
BB93 VAL_MOVE
BB9C VAL_1
BBA1 VAL_2
BBAA VAL_3
BBB3 VAL_5
BBBC CHK_STAK
BBC3 STK_ERR
BBC3 STK_FULL
BBC8 CONST
BBDF CONST1
BBE4 CONST3
BBE9 CONST2
BBED CONST9
BBEE VARDEC
BC00 SIMEXP
BC0A SIM1
BC1B SIM3
BC2E SIM4
BC44 SIM7
BC4A SIM5
BC4E SIM6
BC52 SIM2
BC58 SIM8
BC5C TERMT1
BC72 TERM
BC75 TERM2
BC7F TERM1
BC8E TERM4
BC90 TERM3
BC96 TERM5
BC9A TERM6
BC9E TERM7
BCA2 TERM8
BCA6 TERM9
BCAA TERMT3
BCC0 FACTOR
BCD1 IDENT
BCD4 IDENT1
BCDC IDENT1A
BCE1 IDENT2
BCFA IDENT2A
BD01 IDENT3
BD0F FACAD1
BD17 IDENT5
BD19 IDENT5_A
BD24 IDENT6
BD2A IDENT7
BD2D FACAD2
BD35 IDENT4
BD37 IDENT4_A
BD57 FACADR
BD6A FACSTR
BD70 FACERR1
BD75 FACNUM
BD7B PAREN
BD81 FACMEM
BD87 FACMMC
BD8B FACM2
BD97 FACNOT
BD9F GENNOP1
BDA2 FACRND1
BDA8 FACTB1
BDAE FACTQT1
BDC1 EXPRES
BDD1 EXPTB1
BDE4 EXPR1
BDF3 EXPTB3
BE06 EXPR2
BE08 EXPR8
BE0C EXPR3
BE10 EXPR4
BE14 EXPR5
BE18 EXPR6
BE1C EXPR7
BE20 STMNT
BE2D STMNT1
BE58 ASSIGN
BE5B ASS1
BE67 ASSTB1
BE7D assign_bad_identifier
BE82 ASSARR
BE94 ASSVAR
BEA3 ASS2
BEBF WRITELN
BEC9 WRITELN9
BECE WRITE
BED1 WRIT9
BEE0 W_STRING
BEEA WRIT2
BEED WRIT10
BEFA WRIT1
BF0A WRIT5
BF13 W_CHR
BF15 W_CHR1
BF1B W_HEX
BF1F STMNT_WRITE_LCD
BF22 WRITE_LCD9
BF31 WRITE_LCD_STRING
BF3B WRITE_LCD2
BF4B WRITE_LCD1
BF5B WRITE_LCD5
BF64 WRITE_LDC_CHR
BF66 WRITE_LDC_CHR1
BF6C WRITE_LDC_HEX
BF70 READ
BF73 READ8
BF76 READ2
BF8D READ9
BF90 READ11
BFAF READ7
BFB5 READ7_A
BFBF READ3
BFD3 READ3_B
BFEE READ3_A
BFFC TWO_OP
C002 ONE_OP2
C005 ONE_OP
C00C GENNOP2
C00F WAIT_1
C019 MEM
C01E MEMC
C021 MEM2
C034 CALLSB
C041 FNCPRC
C04E FNC2
C078 FNC3
C07E FNC1
C081 FNC5
C09E FNC5A
C0A0 FNC5B
C0C2 FNC4
C0C3 FNC6
C0C8 IF
C0E6 IF2
C0ED IF1
C108 BEG
C11E REPEAT
C121 REP1
C142 WHILE
C174 CASE
C182 CASE7
C186 CASE2
C1AD CASE1
C1B9 CASE4
C1C3 CASE3
C1F6 CASE5
C214 CASE6
C21F CASE9
C229 CASE8
C22F FOR
C239 FOR1
C246 FOR2
C25F FOR3
C290 FOR4
C2D3 FOR5
C2F5 FOR6
C302 CHKGET
C308 WRK_VAL
C313 VAL_WRK
C31E END_WRK
C329 BLCKT1
C32C BLCKT2
C32F BLCKT3
C339 BLOCK
C350 BLK1A
C364 BLK1
C36C BLK2
C376 BLK4
C380 BLKCNS
C383 BLKCN1
C397 BLKVAR
C39B BLKVR1
C39E BLKVR6
C3A8 BLKVR7
C3C7 BLKVR8
C3CA BLKV10
C3E6 BLKV10_A
C3ED BLKV10_B
C3FC BLKVR2
C415 BLKV13
C41A BLKVR4
C454 BLKV11
C45B BLKV12
C461 BLKVR9
C47A BLKVR5
C4BC BLKVR3
C4D4 BLKPRC
C4F4 BLKFNC
C516 BLKPR1
C532 BLKPR3
C53F BLKPR6
C548 BLKPR2
C569 BLKPR5
C590 BLKPR4
C5BC BLKBEG
C5C6 BLKB3
C5CC BLKB1
C5E8 BLKB2
C5F5 BLKB5
C604 BLKB4
C613 BLKB6
C616 pascal_library_functions_table
C6B6 add_pascal_library_functions
C6BE add_pascal_library_functions_loop
C6CE add_pascal_library_functions_name_loop
C70F add_pascal_library_functions_done
C710 library_function_call
C71D library_function_call_2
C747 library_function_call_3
C74C library_function_call_1
C74F library_function_call_5
C760 GENNOP
C775 GEN1
C779 GENADR
C7AC GEN2
C7AE GEN2_B
C7B7 GEN2_A
C7C9 GEN_FULL
C7CE DISP9
C7CE GEN2_C
C7CF GENRJMP
C7E1 GENNJP
C7E3 GENNJM
C7E9 GENJMP
C812 GEN3
C817 FIXAD
C854 FIXAD1
C855 FIXM1
C85E FIXM2
C86A pin_number_to_mask
C870 pin_number_to_mask_loop
C878 pin_number_to_mask_done
C87D pinmode
C88E pinmode_B
C896 pinmode_C
C8A4 pinmode_OUTPUT
C8AC digitalwrite
C8BD digitalwrite_B
C8C5 digitalwrite_C
C8D3 digitalwrite_ONE
C8DB digitalread
C8EA digitalread_B
C8F2 digitalread_C
C8F8 write_to_serial
C903 write_to_lcd
C90E CHRIN
C90E GETIN
C918 GETIN1
C91F serial_available
C922 EMULATOR_DEBUG
C923 START_TRACE
C924 STOP_TRACE
C925 hardware_init
C956 write_char
C972 write_char_loop
C97B serial_print_message
C981 serial_print
C98B serial_print_done
C98C get_token
C990 get_token_loop
C99A gc_skip_spaces
C9AF gc_newline
C9BC gc_newline1
C9C9 gc_newline_assembling
C9CE gc_single_byte_already_known
C9D0 gc_single_byte_token
C9D2 gc_done
C9EA gc_not_space
C9EF gc_alpha_loop
C9F7 gc_alpha_ok
CA08 gc_alpha_done
CA0C gc_alpha_alpha_only
CA15 gc_not_alpha
CA21 gc_not_digit
CA2C token_line
CA32 token_line1
CA4D token_line_listing
CA65 token_line_loop
CA75 token_line_loop1
CA7A token_line_done
CA7B atoi
CA84 atoi_loop
CA93 atoi_positive
CA95 atoi_more
CAEA atoi_error
CAF0 atoi_not_running
CAF5 negate_token_value
CB09 gtoken_table
CB3A gtoken_directive_table
CB47 gc_single_byte_tokenJ
CB4A gc_single_byte_already_knownJ
CB4D gc_lh_brace
CB51 gc_lh_paren
CB5F gc_pascal_comment
CB7E gc_pascal_comment_find_end
CB89 gc_comment_not_eof
CB92 gc_comment_not_newline
CBA1 gc_comment_keep_looking
CBA9 gc_comment_found_end
CBB9 gc_directive_symbols
CBC5 gc_directive_symbols_ok
CBEC gc_directive_symbols_too_late
CBF1 gc_directive_list
CBF8 gc_directive_pcodes
CBFE gc_directive_nolist
CC07 gc_semicolon
CC10 gc_assembler_comment_find_end
CC1B gc_assembler_comment_not_eof
CC22 gc_assembler_comment_keep_looking
CC2A gc_backslash_tokens
CC40 gc_backslash_tokens_end
CC40 gc_quote
CC4E gc_quote_loop
CC57 gc_quote_bad
CC5C gc_quote_loop_not_end_of_line
CC71 gc_quote_long_string
CC7C gc_quote_copied_value
CC85 gc_quote_done
CC97 gc_quote_not_finished
CCA9 gc_quote_backslash_loop
CCB4 gc_quote_bad_string
CCB9 gc_quote_hex_character_done
CCBD gc_quote_found_backslash_character
CCC1 gc_quote_not_backslash
CCCD gc_quote_too_long
CCD2 gc_fix_hex
CCDB gc_fix_hex_not_a_to_f
CCDF gc_quote_hex_character
CD0B gc_quote_hex_character_one_only
CD0E gc_dollar
CD1A gc_hex_literal
CD23 gc_hex_loop
CD5E gc_hex_done
CD63 gc_hex_too_big
CD68 gc_percent
CD74 gc_binary_literal
CD7C gc_binary_loop
CD92 gc_colon
CD9D gc_assign
CDA3 gc_less_than
CDB7 gc_leq
CDBC gc_neq
CDC1 gc_shift_left
CDC6 gc_greater_than
CDD3 gc_single_byte_already_knownJ2
CDD6 gc_geq
CDDB gc_shift_right
CDE0 gc_minus
CDE2 gc_plus
CE01 gc_ampersand
CE0C gc_logical_and
CE12 gc_bar
CE1D gc_logical_or
CE23 gc_equals
CE2E gc_equality
CE34 gc_bang
CE3F gc_inequality
CE45 RSVWRD
CF38 RSVEND
CF3A pas_get_token
CF43 pas_get_token_eof
CF44 pas_gc_identifier
CF4C pas_gc_loop
CF55 pas_gc_more
CF7D pas_gc_no_match
CF8E GETCHK
CF99 CHKNOK
CF9C CHKOK
CF9E CHKTKN
CFA3 GET_LOOK
CFAD i2c_init
CFB8 i2c_delay
CFBC i2c_toggle_clock
CFC4 i2c_toggle_clock_wait
CFD7 i2c_begin_transmission
CFDB i2c_begin_transmission_loop
CFFE i2c_write
D001 i2c_write_loop
D00D i2c_write_one
D018 i2c_write_clock
D028 i2c_write_clock_wait
D040 i2c_write_lost_arbitration
D042 i2c_write_got_ack
D044 i2c_read
D04D i2c_read_loop
D062 i2c_read_zero
D066 i2c_read_next
D07C i2c_read_nak
D081 i2c_read_ack_or_nak
D086 i2c_read_ack_or_nak_wait
D098 i2c_read_done
D09A i2c_end_transmission
D0B3 i2c_send_message
D0BB i2c_send_message_loop
D0D2 i2c_send_message_done
D0D7 i2c_send_message_fail
D0DC i2c_receive_message
D0EA i2c_receive_message_loop
D0FF i2c_receive_message_done
D104 i2c_receive_message_fail
D109 LCD_welcome
D128 START
D144 RESTART
4240 CLOCK_RATE
