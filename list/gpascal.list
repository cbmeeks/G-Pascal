Sections:
00: "seg8000" (8000-CF6B)
01: "segfffa" (FFFA-0)


Source: "gpascal.asm"
                        	     1: ;***********************************************
                        	     2: ; G-PASCAL COMPILER
                        	     3: ; for Ben Eater's breadboard computer
                        	     4: ;
                        	     5: ; Author: Nick Gammon
                        	     6: ; Date: 20 January 2022
                        	     7: ;
                        	     8: ; To compile:
                        	     9: ;
                        	    10: ;  vasm6502_oldstyle gpascal.asm -wdc02 -esc -Fbin -o gpascal.bin -dotdir -L gpascal.list
                        	    11: ;
                        	    12: ; To program EEPROM:
                        	    13: ;
                        	    14: ;  minipro -p AT28C256 -w gpascal.bin
                        	    15: ;
                        	    16: ;
                        	    17: ;
                        	    18: ; To communicate, I suggest: miniterm /dev/ttyUSB0 4800 -e
                        	    19: ;
                        	    20: ;   Miniterm: Ctrl+]        : to exit.
                        	    21: ;             Ctrl+T Ctrl+H : help
                        	    22: ;             Ctrl+T Ctrl+E : toggle local echo
                        	    23: ;
                        	    24: ;
                        	    25: ;  Copyright 2022 by Nick Gammon
                        	    26: ;
                        	    27: ;  Permission is hereby granted, free of charge, to any person obtaining a copy
                        	    28: ;  of this software and associated documentation files (the "Software"), to deal
                        	    29: ;  in the Software without restriction, including without limitation the rights
                        	    30: ;  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                        	    31: ;  copies of the Software, and to permit persons to whom the Software is
                        	    32: ;  furnished to do so, subject to the following conditions:
                        	    33: ;
                        	    34: ;  The above copyright notice and this permission notice shall be included in all
                        	    35: ;  copies or substantial portions of the Software.
                        	    36: ;
                        	    37: ;  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                        	    38: ;  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                        	    39: ;  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                        	    40: ;  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                        	    41: ;  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                        	    42: ;  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
                        	    43: ;  SOFTWARE.
                        	    44: ;
                        	    45: ;***********************************************
                        	    46: ;
                        	    47: 
                        	    48: ; Note: BCC == BLT and BCS == BGE
                        	    49: ;
                        	    50: 
                        	    51: ;
                        	    52: ;  CONDITIONAL COMPILES
                        	    53: ;
                        	    54: EMULATOR = 0          ; for testing on a PC running an emulator
                        	    55: LCD_SUPPORT = 1       ; 1 = support LCD, 0 = not. Unset if you have removed the LCD.
                        	    56: SERIAL_DEBUGGING = 0  ; if set, toggle VIA PA2 when reading a bit, and PA3 when writing a bit
                        	    57: 
                        	    58: ;
                        	    59: ;  CONFIGURATION
                        	    60: ;
                        	    61: CLOCK_RATE   = 1000000   ; 1 Mhz
                        	    62: START_OF_ROM = $8000     ; where the ROM chip starts
                        	    63: HIGHEST_RAM = $3FFF      ; original board hardware
                        	    64: ;HIGHEST_RAM  = $5FFF    ; with suggested additional AND gate
                        	    65: 
                        	    66: ;
                        	    67: ;  serial output
                        	    68: ;
                        	    69: BAUD_RATE    = 4800         ; baud
                        	    70: BIT_INTERVAL = CLOCK_RATE / BAUD_RATE ; time between bits in Âµs
                        	    71: 
                        	    72: ;
                        	    73: ;  serial input - input commences on the interrupt generated by the falling edge
                        	    74: ;    of the start bit. Bits are then clocked in with a timed loop.
                        	    75: ;  - these delays can be tweaked if you believe the serial input is not being
                        	    76: ;    sampled at the right moment, confirm by turning SERIAL_DEBUGGING on
                        	    77: ;    and checking the debugging pulses compared to the middle of the bit times
                        	    78: ;    with an oscilloscope or logic analyser
                        	    79: ;
                        	    80: SERIAL_DELAY1 = 32    ; initial delay (count) - lower because of the initial overhead
                        	    81: SERIAL_DELAY2 = 35    ; subsequent delays between bits (count)
                        	    82: 
                        	    83: SYMBOL_TABLE_START = HIGHEST_RAM  ; symbol table pointer (ENDSYM) is decremented before being used
                        	    84: 
                        	    85: STACK            =  $100  ; hardware stack address
                        	    86: SPACE            =  $20   ; uh-huh
                        	    87: SINGLE_QUOTE     =  $27
                        	    88: NL               =  $0A   ; newline
                        	    89: CR               =  $0D   ; carriage-return
                        	    90: BACKSPACE        =  $08   ; backspace
                        	    91: 
                        	    92: MAX_STK          =  32
                        	    93: NEW_STK          =  $FF
                        	    94: 
                        	    95:     .if EMULATOR
                        	    96: END_EDITOR_INPUT =  '`'   ; backtick terminates input
                        	    97:     .else
                        	    98: END_EDITOR_INPUT =  $1B   ; Esc terminates editor input
                        	    99:     .endif
                        	   100: 
                        	   101: KEY_DEBUG      = 'D'-$40   ; Ctrl+D start debugging
                        	   102: KEY_TRACE      = 'T'-$40   ; Ctrl+T start tracing
                        	   103: KEY_STOP_TRACE = 'N'-$40   ; Ctrl+N stop tracing
                        	   104: KEY_ABORT      = 'C'-$40   ; Ctrl+C abort execution
                        	   105: 
                        	   106: 
                        	   107:   .if LCD_SUPPORT
                        	   108: ;
                        	   109: ;  Pins connected from the VIA to the LCD
                        	   110: ;
                        	   111: LCD_RS             = %00100000  ; PA 5 - 0 = instruction, 1 = data
                        	   112: LCD_RW             = %01000000  ; PA 6 - 0 = write, 1 = read
                        	   113: LCD_E              = %10000000  ; PA 7 - toggle (0 -> 1 -> 0) to clock out a command or data
                        	   114:   .endif
                        	   115: 
                        	   116:   .include "zp_variables.inc"

Source: "zp_variables.inc"
                        	     1: ;***********************************************
                        	     2: ;
                        	     3: ; Zero-page variables (currently 64 (decimal) bytes are free for your use).
                        	     4: ;  I suggest using the high ones and working down in case there is a change to the code.
                        	     5: ;  For example, start with 0xFF, then 0xFE and so on.
                        	     6: ;
                        	     7: ;***********************************************
                        	     8: 
                        	     9:   .dsect
                        	    10: 
                        	    11: 
                        	    12: ;
                        	    13: ;  General work-areas for arithmetic routines (eg. add, subtract, divide, multiply)
                        	    14: ;   3-byte signed numbers: -8388608 to +8388607
                        	    15: ;
00:0000 00              	    16: VALUE    reserve 3    ; the current value of the token (ie. if a number)
00:0001 *
00:0003 00              	    17: VALUE2   reserve 3    ; used by the assembler expression evaluator
00:0004 *
                        	    18: 
                        	    19: ; SRCE and DEST used in compiler and editor, particularly for string comparisons
                        	    20: ;   (re-using VALUE and VALUE2)
                        	    21: 
                        	    22: SRCE     =  VALUE
                        	    23: DEST     =  VALUE2
                        	    24: 
00:0006 00              	    25: REMAIN   reserve 3    ; division remainder
00:0007 *
                        	    26: 
                        	    27: ;
                        	    28: ;  work "register" - re-using VALUE and VALUE2 again
                        	    29: ;
                        	    30: REG   = VALUE
                        	    31: REGB  = VALUE+2
                        	    32: REG2  = VALUE2
                        	    33: REG2B = VALUE2+2
                        	    34: 
                        	    35: ;
                        	    36: ;  re-using above for CRC-16 calculations
                        	    37: ;
                        	    38: crc_addr = VALUE      ; the address to take a CRC of (2 bytes)
                        	    39: crc_num  = VALUE2     ; the number of bytes to take a CRC of (2 bytes)
                        	    40: crc_val  = REMAIN     ; the current CRC value (2 bytes)
                        	    41: 
                        	    42: ;
                        	    43: ;  current random number - change this to reseed it
                        	    44: ;
00:0009 00              	    45: random         reserve 4 ; 32-bit random number
00:000A *
00:000D 00              	    46: typing_latency reserve 3 ; incremented while waiting for input
00:000E *
                        	    47: 
                        	    48: ;
                        	    49: ;  Used for seeding registers when calling machine code from Pascal
                        	    50: ;
00:0010 00              	    51: call_a reserve 1      ; used when doing a machine code call:  A register
00:0011 00              	    52: call_x reserve 1      ;  ditto: X register
00:0012 00              	    53: call_y reserve 1      ;  ditto: Y register
00:0013 00              	    54: call_p reserve 1      ;  ditto: status register
00:0014 00              	    55: call_s reserve 1      ; stack register, used by BRK
00:0015 00              	    56: brk_address reserve 2 ; BRK address
00:0016 *
                        	    57: 
                        	    58: ;
                        	    59: ;  address of write function (2 bytes)
                        	    60: ;
                        	    61: ;  This is called by "character out" function COUT. It writes the character in "A" to
                        	    62: ;   serial port or LCD. You could conceivably put another function address here if
                        	    63: ;   you wanted to capture output (eg. from calling DISP_BIN) and putting it somewhere else
                        	    64: ;   like into a series of memory locations, or to output to SPI.
                        	    65: ;  The functions write_to_serial and write_to_lcd
                        	    66: ;   put the appropriate outputting functions into this location.
                        	    67: ;
00:0017 00              	    68: write_function reserve 2  ; address of function to write to serial or LCD
00:0018 *
                        	    69: 
                        	    70: 
00:0019 00              	    71: LINE_CNT  reserve 2   ; line counter during compile
00:001A *
                        	    72: LINE_NO  =  LINE_CNT
                        	    73: 
00:001B 00              	    74: WX       reserve 2    ; 2-byte address used during compilation (reserved word lookup)
00:001C *
00:001D 00              	    75: LIST     reserve 1    ; 0 = no listing, 1 = list source during compile
00:001E 00              	    76: DIGIT    reserve 1    ; used only in GET_NUM to process a decimal number
00:001F 00              	    77: SIGN     reserve 1    ; used in compiling and inputting a number - is there a minus sign?
                        	    78: 
00:0020 00              	    79: FRAME    reserve 2    ; stack frame number - not totally certain but it used for procedure calls at runtime
00:0021 *
00:0022 00              	    80: LEVEL    reserve 1    ; current nested procedure/function level (how far we are nested)
00:0023 00              	    81: PCODE    reserve 2    ; current P-code address (increments during compile and running)
00:0024 *
                        	    82: PNTR     =  PCODE     ; 2-byte work pointer used in editor (eg. in find/replace etc.)
00:0025 00              	    83: ACT_PCDA reserve 2    ; start of P-codes (after source) - does not increment
00:0026 *
00:0027 00              	    84: DISPL    reserve 2    ; level? ahhh ... I don't know
00:0028 *
00:0029 00              	    85: OFFSET   reserve 2    ; variable offset? maybe just a work area
00:002A *
00:002B 00              	    86: OPND     reserve 3    ; jump operand ... not sure
00:002C *
00:002E 00              	    87: DCODE    reserve 1     ; 0 = no display, 1 = display P-codes during compile
00:002F 00              	    88: STARTSYM reserve 2    ; start of symbol table
00:0030 *
00:0031 00              	    89: ENDSYM   reserve 2    ; end of symbol table - used for reverse searching symbols
00:0032 *
                        	    90: T        =  ENDSYM     ; stack pointer 2 bytes
00:0033 00              	    91: WORKD    reserve 2    ; work area for holding P-code address
00:0034 *
00:0035 00              	    92: ERRNO    reserve 1    ; current error number, if ERROR called
00:0036 00              	    93: BSAVE    reserve 1    ; seems to be used to save "A" register, lol
00:0037 00              	    94: WORK     reserve 2    ; work area, used for pushing 2-bytes onto the (processor) stack
00:0038 *
00:0039 00              	    95: PRCITM   reserve 2    ; seems to hold the current procedure/function symbol
00:003A *
00:003B 00              	    96: BASE     reserve 2    ; the base interpreter stack frame (for this procedure)
00:003C *
                        	    97: TO       =  BASE      ; Used in editor (from/to list ranges, and copying text)
00:003D 00              	    98: DATA     reserve 2    ; 2-byte address work-area for calculating the address of a variable at runtime
00:003E *
00:003F 00              	    99: RUNNING  reserve 1    ; 0x40 - in editor, 0x80 - executing - affects stuff like numeric conversion
00:0040 00              	   100: SYMITM   reserve 2    ; current symbol table item (found by searching)
00:0041 *
                        	   101: FROM     =  SYMITM    ; Used in editor (from/to list ranges, and copying text)
00:0042 00              	   102: SYNTAX   reserve 1    ; 0 = full compile, 1 = syntax-only compile (no writing to memory)
00:0043 00              	   103: END_PCD  reserve 2    ; where the P-codes ended after a compile
00:0044 *
00:0045 00              	   104: TEMP     reserve 2    ; temporary work area?
00:0046 *
00:0047 00              	   105: CALL     reserve 2    ; the procedure address we are calling
00:0048 *
00:0049 00              	   106: DBGFLG   reserve 1    ; 0 = not debugging, 1 = debugging, $80 = tracing
00:004A 00              	   107: DATTYP   reserve 1    ; 0 for integers and 1 for characters
00:004B 00              	   108: COUNT1   reserve 1    ; work counter
00:004C 00              	   109: COUNT2   reserve 1    ; and another
00:004D 00              	   110: LASTP    reserve 2    ; 2-byte last P-code address executed at runtime (start of this P-code)
00:004E *
00:004F 00              	   111: IO_A     reserve 1    ; dunno
00:0050 00              	   112: IO_Y     reserve 1    ; seems to be used to save and restore Y
00:0051 00              	   113: IO_X     reserve 1    ;  ditto for X
00:0052 00              	   114: RES      reserve 3    ; multiplication result
00:0053 *
00:0055 00              	   115: MCAND    reserve 3    ; multiplicand
00:0056 *
                        	   116: DIVISOR  = MCAND      ; divisor for division (shares with multiplicand for multiplication)
00:0058 00              	   117: DVDN     reserve 3    ; dividend
00:0059 *
00:005B 00              	   118: RMNDR    reserve 1    ; for division, 0 if positive, 0x80 if negative
00:005C 00              	   119: bcd_work    reserve 4    ; work area for converting binary to decimal (packed)
00:005D *
00:0060 00              	   120: bcd_result  reserve 8    ; work area for turning numbers into printable (unpacked)
00:0061 *
00:0068 00              	   121: QT_TGL   reserve 1    ; quote toggle
00:0069 00              	   122: QUOT_SYM reserve 1     ; current quote symbol
00:006A 00              	   123: QT_SIZE  reserve 1    ; number of characters in reserved words
00:006B 00              	   124: ASS_OPERAND reserve 1 ; assembler operand type = see defines below
00:006C 00              	   125: OPCODE   reserve 2    ; address of opcode in assembler
00:006D *
00:006E 00              	   126: OPCODE_LEN reserve 1  ; length of opcode
00:006F 00              	   127: ASS_EMIT_COUNT reserve 1 ; number of bytes emitted on this line
00:0070 00              	   128: ASS_OPCODE_WORK reserve 2; for opcode lookups
00:0071 *
00:0072 00              	   129: ASS_COUNT reserve 1 ; for counting opcode matches
00:0073 00              	   130: ASS_VALUE reserve 3 ; the assembler operand (address or immediate) will be here
00:0074 *
00:0076 00              	   131: ASS_PASS  reserve 1 ; which assembler pass we are up to
00:0077 00              	   132: ass_emit_bytes reserve 2 ; how many bytes the assembler emitted altogether
00:0078 *
00:0079 00              	   133: exp_value_stack reserve 2  ; address of assembler value stack
00:007A *
00:007B 00              	   134: exp_value_stack_count reserve 1 ; how far through value stack we are (0 = empty)
00:007C 00              	   135: exp_operator_stack_count reserve 1 ;  how far through operator stack we are (0 = empty)
00:007D 00              	   136: exp_operator reserve 1  ; current operator for expression evaluation
00:007E 00              	   137: exp_operator_precedence reserve 1 ; current operator precedence
00:007F 00              	   138: exp_evaluation_function reserve 2 ; function to evaluate an expression
00:0080 *
00:0081 00              	   139: exp_unary_ok reserve 1  ; true if the next token can be a unary operator (like: - < >)
00:0082 00              	   140: show_symbols reserve 1  ; true to list the symbol table after an assemble
00:0083 00              	   141: ass_current_label reserve 2 ; current symbol table address of the label on this line
00:0084 *
00:0085 00              	   142: str_work reserve 1      ; work byte for string compares
                        	   143:   .if LCD_SUPPORT
00:0086 00              	   144: lcd_work  reserve 1 ; used by the LCD routines
                        	   145:   .endif
                        	   146: 
                        	   147: ;
                        	   148: ;  serial work
                        	   149: ;
00:0087 00              	   150: serial_out_byte reserve 2 ; current byte we are sending
00:0088 *
00:0089 00              	   151: serial_out_bit  reserve 1 ; current bit count
00:008A 00              	   152: serial_in_byte  reserve 1 ; current byte we are receiving
00:008B 00              	   153: serial_in_byte_received  reserve 1 ; last received byte
                        	   154: 
                        	   155: ;
                        	   156: ; hardware
                        	   157: ;
00:008C 00              	   158: hardware_work  reserve 1  ; work for use during interpreting
                        	   159: 
                        	   160: ;
                        	   161: ; maths
                        	   162: ;
00:008D 00              	   163: maths_work  reserve 1 ; work for multiply/divide
                        	   164: ;
                        	   165: ;  for get_token
                        	   166: ;
00:008E 00              	   167: token_start      reserve 2  ; where to start looking for a token
00:008F *
00:0090 00              	   168: token_address    reserve 2  ; where the token actually started
00:0091 *
00:0092 00              	   169: token_length     reserve 1  ; length of the token
00:0093 00              	   170: token_type       reserve 1  ; what type of token it is
00:0094 00              	   171: token_value      reserve 3  ; the value of numeric tokens
00:0095 *
00:0097 00              	   172: token_sign       reserve 1  ; non-zero if negative value
00:0098 00              	   173: token_work       reserve 3  ; temporary work area - also used by handlerLookup
00:0099 *
00:009B 00              	   174: token_digit      reserve 1  ; used by get_token
00:009C 00              	   175: token_line_start reserve 2  ; where the current line starts
00:009D *
                        	   176: 
                        	   177: ;
                        	   178: ;  for editor
                        	   179: ;
00:009E 00              	   180: from_line       reserve 2     ; list, delete, modify: FROM line number
00:009F *
00:00A0 00              	   181: to_line         reserve 2     ; list, delete, modify: TO line number
00:00A1 *
00:00A2 00              	   182: current_line    reserve 2     ; current editor line number
00:00A3 *
00:00A4 00              	   183: insert_limit    reserve 2     ; maximum we can input to
00:00A5 *
00:00A6 00              	   184: mem_move_src    reserve 2     ; for copying memory - source of move
00:00A7 *
00:00A8 00              	   185: mem_move_dest   reserve 2     ; for copying memory - destination of move
00:00A9 *
00:00AA 00              	   186: mem_move_len    reserve 2     ; for copying memory - length of move
00:00AB *
00:00AC 00              	   187: this_line       reserve 2     ; which line we are searching for
00:00AD *
00:00AE 00              	   188: this_line_addr  reserve 2     ; address of the "this" line
00:00AF *
00:00B0 00              	   189: find_from       reserve 1     ; editor find: from offset in INBUF (start of target string)
00:00B1 00              	   190: find_to         reserve 1     ; editor find: to offset in INBUF (end of target string)
00:00B2 00              	   191: find_pos        reserve 1     ; which offset in the current line we are currently searching from
00:00B3 00              	   192: find_len        reserve 1     ; the length of the find text
00:00B4 00              	   193: find_delimiter  reserve 1     ; the find/replace delimiter
00:00B5 00              	   194: rep_from        reserve 1     ; editor replace: start of replacement string
00:00B6 00              	   195: rep_to          reserve 1     ; editor replace: end of replacement string
00:00B7 00              	   196: rep_diff        reserve 2     ; difference in find/replace string lengths (signed 2 bytes)
00:00B8 *
00:00B9 00              	   197: find_count      reserve 2     ; count of find/replace
00:00BA *
00:00BB 00              	   198: found_this_line reserve 1     ; did we find something on this line?
                        	   199: insert_last_char = find_from  ; the last character we inserted in INSERT/LOAD mode
                        	   200: 
00:00BC 00              	   201: editor_flags    reserve 1     ; various flags, see below
                        	   202: 
                        	   203: EFLAG_SHOW_LINE        = %00000001    ; set after receiving a newline, so we display the next line
                        	   204: EFLAG_ALLOW_ZERO_FROM  = %00000010    ; for use with MEMORY, allow them to start from $0000
                        	   205: EFLAG_LOAD             = %00000100    ; doing a LOAD, do not show line numbers when inserting
                        	   206: EFLAG_SAVE             = %00001000    ; doing a SAVE, do not show line numbers
                        	   207: EFLAG_FIND             = %00010000    ; doing a FIND
                        	   208: EFLAG_REPLACE          = %00100000    ; doing a REPLACE
                        	   209: EFLAG_SUPPRESS_NEWLINE = %01000000    ; don't show newlines
                        	   210: EFLAG_NO_LINE_NUMBERS  = %10000000    ; don't show line numbers
                        	   211: 
00:00BD 00              	   212: find_flags     reserve 1      ; find/replace flags, see below
                        	   213: 
                        	   214: FFLAG_IGNORE_CASE = %00000001
                        	   215: FFLAG_GLOBAL      = %00000010
                        	   216: FFLAG_QUIET       = %00000100
                        	   217: 
                        	   218: ;
                        	   219: ;  system flags
                        	   220: ;
                        	   221: 
00:00BE 00              	   222: system_flags    reserve 1    ; general flags
                        	   223: 
                        	   224: FLAG_COMPILING      = %00000001
                        	   225: FLAG_ASSEMBLING     = %00000010
                        	   226: FLAG_LIST_SOURCE    = %00000100
                        	   227: FLAG_VALID_COMPILE  = %00001000
                        	   228: FLAG_VALID_ASSEMBLE = %00010000
                        	   229: FLAG_RUNNING        = %00100000
                        	   230: FLAG_ONLY_ALPHA     = %01000000   ; for editor, so you can L5 to do LIST 5
                        	   231: FLAG_ABORTED        = %10000000   ; Ctrl+C pressed during printing
                        	   232: 

Source: "gpascal.asm"
                        	   117: 
                        	   118: ;
                        	   119: ;  A general work-buffer is allocated from $200 to $2FF for use during keyboard input, and also
                        	   120: ;  for converting strings during tokenisation (eg. two quotes in a row to one quote, and handling
                        	   121: ;  string escape sequences). It is also used during assembly as a 256-byte operator stack.
                        	   122: ;
                        	   123:   .org $200
                        	   124: INBUF_SIZE = 256          ; we use this for string storage during tokenisation
01:0200 00              	   125: INBUF  reserve INBUF_SIZE ; and also for preprocessing string literals (eg. backslash expansion)
01:0201 *
                        	   126: TEXT_START = *            ; where source goes in memory (currently $300)
                        	   127:   .dend
                        	   128: 
                        	   129: 
                        	   130: 
                        	   131: ;------------------------------------------
                        	   132: ;  Macros
                        	   133: ;------------------------------------------
                        	   134: 
                        	   135:  .macro tknjmpItem ; tknjmp entry: token, handler
                        	   136:    dfb   \1
                        	   137:    word  \2
                        	   138:  .endmacro
                        	   139: 
                        	   140:  .macro makeHandler ; table of words and handlers: word, handler
                        	   141:    asciiz   \1
                        	   142:    word  \2
                        	   143:  .endmacro
                        	   144: 
                        	   145: ;
                        	   146: ; makePasLibraryFunction NAME (SYMNAM), TYPE (SYMTYP), ARG_COUNT (SYMARG), EXECUTION_ADDRESS (SYMDSP)
                        	   147: ;
                        	   148: ;   TYPE = SYMBOL_LIBRARY_PROCEDURE or SYMBOL_LIBRARY_FUNCTION
                        	   149:    .macro makePasLibraryFunction
                        	   150:      asciiz   \1
                        	   151:      dfb      \2
                        	   152:      dfb      \3
                        	   153:      word     \4
                        	   154:    .endmacro
                        	   155: 
                        	   156: ;
                        	   157: ; makeAsmLibraryFunction NAME (SYMNAM), EXECUTION_ADDRESS (SYMDSP)
                        	   158: ;
                        	   159:    .macro makeAsmLibraryFunction
                        	   160:      asciiz   \1
                        	   161:      word     \2
                        	   162:    .endmacro
                        	   163: 
                        	   164:   ORG  START_OF_ROM   ; normally $8000 in the case of Ben Eater's board
                        	   165: 
00:8000 4C31CF          	   166:   JMP  START   ; where RESET takes us - a cold start
00:8003 4C55CF          	   167:   JMP  RESTART ; where NMI takes us - a warm start
                        	   168: 
                        	   169: ;***********************************************
                        	   170: ; INCLUDES
                        	   171: ;***********************************************
                        	   172: 
                        	   173:   .include "memory.inc"

Source: "memory.inc"
                        	     1: ;---------------------------
                        	     2: ; standard library stuff
                        	     3: ;---------------------------
                        	     4: 
                        	     5: ;
                        	     6: ;  character type masks
                        	     7: ;
                        	     8: m_upper   = %00000001    ; $01
                        	     9: m_lower   = %00000010    ; $02
                        	    10: m_alpha   = %00000100    ; $04
                        	    11: m_digit   = %00001000    ; $08
                        	    12: m_xdigit  = %00010000    ; $10
                        	    13: m_space   = %00100000    ; $20
                        	    14: m_cntrl   = %01000000    ; $40
                        	    15: m_alnum   = %10000000    ; $80
                        	    16: 
                        	    17: ;
                        	    18: ;  for fast checks which corrupt registers
                        	    19: ;
                        	    20: ;    ldx THE_CHARACTER_TO_BE_TESTED
                        	    21: ;    lda character_types_table,X
                        	    22: ;    bne IS_IN_THAT_CLASS
                        	    23: ;
                        	    24: 
                        	    25: character_types_table = *
00:8006 40              	    26:   dfb $40,$40,$40,$40,$40,$40,$40,$40    ; 0x00
00:8007 40
00:8008 40
00:8009 40
00:800A 40
00:800B 40
00:800C 40
00:800D 40
00:800E 40              	    27:   dfb $40,$60,$60,$60,$60,$60,$40,$40    ; 0x08
00:800F 60
00:8010 60
00:8011 60
00:8012 60
00:8013 60
00:8014 40
00:8015 40
00:8016 40              	    28:   dfb $40,$40,$40,$40,$40,$40,$40,$40    ; 0x10
00:8017 40
00:8018 40
00:8019 40
00:801A 40
00:801B 40
00:801C 40
00:801D 40
00:801E 40              	    29:   dfb $40,$40,$40,$40,$40,$40,$40,$40    ; 0x18
00:801F 40
00:8020 40
00:8021 40
00:8022 40
00:8023 40
00:8024 40
00:8025 40
00:8026 20              	    30:   dfb $20,$00,$00,$00,$00,$00,$00,$00    ; 0x20   !"#$%&'
00:8027 00
00:8028 00
00:8029 00
00:802A 00
00:802B 00
00:802C 00
00:802D 00
00:802E 00              	    31:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x28  ()*+,-./
00:802F 00
00:8030 00
00:8031 00
00:8032 00
00:8033 00
00:8034 00
00:8035 00
00:8036 98              	    32:   dfb $98,$98,$98,$98,$98,$98,$98,$98    ; 0x30  01234567
00:8037 98
00:8038 98
00:8039 98
00:803A 98
00:803B 98
00:803C 98
00:803D 98
00:803E 98              	    33:   dfb $98,$98,$00,$00,$00,$00,$00,$00    ; 0x38  89:;<=>?
00:803F 98
00:8040 00
00:8041 00
00:8042 00
00:8043 00
00:8044 00
00:8045 00
00:8046 00              	    34:   dfb $00,$95,$95,$95,$95,$95,$95,$85    ; 0x40  @ABCDEFG
00:8047 95
00:8048 95
00:8049 95
00:804A 95
00:804B 95
00:804C 95
00:804D 85
00:804E 85              	    35:   dfb $85,$85,$85,$85,$85,$85,$85,$85    ; 0x48  HIJKLMNO
00:804F 85
00:8050 85
00:8051 85
00:8052 85
00:8053 85
00:8054 85
00:8055 85
00:8056 85              	    36:   dfb $85,$85,$85,$85,$85,$85,$85,$85    ; 0x50  PQRSTUVW
00:8057 85
00:8058 85
00:8059 85
00:805A 85
00:805B 85
00:805C 85
00:805D 85
00:805E 85              	    37:   dfb $85,$85,$85,$00,$00,$00,$00,$00    ; 0x58  XYZ[\]^_
00:805F 85
00:8060 85
00:8061 00
00:8062 00
00:8063 00
00:8064 00
00:8065 00
00:8066 00              	    38:   dfb $00,$96,$96,$96,$96,$96,$96,$86    ; 0x60  `abcdefg
00:8067 96
00:8068 96
00:8069 96
00:806A 96
00:806B 96
00:806C 96
00:806D 86
00:806E 86              	    39:   dfb $86,$86,$86,$86,$86,$86,$86,$86    ; 0x68  hijklmno
00:806F 86
00:8070 86
00:8071 86
00:8072 86
00:8073 86
00:8074 86
00:8075 86
00:8076 86              	    40:   dfb $86,$86,$86,$86,$86,$86,$86,$86    ; 0x70  pqrstuvw
00:8077 86
00:8078 86
00:8079 86
00:807A 86
00:807B 86
00:807C 86
00:807D 86
00:807E 86              	    41:   dfb $86,$86,$86,$00,$00,$00,$00,$40    ; 0x78  xyz{|}~
00:807F 86
00:8080 86
00:8081 00
00:8082 00
00:8083 00
00:8084 00
00:8085 40
00:8086 00              	    42:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x80
00:8087 00
00:8088 00
00:8089 00
00:808A 00
00:808B 00
00:808C 00
00:808D 00
00:808E 00              	    43:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x88
00:808F 00
00:8090 00
00:8091 00
00:8092 00
00:8093 00
00:8094 00
00:8095 00
00:8096 00              	    44:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x90
00:8097 00
00:8098 00
00:8099 00
00:809A 00
00:809B 00
00:809C 00
00:809D 00
00:809E 00              	    45:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x98
00:809F 00
00:80A0 00
00:80A1 00
00:80A2 00
00:80A3 00
00:80A4 00
00:80A5 00
00:80A6 00              	    46:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xA0
00:80A7 00
00:80A8 00
00:80A9 00
00:80AA 00
00:80AB 00
00:80AC 00
00:80AD 00
00:80AE 00              	    47:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xA8
00:80AF 00
00:80B0 00
00:80B1 00
00:80B2 00
00:80B3 00
00:80B4 00
00:80B5 00
00:80B6 00              	    48:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xB0
00:80B7 00
00:80B8 00
00:80B9 00
00:80BA 00
00:80BB 00
00:80BC 00
00:80BD 00
00:80BE 00              	    49:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xB8
00:80BF 00
00:80C0 00
00:80C1 00
00:80C2 00
00:80C3 00
00:80C4 00
00:80C5 00
00:80C6 00              	    50:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xC0
00:80C7 00
00:80C8 00
00:80C9 00
00:80CA 00
00:80CB 00
00:80CC 00
00:80CD 00
00:80CE 00              	    51:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xC8
00:80CF 00
00:80D0 00
00:80D1 00
00:80D2 00
00:80D3 00
00:80D4 00
00:80D5 00
00:80D6 00              	    52:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xD0
00:80D7 00
00:80D8 00
00:80D9 00
00:80DA 00
00:80DB 00
00:80DC 00
00:80DD 00
00:80DE 00              	    53:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xD8
00:80DF 00
00:80E0 00
00:80E1 00
00:80E2 00
00:80E3 00
00:80E4 00
00:80E5 00
00:80E6 00              	    54:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xE0
00:80E7 00
00:80E8 00
00:80E9 00
00:80EA 00
00:80EB 00
00:80EC 00
00:80ED 00
00:80EE 00              	    55:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xE8
00:80EF 00
00:80F0 00
00:80F1 00
00:80F2 00
00:80F3 00
00:80F4 00
00:80F5 00
00:80F6 00              	    56:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xF0
00:80F7 00
00:80F8 00
00:80F9 00
00:80FA 00
00:80FB 00
00:80FC 00
00:80FD 00
00:80FE 00              	    57:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xF8
00:80FF 00
00:8100 00
00:8101 00
00:8102 00
00:8103 00
00:8104 00
00:8105 00
                        	    58: 
                        	    59: ;
                        	    60: ;  character type tests: test character in A, Carry set if true, carry clear if false
                        	    61: ;    -no registers changed
                        	    62: ;
                        	    63: is_xxx_fail:
00:8106 FA              	    64:   plx
00:8107 68              	    65:   pla
00:8108 18              	    66:   clc
00:8109 60              	    67:   rts
                        	    68: 
                        	    69: is_xxx_pass:
00:810A FA              	    70:   plx
00:810B 68              	    71:   pla
00:810C 38              	    72:   sec
00:810D 60              	    73:   rts
                        	    74: 
                        	    75:   .macro isXXX
                        	    76: \1 = *
                        	    77:   pha
                        	    78:   phx
                        	    79:   tax
                        	    80:   lda character_types_table,x
                        	    81:   and #\2
                        	    82:   beq is_xxx_fail
                        	    83:   bra is_xxx_pass
                        	    84:   .endmacro
                        	    85: 
                        	    86: ;
                        	    87: ;  generate the various character type tests - done by fast table lookup
                        	    88: ;
                        	    89:   isXXX isupper,  m_upper
                        	     1M isupper = *
00:810E 48              	     2M   pha
00:810F DA              	     3M   phx
00:8110 AA              	     4M   tax
00:8111 BD0680          	     5M   lda character_types_table,x
00:8114 2901            	     6M   and #m_upper
00:8116 F0EE            	     7M   beq is_xxx_fail
00:8118 80F0            	     8M   bra is_xxx_pass
                        	    90:   isXXX islower,  m_lower
                        	     1M islower = *
00:811A 48              	     2M   pha
00:811B DA              	     3M   phx
00:811C AA              	     4M   tax
00:811D BD0680          	     5M   lda character_types_table,x
00:8120 2902            	     6M   and #m_lower
00:8122 F0E2            	     7M   beq is_xxx_fail
00:8124 80E4            	     8M   bra is_xxx_pass
                        	    91:   isXXX isalpha,  m_alpha
                        	     1M isalpha = *
00:8126 48              	     2M   pha
00:8127 DA              	     3M   phx
00:8128 AA              	     4M   tax
00:8129 BD0680          	     5M   lda character_types_table,x
00:812C 2904            	     6M   and #m_alpha
00:812E F0D6            	     7M   beq is_xxx_fail
00:8130 80D8            	     8M   bra is_xxx_pass
                        	    92:   isXXX isdigit,  m_digit
                        	     1M isdigit = *
00:8132 48              	     2M   pha
00:8133 DA              	     3M   phx
00:8134 AA              	     4M   tax
00:8135 BD0680          	     5M   lda character_types_table,x
00:8138 2908            	     6M   and #m_digit
00:813A F0CA            	     7M   beq is_xxx_fail
00:813C 80CC            	     8M   bra is_xxx_pass
                        	    93:   isXXX isxdigit, m_xdigit
                        	     1M isxdigit = *
00:813E 48              	     2M   pha
00:813F DA              	     3M   phx
00:8140 AA              	     4M   tax
00:8141 BD0680          	     5M   lda character_types_table,x
00:8144 2910            	     6M   and #m_xdigit
00:8146 F0BE            	     7M   beq is_xxx_fail
00:8148 80C0            	     8M   bra is_xxx_pass
                        	    94:   isXXX isspace,  m_space
                        	     1M isspace = *
00:814A 48              	     2M   pha
00:814B DA              	     3M   phx
00:814C AA              	     4M   tax
00:814D BD0680          	     5M   lda character_types_table,x
00:8150 2920            	     6M   and #m_space
00:8152 F0B2            	     7M   beq is_xxx_fail
00:8154 80B4            	     8M   bra is_xxx_pass
                        	    95:   isXXX iscntrl,  m_cntrl
                        	     1M iscntrl = *
00:8156 48              	     2M   pha
00:8157 DA              	     3M   phx
00:8158 AA              	     4M   tax
00:8159 BD0680          	     5M   lda character_types_table,x
00:815C 2940            	     6M   and #m_cntrl
00:815E F0A6            	     7M   beq is_xxx_fail
00:8160 80A8            	     8M   bra is_xxx_pass
                        	    96:   isXXX isalnum,  m_alnum
                        	     1M isalnum = *
00:8162 48              	     2M   pha
00:8163 DA              	     3M   phx
00:8164 AA              	     4M   tax
00:8165 BD0680          	     5M   lda character_types_table,x
00:8168 2980            	     6M   and #m_alnum
00:816A F09A            	     7M   beq is_xxx_fail
00:816C 809C            	     8M   bra is_xxx_pass
                        	    97: 
                        	    98: ;
                        	    99: ;  ran out of bits so implemented this one manually
                        	   100: ;
                        	   101: isbinary   =  *
00:816E C930            	   102:          cmp  #'0'
00:8170 F004            	   103:          beq  isbin
00:8172 C931            	   104:          cmp  #'1'
00:8174 D002            	   105:          bne  notbin
                        	   106: isbin:
00:8176 38              	   107:          sec
00:8177 60              	   108:          rts
                        	   109: notbin:
00:8178 18              	   110:          clc
00:8179 60              	   111:          rts
                        	   112: 
                        	   113: ;
                        	   114: ; Move memory down  (mem_move_dest is < mem_move_src)
                        	   115: ;
                        	   116: ;  Copies first byte first, working upwards
                        	   117: ;
                        	   118: ; mem_move_src = source start address
                        	   119: ; mem_move_dest = destination start address
                        	   120: ; mem_move_len = number of bytes mem_move_dest move
                        	   121: ;
                        	   122: movedown:
00:817A A5AA            	   123:   lda mem_move_len
00:817C 05AB            	   124:   ora mem_move_len+1
00:817E F01C            	   125:   beq movedown_done
00:8180 A000            	   126:   ldy #0
00:8182 8498            	   127:   sty  token_work      ; counter
00:8184 8499            	   128:   sty  token_work+1
                        	   129: ;
                        	   130: ;  copy one byte, increment counter
                        	   131: ;
                        	   132: movedown_loop:
00:8186 B1A6            	   133:   lda (mem_move_src),Y
00:8188 91A8            	   134:   sta (mem_move_dest),Y
00:818A E698            	   135:   inc token_work
00:818C D002            	   136:   bne movedown2
00:818E E699            	   137:   inc token_work+1
                        	   138: ;
                        	   139: ;  see if length reached
                        	   140: ;
                        	   141: movedown2:
                        	   142: 
00:8190 A598            	   143:   lda  token_work
00:8192 C5AA            	   144:   cmp  mem_move_len
00:8194 D007            	   145:   bne  movedown1
00:8196 A599            	   146:   lda  token_work+1
00:8198 C5AB            	   147:   cmp  mem_move_len+1
00:819A D001            	   148:   bne  movedown1
                        	   149: movedown_done:
00:819C 60              	   150:   rts
                        	   151: 
                        	   152: ;
                        	   153: ; increment Y, and increment high-order address bytes if necessary
                        	   154: ;
                        	   155: movedown1:
00:819D C8              	   156:   iny
00:819E D0E6            	   157:   bne  movedown_loop
00:81A0 E6A7            	   158:   inc  mem_move_src+1
00:81A2 E6A9            	   159:   inc  mem_move_dest+1
00:81A4 80E0            	   160:   bra  movedown_loop
                        	   161: 
                        	   162: ; Move memory up (mem_move_dest is > mem_move_src)
                        	   163: ;
                        	   164: ;   Copies last byte first, moving downwards
                        	   165: ;
                        	   166: ; mem_move_src = source start address
                        	   167: ; mem_move_dest = destination start address
                        	   168: ; mem_move_len = number of bytes mem_move_dest move
                        	   169: ;
                        	   170: moveup:
00:81A6 A5AA            	   171:   lda mem_move_len
00:81A8 05AB            	   172:   ora mem_move_len+1
00:81AA F038            	   173:   beq moveup_done
00:81AC A000            	   174:   ldy #0
00:81AE 8498            	   175:   sty  token_work      ; counter
00:81B0 8499            	   176:   sty  token_work+1
                        	   177:   ;
                        	   178:   ;  calculate final address of source
                        	   179:   ;
00:81B2 18              	   180:   clc
00:81B3 A5A6            	   181:   lda mem_move_src
00:81B5 65AA            	   182:   adc mem_move_len
00:81B7 85A6            	   183:   sta mem_move_src
00:81B9 A5A7            	   184:   lda mem_move_src+1
00:81BB 65AB            	   185:   adc mem_move_len+1
00:81BD 85A7            	   186:   sta mem_move_src+1
                        	   187:   ;
                        	   188:   ;  calculate final address of destination
                        	   189:   ;
00:81BF 18              	   190:   clc
00:81C0 A5A8            	   191:   lda mem_move_dest
00:81C2 65AA            	   192:   adc mem_move_len
00:81C4 85A8            	   193:   sta mem_move_dest
00:81C6 A5A9            	   194:   lda mem_move_dest+1
00:81C8 65AB            	   195:   adc mem_move_len+1
00:81CA 85A9            	   196:   sta mem_move_dest+1
00:81CC 8017            	   197:   bra moveup_next   ; have to decrement first
                        	   198: ;
                        	   199: ; move one byte, count moves
                        	   200: ;
                        	   201: moveup_loop:
00:81CE B1A6            	   202:   lda (mem_move_src),Y
00:81D0 91A8            	   203:   sta (mem_move_dest),Y
00:81D2 E698            	   204:   inc token_work
00:81D4 D002            	   205:   bne moveup3
00:81D6 E699            	   206:   inc token_work+1
                        	   207: moveup3:
                        	   208: ;
                        	   209: ;  see if length reached
                        	   210: ;
00:81D8 A598            	   211:   lda token_work
00:81DA C5AA            	   212:   cmp mem_move_len
00:81DC D007            	   213:   bne moveup_next
00:81DE A599            	   214:   lda token_work+1
00:81E0 C5AB            	   215:   cmp mem_move_len+1
00:81E2 D001            	   216:   bne moveup_next
                        	   217: moveup_done:
00:81E4 60              	   218:   rts
                        	   219: ;
                        	   220: ;  decrement Y, and decrement high-order address bytes if necessary
                        	   221: ;
                        	   222: moveup_next   =  *
00:81E5 88              	   223:   dey
00:81E6 C0FF            	   224:   cpy #$FF
00:81E8 D0E4            	   225:   bne moveup_loop
00:81EA C6A7            	   226:   dec mem_move_src+1
00:81EC C6A9            	   227:   dec mem_move_dest+1
00:81EE 80DE            	   228:   bra moveup_loop
                        	   229: 
                        	   230: ;
                        	   231: ;
                        	   232: ; String compare - case significant (max 128 byte strings)
                        	   233: ;
                        	   234: ; SRCE = source start address
                        	   235: ; DEST = destination start address
                        	   236: ; Y    = length of both strings (range 1 to 128)
                        	   237: ;
                        	   238: ;  returns Z set if strings are equal
                        	   239: ;
                        	   240: 
                        	   241: str_compare:
00:81F0 88              	   242:   dey             ; make zero-relative
00:81F1 300B            	   243:   bmi str_compare_done
00:81F3 B100            	   244:   lda (SRCE),y
00:81F5 8585            	   245:   sta str_work
00:81F7 B103            	   246:   lda (DEST),y
00:81F9 C585            	   247:   cmp str_work
00:81FB F0F3            	   248:   beq str_compare
00:81FD 60              	   249:   rts   ; no match, zero flag not set
                        	   250: str_compare_done:
00:81FE A900            	   251:   lda #0    ; set Z flag
00:8200 60              	   252:   rts
                        	   253: 
                        	   254: ;
                        	   255: ; String compare - case NOT significant (max 128 byte strings)
                        	   256: ;
                        	   257: ; SRCE = source start address
                        	   258: ; DEST = destination start address
                        	   259: ; Y    = length of both strings (range 1 to 128)
                        	   260: ;
                        	   261: ;  returns Z set if strings are equal
                        	   262: ;
                        	   263: 
                        	   264: str_ic_compare:
00:8201 88              	   265:   dey
00:8202 301F            	   266:   bmi str_ic_compare_done
00:8204 B100            	   267:   lda (SRCE),y
00:8206 C97B            	   268:   cmp #'z'+1
00:8208 B006            	   269:   bcs str_ic_compare_fixed_srce  ; BGE
00:820A C961            	   270:   cmp #'a'
00:820C 9002            	   271:   bcc str_ic_compare_fixed_srce  ; BLT
00:820E E920            	   272:   sbc #$20    ; make upper-case
                        	   273: str_ic_compare_fixed_srce:
00:8210 8585            	   274:   sta str_work
00:8212 B103            	   275:   lda (DEST),y
00:8214 C97B            	   276:   cmp #'z'+1
00:8216 B006            	   277:   bcs str_ic_compare_fixed_dest  ; BGE
00:8218 C961            	   278:   cmp #'a'
00:821A 9002            	   279:   bcc str_ic_compare_fixed_dest  ; BLT
00:821C E920            	   280:   sbc #$20    ; make upper-case
                        	   281: str_ic_compare_fixed_dest:
00:821E C585            	   282:   cmp str_work
00:8220 F0DF            	   283:   beq str_ic_compare
00:8222 60              	   284:   rts       ; no match, zero flag not set
                        	   285: str_ic_compare_done:
00:8223 A900            	   286:   lda #0    ; set Z flag
00:8225 60              	   287:   rts
                        	   288: 
                        	   289: 

Source: "gpascal.asm"
                        	   174:   .include "editor.inc"

Source: "editor.inc"
                        	     1: ;-------------------------------------------------
                        	     2: ;
                        	     3: ;  Shell, and text editor
                        	     4: ;
                        	     5: ;-------------------------------------------------
                        	     6: 
                        	     7: 
                        	     8: ;-------------------------------------------------
                        	     9: ;  print null-terminated message, message in A (lo) and X (hi)
                        	    10: ;  returns the length of the message in Y
                        	    11: ;-------------------------------------------------
                        	    12: print:
00:8226 A8              	    13:   tay   ; save A
00:8227 A503            	    14:   lda REG2 ; save REG2
00:8229 48              	    15:   pha
00:822A A504            	    16:   lda REG2+1  ; save REG2+1
00:822C 48              	    17:   pha
00:822D 98              	    18:   tya   ; get original A back
00:822E 8503            	    19:   sta REG2
00:8230 8604            	    20:   stx REG2+1
00:8232 A000            	    21:   ldy #0
                        	    22: print_loop:
00:8234 A58B            	    23:   lda  serial_in_byte_received
00:8236 F00A            	    24:   beq  print_not_abort
00:8238 C903            	    25:   cmp  #KEY_ABORT
00:823A D010            	    26:   bne  print_done
00:823C A980            	    27:   lda  #FLAG_ABORTED    ; set aborted flag
00:823E 04BE            	    28:   tsb  system_flags
00:8240 800A            	    29:   bra  print_done
                        	    30: print_not_abort:
00:8242 B103            	    31:   lda (REG2),y
00:8244 F006            	    32:   beq print_done
00:8246 20AF93          	    33:   jsr COUT
00:8249 C8              	    34:   iny
00:824A D0E8            	    35:   bne print_loop  ; give up if we overflow
                        	    36: print_done:
00:824C 648B            	    37:   stz serial_in_byte_received
                        	    38: ;
                        	    39: ;  get REG2 back
                        	    40: ;
00:824E 68              	    41:   pla
00:824F 8504            	    42:   sta REG2+1
00:8251 68              	    43:   pla
00:8252 8503            	    44:   sta REG2
00:8254 60              	    45:   rts
                        	    46: 
00:8255 472D50617363616C	    47: introduction asc    "G-Pascal compiler, version 4.0.\n"
00:825D 20636F6D70696C65
00:8265 722C207665727369
00:826D 6F6E20342E302E0A
00:8275 5772697474656E20	    48:              asciiz "Written by Nick Gammon.\nType H for help.\n"
00:827D 6279204E69636B20
00:8285 47616D6D6F6E2E0A
00:828D 5479706520482066
00:8295 6F722068656C702E
00:829D 0A
00:829E 00
00:829F 3A20            	    49: prompt       asciiz ": "
00:82A1 00
00:82A2 556E6B6E6F776E20	    50: bad_command  asciiz "Unknown command, type H for help.\n"
00:82AA 636F6D6D616E642C
00:82B2 2074797065204820
00:82BA 666F722068656C70
00:82C2 2E0A
00:82C4 00
                        	    51: 
                        	    52: ;-------------------------------------------------
                        	    53: ; Start here after Reset or NMI - show introduction
                        	    54: ;-------------------------------------------------
                        	    55: 
                        	    56: main_start:
00:82C5 A955            	    57:   lda #<introduction
00:82C7 A282            	    58:   ldx #>introduction
00:82C9 202682          	    59:   jsr print
                        	    60: 
                        	    61: main_prompt:
00:82CC A2FF            	    62:   ldx  #NEW_STK
00:82CE 9A              	    63:   txs
00:82CF D8              	    64:   cld
                        	    65: 
00:82D0 A99F            	    66:   lda #<prompt
00:82D2 A282            	    67:   ldx #>prompt
00:82D4 202682          	    68:   jsr print
                        	    69: 
00:82D7 208793          	    70:   jsr  GET_LINE
                        	    71: 
00:82DA A900            	    72:   lda #<INBUF
00:82DC 858E            	    73:   sta token_start
00:82DE A902            	    74:   lda #>INBUF
00:82E0 858F            	    75:   sta token_start+1
                        	    76: 
00:82E2 A901            	    77:   lda #1
00:82E4 853F            	    78:   sta RUNNING
                        	    79: 
                        	    80: ;-------------------------------------------------
                        	    81: ; EDITOR (SHELL) MAIN LOOP
                        	    82: ;-------------------------------------------------
                        	    83: 
                        	    84: main_loop:
00:82E6 64BC            	    85:   stz editor_flags  ; no flags yet
00:82E8 64BD            	    86:   stz find_flags    ;  ditto
00:82EA A901            	    87:   lda #FLAG_COMPILING
00:82EC 0902            	    88:   ora #FLAG_ASSEMBLING
00:82EE 14BE            	    89:   trb system_flags  ; not compiling or assembling now
                        	    90: 
00:82F0 A940            	    91:   lda #FLAG_ONLY_ALPHA
00:82F2 04BE            	    92:   tsb system_flags  ; we only want alpha commands, thus we can enter L1 and be the same as List 1
                        	    93: 
00:82F4 20F2C8          	    94:   jsr get_token
00:82F7 F0D3            	    95:   beq main_prompt   ; no input
                        	    96: 
                        	    97: ;
                        	    98: ;  Shortcut: If the input is "R" or "r" followed directly by a newline, assume they want to Run
                        	    99: ;
00:82F9 C949            	   100:   cmp #TOKEN_IDENTIFIER
00:82FB D015            	   101:   bne main_loop_not_run
                        	   102: 
00:82FD A000            	   103:   ldy #0
00:82FF B190            	   104:   lda (token_address),y
00:8301 20C48F          	   105:   jsr MAKE_UPPER
00:8304 C952            	   106:   cmp #'R'
00:8306 D00A            	   107:   bne main_loop_not_run
00:8308 C8              	   108:   iny
00:8309 B190            	   109:   lda (token_address),y
00:830B C90A            	   110:   cmp #NL
00:830D D003            	   111:   bne main_loop_not_run
00:830F 4C9F8E          	   112:   jmp editor_run
                        	   113: 
                        	   114: ;
                        	   115: ;  Not a RUN shortcut, look up the command in our table
                        	   116: ;
                        	   117: main_loop_not_run:
                        	   118: ;
                        	   119: ;  set up our input line as where to find tokens
                        	   120: ;
00:8312 A590            	   121:   lda token_address
00:8314 8500            	   122:   sta SRCE
00:8316 A591            	   123:   lda token_address+1
00:8318 8501            	   124:   sta SRCE+1
                        	   125: 
                        	   126: ;
                        	   127: ;  get editor handlers
                        	   128: ;
00:831A A930            	   129:   lda #<editor_handlers
00:831C 8503            	   130:   sta DEST
00:831E A983            	   131:   lda #>editor_handlers
00:8320 8504            	   132:   sta DEST+1
                        	   133: 
                        	   134: ;
                        	   135: ;  get the token length and look up the handler
                        	   136: ;
00:8322 A592            	   137:   lda token_length
00:8324 204D8F          	   138:   jsr partial_handler_Lookup
                        	   139: 
                        	   140: ;
                        	   141: ;  if we returned, unknown command
                        	   142: ;
00:8327 A9A2            	   143:   lda #<bad_command
00:8329 A282            	   144:   ldx #>bad_command
00:832B 202682          	   145:   jsr print
00:832E 809C            	   146:   bra  main_prompt
                        	   147: 
                        	   148: 
                        	   149: editor_handlers:
                        	   150:   makeHandler "LIST",    editor_list
00:8330 4C495354        	     1M    asciiz   "LIST"
00:8334 00
00:8335 4787            	     2M    word  editor_list
                        	   151:   makeHandler "INSERT",  editor_insert
00:8337 494E53455254    	     1M    asciiz   "INSERT"
00:833D 00
00:833E FA89            	     2M    word  editor_insert
                        	   152:   makeHandler "LOAD",    editor_load
00:8340 4C4F4144        	     1M    asciiz   "LOAD"
00:8344 00
00:8345 F689            	     2M    word  editor_load
                        	   153:   makeHandler "DELETE",  editor_delete
00:8347 44454C455445    	     1M    asciiz   "DELETE"
00:834D 00
00:834E 6E8B            	     2M    word  editor_delete
                        	   154:   makeHandler "HELP",    editor_help
00:8350 48454C50        	     1M    asciiz   "HELP"
00:8354 00
00:8355 3385            	     2M    word  editor_help
                        	   155:   makeHandler "COMPILE" ,editor_compile
00:8357 434F4D50494C45  	     1M    asciiz   "COMPILE" 
00:835E 00
00:835F 918E            	     2M    word  editor_compile
                        	   156:   makeHandler "SYNTAX",  editor_syntax
00:8361 53594E544158    	     1M    asciiz   "SYNTAX"
00:8367 00
00:8368 988E            	     2M    word  editor_syntax
                        	   157:   makeHandler "SAVE",    editor_save
00:836A 53415645        	     1M    asciiz   "SAVE"
00:836E 00
00:836F 4187            	     2M    word  editor_save
                        	   158: ;  makeHandler "TEST",    editor_test
                        	   159:   makeHandler "MEMORY",  editor_memory
00:8371 4D454D4F5259    	     1M    asciiz   "MEMORY"
00:8377 00
00:8378 CC8C            	     2M    word  editor_memory
                        	   160:  ; makeHandler "SYMTBL", editor_symbol_table_list
                        	   161:   makeHandler "INFO",    editor_info
00:837A 494E464F        	     1M    asciiz   "INFO"
00:837E 00
00:837F 858E            	     2M    word  editor_info
                        	   162:   makeHandler "TRACE",   editor_trace
00:8381 5452414345      	     1M    asciiz   "TRACE"
00:8386 00
00:8387 7C8E            	     2M    word  editor_trace
                        	   163:   makeHandler "DEBUG",   editor_debug
00:8389 4445425547      	     1M    asciiz   "DEBUG"
00:838E 00
00:838F 738E            	     2M    word  editor_debug
                        	   164:   makeHandler "ASSEMBLE",editor_assemble
00:8391 415353454D424C45	     1M    asciiz   "ASSEMBLE"
00:8399 00
00:839A 078F            	     2M    word  editor_assemble
                        	   165:   makeHandler "FIND",    editor_find
00:839C 46494E44        	     1M    asciiz   "FIND"
00:83A0 00
00:83A1 3B87            	     2M    word  editor_find
                        	   166:   makeHandler "REPLACE", editor_replace
00:83A3 5245504C414345  	     1M    asciiz   "REPLACE"
00:83AA 00
00:83AB 3387            	     2M    word  editor_replace
                        	   167:   makeHandler "RUN",     editor_run
00:83AD 52554E          	     1M    asciiz   "RUN"
00:83B0 00
00:83B1 9F8E            	     2M    word  editor_run
                        	   168:   makeHandler "RECOVER", editor_recover
00:83B3 5245434F564552  	     1M    asciiz   "RECOVER"
00:83BA 00
00:83BB 4D8E            	     2M    word  editor_recover
00:83BD 00              	   169:   dfb 0
                        	   170: 
                        	   171: editor_help_info:
00:83BE 417661696C61626C	   172:   asc "Available actions:\n\n"
00:83C6 6520616374696F6E
00:83CE 733A0A0A
00:83D2 4C6973742F534176	   173:   asc "List/SAve   line_number_range\n"
00:83DA 652020206C696E65
00:83E2 5F6E756D6265725F
00:83EA 72616E67650A
00:83F0 44656C6574652020	   174:   asc "Delete      line_number_range\n"
00:83F8 202020206C696E65
00:8400 5F6E756D6265725F
00:8408 72616E67650A
00:840E 496E736572742F4C	   175:   asc "Insert/LOad after_line\n"
00:8416 4F61642061667465
00:841E 725F6C696E650A
00:8425 46696E6420202020	   176:   asc "Find        line_number_range /target/flags\n"
00:842D 202020206C696E65
00:8435 5F6E756D6265725F
00:843D 72616E6765202F74
00:8445 61726765742F666C
00:844D 6167730A
00:8451 5265706C61636520	   177:   asc "Replace     line_number_range /target/replacement/flags\n"
00:8459 202020206C696E65
00:8461 5F6E756D6265725F
00:8469 72616E6765202F74
00:8471 61726765742F7265
00:8479 706C6163656D656E
00:8481 742F666C6167730A
00:8489 0A              	   178:   asc "\n"
00:848A 48656C700A      	   179:   asc "Help\n"
00:848F 494E666F0A      	   180:   asc "INfo\n"
00:8494 4D656D6F72792020	   181:   asc "Memory      first_address last_address\n"
00:849C 2020202066697273
00:84A4 745F616464726573
00:84AC 73206C6173745F61
00:84B4 6464726573730A
00:84BB 436F6D70696C652F	   182:   asc "Compile/Syntax/Assemble\n"
00:84C3 53796E7461782F41
00:84CB 7373656D626C650A
00:84D3 52556E2F44454275	   183:   asc "RUn/DEBug/Trace\n"
00:84DB 672F54726163650A
00:84E3 5245436F7665720A	   184:   asc "RECover\n"
00:84EB 28416374696F6E73	   185:   asc "(Actions may be abbreviated)\n"
00:84F3 206D617920626520
00:84FB 6162627265766961
00:8503 746564290A
00:8508 28466C6167733A20	   186:   asc "(Flags: 'I'gnore case, 'G'lobal, 'Q'uiet)\n"
00:8510 274927676E6F7265
00:8518 20636173652C2027
00:8520 47276C6F62616C2C
00:8528 2027512775696574
00:8530 290A
00:8532 00              	   187:   dfb 0
                        	   188: 
                        	   189: 
                        	   190: ;--------------------------------------------
                        	   191: ;  HELP
                        	   192: ;--------------------------------------------
                        	   193: editor_help:
00:8533 A9BE            	   194:   lda #<editor_help_info
00:8535 8500            	   195:   sta REG
00:8537 A983            	   196:   lda #>editor_help_info
00:8539 8501            	   197:   sta REG+1
                        	   198: editor_help_loop:
00:853B A000            	   199:   ldy #0
00:853D B100            	   200:   lda (REG),Y
00:853F F00B            	   201:   beq editor_help_done
00:8541 20AF93          	   202:   jsr COUT
00:8544 E600            	   203:   inc REG
00:8546 D0F3            	   204:   bne editor_help_loop
00:8548 E601            	   205:   inc REG+1
00:854A 80EF            	   206:   bra editor_help_loop
                        	   207: editor_help_done:
00:854C 4CCC82          	   208:   jmp main_prompt
                        	   209: 
                        	   210: ;
                        	   211: ;  Sets default range from 1 to 65535
                        	   212: ;
                        	   213: editor_default_range:
                        	   214: ;
                        	   215: ;  default to all lines
                        	   216: ;
00:854F A901            	   217:   lda #1
00:8551 859E            	   218:   sta from_line
00:8553 649F            	   219:   stz from_line+1
00:8555 A9FF            	   220:   lda #$FF
00:8557 85A0            	   221:   sta to_line
00:8559 85A1            	   222:   sta to_line+1
00:855B 60              	   223:   rts
                        	   224: 
                        	   225: number_expected_message:
00:855C 4E756D6265722065	   226:   asciiz "Number expected\n"
00:8564 787065637465640A
00:856C 00
                        	   227: 
                        	   228: editor_bad_number:
00:856D A95C            	   229:   lda #<number_expected_message
00:856F A285            	   230:   ldx #>number_expected_message
00:8571 202682          	   231:   jsr print
00:8574 4CCC82          	   232:   jmp main_prompt
                        	   233: 
                        	   234: ;
                        	   235: ;  get a number for the editor: accepts eof or newline as "no number"
                        	   236: ;  otherwise must be a number and in the range 0x0001 to 0xFFFF
                        	   237: ;  returns carry set if a number (in token_value) and carry clear if
                        	   238: ;  no number. Raises an error otherwise
                        	   239: ;
                        	   240: editor_get_number:
00:8577 20F2C8          	   241:   jsr get_token
00:857A F05E            	   242:   beq editor_get_number_none ; no token? return with carry set
00:857C C90A            	   243:   cmp #NL
00:857E F05A            	   244:   beq editor_get_number_none ; newline counts as no token
00:8580 C94E            	   245:   cmp #TOKEN_NUMBER
00:8582 F044            	   246:   beq editor_get_number_ok
00:8584 C949            	   247:   cmp #TOKEN_IDENTIFIER
00:8586 D02A            	   248:   bne editor_get_number_not_identifier
00:8588 A592            	   249:   lda token_length
00:858A C903            	   250:   cmp #3
00:858C D0DF            	   251:   bne editor_bad_number
00:858E A000            	   252:   ldy #0
00:8590 B190            	   253:   lda (token_address),y
00:8592 20C48F          	   254:   jsr MAKE_UPPER
00:8595 C941            	   255:   cmp #'A'
00:8597 D0D4            	   256:   bne editor_bad_number
00:8599 C8              	   257:   iny
00:859A B190            	   258:   lda (token_address),y
00:859C 20C48F          	   259:   jsr MAKE_UPPER
00:859F C94C            	   260:   cmp #'L'
00:85A1 D0CA            	   261:   bne editor_bad_number
00:85A3 C8              	   262:   iny
00:85A4 B190            	   263:   lda (token_address),y
00:85A6 20C48F          	   264:   jsr MAKE_UPPER
00:85A9 C94C            	   265:   cmp #'L'
00:85AB D0C0            	   266:   bne editor_bad_number
00:85AD 204F85          	   267:   jsr editor_default_range
00:85B0 8028            	   268:   bra editor_get_number_none
                        	   269: ;
                        	   270: ;  find / replace can go straight to the delimiter
                        	   271: ;
                        	   272: editor_get_number_not_identifier:
00:85B2 A910            	   273:   lda #EFLAG_FIND
00:85B4 0920            	   274:   ora #EFLAG_REPLACE
00:85B6 25BC            	   275:   and editor_flags
00:85B8 F0B3            	   276:   beq editor_bad_number
00:85BA A592            	   277:   lda token_length
00:85BC C901            	   278:   cmp #1
00:85BE D0AD            	   279:   bne editor_bad_number
                        	   280: ;
                        	   281: ;  go back one character, we need get_token to find this again later
                        	   282: ;
00:85C0 C68E            	   283:   dec token_start
00:85C2 D016            	   284:   bne editor_get_number_none
00:85C4 C68F            	   285:   dec token_start+1
00:85C6 8012            	   286:   bra editor_get_number_none
                        	   287: 
                        	   288: editor_get_number_ok:
00:85C8 A596            	   289:   lda token_value+2         ; must be a number
00:85CA D02F            	   290:   bne editor_line_number_too_big
00:85CC A5BC            	   291:   lda editor_flags
00:85CE 2902            	   292:   and #EFLAG_ALLOW_ZERO_FROM
00:85D0 D006            	   293:   bne editor_get_number_done
00:85D2 A594            	   294:   lda token_value
00:85D4 0595            	   295:   ora token_value+1
00:85D6 F023            	   296:   beq editor_line_number_too_big  ; too small actually
                        	   297: editor_get_number_done:
00:85D8 38              	   298:   sec
00:85D9 60              	   299:   rts
                        	   300: 
                        	   301: editor_get_number_none:
00:85DA 18              	   302:   clc
00:85DB 60              	   303:   rts
                        	   304: 
                        	   305: number_too_large_message:
00:85DC 4E756D6265722074	   306:   asciiz "Number too large or too small\n"
00:85E4 6F6F206C61726765
00:85EC 206F7220746F6F20
00:85F4 736D616C6C0A
00:85FA 00
                        	   307: 
                        	   308: editor_line_number_too_big:
00:85FB A9DC            	   309:   lda #<number_too_large_message
00:85FD A285            	   310:   ldx #>number_too_large_message
00:85FF 202682          	   311:   jsr print
00:8602 4CCC82          	   312:   jmp main_prompt
                        	   313: 
                        	   314: number_bad_range_message:
00:8605 52616E676520696E	   315:   asciiz "Range invalid\n"
00:860D 76616C69640A
00:8613 00
                        	   316: 
                        	   317: editor_bad_range:
00:8614 A905            	   318:   lda #<number_bad_range_message
00:8616 A286            	   319:   ldx #>number_bad_range_message
00:8618 202682          	   320:   jsr print
00:861B 4CCC82          	   321:   jmp main_prompt
                        	   322: 
                        	   323: too_much_on_line:
00:861E 556E657870656374	   324:   asciiz "Unexpected input on line\n"
00:8626 656420696E707574
00:862E 206F6E206C696E65
00:8636 0A
00:8637 00
                        	   325: 
                        	   326: editor_check_no_more:
00:8638 20F2C8          	   327:   jsr get_token
00:863B F00A            	   328:   beq editor_check_no_more_ok
00:863D A91E            	   329:   lda #<too_much_on_line
00:863F A286            	   330:   ldx #>too_much_on_line
00:8641 202682          	   331:   jsr print
00:8644 4CCC82          	   332:   jmp main_prompt
                        	   333: editor_check_no_more_ok:
00:8647 60              	   334:   rts
                        	   335: 
                        	   336: 
                        	   337: 
                        	   338: ;--------------------------------------------
                        	   339: ;  get a range of line numbers (eg. L 1,10; D 4; M 6,10 )
                        	   340: ;--------------------------------------------
                        	   341: 
                        	   342: editor_get_range:
                        	   343: 
                        	   344: 
                        	   345: ;
                        	   346: ;  get the first line number (if any)
                        	   347: ;
00:8648 207785          	   348:   jsr editor_get_number
00:864B 9045            	   349:   bcc editor_get_range_done ; no token? take defaults
                        	   350: ;
                        	   351: ;  store the from line
                        	   352: ;
00:864D A594            	   353:   lda token_value
00:864F 859E            	   354:   sta from_line
00:8651 85A0            	   355:   sta to_line
00:8653 A595            	   356:   lda token_value+1
00:8655 859F            	   357:   sta from_line+1
00:8657 85A1            	   358:   sta to_line+1
                        	   359: 
                        	   360: ;
                        	   361: ;  comma or hyphen?
                        	   362: ;
00:8659 20F2C8          	   363:   jsr get_token
00:865C F034            	   364:   beq editor_get_range_done   ; line done, just the single line wanted
                        	   365: 
00:865E C92D            	   366:   cmp #'-'
00:8660 F018            	   367:   beq editor_get_range_hyphen
00:8662 C94E            	   368:   cmp #TOKEN_NUMBER
00:8664 F019            	   369:   beq editor_get_range_number
00:8666 C92C            	   370:   cmp #','
00:8668 F010            	   371:   beq editor_get_range_hyphen
                        	   372: ;
                        	   373: ;  find and replace may have another character after the first line number
                        	   374: ;  which isn't a second line number or a hyphen/comma
                        	   375: ;
00:866A A910            	   376:   lda #EFLAG_FIND
00:866C 0920            	   377:   ora #EFLAG_REPLACE
00:866E 25BC            	   378:   and editor_flags
00:8670 F0A2            	   379:   beq editor_bad_range
                        	   380: 
                        	   381: ;
                        	   382: ;  go back one character, we need get_token to find this again later
                        	   383: ;
00:8672 C68E            	   384:   dec token_start
00:8674 D01C            	   385:   bne editor_get_range_done
00:8676 C68F            	   386:   dec token_start+1
00:8678 8018            	   387:   bra editor_get_range_done
                        	   388: 
                        	   389: editor_get_range_hyphen:
                        	   390: ;
                        	   391: ;  get the second line number
                        	   392: ;
00:867A 207785          	   393:   jsr editor_get_number
00:867D 9095            	   394:   bcc editor_bad_range
                        	   395: 
                        	   396: editor_get_range_number:
00:867F A594            	   397:   lda token_value
00:8681 85A0            	   398:   sta to_line
00:8683 A595            	   399:   lda token_value+1
00:8685 85A1            	   400:   sta to_line+1
                        	   401: 
                        	   402: ;
                        	   403: ;  make sure range ascends
                        	   404: ;
00:8687 38              	   405:   sec
00:8688 A5A0            	   406:   lda to_line
00:868A E59E            	   407:   sbc from_line
00:868C A5A1            	   408:   lda to_line+1
00:868E E59F            	   409:   sbc from_line+1
00:8690 9082            	   410:   bcc editor_bad_range    ; <sigh> because of the way SBC works
                        	   411: 
                        	   412: editor_get_range_done:
00:8692 60              	   413:   rts
                        	   414: 
                        	   415: 
                        	   416: ;
                        	   417: 
00:8693 20666F756E640A  	   418: found_message asciiz  ' found\n'
00:869A 00
                        	   419: 
                        	   420: 
                        	   421: 
00:869B 46726F6D3A20    	   422: from_msg: asciiz "From: "
00:86A1 00
00:86A2 20746F20        	   423: to_msg:   asciiz " to "
00:86A6 00
                        	   424: 
00:86A7 4261642064656C69	   425: bad_delimiter_message asciiz "Bad delimiter\n"
00:86AF 6D697465720A
00:86B5 00
                        	   426: 
                        	   427: editor_bad_delimiter:
00:86B6 A9A7            	   428:   lda #<bad_delimiter_message
00:86B8 A286            	   429:   ldx #>bad_delimiter_message
                        	   430: editor_find_problem:
00:86BA 202682          	   431:   jsr print
00:86BD 4CCC82          	   432:   jmp main_prompt
                        	   433: 
00:86C0 46696E642F726570	   434: find_string_too_long_message asciiz "Find/replace string too long\n"
00:86C8 6C61636520737472
00:86D0 696E6720746F6F20
00:86D8 6C6F6E670A
00:86DD 00
                        	   435: 
                        	   436: find_string_too_long:
00:86DE A9C0            	   437:   lda #<find_string_too_long_message
00:86E0 A286            	   438:   ldx #>find_string_too_long_message
00:86E2 80D6            	   439:   bra editor_find_problem
                        	   440: 
                        	   441: editor_get_delimiter:
00:86E4 20F2C8          	   442:   jsr get_token
00:86E7 C949            	   443:   cmp #TOKEN_IDENTIFIER
00:86E9 F0CB            	   444:   beq editor_bad_delimiter
00:86EB C94E            	   445:   cmp #TOKEN_NUMBER
00:86ED F0C7            	   446:   beq editor_bad_delimiter
00:86EF C922            	   447:   cmp #TOKEN_STRING
00:86F1 F0C3            	   448:   beq editor_bad_delimiter
00:86F3 A692            	   449:   ldx token_length
00:86F5 E001            	   450:   cpx #1
00:86F7 D0BD            	   451:   bne editor_bad_delimiter
00:86F9 85B4            	   452:   sta find_delimiter
00:86FB 60              	   453:   rts
                        	   454: 
00:86FC 4E6F20636C6F7369	   455: editor_no_closing_delimiter_message asciiz "No closing delimiter\n"
00:8704 6E672064656C696D
00:870C 697465720A
00:8711 00
                        	   456: 
                        	   457: editor_no_closing_delimiter:
00:8712 A9FC            	   458:   lda #<editor_no_closing_delimiter_message
00:8714 A286            	   459:   ldx #>editor_no_closing_delimiter_message
00:8716 80A2            	   460:   bra editor_find_problem
                        	   461: 
00:8718 5461726765742073	   462: no_find_message asciiz "Target string empty\n"
00:8720 7472696E6720656D
00:8728 7074790A
00:872C 00
                        	   463: 
                        	   464: editor_no_find_string:
00:872D A918            	   465:   lda #<no_find_message
00:872F A287            	   466:   ldx #>no_find_message
00:8731 8087            	   467:   bra editor_find_problem
                        	   468: 
                        	   469: ;--------------------------------------------
                        	   470: ;  LIST / SAVE / FIND / REPLACE / MODIFY
                        	   471: ;
                        	   472: ;  This rather complex routine lists the source between from_line and to_line
                        	   473: ;   In the process it can show or omit line numbers  (omit for SAVE)
                        	   474: ;  Also, it can find the target text, and optionally replace it with the replacement text
                        	   475: ;  In find/replace mode the lines are not shown unless they had something found (unless
                        	   476: ;   the Quiet flag is set)
                        	   477: ;
                        	   478: ;--------------------------------------------
                        	   479: 
                        	   480: editor_replace:
00:8733 A920            	   481:   lda #EFLAG_REPLACE
00:8735 0910            	   482:   ora #EFLAG_FIND   ; makes things simpler later on
00:8737 85BC            	   483:   sta editor_flags
00:8739 800C            	   484:   bra editor_list
                        	   485: 
                        	   486: editor_find:
                        	   487: 
00:873B A910            	   488:   lda #EFLAG_FIND
00:873D 85BC            	   489:   sta editor_flags
00:873F 8006            	   490:   bra editor_list
                        	   491: 
                        	   492: editor_save
                        	   493: 
00:8741 A980            	   494:   lda #EFLAG_NO_LINE_NUMBERS
00:8743 0908            	   495:   ora #EFLAG_SAVE
00:8745 85BC            	   496:   sta editor_flags
                        	   497: 
                        	   498: ;
                        	   499: ;  main entry point - get the from and to lines
                        	   500: ;
                        	   501: editor_list:
00:8747 204F85          	   502:   jsr editor_default_range
00:874A 204886          	   503:   jsr editor_get_range
                        	   504: 
                        	   505: ;
                        	   506: ;  turn the from_line into an address and put it into PCODE
                        	   507: ;
00:874D A59E            	   508:   lda from_line
00:874F 85AC            	   509:   sta this_line
00:8751 A59F            	   510:   lda from_line+1
00:8753 85AD            	   511:   sta this_line+1
00:8755 20558C          	   512:   jsr find_line    ; find the "from" line address (this_line in fact)
00:8758 A5AE            	   513:   lda this_line_addr
00:875A 8523            	   514:   sta PCODE
00:875C A5AF            	   515:   lda this_line_addr+1
00:875E 8524            	   516:   sta PCODE+1
00:8760 64B9            	   517:   stz find_count
00:8762 64BA            	   518:   stz find_count+1
                        	   519: 
                        	   520: ;
                        	   521: ;  for FIND and REPLACE, get the first delimiter
                        	   522: ;
00:8764 A5BC            	   523:   lda editor_flags
00:8766 2910            	   524:   and #EFLAG_FIND
00:8768 D003            	   525:   bne editor_list_doing_find
00:876A 4C3788          	   526:   jmp editor_list_not_find
                        	   527: 
                        	   528: editor_list_doing_find:
00:876D 20E486          	   529:   jsr editor_get_delimiter
                        	   530: ;
                        	   531: ;  token_next should now be the start of what we are searching for
                        	   532: ;
00:8770 38              	   533:   sec
00:8771 A58E            	   534:   lda token_start
00:8773 E900            	   535:   sbc #<INBUF
00:8775 85B0            	   536:   sta find_from
00:8777 B00B            	   537:   bcs editor_list_got_from_point ; delimiter should be a single byte
                        	   538: 
                        	   539: editor_find_bug:
00:8779 A214            	   540:   ldx #20  ; ERROR: bug
00:877B 4C6497          	   541:   jmp ERROR
                        	   542: 
00:877E 4CDE86          	   543: find_string_too_longJ         jmp find_string_too_long
00:8781 4C1287          	   544: editor_no_closing_delimiterJ  jmp editor_no_closing_delimiter
                        	   545: 
                        	   546: editor_list_got_from_point:
                        	   547: 
                        	   548: ;
                        	   549: ;  Now find closing delimiter by a simple scan as we will pass who-knows-what on the way
                        	   550: ;
00:8784 A6B0            	   551:   ldx find_from
                        	   552: editor_find_second_delimiter_loop:
00:8786 E8              	   553:   inx
00:8787 BD0002          	   554:   lda INBUF,x
00:878A F0F5            	   555:   beq editor_no_closing_delimiterJ
00:878C C90A            	   556:   cmp #NL
00:878E F0F1            	   557:   beq editor_no_closing_delimiterJ
00:8790 C5B4            	   558:   cmp find_delimiter
00:8792 D0F2            	   559:   bne editor_find_second_delimiter_loop
                        	   560: 
                        	   561: ;
                        	   562: ;  found the closing delimiter
                        	   563: ;
00:8794 86B1            	   564:   stx find_to
00:8796 E4B0            	   565:   cpx find_from
00:8798 F093            	   566:   beq editor_no_find_string
                        	   567: ;
                        	   568: ;  maximum 127 byte find string
                        	   569: ;
00:879A 38              	   570:   sec
00:879B A5B1            	   571:   lda find_to
00:879D E5B0            	   572:   sbc find_from
00:879F 30DD            	   573:   bmi find_string_too_longJ
00:87A1 85B3            	   574:   sta find_len    ; save for later memory move calculations
                        	   575: 
00:87A3 A920            	   576:   lda #EFLAG_REPLACE
00:87A5 25BC            	   577:   and editor_flags
00:87A7 F02A            	   578:   beq editor_find_get_flags
                        	   579: 
                        	   580: ;
                        	   581: ;  doing a replace - find second delimiter
                        	   582: ;
                        	   583: 
00:87A9 86B5            	   584:   stx rep_from
00:87AB E6B5            	   585:   inc rep_from    ; get past the delimiter
                        	   586: 
                        	   587: editor_find_third_delimiter_loop:
00:87AD E8              	   588:   inx
00:87AE BD0002          	   589:   lda INBUF,x
00:87B1 F0CE            	   590:   beq editor_no_closing_delimiterJ
00:87B3 C90A            	   591:   cmp #NL
00:87B5 F0CA            	   592:   beq editor_no_closing_delimiterJ
00:87B7 C5B4            	   593:   cmp find_delimiter
00:87B9 D0F2            	   594:   bne editor_find_third_delimiter_loop
                        	   595: 
                        	   596: ;
                        	   597: ;  found the replacement closing delimiter
00:87BB 86B6            	   598:   stx rep_to
                        	   599: 
                        	   600: ;
                        	   601: ;  maximum 127 byte replacement string
                        	   602: ;
00:87BD 38              	   603:   sec
00:87BE A5B6            	   604:   lda rep_to
00:87C0 E5B5            	   605:   sbc rep_from
00:87C2 30BA            	   606:   bmi find_string_too_longJ
                        	   607: 
                        	   608: ;
                        	   609: ;  now find the signed difference between the find and replace strings
                        	   610: ;  namely: (rep_to - rep_from) - find_len
                        	   611: ;
00:87C4 64B8            	   612:   stz rep_diff+1
00:87C6 38              	   613:   sec
00:87C7 A5B6            	   614:   lda rep_to
00:87C9 E5B5            	   615:   sbc rep_from
00:87CB E5B3            	   616:   sbc find_len
00:87CD 85B7            	   617:   sta rep_diff
00:87CF 1002            	   618:   bpl editor_find_get_flags
00:87D1 C6B8            	   619:   dec rep_diff+1   ; make that $ff
                        	   620: 
                        	   621: ;
                        	   622: ; get any find/replace flags
                        	   623: ;
                        	   624: editor_find_get_flags:
00:87D3 64BD            	   625:   stz find_flags
                        	   626: 
                        	   627: editor_flags_loop:
00:87D5 E8              	   628:   inx
00:87D6 BD0002          	   629:   lda INBUF,X
00:87D9 C90A            	   630:   cmp #NL
00:87DB F042            	   631:   beq editor_list_fix_target_string
00:87DD 204A81          	   632:   jsr isspace
00:87E0 B0F3            	   633:   bcs editor_flags_loop
00:87E2 20C48F          	   634:   jsr MAKE_UPPER
00:87E5 C951            	   635:   cmp #'Q'
00:87E7 D00A            	   636:   bne editor_flags1
00:87E9 A904            	   637:   lda #FFLAG_QUIET
00:87EB 04BD            	   638:   tsb find_flags
00:87ED A980            	   639:   lda #EFLAG_NO_LINE_NUMBERS
00:87EF 04BC            	   640:   tsb editor_flags
00:87F1 80E2            	   641:   bra editor_flags_loop
                        	   642: editor_flags1:
00:87F3 C947            	   643:   cmp #'G'
00:87F5 D006            	   644:   bne editor_flags2
00:87F7 A902            	   645:   lda #FFLAG_GLOBAL
00:87F9 04BD            	   646:   tsb find_flags
00:87FB 80D8            	   647:   bra editor_flags_loop
                        	   648: editor_flags2:
00:87FD C949            	   649:   cmp #'I'
00:87FF D006            	   650:   bne editor_flags3
00:8801 A901            	   651:   lda #FFLAG_IGNORE_CASE
00:8803 04BD            	   652:   tsb find_flags
00:8805 80CE            	   653:   bra editor_flags_loop
                        	   654: editor_flags3:
00:8807 A911            	   655:   lda #<bad_flag_message
00:8809 A288            	   656:   ldx #>bad_flag_message
00:880B 202682          	   657:   jsr print
00:880E 4CCC82          	   658:   jmp main_prompt
                        	   659: 
00:8811 556E6B6E6F776E20	   660: bad_flag_message: asciiz "Unknown flag\n"
00:8819 666C61670A
00:881E 00
                        	   661: 
                        	   662: editor_list_fix_target_string:
                        	   663: 
00:881F A901            	   664:   lda #FFLAG_IGNORE_CASE
00:8821 25BD            	   665:   and find_flags
00:8823 F015            	   666:   beq editor_list_get_on_with_it
                        	   667: 
                        	   668: ;
                        	   669: ;  for case insensitive compare force target to be upper case
                        	   670: ;
00:8825 A6B0            	   671:   ldx find_from
                        	   672: editor_list_fixup_loop:
00:8827 E4B1            	   673:   cpx find_to
00:8829 F00F            	   674:   beq editor_list_get_on_with_it
00:882B BD0002          	   675:   lda INBUF,X
00:882E 20C48F          	   676:   jsr MAKE_UPPER
00:8831 9D0002          	   677:   sta INBUF,X
00:8834 E8              	   678:   inx
00:8835 80F0            	   679:   bra editor_list_fixup_loop
                        	   680: 
                        	   681: 
                        	   682: editor_list_not_find:
                        	   683: ;
                        	   684: ;  we should have no more tokens now
                        	   685: ;
00:8837 203886          	   686:   jsr editor_check_no_more
                        	   687: 
                        	   688: editor_list_get_on_with_it:
                        	   689: ;
                        	   690: ;  make sure current_line is correct
                        	   691: ;
00:883A A59E            	   692:   lda from_line
00:883C 85A2            	   693:   sta current_line
00:883E A59F            	   694:   lda from_line+1
00:8840 85A3            	   695:   sta current_line+1
                        	   696: 
                        	   697: ;
                        	   698: ;  exit immediately if no source from here on
                        	   699: ;
00:8842 A000            	   700:   ldy #0
00:8844 B123            	   701:   lda (PCODE),Y
00:8846 D003            	   702:   bne editor_list_have_source
00:8848 4C6689          	   703:   jmp editor_list_done
                        	   704: 
                        	   705: editor_list_have_source:
00:884B A901            	   706:   lda #EFLAG_SHOW_LINE
00:884D 04BC            	   707:   tsb editor_flags
00:884F 8006            	   708:   bra editor_list_loop
                        	   709: 
00:8851 4C6689          	   710: editor_list_doneJ jmp editor_list_done
00:8854 4C2889          	   711: editor_list_no_line_numberJ jmp editor_list_no_line_number
                        	   712: 
                        	   713: editor_list_loop:
00:8857 A58B            	   714:   lda serial_in_byte_received
00:8859 C903            	   715:   cmp  #KEY_ABORT
00:885B F021            	   716:   beq  editor_list_aborted
00:885D 64BB            	   717:   stz  found_this_line
00:885F A000            	   718:   ldy #0
00:8861 B123            	   719:   lda (PCODE),Y
00:8863 F0EC            	   720:   beq editor_list_doneJ
00:8865 A5BC            	   721:   lda editor_flags
00:8867 2901            	   722:   and #EFLAG_SHOW_LINE
00:8869 F0E9            	   723:   beq  editor_list_no_line_numberJ
00:886B A5BC            	   724:   lda editor_flags
00:886D 2908            	   725:   and #EFLAG_SAVE
00:886F D0E3            	   726:   bne editor_list_no_line_numberJ
                        	   727: ;
                        	   728: ;  At this exact point we know we are at the start of a line
                        	   729: ;  and we aren't doing a Save. Now, if we are doing a Find then
                        	   730: ;  we need to know if this line (from here to the next newline)
                        	   731: ;  matches our find string, and if not, to skip it
                        	   732: 
00:8871 A940            	   733:   lda #EFLAG_SUPPRESS_NEWLINE
00:8873 14BC            	   734:   trb editor_flags              ; we can show newlines now
                        	   735: 
00:8875 A5BC            	   736:   lda editor_flags
00:8877 2910            	   737:   and #EFLAG_FIND
00:8879 D010            	   738:   bne editor_find_or_replacing
                        	   739: 
00:887B 4C1B89          	   740:   jmp  editor_list_not_finding
                        	   741: 
                        	   742: ;
                        	   743: ;  Here when Ctrl+C pressed
                        	   744: ;
                        	   745: editor_list_aborted:
00:887E A232            	   746:   ldx #50
00:8880 A000            	   747:   ldy #0
00:8882 20D590          	   748:   jsr delay   ; 50 ms delay to allow serial to settle
00:8885 202892          	   749:   jsr CROUT
00:8888 4C6689          	   750:   jmp editor_list_done
                        	   751: 
                        	   752: editor_find_or_replacing:
                        	   753: 
                        	   754: ;
                        	   755: ;  here if finding or replacing
                        	   756: ;
                        	   757: 
00:888B A900            	   758:   lda #0
                        	   759: 
                        	   760: ;
                        	   761: ;  we come back here for multiple replacements with a new starting pos
                        	   762: ;
                        	   763: editor_replacement_loop:
00:888D 85B2            	   764:   sta find_pos    ; searching line from beginning (or not, if doing a multiple replace)
                        	   765: 
                        	   766: editor_find_loop:
00:888F A6B0            	   767:   ldx find_from   ; out target string position in INBUF
00:8891 A4B2            	   768:   ldy find_pos    ; where we are on the line
                        	   769: editor_find_inner_loop:
00:8893 E4B1            	   770:   cpx find_to     ; reached end of target, found the string!
00:8895 F037            	   771:   beq editor_find_found_it
00:8897 B123            	   772:   lda (PCODE),Y
00:8899 C90A            	   773:   cmp #NL
00:889B F01B            	   774:   beq editor_find_no_match ; hit end of line without matching
                        	   775: 
                        	   776: ;
                        	   777: ;  force to upper-case if required
                        	   778: ;
00:889D 48              	   779:   pha
00:889E A901            	   780:   lda #FFLAG_IGNORE_CASE
00:88A0 25BD            	   781:   and find_flags
00:88A2 F006            	   782:   beq editor_find_case_sensitive
00:88A4 68              	   783:   pla
00:88A5 20C48F          	   784:   jsr MAKE_UPPER
00:88A8 8001            	   785:   bra editor_find_test_character
                        	   786: editor_find_case_sensitive:
00:88AA 68              	   787:   pla
                        	   788: editor_find_test_character:
00:88AB DD0002          	   789:   cmp INBUF,X     ; does source byte match target byte?
00:88AE D004            	   790:   bne editor_find_skip_this
00:88B0 C8              	   791:   iny
00:88B1 E8              	   792:   inx
00:88B2 80DF            	   793:   bra editor_find_inner_loop
                        	   794: 
                        	   795: editor_find_skip_this:
00:88B4 E6B2            	   796:   inc find_pos
00:88B6 D0D7            	   797:   bne editor_find_loop  ; if it wraps, give up
                        	   798: 
                        	   799: ;
                        	   800: ;  we are at the newline without a match, increment PCODE to match
                        	   801: ;  where we are and go onto newline processing
                        	   802: ;
                        	   803: editor_find_no_match:
00:88B8 A5BB            	   804:    lda found_this_line
00:88BA D05F            	   805:    bne editor_list_not_finding
00:88BC 18              	   806:    clc
00:88BD 98              	   807:    tya
00:88BE 6523            	   808:    adc PCODE
00:88C0 8523            	   809:    sta PCODE
00:88C2 A900            	   810:    lda #0
00:88C4 6524            	   811:    adc PCODE+1
00:88C6 8524            	   812:    sta PCODE+1
00:88C8 A940            	   813:    lda #EFLAG_SUPPRESS_NEWLINE
00:88CA 04BC            	   814:    tsb editor_flags
00:88CC 8062            	   815:    bra editor_newline_processing
                        	   816: 
                        	   817: ;
                        	   818: ;  here when find succeeded
                        	   819: ;
                        	   820: editor_find_found_it:
00:88CE E6B9            	   821:   inc find_count
00:88D0 D002            	   822:   bne editor_find_found_it1
00:88D2 E6BA            	   823:   inc find_count+1
                        	   824: editor_find_found_it1:
00:88D4 A901            	   825:   lda #1
00:88D6 85BB            	   826:   sta found_this_line
00:88D8 A920            	   827:   lda #EFLAG_REPLACE
00:88DA 25BC            	   828:   and editor_flags
00:88DC D00E            	   829:   bne editor_do_the_replace
                        	   830: 
00:88DE A902            	   831:   lda #FFLAG_GLOBAL
00:88E0 25BD            	   832:   and find_flags
00:88E2 F037            	   833:   beq editor_list_not_finding   ; one replace is enough
                        	   834: 
                        	   835: ;
                        	   836: ;  add the find length to Y (moving past what we just found)
                        	   837: ;
                        	   838: ;
00:88E4 18              	   839:   clc
00:88E5 A5B2            	   840:   lda find_pos
00:88E7 65B3            	   841:   adc find_len
00:88E9 4C8D88          	   842:   jmp editor_replacement_loop
                        	   843: 
                        	   844: ;
                        	   845: ;  here when replacing
                        	   846: ;
                        	   847: editor_do_the_replace:
00:88EC A908            	   848:   lda #FLAG_VALID_COMPILE   ; compile or assemble no longer valid
00:88EE 0910            	   849:   ora #FLAG_VALID_ASSEMBLE
00:88F0 14BE            	   850:   trb system_flags
                        	   851: 
00:88F2 A5B7            	   852:   lda rep_diff ; same length?
00:88F4 F003            	   853:   beq editor_easy_replace
00:88F6 4C8689          	   854:   jmp editor_do_replace
                        	   855: 
                        	   856: editor_easy_replace:
00:88F9 A4B2            	   857:   ldy find_pos
00:88FB A6B5            	   858:   ldx rep_from
                        	   859: editor_easy_replace_loop:
00:88FD E4B6            	   860:   cpx rep_to
00:88FF F009            	   861:   beq editor_easy_replace_done
00:8901 BD0002          	   862:   lda INBUF,x
00:8904 9123            	   863:   sta (PCODE),y
00:8906 C8              	   864:   iny
00:8907 E8              	   865:   inx
00:8908 D0F3            	   866:   bne editor_easy_replace_loop  ; keep replacing
                        	   867: 
                        	   868: editor_easy_replace_done:
00:890A A902            	   869:   lda #FFLAG_GLOBAL
00:890C 25BD            	   870:   and find_flags
00:890E F00B            	   871:   beq editor_list_not_finding   ; one replace is enough
                        	   872: 
                        	   873: ;
                        	   874: ;  add the replacement length to Y (moving past what we just replaced)
                        	   875: ;   the replacement length is rep_to - rep_from
                        	   876: ;
00:8910 18              	   877:   clc
00:8911 A5B2            	   878:   lda find_pos
00:8913 65B6            	   879:   adc rep_to
00:8915 38              	   880:   sec
00:8916 E5B5            	   881:   sbc rep_from
00:8918 4C8D88          	   882:   jmp editor_replacement_loop
                        	   883: 
                        	   884: ;
                        	   885: ;
                        	   886: ;  display the line number
                        	   887: ;
                        	   888: editor_list_not_finding:
00:891B A901            	   889:   lda #EFLAG_SHOW_LINE
00:891D 14BC            	   890:   trb editor_flags      ; cancel flag until next newline
00:891F A980            	   891:   lda #EFLAG_NO_LINE_NUMBERS
00:8921 25BC            	   892:   and editor_flags
00:8923 D003            	   893:   bne editor_list_no_line_number
00:8925 201E8C          	   894:   jsr show_current_line_number
                        	   895: 
                        	   896: editor_list_no_line_number:
00:8928 A000            	   897:   ldy  #0
00:892A B123            	   898:   lda  (PCODE),Y
00:892C C90A            	   899:   cmp  #NL
00:892E D022            	   900:   bne  editor_list_not_newline
                        	   901: 
                        	   902: editor_newline_processing:
00:8930 A901            	   903:   lda  #EFLAG_SHOW_LINE
00:8932 04BC            	   904:   tsb  editor_flags
00:8934 E6A2            	   905:   inc  current_line
00:8936 D002            	   906:   bne  editor_list_check_to_line
00:8938 E6A3            	   907:   inc  current_line+1
                        	   908: 
                        	   909: ;
                        	   910: ;  see if we hit the wanted "to" line
                        	   911: ;
                        	   912: editor_list_check_to_line:
00:893A A5A3            	   913:   lda  current_line+1
00:893C C5A1            	   914:   cmp  to_line+1
00:893E 900A            	   915:   bcc  editor_list_check_to_line_ok
00:8940 D024            	   916:   bne  editor_list_done
00:8942 A5A2            	   917:   lda  current_line
00:8944 C5A0            	   918:   cmp  to_line
00:8946 9002            	   919:   bcc  editor_list_check_to_line_ok
00:8948 D01C            	   920:   bne  editor_list_done
                        	   921: 
                        	   922: editor_list_check_to_line_ok:
                        	   923: 
00:894A A940            	   924:   lda #EFLAG_SUPPRESS_NEWLINE
00:894C 25BC            	   925:   and editor_flags
00:894E D00D            	   926:   bne editor_list_skip_newline
00:8950 A90A            	   927:   lda #NL   ; put the newline back
                        	   928: 
                        	   929: ;
                        	   930: ;  just echo the character, and increment the memory address
                        	   931: ;
                        	   932: editor_list_not_newline:
00:8952 AA              	   933:   tax
00:8953 A904            	   934:   lda #FFLAG_QUIET
00:8955 25BD            	   935:   and find_flags
00:8957 D004            	   936:   bne editor_list_skip_newline
00:8959 8A              	   937:   txa
00:895A 208592          	   938:   jsr PRCHAR
                        	   939: 
                        	   940: editor_list_skip_newline:
00:895D E623            	   941:   inc PCODE
00:895F D002            	   942:   bne editor_list_loopJ
00:8961 E624            	   943:   inc PCODE+1
                        	   944: 
                        	   945: editor_list_loopJ:
00:8963 4C5788          	   946:   jmp editor_list_loop
                        	   947: 
                        	   948: editor_list_done:
00:8966 202892          	   949:   jsr CROUT
                        	   950: 
00:8969 A5B9            	   951:   lda find_count
00:896B 05BA            	   952:   ora find_count+1
00:896D F014            	   953:   beq  editor_list_completely_done
00:896F A5B9            	   954:   lda find_count
00:8971 8500            	   955:   sta REG
00:8973 A5BA            	   956:   lda find_count+1
00:8975 8501            	   957:   sta REG+1
00:8977 6402            	   958:   stz REGB
00:8979 205291          	   959:   jsr display_in_decimal
00:897C A993            	   960:   lda #<found_message
00:897E A286            	   961:   ldx #>found_message
00:8980 202682          	   962:   jsr print
                        	   963: 
                        	   964: editor_list_completely_done:
00:8983 4CCC82          	   965:   jmp main_prompt
                        	   966: 
                        	   967: ;
                        	   968: ;  This if for replacing when the lengths differ
                        	   969: ;
                        	   970: editor_do_replace:
                        	   971: ;
                        	   972: ; add our current find_pos to PCODE to get where we are in memory
                        	   973: ;
00:8986 18              	   974:   clc
00:8987 A523            	   975:   lda  PCODE
00:8989 48              	   976:   pha   ; save where we currently are
00:898A 65B2            	   977:   adc  find_pos
00:898C 85A6            	   978:   sta  mem_move_src
00:898E A524            	   979:   lda  PCODE+1
00:8990 48              	   980:   pha
00:8991 6900            	   981:   adc  #0
00:8993 85A7            	   982:   sta  mem_move_src+1
                        	   983: 
                        	   984: ;
                        	   985: ;  add the source string length as we don't need to copy that
                        	   986: ;
00:8995 18              	   987:   clc
00:8996 A5A6            	   988:   lda mem_move_src
00:8998 65B3            	   989:   adc find_len
00:899A 85A6            	   990:   sta mem_move_src
00:899C A5A7            	   991:   lda mem_move_src+1
00:899E 6900            	   992:   adc #0
00:89A0 85A7            	   993:   sta mem_move_src+1
                        	   994: 
                        	   995: ;
                        	   996: ;  the move destination is the source plus the replacement length
                        	   997: ;   (ie. a gap of the difference in bytes)
                        	   998: 
00:89A2 18              	   999:   clc
00:89A3 A5A6            	  1000:   lda mem_move_src
00:89A5 65B7            	  1001:   adc rep_diff
00:89A7 85A8            	  1002:   sta mem_move_dest
00:89A9 A5A7            	  1003:   lda mem_move_src+1
00:89AB 65B8            	  1004:   adc rep_diff+1
00:89AD 85A9            	  1005:   sta mem_move_dest+1
                        	  1006: 
                        	  1007: 
00:89AF 20898C          	  1008:   jsr find_source_end   ; goes into PCODE
                        	  1009: ;
                        	  1010: ;  the length to move will be (the end of the source) - (the start of the move)
                        	  1011: ;
00:89B2 18              	  1012:   clc
00:89B3 A523            	  1013:   lda PCODE
00:89B5 E5A6            	  1014:   sbc mem_move_src
00:89B7 85AA            	  1015:   sta mem_move_len
00:89B9 A524            	  1016:   lda PCODE+1
00:89BB E5A7            	  1017:   sbc mem_move_src+1
00:89BD 85AB            	  1018:   sta mem_move_len+1
                        	  1019: 
00:89BF A5B8            	  1020:   lda rep_diff+1
00:89C1 3005            	  1021:   bmi editor_do_replace_smaller
00:89C3 20A681          	  1022:   jsr moveup      ; replacing with larger string
00:89C6 8003            	  1023:   bra editor_do_replace_copy_done
                        	  1024: 
                        	  1025: editor_do_replace_smaller:
00:89C8 207A81          	  1026:   jsr movedown    ; replacing with smaller string
                        	  1027: 
                        	  1028: editor_do_replace_copy_done:
                        	  1029: ;
                        	  1030: ;  get the current source address back
                        	  1031: ;
00:89CB 68              	  1032:   pla
00:89CC 8524            	  1033:   sta  PCODE+1
00:89CE 68              	  1034:   pla
00:89CF 8523            	  1035:   sta  PCODE
00:89D1 4CF988          	  1036:   jmp  editor_easy_replace    ; now move in new string
                        	  1037: 
                        	  1038: 
00:89D4 456E74657220736F	  1039: load_message asciiz "Enter source, terminate with Esc\n"
00:89DC 757263652C207465
00:89E4 726D696E61746520
00:89EC 7769746820457363
00:89F4 0A
00:89F5 00
                        	  1040: 
                        	  1041: ;--------------------------------------------
                        	  1042: ;  INSERT / LOAD
                        	  1043: ;--------------------------------------------
                        	  1044: editor_load:
                        	  1045: 
00:89F6 A904            	  1046:   lda #EFLAG_LOAD
00:89F8 85BC            	  1047:   sta editor_flags
                        	  1048: 
                        	  1049: editor_insert:
00:89FA 64B0            	  1050:   stz insert_last_char
00:89FC 207785          	  1051:   jsr editor_get_number
00:89FF F015            	  1052:   beq editor_insert_at_start
                        	  1053: 
                        	  1054:   ;
                        	  1055:   ; I really want to insert AFTER this line so I'll add 1 to whatever line number they gave
                        	  1056:   ; To insert at the start use Insert without a line number
                        	  1057:   ;
00:8A01 18              	  1058:   clc
00:8A02 A594            	  1059:   lda token_value
00:8A04 6901            	  1060:   adc #1
00:8A06 85AC            	  1061:   sta this_line
00:8A08 A595            	  1062:   lda token_value+1
00:8A0A 6900            	  1063:   adc #0
00:8A0C 85AD            	  1064:   sta this_line+1
                        	  1065: 
00:8A0E 203886          	  1066:   jsr editor_check_no_more
00:8A11 20558C          	  1067:   jsr find_line    ; find the "from" line address
00:8A14 800E            	  1068:   bra editor_insert_common
                        	  1069: 
                        	  1070: editor_insert_at_start:
00:8A16 A900            	  1071:   lda #<TEXT_START
00:8A18 85AE            	  1072:   sta this_line_addr
00:8A1A A903            	  1073:   lda #>TEXT_START
00:8A1C 85AF            	  1074:   sta this_line_addr+1
00:8A1E A901            	  1075:   lda #1
00:8A20 85A2            	  1076:   sta current_line    ; current line number (1)
00:8A22 64A3            	  1077:   stz current_line+1
                        	  1078: 
                        	  1079: editor_insert_common:
00:8A24 20898C          	  1080:   jsr find_source_end
                        	  1081: 
                        	  1082: ;
                        	  1083: ;  move existing source to end of RAM
                        	  1084: ;
00:8A27 38              	  1085:   sec
00:8A28 A523            	  1086:   lda PCODE
00:8A2A E5AE            	  1087:   sbc this_line_addr
00:8A2C 85AA            	  1088:   sta mem_move_len
00:8A2E A524            	  1089:   lda PCODE+1
00:8A30 E5AF            	  1090:   sbc this_line_addr+1
00:8A32 85AB            	  1091:   sta mem_move_len+1
                        	  1092: 
                        	  1093: ;
                        	  1094: ;  find where to move to
                        	  1095: ;
00:8A34 38              	  1096:   sec
00:8A35 A9FF            	  1097:   lda #<HIGHEST_RAM
00:8A37 E5AA            	  1098:   sbc mem_move_len
00:8A39 85A8            	  1099:   sta mem_move_dest
00:8A3B 85A4            	  1100:   sta insert_limit
00:8A3D A93F            	  1101:   lda #>HIGHEST_RAM
00:8A3F E5AB            	  1102:   sbc mem_move_len+1
00:8A41 85A9            	  1103:   sta mem_move_dest+1
00:8A43 85A5            	  1104:   sta insert_limit+1
                        	  1105: 
                        	  1106: ;
                        	  1107: ;  the source of the move
                        	  1108: ;
00:8A45 A5AE            	  1109:   lda this_line_addr
00:8A47 85A6            	  1110:   sta mem_move_src
00:8A49 A5AF            	  1111:   lda this_line_addr+1
00:8A4B 85A7            	  1112:   sta mem_move_src+1
                        	  1113: 
00:8A4D 20A681          	  1114:   jsr moveup
                        	  1115: 
                        	  1116: ;
                        	  1117: ;  put input at from_line_addr
                        	  1118: ;
                        	  1119: 
00:8A50 A5AE            	  1120:   lda this_line_addr
00:8A52 8523            	  1121:   sta PCODE
00:8A54 A5AF            	  1122:   lda this_line_addr+1
00:8A56 8524            	  1123:   sta PCODE+1
                        	  1124: 
00:8A58 A9D4            	  1125:   lda  #<load_message
00:8A5A A289            	  1126:   ldx  #>load_message
00:8A5C 202682          	  1127:   jsr  print
                        	  1128: 
                        	  1129: ;
                        	  1130: ;  show the first line number
                        	  1131: ;
                        	  1132: 
00:8A5F A901            	  1133:   lda #EFLAG_SHOW_LINE
00:8A61 04BC            	  1134:   tsb editor_flags
                        	  1135: 
                        	  1136: editor_insert_loop:
00:8A63 A904            	  1137:   lda #EFLAG_LOAD         ; no line numbers on load
00:8A65 25BC            	  1138:   and editor_flags
00:8A67 D00B            	  1139:   bne editor_insert_no_line_number
                        	  1140: 
00:8A69 A5BC            	  1141:   lda editor_flags
00:8A6B 2901            	  1142:   and #EFLAG_SHOW_LINE
00:8A6D F005            	  1143:   beq  editor_insert_no_line_number
                        	  1144: ;
                        	  1145: ;  display the line number
                        	  1146: ;
                        	  1147: 
00:8A6F 64BC            	  1148:   stz editor_flags      ; cancel flag until next newline
00:8A71 201E8C          	  1149:   jsr show_current_line_number
                        	  1150: 
                        	  1151: editor_insert_no_line_number:
00:8A74 A000            	  1152:   ldy  #0
00:8A76 2076C8          	  1153:   jsr  CHRIN
00:8A79 C90D            	  1154:   cmp  #CR       ; carriage-return?
00:8A7B F0F7            	  1155:   beq  editor_insert_no_line_number ; yes, ignore
00:8A7D C91B            	  1156:   cmp  #END_EDITOR_INPUT  ; Esc?
00:8A7F F051            	  1157:   beq  editor_insert_done
00:8A81 C903            	  1158:   cmp  #KEY_ABORT         ; let them stop inputting with Ctrl+C
00:8A83 F04D            	  1159:   beq  editor_insert_done
00:8A85 C908            	  1160:   cmp  #BACKSPACE
00:8A87 F02A            	  1161:   beq  editor_insert_backspace
00:8A89 C90A            	  1162:   cmp  #NL
00:8A8B D00C            	  1163:   bne  editor_insert_not_newline
00:8A8D A901            	  1164:   lda  #EFLAG_SHOW_LINE
00:8A8F 04BC            	  1165:   tsb  editor_flags
00:8A91 A90A            	  1166:   lda  #NL            ; get the newline back
00:8A93 E6A2            	  1167:   inc  current_line
00:8A95 D002            	  1168:   bne  editor_insert_not_newline
00:8A97 E6A3            	  1169:   inc  current_line+1
                        	  1170: editor_insert_not_newline
00:8A99 9123            	  1171:   sta  (PCODE),Y
00:8A9B 85B0            	  1172:   sta  insert_last_char       ; for detecting final newline
00:8A9D E623            	  1173:   inc  PCODE
00:8A9F D002            	  1174:   bne  editor_insert_loop1
00:8AA1 E624            	  1175:   inc  PCODE+1
                        	  1176: 
                        	  1177: editor_insert_loop1:
00:8AA3 A5A5            	  1178:   lda  insert_limit+1
00:8AA5 C524            	  1179:   cmp  PCODE+1
00:8AA7 B0BA            	  1180:   bcs  editor_insert_loop   ; carry is SET if we didn't borrow
00:8AA9 D054            	  1181:   bne  editor_too_full
00:8AAB A5A4            	  1182:   lda  insert_limit
00:8AAD C523            	  1183:   cmp  PCODE
00:8AAF F04E            	  1184:   beq  editor_too_full
00:8AB1 80B0            	  1185:   bra  editor_insert_loop
                        	  1186: 
                        	  1187: ;
                        	  1188: ;  backspace reduces our pointer by one, unless we are at the start
                        	  1189: ;
                        	  1190: editor_insert_backspace:
00:8AB3 A523            	  1191:   lda PCODE
00:8AB5 C5AE            	  1192:   cmp this_line_addr
00:8AB7 D006            	  1193:   bne editor_insert_backspace_not_at_start
00:8AB9 A524            	  1194:   lda PCODE+1
00:8ABB C5AF            	  1195:   cmp this_line_addr+1
00:8ABD F0A4            	  1196:   beq editor_insert_loop    ; at start, ignore backspace
                        	  1197: 
                        	  1198: editor_insert_backspace_not_at_start:
00:8ABF 38              	  1199:   sec                       ; move source pointer back one
00:8AC0 A523            	  1200:   lda PCODE
00:8AC2 E901            	  1201:   sbc #1
00:8AC4 8523            	  1202:   sta PCODE
00:8AC6 A524            	  1203:   lda PCODE+1
00:8AC8 E900            	  1204:   sbc #0
00:8ACA 8524            	  1205:   sta PCODE+1
00:8ACC B123            	  1206:   lda (PCODE),y
00:8ACE 85B0            	  1207:   sta insert_last_char       ; this is now the last character we inserted
00:8AD0 8091            	  1208:   bra editor_insert_loop
                        	  1209: 
                        	  1210: editor_insert_done:
00:8AD2 A5B0            	  1211:   lda insert_last_char
00:8AD4 F00E            	  1212:   beq editor_insert_done_with_newline   ; nothing got inserted at all
00:8AD6 C90A            	  1213:   cmp #NL
00:8AD8 F00A            	  1214:   beq editor_insert_done_with_newline  ; skip inserting a newline if we just got a newline
                        	  1215: ;
                        	  1216: ;  They finished inserting, but without a newline ... add one
                        	  1217: ;
00:8ADA A90A            	  1218:   lda #NL
00:8ADC 9123            	  1219:   sta (PCODE),Y
00:8ADE E623            	  1220:   inc PCODE
00:8AE0 D002            	  1221:   bne editor_insert_done_with_newline
00:8AE2 E624            	  1222:   inc PCODE+1
                        	  1223: 
                        	  1224: ;
                        	  1225: ;  they are done - copy the rest back to the end of where they just inserted
                        	  1226: ;
                        	  1227: editor_insert_done_with_newline:
                        	  1228: 
00:8AE4 64BE            	  1229:   stz system_flags     ; compile is not valid any more
                        	  1230: 
00:8AE6 A523            	  1231:   lda PCODE
00:8AE8 85A8            	  1232:   sta mem_move_dest
00:8AEA A524            	  1233:   lda PCODE+1
00:8AEC 85A9            	  1234:   sta mem_move_dest+1
                        	  1235: 
00:8AEE A5A4            	  1236:   lda insert_limit
00:8AF0 85A6            	  1237:   sta mem_move_src
00:8AF2 A5A5            	  1238:   lda insert_limit+1
00:8AF4 85A7            	  1239:   sta mem_move_src+1
                        	  1240: 
00:8AF6 207A81          	  1241:   jsr movedown
                        	  1242: 
00:8AF9 202892          	  1243:   jsr CROUT   ; put a newline after the ESC character
00:8AFC 4CCC82          	  1244:   jmp main_prompt
                        	  1245: 
                        	  1246: editor_too_full:
00:8AFF A92A            	  1247:   lda #<memory_full
00:8B01 A28B            	  1248:   ldx #>memory_full
00:8B03 202682          	  1249:   jsr print
                        	  1250: ;
                        	  1251: ;  consume input so it isn't mistaken for a command
                        	  1252: ;
                        	  1253: editor_too_full_loop:
00:8B06 2076C8          	  1254:   jsr CHRIN
00:8B09 C91B            	  1255:   cmp #END_EDITOR_INPUT
00:8B0B D0F9            	  1256:   bne editor_too_full_loop
                        	  1257: ;
                        	  1258: ;  another message, they may miss the first one during a bulk load
                        	  1259: ;
00:8B0D A945            	  1260:   lda #<memory_filled_up
00:8B0F A28B            	  1261:   ldx #>memory_filled_up
00:8B11 202682          	  1262:   jsr print
00:8B14 4CD28A          	  1263:   jmp editor_insert_done
                        	  1264: 
00:8B17 4E6F2072616E6765	  1265: editor_no_lines  asciiz "No range supplied\n"
00:8B1F 20737570706C6965
00:8B27 640A
00:8B29 00
00:8B2A 0A0A4D656D6F7279	  1266: memory_full      asciiz "\n\nMemory full - press Esc\n"
00:8B32 2066756C6C202D20
00:8B3A 7072657373204573
00:8B42 630A
00:8B44 00
00:8B45 0A0A4E6F20726F6F	  1267: memory_filled_up asciiz "\n\nNo room for source during load/input\n\n"
00:8B4D 6D20666F7220736F
00:8B55 7572636520647572
00:8B5D 696E67206C6F6164
00:8B65 2F696E7075740A0A
00:8B6D 00
                        	  1268: 
                        	  1269: ;--------------------------------------------
                        	  1270: ;  DELETE
                        	  1271: ;--------------------------------------------
                        	  1272: editor_delete:
                        	  1273: ;
                        	  1274: ;  default to no lines
                        	  1275: ;
00:8B6E 649E            	  1276:   stz from_line
00:8B70 649F            	  1277:   stz from_line+1
00:8B72 64A0            	  1278:   stz to_line
00:8B74 64A1            	  1279:   stz to_line+1
                        	  1280: 
00:8B76 64B9            	  1281:   stz find_count      ; delete count in this case
00:8B78 64BA            	  1282:   stz find_count+1
                        	  1283: 
00:8B7A 204886          	  1284:   jsr editor_get_range
00:8B7D 203886          	  1285:   jsr editor_check_no_more
                        	  1286: ;
                        	  1287: ; if no lines given, give up
                        	  1288: ;
00:8B80 A59E            	  1289:   lda from_line
00:8B82 059F            	  1290:   ora from_line+1
00:8B84 D00A            	  1291:   bne editor_delete_have_range
00:8B86 A917            	  1292:   lda #<editor_no_lines
00:8B88 A28B            	  1293:   ldx #>editor_no_lines
00:8B8A 202682          	  1294:   jsr print
00:8B8D 4CCC82          	  1295:   jmp  main_prompt
                        	  1296: 
                        	  1297: editor_delete_have_range:
00:8B90 A59E            	  1298:   lda from_line
00:8B92 85AC            	  1299:   sta this_line
00:8B94 A59F            	  1300:   lda from_line+1
00:8B96 85AD            	  1301:   sta this_line+1
00:8B98 20558C          	  1302:   jsr find_line       ; find the "from" line address
00:8B9B A5AE            	  1303:   lda this_line_addr  ; that becomes the destination of the move
00:8B9D 85A8            	  1304:   sta mem_move_dest
00:8B9F A5AF            	  1305:   lda this_line_addr+1
00:8BA1 85A9            	  1306:   sta mem_move_dest+1
00:8BA3 64AA            	  1307:   stz mem_move_len
00:8BA5 64AB            	  1308:   stz mem_move_len+1
                        	  1309: ;
                        	  1310: ;  now we'll work our way up until we get to the to_line, however we'll
                        	  1311: ;  add one because we want the final address to actually be the start of
                        	  1312: ;  the NEXT line
                        	  1313: ;
00:8BA7 18              	  1314:   clc
00:8BA8 A5A0            	  1315:   lda to_line
00:8BAA 6901            	  1316:   adc #1
00:8BAC 85AC            	  1317:   sta this_line
00:8BAE A5A1            	  1318:   lda to_line+1
00:8BB0 6900            	  1319:   adc #0
00:8BB2 85AD            	  1320:   sta this_line+1
00:8BB4 20638C          	  1321:   jsr find_line_loop    ; find the "to" line address
00:8BB7 A5AE            	  1322:   lda this_line_addr  ; that becomes the destination of the move
00:8BB9 85A6            	  1323:   sta mem_move_src
00:8BBB A5AF            	  1324:   lda this_line_addr+1
00:8BBD 85A7            	  1325:   sta mem_move_src+1
                        	  1326: 
                        	  1327: ;
                        	  1328: ;  count how many lines we delete by counting newlines from
                        	  1329: ;   mem_move_dest to mem_move_src
                        	  1330: ;
                        	  1331: 
00:8BBF A5A8            	  1332:   lda mem_move_dest
00:8BC1 8523            	  1333:   sta PCODE
00:8BC3 A5A9            	  1334:   lda mem_move_dest+1
00:8BC5 8524            	  1335:   sta PCODE+1
00:8BC7 A000            	  1336:   ldy #0
                        	  1337: 
                        	  1338: editor_delete_line_count_loop:
00:8BC9 A523            	  1339:   lda PCODE
00:8BCB C5A6            	  1340:   cmp mem_move_src
00:8BCD D006            	  1341:   bne editor_delete_line_count_not_done
00:8BCF A524            	  1342:   lda PCODE+1
00:8BD1 C5A7            	  1343:   cmp mem_move_src+1
00:8BD3 F014            	  1344:   beq editor_delete_line_count_done
                        	  1345: 
                        	  1346: editor_delete_line_count_not_done:
00:8BD5 B123            	  1347:   lda (PCODE),y
00:8BD7 C90A            	  1348:   cmp #NL
00:8BD9 D006            	  1349:   bne editor_delete_line_count_not_newline
00:8BDB E6B9            	  1350:   inc find_count
00:8BDD D002            	  1351:   bne editor_delete_line_count_not_newline
00:8BDF E6BA            	  1352:   inc find_count+1
                        	  1353: editor_delete_line_count_not_newline:
00:8BE1 E623            	  1354:   inc PCODE
00:8BE3 D0E4            	  1355:   bne editor_delete_line_count_loop
00:8BE5 E624            	  1356:   inc PCODE+1
00:8BE7 80E0            	  1357:   bra editor_delete_line_count_loop
                        	  1358: 
                        	  1359: ;
                        	  1360: ;  now find where the source ends
                        	  1361: ;  PCODE will now be at the first line to not be deleted
                        	  1362: ;
                        	  1363: editor_delete_line_count_done:
                        	  1364: 
00:8BE9 20918C          	  1365:   jsr find_source_end_loop
00:8BEC 38              	  1366:   sec
00:8BED A523            	  1367:   lda PCODE
00:8BEF E5AE            	  1368:   sbc this_line_addr
00:8BF1 85AA            	  1369:   sta mem_move_len
00:8BF3 A524            	  1370:   lda PCODE+1
00:8BF5 E5AF            	  1371:   sbc this_line_addr+1
00:8BF7 85AB            	  1372:   sta mem_move_len+1
00:8BF9 207A81          	  1373:   jsr movedown  ; that should do it
                        	  1374: 
00:8BFC A5B9            	  1375:   lda find_count
00:8BFE 8500            	  1376:   sta REG
00:8C00 A5BA            	  1377:   lda find_count+1
00:8C02 8501            	  1378:   sta REG+1
00:8C04 6402            	  1379:   stz REGB
00:8C06 205291          	  1380:   jsr display_in_decimal
00:8C09 A913            	  1381:   lda #<lines_deleted_message
00:8C0B A28C            	  1382:   ldx #>lines_deleted_message
00:8C0D 202682          	  1383:   jsr print
00:8C10 4CCC82          	  1384:   jmp main_prompt
                        	  1385: 
00:8C13 2064656C65746564	  1386: lines_deleted_message asciiz " deleted.\n"
00:8C1B 2E0A
00:8C1D 00
                        	  1387: 
                        	  1388: ;--------------------------------------------
                        	  1389: ;  show current line number with leading spaces
                        	  1390: ;--------------------------------------------
                        	  1391: show_current_line_number:
                        	  1392: ;
                        	  1393: ;  get the line number into REG ready for printing
                        	  1394: ;
00:8C1E A5A2            	  1395:   lda current_line
00:8C20 8500            	  1396:   sta REG
00:8C22 A6A3            	  1397:   ldx current_line+1
00:8C24 8601            	  1398:   stx REG+1
00:8C26 A000            	  1399:   ldy #0        ; count of leading spaces
00:8C28 8402            	  1400:   sty REGB
00:8C2A E003            	  1401:   cpx #>1000    ; if the number is >= 1000 don't print any spaces
00:8C2C 9006            	  1402:   bcc line_number_lt_1000
00:8C2E D013            	  1403:   bne line_number_output_spaces
00:8C30 C9E8            	  1404:   cmp #<1000
00:8C32 B00F            	  1405:   bcs line_number_output_spaces
                        	  1406: line_number_lt_1000:
00:8C34 C8              	  1407:   iny           ; output one space
00:8C35 E000            	  1408:   cpx  #0       ; if line number > 255 then one space is all we need
00:8C37 D00A            	  1409:   bne  line_number_output_spaces
00:8C39 C964            	  1410:   cmp  #100     ; if line number >= 100 then one space is all we need
00:8C3B B006            	  1411:   bcs  line_number_output_spaces
00:8C3D C8              	  1412:   iny           ; output two spaces
00:8C3E C90A            	  1413:   cmp  #10      ; if line number >= 10 then two spaces are all we need
00:8C40 B001            	  1414:   bcs  line_number_output_spaces
00:8C42 C8              	  1415:   iny           ; output three spaces
                        	  1416: line_number_output_spaces:
00:8C43 C000            	  1417:   cpy #0            ; leading spaces in front of line number
00:8C45 F008            	  1418:   beq  show_current_line_number_done
00:8C47 5A              	  1419:   phy
00:8C48 20B392          	  1420:   jsr  PUTSP      ; output the space
00:8C4B 7A              	  1421:   ply
00:8C4C 88              	  1422:   dey             ; count them
00:8C4D D0F4            	  1423:   bne  line_number_output_spaces  ; more spaces to go
                        	  1424: show_current_line_number_done:
00:8C4F 205291          	  1425:   jsr  display_in_decimal    ; now the actual number
00:8C52 4CB392          	  1426:   jmp  PUTSP      ; and a space after it
                        	  1427: 
                        	  1428: ;--------------------------------------------
                        	  1429: ;  find_line
                        	  1430: ;
                        	  1431: ;  finds address of this_line in memory - returns in this_line_addr
                        	  1432: ;--------------------------------------------
                        	  1433: find_line:
00:8C55 A901            	  1434:   lda #1
00:8C57 85A2            	  1435:   sta current_line    ; current line number (1)
00:8C59 64A3            	  1436:   stz current_line+1
00:8C5B A900            	  1437:   lda #<TEXT_START   ; start at start of source
00:8C5D 85AE            	  1438:   sta this_line_addr
00:8C5F A903            	  1439:   lda #>TEXT_START
00:8C61 85AF            	  1440:   sta this_line_addr+1
                        	  1441: find_line_loop:
00:8C63 A000            	  1442:   ldy #0
00:8C65 A5A2            	  1443:   lda current_line
00:8C67 C5AC            	  1444:   cmp this_line
00:8C69 D007            	  1445:   bne find_line_next
00:8C6B A5A3            	  1446:   lda current_line+1
00:8C6D C5AD            	  1447:   cmp this_line+1
00:8C6F D001            	  1448:   bne find_line_next
00:8C71 60              	  1449:   rts
                        	  1450: find_line_next:
00:8C72 B1AE            	  1451:   lda (this_line_addr),Y
00:8C74 F012            	  1452:   beq find_line_eof
00:8C76 C90A            	  1453:   cmp #NL
00:8C78 D006            	  1454:   bne find_line_same_line
00:8C7A E6A2            	  1455:   inc current_line       ; add 1 to our line number counter
00:8C7C D002            	  1456:   bne find_line_same_line
00:8C7E E6A3            	  1457:   inc current_line+1
                        	  1458: find_line_same_line:
00:8C80 E6AE            	  1459:   inc this_line_addr     ; onto next address - which means that a newline
00:8C82 D0DF            	  1460:   bne find_line_loop     ; will actually end up being the start of the new
00:8C84 E6AF            	  1461:   inc this_line_addr+1   ; line, which is what we want
00:8C86 80DB            	  1462:   bra find_line_loop
                        	  1463: find_line_eof:           ; we are pointing to 0x00 - make that the address
00:8C88 60              	  1464:   rts
                        	  1465: 
                        	  1466: 
                        	  1467: 
                        	  1468: ;***********************************************
                        	  1469: ; Find text end
                        	  1470: ;***********************************************
                        	  1471: find_source_end:
00:8C89 A900            	  1472:   lda  #<TEXT_START        ; start at start of source
00:8C8B 8523            	  1473:   sta  PCODE
00:8C8D A903            	  1474:   lda  #>TEXT_START
00:8C8F 8524            	  1475:   sta  PCODE+1
                        	  1476: find_source_end_loop =  *
00:8C91 A000            	  1477:   ldy  #0
00:8C93 B123            	  1478:   lda  (PCODE),Y             ; keep going until 0x00 indicates end of source
00:8C95 F008            	  1479:   beq  find_source_end_wrap
00:8C97 E623            	  1480:   inc  PCODE
00:8C99 D0F6            	  1481:   bne  find_source_end_loop
00:8C9B E624            	  1482:   inc  PCODE+1
00:8C9D 80F2            	  1483:   bra  find_source_end_loop
                        	  1484: ;
                        	  1485: ;  include final 0x00
                        	  1486: ;
                        	  1487: find_source_end_wrap =  *
00:8C9F E623            	  1488:   inc  PCODE
00:8CA1 D002            	  1489:   bne  find_source_end_done
00:8CA3 E624            	  1490:   inc  PCODE+1
                        	  1491: find_source_end_done =  *
00:8CA5 60              	  1492:   rts
                        	  1493: 
                        	  1494: ;
                        	  1495: ;  testing BRK handling
                        	  1496: ;
00:8CA6 0A526573756D6564	  1497: brk_resumed asciiz "\nResumed after BRK\n"
00:8CAE 2061667465722042
00:8CB6 524B0A
00:8CB9 00
                        	  1498: 
                        	  1499: editor_test:
00:8CBA A912            	  1500:   lda #$12
00:8CBC A223            	  1501:   ldx #$23
00:8CBE A042            	  1502:   ldy #$42
00:8CC0 C912            	  1503:   cmp #$12
00:8CC2 00              	  1504:   brk
00:8CC3 99              	  1505:   dfb $99   ; break number
00:8CC4 A9A6            	  1506:   lda #<brk_resumed
00:8CC6 A28C            	  1507:   ldx #>brk_resumed
00:8CC8 202682          	  1508:   jsr print
00:8CCB 60              	  1509:   rts
                        	  1510: 
                        	  1511: ;
                        	  1512: ;  memory dump
                        	  1513: ;
                        	  1514: editor_memory:
00:8CCC 204F85          	  1515:   jsr editor_default_range
00:8CCF A902            	  1516:   lda #EFLAG_ALLOW_ZERO_FROM
00:8CD1 85BC            	  1517:   sta editor_flags
00:8CD3 204886          	  1518:   jsr editor_get_range
00:8CD6 203886          	  1519:   jsr editor_check_no_more
00:8CD9 64A2            	  1520:   stz current_line      ; count of bytes shown
00:8CDB A59E            	  1521:   lda from_line
00:8CDD 85AE            	  1522:   sta this_line_addr
00:8CDF A59F            	  1523:   lda from_line+1
00:8CE1 85AF            	  1524:   sta this_line_addr+1
                        	  1525: 
                        	  1526: editor_memory_loop:
00:8CE3 A58B            	  1527:   lda serial_in_byte_received
00:8CE5 C903            	  1528:   cmp  #KEY_ABORT
00:8CE7 F050            	  1529:   beq  editor_memory_aborted
                        	  1530: 
00:8CE9 A5A2            	  1531:   lda current_line
00:8CEB D017            	  1532:   bne editor_memory_loop1
                        	  1533: ;
                        	  1534: ;  show address
                        	  1535: ;
00:8CED A924            	  1536:   lda #'$'
00:8CEF 20AF93          	  1537:   jsr COUT
00:8CF2 A59F            	  1538:   lda from_line+1
00:8CF4 209D92          	  1539:   jsr PRBYTE
00:8CF7 A59E            	  1540:   lda from_line
00:8CF9 209D92          	  1541:   jsr PRBYTE
00:8CFC A93A            	  1542:   lda #':'
00:8CFE 20AF93          	  1543:   jsr COUT
00:8D01 20B392          	  1544:   jsr PUTSP
                        	  1545: editor_memory_loop1:
00:8D04 A000            	  1546:   ldy #0
00:8D06 B19E            	  1547:   lda (from_line),Y
00:8D08 209D92          	  1548:   jsr PRBYTE
00:8D0B 20B392          	  1549:   jsr PUTSP
00:8D0E E6A2            	  1550:   inc current_line
00:8D10 E69E            	  1551:   inc from_line
00:8D12 D002            	  1552:   bne editor_memory_loop2
00:8D14 E69F            	  1553:   inc from_line+1
                        	  1554: editor_memory_loop2:
00:8D16 A59F            	  1555:   lda from_line+1
00:8D18 C5A1            	  1556:   cmp to_line+1
00:8D1A 900A            	  1557:   bcc editor_memory_loop3   ; less than
00:8D1C D018            	  1558:   bne editor_memory_done    ; greater than
00:8D1E A59E            	  1559:   lda from_line             ; equal, so try low-order byte
00:8D20 C5A0            	  1560:   cmp to_line
00:8D22 9002            	  1561:   bcc editor_memory_loop3   ; less than
00:8D24 D010            	  1562:   bne editor_memory_done    ; greater than
                        	  1563: editor_memory_loop3:
00:8D26 A5A2            	  1564:   lda current_line
00:8D28 C910            	  1565:   cmp #16
00:8D2A 90B7            	  1566:   bcc editor_memory_loop
00:8D2C 20B392          	  1567:   jsr PUTSP
00:8D2F 203F8D          	  1568:   jsr editor_memory_show_ascii
00:8D32 64A2            	  1569:   stz current_line      ; count of bytes shown
00:8D34 80AD            	  1570:   bra editor_memory_loop
                        	  1571: 
                        	  1572: editor_memory_done:
00:8D36 203F8D          	  1573:   jsr editor_memory_show_ascii
                        	  1574: editor_memory_aborted:
00:8D39 202892          	  1575:   jsr CROUT
00:8D3C 4CCC82          	  1576:   jmp  main_prompt
                        	  1577: 
                        	  1578: editor_memory_show_ascii:
                        	  1579: ;
                        	  1580: ;  now the ASCII equivalents
                        	  1581: ;
00:8D3F A000            	  1582:   ldy #0
                        	  1583: editor_memory_ascii:
00:8D41 B1AE            	  1584:   lda (this_line_addr),Y
00:8D43 C920            	  1585:   cmp #$20
00:8D45 B002            	  1586:   bcs editor_memory_not_control
00:8D47 8004            	  1587:   bra editor_memory_show_dot
                        	  1588: editor_memory_not_control:
00:8D49 C97F            	  1589:   cmp #$7F
00:8D4B 9002            	  1590:   bcc editor_memory_not_high
                        	  1591: editor_memory_show_dot
00:8D4D A92E            	  1592:   lda #'.'
                        	  1593: editor_memory_not_high:
00:8D4F 20AF93          	  1594:   jsr COUT
00:8D52 20B392          	  1595:   jsr PUTSP
00:8D55 C8              	  1596:   iny
00:8D56 C6A2            	  1597:   dec current_line
00:8D58 D0E7            	  1598:   bne editor_memory_ascii
                        	  1599: ;
                        	  1600: ;  adjust the ASCII printing address
                        	  1601: ;
00:8D5A A59E            	  1602:   lda from_line
00:8D5C 85AE            	  1603:   sta this_line_addr
00:8D5E A59F            	  1604:   lda from_line+1
00:8D60 85AF            	  1605:   sta this_line_addr+1
                        	  1606: 
00:8D62 202892          	  1607:   jsr CROUT
00:8D65 60              	  1608:   rts
                        	  1609: 
                        	  1610: 
                        	  1611: 
                        	  1612: 
00:8D66 4164647220507265	  1613: symbol_table_message asciiz "Addr Prev L  T Dsp  Ar Da Ln Name\n"
00:8D6E 76204C2020542044
00:8D76 7370202041722044
00:8D7E 61204C6E204E616D
00:8D86 650A
00:8D88 00
                        	  1614: 
                        	  1615: editor_symbol_table_list  = *
00:8D89 A966            	  1616:   lda #<symbol_table_message
00:8D8B A28D            	  1617:   ldx #>symbol_table_message
00:8D8D 202682          	  1618:   jsr print
                        	  1619: 
00:8D90 A532            	  1620:   lda  ENDSYM+1    ; get the end of the symbol table
00:8D92 8541            	  1621:   sta  SYMITM+1    ; make it the current symbol
00:8D94 A531            	  1622:   lda  ENDSYM
00:8D96 800B            	  1623:   bra  ST_SYMTBL_LIST_CHECK
                        	  1624: 
                        	  1625: ST_SYMTBL_LIST_NEXT =  *
00:8D98 A000            	  1626:   ldy  #SYMPRV
00:8D9A B140            	  1627:   lda  (SYMITM),Y
00:8D9C AA              	  1628:   tax
00:8D9D C8              	  1629:   iny
00:8D9E B140            	  1630:   lda  (SYMITM),Y
00:8DA0 8541            	  1631:   sta  SYMITM+1   ; previous link
00:8DA2 8A              	  1632:   txa
                        	  1633: ;
                        	  1634: ;  go to the previous symbol table item
                        	  1635: ;
                        	  1636: ST_SYMTBL_LIST_CHECK     =  *
00:8DA3 8540            	  1637:   sta  SYMITM
00:8DA5 C9FF            	  1638:   cmp  #<SYMBOL_TABLE_START
00:8DA7 D009            	  1639:   bne  ST_SYMTBL_LIST_LINE
00:8DA9 A541            	  1640:   lda  SYMITM+1
00:8DAB C93F            	  1641:   cmp  #>SYMBOL_TABLE_START
00:8DAD D003            	  1642:   bne  ST_SYMTBL_LIST_LINE       ; more to go
00:8DAF 4C388E          	  1643:   jmp  ST_SYMTBL_LIST_DONE       ; finished if symitm and symitm+1 are both zero
                        	  1644: 
                        	  1645: ST_SYMTBL_LIST_LINE = *
00:8DB2 A541            	  1646:   lda  SYMITM+1
00:8DB4 209D92          	  1647:   jsr  PRBYTE
00:8DB7 A540            	  1648:   lda  SYMITM
00:8DB9 209D92          	  1649:   jsr  PRBYTE
00:8DBC A920            	  1650:   lda  #' '
00:8DBE 208592          	  1651:   jsr  PRCHAR
00:8DC1 A001            	  1652:   ldy  #SYMPRV+1
00:8DC3 B140            	  1653:   lda  (SYMITM),Y
00:8DC5 209D92          	  1654:   jsr  PRBYTE
00:8DC8 88              	  1655:   dey
00:8DC9 B140            	  1656:   lda  (SYMITM),Y
00:8DCB 209D92          	  1657:   jsr  PRBYTE
00:8DCE A920            	  1658:   lda  #' '
00:8DD0 208592          	  1659:   jsr  PRCHAR
00:8DD3 A002            	  1660:   ldy  #SYMLVL
00:8DD5 B140            	  1661:   lda  (SYMITM),Y  ; level
00:8DD7 209D92          	  1662:   jsr  PRBYTE
00:8DDA A920            	  1663:   lda  #' '
00:8DDC 208592          	  1664:   jsr  PRCHAR
00:8DDF A003            	  1665:   ldy  #SYMTYP
00:8DE1 B140            	  1666:   lda  (SYMITM),Y  ; type
00:8DE3 208592          	  1667:   jsr  PRCHAR
00:8DE6 A920            	  1668:   lda  #' '
00:8DE8 208592          	  1669:   jsr  PRCHAR
00:8DEB A004            	  1670:   ldy  #SYMDSP
00:8DED C8              	  1671:   iny
00:8DEE B140            	  1672:   lda  (SYMITM),Y  ; displacement
00:8DF0 209D92          	  1673:   jsr  PRBYTE
00:8DF3 88              	  1674:   dey
00:8DF4 B140            	  1675:   lda  (SYMITM),Y  ; displacement
00:8DF6 209D92          	  1676:   jsr  PRBYTE
00:8DF9 A920            	  1677:   lda  #' '
00:8DFB 208592          	  1678:   jsr  PRCHAR
00:8DFE A006            	  1679:   ldy  #SYMARG
00:8E00 B140            	  1680:   lda  (SYMITM),Y  ; argument count
00:8E02 209D92          	  1681:   jsr  PRBYTE
00:8E05 A920            	  1682:   lda  #' '
00:8E07 208592          	  1683:   jsr  PRCHAR
00:8E0A A008            	  1684:   ldy  #SYMDAT
00:8E0C B140            	  1685:   lda  (SYMITM),Y  ; data type
00:8E0E 209D92          	  1686:   jsr  PRBYTE
00:8E11 A920            	  1687:   lda  #' '
00:8E13 208592          	  1688:   jsr  PRCHAR
00:8E16 A009            	  1689:   ldy  #SYMLEN
00:8E18 B140            	  1690:   lda  (SYMITM),Y  ; length
00:8E1A 48              	  1691:   pha
00:8E1B 209D92          	  1692:   jsr  PRBYTE
00:8E1E A920            	  1693:   lda  #' '
00:8E20 208592          	  1694:   jsr  PRCHAR
00:8E23 A00A            	  1695:   ldy  #SYMNAM
00:8E25 68              	  1696:   pla
00:8E26 AA              	  1697:   tax
                        	  1698: ST_SYMTBL_LIST_NAME = *
00:8E27 B140            	  1699:   lda  (SYMITM),Y  ; name
00:8E29 5A              	  1700:   phy
00:8E2A 208592          	  1701:   jsr  PRCHAR
00:8E2D 7A              	  1702:   ply
00:8E2E C8              	  1703:   iny
00:8E2F CA              	  1704:   dex
00:8E30 D0F5            	  1705:   bne ST_SYMTBL_LIST_NAME
00:8E32 202892          	  1706:   jsr CROUT
00:8E35 4C988D          	  1707:   jmp ST_SYMTBL_LIST_NEXT
                        	  1708: 
                        	  1709: ST_SYMTBL_LIST_DONE = *
                        	  1710: 
00:8E38 4CCC82          	  1711:   jmp main_prompt
                        	  1712: 
                        	  1713: 
00:8E3B 446F6E650A      	  1714: recover_done asciiz "Done\n"
00:8E40 00
00:8E41 4E6F74206E656564	  1715: recover_not_needed asciiz "Not needed\n"
00:8E49 65640A
00:8E4C 00
                        	  1716: 
                        	  1717: ;
                        	  1718: ; Recover: if the first byte of the source is 0x00, change it to a space
                        	  1719: ;
                        	  1720: editor_recover:
00:8E4D A900            	  1721:   lda  #<TEXT_START
00:8E4F 8540            	  1722:   sta  FROM
00:8E51 A903            	  1723:   lda  #>TEXT_START
00:8E53 8541            	  1724:   sta  FROM+1
00:8E55 A000            	  1725:   ldy  #0
00:8E57 B140            	  1726:   lda  (FROM),Y
00:8E59 D00E            	  1727:   bne  editor_recover_not_needed
00:8E5B A920            	  1728:   lda  #' '
00:8E5D 9140            	  1729:   sta  (FROM),Y
00:8E5F A93B            	  1730:   lda #<recover_done
00:8E61 A28E            	  1731:   ldx #>recover_done
00:8E63 202682          	  1732:   jsr print
00:8E66 4CCC82          	  1733:   jmp main_prompt
                        	  1734: 
                        	  1735: editor_recover_not_needed:
00:8E69 A941            	  1736:   lda #<recover_not_needed
00:8E6B A28E            	  1737:   ldx #>recover_not_needed
00:8E6D 202682          	  1738:   jsr print
00:8E70 4CCC82          	  1739:   jmp main_prompt
                        	  1740: 
                        	  1741: 
                        	  1742: editor_debug:
00:8E73 A901            	  1743:   lda #1
00:8E75 8549            	  1744:   sta  DBGFLG
00:8E77 852E            	  1745:   sta  DCODE
00:8E79 4C6B93          	  1746:   jmp  CHK_RUN
                        	  1747: 
                        	  1748: editor_trace:
00:8E7C A980            	  1749:   lda  #$80
00:8E7E 8549            	  1750:   sta  DBGFLG
00:8E80 852E            	  1751:   sta  DCODE
00:8E82 4C6B93          	  1752:   jmp  CHK_RUN
                        	  1753: 
                        	  1754: 
                        	  1755: editor_info  = *
00:8E85 20F58E          	  1756:   jsr show_source_start
00:8E88 20CD8E          	  1757:   jsr show_source_end
00:8E8B 208390          	  1758:   jsr crc_source
00:8E8E 4CCC82          	  1759:   jmp main_prompt
                        	  1760: 
                        	  1761: editor_compile:
00:8E91 A900            	  1762:   lda  #0
00:8E93 8542            	  1763:   sta  SYNTAX
00:8E95 4CADB9          	  1764:   jmp  COMPIL
                        	  1765: 
                        	  1766: editor_syntax:
00:8E98 A901            	  1767:   lda #1
00:8E9A 8542            	  1768:   sta  SYNTAX
00:8E9C 4CADB9          	  1769:   jmp  COMPIL
                        	  1770: 
                        	  1771: editor_run:
00:8E9F A900            	  1772:   lda  #0
00:8EA1 8549            	  1773:   sta  DBGFLG
00:8EA3 852E            	  1774:   sta  DCODE
00:8EA5 4C6B93          	  1775:   jmp  CHK_RUN
                        	  1776: 
                        	  1777:   ;
                        	  1778: show_symbol_table_end:
00:8EA8 A910            	  1779:   lda  #<symbol_table_ended_message    ; Symbol table ended at
00:8EAA A293            	  1780:   ldx  #>symbol_table_ended_message
00:8EAC 202682          	  1781:   jsr  print
00:8EAF A532            	  1782:   lda  ENDSYM+1
00:8EB1 209D92          	  1783:   jsr  PRBYTE
00:8EB4 A531            	  1784:   lda  ENDSYM
00:8EB6 205293          	  1785:   jsr  PRBYTECR
00:8EB9 60              	  1786:   rts
                        	  1787: 
                        	  1788: 
00:8EBA 536F757263652065	  1789: source_ended_message asciiz "Source ends   at $"
00:8EC2 6E64732020206174
00:8ECA 2024
00:8ECC 00
                        	  1790: show_source_end:
00:8ECD A9BA            	  1791:   lda #<source_ended_message
00:8ECF A28E            	  1792:   ldx #>source_ended_message
00:8ED1 202682          	  1793:   jsr print
00:8ED4 20898C          	  1794:   jsr find_source_end
00:8ED7 A524            	  1795:   lda PCODE+1
00:8ED9 209D92          	  1796:   jsr PRBYTE
00:8EDC A523            	  1797:   lda PCODE
00:8EDE 205293          	  1798:   jsr PRBYTECR
00:8EE1 60              	  1799:   rts
                        	  1800: 
00:8EE2 536F757263652073	  1801: source_starts_message asciiz "Source starts at $"    ; source starts at
00:8EEA 7461727473206174
00:8EF2 2024
00:8EF4 00
                        	  1802: show_source_start:
00:8EF5 A9E2            	  1803:   lda #<source_starts_message
00:8EF7 A28E            	  1804:   ldx #>source_starts_message
00:8EF9 202682          	  1805:   jsr print
00:8EFC A903            	  1806:   lda #>TEXT_START
00:8EFE 209D92          	  1807:   jsr PRBYTE
00:8F01 A900            	  1808:   lda #<TEXT_START
00:8F03 205293          	  1809:   jsr PRBYTECR
00:8F06 60              	  1810:   rts
                        	  1811: 
                        	  1812: editor_assemble:
00:8F07 4C4298          	  1813:   jmp ASSEMBLE
                        	  1814: 
                        	  1815: 
                        	  1816: 
                        	  1817: 
                        	  1818: ;16-bit number comparison...
                        	  1819: ;
                        	  1820: ;         lda #>x               ; MSB of 1st number
                        	  1821: ;         cmp #>y               ; MSB of 2nd number
                        	  1822: ;         bcc islower           ; X < Y
                        	  1823: ;
                        	  1824: ;         bne ishigher          ; X > Y
                        	  1825: ;
                        	  1826: ;         lda #<x               ; LSB of 1st number
                        	  1827: ;         cmp #<y               ; LSB of 2nd number
                        	  1828: ;         bcc islower           ; X < Y
                        	  1829: ;
                        	  1830: ;         beq issame            ; X = Y
                        	  1831: ;
                        	  1832: ;         bne ishigher          ; X > Y
                        	  1833: ;
                        	  1834: ;
                        	  1835: 

Source: "gpascal.asm"
                        	   175:   .include "utilities.inc"

Source: "utilities.inc"
                        	     1: ;
                        	     2: ;  function to look up a handler for a word (eg. assembler directive)
                        	     3: ;
                        	     4: ;  word in SRCE
                        	     5: ;
                        	     6: ;  table of words/handlers in DEST
                        	     7: ;
                        	     8: ;  length of word in A
                        	     9: ;
                        	    10: ;  see makeHandler for making the table
                        	    11: ;
                        	    12: ;  Basically:
                        	    13: ;    asciiz "foo"
                        	    14: ;    word   foo_handler
                        	    15: ;
                        	    16: ;  In other words:
                        	    17: ;    makeHandler "foo",foo_handler
                        	    18: ;
                        	    19: ;  Returns with carry set if no match, otherwise calls the handler which should clear carry
                        	    20: ;
                        	    21: 
                        	    22: handlerLookup:
00:8F0A 8598            	    23:   sta token_work    ; save length
                        	    24: 
                        	    25: ;
                        	    26: ;  find the length of the word
                        	    27: ;
                        	    28: handler_loop:
00:8F0C A000            	    29:   ldy #0
00:8F0E B103            	    30:   lda (DEST),y
00:8F10 F036            	    31:   beq handlers_done
                        	    32: handler_find_length:
00:8F12 B103            	    33:   lda (DEST),y
00:8F14 F005            	    34:   beq handler_found_length
00:8F16 C8              	    35:   iny
00:8F17 F02F            	    36:   beq handlers_done   ; sanity clause
00:8F19 80F7            	    37:   bra handler_find_length
                        	    38: handler_found_length:
                        	    39: 
                        	    40: ;  lda #'i'
                        	    41: ;  jsr ass_debug_point
                        	    42: 
00:8F1B C498            	    43:   cpy token_work
00:8F1D F010            	    44:   beq handler_same_length
                        	    45: ;
                        	    46: ;  not the same length, or no match on the string
                        	    47: ;
                        	    48: handler_next:
00:8F1F 98              	    49:   tya
00:8F20 18              	    50:   clc
00:8F21 6903            	    51:   adc #3  ; skip the 0x00 and the execution address
00:8F23 6503            	    52:   adc DEST
00:8F25 8503            	    53:   sta DEST
00:8F27 A504            	    54:   lda DEST+1
00:8F29 6900            	    55:   adc #0
00:8F2B 8504            	    56:   sta DEST+1
00:8F2D 80DD            	    57:   bra handler_loop
                        	    58: 
                        	    59: handler_same_length:
                        	    60: 
                        	    61: ;  lda #'j'
                        	    62: ;  jsr ass_debug_point
                        	    63: 
00:8F2F 5A              	    64:   phy  ; save the length
00:8F30 202D92          	    65:   jsr COMSTL
00:8F33 F003            	    66:   beq  handler_found_directive
00:8F35 7A              	    67:   ply
00:8F36 80E7            	    68:   bra handler_next
                        	    69: handler_found_directive:
00:8F38 7A              	    70:   ply  ; get the length back
00:8F39 C8              	    71:   iny  ; skip past the 0x00 byte
00:8F3A B103            	    72:   lda (DEST),y
00:8F3C 8599            	    73:   sta token_work+1
00:8F3E C8              	    74:   iny
00:8F3F B103            	    75:   lda (DEST),y
00:8F41 859A            	    76:   sta token_work+2
00:8F43 204A8F          	    77:   jsr call_handler
00:8F46 18              	    78:   clc
00:8F47 60              	    79:   rts
                        	    80: 
                        	    81: handlers_done:
                        	    82: ;  lda #'h'
                        	    83: ;  jsr ass_debug_point
00:8F48 38              	    84:   sec     ; error flag
00:8F49 60              	    85:   rts
                        	    86: 
                        	    87: call_handler:
                        	    88: ;  lda #'g'
                        	    89: ;  jsr ass_debug_point
                        	    90: 
00:8F4A 6C9900          	    91:   jmp (token_work+1)   ; do handler - it will RTS for us
                        	    92: 
                        	    93: 
                        	    94: ;
                        	    95: ;  function to look up a handler for a word on a partial match (eg. editor command)
                        	    96: ;
                        	    97: ;  word in SRCE
                        	    98: ;
                        	    99: ;  table of words/handlers in DEST - in UPPER CASE
                        	   100: ;
                        	   101: ;  length of word in A
                        	   102: ;
                        	   103: ;  see makeHandler for making the table
                        	   104: ;
                        	   105: ;  Basically:
                        	   106: ;    asciiz "FOO"
                        	   107: ;    word   foo_handler
                        	   108: ;
                        	   109: ;  In other words:
                        	   110: ;    makeHandler "FOO",foo_handler
                        	   111: ;
                        	   112: ;  Returns if no match, otherwise jumps to the handler and thus doesn't return
                        	   113: ;
                        	   114: 
                        	   115: partial_handler_Lookup:
00:8F4D 8598            	   116:   sta token_work    ; save length
                        	   117: ;
                        	   118: ;  here for a new table item
                        	   119: ;
                        	   120: partial_handler_next_item:
00:8F4F A000            	   121:   ldy #0
00:8F51 B103            	   122:   lda (DEST),y
00:8F53 F03C            	   123:   beq partial_handler_done
00:8F55 A698            	   124:   ldx token_work        ; source length
                        	   125: partial_handler_next_loop:
                        	   126: ;
                        	   127: ;  ensure the nth character matches until the source runs out
                        	   128: ;
00:8F57 B100            	   129:   lda (SRCE),y
00:8F59 20C48F          	   130:   jsr MAKE_UPPER
00:8F5C D103            	   131:   cmp (DEST),y
00:8F5E D006            	   132:   bne partial_handler_next
00:8F60 C8              	   133:   iny
00:8F61 CA              	   134:   dex     ; one less count
00:8F62 F019            	   135:   beq partial_handler_found_directive ; source has finished and we found the directive
00:8F64 80F1            	   136:   bra partial_handler_next_loop       ; try matching the next one
                        	   137: ;
                        	   138: ;  no match on the string - advance Y to the end of the destination string
                        	   139: ;
                        	   140: partial_handler_next:
00:8F66 B103            	   141:   lda (DEST),y
00:8F68 F003            	   142:   beq partial_handler_next_found_item_length
00:8F6A C8              	   143:   iny
00:8F6B 80F9            	   144:   bra partial_handler_next
                        	   145: partial_handler_next_found_item_length:
00:8F6D 98              	   146:   tya     ; length of the word in the table
00:8F6E 18              	   147:   clc
00:8F6F 6903            	   148:   adc #3  ; skip the 0x00 and the execution address
00:8F71 6503            	   149:   adc DEST
00:8F73 8503            	   150:   sta DEST
00:8F75 A504            	   151:   lda DEST+1
00:8F77 6900            	   152:   adc #0
00:8F79 8504            	   153:   sta DEST+1
00:8F7B 80D2            	   154:   bra partial_handler_next_item
                        	   155: 
                        	   156: partial_handler_found_directive:
00:8F7D B103            	   157:   lda (DEST),y
00:8F7F F003            	   158:   beq partial_handler_skipped_string
00:8F81 C8              	   159:   iny
00:8F82 80F9            	   160:   bra partial_handler_found_directive
                        	   161: partial_handler_skipped_string:
00:8F84 C8              	   162:   iny  ; skip past the 0x00 byte
00:8F85 B103            	   163:   lda (DEST),y
00:8F87 8599            	   164:   sta token_work+1
00:8F89 C8              	   165:   iny
00:8F8A B103            	   166:   lda (DEST),y
00:8F8C 859A            	   167:   sta token_work+2
00:8F8E 6C9900          	   168:   jmp (token_work+1)   ; do partial_partial_handler_ - it will RTS for us
                        	   169: 
                        	   170: partial_handler_done:
00:8F91 60              	   171:   rts
                        	   172: 
                        	   173: ;***********************************************
                        	   174: ; JUMP ON TOKEN
                        	   175: ; X/Y = START OF TABLE
                        	   176: ; END OF TABLE IS A NULL
                        	   177: ; A = TOKEN
                        	   178: ;***********************************************
                        	   179: TKNJMP   =  *
00:8F92 8600            	   180:          stx  REG     ; save table address
00:8F94 8401            	   181:          sty  REG+1
                        	   182: 
00:8F96 20C48F          	   183:          jsr MAKE_UPPER
00:8F99 AA              	   184:          tax          ; save the token
                        	   185: JMP1     =  *
00:8F9A A000            	   186:          ldy  #0
00:8F9C B100            	   187:          lda  (REG),Y
00:8F9E D002            	   188:          bne  JMP2
                        	   189: ; failed to find the token
00:8FA0 8A              	   190:          txa          ; retore the token
00:8FA1 60              	   191:          rts
                        	   192: JMP2     =  *
00:8FA2 8A              	   193:          txa          ; get token back
00:8FA3 D100            	   194:          cmp  (REG),Y
00:8FA5 D010            	   195:          bne  JMP3    ; branch if not found
00:8FA7 68              	   196:          pla
00:8FA8 68              	   197:          pla          ; remove return address for TKNJMP call
00:8FA9 C8              	   198:          iny          ; move Y on to routine address
00:8FAA B100            	   199:          lda  (REG),Y ; get low order byte of routine
00:8FAC 8503            	   200:          sta  REG2
00:8FAE C8              	   201:          iny          ; next byte
00:8FAF B100            	   202:          lda  (REG),Y ; get high order byte
00:8FB1 8504            	   203:          sta  REG2+1
00:8FB3 8A              	   204:          txa          ; get token back
00:8FB4 6C0300          	   205:          jmp  (REG2)  ; go to routine
                        	   206: JMP3     =  *
00:8FB7 A500            	   207:          lda  REG     ; skip this token sequence
00:8FB9 18              	   208:          clc
00:8FBA 6903            	   209:          adc  #3
00:8FBC 8500            	   210:          sta  REG
00:8FBE 90DA            	   211:          bcc  JMP1
00:8FC0 E601            	   212:          inc  REG+1
00:8FC2 80D6            	   213:          bra  JMP1    ; try again
                        	   214: 
                        	   215: ;
                        	   216: 
                        	   217: 
                        	   218: ;***********************************************
                        	   219: ;
                        	   220: ; Case conversion
                        	   221: ;
                        	   222: ;***********************************************
                        	   223: 
                        	   224: 
                        	   225: MAKE_UPPER = *
00:8FC4 C97B            	   226:          CMP  #('z'+1)
00:8FC6 B006            	   227:          BCS  MAKE_UPPER_DONE
00:8FC8 C961            	   228:          CMP  #'a'
00:8FCA 9002            	   229:          BCC  MAKE_UPPER_DONE
00:8FCC E920            	   230:          SBC  #$20  ; make upper-case - we want carry set so there is no borrow
                        	   231: MAKE_UPPER_DONE = *
00:8FCE 60              	   232:          RTS
                        	   233: 
                        	   234: MAKE_LOWER = *
00:8FCF C941            	   235:          CMP  #'A'
00:8FD1 9006            	   236:          BCC  MAKE_LOWER_DONE
00:8FD3 C95B            	   237:          CMP  #('Z'+1)
00:8FD5 B002            	   238:          BCS  MAKE_LOWER_DONE
00:8FD7 6920            	   239:          ADC  #$20  ; make upper-case - we want carry clear so there is no carry
                        	   240: MAKE_LOWER_DONE = *
00:8FD9 60              	   241:          RTS
                        	   242: 
                        	   243: 
                        	   244: ;
                        	   245: ;  generate the next random number
                        	   246: ;
                        	   247: gen_random:
00:8FDA 0609            	   248:     asl random
00:8FDC 260A            	   249:     rol random+1
00:8FDE 260B            	   250:     rol random+2
00:8FE0 260C            	   251:     rol random+3
00:8FE2 9018            	   252:     bcc gen_random1
00:8FE4 A509            	   253:     lda random
00:8FE6 49B7            	   254:     eor #$B7
00:8FE8 8509            	   255:     sta random
00:8FEA A50A            	   256:     lda random+1
00:8FEC 491D            	   257:     eor #$1D
00:8FEE 850A            	   258:     sta random+1
00:8FF0 A50B            	   259:     lda random+2
00:8FF2 49C1            	   260:     eor #$C1
00:8FF4 850B            	   261:     sta random+2
00:8FF6 A50C            	   262:     lda random+3
00:8FF8 4904            	   263:     eor #$04
00:8FFA 850C            	   264:     sta random+3
                        	   265: gen_random1:
00:8FFC 60              	   266:     rts
                        	   267: 
                        	   268: 
                        	   269: 
                        	   270: ;
                        	   271: ;  From: http://www.6502.org/source/integers/crc-more.html
                        	   272: ;
                        	   273: ;   jacksum  -a crc:16,1021,FFFF,false,false,0 -X SOME_FILE
                        	   274: ;
                        	   275: ;   https://jacksum.net/en/index.html
                        	   276: ;
                        	   277: ;   With a starting CRC of $FFFF, the binary string $01 $02 $03 $04 should evaluate to $89C3.
                        	   278: ;
                        	   279: ;   Start at crc_addr, for crc_num bytes
                        	   280: ;
                        	   281: crc16 = *
                        	   282: ;
                        	   283: ;  initialise CRC
                        	   284: ;
00:8FFD A9FF            	   285:   lda #$FF
00:8FFF 8506            	   286:   sta crc_val
00:9001 8507            	   287:   sta crc_val+1
00:9003 A503            	   288:   lda crc_num
00:9005 0504            	   289:   ora crc_num+1
00:9007 F01B            	   290:   beq crc_done
                        	   291: 
                        	   292: ;
                        	   293: ;  here for each byte
                        	   294: ;
                        	   295: crc16_loop  = *
00:9009 A000            	   296:   ldy #0
00:900B B100            	   297:   lda (crc_addr),y  ; get next byte
00:900D 202590          	   298:   jsr crc_byte
                        	   299:   ;
                        	   300:   ;  onto next address
                        	   301:   ;
00:9010 E600            	   302:   inc crc_addr
00:9012 D002            	   303:   bne crc16_next
00:9014 E601            	   304:   inc crc_addr+1       ; Step to next byte
                        	   305: crc16_next:
                        	   306:   ;
                        	   307:   ; now do a 16-bit decrement
                        	   308:   ;
00:9016 A503            	   309:   LDA crc_num
00:9018 D002            	   310:   BNE crc16_skip    ; decrement the high-order byte if we are about to wrap
00:901A C604            	   311:   DEC crc_num+1
                        	   312: crc16_skip:
00:901C C603            	   313:   DEC crc_num       ; decrement the low-order byte
00:901E D0E9            	   314:   BNE crc16_loop    ; not zero, keep going
00:9020 A504            	   315:   LDA crc_num+1     ; are we zero here too?
00:9022 D0E5            	   316:   BNE crc16_loop    ; not yet
                        	   317: 
                        	   318: crc_done:
00:9024 60              	   319:   rts
                        	   320: 
                        	   321: ;
                        	   322: ;  do a CRC of one byte (in A) updating crc_val
                        	   323: ;
                        	   324: crc_byte = *
00:9025 4507            	   325:   eor crc_val+1     ; A contained the data
00:9027 8507            	   326:   sta crc_val+1     ; XOR it into high byte
00:9029 4A              	   327:   lsr               ; right shift A 4 bits
00:902A 4A              	   328:   lsr               ; to make top of x^12 term
00:902B 4A              	   329:   lsr               ; ($1...)
00:902C 4A              	   330:   lsr
00:902D AA              	   331:   tax               ; save it
00:902E 0A              	   332:   asl               ; then make top of x^5 term
00:902F 4506            	   333:   eor crc_val       ; and XOR that with low byte
00:9031 8506            	   334:   sta crc_val       ; and save
00:9033 8A              	   335:   txa               ; restore partial term
00:9034 4507            	   336:   eor crc_val+1     ; and update high byte
00:9036 8507            	   337:   sta crc_val+1     ; and save
00:9038 0A              	   338:   asl               ; left shift three
00:9039 0A              	   339:   asl               ; the rest of the terms
00:903A 0A              	   340:   asl               ; have feedback from x^12
00:903B AA              	   341:   tax               ; save bottom of x^12
00:903C 0A              	   342:   asl               ; left shift two more
00:903D 0A              	   343:   asl               ; watch the carry flag
00:903E 4507            	   344:   eor crc_val+1     ; bottom of x^5 ($..2.)
00:9040 A8              	   345:   tay               ; save high byte
00:9041 8A              	   346:   txa               ; fetch temp value
00:9042 2A              	   347:   rol               ; bottom of x^12, middle of x^5!
00:9043 4506            	   348:   eor crc_val       ; finally update low byte
00:9045 8507            	   349:   sta crc_val+1     ; then swap high and low bytes
00:9047 8406            	   350:   sty crc_val
00:9049 60              	   351:   rts
                        	   352: 
                        	   353: 
                        	   354: crc_helper = *
00:904A 5A              	   355:   phy
00:904B DA              	   356:   phx
00:904C 202590          	   357:   jsr crc_byte
00:904F E603            	   358:   inc crc_num
00:9051 D002            	   359:   bne crc_helper1
00:9053 E604            	   360:   inc crc_num+1
                        	   361: crc_helper1:
00:9055 FA              	   362:   plx
00:9056 7A              	   363:   ply
00:9057 60              	   364:   rts
                        	   365: 
00:9058 536F757263652043	   366: crc_message asciiz "Source CRC       $"               ; source CRC
00:9060 5243202020202020
00:9068 2024
00:906A 00
00:906B 536F75726365206C	   367: source_length_message asciiz "Source length: "    ; source length
00:9073 656E6774683A20
00:907A 00
00:907B 2062797465730A  	   368: bytes_message asciiz " bytes\n"
00:9082 00
                        	   369: 
                        	   370: crc_source = *
00:9083 20898C          	   371:   jsr find_source_end
                        	   372: 
                        	   373: ;
                        	   374: ;  move existing source to end of RAM
                        	   375: ;
00:9086 18              	   376:   clc             ; don't count the final 0x00 byte
00:9087 A523            	   377:   lda PCODE
00:9089 E900            	   378:   sbc #<TEXT_START
00:908B 8503            	   379:   sta crc_num
00:908D A524            	   380:   lda PCODE+1
00:908F E903            	   381:   sbc #>TEXT_START
00:9091 8504            	   382:   sta crc_num+1
                        	   383: ;
                        	   384: ;  Show the length of the source
                        	   385: ;
00:9093 A96B            	   386:   lda #<source_length_message
00:9095 A290            	   387:   ldx #>source_length_message
00:9097 202682          	   388:   jsr print
00:909A A503            	   389:   lda crc_num
00:909C 8500            	   390:   sta REG
00:909E A504            	   391:   lda crc_num+1
00:90A0 8501            	   392:   sta REG+1
00:90A2 6402            	   393:   stz REGB
00:90A4 205291          	   394:   jsr display_in_decimal
00:90A7 A97B            	   395:   lda #<bytes_message
00:90A9 A290            	   396:   ldx #>bytes_message
00:90AB 202682          	   397:   jsr print
                        	   398: 
                        	   399: ;
                        	   400: ;  now the CRC
                        	   401: ;
00:90AE A900            	   402:   lda #<TEXT_START
00:90B0 8500            	   403:   sta crc_addr
00:90B2 A903            	   404:   lda #>TEXT_START
00:90B4 8501            	   405:   sta crc_addr+1
00:90B6 20FD8F          	   406:   jsr crc16
00:90B9 A958            	   407:   lda  #<crc_message            ;  source CRC
00:90BB A290            	   408:   ldx  #>crc_message            ;
00:90BD 202682          	   409:   jsr  print
00:90C0 A507            	   410:   lda crc_val+1
00:90C2 209D92          	   411:   jsr PRBYTE
00:90C5 A506            	   412:   lda crc_val
00:90C7 205293          	   413:   jsr PRBYTECR
00:90CA 60              	   414:   rts
                        	   415: 
                        	   416: 
                        	   417: ;
                        	   418: ;  delays for roughly 1 ms - changes no registers
                        	   419: ;
                        	   420: delay_1ms = *
00:90CB DA              	   421:          phx
00:90CC A26C            	   422:          ldx #108
                        	   423: delay_1ms_loop:
00:90CE EA              	   424:          nop
00:90CF EA              	   425:          nop
00:90D0 CA              	   426:          dex
00:90D1 D0FB            	   427:          bne delay_1ms_loop
00:90D3 FA              	   428:          plx
00:90D4 60              	   429:          rts
                        	   430: 
                        	   431: ;
                        	   432: ; delay for YYXX ms (Y = high-order byte, X = lo-order byte)
                        	   433: ;  maximum delay 0x7FFF, that is 32767 ms
                        	   434: ;  Changes X and Y
                        	   435: ;
                        	   436: delay = *
00:90D5 20CB90          	   437:   jsr delay_1ms
00:90D8 CA              	   438:   dex
00:90D9 D0FA            	   439:   bne delay
00:90DB 88              	   440:   dey
00:90DC 10F7            	   441:   bpl delay
00:90DE 60              	   442:   rts
                        	   443: 
                        	   444: 
                        	   445: ;--------------------------------------------------------------------------
                        	   446: ;
                        	   447: ;  BINARY TO DECIMAL CONVERSION
                        	   448: ;
                        	   449: ;  This works as follows:
                        	   450: ;
                        	   451: ;  1. First the number is checked if it is negative (sign bit set).
                        	   452: ;  2. If so, a "-" is output and the number subtracted from zero to make it positive.
                        	   453: ;  3. Our next step is to set a BCD (binary coded decimal) output area to all zeroes.
                        	   454: ;      In BCD, the number 1234 is actually stored as 0x1234.
                        	   455: ;      With BCD mode turned on in the processor, doing adds results in an early carry
                        	   456: ;      so that numbers add "the decimal way" rather than the binary way.
                        	   457: ;  4. Then we a loop of 24 iterations (one for each bit) which adds the appropriate number from bcd_table
                        	   458: ;      if that bit was set in the original value.
                        	   459: ;  5. The function bcd_unpack is then called to convert the BCD format into ASCII format. It takes each
                        	   460: ;     nibble and adds 0x30 ('0') to it, and saves that in bcd_result.
                        	   461: ;  6. At this stage bcd_result has a 8-digit ASCII number in it.
                        	   462: ;  7. We then skip leading zeroes in bcd_result.
                        	   463: ;  8. Finally the remaining digits in bcd_result are output.
                        	   464: ;
                        	   465: ;
                        	   466: ;   I'm not sure where the idea for this came from. There was no Internet when this was written in 1979
                        	   467: ;   so it is possibly (probably) my own.
                        	   468: ;   My original implementation, although similar, was more complex than this one, which I found at:
                        	   469: ;              http://www.6502.org/source/integers/hex2dec.htm
                        	   470: ;
                        	   471: ;   Other suggestions for binary to decimal conversion I found recently do not employ this method. One
                        	   472: ;   technique (as described by Ben Eater here: https://www.youtube.com/watch?v=v3-a-zqKfgA ) is to
                        	   473: ;   repeatedly divide by 10 and use the remainder as the digit. This has to be done until the result of
                        	   474: ;   the division is zero. Dividing a 3-byte number by 10 on an 8-bit machine is not particularly fast,
                        	   475: ;   as it involves an inner loop of 24 iterations (one for each bit) and this would have to be done for
                        	   476: ;   each digit, so the number of loops of 24 iterations would increase for each digit. Therefore an
                        	   477: ;   8-digit number (like 80000000) would take 144 iterations in the divide loop. Then the digits have to
                        	   478: ;   be reversed because the remainder gives you the low-order decimal digit first.
                        	   479: ;
                        	   480: ;   Another technique is the "Double dabble" routine.
                        	   481: ;
                        	   482: ;     https://en.wikipedia.org/wiki/Double_dabble
                        	   483: ;
                        	   484: ;   The method below seems fairly efficient, as the inner loop only does anything substantial if a
                        	   485: ;     1-bit is detected. Thus large numbers can be produced quite efficiently, however it would be a
                        	   486: ;     bit slower if the input number had a lot of 1-bits set.
                        	   487: ;
                        	   488: ;   Considering that this is only used when outputting to serial, itself a slow process, speed is not
                        	   489: ;   really the issue here.
                        	   490: ;
                        	   491: ;   - Nick Gammon
                        	   492: ;
                        	   493: ;
                        	   494: ;--------------------------------------------------------------------------
                        	   495: ;
                        	   496: ; Converts BCD to ASCII
                        	   497: ;
                        	   498: bcd_unpack:
00:90DF 48              	   499:   pha  ; save the number for later
                        	   500: ;
                        	   501: ;  shift right 4 bits
                        	   502: ;
00:90E0 4A              	   503:   lsr A
00:90E1 4A              	   504:   lsr A
00:90E2 4A              	   505:   lsr A
00:90E3 4A              	   506:   lsr A
00:90E4 0930            	   507:   ora #'0'          ; make printable
00:90E6 9560            	   508:   sta bcd_result,X  ; save in bcd_result
00:90E8 E8              	   509:   inx
00:90E9 68              	   510:   pla               ; get the original character back
00:90EA 290F            	   511:   and #$0F          ; take low-order bits and make printable
00:90EC 0930            	   512:   ora #'0'
00:90EE 9560            	   513:   sta bcd_result,X  ; save in bcd_result
00:90F0 E8              	   514:   inx
00:90F1 60              	   515:   rts               ; done!
                        	   516: 
                        	   517: ;
                        	   518: ;
                        	   519: ; Table for adding into the BCD result.
                        	   520: ;
                        	   521: bcd_table  =  *
00:90F2 00              	   522:   dfb $00,$00,$00,$01   ; 0000001
00:90F3 00
00:90F4 00
00:90F5 01
00:90F6 00              	   523:   dfb $00,$00,$00,$02   ; 0000002
00:90F7 00
00:90F8 00
00:90F9 02
00:90FA 00              	   524:   dfb $00,$00,$00,$04   ; 0000004
00:90FB 00
00:90FC 00
00:90FD 04
00:90FE 00              	   525:   dfb $00,$00,$00,$08   ; 0000008
00:90FF 00
00:9100 00
00:9101 08
00:9102 00              	   526:   dfb $00,$00,$00,$16   ; 0000016
00:9103 00
00:9104 00
00:9105 16
00:9106 00              	   527:   dfb $00,$00,$00,$32   ; 0000032
00:9107 00
00:9108 00
00:9109 32
00:910A 00              	   528:   dfb $00,$00,$00,$64   ; 0000064
00:910B 00
00:910C 00
00:910D 64
00:910E 00              	   529:   dfb $00,$00,$01,$28   ; 0000128
00:910F 00
00:9110 01
00:9111 28
00:9112 00              	   530:   dfb $00,$00,$02,$56   ; 0000256
00:9113 00
00:9114 02
00:9115 56
00:9116 00              	   531:   dfb $00,$00,$05,$12   ; 0000512
00:9117 00
00:9118 05
00:9119 12
00:911A 00              	   532:   dfb $00,$00,$10,$24   ; 0001024
00:911B 00
00:911C 10
00:911D 24
00:911E 00              	   533:   dfb $00,$00,$20,$48   ; 0002048
00:911F 00
00:9120 20
00:9121 48
00:9122 00              	   534:   dfb $00,$00,$40,$96   ; 0004096
00:9123 00
00:9124 40
00:9125 96
00:9126 00              	   535:   dfb $00,$00,$81,$92   ; 0008192
00:9127 00
00:9128 81
00:9129 92
00:912A 00              	   536:   dfb $00,$01,$63,$84   ; 0016384
00:912B 01
00:912C 63
00:912D 84
00:912E 00              	   537:   dfb $00,$03,$27,$68   ; 0032768
00:912F 03
00:9130 27
00:9131 68
00:9132 00              	   538:   dfb $00,$06,$55,$36   ; 0065536
00:9133 06
00:9134 55
00:9135 36
00:9136 00              	   539:   dfb $00,$13,$10,$72   ; 0131072
00:9137 13
00:9138 10
00:9139 72
00:913A 00              	   540:   dfb $00,$26,$21,$44   ; 0262144
00:913B 26
00:913C 21
00:913D 44
00:913E 00              	   541:   dfb $00,$52,$42,$88   ; 0524288
00:913F 52
00:9140 42
00:9141 88
00:9142 01              	   542:   dfb $01,$04,$85,$76   ; 1048576
00:9143 04
00:9144 85
00:9145 76
00:9146 02              	   543:   dfb $02,$09,$71,$52   ; 2097152
00:9147 09
00:9148 71
00:9149 52
00:914A 04              	   544:   dfb $04,$19,$43,$04   ; 4194304
00:914B 19
00:914C 43
00:914D 04
00:914E 08              	   545:   dfb $08,$38,$86,$08   ; 8388608
00:914F 38
00:9150 86
00:9151 08
                        	   546: 
                        	   547: ;--------------------------------------------------------------------------
                        	   548: ; display_in_decimal - start here - VALUE will be zero after this is executed
                        	   549: ;--------------------------------------------------------------------------
                        	   550: 
                        	   551: display_in_decimal  =  *
00:9152 A502            	   552:   lda  VALUE+2
00:9154 1008            	   553:   bpl  bcd_positive
                        	   554: ;
                        	   555: ;  if the number is negative, output a minus sign and make it positive
                        	   556: ;
00:9156 A92D            	   557:   lda  #'-'
00:9158 20AF93          	   558:   jsr  COUT
00:915B 208AAB          	   559:   jsr  exp_unary_minus
                        	   560: ;
                        	   561: ;  number is now positive
                        	   562: ;
                        	   563: bcd_positive:
                        	   564: 
00:915E 207B91          	   565:   jsr binary_to_decimal   ; do the conversion
                        	   566: 
00:9161 A207            	   567:   ldx  #7         ; zero suppress count (always keep the last zero)
00:9163 A000            	   568:   ldy  #0
                        	   569: ;
                        	   570: ;  this is skipping the leading zeroes
                        	   571: ;
                        	   572: bcd_skip_zeroes:
00:9165 B96000          	   573:   lda  bcd_result,Y
00:9168 C930            	   574:   cmp  #'0'
00:916A D004            	   575:   bne  bcd_output_digit
00:916C C8              	   576:   iny
00:916D CA              	   577:   dex
00:916E D0F5            	   578:   bne  bcd_skip_zeroes
                        	   579: ;
                        	   580: ;  now we have a non-zero, start outputting them
                        	   581: ;
                        	   582: ;  Y points to how far we are through bcd_result
                        	   583: ;  X is how many digits to go
                        	   584: ;
                        	   585: bcd_output_digit:
00:9170 B96000          	   586:   lda  bcd_result,Y
00:9173 20AF93          	   587:   jsr  COUT
00:9176 C8              	   588:   iny
00:9177 CA              	   589:   dex
00:9178 10F6            	   590:   bpl  bcd_output_digit
                        	   591: ;
                        	   592: ;  done!
                        	   593: ;
00:917A 60              	   594:   rts
                        	   595: 
                        	   596: ;--------------------------------------------------------------------------
                        	   597: ;
                        	   598: ;  Binary to decimal routine: Converts VALUE into bcd_result (8 digits)
                        	   599: ;
                        	   600: ;  See: http://www.6502.org/source/integers/hex2dec.htm
                        	   601: ;
                        	   602: ;  - VALUE will be zero after this is executed
                        	   603: ;
                        	   604: ;--------------------------------------------------------------------------
                        	   605: binary_to_decimal:
00:917B F8              	   606:   sed                 ; decimal mode for adds below
00:917C 645C            	   607:   stz  bcd_work       ; zero our result area (4 bytes = 8 digits)
00:917E 645D            	   608:   stz  bcd_work+1
00:9180 645E            	   609:   stz  bcd_work+2
00:9182 645F            	   610:   stz  bcd_work+3
                        	   611: 
00:9184 A25C            	   612:   ldx  #(4*23)        ; X points to the start of the highest entry
                        	   613: 
                        	   614: binary_to_decimal_loop:
00:9186 0600            	   615:   asl VALUE      ;  shift out high-order bit into Carry
00:9188 2601            	   616:   rol VALUE+1
00:918A 2602            	   617:   rol VALUE+2
00:918C 901D            	   618:   bcc binary_to_decimal_next  ; if carry clear, no add needs to be done
                        	   619: ;
                        	   620: ;  that bit was set, so add the appropriate BCD number from the table (eg. 1, 2, 4, 8, 16 and so on)
                        	   621: ;
00:918E 18              	   622:   clc
00:918F A55C            	   623:   lda bcd_work
00:9191 7DF590          	   624:   adc bcd_table+3,X
00:9194 855C            	   625:   sta bcd_work
00:9196 A55D            	   626:   lda bcd_work+1
00:9198 7DF490          	   627:   adc bcd_table+2,X
00:919B 855D            	   628:   sta bcd_work+1
00:919D A55E            	   629:   lda bcd_work+2
00:919F 7DF390          	   630:   adc bcd_table+1,X
00:91A2 855E            	   631:   sta bcd_work+2
00:91A4 A55F            	   632:   lda bcd_work+3
00:91A6 7DF290          	   633:   adc bcd_table,X
00:91A9 855F            	   634:   sta bcd_work+3
                        	   635: 
                        	   636: binary_to_decimal_next:
00:91AB CA              	   637:   dex      ; back to the previous table item
00:91AC CA              	   638:   dex
00:91AD CA              	   639:   dex
00:91AE CA              	   640:   dex
00:91AF 10D5            	   641:   bpl binary_to_decimal_loop
00:91B1 D8              	   642:   cld     ; decimal mode off
                        	   643: 
                        	   644: 
                        	   645: ;
                        	   646: ;  convert BCD to ASCII - note that UNPACK increments x by two each time
                        	   647: ;    - the results are in bcd_result - an 8-character field
                        	   648: ;
                        	   649: ;  We unpack the high-order bytes first, naturally
                        	   650: ;
00:91B2 A200            	   651:   ldx  #0
00:91B4 A55F            	   652:   lda  bcd_work+3
00:91B6 20DF90          	   653:   jsr  bcd_unpack
00:91B9 A55E            	   654:   lda  bcd_work+2
00:91BB 20DF90          	   655:   jsr  bcd_unpack
00:91BE A55D            	   656:   lda  bcd_work+1
00:91C0 20DF90          	   657:   jsr  bcd_unpack
00:91C3 A55C            	   658:   lda  bcd_work
00:91C5 20DF90          	   659:   jsr  bcd_unpack
00:91C8 60              	   660:   rts
                        	   661: 
00:91C9 4E6F20736F757263	   662: NOSCE    asciiz  'No source file.\n'   ; No source file
00:91D1 652066696C652E0A
00:91D9 00
                        	   663: 
                        	   664: ;***********************************************
                        	   665: ;
                        	   666: ; Initialize a compile or assembly
                        	   667: ;
                        	   668: ;***********************************************
                        	   669: 
                        	   670: 
                        	   671: INIT     =  *
                        	   672: ;
                        	   673: ;  set up symbol table pointer
                        	   674: ;
                        	   675: 
00:91DA A93F            	   676:   lda  #>SYMBOL_TABLE_START
00:91DC 8532            	   677:   sta  ENDSYM+1
00:91DE 8530            	   678:   sta  STARTSYM+1
00:91E0 A9FF            	   679:   lda  #<SYMBOL_TABLE_START
00:91E2 8531            	   680:   sta  ENDSYM
00:91E4 852F            	   681:   sta  STARTSYM
                        	   682: 
                        	   683: INIT_SECOND_PASS:   ; for assembler
                        	   684: 
00:91E6 A900            	   685:   lda  #0
00:91E8 851D            	   686:   sta  LIST            ; not listing
00:91EA 8522            	   687:   sta  LEVEL           ; variable level zero
00:91EC 852E            	   688:   sta  DCODE
00:91EE 853F            	   689:   sta  RUNNING         ; not running
00:91F0 8539            	   690:   sta  PRCITM
00:91F2 853A            	   691:   sta  PRCITM+1
00:91F4 8502            	   692:   sta  REGB
00:91F6 8593            	   693:   sta  token_type
00:91F8 64BE            	   694:   stz  system_flags
00:91FA A901            	   695:   lda #1
00:91FC 85A2            	   696:   sta  current_line        ; we are currently on line 1
00:91FE 64A3            	   697:   stz  current_line+1
                        	   698: 
                        	   699: ;
                        	   700: ;  set up for reading first byte of source
                        	   701: ;
00:9200 A900            	   702:   lda  #<TEXT_START
00:9202 858E            	   703:   sta  token_start
00:9204 859C            	   704:   sta  token_line_start
00:9206 A903            	   705:   lda  #>TEXT_START
00:9208 858F            	   706:   sta  token_start+1
00:920A 859D            	   707:   sta  token_line_start+1
00:920C 20898C          	   708:   jsr  find_source_end
00:920F A523            	   709:   lda  PCODE
00:9211 8525            	   710:   sta  ACT_PCDA
00:9213 A524            	   711:   lda  PCODE+1
00:9215 8526            	   712:   sta  ACT_PCDA+1
00:9217 A000            	   713:   ldy  #0
00:9219 B18E            	   714:   lda  (token_start),y
00:921B D00A            	   715:   bne  INIT9
00:921D A9C9            	   716:   lda  #<NOSCE
00:921F A291            	   717:   ldx  #>NOSCE
00:9221 202682          	   718:   jsr  print                      ; No source file
00:9224 4CCC82          	   719:   jmp  main_prompt
00:9227 60              	   720: INIT9    rts
                        	   721: 
                        	   722: 
                        	   723: 
                        	   724: 
                        	   725: ;
                        	   726: CROUT    =  *             ; show a newline
00:9228 A90A            	   727:   lda  #NL         ; was a carriage-return in legacy, now is newline
00:922A 4CAF93          	   728:   jmp  COUT
                        	   729: ;
                        	   730: ;***********************************************
                        	   731: ; COMPARE STRING - compare SRCE to DEST, assumes DEST is upper-case
                        	   732: ;                - length in Y (therefore max 255 characters)
                        	   733: ;                - zero flag set if match (therefore do a BEQ to see if strings match)
                        	   734: ;***********************************************
                        	   735: COMSTL   =  *
00:922D 88              	   736:          dey
00:922E 300A            	   737:          bmi  COMS8
00:9230 B100            	   738:          lda  (SRCE),Y
00:9232 20C48F          	   739:          jsr MAKE_UPPER
00:9235 D103            	   740:          cmp  (DEST),Y
00:9237 F0F4            	   741:          beq  COMSTL
00:9239 60              	   742: COMS9    rts             ; NOT EQUAL
00:923A A900            	   743: COMS8    lda  #0
00:923C 60              	   744:          rts             ; EQUAL
                        	   745: 
                        	   746: ;***********************************************
                        	   747: ; DISPLAY A LINE
                        	   748: ;
                        	   749: 
                        	   750: ;
                        	   751: ; DISPLAY IN HEX
                        	   752: ;
00:923D 209D92          	   753: DISHX    jsr  PRBYTE
00:9240 4CB392          	   754:          jmp  PUTSP
                        	   755: ;
                        	   756: 
                        	   757: ;***********************************************
                        	   758: ; DISPLAY PCODE ADDRESS
                        	   759: ;***********************************************
                        	   760: DISPAD   =  *
00:9243 A52E            	   761:          lda  DCODE
00:9245 F017            	   762:          beq  DISPAD2
                        	   763: DISPAD1  =  *
00:9247 A928            	   764:          lda  #'('
00:9249 20AF93          	   765:          jsr  COUT
00:924C A524            	   766:          lda  PCODE+1
00:924E 209D92          	   767:          jsr  PRBYTE
00:9251 A523            	   768:          lda  PCODE
00:9253 209D92          	   769:          jsr  PRBYTE
00:9256 A929            	   770:          lda  #')'
00:9258 20AF93          	   771:          jsr  COUT
00:925B 4CB392          	   772:          jmp  PUTSP
00:925E 60              	   773: DISPAD2  rts
                        	   774: ;
                        	   775: 
                        	   776: ;***********************************************
                        	   777: ; PUSH 'WORK' ONTO STACK
                        	   778: ;***********************************************
                        	   779: PSHWRK   =  *
00:925F 8536            	   780:          sta  BSAVE
00:9261 68              	   781:          pla
00:9262 AA              	   782:          tax
00:9263 68              	   783:          pla
00:9264 A8              	   784:          tay
00:9265 A538            	   785:          lda  WORK+1
00:9267 48              	   786:          pha
00:9268 A537            	   787:          lda  WORK
00:926A 48              	   788:          pha
00:926B 98              	   789:          tya
00:926C 48              	   790:          pha
00:926D 8A              	   791:          txa
00:926E 48              	   792:          pha
00:926F A536            	   793:          lda  BSAVE
00:9271 60              	   794: PSH9     rts
                        	   795: ;
                        	   796: ;***********************************************
                        	   797: ; PULL 'WORK' FROM STACK
                        	   798: ;***********************************************
                        	   799: PULWRK   =  *
00:9272 8536            	   800:          sta  BSAVE
00:9274 68              	   801:          pla
00:9275 AA              	   802:          tax
00:9276 68              	   803:          pla
00:9277 A8              	   804:          tay
00:9278 68              	   805:          pla
00:9279 8537            	   806:          sta  WORK
00:927B 68              	   807:          pla
00:927C 8538            	   808:          sta  WORK+1
00:927E 98              	   809:          tya
00:927F 48              	   810:          pha
00:9280 8A              	   811:          txa
00:9281 48              	   812:          pha
00:9282 A536            	   813:          lda  BSAVE
00:9284 60              	   814:          rts
                        	   815: ;
                        	   816: ;***********************************************
                        	   817: ; PRINTING SUBROUTINES
                        	   818: ; Control characters print with a ^ in front of them, eg. ^A
                        	   819: ;***********************************************
                        	   820: PRCHAR   =  *
00:9285 48              	   821:   pha
00:9286 C90A            	   822:   cmp #NL
00:9288 F00E            	   823:   beq prchar_not_control
00:928A C920            	   824:   cmp #$20
00:928C B00A            	   825:   bcs prchar_not_control
00:928E 48              	   826:   pha
00:928F A95E            	   827:   lda #'^'
00:9291 20AF93          	   828:   jsr COUT
00:9294 68              	   829:   pla
00:9295 18              	   830:   clc
00:9296 6940            	   831:   adc #$40  ; make 0x01 print as ^A
                        	   832: prchar_not_control:
00:9298 20AF93          	   833:   jsr  COUT
00:929B 68              	   834:   pla
00:929C 60              	   835:   rts
                        	   836: ;
                        	   837: ; Prints A in hex
                        	   838: ;
                        	   839: PRBYTE:
00:929D 48              	   840:   pha
00:929E 4A              	   841:   lsr
00:929F 4A              	   842:   lsr
00:92A0 4A              	   843:   lsr
00:92A1 4A              	   844:   lsr
00:92A2 20A892          	   845:   jsr  PRHEXZ    ; first nibble
00:92A5 68              	   846:   pla            ; now do other nibble
                        	   847: PRHEX:
00:92A6 290F            	   848:   and  #$0F
                        	   849: PRHEXZ:
00:92A8 0930            	   850:   ora  #'0'
00:92AA C93A            	   851:   cmp  #'0' + $0A
00:92AC 9002            	   852:   bcc  PRHEX1
00:92AE 6926            	   853:   adc  #$26  ; (carry is set: adding 7 to make 0x0a become 'a')
                        	   854: PRHEX1:
00:92B0 4C8592          	   855:   jmp  PRCHAR
                        	   856: ;
                        	   857: PUTSP    =  *
00:92B3 A920            	   858:   lda  #' '
00:92B5 80F9            	   859:   bra  PRHEX1
                        	   860: ;
                        	   861: ;
                        	   862: ;  PT - put text
                        	   863: ;   Low-order address in A, high-order address in X, count in Y
                        	   864: ;
                        	   865: ;
                        	   866: PT:
00:92B7 8503            	   867:   sta  REG2
00:92B9 8604            	   868:   stx  REG2+1
00:92BB 98              	   869:   tya    ; count of bytes to print
00:92BC AA              	   870:   tax    ; put that into X
00:92BD A000            	   871:   ldy  #0
                        	   872: PT6:
00:92BF B103            	   873:   lda  (REG2),Y    ; next character
00:92C1 20AF93          	   874:   jsr COUT         ; show it
00:92C4 C8              	   875:   iny
00:92C5 CA              	   876:   dex
00:92C6 D0F7            	   877:   bne  PT6
00:92C8 60              	   878:   rts
                        	   879: ;
                        	   880: ;
                        	   881: ;
                        	   882: ;---- token_address --> WORK
                        	   883: ;
                        	   884: TKNWRK   =  *
00:92C9 48              	   885:          PHA
00:92CA A590            	   886:          LDA  token_address
00:92CC 8537            	   887:          STA  WORK
00:92CE A591            	   888:          LDA  token_address+1
00:92D0 8538            	   889:          STA  WORK+1
00:92D2 68              	   890:          PLA
00:92D3 60              	   891:          RTS
                        	   892: ;
                        	   893: ;---- WORK --> token_address
                        	   894: ;
                        	   895: WRKTKN   =  *
00:92D4 48              	   896:          PHA
00:92D5 A537            	   897:          LDA  WORK
00:92D7 8590            	   898:          STA  token_address
00:92D9 A538            	   899:          LDA  WORK+1
00:92DB 8591            	   900:          STA  token_address+1
00:92DD 68              	   901:          PLA
00:92DE 60              	   902:          RTS
                        	   903: ;
                        	   904: 
                        	   905: 
                        	   906: ;***********************************************
                        	   907: ; MENU, FILE HANDLING
                        	   908: ;***********************************************
                        	   909: ;
00:92DF 502D636F64657320	   910: pcodes_ended_message        asciiz  "P-codes ended at $"
00:92E7 656E646564206174
00:92EF 2024
00:92F1 00
00:92F2 436F6D70696C6520	   911: compile_finished_message    asciiz  "Compile finished: No errors.\n"
00:92FA 66696E6973686564
00:9302 3A204E6F20657272
00:930A 6F72732E0A
00:930F 00
00:9310 53796D626F6C2074	   912: symbol_table_ended_message  asciiz "Symbol table ended at $"
00:9318 61626C6520656E64
00:9320 65642061742024
00:9327 00
00:9328 4E6F2076616C6964	   913: no_valid_compile_message    asciiz  'No valid compile or assemble done before\n'
00:9330 20636F6D70696C65
00:9338 206F722061737365
00:9340 6D626C6520646F6E
00:9348 65206265666F7265
00:9350 0A
00:9351 00
                        	   914: ;
                        	   915: PRBYTECR =  *
00:9352 209D92          	   916:          JSR  PRBYTE
00:9355 4C2892          	   917:          JMP  CROUT
                        	   918: ;
                        	   919: ;
                        	   920: ;
                        	   921: CHK_VAL  =  *
00:9358 A908            	   922:          LDA  #FLAG_VALID_COMPILE
00:935A 0910            	   923:          ORA  #FLAG_VALID_ASSEMBLE
00:935C 25BE            	   924:          and  system_flags
00:935E D00A            	   925:          BNE  CHK_VAL9
00:9360 A928            	   926:          LDA  #<no_valid_compile_message    ; No valid Compile or Assemble done before
00:9362 A293            	   927:          LDX  #>no_valid_compile_message
00:9364 202682          	   928:          JSR  print
00:9367 4CCC82          	   929:          JMP  main_prompt
                        	   930: CHK_VAL9 =  *
                        	   931: BELL1X   =  *          ; no bell yet
00:936A 60              	   932:          RTS
                        	   933: ;
00:936B 205893          	   934: CHK_RUN  JSR  CHK_VAL
00:936E A910            	   935:          lda  #FLAG_VALID_ASSEMBLE
00:9370 25BE            	   936:          and  system_flags
00:9372 D003            	   937:          bne  run_assembler
00:9374 4CCAAD          	   938:          JMP  INTERP
                        	   939: run_assembler:
00:9377 207D93          	   940:          jsr call_assembler
00:937A 4C66AE          	   941:          JMP  EX_FINISHD
                        	   942: ;
                        	   943: ;  let's assume they put a RTS at the end of their code
                        	   944: ;
                        	   945: call_assembler:
00:937D A958            	   946:          LDA  #<running_message   ; Running
00:937F A2AD            	   947:          LDX  #>running_message
00:9381 202682          	   948:          JSR  print
00:9384 6C2500          	   949:          JMP (ACT_PCDA)
                        	   950: 
                        	   951: ;
                        	   952: 
                        	   953: ;
                        	   954: ; Get a line, read byte by byte until we get a newline, store in INBUF
                        	   955: ;   returns length in Y - handles backspace, ignores carriage-return
                        	   956: ;
                        	   957: GET_LINE =  *
                        	   958: GETLN1   =  *
00:9387 A000            	   959:   ldy  #0
                        	   960: GET1:
00:9389 2076C8          	   961:   jsr  CHRIN
00:938C C90D            	   962:   cmp  #CR       ; carriage-return?
00:938E F0F9            	   963:   beq  GET1       ; ignore it
00:9390 990002          	   964:   sta  INBUF,Y    ; SAVE IN BUFFER
00:9393 C8              	   965:   iny
00:9394 F016            	   966:   beq  GETLN_OVERFLOW       ; overflow
00:9396 C90A            	   967:   cmp  #NL        ; END OF LINE?
00:9398 F00C            	   968:   beq  GET3       ; yes
00:939A C908            	   969:   cmp  #BACKSPACE ; backspace?
00:939C D0EB            	   970:   bne  GET1       ; no - keep adding to buffer
                        	   971: ;
                        	   972: ;  here for backspace
                        	   973: ;
00:939E 88              	   974:   dey  ; get rid of backspace
00:939F 88              	   975:   dey  ; get rid of character we backspaced over
00:93A0 C0FF            	   976:   cpy  #$FF
00:93A2 F0E3            	   977:   beq  GETLN1   ; if Y underflowed, go back to zero
00:93A4 80E3            	   978:   bra GET1
                        	   979: 
                        	   980: GET3:
00:93A6 A900            	   981:   lda  #0
00:93A8 990002          	   982:   sta  INBUF,Y    ; turn newline into 0x00
00:93AB 60              	   983:   rts             ; RETURN
                        	   984: ;
                        	   985: ;  here on INBUF overflow
                        	   986: ;
                        	   987: GETLN_OVERFLOW:
00:93AC 88              	   988:   dey           ; get back to 255 (last byte)
00:93AD 80F7            	   989:   bra  GET3     ; store a zero there
                        	   990: 
                        	   991: 
                        	   992: ;
                        	   993: ;  output a character - saves all registers
                        	   994: ;
                        	   995: COUT:
00:93AF 48              	   996:   pha
00:93B0 DA              	   997:   phx
00:93B1 5A              	   998:   phy
00:93B2 20B993          	   999:   jsr COUT_CALL   ; call the current outputting routine
00:93B5 7A              	  1000:   ply
00:93B6 FA              	  1001:   plx
00:93B7 68              	  1002:   pla
00:93B8 60              	  1003:   rts
                        	  1004: 
                        	  1005: 
                        	  1006: COUT_CALL:
00:93B9 6C1700          	  1007:   jmp (write_function)
                        	  1008: 
                        	  1009: 

Source: "gpascal.asm"
                        	   176:   .include "errors.inc"

Source: "errors.inc"
                        	     1: 
                        	     2: errors_table:
00:93BC 4D656D6F72792066	     3:   asciiz "Memory full"                               ;  1
00:93C4 756C6C
00:93C7 00
00:93C8 436F6E7374616E74	     4:   asciiz "Constant expected"                         ;  2
00:93D0 2065787065637465
00:93D8 64
00:93D9 00
00:93DA 3D20657870656374	     5:   asciiz "= expected"                                ;  3
00:93E2 6564
00:93E4 00
00:93E5 4964656E74696669	     6:   asciiz "Identifier expected"                       ;  4
00:93ED 6572206578706563
00:93F5 746564
00:93F8 00
00:93F9 2C206F72203A2065	     7:   asciiz ", or : expected"                           ;  5
00:9401 78706563746564
00:9408 00
00:9409 427567          	     8:   asciiz "Bug"                                       ;  6
00:940C 00
00:940D 2A29206F72207D20	     9:   asciiz "*) or } expected"                          ;  7
00:9415 6578706563746564
00:941D 00
00:941E 496E636F72726563	    10:   asciiz "Incorrect string"                          ;  8
00:9426 7420737472696E67
00:942E 00
00:942F 2E20657870656374	    11:   asciiz ". expected"                                ;  9
00:9437 6564
00:9439 00
00:943A 3B20657870656374	    12:   asciiz "; expected"                                ; 10
00:9442 6564
00:9444 00
00:9445 556E6465636C6172	    13:   asciiz "Undeclared identifier"                     ; 11
00:944D 6564206964656E74
00:9455 6966696572
00:945A 00
00:945B 496C6C6567616C20	    14:   asciiz "Illegal identifier"                        ; 12
00:9463 6964656E74696669
00:946B 6572
00:946D 00
00:946E 3A3D206578706563	    15:   asciiz ":= expected"                               ; 13
00:9476 746564
00:9479 00
00:947A 4C69746572616C20	    16:   asciiz "Literal string of zero length"             ; 14
00:9482 737472696E67206F
00:948A 66207A65726F206C
00:9492 656E677468
00:9497 00
00:9498 436F6D70696C6572	    17:   asciiz "Compiler limits exceeded"                  ; 15
00:94A0 206C696D69747320
00:94A8 6578636565646564
00:94B0 00
00:94B1 5448454E20657870	    18:   asciiz "THEN expected"                             ; 16
00:94B9 6563746564
00:94BE 00
00:94BF 3B206F7220454E44	    19:   asciiz "; or END expected"                         ; 17
00:94C7 2065787065637465
00:94CF 64
00:94D0 00
00:94D1 444F206578706563	    20:   asciiz "DO expected"                               ; 18
00:94D9 746564
00:94DC 00
00:94DD 496E636F72726563	    21:   asciiz "Incorrect symbol"                          ; 19
00:94E5 742073796D626F6C
00:94ED 00
00:94EE 427567          	    22:   asciiz "Bug"                                       ; 20
00:94F1 00
00:94F2 557365206F662070	    23:   asciiz "Use of procedure identifier in expression" ; 21
00:94FA 726F636564757265
00:9502 206964656E746966
00:950A 69657220696E2065
00:9512 787072657373696F
00:951A 6E
00:951B 00
00:951C 2920657870656374	    24:   asciiz ") expected"                                ; 22
00:9524 6564
00:9526 00
00:9527 496C6C6567616C20	    25:   asciiz "Illegal factor"                            ; 23
00:952F 666163746F72
00:9535 00
00:9536 54797065206D6973	    26:   asciiz "Type mismatch"                             ; 24
00:953E 6D61746368
00:9543 00
00:9544 424547494E206578	    27:   asciiz "BEGIN expected"                            ; 25
00:954C 706563746564
00:9552 00
00:9553 4F46206578706563	    28:   asciiz "OF expected"                               ; 26
00:955B 746564
00:955E 00
00:955F 537461636B206675	    29:   asciiz "Stack full"                                ; 27
00:9567 6C6C
00:9569 00
00:956A 544F206F7220444F	    30:   asciiz "TO or DOWNTO expected"                     ; 28
00:9572 574E544F20657870
00:957A 6563746564
00:957F 00
00:9580 537472696E67206C	    31:   asciiz "String literal too big"                    ; 29
00:9588 69746572616C2074
00:9590 6F6F20626967
00:9596 00
00:9597 4E756D626572206F	    32:   asciiz "Number out of range"                       ; 30
00:959F 7574206F66207261
00:95A7 6E6765
00:95AA 00
00:95AB 2820657870656374	    33:   asciiz "( expected"                                ; 31
00:95B3 6564
00:95B5 00
00:95B6 2C20657870656374	    34:   asciiz ", expected"                                ; 32
00:95BE 6564
00:95C0 00
00:95C1 5B20657870656374	    35:   asciiz "[ expected"                                ; 33
00:95C9 6564
00:95CB 00
00:95CC 5D20657870656374	    36:   asciiz "] expected"                                ; 34
00:95D4 6564
00:95D6 00
00:95D7 506172616D657465	    37:   asciiz "Parameters mismatched"                     ; 35
00:95DF 7273206D69736D61
00:95E7 7463686564
00:95EC 00
00:95ED 4461746120747970	    38:   asciiz "Data type not recognised"                  ; 36
00:95F5 65206E6F74207265
00:95FD 636F676E69736564
00:9605 00
00:9606 53796D626F6C2074	    39:   asciiz "Symbol table full"                         ; 37
00:960E 61626C652066756C
00:9616 6C
00:9617 00
00:9618 4475706C69636174	    40:   asciiz "Duplicate identifier"                      ; 38
00:9620 65206964656E7469
00:9628 66696572
00:962C 00
00:962D 56616C7565206578	    41:   asciiz "Value expected"                            ; 39
00:9635 706563746564
00:963B 00
00:963C 496C6C6567616C20	    42:   asciiz "Illegal opcode"                            ; 40
00:9644 6F70636F6465
00:964A 00
00:964B 496C6C6567616C20	    43:   asciiz "Illegal addressing mode"                   ; 41
00:9653 6164647265737369
00:965B 6E67206D6F6465
00:9662 00
00:9663 4272616E6368206F	    44:   asciiz "Branch out of range"                       ; 42
00:966B 7574206F66207261
00:9673 6E6765
00:9676 00
00:9677 4E656564207A6572	    45:   asciiz "Need zero page address"                    ; 43
00:967F 6F20706167652061
00:9687 646472657373
00:968D 00
00:968E 4F706572616E6420	    46:   asciiz "Operand too large"                         ; 44
00:9696 746F6F206C617267
00:969E 65
00:969F 00
00:96A0 53796D626F6C2061	    47:   asciiz "Symbol address changed"                    ; 45
00:96A8 6464726573732063
00:96B0 68616E676564
00:96B6 00
00:96B7 4578707265737369	    48:   asciiz "Expression too complex"                    ; 46
00:96BF 6F6E20746F6F2063
00:96C7 6F6D706C6578
00:96CD 00
00:96CE 4469766964652062	    49:   asciiz "Divide by zero"                            ; 47
00:96D6 79207A65726F
00:96DC 00
00:96DD 4C6162656C207265	    50:   asciiz "Label required"                            ; 48
00:96E5 717569726564
00:96EB 00
00:96EC 53796D626F6C2074	    51:   asciiz "Symbol table in use"                       ; 49
00:96F4 61626C6520696E20
00:96FC 757365
00:96FF 00
00:9700 4E6F204C4344    	    52:   asciiz "No LCD"                                    ; 50
00:9706 00
00:9707 436F646520616C72	    53:   asciiz "Code already generated"                    ; 51
00:970F 656164792067656E
00:9717 657261746564
00:971D 00
                        	    54: assertion_failed_message:   ; used by Pascal assert function
00:971E 417373657274696F	    55:   asciiz "Assertion failed"                          ; 52
00:9726 6E206661696C6564
00:972E 00
00:972F 557365206F662066	    56:   asciiz "Use of function identifier in statement"   ; 53
00:9737 756E6374696F6E20
00:973F 6964656E74696669
00:9747 657220696E207374
00:974F 6174656D656E74
00:9756 00
00:9757 00              	    57:   dfb 0
                        	    58: 
                        	    59: ;***********************************************
                        	    60: ; DISPLAY ERROR - this does not return to the caller
                        	    61: ;  but to main_prompt
                        	    62: ;  Error number in X
                        	    63: ;***********************************************
00:9758 2A2A2A204572726F	    64: ERRLIT   asciiz  '*** Error: '
00:9760 723A20
00:9763 00
                        	    65: 
00:9764 8635            	    66: ERROR    stx  ERRNO
00:9766 A53F            	    67:          lda  RUNNING
00:9768 F003            	    68:          beq  ERR7
00:976A 4CA197          	    69:          jmp  ERR6
                        	    70: ERR7     =  *
00:976D A51D            	    71:          lda  LIST
00:976F D006            	    72:          bne  ERR1
00:9771 202892          	    73:          jsr  CROUT
00:9774 20F997          	    74:          jsr  show_current_line
                        	    75: ERR1     =  *
00:9777 A590            	    76:          lda  token_address
00:9779 38              	    77:          sec
00:977A E59C            	    78:          sbc  token_line_start  ; TODO: what about high-order byte?
00:977C 48              	    79:          pha             ; CHARS UP TO ERROR POINT
00:977D A958            	    80:          lda  #<ERRLIT   ; *** Error
00:977F A297            	    81:          ldx  #>ERRLIT
00:9781 202682          	    82:          jsr  print
00:9784 68              	    83:          pla
00:9785 18              	    84:          clc
00:9786 6901            	    85:          adc   #1
00:9788 8545            	    86:          sta  TEMP       ; BYTES TO ERROR POINT
00:978A AA              	    87:          tax
                        	    88: ERR3     =  *
00:978B 20B392          	    89:          jsr  PUTSP
00:978E CA              	    90:          dex
00:978F D0FA            	    91:          bne  ERR3
00:9791 A95E            	    92:          lda  #'^'
00:9793 20AF93          	    93:          jsr  COUT
00:9796 202892          	    94:          jsr  CROUT
00:9799 A209            	    95:          ldx  #9
                        	    96: ERR5     =  *
00:979B 20B392          	    97:          jsr  PUTSP
00:979E CA              	    98:          dex
00:979F D0FA            	    99:          bne  ERR5
                        	   100: ERR6     =  *
00:97A1 A9BC            	   101:   lda #<errors_table
00:97A3 8500            	   102:   sta REG
00:97A5 A993            	   103:   lda #>errors_table
00:97A7 8501            	   104:   sta REG+1
00:97A9 A200            	   105:   ldx #0
00:97AB A000            	   106:   ldy #0
                        	   107: error_next:
00:97AD E8              	   108:   inx
                        	   109: error_loop:
00:97AE E435            	   110:   cpx ERRNO
00:97B0 F02A            	   111:   beq error_found
                        	   112: error_find_next:
00:97B2 B100            	   113:   lda (REG),Y
00:97B4 48              	   114:   pha
00:97B5 E600            	   115:   inc REG
00:97B7 D002            	   116:   bne error1
00:97B9 E601            	   117:   inc REG+1
                        	   118: error1:
00:97BB 68              	   119:   pla           ; get the previous byte
00:97BC D0F4            	   120:   bne error_find_next
00:97BE B100            	   121:   lda (REG),Y   ; a null after a null?
00:97C0 F002            	   122:   beq error_not_found
00:97C2 80E9            	   123:   bra error_next  ; we got a null, so add 1 to our current error number (X)
                        	   124: 
                        	   125: error_not_found:
00:97C4 A9E9            	   126:   lda #<error_not_found_message
00:97C6 A297            	   127:   ldx #>error_not_found_message
00:97C8 202682          	   128:   jsr print
00:97CB A535            	   129:   lda ERRNO
00:97CD 8500            	   130:   sta REG
00:97CF 6401            	   131:   stz REG+1
00:97D1 6402            	   132:   stz REGB
00:97D3 205291          	   133:   jsr display_in_decimal
00:97D6 202892          	   134:   jsr CROUT
00:97D9 4CCC82          	   135:   jmp main_prompt
                        	   136: 
                        	   137: error_found:
00:97DC A500            	   138:   lda REG
00:97DE A601            	   139:   ldx REG+1
00:97E0 202682          	   140:   jsr print
00:97E3 202892          	   141:   jsr CROUT
00:97E6 4CCC82          	   142:   jmp  main_prompt
                        	   143: 
00:97E9 556E6B6E6F776E20	   144: error_not_found_message asciiz "Unknown error: "
00:97F1 6572726F723A20
00:97F8 00
                        	   145: 
                        	   146: show_current_line:
00:97F9 A928            	   147:   lda #'('
00:97FB 20AF93          	   148:   jsr COUT
00:97FE A524            	   149:   lda PCODE+1
00:9800 209D92          	   150:   jsr PRBYTE
00:9803 A523            	   151:   lda PCODE
00:9805 209D92          	   152:   jsr PRBYTE
00:9808 A929            	   153:   lda #')'
00:980A 20AF93          	   154:   jsr COUT
00:980D 20B392          	   155:   jsr PUTSP
00:9810 201E8C          	   156:   jsr show_current_line_number
00:9813 A59C            	   157:   lda token_line_start
00:9815 85A6            	   158:   sta mem_move_src
00:9817 A59D            	   159:   lda token_line_start+1
00:9819 85A7            	   160:   sta mem_move_src+1
                        	   161: 
                        	   162: show_current_line_loop:
00:981B A000            	   163:   ldy #0
00:981D B1A6            	   164:   lda (mem_move_src),Y
00:981F F01D            	   165:   beq show_current_line_done
00:9821 C90A            	   166:   cmp #NL
00:9823 F019            	   167:   beq show_current_line_done
00:9825 C920            	   168:   cmp #$20
00:9827 B00A            	   169:   bcs show_current_line_loop_print_one_character
00:9829 48              	   170:   pha
00:982A A95E            	   171:   lda #'^'
00:982C 20AF93          	   172:   jsr COUT
00:982F 68              	   173:   pla
00:9830 18              	   174:   clc
00:9831 6940            	   175:   adc #$40  ; make 0x01 print as ^A
                        	   176: show_current_line_loop_print_one_character:
00:9833 20AF93          	   177:   jsr COUT    ; show that byte
00:9836 E6A6            	   178:   inc mem_move_src
00:9838 D0E1            	   179:   bne show_current_line_loop
00:983A E6A7            	   180:   inc mem_move_src+1
00:983C 80DD            	   181:   bra show_current_line_loop
                        	   182: 
                        	   183: show_current_line_done:
00:983E 202892          	   184:   jsr CROUT
00:9841 60              	   185:   rts
                        	   186: 

Source: "gpascal.asm"
                        	   177:   .include "assembler.inc"

Source: "assembler.inc"
                        	     1: ;***********************************************
                        	     2: ;
                        	     3: ; Assembler
                        	     4: ;
                        	     5: ;***********************************************
                        	     6: 
                        	     7: ;***********************************************
                        	     8: ; Assembler operand types
                        	     9: ;***********************************************
                        	    10: 
                        	    11: ASS_OPERAND_ABSOLUTE                           =  1      ; a
                        	    12: ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT          =  2      ; (a,x)
                        	    13: ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X            =  3      ; a,x
                        	    14: ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y            =  4      ; a,y
                        	    15: ASS_OPERAND_ABSOLUTE_INDIRECT                  =  5      ; (a)
                        	    16: ASS_OPERAND_ACCUMULATOR_A                      =  6      ; A
                        	    17: ASS_OPERAND_IMMEDIATE                          =  7      ; #
                        	    18: ASS_OPERAND_IMPLIED                            =  8      ; i
                        	    19: ASS_OPERAND_PROGRAM_COUNTER_RELATIVE           =  9      ; r
                        	    20: ASS_OPERAND_STACK                              = 10      ; s
                        	    21: ASS_OPERAND_ZERO_PAGE                          = 11      ; zp
                        	    22: ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT         = 12      ; (zp,x)
                        	    23: ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X           = 13      ; zp,x
                        	    24: ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y           = 14      ; zp,y
                        	    25: ASS_OPERAND_ZERO_PAGE_INDIRECT                 = 15      ; (zp)
                        	    26: ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y  = 16      ; (zp),y
                        	    27: ASS_OPERAND_STRING                             = 17      ; "But does it get goat's blood out?"
                        	    28: ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE             = 18      ; zp,r
                        	    29: 
                        	    30: ;
                        	    31: ;  Entry point for assembler
                        	    32: ;
                        	    33: ASSEMBLE:
                        	    34: 
00:9842 A2FF            	    35:    ldx  #NEW_STK
00:9844 9A              	    36:    txs    ; set stack back to 0xFF
00:9845 6476            	    37:    stz  ASS_PASS  ; first pass
00:9847 20DA91          	    38:    jsr  INIT       ; sets up pointers, calls LINE
00:984A 20F8A9          	    39:    jsr  add_assembler_library_functions  ; add our inbuilt functions to the symbol table
00:984D 8005            	    40:    bra  ASSEMBLE_PASS
                        	    41: 
                        	    42: ASSEMBLE_SECOND_PASS:
00:984F E676            	    43:    inc  ASS_PASS
00:9851 20E691          	    44:    jsr  INIT_SECOND_PASS    ; don't re-initialise the symbol table
                        	    45: ASSEMBLE_PASS:
00:9854 64A2            	    46:    stz  current_line  ; we'll got for zero, not one
                        	    47: 
00:9856 A902            	    48:    lda  #FLAG_ASSEMBLING
00:9858 04BE            	    49:    tsb  system_flags
                        	    50: 
                        	    51: ;
                        	    52: ;  no listing yet
                        	    53: ;
00:985A 642E            	    54:    stz  DCODE
00:985C 641D            	    55:    stz  LIST
00:985E 6442            	    56:    stz  SYNTAX
00:9860 6482            	    57:    stz  show_symbols
                        	    58: ;
                        	    59: ; zero line count
                        	    60: ;
00:9862 6419            	    61:    stz  LINE_CNT
00:9864 641A            	    62:    stz  LINE_CNT+1
                        	    63: 
                        	    64: ;
                        	    65: ;  and emitted bytes count
                        	    66: ;
00:9866 6477            	    67:    stz ass_emit_bytes
00:9868 6478            	    68:    stz ass_emit_bytes+1
                        	    69: 
                        	    70: ;
                        	    71: ; no previous token
                        	    72: ;
00:986A 6493            	    73:    stz  token_type
00:986C 800E            	    74:    bra ass_line
                        	    75: 
                        	    76: ass_finish_line:
00:986E A593            	    77:    lda token_type
00:9870 C90A            	    78:    cmp #NL
00:9872 F008            	    79:    beq ass_line
00:9874 A213            	    80:    ldx #19    ; Incorrect Symbol
00:9876 4CB49E          	    81:    jmp ass_error
                        	    82: 
                        	    83: ass_done_jump:
00:9879 4C839B          	    84:    jmp ass_done
                        	    85: ;
                        	    86: ;  here for the start of a line
                        	    87: ;
                        	    88: ass_line:
00:987C A576            	    89:   lda ASS_PASS    ; only showing codes on 2nd pass
00:987E F00B            	    90:   beq ass_line1
00:9880 A56F            	    91:   lda ASS_EMIT_COUNT  ; only need a newline if we actually output a code
00:9882 F007            	    92:   beq ass_line1
00:9884 A52E            	    93:   lda DCODE           ; is showing codes on?
00:9886 F003            	    94:   beq ass_line1
00:9888 202892          	    95:   jsr CROUT
                        	    96: ass_line1:
00:988B A000            	    97:   ldy #0
00:988D B18E            	    98:   lda (token_start),y ; quick test so we don't list a non-existent line
00:988F F0E8            	    99:   beq ass_done_jump
                        	   100: 
00:9891 A58E            	   101:   lda token_start
00:9893 859C            	   102:   sta token_line_start
00:9895 A58F            	   103:   lda token_start+1
00:9897 859D            	   104:   sta token_line_start+1
00:9899 2092C9          	   105:   jsr token_line        ; list the next line
                        	   106: 
00:989C 646B            	   107:   stz ASS_OPERAND   ; no operand yet
00:989E 646F            	   108:   stz ASS_EMIT_COUNT
00:98A0 6483            	   109:   stz ass_current_label
00:98A2 6484            	   110:   stz ass_current_label+1
                        	   111: 
00:98A4 20F2C8          	   112:   jsr get_token
                        	   113: 
00:98A7 C949            	   114:   cmp #TOKEN_IDENTIFIER  ; could be a label if in column 1
00:98A9 F015            	   115:   beq ass_identifier
00:98AB C93D            	   116:   cmp #'='               ; = directive is OK
00:98AD F011            	   117:   beq ass_identifier
                        	   118: 
00:98AF C93B            	   119:   cmp #';'
00:98B1 F0BB            	   120:   beq ass_finish_line
                        	   121: 
00:98B3 C90A            	   122:   cmp #NL
00:98B5 F0C5            	   123:   beq ass_line
                        	   124: 
00:98B7 C900            	   125:   cmp #0
00:98B9 F0BE            	   126:   beq ass_done_jump
                        	   127: 
                        	   128: ass_bad_identifier:
00:98BB A204            	   129:   ldx #4      ; Identifier expected
00:98BD 4CB49E          	   130:   JMP ass_error
                        	   131: 
                        	   132: ass_identifier:
                        	   133: 
                        	   134: ;
                        	   135: ;  if the identifier is at the start of the line, it is a label, not an opcode
                        	   136: ;
00:98C0 A590            	   137:   lda token_address
00:98C2 C59C            	   138:   cmp token_line_start
00:98C4 D067            	   139:   bne ass_opcode
00:98C6 A591            	   140:   lda token_address+1
00:98C8 C59D            	   141:   cmp token_line_start+1
00:98CA D061            	   142:   bne ass_opcode
                        	   143: 
00:98CC A593            	   144:   lda token_type         ; can't have = as an identifier
00:98CE C93D            	   145:   cmp #'='               ; or "="
00:98D0 F0E9            	   146:   beq ass_bad_identifier
                        	   147: 
                        	   148: ;
                        	   149: ;  here for label - on the first pass, add it to the symbol table, on the second pass look it up
                        	   150: ;
00:98D2 A576            	   151:   lda ASS_PASS
00:98D4 D014            	   152:   bne ass_lookup_existing_label
                        	   153: ;
                        	   154: ;  here for first pass
                        	   155: ;
00:98D6 209DB9          	   156:   jsr CHKDUP
                        	   157: ;
                        	   158: ; not a duplicate - add it
                        	   159: ;
00:98D9 A523            	   160:   lda PCODE
00:98DB 8594            	   161:   sta token_value
00:98DD A524            	   162:   lda PCODE+1
00:98DF 8595            	   163:   sta token_value+1
00:98E1 6496            	   164:   stz token_value+2
00:98E3 A943            	   165:   lda #SYMBOL_CONSTANT
00:98E5 20F6B8          	   166:   jsr ADDSYM
00:98E8 8016            	   167:   bra ass_added_symbol
                        	   168: 
                        	   169: ;
                        	   170: ;  here for second pass
                        	   171: ;
                        	   172: ass_lookup_existing_label:
00:98EA 207AB8          	   173:   jsr SEARCH  ; look it up
00:98ED D005            	   174:   bne ass_lookup_save_address  ; it should be!
00:98EF A206            	   175:   ldx #6  ; ERROR: bug
00:98F1 4CB49E          	   176:   jmp ass_error
                        	   177: 
                        	   178: ass_lookup_save_address:
00:98F4 A594            	   179:   lda token_value
00:98F6 8573            	   180:   sta ASS_VALUE
00:98F8 A595            	   181:   lda token_value+1
00:98FA 8574            	   182:   sta ASS_VALUE+1
00:98FC A596            	   183:   lda token_value+2
00:98FE 8575            	   184:   sta ASS_VALUE+2
                        	   185: 
                        	   186: ;
                        	   187: ;  the symbol has either been added, or looked up to make sure it is still there
                        	   188: ;
                        	   189: ass_added_symbol:
                        	   190: 
                        	   191: ;
                        	   192: ;  remember its address in case we have an EQU directive
                        	   193: ;
00:9900 A540            	   194:   lda SYMITM
00:9902 8583            	   195:   sta ass_current_label
00:9904 A541            	   196:   lda SYMITM+1
00:9906 8584            	   197:   sta ass_current_label+1
                        	   198: 
                        	   199: ;
                        	   200: ;  get whatever is after the label
                        	   201: ;
00:9908 20F2C8          	   202:   jsr get_token
00:990B C93A            	   203:   cmp #':'
00:990D D003            	   204:   bne ass_not_colon
00:990F 20F2C8          	   205:   jsr get_token  ; skip the colon
                        	   206: ass_not_colon:
00:9912 C90A            	   207:   cmp #NL     ; newline means this is just a label line
00:9914 F004            	   208:   beq ass_finish_lineJ2
00:9916 C93B            	   209:   cmp #';'    ; ditto for comment
00:9918 D003            	   210:   bne ass_not_colon2
00:991A 4C6E98          	   211: ass_finish_lineJ2  jmp ass_finish_line
                        	   212: ass_not_colon2:
00:991D C949            	   213:   cmp #TOKEN_IDENTIFIER  ; should be an opcode now
00:991F F00C            	   214:   beq ass_opcode
00:9921 C93D            	   215:   cmp #'='               ; = directive is OK
00:9923 F008            	   216:   beq ass_opcode
                        	   217: 
                        	   218: ass_illegal_opcode:
00:9925 209D92          	   219:   jsr PRBYTE
00:9928 A228            	   220:   ldx #40      ; ERROR: illegal opcode
00:992A 4CB49E          	   221:   JMP ass_error
                        	   222: 
                        	   223: ass_opcode:
                        	   224: 
                        	   225: ;
                        	   226: ;  this will be our assembler mnemonic or directive so save its start point and length
                        	   227: ;
                        	   228: 
00:992D A690            	   229:   ldx token_address
00:992F 866C            	   230:   stx OPCODE
00:9931 A691            	   231:   ldx token_address+1
00:9933 866D            	   232:   stx OPCODE+1
00:9935 A692            	   233:   ldx token_length
00:9937 866E            	   234:   stx OPCODE_LEN
                        	   235: 
                        	   236: ;
                        	   237: ;  if we had a label on the line, check its address hasn't changed (on the second pass)
                        	   238: ;   UNLESS it is an EQU directive in which case it probably did change
                        	   239: ;
00:9939 A576            	   240:   lda ASS_PASS
00:993B F046            	   241:   beq ass_opcode2
00:993D A583            	   242:   lda ass_current_label
00:993F 0584            	   243:   ora ass_current_label+1   ; was there a label?
00:9941 F040            	   244:   beq ass_opcode2    ; nope
00:9943 A593            	   245:   lda token_type
00:9945 C93D            	   246:   cmp #'='
00:9947 F03A            	   247:   beq ass_opcode2   ; don't check on "=" directive
00:9949 A592            	   248:   lda token_length
00:994B C903            	   249:   cmp #3
00:994D D034            	   250:   bne ass_opcode2   ; can't be EQU
                        	   251: ;
                        	   252: ; this is truly crap, but I am feeling lazy
                        	   253: ;
00:994F A000            	   254:   ldy #0
00:9951 B190            	   255:   lda (token_address),y
00:9953 20C48F          	   256:   jsr MAKE_UPPER
00:9956 C945            	   257:   cmp #'E'
00:9958 D014            	   258:   bne ass_check_label_changed
00:995A C8              	   259:   iny
00:995B B190            	   260:   lda (token_address),y
00:995D 20C48F          	   261:   jsr MAKE_UPPER
00:9960 C951            	   262:   cmp #'Q'
00:9962 D00A            	   263:   bne ass_check_label_changed
00:9964 C8              	   264:   iny
00:9965 B190            	   265:   lda (token_address),y
00:9967 20C48F          	   266:   jsr MAKE_UPPER
00:996A C955            	   267:   cmp #'U'
00:996C F015            	   268:   beq ass_opcode2
                        	   269: 
                        	   270: ;
                        	   271: ;  we looked up the label earlier, when it was the current token,
                        	   272: ;   and we saved its value in ASS_VALUE
                        	   273: ;
                        	   274: 
                        	   275: ass_check_label_changed:
00:996E A523            	   276:   lda PCODE
00:9970 C573            	   277:   cmp ASS_VALUE
00:9972 D00A            	   278:   bne ass_symbol_address_changed
00:9974 A524            	   279:   lda PCODE+1
00:9976 C574            	   280:   cmp ASS_VALUE+1
00:9978 D004            	   281:   bne ass_symbol_address_changed
00:997A A575            	   282:   lda ASS_VALUE+2   ; 3rd byte should be zero
00:997C F005            	   283:   beq ass_opcode2
                        	   284: 
                        	   285: ass_symbol_address_changed:
00:997E A22D            	   286:   ldx #45     ; ERROR: Symbol address changed
00:9980 4CB49E          	   287:   jmp ass_error
                        	   288: 
                        	   289: 
                        	   290: 
                        	   291: ass_opcode2:
                        	   292: ;
                        	   293: ;  look up operand
                        	   294: ;
                        	   295: 
00:9983 20F2C8          	   296:   jsr get_token
00:9986 C93B            	   297:   cmp #';'          ; hit a comment?
00:9988 F004            	   298:   beq ass_no_operand
00:998A C90A            	   299:   cmp #NL           ; or end of line?
00:998C D00D            	   300:   bne ass_operand
                        	   301: 
                        	   302: ;
                        	   303: ;  here when the opcode is followed by (spaces), a comment or a newline
                        	   304: ;
                        	   305: ass_no_operand:
00:998E A908            	   306:   lda #ASS_OPERAND_IMPLIED
00:9990 856B            	   307:   sta ASS_OPERAND
00:9992 20DA9A          	   308:   jsr opcode_lookup
00:9995 20C69B          	   309:   jsr ass_check_no_more_tokens
                        	   310: ass_finish_lineJ:
00:9998 4C6E98          	   311:   jmp ass_finish_line
                        	   312: 
                        	   313: ass_operand:
00:999B C923            	   314:   cmp #'#'  ; immediate?
00:999D F01B            	   315:   beq ass_immediate
00:999F C928            	   316:   cmp #'('  ; indirect?
00:99A1 F02A            	   317:   beq ass_indirect
00:99A3 C949            	   318:   cmp #TOKEN_IDENTIFIER
00:99A5 F02F            	   319:   beq ass_identifier_operand
00:99A7 C922            	   320:   cmp #TOKEN_STRING
00:99A9 F002            	   321:   beq ass_string
                        	   322: ;
                        	   323: ;  here for some kind of numeric address
                        	   324: ;
00:99AB 804A            	   325:   bra ass_operand_value
                        	   326: 
                        	   327: ;
                        	   328: ;  Here for a string as an operand, should be a compiler directive, eg.  ASC "Hello, world"
                        	   329: ;
                        	   330: ass_string:
00:99AD A911            	   331:   lda #ASS_OPERAND_STRING
00:99AF 856B            	   332:   sta ASS_OPERAND
00:99B1 20DA9A          	   333:   jsr opcode_lookup
00:99B4 20F2C8          	   334:   jsr get_token  ; NOW get the next token
00:99B7 4C6E98          	   335:   jmp ass_finish_line
                        	   336: 
                        	   337: ;
                        	   338: ;  immediate, that is:  #<expression>
                        	   339: ;
                        	   340: ass_immediate:
00:99BA A907            	   341:   lda #ASS_OPERAND_IMMEDIATE
00:99BC 856B            	   342:   sta ASS_OPERAND
00:99BE 20F2C8          	   343:   jsr get_token
00:99C1 20E19C          	   344:   jsr ass_get_value
00:99C4 20C69B          	   345:   jsr ass_check_no_more_tokens
00:99C7 20DA9A          	   346:   jsr opcode_lookup
00:99CA 4C6E98          	   347:   jmp ass_finish_line
                        	   348: 
                        	   349: ;
                        	   350: ;  indirect, that is: (expression) OR (expression,X) OR (expression),Y
                        	   351: ;
                        	   352: ass_indirect:
00:99CD A905            	   353:   lda #ASS_OPERAND_ABSOLUTE_INDIRECT  ; first guess
00:99CF 856B            	   354:   sta ASS_OPERAND
00:99D1 20F2C8          	   355:   jsr get_token    ; skip the bracket
00:99D4 8021            	   356:   bra ass_operand_value
                        	   357: 
                        	   358: ;
                        	   359: ;  some sort of identifier, possibly the start of an expression or maybe just "A"
                        	   360: ;
                        	   361: ass_identifier_operand:
                        	   362: 
                        	   363: ;
                        	   364: ;  see if the operand is just the letter "A"
                        	   365: ;
00:99D6 A592            	   366:   lda token_length
00:99D8 C901            	   367:   cmp #1
00:99DA D01B            	   368:   bne ass_operand_value
00:99DC A000            	   369:   ldy #0
00:99DE B190            	   370:   lda (token_address),Y
00:99E0 20C48F          	   371:   jsr MAKE_UPPER
00:99E3 C941            	   372:   cmp #'A'
00:99E5 D010            	   373:   bne ass_operand_value
00:99E7 A906            	   374:   lda #ASS_OPERAND_ACCUMULATOR_A
00:99E9 856B            	   375:   sta ASS_OPERAND
00:99EB 20F2C8          	   376:   jsr get_token  ; skip past A
00:99EE 20C69B          	   377:   jsr ass_check_no_more_tokens
00:99F1 20DA9A          	   378:   jsr opcode_lookup
00:99F4 4C6E98          	   379:   jmp ass_finish_line
                        	   380: 
                        	   381: ;
                        	   382: ;  a number or identifier - evaluate as an expression
                        	   383: ;
                        	   384: ass_operand_value:
                        	   385: 
00:99F7 A593            	   386:   lda token_type ; get token back
00:99F9 20E19C          	   387:   jsr ass_get_value  ; should have some sort of address now in VALUE
                        	   388: ;
                        	   389: ;  we come back with the first non-value token loaded in TOKEN
                        	   390: ;  now see if we originally had a bracket, so this must be one of those indirect things
                        	   391: ;
00:99FC A56B            	   392:   lda ASS_OPERAND
00:99FE C905            	   393:   cmp #ASS_OPERAND_ABSOLUTE_INDIRECT
00:9A00 D02D            	   394:   bne ass_value_not_indirectJ
00:9A02 A593            	   395:   lda token_type   ; now we should have a comma or a bracket
00:9A04 C929            	   396:   cmp #')'
00:9A06 F02F            	   397:   beq ass_indirect_with_bracket
                        	   398: ;
                        	   399: ;  We had an opening bracket but not a closing bracket. Must be a comma then
                        	   400: ;
                        	   401: 
00:9A08 A92C            	   402:   lda #','
00:9A0A A220            	   403:   ldx #32  ; ERROR: , expected
00:9A0C 2004CF          	   404:   jsr CHKTKN
                        	   405: ;
                        	   406: ;  now we must have X
                        	   407: ;
00:9A0F 20739A          	   408:   jsr ass_check_we_have_x_or_y
00:9A12 901E            	   409:   bcc ass_bad_indirect
00:9A14 C958            	   410:   cmp #'X'
00:9A16 D01A            	   411:   bne ass_bad_indirect
00:9A18 A902            	   412:   lda #ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
00:9A1A 856B            	   413:   sta ASS_OPERAND
00:9A1C A929            	   414:   lda #')'
00:9A1E A216            	   415:   ldx #22  ; ERROR: ) expected
00:9A20 20F4CE          	   416:   jsr GETCHK
00:9A23 20F2C8          	   417:   jsr get_token
00:9A26 20C69B          	   418:   jsr ass_check_no_more_tokens
00:9A29 20DA9A          	   419:   jsr opcode_lookup
00:9A2C 4C6E98          	   420:   jmp ass_finish_line
                        	   421: 
00:9A2F 4C919A          	   422: ass_value_not_indirectJ jmp ass_value_not_indirect
                        	   423: 
                        	   424: ass_bad_indirect:
00:9A32 A229            	   425:   ldx #41  ; ERROR: illegal addressing mode
00:9A34 4CB49E          	   426:   jmp ass_error
                        	   427: 
                        	   428: 
                        	   429: ;
                        	   430: ;  we have some sort of indirect expression followed by a bracket, so see if there is ",Y" after it
                        	   431: ;
                        	   432: ass_indirect_with_bracket:
                        	   433: ;
                        	   434: ;  can only be (a), (zp) or (zp),y
                        	   435: ;
00:9A37 20F2C8          	   436:   jsr get_token
00:9A3A C92C            	   437:   cmp #','
00:9A3C F00D            	   438:   beq ass_zp_indirect_indexed
00:9A3E 20C69B          	   439:   jsr ass_check_no_more_tokens
00:9A41 A905            	   440:   lda #ASS_OPERAND_ABSOLUTE_INDIRECT
00:9A43 856B            	   441:   sta ASS_OPERAND
00:9A45 20DA9A          	   442:   jsr opcode_lookup
00:9A48 4C6E98          	   443:   jmp ass_finish_line
                        	   444: 
                        	   445: 
                        	   446: ;
                        	   447: ;  For indirect followed by a comma, we must have Y and nothing else
                        	   448: ;  Also, the operand must be a zero-page address
                        	   449: ;
                        	   450: ass_zp_indirect_indexed:
00:9A4B 20739A          	   451:   jsr ass_check_we_have_x_or_y
00:9A4E 90E2            	   452:   bcc ass_bad_indirect
00:9A50 C959            	   453:   cmp #'Y'
00:9A52 D0DE            	   454:   bne ass_bad_indirect
00:9A54 A574            	   455:   lda ASS_VALUE+1
00:9A56 D014            	   456:   bne ass_bad_zp_indirect_indexed
00:9A58 A575            	   457:   lda ASS_VALUE+2
00:9A5A D010            	   458:   bne ass_bad_zp_indirect_indexed
00:9A5C A910            	   459:   lda #ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
00:9A5E 856B            	   460:   sta ASS_OPERAND
00:9A60 20F2C8          	   461:   jsr get_token  ; skip the Y
00:9A63 20C69B          	   462:   jsr ass_check_no_more_tokens
00:9A66 20DA9A          	   463:   jsr opcode_lookup
00:9A69 4C6E98          	   464:   jmp ass_finish_line
                        	   465: 
                        	   466: ass_bad_zp_indirect_indexed:
00:9A6C A22B            	   467:   ldx #43
00:9A6E 4CB49E          	   468:   jmp ass_error
                        	   469: 
                        	   470: ass_not_x_or_y:
00:9A71 18              	   471:   clc
00:9A72 60              	   472:   rts
                        	   473: 
                        	   474: ;
                        	   475: ;  we had (<expression>),<something> so check that <something> is X or Y
                        	   476: ;   sets carry if it is
                        	   477: ;
                        	   478: ass_check_we_have_x_or_y:
00:9A73 20F2C8          	   479:   jsr get_token
00:9A76 C949            	   480:   cmp #TOKEN_IDENTIFIER
00:9A78 D0F7            	   481:   bne ass_not_x_or_y
00:9A7A A592            	   482:   lda token_length
00:9A7C C901            	   483:   cmp #1
00:9A7E D0F1            	   484:   bne ass_not_x_or_y
00:9A80 A000            	   485:   ldy #0
00:9A82 B190            	   486:   lda (token_address),y
00:9A84 20C48F          	   487:   jsr MAKE_UPPER
00:9A87 C959            	   488:   cmp #'Y'
00:9A89 F004            	   489:   beq ass_check_we_have_x_or_y_ok
00:9A8B C958            	   490:   cmp #'X'
00:9A8D D0E2            	   491:   bne ass_not_x_or_y
                        	   492: ass_check_we_have_x_or_y_ok:
00:9A8F 38              	   493:   sec
00:9A90 60              	   494:   rts
                        	   495: 
                        	   496: ;
                        	   497: ;  we had a non-indirect expression, so was it followed by a comma?
                        	   498: ;
                        	   499: 
                        	   500: ass_value_not_indirect:
00:9A91 A593            	   501:   lda token_type
00:9A93 C92C            	   502:   cmp #','
00:9A95 F00D            	   503:   beq ass_indexed
00:9A97 A901            	   504:   lda #ASS_OPERAND_ABSOLUTE
00:9A99 856B            	   505:   sta ASS_OPERAND
                        	   506: ass_value_done:
00:9A9B 20C69B          	   507:   jsr ass_check_no_more_tokens
00:9A9E 20DA9A          	   508:   jsr opcode_lookup
00:9AA1 4C6E98          	   509:   jmp ass_finish_line
                        	   510: 
                        	   511: ;
                        	   512: ;  <expression>,X or <expression>,Y is what we are expecting here
                        	   513: ;
                        	   514: ;  OR: in the case of BBR0 ... BBR7 and BBS0 ... BBS7 : another expression
                        	   515: ;
                        	   516: 
                        	   517: ass_indexed:
                        	   518: ;
                        	   519: ;  save the value in case we find a second one
                        	   520: ;
                        	   521: ;  checking for another one may change VALUE so we do this now
                        	   522: ;
00:9AA4 A500            	   523:   lda VALUE
00:9AA6 8506            	   524:   sta REMAIN
00:9AA8 A501            	   525:   lda VALUE+1
00:9AAA 8507            	   526:   sta REMAIN+1
00:9AAC A502            	   527:   lda VALUE+2
00:9AAE 8508            	   528:   sta REMAIN+2
00:9AB0 20739A          	   529:   jsr ass_check_we_have_x_or_y
00:9AB3 9016            	   530:   bcc ass_absolute_another_value
00:9AB5 C958            	   531:   cmp #'X'
00:9AB7 F009            	   532:   beq ass_indexed_x
00:9AB9 A904            	   533:   lda #ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
00:9ABB 856B            	   534:   sta ASS_OPERAND
00:9ABD 20F2C8          	   535:   jsr get_token ; skip the Y
00:9AC0 80D9            	   536:   bra ass_value_done
                        	   537: ass_indexed_x:
00:9AC2 A903            	   538:   lda #ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
00:9AC4 856B            	   539:   sta ASS_OPERAND
00:9AC6 20F2C8          	   540:   jsr get_token ; skip the X
00:9AC9 80D0            	   541:   bra ass_value_done
                        	   542: 
                        	   543: ;
                        	   544: ;  this is hopefully something like BBR0 $42,foo
                        	   545: ;   so we need to evaluate foo
                        	   546: ;
                        	   547: ass_absolute_another_value:
00:9ACB A593            	   548:   lda token_type ; get token back
00:9ACD 20E19C          	   549:   jsr ass_get_value  ; should have some sort of address now in VALUE
                        	   550: ;  jsr ass_check_no_more_tokens
00:9AD0 A912            	   551:   lda #ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE
00:9AD2 856B            	   552:   sta ASS_OPERAND
00:9AD4 20DA9A          	   553:   jsr opcode_lookup
00:9AD7 4C6E98          	   554:   jmp ass_finish_line
                        	   555: 
                        	   556: 
                        	   557: ;
                        	   558: ;  look up opcode
                        	   559: ;
                        	   560: opcode_lookup:
                        	   561:   ; the opcode we are looking up
00:9ADA A56C            	   562:   lda OPCODE
00:9ADC 8500            	   563:   sta SRCE
00:9ADE A56D            	   564:   lda OPCODE+1
00:9AE0 8501            	   565:   sta SRCE+1
00:9AE2 6472            	   566:   stz ASS_COUNT   ; count of matches
                        	   567: ;
                        	   568: ;  get the address of our table of tables
                        	   569: ;
00:9AE4 A928            	   570:   lda #<OPCODE_LOOKUP_TABLE
00:9AE6 8570            	   571:   sta ASS_OPCODE_WORK
00:9AE8 A99F            	   572:   lda #>OPCODE_LOOKUP_TABLE
00:9AEA 8571            	   573:   sta ASS_OPCODE_WORK+1
                        	   574: opcode_lookup_loop:
00:9AEC A000            	   575:   ldy #OPCODE_LOOKUP_OPCODE_LENGTH
00:9AEE B170            	   576:   lda (ASS_OPCODE_WORK),Y       ; get opcode length
00:9AF0 F058            	   577:   beq opcode_lookup_loop_done   ; end of table
00:9AF2 C56E            	   578:   cmp OPCODE_LEN                ; right length?
00:9AF4 F00F            	   579:   beq opcode_lookup_correct_length ; yes
                        	   580: ;
                        	   581: ; no, try the next table item
                        	   582: ;
                        	   583: opcode_lookup_next_table:
00:9AF6 18              	   584:   clc
00:9AF7 A570            	   585:   lda ASS_OPCODE_WORK
00:9AF9 6906            	   586:   adc #OPCODE_LOOKUP_TABLE_SIZE  ; onto next item
00:9AFB 8570            	   587:   sta ASS_OPCODE_WORK
00:9AFD A571            	   588:   lda ASS_OPCODE_WORK+1
00:9AFF 6900            	   589:   adc #0
00:9B01 8571            	   590:   sta ASS_OPCODE_WORK+1
00:9B03 80E7            	   591:   bra opcode_lookup_loop
                        	   592: opcode_lookup_correct_length:
00:9B05 A002            	   593:   ldy #OPCODE_LOOKUP_OPCODE_TABLE
00:9B07 B170            	   594:   lda (ASS_OPCODE_WORK),Y ; get table address low-order byte
00:9B09 8503            	   595:   sta DEST
00:9B0B C8              	   596:   iny
00:9B0C B170            	   597:   lda (ASS_OPCODE_WORK),Y ; get table address high-order byte
00:9B0E 8504            	   598:   sta DEST+1
00:9B10 20529E          	   599:   jsr ass_lookup_loop
00:9B13 90E1            	   600:   bcc opcode_lookup_next_table  ; not found
00:9B15 AA              	   601:   tax   ; save the machine code byte
00:9B16 E672            	   602:   inc ASS_COUNT
00:9B18 A001            	   603:   ldy #OPCODE_LOOKUP_OPERAND_TYPE
00:9B1A A56B            	   604:   lda ASS_OPERAND         ; get wanted type of operand?
00:9B1C D170            	   605:   cmp (ASS_OPCODE_WORK),Y ; compare to operand type in table
00:9B1E F013            	   606:   beq opcode_lookup_correct_operand  ; yes
00:9B20 C906            	   607:   cmp #ASS_OPERAND_ACCUMULATOR_A  ; see if in range 1 to 5
00:9B22 B0D2            	   608:   bcs opcode_lookup_next_table
                        	   609: ;
                        	   610: ;  so if we have a so-called ASS_OPERAND_ABSOLUTE (with various indexing modes)
                        	   611: ;  see if we can match on ASS_OPERAND_ZERO_PAGE by adding 10 to the operand type
                        	   612: ;  - also applies to all the absolute modes (1 to 5)
                        	   613: ;
00:9B24 18              	   614:   clc
00:9B25 690A            	   615:   adc #10
00:9B27 D170            	   616:   cmp (ASS_OPCODE_WORK),Y
00:9B29 D0CB            	   617:   bne opcode_lookup_next_table
                        	   618: ;
                        	   619: ;  plus, the operand has to be in the zero page
                        	   620: ;
00:9B2B A574            	   621:   lda ASS_VALUE+1
00:9B2D D0C7            	   622:   bne opcode_lookup_next_table
00:9B2F A575            	   623:   lda ASS_VALUE+2
00:9B31 D0C3            	   624:   bne opcode_lookup_next_table
                        	   625: opcode_lookup_correct_operand:
00:9B33 8A              	   626:   txa   ; get the byte to emit back
                        	   627: 
                        	   628: ;
                        	   629: ; we have a match! emit the opcode
                        	   630: ;
00:9B34 20769E          	   631:   jsr ass_emit            ; emit it
00:9B37 A004            	   632:   ldy #OPCODE_LOOKUP_HANDLER  ; offset of handler
00:9B39 B170            	   633:   lda (ASS_OPCODE_WORK),Y ; get opcode handler address low-order byte
00:9B3B AA              	   634:   tax
00:9B3C C8              	   635:   iny
00:9B3D B170            	   636:   lda (ASS_OPCODE_WORK),Y ; get opcode handler address high-order byte
00:9B3F F008            	   637:   beq opcode_lookup_no_handler
00:9B41 8571            	   638:   sta ASS_OPCODE_WORK+1
00:9B43 8A              	   639:   txa
00:9B44 8570            	   640:   sta ASS_OPCODE_WORK
00:9B46 6C7000          	   641:   jmp (ASS_OPCODE_WORK)   ; do handler - it will RTS for us
                        	   642: 
                        	   643: opcode_lookup_no_handler:
                        	   644: ; put nothing here as it won't be done if there is a handler
00:9B49 60              	   645:   rts    ; done!
                        	   646: 
                        	   647: opcode_lookup_loop_done:
                        	   648: ;
                        	   649: ;  look for assembler directives
                        	   650: ;
00:9B4A A9CB            	   651:   lda #<DIRECTIVES
00:9B4C 8503            	   652:   sta DEST
00:9B4E A99F            	   653:   lda #>DIRECTIVES
00:9B50 8504            	   654:   sta DEST+1
00:9B52 A56E            	   655:   lda OPCODE_LEN
                        	   656: 
                        	   657: ;  pha
                        	   658: ;   lda #'c'
                        	   659: ;   jsr ass_debug_point
                        	   660: ;   pla
                        	   661: 
00:9B54 200A8F          	   662:   jsr handlerLookup
00:9B57 9029            	   663:   bcc opcode_lookup_ok
                        	   664: 
                        	   665: ;   lda #'d'
                        	   666: ;   jsr ass_debug_point
                        	   667: 
                        	   668: ;
                        	   669: ;  here for unknown opcode
                        	   670: ;
00:9B59 A56C            	   671:   lda OPCODE
00:9B5B 8590            	   672:   sta token_address
00:9B5D A56D            	   673:   lda OPCODE+1
00:9B5F 8591            	   674:   sta token_address+1
00:9B61 A56E            	   675:   lda OPCODE_LEN
00:9B63 8592            	   676:   sta token_length
                        	   677: 
                        	   678: ;
                        	   679: ;  if we NEVER found a match, this is an illegal opcode
                        	   680: ;
00:9B65 A921            	   681:   lda #'!'
00:9B67 20AF93          	   682:   jsr COUT
00:9B6A A66E            	   683:   ldx OPCODE_LEN
00:9B6C A000            	   684:   ldy #0
                        	   685: wtf_loop:
00:9B6E B16C            	   686:    lda (OPCODE),Y
00:9B70 20AF93          	   687:    jsr COUT
00:9B73 C8              	   688:    iny
00:9B74 CA              	   689:    dex
00:9B75 D0F7            	   690:    bne wtf_loop
                        	   691: 
                        	   692: 
00:9B77 A228            	   693:   ldx  #40    ; illegal opcode
00:9B79 A572            	   694:   lda ASS_COUNT
00:9B7B F002            	   695:   beq opcode_lookup_loop_unknown
                        	   696: ;
                        	   697: ;  if we found a match, but not for this addressing mode, they used an illegal mode
                        	   698: ;
00:9B7D A229            	   699:   ldx  #41   ; illegal addressing mode
                        	   700: opcode_lookup_loop_unknown:
00:9B7F 4CB49E          	   701:   JMP  ass_error
                        	   702: 
                        	   703: opcode_lookup_ok:
                        	   704: 
                        	   705: ;   lda #'e'
                        	   706: ; jsr ass_debug_point
                        	   707: 
00:9B82 60              	   708:   rts
                        	   709: 
                        	   710: ass_done:
00:9B83 202892          	   711:   jsr  CROUT
00:9B86 A576            	   712:   LDA  ASS_PASS
00:9B88 D003            	   713:   bne  ass_done_second_pass
00:9B8A 4C4F98          	   714:   jmp  ASSEMBLE_SECOND_PASS
                        	   715: ass_done_second_pass:
00:9B8D A9A8            	   716:   LDA  #<ass_done_message  ; Assemble finished: No Errors
00:9B8F A29B            	   717:   LDX  #>ass_done_message
00:9B91 202682          	   718:   JSR  print
00:9B94 A910            	   719:   lda  #FLAG_VALID_ASSEMBLE
00:9B96 04BE            	   720:   tsb  system_flags
00:9B98 20A88E          	   721:   jsr  show_symbol_table_end
00:9B9B 20CD8E          	   722:   jsr  show_source_end
00:9B9E A582            	   723:   lda  show_symbols
00:9BA0 F003            	   724:   beq  ass_done1
00:9BA2 206FA5          	   725:   jsr  list_symbols
                        	   726: ass_done1:
00:9BA5 4CCC82          	   727:   JMP  main_prompt
                        	   728: 
00:9BA8 417373656D626C65	   729: ass_done_message asciiz "Assemble finished: No errors\n"
00:9BB0 2066696E69736865
00:9BB8 643A204E6F206572
00:9BC0 726F72730A
00:9BC5 00
                        	   730: 
                        	   731: ass_check_no_more_tokens:
00:9BC6 A593            	   732:   lda token_type
00:9BC8 C93B            	   733:   cmp #';'          ; hit a comment?
00:9BCA F009            	   734:   beq ass_check_no_more_tokens_ok
00:9BCC C90A            	   735:   cmp #NL           ; or end of line?
00:9BCE F005            	   736:   beq ass_check_no_more_tokens_ok
00:9BD0 A213            	   737:   ldx #19    ; ERROR: incorrect symbol
00:9BD2 4CB49E          	   738:   jmp ass_error
                        	   739: 
                        	   740: ass_check_no_more_tokens_ok:
00:9BD5 60              	   741:   rts
                        	   742: 
                        	   743: ;
                        	   744: ;  push a 3-byte value (in VALUE) onto the evaluation stack
                        	   745: ;    changes A and Y
                        	   746: ;
                        	   747: exp_push_value = *
00:9BD6 A57B            	   748:   lda exp_value_stack_count
00:9BD8 C9FF            	   749:   cmp #$FF
00:9BDA D005            	   750:   bne exp_push_value_ok
                        	   751: exp_push_value_memory_full:
00:9BDC A22E            	   752:   ldx #46   ; ERROR: Expression too complex
00:9BDE 4CB49E          	   753:   jmp ass_error
                        	   754: exp_push_value_ok:
00:9BE1 E67B            	   755:   inc exp_value_stack_count
00:9BE3 38              	   756:   sec
00:9BE4 A579            	   757:   lda exp_value_stack
00:9BE6 E903            	   758:   sbc #3
00:9BE8 8579            	   759:   sta exp_value_stack
00:9BEA A57A            	   760:   lda exp_value_stack+1
00:9BEC E900            	   761:   sbc #0
00:9BEE 857A            	   762:   sta exp_value_stack+1
                        	   763: ;
                        	   764: ;  has our expression value fallen down into our P-codes?
                        	   765: ;
                        	   766: ;  This doesn't work if the output (PCODE) has been relocated to above
                        	   767: ;  the symbol table and I can't think of an easy solution, so let's ignore
                        	   768: ;  it and hope it doesn't happen.
                        	   769: ;
                        	   770: ;
                        	   771: ; lda  PCODE+1               ; see if P-codes full
                        	   772: ; cmp  exp_value_stack+1     ; in other words, have we hit the symbol table?
                        	   773: ; bcc  exp_push_value_not_full      ; less than
                        	   774: ; bne  exp_push_value_memory_full   ; greater than
                        	   775: ; lda  PCODE
                        	   776: ; cmp  exp_value_stack
                        	   777: ; bcs  exp_push_value_memory_full   ; BGE
                        	   778: 
                        	   779: exp_push_value_not_full:
00:9BF0 A000            	   780:   ldy #0
00:9BF2 A500            	   781:   lda VALUE
00:9BF4 9179            	   782:   sta (exp_value_stack),y
00:9BF6 C8              	   783:   iny
00:9BF7 A501            	   784:   lda VALUE+1
00:9BF9 9179            	   785:   sta (exp_value_stack),y
00:9BFB C8              	   786:   iny
00:9BFC A502            	   787:   lda VALUE+2
00:9BFE 9179            	   788:   sta (exp_value_stack),y
00:9C00 60              	   789:   rts
                        	   790: 
                        	   791: ;
                        	   792: ;  pop a 3-byte value (into VALUE) from the evaluation stack
                        	   793: ;    changes A and Y
                        	   794: ;
                        	   795: exp_pop_value = *
00:9C01 A57B            	   796:   lda exp_value_stack_count
00:9C03 D005            	   797:   bne exp_pop_value_ok
00:9C05 A217            	   798:   ldx #23    ; ERROR: illegal factor
00:9C07 4CB49E          	   799:   jmp ass_error
                        	   800: exp_pop_value_ok:
00:9C0A C67B            	   801:   dec exp_value_stack_count
00:9C0C A000            	   802:   ldy #0
00:9C0E B179            	   803:   lda (exp_value_stack),y
00:9C10 8500            	   804:   sta VALUE
00:9C12 C8              	   805:   iny
00:9C13 B179            	   806:   lda (exp_value_stack),y
00:9C15 8501            	   807:   sta VALUE+1
00:9C17 C8              	   808:   iny
00:9C18 B179            	   809:   lda (exp_value_stack),y
00:9C1A 8502            	   810:   sta VALUE+2
00:9C1C 18              	   811:   clc
00:9C1D A579            	   812:   lda exp_value_stack
00:9C1F 6903            	   813:   adc #3
00:9C21 8579            	   814:   sta exp_value_stack
00:9C23 A57A            	   815:   lda exp_value_stack+1
00:9C25 6900            	   816:   adc #0
00:9C27 857A            	   817:   sta exp_value_stack+1
00:9C29 60              	   818:   rts
                        	   819: 
                        	   820: ;
                        	   821: ;  I needed a work area for operators, and initially used INBUF however that got
                        	   822: ;  repurposed for managing strings (in particular handling \Xnn and double quotes)
                        	   823: ;  so now I am using the memory at the current PCODE address as a work area.
                        	   824: ;  It is only needed during expression evaluation, and should hopefully be available.
                        	   825: ;
                        	   826: ;
                        	   827: ;  push an operator (A) onto the operator stack
                        	   828: ;   changes X and Y
                        	   829: ;
                        	   830: exp_push_operator:
00:9C2A A67C            	   831:   ldx exp_operator_stack_count
00:9C2C E0FA            	   832:   cpx #250  ; make sure we don't overflow our operator stack
00:9C2E 9005            	   833:   bcc exp_push_operator_ok
00:9C30 A22E            	   834:   ldx #46   ; ERROR: Expression too complex
00:9C32 4CB49E          	   835:   jmp ass_error
                        	   836: exp_push_operator_ok:
00:9C35 E67C            	   837:   inc exp_operator_stack_count  ; add, then store
00:9C37 A47C            	   838:   ldy exp_operator_stack_count
00:9C39 9123            	   839:   sta (PCODE),Y
00:9C3B 60              	   840:   rts
                        	   841: 
                        	   842: ;
                        	   843: ;  pop an operator (into A) from the operator stack
                        	   844: ;   changes X and Y
                        	   845: ;
                        	   846: exp_pop_operator:
00:9C3C A67C            	   847:   ldx exp_operator_stack_count
00:9C3E D005            	   848:   bne exp_pop_operator_ok
00:9C40 A217            	   849:   ldx #23   ; ERROR: Illegal factor
00:9C42 4CB49E          	   850:   jmp ass_error
                        	   851: exp_pop_operator_ok:
00:9C45 A47C            	   852:   ldy exp_operator_stack_count  ; retrieve, then decrement
00:9C47 B123            	   853:   lda (PCODE),Y
00:9C49 C67C            	   854:   dec exp_operator_stack_count
00:9C4B 60              	   855:   rts
                        	   856: 
                        	   857: ;
                        	   858: ;  get an operator (into A) from the operator stack (without removing it)
                        	   859: ;   changes X and Y
                        	   860: ;
                        	   861: exp_get_operator:
00:9C4C A67C            	   862:   ldx exp_operator_stack_count
00:9C4E D005            	   863:   bne exp_get_operator_ok
00:9C50 A217            	   864:   ldx #23   ; ERROR: Illegal factor
00:9C52 4CB49E          	   865:   jmp ass_error
                        	   866: exp_get_operator_ok:
00:9C55 A47C            	   867:   ldy exp_operator_stack_count
00:9C57 B123            	   868:   lda (PCODE),Y
00:9C59 60              	   869:   rts
                        	   870: 
                        	   871:  .macro makePrecedenceTable ; table of operators, precedence, handler
                        	   872:    dfb   \1
                        	   873:    dfb   \2
                        	   874:    word  \3
                        	   875:  .endmacro
                        	   876: 
                        	   877: ; cannot have more than 64 entries because we index into this with X
                        	   878: exp_precedence_table:
                        	   879:   makePrecedenceTable '~', 1, exp_negate
00:9C5A 7E              	     1M    dfb   '~'
00:9C5B 01              	     2M    dfb   1
00:9C5C 69AB            	     3M    word  exp_negate
                        	   880:   makePrecedenceTable '!', 1, exp_not
00:9C5E 21              	     1M    dfb   '!'
00:9C5F 01              	     2M    dfb   1
00:9C60 7CAB            	     3M    word  exp_not
                        	   881:   makePrecedenceTable TOKEN_UNARY_MINUS, 1, exp_unary_minus
00:9C62 4D              	     1M    dfb   TOKEN_UNARY_MINUS
00:9C63 01              	     2M    dfb   1
00:9C64 8AAB            	     3M    word  exp_unary_minus
                        	   882:   makePrecedenceTable TOKEN_LOW_BYTE, 1, exp_low_byte
00:9C66 56              	     1M    dfb   TOKEN_LOW_BYTE
00:9C67 01              	     2M    dfb   1
00:9C68 9EAB            	     3M    word  exp_low_byte
                        	   883:   makePrecedenceTable TOKEN_HIGH_BYTE, 1, exp_high_byte
00:9C6A 57              	     1M    dfb   TOKEN_HIGH_BYTE
00:9C6B 01              	     2M    dfb   1
00:9C6C A3AB            	     3M    word  exp_high_byte
                        	   884:   makePrecedenceTable TOKEN_SHIFT_LEFT, 2, exp_shift_left
00:9C6E 4C              	     1M    dfb   TOKEN_SHIFT_LEFT
00:9C6F 02              	     2M    dfb   2
00:9C70 37AB            	     3M    word  exp_shift_left
                        	   885:   makePrecedenceTable TOKEN_SHIFT_RIGHT, 2, exp_shift_right
00:9C72 52              	     1M    dfb   TOKEN_SHIFT_RIGHT
00:9C73 02              	     2M    dfb   2
00:9C74 50AB            	     3M    word  exp_shift_right
                        	   886:   makePrecedenceTable '&', 3, exp_bitwise_and
00:9C76 26              	     1M    dfb   '&'
00:9C77 03              	     2M    dfb   3
00:9C78 E6AA            	     3M    word  exp_bitwise_and
                        	   887:   makePrecedenceTable '^', 4, exp_bitwise_xor
00:9C7A 5E              	     1M    dfb   '^'
00:9C7B 04              	     2M    dfb   4
00:9C7C FBAA            	     3M    word  exp_bitwise_xor
                        	   888:   makePrecedenceTable '|', 5, exp_bitwise_or
00:9C7E 7C              	     1M    dfb   '|'
00:9C7F 05              	     2M    dfb   5
00:9C80 D1AA            	     3M    word  exp_bitwise_or
                        	   889:   makePrecedenceTable '*', 6, exp_multiply
00:9C82 2A              	     1M    dfb   '*'
00:9C83 06              	     2M    dfb   6
00:9C84 11AC            	     3M    word  exp_multiply
                        	   890:   makePrecedenceTable '/', 6, exp_divide
00:9C86 2F              	     1M    dfb   '/'
00:9C87 06              	     2M    dfb   6
00:9C88 4AAC            	     3M    word  exp_divide
                        	   891:   makePrecedenceTable '%', 6, exp_modulo
00:9C8A 25              	     1M    dfb   '%'
00:9C8B 06              	     2M    dfb   6
00:9C8C AAAC            	     3M    word  exp_modulo
                        	   892:   makePrecedenceTable '+', 7, exp_add
00:9C8E 2B              	     1M    dfb   '+'
00:9C8F 07              	     2M    dfb   7
00:9C90 43AA            	     3M    word  exp_add
                        	   893:   makePrecedenceTable '-', 7, exp_subtract
00:9C92 2D              	     1M    dfb   '-'
00:9C93 07              	     2M    dfb   7
00:9C94 57AA            	     3M    word  exp_subtract
                        	   894:   makePrecedenceTable '<', 8, exp_less_than
00:9C96 3C              	     1M    dfb   '<'
00:9C97 08              	     2M    dfb   8
00:9C98 A5AA            	     3M    word  exp_less_than
                        	   895:   makePrecedenceTable '>', 8, exp_greater_than
00:9C9A 3E              	     1M    dfb   '>'
00:9C9B 08              	     2M    dfb   8
00:9C9C ACAA            	     3M    word  exp_greater_than
                        	   896:   makePrecedenceTable TOKEN_LEQ, 8, exp_leq
00:9C9E 80              	     1M    dfb   TOKEN_LEQ
00:9C9F 08              	     2M    dfb   8
00:9CA0 BBAA            	     3M    word  exp_leq
                        	   897:   makePrecedenceTable TOKEN_GEQ, 8, exp_geq
00:9CA2 81              	     1M    dfb   TOKEN_GEQ
00:9CA3 08              	     2M    dfb   8
00:9CA4 CAAA            	     3M    word  exp_geq
                        	   898:   makePrecedenceTable TOKEN_EQUALITY, 9, exp_eql
00:9CA6 45              	     1M    dfb   TOKEN_EQUALITY
00:9CA7 09              	     2M    dfb   9
00:9CA8 7DAA            	     3M    word  exp_eql
                        	   899:   makePrecedenceTable TOKEN_NEQ, 9, exp_neq     ; <>
00:9CAA 55              	     1M    dfb   TOKEN_NEQ
00:9CAB 09              	     2M    dfb   9
00:9CAC 91AA            	     3M    word  exp_neq     
                        	   900:   makePrecedenceTable TOKEN_INEQUALITY, 9, exp_neq  ; !=
00:9CAE 5A              	     1M    dfb   TOKEN_INEQUALITY
00:9CAF 09              	     2M    dfb   9
00:9CB0 91AA            	     3M    word  exp_neq  
                        	   901:   makePrecedenceTable TOKEN_LOGICAL_AND, 10, exp_logical_and
00:9CB2 58              	     1M    dfb   TOKEN_LOGICAL_AND
00:9CB3 0A              	     2M    dfb   10
00:9CB4 25AB            	     3M    word  exp_logical_and
                        	   902:   makePrecedenceTable TOKEN_LOGICAL_OR, 11, exp_logical_or
00:9CB6 59              	     1M    dfb   TOKEN_LOGICAL_OR
00:9CB7 0B              	     2M    dfb   11
00:9CB8 16AB            	     3M    word  exp_logical_or
                        	   903: 
                        	   904: exp_precedence_table_end = *
                        	   905: 
                        	   906: ;
                        	   907: ;  finds precedence of operator in A, returns it in Y (returns 0 if not found)
                        	   908: ;    changes X, A
                        	   909: ;  also stores the operator evaluation function (eg. exp_add) in exp_evaluation_function
                        	   910: ;
                        	   911: exp_get_precedence:
00:9CBA A200            	   912:   ldx #0
                        	   913: exp_get_precedence_loop:
00:9CBC DD5A9C          	   914:   cmp exp_precedence_table,x
00:9CBF F00F            	   915:   beq exp_get_precedence_found
00:9CC1 E8              	   916:   inx   ; skip operator
00:9CC2 E8              	   917:   inx   ; skip precedence
00:9CC3 E8              	   918:   inx   ; skip evaluation function
00:9CC4 E8              	   919:   inx   ;  (2 bytes)
00:9CC5 E060            	   920:   cpx #exp_precedence_table_end - exp_precedence_table
00:9CC7 90F3            	   921:   bcc exp_get_precedence_loop
00:9CC9 A000            	   922:   ldy #0
00:9CCB 647F            	   923:   stz exp_evaluation_function
00:9CCD 6480            	   924:   stz exp_evaluation_function+1
00:9CCF 60              	   925:   rts
                        	   926: exp_get_precedence_found:
00:9CD0 E8              	   927:   inx
00:9CD1 BC5A9C          	   928:   ldy exp_precedence_table,x
00:9CD4 E8              	   929:   inx
00:9CD5 BD5A9C          	   930:   lda exp_precedence_table,x
00:9CD8 857F            	   931:   sta exp_evaluation_function
00:9CDA E8              	   932:   inx
00:9CDB BD5A9C          	   933:   lda exp_precedence_table,x
00:9CDE 8580            	   934:   sta exp_evaluation_function+1
00:9CE0 60              	   935:   rts
                        	   936: 
                        	   937: ;
                        	   938: ;  Convert an expression into a value
                        	   939: ;
                        	   940: ;   Ideas from https://www.geeksforgeeks.org/expression-evaluation/
                        	   941: ;
                        	   942: ass_get_value:
                        	   943: ;
                        	   944: ;  set up expression evaluation stack
                        	   945: ;
00:9CE1 647B            	   946:   stz exp_value_stack_count
00:9CE3 647C            	   947:   stz exp_operator_stack_count
00:9CE5 A531            	   948:   lda ENDSYM
00:9CE7 8579            	   949:   sta exp_value_stack
00:9CE9 A532            	   950:   lda ENDSYM+1
00:9CEB 857A            	   951:   sta exp_value_stack+1
                        	   952: 
00:9CED 6473            	   953:   stz ASS_VALUE
00:9CEF 6474            	   954:   stz ASS_VALUE+1
00:9CF1 6475            	   955:   stz ASS_VALUE+2
00:9CF3 A901            	   956:   lda #1
00:9CF5 8581            	   957:   sta exp_unary_ok  ; unary operators can appear at the start of the expression
00:9CF7 A593            	   958:   lda token_type
                        	   959: ;  jsr START_TRACE
                        	   960: ;
                        	   961: ;  one token lookahead
                        	   962: ;
00:9CF9 8003            	   963:   bra ass_expression_loop_initial
                        	   964: 
                        	   965: ;
                        	   966: ;  1.1 Get the next token
                        	   967: ;
                        	   968: ass_expression_loop:
00:9CFB 20F2C8          	   969:   jsr get_token
                        	   970: ass_expression_loop_initial:
                        	   971: 
                        	   972: ;
                        	   973: ;  1.2.1 If it's a number, push onto the value stack
                        	   974: ;
00:9CFE C94E            	   975:   cmp #TOKEN_NUMBER
00:9D00 D013            	   976:   bne ass_expression_loop1a
                        	   977: ass_expression_number:
00:9D02 A594            	   978:   lda token_value
00:9D04 8500            	   979:   sta VALUE
00:9D06 A595            	   980:   lda token_value+1
00:9D08 8501            	   981:   sta VALUE+1
00:9D0A A596            	   982:   lda token_value+2
00:9D0C 8502            	   983:   sta VALUE+2
00:9D0E 20D69B          	   984:   jsr exp_push_value
00:9D11 6481            	   985:   stz exp_unary_ok          ; don't have unary operators after numbers
00:9D13 80E6            	   986:   bra ass_expression_loop
                        	   987: ;
                        	   988: ;  if it's a string and only 1 or 2 bytes, consider as a number
                        	   989: ;
                        	   990: ass_expression_loop1a:
00:9D15 C922            	   991:   cmp #TOKEN_STRING
00:9D17 D013            	   992:   bne ass_expression_loop1
00:9D19 A592            	   993:   lda token_length
00:9D1B C903            	   994:   cmp #3
00:9D1D B008            	   995:   bcs ass_expression_not_small_string  ; too long?
                        	   996: ;
                        	   997: ;  one or two character string - is this an immediate operand?
                        	   998: ;
00:9D1F A56B            	   999:   lda ASS_OPERAND
00:9D21 C907            	  1000:   cmp #ASS_OPERAND_IMMEDIATE
00:9D23 D002            	  1001:   bne ass_expression_not_small_string
00:9D25 80DB            	  1002:   bra ass_expression_number   ; treat as a number (its value should be in VALUE)
                        	  1003: 
                        	  1004: ass_expression_not_small_string:
00:9D27 A21D            	  1005:   ldx #29     ; string literal too big
00:9D29 4CB49E          	  1006:   jmp ass_error
                        	  1007: 
                        	  1008: ;
                        	  1009: ;  1.2.2 If it's an identifier, get its value and push onto the value stack
                        	  1010: ;
                        	  1011: ass_expression_loop1:
00:9D2C C949            	  1012:   cmp #TOKEN_IDENTIFIER
00:9D2E D029            	  1013:   bne ass_expression_loop2
00:9D30 6481            	  1014:   stz exp_unary_ok          ; don't have unary operators after identifiers
                        	  1015: 
00:9D32 207AB8          	  1016:   jsr SEARCH    ; should be in symbol table as a constant, and the value in VALUE
00:9D35 D011            	  1017:   bne ass_expression_found_value
00:9D37 A576            	  1018:   lda ASS_PASS
00:9D39 F005            	  1019:   beq ass_label_not_found_yet
                        	  1020: 
                        	  1021: ;
                        	  1022: ; it's an error if it isn't there on the second pass
                        	  1023: ;
00:9D3B A20B            	  1024:   ldx #11  ; ERROR: Undeclared Identifier
00:9D3D 4CB49E          	  1025:   jmp ass_error
                        	  1026: 
                        	  1027: ;
                        	  1028: ;  label not found on first pass, make the value 0x6666 for now
                        	  1029: ;   - we don't want a zero-page address assumption because that
                        	  1030: ;     will throw out opcode lengths (it might assume a zero page opcode
                        	  1031: ;     which is shorter and then change it to a longer one)
                        	  1032: ;
                        	  1033: ass_label_not_found_yet:
00:9D40 A966            	  1034:   lda #$66
00:9D42 8500            	  1035:   sta VALUE
00:9D44 8501            	  1036:   sta VALUE+1
00:9D46 6402            	  1037:   stz VALUE+2
                        	  1038: ass_expression_found_value:
00:9D48 A594            	  1039:   lda token_value
00:9D4A 8500            	  1040:   sta VALUE
00:9D4C A595            	  1041:   lda token_value+1
00:9D4E 8501            	  1042:   sta VALUE+1
00:9D50 A596            	  1043:   lda token_value+2
00:9D52 8502            	  1044:   sta VALUE+2
00:9D54 20D69B          	  1045:   jsr exp_push_value
00:9D57 80A2            	  1046:   bra ass_expression_loop
                        	  1047: 
                        	  1048: ;
                        	  1049: ; 1.2.3 If it's a left parenthesis: push it onto the operator stack.
                        	  1050: ;
                        	  1051: ass_expression_loop2:
00:9D59 C928            	  1052:   cmp #'('
00:9D5B D00B            	  1053:   bne ass_expression_loop3
00:9D5D 48              	  1054:   pha
00:9D5E A901            	  1055:   lda  #1
00:9D60 8581            	  1056:   sta exp_unary_ok          ; unary operators can follow left parentheses
00:9D62 68              	  1057:   pla
                        	  1058: 
00:9D63 202A9C          	  1059:   jsr exp_push_operator
00:9D66 8093            	  1060:   bra ass_expression_loop
                        	  1061: 
                        	  1062: ;
                        	  1063: ;  1.2.4 A right parenthesis:
                        	  1064: ;       1 While the thing on top of the operator stack is not a
                        	  1065: ;         left parenthesis,
                        	  1066: ;           1 Pop the operator from the operator stack.
                        	  1067: ;           2 Pop the value stack twice, getting two operands.
                        	  1068: ;           3 Apply the operator to the operands, in the correct order.
                        	  1069: ;           4 Push the result onto the value stack.
                        	  1070: ;        2 Pop the left parenthesis from the operator stack, and discard it.
                        	  1071: 
                        	  1072: 
                        	  1073: ass_expression_loop3:
00:9D68 C929            	  1074:   cmp #')'
00:9D6A D016            	  1075:   bne ass_expression_loop4
                        	  1076: ass_expression_loop3b:
                        	  1077: ;
                        	  1078: ;  a RH parenthesis with an empty operator stack is probably the end of the expression, eg. ($1234),x
                        	  1079: ;  where the ")" belongs to the indexed operand stuff and not the expression
                        	  1080: ;
00:9D6C A57C            	  1081:   lda exp_operator_stack_count
00:9D6E F078            	  1082:   beq exp_no_operators_left
00:9D70 204C9C          	  1083:   jsr exp_get_operator
00:9D73 C928            	  1084:   cmp #'('
00:9D75 F005            	  1085:   beq ass_expression_loop3c
                        	  1086: ;
                        	  1087: ;  not a left parenthesis
                        	  1088: ;
                        	  1089: ass_expression_loop3a:
00:9D77 200E9E          	  1090:   jsr ass_expression_apply_operator ; pop the operator and two values, apply the operator and push the result
00:9D7A 80F0            	  1091:   bra ass_expression_loop3b          ; keep going until we don't have a left parenthesis
                        	  1092: 
                        	  1093: ass_expression_loop3c:
00:9D7C 203C9C          	  1094:   jsr exp_pop_operator              ;  2 Pop the left parenthesis from the operator stack, and discard it.
                        	  1095: ass_expression_loopJ:
00:9D7F 4CFB9C          	  1096:   jmp ass_expression_loop
                        	  1097: 
                        	  1098: ;       1.2.5 An operator (call it thisOp):
                        	  1099: ;         1 While the operator stack is not empty, and the top thing on the
                        	  1100: ;           operator stack has the same or greater precedence as thisOp,
                        	  1101: ;           1 Pop the operator from the operator stack.
                        	  1102: ;           2 Pop the value stack twice, getting two operands.
                        	  1103: ;           3 Apply the operator to the operands, in the correct order.
                        	  1104: ;           4 Push the result onto the value stack.
                        	  1105: ;         2 Push thisOp onto the operator stack.
                        	  1106: 
                        	  1107: ass_expression_loop4:
                        	  1108: ;
                        	  1109: ;  look for unary operators
                        	  1110: ;
00:9D82 A681            	  1111:   ldx exp_unary_ok
00:9D84 F034            	  1112:   beq ass_expression_cannot_be_unary
00:9D86 C92D            	  1113:   cmp #'-'
00:9D88 D006            	  1114:   bne ass_not_unary_minus
00:9D8A A94D            	  1115:   lda #TOKEN_UNARY_MINUS
00:9D8C 8593            	  1116:   sta token_type
00:9D8E 802A            	  1117:   bra ass_expression_cannot_be_unary
                        	  1118: ass_not_unary_minus:
00:9D90 C93C            	  1119:   cmp #'<'
00:9D92 D006            	  1120:   bne ass_not_unary_less_than
00:9D94 A956            	  1121:   lda #TOKEN_LOW_BYTE
00:9D96 8593            	  1122:   sta token_type
00:9D98 8020            	  1123:   bra ass_expression_cannot_be_unary
                        	  1124: ass_not_unary_less_than:
00:9D9A C93E            	  1125:   cmp #'>'
00:9D9C D006            	  1126:   bne ass_not_unary_greater_than
00:9D9E A957            	  1127:   lda #TOKEN_HIGH_BYTE
00:9DA0 8593            	  1128:   sta token_type
00:9DA2 8000            	  1129:   bra ass_not_unary_greater_than
                        	  1130: ass_not_unary_greater_than:
00:9DA4 C92A            	  1131:   cmp #'*'
00:9DA6 D012            	  1132:   bne ass_expression_cannot_be_unary
                        	  1133: ;
                        	  1134: ;  A '*' where a unary expression is allowed will be the current emit address (eg. foo = *)
                        	  1135: ;
00:9DA8 A523            	  1136:   lda PCODE
00:9DAA 8594            	  1137:   sta token_value
00:9DAC A524            	  1138:   lda PCODE+1
00:9DAE 8595            	  1139:   sta token_value+1
00:9DB0 6496            	  1140:   stz token_value+2
00:9DB2 6481            	  1141:   stz exp_unary_ok          ; don't have unary operators after numbers
00:9DB4 A94E            	  1142:   lda #TOKEN_NUMBER
00:9DB6 8593            	  1143:   sta token_type            ; make get_token think a sign as a token on its own
00:9DB8 808E            	  1144:   bra ass_expression_found_value
                        	  1145: 
                        	  1146: ass_expression_cannot_be_unary:
00:9DBA 48              	  1147:   pha
00:9DBB A901            	  1148:   lda #1
00:9DBD 8581            	  1149:   sta exp_unary_ok          ; can have unary operators after operators
00:9DBF 68              	  1150:   pla
                        	  1151: 
00:9DC0 20BA9C          	  1152:   jsr exp_get_precedence
00:9DC3 847E            	  1153:   sty exp_operator_precedence ; thisOp's precedence
00:9DC5 C000            	  1154:   cpy #0
00:9DC7 F01F            	  1155:   beq exp_no_operators_left
                        	  1156: 
                        	  1157: ass_expression_loop7:         ; 1 While the operator stack is not empty
00:9DC9 A57C            	  1158:   lda exp_operator_stack_count
00:9DCB F013            	  1159:   beq ass_expression_loop6    ; stack empty
00:9DCD 204C9C          	  1160:   jsr exp_get_operator    ; find the top thing on the operator stack
00:9DD0 C928            	  1161:   cmp #'('                ; if a bracket, consider that low precedence
00:9DD2 F00C            	  1162:   beq ass_expression_loop6
00:9DD4 20BA9C          	  1163:   jsr exp_get_precedence  ; and its precedence
00:9DD7 C47E            	  1164:   cpy exp_operator_precedence
00:9DD9 B005            	  1165:   bcs ass_expression_loop6  ; thing on top has less precedence (a higher value) than thisOp
00:9DDB 200E9E          	  1166:   jsr ass_expression_apply_operator  ; pop the operator and two values, apply the operator and push the result
00:9DDE 80E9            	  1167:   bra ass_expression_loop7
                        	  1168: 
                        	  1169: ass_expression_loop6:
00:9DE0 A593            	  1170:   lda token_type       ; thisOp
00:9DE2 202A9C          	  1171:   jsr exp_push_operator
00:9DE5 4CFB9C          	  1172:   jmp ass_expression_loop
                        	  1173: 
                        	  1174: 
                        	  1175: ; 2. While the operator stack is not empty,
                        	  1176: ;     1 Pop the operator from the operator stack.
                        	  1177: ;     2 Pop the value stack twice, getting two operands.
                        	  1178: ;     3 Apply the operator to the operands, in the correct order.
                        	  1179: ;     4 Push the result onto the value stack.
                        	  1180: 
                        	  1181: 
                        	  1182: exp_no_operators_left:
00:9DE8 A57C            	  1183:     lda exp_operator_stack_count
00:9DEA F005            	  1184:     beq exp_done
00:9DEC 200E9E          	  1185:     jsr ass_expression_apply_operator ; pop the operator and two values, apply the operator and push the result
00:9DEF 80F7            	  1186:     bra exp_no_operators_left
                        	  1187: 
                        	  1188: exp_done:
00:9DF1 A57B            	  1189:       lda exp_value_stack_count
00:9DF3 C901            	  1190:       cmp #1
00:9DF5 F005            	  1191:       beq exp_done_ok
                        	  1192: exp_done_error:
00:9DF7 A217            	  1193:       ldx #23       ; ERROR: Illegal factor
00:9DF9 4CB49E          	  1194:       jmp ass_error
                        	  1195: 
                        	  1196: exp_done_ok:
00:9DFC A57C            	  1197:       lda exp_operator_stack_count
00:9DFE D0F7            	  1198:       bne exp_done_error
00:9E00 20019C          	  1199:       jsr exp_pop_value   ; pop the finished value
00:9E03 A500            	  1200:       lda VALUE
00:9E05 8573            	  1201:       sta ASS_VALUE
00:9E07 A501            	  1202:       lda VALUE+1
00:9E09 8574            	  1203:       sta ASS_VALUE+1
00:9E0B 6475            	  1204:       stz ASS_VALUE+2   ; make high-order byte zero just in case
00:9E0D 60              	  1205:       rts
                        	  1206: 
                        	  1207: ;
                        	  1208: ;
                        	  1209: ;     1 Pop the operator from the operator stack.
                        	  1210: ;     2 Pop the value stack twice, getting two operands.
                        	  1211: ;     3 Apply the operator to the operands, in the correct order.
                        	  1212: ;     4 Push the result onto the value stack.
                        	  1213: 
                        	  1214: ;
                        	  1215: ass_expression_apply_operator:
00:9E0E 20019C          	  1216:   jsr exp_pop_value         ; 2 Pop the value stack twice, getting two operands.
00:9E11 204C9C          	  1217:   jsr exp_get_operator
00:9E14 C97E            	  1218:   cmp #'~'
00:9E16 F01F            	  1219:   beq ass_expression_unary
00:9E18 C921            	  1220:   cmp #'!'
00:9E1A F01B            	  1221:   beq ass_expression_unary
00:9E1C C94D            	  1222:   cmp #TOKEN_UNARY_MINUS
00:9E1E F017            	  1223:   beq ass_expression_unary
00:9E20 C956            	  1224:   cmp #TOKEN_LOW_BYTE
00:9E22 F013            	  1225:   beq ass_expression_unary
00:9E24 C957            	  1226:   cmp #TOKEN_HIGH_BYTE
00:9E26 F00F            	  1227:   beq ass_expression_unary
                        	  1228: 
                        	  1229: ;
                        	  1230: ;  if a binary operator get the second value
                        	  1231: ;
00:9E28 A500            	  1232:   lda VALUE                 ; copy top value to VALUE2
00:9E2A 8503            	  1233:   sta VALUE2
00:9E2C A501            	  1234:   lda VALUE+1
00:9E2E 8504            	  1235:   sta VALUE2+1
00:9E30 A502            	  1236:   lda VALUE+2
00:9E32 8505            	  1237:   sta VALUE2+2
00:9E34 20019C          	  1238:   jsr exp_pop_value         ; second pop
                        	  1239: ass_expression_unary:
                        	  1240: 
                        	  1241: ;
                        	  1242: ;  now we have the top two values in VALUE (and VALUE2 in the case of binary operators)
                        	  1243: ;
00:9E37 203C9C          	  1244:   jsr exp_pop_operator      ; 1 Pop the operator from the operator stack.
00:9E3A 857D            	  1245:   sta exp_operator
00:9E3C 20BA9C          	  1246:   jsr exp_get_precedence    ; find the evaluation function
00:9E3F C000            	  1247:   cpy #0
00:9E41 F0CB            	  1248:   beq ass_expression_apply_operator ; should not be here if the operator isn't in the table
00:9E43 204F9E          	  1249:   jsr ass_evaluate_operator ; do the evaluation
00:9E46 20D69B          	  1250:   jsr exp_push_value        ; 4 Push the result onto the value stack.
00:9E49 60              	  1251:   rts
                        	  1252: 
                        	  1253: ass_expression_apply_operator_bug:
00:9E4A A206            	  1254:   ldx #6
00:9E4C 4CB49E          	  1255:   jmp ass_error
                        	  1256: 
                        	  1257: ass_evaluate_operator:
00:9E4F 6C7F00          	  1258:   jmp (exp_evaluation_function)
                        	  1259: 
                        	  1260: 
                        	  1261: ;
                        	  1262: ;  look up opcodes in a table
                        	  1263: ;  returns carry set if found, carry clear if not found
                        	  1264: ;
                        	  1265: ass_lookup_loop:
00:9E52 A46E            	  1266:   ldy OPCODE_LEN
00:9E54 202D92          	  1267:   jsr COMSTL
00:9E57 F017            	  1268:   beq ass_opcode_found
                        	  1269: ;
                        	  1270: ;  add the opcode length, plus 1 to DEST
                        	  1271: ;
00:9E59 18              	  1272:   clc
00:9E5A A46E            	  1273:   ldy OPCODE_LEN
00:9E5C C8              	  1274:   iny
00:9E5D 98              	  1275:   tya
00:9E5E 6503            	  1276:   adc DEST
00:9E60 8503            	  1277:   sta DEST
00:9E62 A504            	  1278:   lda DEST+1
00:9E64 6900            	  1279:   adc #0
00:9E66 8504            	  1280:   sta DEST+1
                        	  1281: ;
                        	  1282: ;  end of table?
                        	  1283: ;
00:9E68 A000            	  1284:   ldy #0
00:9E6A B103            	  1285:   lda (DEST),Y
00:9E6C D0E4            	  1286:   bne ass_lookup_loop   ; not yet
00:9E6E 18              	  1287:   clc
00:9E6F 60              	  1288:   rts
                        	  1289: 
                        	  1290: 
                        	  1291: ass_opcode_found:
00:9E70 A46E            	  1292:   ldy OPCODE_LEN
00:9E72 B103            	  1293:   lda (DEST),Y
00:9E74 38              	  1294:   sec   ; indicate found
00:9E75 60              	  1295:   rts
                        	  1296: 
                        	  1297: ass_emit:
00:9E76 A476            	  1298:   ldy ASS_PASS
00:9E78 F031            	  1299:   beq ass_emit3  ; only emit codes on 2nd pass
                        	  1300:   ;
                        	  1301:   ;  first time for this line of code, indent by two spaces
                        	  1302:   ;
00:9E7A A46F            	  1303:   ldy ASS_EMIT_COUNT
00:9E7C D00C            	  1304:   bne ass_emit2
00:9E7E A42E            	  1305:   ldy DCODE
00:9E80 F008            	  1306:   beq ass_emit2
00:9E82 48              	  1307:   pha
00:9E83 20B392          	  1308:   jsr PUTSP
00:9E86 20B392          	  1309:   jsr PUTSP
00:9E89 68              	  1310:   pla
                        	  1311: ass_emit2:
                        	  1312: ;
                        	  1313: ;  if this is the *first* byte we emitted, then make that the start address
                        	  1314: ;  for running the code. That is, if you relocate the code, the first byte
                        	  1315: ;  actually emitted will be considered the runtime address.
                        	  1316: ;
                        	  1317: ;  this lets you relocate code (eg. to $4500) and have it run from there if
                        	  1318: ;  you happen to hit Run.
                        	  1319: ;
00:9E8A 48              	  1320:   pha
00:9E8B A577            	  1321:   lda ass_emit_bytes
00:9E8D 0578            	  1322:   ora ass_emit_bytes+1
00:9E8F D008            	  1323:   bne ass_already_emitted
00:9E91 A523            	  1324:   lda PCODE
00:9E93 8525            	  1325:   sta ACT_PCDA
00:9E95 A524            	  1326:   lda PCODE+1
00:9E97 8526            	  1327:   sta ACT_PCDA+1
                        	  1328: ass_already_emitted:
00:9E99 68              	  1329:   pla
                        	  1330: ;
                        	  1331: ;  write the byte to memory
                        	  1332: ;
00:9E9A A000            	  1333:   ldy #0
00:9E9C 9123            	  1334:   sta (PCODE),Y
00:9E9E E677            	  1335:   inc ass_emit_bytes
00:9EA0 D002            	  1336:   bne ass_emit4
00:9EA2 E678            	  1337:   inc ass_emit_bytes+1
                        	  1338: ass_emit4:
                        	  1339: 
                        	  1340: ;
                        	  1341: ;  if displaying codes, show the emitted byte
                        	  1342: ;
00:9EA4 A42E            	  1343:   ldy DCODE
00:9EA6 F003            	  1344:   beq ass_emit3
00:9EA8 203D92          	  1345:   jsr DISHX
                        	  1346: ;
                        	  1347: ;  increment the PCODE (output) address
                        	  1348: ;
                        	  1349: ass_emit3:
00:9EAB E623            	  1350:   inc PCODE
00:9EAD D002            	  1351:   bne ass_emit1
00:9EAF E624            	  1352:   inc PCODE+1
                        	  1353: ass_emit1:
00:9EB1 E66F            	  1354:   inc ASS_EMIT_COUNT
00:9EB3 60              	  1355:   rts
                        	  1356: 
                        	  1357: ass_error:
00:9EB4 A56F            	  1358:   lda ASS_EMIT_COUNT
00:9EB6 F003            	  1359:   beq ass_error1
00:9EB8 202892          	  1360:   jsr CROUT
                        	  1361: ass_error1:
00:9EBB 4C6497          	  1362:   jmp ERROR
                        	  1363: 
                        	  1364: ass_fixup_bbr_branch:
00:9EBE A507            	  1365:   lda REMAIN+1
00:9EC0 D043            	  1366:   bne ass_emit_zero_page_too_high
00:9EC2 A508            	  1367:   lda REMAIN+2
00:9EC4 D03F            	  1368:   bne ass_emit_zero_page_too_high
00:9EC6 A506            	  1369:   lda REMAIN
00:9EC8 20769E          	  1370:   jsr ass_emit  ; output zero page address
                        	  1371: 
                        	  1372: ;
                        	  1373: ;  now fall down and emit the branch
                        	  1374: ;
                        	  1375: 
                        	  1376: ass_fixup_branch:
00:9ECB 18              	  1377:   clc         ; I want to subtract one more, so I CLEAR carry <sigh>
00:9ECC A573            	  1378:   lda ASS_VALUE
00:9ECE E523            	  1379:   sbc PCODE
00:9ED0 8573            	  1380:   sta ASS_VALUE
                        	  1381: 
00:9ED2 A574            	  1382:   lda ASS_VALUE+1
00:9ED4 E524            	  1383:   sbc PCODE+1
00:9ED6 C9FF            	  1384:   cmp #$FF  ; backwards branch
00:9ED8 F00A            	  1385:   beq ass_branch_backwards
00:9EDA C900            	  1386:   cmp #0
00:9EDC D010            	  1387:   bne ass_branch_out_of_range
00:9EDE A573            	  1388:   lda ASS_VALUE ; must be 0x00 to 0x7F
00:9EE0 300C            	  1389:   bmi ass_branch_out_of_range
00:9EE2 8004            	  1390:   bra ass_branch_ok
                        	  1391: 
                        	  1392: ass_branch_backwards:
00:9EE4 A573            	  1393:   lda ASS_VALUE   ; must be 0x80 to 0xFF
00:9EE6 1006            	  1394:   bpl ass_branch_out_of_range
                        	  1395: 
                        	  1396: ass_branch_ok:
00:9EE8 A573            	  1397:   lda ASS_VALUE
00:9EEA 20769E          	  1398:   jsr ass_emit  ; output relative address
00:9EED 60              	  1399:   rts
                        	  1400: 
                        	  1401: ass_branch_out_of_range:
00:9EEE A576            	  1402:   lda ASS_PASS
00:9EF0 F0F6            	  1403:   beq ass_branch_ok   ; out of range is OK on first pass, we don't know how far the branch is
00:9EF2 A22A            	  1404:   ldx #42
00:9EF4 4CB49E          	  1405:   jmp ass_error  ; branch out of range
                        	  1406: 
                        	  1407: ass_emit_zero_page:
00:9EF7 A574            	  1408:   lda ASS_VALUE+1
00:9EF9 D00A            	  1409:   bne ass_emit_zero_page_too_high
00:9EFB A575            	  1410:   lda ASS_VALUE+2
00:9EFD D006            	  1411:   bne ass_emit_zero_page_too_high
00:9EFF A573            	  1412:   lda ASS_VALUE
00:9F01 20769E          	  1413:   jsr ass_emit  ; output zero page address
00:9F04 60              	  1414:   rts
                        	  1415: 
                        	  1416: 
                        	  1417: ass_emit_zero_page_too_high:
00:9F05 A22B            	  1418:   ldx #43       ; Need zero page address
00:9F07 4CB49E          	  1419:   jmp ass_error
                        	  1420: 
                        	  1421: ass_emit_immediate:
00:9F0A A574            	  1422:   lda ASS_VALUE+1
00:9F0C D00A            	  1423:   bne ass_emit_immediate_too_high
00:9F0E A575            	  1424:   lda ASS_VALUE+2
00:9F10 D006            	  1425:   bne ass_emit_immediate_too_high
00:9F12 A573            	  1426:   lda ASS_VALUE
00:9F14 20769E          	  1427:   jsr ass_emit  ; output immediate operand
00:9F17 60              	  1428:   rts
                        	  1429: 
                        	  1430: ass_emit_immediate_too_high:
00:9F18 A22C            	  1431:   ldx #44
00:9F1A 4CB49E          	  1432:   jmp ass_error
                        	  1433: 
                        	  1434: 
                        	  1435: ass_emit_absolute:
00:9F1D A573            	  1436:   lda ASS_VALUE
00:9F1F 20769E          	  1437:   jsr ass_emit  ; output absolute address - low-order byte
00:9F22 A574            	  1438:   lda ASS_VALUE+1
00:9F24 20769E          	  1439:   jsr ass_emit  ; output absolute address - high-order byte
00:9F27 60              	  1440:   rts
                        	  1441: 
                        	  1442: 
                        	  1443: ;------------------------------------
                        	  1444: ;  Opcode master table
                        	  1445: ;------------------------------------
                        	  1446: 
                        	  1447:    .macro makeOpcodeLookup ; table of opcodes, length of opcode, wanted operand type, special handler
                        	  1448:      dfb   \1
                        	  1449:      dfb   \2
                        	  1450:      word  \3
                        	  1451:      word   \4
                        	  1452:    .endmacro
                        	  1453: 
                        	  1454: ;
                        	  1455: ;  So, for an opcode to match, it has to:
                        	  1456: ;     a) be the right length (usually 3 or 4 characters)
                        	  1457: ;     b) have the right type of operand (eg. ASS_OPERAND_IMMEDIATE)
                        	  1458: ;     c) the opcode must match the name in the list
                        	  1459: ;
                        	  1460: ;   If those conditions are met we output the corresponding opcode,
                        	  1461: ;   return with the operand type in A
                        	  1462: ;
                        	  1463: ;   Otherwise, we return 0 in A
                        	  1464: ;
                        	  1465: 
                        	  1466: OPCODE_LOOKUP_OPCODE_LENGTH = 0
                        	  1467: OPCODE_LOOKUP_OPERAND_TYPE = 1
                        	  1468: OPCODE_LOOKUP_OPCODE_TABLE = 2    ; 2 bytes
                        	  1469: OPCODE_LOOKUP_HANDLER = 4         ; 2 bytes
                        	  1470: OPCODE_LOOKUP_TABLE_SIZE = 6      ; all of the above
                        	  1471: 
                        	  1472: OPCODE_LOOKUP_TABLE = *
                        	  1473: ;
                        	  1474: ;  zero-page opcodes go first as they are preferred if we are accessing a zero-page address
                        	  1475: ;
                        	  1476:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE, OPCODE_ASS_OPERAND_ZERO_PAGE, ass_emit_zero_page ; (11)
00:9F28 03              	     1M      dfb   3
00:9F29 0B              	     2M      dfb   ASS_OPERAND_ZERO_PAGE
00:9F2A B5A2            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE
00:9F2C F79E            	     4M      word   ass_emit_zero_page 
                        	  1477:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE, OPCODE_ASS_OPERAND_ZERO_PAGE_TOKENISED, ass_emit_zero_page ; (11)
00:9F2E 01              	     1M      dfb   1
00:9F2F 0B              	     2M      dfb   ASS_OPERAND_ZERO_PAGE
00:9F30 16A3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_TOKENISED
00:9F32 F79E            	     4M      word   ass_emit_zero_page 
                        	  1478:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT, ass_em
00:9F34 03              	     1M      dfb   3
00:9F35 0C              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
00:9F36 19A3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
00:9F38 F79E            	     4M      word   ass_emit_zero_page 
                        	  1479:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT_TOKENIS
00:9F3A 01              	     1M      dfb   1
00:9F3B 0C              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
00:9F3C 3AA3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT_TOKENISED
00:9F3E F79E            	     4M      word   ass_emit_zero_page 
                        	  1480:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X, ass_emit_z
00:9F40 03              	     1M      dfb   3
00:9F41 0D              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
00:9F42 3DA3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
00:9F44 F79E            	     4M      word   ass_emit_zero_page 
                        	  1481:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X_TOKENISED, 
00:9F46 01              	     1M      dfb   1
00:9F47 0D              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
00:9F48 86A3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X_TOKENISED
00:9F4A F79E            	     4M      word   ass_emit_zero_page 
                        	  1482:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y, ass_emit_z
00:9F4C 03              	     1M      dfb   3
00:9F4D 0E              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
00:9F4E 89A3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
00:9F50 F79E            	     4M      word   ass_emit_zero_page 
                        	  1483:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDIRECT, OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT, ass_emit_zero_page ; (
00:9F52 03              	     1M      dfb   3
00:9F53 0F              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDIRECT
00:9F54 92A3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT
00:9F56 F79E            	     4M      word   ass_emit_zero_page 
                        	  1484:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE_INDIRECT, OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_TOKENISED, ass_emit_zer
00:9F58 01              	     1M      dfb   1
00:9F59 0F              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDIRECT
00:9F5A B3A3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_TOKENISED
00:9F5C F79E            	     4M      word   ass_emit_zero_page 
                        	  1485:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_
00:9F5E 03              	     1M      dfb   3
00:9F5F 10              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
00:9F60 B6A3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
00:9F62 F79E            	     4M      word   ass_emit_zero_page 
                        	  1486:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_
00:9F64 01              	     1M      dfb   1
00:9F65 10              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
00:9F66 D7A3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y_TOKENISED
00:9F68 F79E            	     4M      word   ass_emit_zero_page 
                        	  1487: 
                        	  1488: ;
                        	  1489: ;  non zero-page opcodes
                        	  1490: ;
                        	  1491:     makeOpcodeLookup  4,  ASS_OPERAND_ABSOLUTE, OPCODE_4_CHAR_ZERO_PAGE,  ass_emit_zero_page  ; (11)
00:9F6A 04              	     1M      dfb   4
00:9F6B 01              	     2M      dfb   ASS_OPERAND_ABSOLUTE
00:9F6C 31A1            	     3M      word  OPCODE_4_CHAR_ZERO_PAGE
00:9F6E F79E            	     4M      word   ass_emit_zero_page  
                        	  1492:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE, OPCODE_ASS_OPERAND_ABSOLUTE,  ass_emit_absolute  ; (1)
00:9F70 03              	     1M      dfb   3
00:9F71 01              	     2M      dfb   ASS_OPERAND_ABSOLUTE
00:9F72 82A1            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE
00:9F74 1D9F            	     4M      word   ass_emit_absolute  
                        	  1493:     makeOpcodeLookup  1,  ASS_OPERAND_ABSOLUTE, OPCODE_ASS_OPERAND_ABSOLUTE_TOKENISED,  ass_emit_absolute  ; (1)
00:9F76 01              	     1M      dfb   1
00:9F77 01              	     2M      dfb   ASS_OPERAND_ABSOLUTE
00:9F78 EBA1            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_TOKENISED
00:9F7A 1D9F            	     4M      word   ass_emit_absolute  
                        	  1494: 
                        	  1495:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT, ass_emit
00:9F7C 03              	     1M      dfb   3
00:9F7D 02              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
00:9F7E EEA1            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
00:9F80 1D9F            	     4M      word   ass_emit_absolute 
                        	  1496:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X, ass_emit_abs
00:9F82 03              	     1M      dfb   3
00:9F83 03              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
00:9F84 F3A1            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
00:9F86 1D9F            	     4M      word   ass_emit_absolute 
                        	  1497:     makeOpcodeLookup  1,  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X_TOKENISED, as
00:9F88 01              	     1M      dfb   1
00:9F89 03              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
00:9F8A 38A2            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X_TOKENISED
00:9F8C 1D9F            	     4M      word   ass_emit_absolute 
                        	  1498:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y, ass_emit_abs
00:9F8E 03              	     1M      dfb   3
00:9F8F 04              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
00:9F90 3BA2            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
00:9F92 1D9F            	     4M      word   ass_emit_absolute 
                        	  1499:     makeOpcodeLookup  1,  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y_TOKENISED, as
00:9F94 01              	     1M      dfb   1
00:9F95 04              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
00:9F96 60A2            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y_TOKENISED
00:9F98 1D9F            	     4M      word   ass_emit_absolute 
                        	  1500:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDIRECT, OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT, ass_emit_absolute ; (5)
00:9F9A 03              	     1M      dfb   3
00:9F9B 05              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDIRECT
00:9F9C 7CA2            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT
00:9F9E 1D9F            	     4M      word   ass_emit_absolute 
                        	  1501:     makeOpcodeLookup  1,  ASS_OPERAND_ABSOLUTE_INDIRECT, OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED, ass_emit_absolute ; (5
00:9FA0 01              	     1M      dfb   1
00:9FA1 05              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDIRECT
00:9FA2 B2A2            	     3M      word  OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED
00:9FA4 1D9F            	     4M      word   ass_emit_absolute 
                        	  1502:     makeOpcodeLookup  3,  ASS_OPERAND_ACCUMULATOR_A, OPCODE_ASS_OPERAND_ACCUMULATOR_A, 0 ; (6)
00:9FA6 03              	     1M      dfb   3
00:9FA7 06              	     2M      dfb   ASS_OPERAND_ACCUMULATOR_A
00:9FA8 63A2            	     3M      word  OPCODE_ASS_OPERAND_ACCUMULATOR_A
00:9FAA 0000            	     4M      word   0 
                        	  1503:     makeOpcodeLookup  3,  ASS_OPERAND_IMMEDIATE, OPCODE_ASS_OPERAND_IMMEDIATE, ass_emit_immediate ; (7)
00:9FAC 03              	     1M      dfb   3
00:9FAD 07              	     2M      dfb   ASS_OPERAND_IMMEDIATE
00:9FAE 81A2            	     3M      word  OPCODE_ASS_OPERAND_IMMEDIATE
00:9FB0 0A9F            	     4M      word   ass_emit_immediate 
                        	  1504:     makeOpcodeLookup  1,  ASS_OPERAND_IMMEDIATE, OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED, ass_emit_immediate ; (7)
00:9FB2 01              	     1M      dfb   1
00:9FB3 07              	     2M      dfb   ASS_OPERAND_IMMEDIATE
00:9FB4 B2A2            	     3M      word  OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED
00:9FB6 0A9F            	     4M      word   ass_emit_immediate 
                        	  1505:     makeOpcodeLookup  3,  ASS_OPERAND_IMPLIED,  OPCODE_3_CHAR_IMPLIED,    0  ; (8) and (10)
00:9FB8 03              	     1M      dfb   3
00:9FB9 08              	     2M      dfb   ASS_OPERAND_IMPLIED
00:9FBA B4A0            	     3M      word  OPCODE_3_CHAR_IMPLIED
00:9FBC 0000            	     4M      word   0  
                        	  1506:     makeOpcodeLookup  4,  ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE, OPCODE_4_CHAR_BRANCH,     ass_fixup_bbr_branch  ; (9)
00:9FBE 04              	     1M      dfb   4
00:9FBF 12              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE
00:9FC0 3EA0            	     3M      word  OPCODE_4_CHAR_BRANCH
00:9FC2 BE9E            	     4M      word   ass_fixup_bbr_branch  
                        	  1507:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE, OPCODE_3_CHAR_BRANCH,     ass_fixup_branch  ; (9)
00:9FC4 03              	     1M      dfb   3
00:9FC5 01              	     2M      dfb   ASS_OPERAND_ABSOLUTE
00:9FC6 8FA0            	     3M      word  OPCODE_3_CHAR_BRANCH
00:9FC8 CB9E            	     4M      word   ass_fixup_branch  
00:9FCA 00              	  1508:     dfb 0
                        	  1509: 
                        	  1510: 
                        	  1511: ;------------------------------------
                        	  1512: ;  directives
                        	  1513: ;------------------------------------
                        	  1514: 
                        	  1515: 
                        	  1516: DIRECTIVES = *
                        	  1517:   makeHandler "ASSERT",   asm_do_assert
00:9FCB 415353455254    	     1M    asciiz   "ASSERT"
00:9FD1 00
00:9FD2 DAA3            	     2M    word  asm_do_assert
                        	  1518:   makeHandler "LIST",     asm_do_list
00:9FD4 4C495354        	     1M    asciiz   "LIST"
00:9FD8 00
00:9FD9 F1A3            	     2M    word  asm_do_list
                        	  1519:   makeHandler "NOLIST",   asm_do_nolist
00:9FDB 4E4F4C495354    	     1M    asciiz   "NOLIST"
00:9FE1 00
00:9FE2 00A4            	     2M    word  asm_do_nolist
                        	  1520:   makeHandler "ASC",      asm_do_asc
00:9FE4 415343          	     1M    asciiz   "ASC"
00:9FE7 00
00:9FE8 3FA4            	     2M    word  asm_do_asc
                        	  1521:   makeHandler "ASCII",    asm_do_asc
00:9FEA 4153434949      	     1M    asciiz   "ASCII"
00:9FEF 00
00:9FF0 3FA4            	     2M    word  asm_do_asc
                        	  1522:   makeHandler "ASCIIZ",   asm_do_string
00:9FF2 41534349495A    	     1M    asciiz   "ASCIIZ"
00:9FF8 00
00:9FF9 5AA4            	     2M    word  asm_do_string
                        	  1523:   makeHandler "STRING",   asm_do_string
00:9FFB 535452494E47    	     1M    asciiz   "STRING"
00:A001 00
00:A002 5AA4            	     2M    word  asm_do_string
                        	  1524:   makeHandler "EQU",      asm_do_equ
00:A004 455155          	     1M    asciiz   "EQU"
00:A007 00
00:A008 63A4            	     2M    word  asm_do_equ
                        	  1525:   makeHandler "=",        asm_do_equ
00:A00A 3D              	     1M    asciiz   "="
00:A00B 00
00:A00C 63A4            	     2M    word  asm_do_equ
                        	  1526:   makeHandler "ORG",      asm_do_org
00:A00E 4F5247          	     1M    asciiz   "ORG"
00:A011 00
00:A012 80A4            	     2M    word  asm_do_org
                        	  1527:   makeHandler "DFB",      asm_do_dfb
00:A014 444642          	     1M    asciiz   "DFB"
00:A017 00
00:A018 94A4            	     2M    word  asm_do_dfb
                        	  1528:   makeHandler "DFW",      asm_do_dfw
00:A01A 444657          	     1M    asciiz   "DFW"
00:A01D 00
00:A01E D4A4            	     2M    word  asm_do_dfw
                        	  1529:   makeHandler "WORD",     asm_do_dfw
00:A020 574F5244        	     1M    asciiz   "WORD"
00:A024 00
00:A025 D4A4            	     2M    word  asm_do_dfw
                        	  1530:   makeHandler "BLK",      asm_do_blk
00:A027 424C4B          	     1M    asciiz   "BLK"
00:A02A 00
00:A02B 11A5            	     2M    word  asm_do_blk
                        	  1531:   makeHandler "RESERVE",  asm_do_reserve
00:A02D 52455345525645  	     1M    asciiz   "RESERVE"
00:A034 00
00:A035 2FA5            	     2M    word  asm_do_reserve
                        	  1532:   makeHandler "SYM",      asm_do_sym
00:A037 53594D          	     1M    asciiz   "SYM"
00:A03A 00
00:A03B 4AA5            	     2M    word  asm_do_sym
                        	  1533: 
00:A03D 00              	  1534:   dfb 0
                        	  1535: 
                        	  1536: ;------------------------------------
                        	  1537: ;  4-character branch opcodes
                        	  1538: ;------------------------------------
                        	  1539: 
                        	  1540: 
                        	  1541: OPCODE_4_CHAR_BRANCH = *
00:A03E 42425230        	  1542:   asc "BBR0",$0F
00:A042 0F
00:A043 42425231        	  1543:   asc "BBR1",$1F
00:A047 1F
00:A048 42425232        	  1544:   asc "BBR2",$2F
00:A04C 2F
00:A04D 42425233        	  1545:   asc "BBR3",$3F
00:A051 3F
00:A052 42425234        	  1546:   asc "BBR4",$4F
00:A056 4F
00:A057 42425235        	  1547:   asc "BBR5",$5F
00:A05B 5F
00:A05C 42425236        	  1548:   asc "BBR6",$6F
00:A060 6F
00:A061 42425237        	  1549:   asc "BBR7",$7F
00:A065 7F
00:A066 42425330        	  1550:   asc "BBS0",$8F
00:A06A 8F
00:A06B 42425331        	  1551:   asc "BBS1",$9F
00:A06F 9F
00:A070 42425332        	  1552:   asc "BBS2",$AF
00:A074 AF
00:A075 42425333        	  1553:   asc "BBS3",$BF
00:A079 BF
00:A07A 42425334        	  1554:   asc "BBS4",$CF
00:A07E CF
00:A07F 42425335        	  1555:   asc "BBS5",$DF
00:A083 DF
00:A084 42425336        	  1556:   asc "BBS6",$EF
00:A088 EF
00:A089 42425337        	  1557:   asc "BBS7",$FF
00:A08D FF
00:A08E 00              	  1558:   dfb 0
                        	  1559: 
                        	  1560: ;------------------------------------
                        	  1561: ;  3-character branch opcodes
                        	  1562: ;------------------------------------
                        	  1563: 
                        	  1564: 
                        	  1565: OPCODE_3_CHAR_BRANCH = *
00:A08F 424343          	  1566:   asc "BCC",$90
00:A092 90
00:A093 424353          	  1567:   asc "BCS",$B0
00:A096 B0
00:A097 424551          	  1568:   asc "BEQ",$F0
00:A09A F0
00:A09B 424D49          	  1569:   asc "BMI",$30
00:A09E 30
00:A09F 424E45          	  1570:   asc "BNE",$D0
00:A0A2 D0
00:A0A3 42504C          	  1571:   asc "BPL",$10
00:A0A6 10
00:A0A7 425241          	  1572:   asc "BRA",$80
00:A0AA 80
00:A0AB 425643          	  1573:   asc "BVC",$50
00:A0AE 50
00:A0AF 425653          	  1574:   asc "BVS",$70
00:A0B2 70
00:A0B3 00              	  1575:   dfb 0
                        	  1576: 
                        	  1577: 
                        	  1578: ;------------------------------------
                        	  1579: ;  3-character implied opcodes (no operand)
                        	  1580: ;------------------------------------
                        	  1581: 
                        	  1582: OPCODE_3_CHAR_IMPLIED = *
00:A0B4 42524B          	  1583:   asc "BRK",$00
00:A0B7 00
00:A0B8 434C43          	  1584:   asc "CLC",$18
00:A0BB 18
00:A0BC 434C44          	  1585:   asc "CLD",$D8
00:A0BF D8
00:A0C0 434C49          	  1586:   asc "CLI",$58
00:A0C3 58
00:A0C4 434C56          	  1587:   asc "CLV",$B8
00:A0C7 B8
00:A0C8 444558          	  1588:   asc "DEX",$CA
00:A0CB CA
00:A0CC 444559          	  1589:   asc "DEY",$88
00:A0CF 88
00:A0D0 494E58          	  1590:   asc "INX",$E8
00:A0D3 E8
00:A0D4 494E59          	  1591:   asc "INY",$C8
00:A0D7 C8
00:A0D8 4E4F50          	  1592:   asc "NOP",$EA
00:A0DB EA
00:A0DC 504841          	  1593:   asc "PHA",$48
00:A0DF 48
00:A0E0 504850          	  1594:   asc "PHP",$08
00:A0E3 08
00:A0E4 504858          	  1595:   asc "PHX",$DA
00:A0E7 DA
00:A0E8 504859          	  1596:   asc "PHY",$5A
00:A0EB 5A
00:A0EC 504C41          	  1597:   asc "PLA",$68
00:A0EF 68
00:A0F0 504C50          	  1598:   asc "PLP",$28
00:A0F3 28
00:A0F4 504C58          	  1599:   asc "PLX",$FA
00:A0F7 FA
00:A0F8 504C59          	  1600:   asc "PLY",$7A
00:A0FB 7A
00:A0FC 525449          	  1601:   asc "RTI",$40
00:A0FF 40
00:A100 525453          	  1602:   asc "RTS",$60
00:A103 60
00:A104 534543          	  1603:   asc "SEC",$38
00:A107 38
00:A108 534544          	  1604:   asc "SED",$F8
00:A10B F8
00:A10C 534549          	  1605:   asc "SEI",$78
00:A10F 78
00:A110 535450          	  1606:   asc "STP",$DB
00:A113 DB
00:A114 544158          	  1607:   asc "TAX",$AA
00:A117 AA
00:A118 544159          	  1608:   asc "TAY",$A8
00:A11B A8
00:A11C 545358          	  1609:   asc "TSX",$BA
00:A11F BA
00:A120 545841          	  1610:   asc "TXA",$8A
00:A123 8A
00:A124 545853          	  1611:   asc "TXS",$9A
00:A127 9A
00:A128 545941          	  1612:   asc "TYA",$98
00:A12B 98
00:A12C 574149          	  1613:   asc "WAI",$CB
00:A12F CB
00:A130 00              	  1614:   dfb 0
                        	  1615: 
                        	  1616: ;------------------------------------
                        	  1617: ;  4-character zero page opcodes (operand must be zero-page address)
                        	  1618: ;------------------------------------
                        	  1619: OPCODE_4_CHAR_ZERO_PAGE = *
00:A131 534D4230        	  1620:   asc "SMB0",$87
00:A135 87
00:A136 534D4231        	  1621:   asc "SMB1",$97
00:A13A 97
00:A13B 534D4232        	  1622:   asc "SMB2",$A7
00:A13F A7
00:A140 534D4233        	  1623:   asc "SMB3",$B7
00:A144 B7
00:A145 534D4234        	  1624:   asc "SMB4",$C7
00:A149 C7
00:A14A 534D4235        	  1625:   asc "SMB5",$D7
00:A14E D7
00:A14F 534D4236        	  1626:   asc "SMB6",$E7
00:A153 E7
00:A154 534D4237        	  1627:   asc "SMB7",$F7
00:A158 F7
00:A159 524D4230        	  1628:   asc "RMB0",$07
00:A15D 07
00:A15E 524D4231        	  1629:   asc "RMB1",$17
00:A162 17
00:A163 524D4232        	  1630:   asc "RMB2",$27
00:A167 27
00:A168 524D4233        	  1631:   asc "RMB3",$37
00:A16C 37
00:A16D 524D4234        	  1632:   asc "RMB4",$47
00:A171 47
00:A172 524D4235        	  1633:   asc "RMB5",$57
00:A176 57
00:A177 524D4236        	  1634:   asc "RMB6",$67
00:A17B 67
00:A17C 524D4237        	  1635:   asc "RMB7",$77
00:A180 77
00:A181 00              	  1636:   dfb 0
                        	  1637: 
                        	  1638: ;------------------------------------
                        	  1639: ;  ASS_OPERAND_ABSOLUTE
                        	  1640: ;------------------------------------
                        	  1641: OPCODE_ASS_OPERAND_ABSOLUTE = *
00:A182 414443          	  1642:   asc "ADC",$6D
00:A185 6D
00:A186 414E44          	  1643:   asc "AND",$2D
00:A189 2D
00:A18A 41534C          	  1644:   asc "ASL",$0E
00:A18D 0E
00:A18E 424954          	  1645:   asc "BIT",$2C
00:A191 2C
00:A192 434D50          	  1646:   asc "CMP",$CD
00:A195 CD
00:A196 435058          	  1647:   asc "CPX",$EC
00:A199 EC
00:A19A 435059          	  1648:   asc "CPY",$CC
00:A19D CC
00:A19E 444543          	  1649:   asc "DEC",$CE
00:A1A1 CE
00:A1A2 454F52          	  1650:   asc "EOR",$4D
00:A1A5 4D
00:A1A6 494E43          	  1651:   asc "INC",$EE
00:A1A9 EE
00:A1AA 4A4D50          	  1652:   asc "JMP",$4C
00:A1AD 4C
00:A1AE 4A5352          	  1653:   asc "JSR",$20
00:A1B1 20
00:A1B2 4C4441          	  1654:   asc "LDA",$AD
00:A1B5 AD
00:A1B6 4C4458          	  1655:   asc "LDX",$AE
00:A1B9 AE
00:A1BA 4C4459          	  1656:   asc "LDY",$AC
00:A1BD AC
00:A1BE 4C5352          	  1657:   asc "LSR",$4E
00:A1C1 4E
00:A1C2 4F5241          	  1658:   asc "ORA",$0D
00:A1C5 0D
00:A1C6 524F4C          	  1659:   asc "ROL",$2E
00:A1C9 2E
00:A1CA 524F52          	  1660:   asc "ROR",$6E
00:A1CD 6E
00:A1CE 534243          	  1661:   asc "SBC",$ED
00:A1D1 ED
00:A1D2 535441          	  1662:   asc "STA",$8D
00:A1D5 8D
00:A1D6 535458          	  1663:   asc "STX",$8E
00:A1D9 8E
00:A1DA 535459          	  1664:   asc "STY",$8C
00:A1DD 8C
00:A1DE 53545A          	  1665:   asc "STZ",$9C
00:A1E1 9C
00:A1E2 545242          	  1666:   asc "TRB",$1C
00:A1E5 1C
00:A1E6 545342          	  1667:   asc "TSB",$0C
00:A1E9 0C
00:A1EA 00              	  1668:   dfb 0
                        	  1669: 
                        	  1670: ;------------------------------------
                        	  1671: ;  ASS_OPERAND_ABSOLUTE - for tokenised opcodes like AND
                        	  1672: ;------------------------------------
                        	  1673: OPCODE_ASS_OPERAND_ABSOLUTE_TOKENISED = *
00:A1EB 8D              	  1674:   dfb TOKEN_AND,$2D
00:A1EC 2D
00:A1ED 00              	  1675:   dfb 0
                        	  1676: 
                        	  1677: 
                        	  1678: ;------------------------------------
                        	  1679: ;  ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
                        	  1680: ;------------------------------------
                        	  1681: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT = *
00:A1EE 4A4D50          	  1682:   asc "JMP",$7C
00:A1F1 7C
00:A1F2 00              	  1683:   dfb 0
                        	  1684: 
                        	  1685: ;------------------------------------
                        	  1686: ;  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
                        	  1687: ;------------------------------------
                        	  1688: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X = *
00:A1F3 414443          	  1689:   asc "ADC",$7D
00:A1F6 7D
00:A1F7 414E44          	  1690:   asc "AND",$3D
00:A1FA 3D
00:A1FB 41534C          	  1691:   asc "ASL",$1E
00:A1FE 1E
00:A1FF 424954          	  1692:   asc "BIT",$3C
00:A202 3C
00:A203 434D50          	  1693:   asc "CMP",$DD
00:A206 DD
00:A207 444543          	  1694:   asc "DEC",$DE
00:A20A DE
00:A20B 454F52          	  1695:   asc "EOR",$5D
00:A20E 5D
00:A20F 494E43          	  1696:   asc "INC",$FE
00:A212 FE
00:A213 4C4441          	  1697:   asc "LDA",$BD
00:A216 BD
00:A217 4C4459          	  1698:   asc "LDY",$BC
00:A21A BC
00:A21B 4C5352          	  1699:   asc "LSR",$5E
00:A21E 5E
00:A21F 4F5241          	  1700:   asc "ORA",$1D
00:A222 1D
00:A223 524F4C          	  1701:   asc "ROL",$3E
00:A226 3E
00:A227 524F52          	  1702:   asc "ROR",$7E
00:A22A 7E
00:A22B 534243          	  1703:   asc "SBC",$FD
00:A22E FD
00:A22F 535441          	  1704:   asc "STA",$9D
00:A232 9D
00:A233 53545A          	  1705:   asc "STZ",$9E
00:A236 9E
00:A237 00              	  1706:   dfb 0
                        	  1707: 
                        	  1708: ;------------------------------------
                        	  1709: ;  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X - for tokenised opcodes like AND
                        	  1710: ;------------------------------------
                        	  1711: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X_TOKENISED = *
00:A238 8D              	  1712:   dfb TOKEN_AND,$3D
00:A239 3D
00:A23A 00              	  1713:   dfb 0
                        	  1714: 
                        	  1715: ;------------------------------------
                        	  1716: ;  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
                        	  1717: ;------------------------------------
                        	  1718: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y = *
00:A23B 414443          	  1719:   asc "ADC",$79
00:A23E 79
00:A23F 414E44          	  1720:   asc "AND",$39
00:A242 39
00:A243 434D50          	  1721:   asc "CMP",$D9
00:A246 D9
00:A247 454F52          	  1722:   asc "EOR",$59
00:A24A 59
00:A24B 4C4441          	  1723:   asc "LDA",$B9
00:A24E B9
00:A24F 4C4458          	  1724:   asc "LDX",$BE
00:A252 BE
00:A253 4F5241          	  1725:   asc "ORA",$19
00:A256 19
00:A257 534243          	  1726:   asc "SBC",$F9
00:A25A F9
00:A25B 535441          	  1727:   asc "STA",$99
00:A25E 99
00:A25F 00              	  1728:   dfb 0
                        	  1729: 
                        	  1730: ;------------------------------------
                        	  1731: ;  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y - for tokenised opcodes like AND
                        	  1732: ;------------------------------------
                        	  1733: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y_TOKENISED = *
00:A260 8D              	  1734:   dfb TOKEN_AND,$39
00:A261 39
00:A262 00              	  1735:   dfb 0
                        	  1736: 
                        	  1737: ;------------------------------------
                        	  1738: ;  ASS_OPERAND_ACCUMULATOR_A
                        	  1739: ;------------------------------------
                        	  1740: OPCODE_ASS_OPERAND_ACCUMULATOR_A = *
00:A263 41534C          	  1741:   asc "ASL",$0A
00:A266 0A
00:A267 444543          	  1742:   asc "DEC",$3A
00:A26A 3A
00:A26B 494E43          	  1743:   asc "INC",$1A
00:A26E 1A
00:A26F 4C5352          	  1744:   asc "LSR",$4A
00:A272 4A
00:A273 524F4C          	  1745:   asc "ROL",$2A
00:A276 2A
00:A277 524F52          	  1746:   asc "ROR",$6A
00:A27A 6A
00:A27B 00              	  1747:   dfb 0
                        	  1748: 
                        	  1749: ;------------------------------------
                        	  1750: ;  ASS_OPERAND_ABSOLUTE_INDIRECT
                        	  1751: ;------------------------------------
                        	  1752: OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT = *
00:A27C 4A4D50          	  1753:   asc "JMP",$6C
00:A27F 6C
00:A280 00              	  1754:   dfb 0
                        	  1755: 
                        	  1756: ;------------------------------------
                        	  1757: ;  ASS_OPERAND_IMMEDIATE
                        	  1758: ;------------------------------------
                        	  1759: OPCODE_ASS_OPERAND_IMMEDIATE = *
00:A281 414443          	  1760:   asc "ADC",$69
00:A284 69
00:A285 414E44          	  1761:   asc "AND",$29
00:A288 29
00:A289 424954          	  1762:   asc "BIT",$89
00:A28C 89
00:A28D 434D50          	  1763:   asc "CMP",$C9
00:A290 C9
00:A291 435058          	  1764:   asc "CPX",$E0
00:A294 E0
00:A295 435059          	  1765:   asc "CPY",$C0
00:A298 C0
00:A299 454F52          	  1766:   asc "EOR",$49
00:A29C 49
00:A29D 4C4441          	  1767:   asc "LDA",$A9
00:A2A0 A9
00:A2A1 4C4458          	  1768:   asc "LDX",$A2
00:A2A4 A2
00:A2A5 4C4459          	  1769:   asc "LDY",$A0
00:A2A8 A0
00:A2A9 4F5241          	  1770:   asc "ORA",$09
00:A2AC 09
00:A2AD 534243          	  1771:   asc "SBC",$E9
00:A2B0 E9
00:A2B1 00              	  1772:   dfb 0
                        	  1773: 
                        	  1774: ;------------------------------------
                        	  1775: ;  ASS_OPERAND_IMMEDIATE - for tokenised opcodes like AND
                        	  1776: ;------------------------------------
                        	  1777: OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED = *
00:A2B2 8D              	  1778:   dfb TOKEN_AND,$29
00:A2B3 29
00:A2B4 00              	  1779:   dfb 0
                        	  1780: 
                        	  1781: ;------------------------------------
                        	  1782: ;  ASS_OPERAND_ZERO_PAGE
                        	  1783: ;------------------------------------
                        	  1784: OPCODE_ASS_OPERAND_ZERO_PAGE = *
00:A2B5 414443          	  1785:   asc "ADC",$65
00:A2B8 65
00:A2B9 414E44          	  1786:   asc "AND",$25
00:A2BC 25
00:A2BD 41534C          	  1787:   asc "ASL",$06
00:A2C0 06
00:A2C1 424954          	  1788:   asc "BIT",$24
00:A2C4 24
00:A2C5 434D50          	  1789:   asc "CMP",$C5
00:A2C8 C5
00:A2C9 435058          	  1790:   asc "CPX",$E4
00:A2CC E4
00:A2CD 435059          	  1791:   asc "CPY",$C4
00:A2D0 C4
00:A2D1 444543          	  1792:   asc "DEC",$C6
00:A2D4 C6
00:A2D5 454F52          	  1793:   asc "EOR",$45
00:A2D8 45
00:A2D9 494E43          	  1794:   asc "INC",$E6
00:A2DC E6
00:A2DD 4C4441          	  1795:   asc "LDA",$A5
00:A2E0 A5
00:A2E1 4C4458          	  1796:   asc "LDX",$A6
00:A2E4 A6
00:A2E5 4C4459          	  1797:   asc "LDY",$A4
00:A2E8 A4
00:A2E9 4C5352          	  1798:   asc "LSR",$46
00:A2EC 46
00:A2ED 4F5241          	  1799:   asc "ORA",$05
00:A2F0 05
00:A2F1 524F4C          	  1800:   asc "ROL",$26
00:A2F4 26
00:A2F5 524F52          	  1801:   asc "ROR",$66
00:A2F8 66
00:A2F9 534243          	  1802:   asc "SBC",$E5
00:A2FC E5
00:A2FD 535441          	  1803:   asc "STA",$85
00:A300 85
00:A301 535458          	  1804:   asc "STX",$86
00:A304 86
00:A305 535459          	  1805:   asc "STY",$84
00:A308 84
00:A309 53545A          	  1806:   asc "STZ",$64
00:A30C 64
00:A30D 545242          	  1807:   asc "TRB",$14
00:A310 14
00:A311 545342          	  1808:   asc "TSB",$04
00:A314 04
00:A315 00              	  1809:   dfb 0
                        	  1810: 
                        	  1811: ;------------------------------------
                        	  1812: ;  ASS_OPERAND_ZERO_PAGE  - for tokenised opcodes like AND
                        	  1813: ;------------------------------------
                        	  1814: OPCODE_ASS_OPERAND_ZERO_PAGE_TOKENISED = *
00:A316 8D              	  1815:   dfb TOKEN_AND,$25
00:A317 25
00:A318 00              	  1816:   dfb 0
                        	  1817: 
                        	  1818: 
                        	  1819: ;------------------------------------
                        	  1820: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
                        	  1821: ;------------------------------------
                        	  1822: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT = *
00:A319 414443          	  1823:   asc "ADC",$61
00:A31C 61
00:A31D 414E44          	  1824:   asc "AND",$21
00:A320 21
00:A321 434D50          	  1825:   asc "CMP",$C1
00:A324 C1
00:A325 454F52          	  1826:   asc "EOR",$41
00:A328 41
00:A329 4C4441          	  1827:   asc "LDA",$A1
00:A32C A1
00:A32D 4F5241          	  1828:   asc "ORA",$01
00:A330 01
00:A331 534243          	  1829:   asc "SBC",$E1
00:A334 E1
00:A335 535441          	  1830:   asc "STA",$81
00:A338 81
00:A339 00              	  1831:   dfb 0
                        	  1832: 
                        	  1833: ;------------------------------------
                        	  1834: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT  - for tokenised opcodes like AND
                        	  1835: ;------------------------------------
                        	  1836: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT_TOKENISED  = *
00:A33A 8D              	  1837:   dfb TOKEN_AND,$21
00:A33B 21
00:A33C 00              	  1838:   dfb 0
                        	  1839: 
                        	  1840: 
                        	  1841: ;------------------------------------
                        	  1842: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
                        	  1843: ;------------------------------------
                        	  1844: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X = *
00:A33D 414443          	  1845:   asc "ADC",$75
00:A340 75
00:A341 414E44          	  1846:   asc "AND",$35
00:A344 35
00:A345 41534C          	  1847:   asc "ASL",$16
00:A348 16
00:A349 424954          	  1848:   asc "BIT",$34
00:A34C 34
00:A34D 434D50          	  1849:   asc "CMP",$D5
00:A350 D5
00:A351 444543          	  1850:   asc "DEC",$D6
00:A354 D6
00:A355 454F52          	  1851:   asc "EOR",$55
00:A358 55
00:A359 494E43          	  1852:   asc "INC",$F6
00:A35C F6
00:A35D 4C4441          	  1853:   asc "LDA",$B5
00:A360 B5
00:A361 4C4459          	  1854:   asc "LDY",$B4
00:A364 B4
00:A365 4C5352          	  1855:   asc "LSR",$56
00:A368 56
00:A369 4F5241          	  1856:   asc "ORA",$15
00:A36C 15
00:A36D 524F4C          	  1857:   asc "ROL",$36
00:A370 36
00:A371 524F52          	  1858:   asc "ROR",$76
00:A374 76
00:A375 534243          	  1859:   asc "SBC",$F5
00:A378 F5
00:A379 535441          	  1860:   asc "STA",$95
00:A37C 95
00:A37D 535459          	  1861:   asc "STY",$94
00:A380 94
00:A381 53545A          	  1862:   asc "STZ",$74
00:A384 74
00:A385 00              	  1863:   dfb 0
                        	  1864: 
                        	  1865: ;------------------------------------
                        	  1866: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X  - for tokenised opcodes like AND
                        	  1867: ;------------------------------------
                        	  1868: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X_TOKENISED = *
00:A386 8D              	  1869:   dfb TOKEN_AND,$35
00:A387 35
00:A388 00              	  1870:   dfb 0
                        	  1871: 
                        	  1872: ;------------------------------------
                        	  1873: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
                        	  1874: ;------------------------------------
                        	  1875: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y = *
00:A389 4C4458          	  1876:   asc "LDX",$B6
00:A38C B6
00:A38D 535458          	  1877:   asc "STX",$96
00:A390 96
00:A391 00              	  1878:   dfb 0
                        	  1879: 
                        	  1880: ;------------------------------------
                        	  1881: ;  ASS_OPERAND_ZERO_PAGE_INDIRECT
                        	  1882: ;------------------------------------
                        	  1883: OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT = *
00:A392 414443          	  1884:   asc "ADC",$72
00:A395 72
00:A396 414E44          	  1885:   asc "AND",$32
00:A399 32
00:A39A 434D50          	  1886:   asc "CMP",$D2
00:A39D D2
00:A39E 454F52          	  1887:   asc "EOR",$52
00:A3A1 52
00:A3A2 4C4441          	  1888:   asc "LDA",$B2
00:A3A5 B2
00:A3A6 4F5241          	  1889:   asc "ORA",$12
00:A3A9 12
00:A3AA 534243          	  1890:   asc "SBC",$F2
00:A3AD F2
00:A3AE 535441          	  1891:   asc "STA",$92
00:A3B1 92
00:A3B2 00              	  1892:   dfb 0
                        	  1893: 
                        	  1894: ;------------------------------------
                        	  1895: ;  ASS_OPERAND_ZERO_PAGE_INDIRECT  - for tokenised opcodes like AND
                        	  1896: ;------------------------------------
                        	  1897: OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_TOKENISED = *
00:A3B3 8D              	  1898:   dfb TOKEN_AND,$32
00:A3B4 32
00:A3B5 00              	  1899:   dfb 0
                        	  1900: 
                        	  1901: ;------------------------------------
                        	  1902: ;  ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
                        	  1903: ;------------------------------------
                        	  1904: OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y = *
00:A3B6 414443          	  1905:   asc "ADC",$71
00:A3B9 71
00:A3BA 414E44          	  1906:   asc "AND",$31
00:A3BD 31
00:A3BE 434D50          	  1907:   asc "CMP",$D1
00:A3C1 D1
00:A3C2 454F52          	  1908:   asc "EOR",$51
00:A3C5 51
00:A3C6 4C4441          	  1909:   asc "LDA",$B1
00:A3C9 B1
00:A3CA 4F5241          	  1910:   asc "ORA",$11
00:A3CD 11
00:A3CE 534243          	  1911:   asc "SBC",$F1
00:A3D1 F1
00:A3D2 535441          	  1912:   asc "STA",$91
00:A3D5 91
00:A3D6 00              	  1913:   dfb 0
                        	  1914: 
                        	  1915: ;------------------------------------
                        	  1916: ;  ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y - for tokenised opcodes like AND
                        	  1917: ;------------------------------------
                        	  1918: OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y_TOKENISED  = *
00:A3D7 8D              	  1919:   dfb TOKEN_AND,$31
00:A3D8 31
00:A3D9 00              	  1920:   dfb 0
                        	  1921: 
                        	  1922: 
                        	  1923: ; ---------------------------
                        	  1924: ; Compiler directives
                        	  1925: ; ---------------------------
                        	  1926: 
                        	  1927: ;
                        	  1928: ;  ASSERT <expression>  - raises an error if <expression> is zero
                        	  1929: ;
                        	  1930: asm_do_assert:
00:A3DA A56B            	  1931:   lda ASS_OPERAND
00:A3DC C901            	  1932:   cmp #ASS_OPERAND_ABSOLUTE
00:A3DE D00E            	  1933:   bne asm_do_constant_expectedJ
00:A3E0 A500            	  1934:   lda VALUE
00:A3E2 0501            	  1935:   ora VALUE+1
00:A3E4 0502            	  1936:   ora VALUE+2
00:A3E6 F001            	  1937:   beq asm_do_assert_failed
00:A3E8 60              	  1938:   rts
                        	  1939: 
                        	  1940: asm_do_assert_failed:
00:A3E9 A234            	  1941:   ldx #52
00:A3EB 4CB49E          	  1942:   jmp ass_error
                        	  1943: 
00:A3EE 4C86A4          	  1944: asm_do_constant_expectedJ jmp asm_do_constant_expected
                        	  1945: 
                        	  1946: ;
                        	  1947: ; LIST (0= none, 1=source, 2=opcodes, 4=symbols, can OR these together)
                        	  1948: ; LIST  is the same as LIST 3
                        	  1949: 
                        	  1950: asm_do_list = *
                        	  1951: 
                        	  1952: ;   lda #'f'
                        	  1953: ;   jsr ass_debug_point
                        	  1954: 
00:A3F1 A56B            	  1955:   lda ASS_OPERAND
00:A3F3 C908            	  1956:   cmp #ASS_OPERAND_IMPLIED      ; implied (ie. no operand) will resolve to be the same as LIST 3
00:A3F5 F01A            	  1957:   beq asm_do_list_no_operand
00:A3F7 C901            	  1958:   cmp #ASS_OPERAND_ABSOLUTE
00:A3F9 F01A            	  1959:   beq asm_do_list_ok
00:A3FB A202            	  1960:   ldx #2    ; ERROR: constant expected
00:A3FD 4CB49E          	  1961:   jmp ass_error
                        	  1962: 
                        	  1963: ;
                        	  1964: ;  NOLIST is the same as LIST 0
                        	  1965: ;
                        	  1966: asm_do_nolist:
00:A400 A56B            	  1967:   lda ASS_OPERAND
00:A402 C908            	  1968:   cmp #ASS_OPERAND_IMPLIED
00:A404 F005            	  1969:   beq asm_do_nolist_ok              ; should have no operand
00:A406 A217            	  1970:   ldx #23   ; ERROR: Illegal factor
00:A408 4CB49E          	  1971:   jmp ass_error
                        	  1972: asm_do_nolist_ok:
00:A40B A900            	  1973:   lda #0
00:A40D 8500            	  1974:   sta VALUE
00:A40F 8004            	  1975:   bra asm_do_list_ok
                        	  1976: 
                        	  1977: asm_do_list_no_operand:
00:A411 A903            	  1978:   lda #3
00:A413 8573            	  1979:   sta ASS_VALUE
                        	  1980: asm_do_list_ok:
00:A415 A576            	  1981:   lda ASS_PASS
00:A417 F025            	  1982:   beq asm_do_list_first_pass  ; ignore on first pass
                        	  1983: 
                        	  1984: ;  lda ASS_VALUE
                        	  1985: ;  clc
                        	  1986: ;  adc #'0'
                        	  1987: ;  jsr ass_debug_point
                        	  1988: 
00:A419 A573            	  1989:   lda ASS_VALUE
00:A41B 2901            	  1990:   and #$01
00:A41D F00C            	  1991:   beq asm_do_list_not    ; no listing wanted
00:A41F A904            	  1992:   lda #FLAG_LIST_SOURCE ; already listing?
00:A421 25BE            	  1993:   and system_flags
00:A423 D00A            	  1994:   bne  asm_do_list1   ; yep
00:A425 A904            	  1995:   lda #FLAG_LIST_SOURCE
00:A427 04BE            	  1996:   tsb system_flags
                        	  1997: ;  jsr token_line        ; list the current line  TODO: don't know, I think it bumps the line number wrongly
00:A429 8004            	  1998:   bra asm_do_list1
                        	  1999: 
                        	  2000: ;
                        	  2001: ;  turn off list flag
                        	  2002: ;
                        	  2003: asm_do_list_not:
00:A42B A904            	  2004:   lda #FLAG_LIST_SOURCE
00:A42D 14BE            	  2005:   trb system_flags
                        	  2006: 
                        	  2007: asm_do_list1:
                        	  2008: 
                        	  2009: 
00:A42F A573            	  2010:   lda ASS_VALUE
00:A431 2902            	  2011:   and #$02
00:A433 852E            	  2012:   sta DCODE
                        	  2013: 
                        	  2014: 
00:A435 A573            	  2015:   lda ASS_VALUE
00:A437 2904            	  2016:   and #$04
00:A439 8582            	  2017:   sta show_symbols
                        	  2018: ;
                        	  2019: ;  output a newline, to get past the asterisks
                        	  2020: ;
00:A43B 202892          	  2021:   jsr CROUT
                        	  2022: asm_do_list_first_pass:
00:A43E 60              	  2023:   rts
                        	  2024: 
                        	  2025: ;
                        	  2026: ;  ASC "String"
                        	  2027: ;
                        	  2028: asm_do_asc = *
00:A43F A56B            	  2029:   lda ASS_OPERAND
00:A441 C911            	  2030:   cmp #ASS_OPERAND_STRING
00:A443 F005            	  2031:   beq asm_do_asc_ok
00:A445 A208            	  2032:   ldx #8    ; ERROR: incorrect string
00:A447 4CB49E          	  2033:   jmp ass_error
                        	  2034: ;
                        	  2035: ;  now emit the string
                        	  2036: ;
                        	  2037: asm_do_asc_ok:
00:A44A A000            	  2038:   ldy  #0
                        	  2039: asm_do_asc_loop:
00:A44C B90002          	  2040:   lda  INBUF,Y
00:A44F C8              	  2041:   iny         ; onto next character in the string
00:A450 5A              	  2042:   phy
00:A451 20769E          	  2043:   jsr ass_emit
00:A454 7A              	  2044:   ply
                        	  2045: 
                        	  2046: asm_do_asc_next:
00:A455 C692            	  2047:   dec token_length
00:A457 D0F3            	  2048:   bne asm_do_asc_loop
00:A459 60              	  2049:   rts
                        	  2050: 
                        	  2051: 
                        	  2052: ;
                        	  2053: ;  ASCIIZ / STRING - output a string with a null terminator
                        	  2054: ;
                        	  2055: 
                        	  2056: asm_do_string:
00:A45A 203FA4          	  2057:   jsr asm_do_asc    ; do the string
00:A45D A900            	  2058:   lda #0            ; and the terminator
00:A45F 20769E          	  2059:   jsr ass_emit
00:A462 60              	  2060:   rts
                        	  2061: 
                        	  2062: 
                        	  2063: ;
                        	  2064: ;  EQU
                        	  2065: ;
                        	  2066: ;  The label, which must be present, takes on the value of the expression
                        	  2067: ;
                        	  2068: 
                        	  2069: asm_do_equ:
00:A463 A56B            	  2070:   lda ASS_OPERAND
00:A465 C901            	  2071:   cmp #ASS_OPERAND_ABSOLUTE
00:A467 D01D            	  2072:   bne asm_do_constant_expected
00:A469 A583            	  2073:   lda ass_current_label
00:A46B 0584            	  2074:   ora ass_current_label+1
00:A46D D005            	  2075:   bne asm_do_equ_have_label
00:A46F A230            	  2076:   ldx #48    ; ERROR: label required
00:A471 4CB49E          	  2077:   jmp ass_error
                        	  2078: 
                        	  2079: asm_do_equ_have_label:
00:A474 A004            	  2080:   ldy #SYMDSP
00:A476 A573            	  2081:   lda ASS_VALUE
00:A478 9183            	  2082:   sta (ass_current_label),y
00:A47A C8              	  2083:   iny
00:A47B A574            	  2084:   lda ASS_VALUE+1
00:A47D 9183            	  2085:   sta (ass_current_label),y
00:A47F 60              	  2086:   rts
                        	  2087: 
                        	  2088: ;
                        	  2089: ;  ORG
                        	  2090: ;
                        	  2091: ;  The program counter becomes the value of the expression
                        	  2092: ;
                        	  2093: 
                        	  2094: asm_do_org:
00:A480 A56B            	  2095:   lda ASS_OPERAND
00:A482 C901            	  2096:   cmp #ASS_OPERAND_ABSOLUTE
00:A484 F005            	  2097:   beq asm_do_org_ok
                        	  2098: asm_do_constant_expected:
00:A486 A202            	  2099:   ldx #2    ; ERROR: constant expected
00:A488 4CB49E          	  2100:   jmp ass_error
                        	  2101: 
                        	  2102: asm_do_org_ok:
00:A48B A573            	  2103:   lda ASS_VALUE
00:A48D 8523            	  2104:   sta PCODE
00:A48F A574            	  2105:   lda ASS_VALUE+1
00:A491 8524            	  2106:   sta PCODE+1
00:A493 60              	  2107:   rts
                        	  2108: 
                        	  2109: ;
                        	  2110: ;  DFB - define one byte (value being the expression)
                        	  2111: ;
                        	  2112: 
                        	  2113: asm_do_dfb:
00:A494 A56B            	  2114:   lda ASS_OPERAND
00:A496 C912            	  2115:   cmp #ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE  ; multiple values?
00:A498 F008            	  2116:   beq asm_do_dfb_multiple
00:A49A C901            	  2117:   cmp #ASS_OPERAND_ABSOLUTE
00:A49C D0E8            	  2118:   bne asm_do_constant_expected
00:A49E 20C6A4          	  2119:   jsr asm_emit_one_byte
00:A4A1 60              	  2120:   rts
                        	  2121: 
                        	  2122: ;
                        	  2123: ;  so if we got here we thought we had two values (like a BBR0 $12,foo)
                        	  2124: ;  - the first is in REMAIN and the other in VALUE
                        	  2125: ;
                        	  2126: ;  let's emit REMAIN, then VALUE, then look for other values
                        	  2127: ;
                        	  2128: asm_do_dfb_multiple:
00:A4A2 A507            	  2129:   lda REMAIN+1
00:A4A4 D01B            	  2130:   bne asm_do_dfb_too_big
00:A4A6 A508            	  2131:   lda REMAIN+2
00:A4A8 D017            	  2132:   bne asm_do_dfb_too_big
00:A4AA A506            	  2133:   lda REMAIN
00:A4AC 20769E          	  2134:   jsr ass_emit  ; emit REMAIN
                        	  2135: asm_do_dfb_multiple_loop:
00:A4AF 20C6A4          	  2136:   jsr asm_emit_one_byte  ; emit VALUE
00:A4B2 A593            	  2137:   lda token_type
00:A4B4 C92C            	  2138:   cmp #','      ; another?
00:A4B6 D008            	  2139:   bne asm_do_dfb_multiple_done
00:A4B8 20F2C8          	  2140:   jsr get_token
00:A4BB 20E19C          	  2141:   jsr ass_get_value  ; should have some sort of address now in VALUE
00:A4BE 80EF            	  2142:   bra asm_do_dfb_multiple_loop
                        	  2143: 
                        	  2144: asm_do_dfb_multiple_done:
00:A4C0 60              	  2145:   rts
                        	  2146: 
                        	  2147: 
                        	  2148: asm_do_dfb_too_big:
00:A4C1 A22C            	  2149:   ldx #44
00:A4C3 4CB49E          	  2150:   jmp ass_error
                        	  2151: 
                        	  2152: asm_emit_one_byte:
00:A4C6 A574            	  2153:   lda ASS_VALUE+1
00:A4C8 D0F7            	  2154:   bne asm_do_dfb_too_big
00:A4CA A575            	  2155:   lda ASS_VALUE+2
00:A4CC D0F3            	  2156:   bne asm_do_dfb_too_big
00:A4CE A573            	  2157:   lda ASS_VALUE
00:A4D0 20769E          	  2158:   jsr ass_emit
00:A4D3 60              	  2159:   rts
                        	  2160: 
                        	  2161: 
                        	  2162: ;
                        	  2163: ;  DFW - define two bytes (value being the expression)
                        	  2164: ;
                        	  2165: 
                        	  2166: asm_do_dfw:
00:A4D4 A56B            	  2167:   lda ASS_OPERAND
00:A4D6 C912            	  2168:   cmp #ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE  ; multiple values?
00:A4D8 F008            	  2169:   beq asm_do_dfw_multiple
00:A4DA C901            	  2170:   cmp #ASS_OPERAND_ABSOLUTE
00:A4DC D0A8            	  2171:   bne asm_do_constant_expected
00:A4DE 2002A5          	  2172:   jsr asm_emit_two_bytes
00:A4E1 60              	  2173:   rts
                        	  2174: 
                        	  2175: ;
                        	  2176: ;  so if we got here we thought we had two values (like a BBR0 $12,foo)
                        	  2177: ;  - the first is in REMAIN and the other in VALUE
                        	  2178: ;
                        	  2179: ;  let's emit REMAIN, then VALUE, then look for other values
                        	  2180: ;
                        	  2181: asm_do_dfw_multiple:
00:A4E2 A508            	  2182:   lda REMAIN+2
00:A4E4 D0DB            	  2183:   bne asm_do_dfb_too_big
00:A4E6 A506            	  2184:   lda REMAIN
00:A4E8 20769E          	  2185:   jsr ass_emit  ; emit REMAIN
00:A4EB A507            	  2186:   lda REMAIN+1
00:A4ED 20769E          	  2187:   jsr ass_emit  ; emit REMAIN+1
                        	  2188: asm_do_dfw_multiple_loop:
00:A4F0 2002A5          	  2189:   jsr asm_emit_two_bytes  ; emit VALUE
00:A4F3 A593            	  2190:   lda token_type
00:A4F5 C92C            	  2191:   cmp #','      ; another?
00:A4F7 D008            	  2192:   bne asm_do_dfw_multiple_done
00:A4F9 20F2C8          	  2193:   jsr get_token
00:A4FC 20E19C          	  2194:   jsr ass_get_value  ; should have some sort of address now in VALUE
00:A4FF 80EF            	  2195:   bra asm_do_dfw_multiple_loop
                        	  2196: 
                        	  2197: asm_do_dfw_multiple_done:
00:A501 60              	  2198:   rts
                        	  2199: 
                        	  2200: 
                        	  2201: asm_emit_two_bytes:
00:A502 A575            	  2202:   lda ASS_VALUE+2
00:A504 D0BB            	  2203:   bne asm_do_dfb_too_big
00:A506 A573            	  2204:   lda ASS_VALUE
00:A508 20769E          	  2205:   jsr ass_emit
00:A50B A574            	  2206:   lda ASS_VALUE+1
00:A50D 20769E          	  2207:   jsr ass_emit
00:A510 60              	  2208:   rts
                        	  2209: 
                        	  2210: 
                        	  2211: 
                        	  2212: ;
                        	  2213: ;  BLK - zero fill <expression> bytes (eg. BLK 5 output 5 zeroes)
                        	  2214: ;
                        	  2215: 
                        	  2216: asm_do_blk:
00:A511 A56B            	  2217:   lda ASS_OPERAND
00:A513 C901            	  2218:   cmp #ASS_OPERAND_ABSOLUTE
00:A515 D030            	  2219:   bne asm_do_constant_expectedJ2
00:A517 A575            	  2220:   lda ASS_VALUE+2
00:A519 D0A6            	  2221:   bne asm_do_dfb_too_big
                        	  2222: ;
                        	  2223: ; handle (obscure) case of them defining zero bytes
                        	  2224: ;
00:A51B A573            	  2225:   lda ASS_VALUE
00:A51D 0574            	  2226:   ora ASS_VALUE+1
00:A51F F00D            	  2227:   beq asm_do_blk_done
                        	  2228: asm_do_blk_loop:
                        	  2229: ;
                        	  2230: ;  emit one zero
                        	  2231: ;
00:A521 A900            	  2232:   lda #0
00:A523 20769E          	  2233:   jsr ass_emit
00:A526 C673            	  2234:   dec ASS_VALUE
00:A528 D0F7            	  2235:   bne asm_do_blk_loop
00:A52A C674            	  2236:   dec ASS_VALUE+1
00:A52C 10F3            	  2237:   bpl asm_do_blk_loop
                        	  2238: asm_do_blk_done:
00:A52E 60              	  2239:   rts
                        	  2240: 
                        	  2241: ;
                        	  2242: ;  RESERVE - reserve <expression> bytes without writing to them
                        	  2243: ;   useful for leaving a gap (eg. for zero-page variables)
                        	  2244: ;
                        	  2245: 
                        	  2246: asm_do_reserve:
00:A52F A56B            	  2247:   lda ASS_OPERAND
00:A531 C901            	  2248:   cmp #ASS_OPERAND_ABSOLUTE
00:A533 D012            	  2249:   bne asm_do_constant_expectedJ2
00:A535 A575            	  2250:   lda ASS_VALUE+2
00:A537 D088            	  2251:   bne asm_do_dfb_too_big
00:A539 18              	  2252:   clc
00:A53A A523            	  2253:   lda PCODE
00:A53C 6573            	  2254:   adc ASS_VALUE
00:A53E 8523            	  2255:   sta PCODE
00:A540 A524            	  2256:   lda PCODE+1
00:A542 6574            	  2257:   adc ASS_VALUE+1
00:A544 8524            	  2258:   sta PCODE+1
00:A546 60              	  2259:   rts
                        	  2260: 
00:A547 4C86A4          	  2261: asm_do_constant_expectedJ2 jmp asm_do_constant_expected
                        	  2262: 
                        	  2263: ;
                        	  2264: ;  SYM <address> symbol table relocation
                        	  2265: ;
                        	  2266: asm_do_sym:
00:A54A A56B            	  2267:   lda ASS_OPERAND
00:A54C C901            	  2268:   cmp #ASS_OPERAND_ABSOLUTE
00:A54E D0F7            	  2269:   bne asm_do_constant_expectedJ2
                        	  2270: ;
                        	  2271: ;  only relocate symbol table on the first pass
                        	  2272: ;
00:A550 A576            	  2273:   lda ASS_PASS
00:A552 D00F            	  2274:   bne asm_do_sym_done
                        	  2275: 
00:A554 A573            	  2276:   lda  ASS_VALUE
00:A556 8531            	  2277:   sta  ENDSYM
00:A558 852F            	  2278:   sta  STARTSYM
00:A55A A574            	  2279:   lda  ASS_VALUE+1
00:A55C 8532            	  2280:   sta  ENDSYM+1        ; store symbol table address
00:A55E 8530            	  2281:   sta  STARTSYM+1
                        	  2282: ;
                        	  2283: ;  put our library functions back into the symbol table
                        	  2284: ;
00:A560 20F8A9          	  2285:   jsr  add_assembler_library_functions  ; add our inbuilt functions to the symbol table
                        	  2286: 
                        	  2287: asm_do_sym_done:
00:A563 60              	  2288:   rts
                        	  2289: ;
                        	  2290: 
                        	  2291: 
00:A564 41646472204E616D	  2292: info_message asciiz "Addr Name\n"
00:A56C 650A
00:A56E 00
                        	  2293: 
                        	  2294: list_symbols  = *
00:A56F A964            	  2295:          lda #<info_message
00:A571 A2A5            	  2296:          ldx #>info_message
00:A573 202682          	  2297:          jsr print
                        	  2298: 
00:A576 A532            	  2299:          lda  ENDSYM+1    ; get the end of the symbol table
00:A578 8541            	  2300:          sta  SYMITM+1    ; make it the current symbol
00:A57A A531            	  2301:          lda  ENDSYM
00:A57C 800B            	  2302:          bra  list_symbols_check
                        	  2303: 
                        	  2304: list_symbols_next =  *
00:A57E A000            	  2305:          ldy  #SYMPRV
00:A580 B140            	  2306:          lda  (SYMITM),Y
00:A582 AA              	  2307:          tax
00:A583 C8              	  2308:          iny
00:A584 B140            	  2309:          lda  (SYMITM),Y
00:A586 8541            	  2310:          sta  SYMITM+1   ; previous link
00:A588 8A              	  2311:          txa
                        	  2312: ;
                        	  2313: ;  go to the previous symbol table item
                        	  2314: ;
                        	  2315: list_symbols_check     =  *
00:A589 8540            	  2316:          sta  SYMITM
00:A58B C52F            	  2317:          cmp  STARTSYM
00:A58D D009            	  2318:          bne  list_symbols_line
00:A58F A541            	  2319:          lda  SYMITM+1
00:A591 C530            	  2320:          cmp  STARTSYM+1
00:A593 D003            	  2321:          bne  list_symbols_line       ; more to go
00:A595 4CC3A5          	  2322:          jmp  list_symbols_done       ; finished if symitm and symitm+1 are both zero
                        	  2323: 
                        	  2324: list_symbols_line = *
00:A598 A004            	  2325:          ldy  #SYMDSP
00:A59A C8              	  2326:          iny
00:A59B B140            	  2327:          lda  (SYMITM),Y  ; displacement
00:A59D 209D92          	  2328:          jsr  PRBYTE
00:A5A0 88              	  2329:          dey
00:A5A1 B140            	  2330:          lda  (SYMITM),Y  ; displacement
00:A5A3 209D92          	  2331:          jsr  PRBYTE
00:A5A6 A920            	  2332:          lda  #' '
00:A5A8 208592          	  2333:          jsr  PRCHAR
00:A5AB A009            	  2334:          ldy  #SYMLEN
00:A5AD B140            	  2335:          lda  (SYMITM),Y  ; length
00:A5AF AA              	  2336:          tax
00:A5B0 A00A            	  2337:          ldy  #SYMNAM
                        	  2338: list_symbols_name = *
00:A5B2 B140            	  2339:          lda  (SYMITM),Y  ; name
00:A5B4 5A              	  2340:          phy
00:A5B5 208592          	  2341:          jsr  PRCHAR
00:A5B8 7A              	  2342:          ply
00:A5B9 C8              	  2343:          iny
00:A5BA CA              	  2344:          dex
00:A5BB D0F5            	  2345:          bne list_symbols_name
00:A5BD 202892          	  2346:          jsr CROUT
00:A5C0 4C7EA5          	  2347:          jmp list_symbols_next
                        	  2348: 
                        	  2349: list_symbols_done = *
00:A5C3 60              	  2350:          rts
                        	  2351: 
                        	  2352: assembler_library_functions_table:
                        	  2353: ;
                        	  2354: ;  put them in reverse alphabetic order so they come out in alphabetic
                        	  2355: ;  order if you request a symbols list
                        	  2356: ;
                        	  2357:   makeAsmLibraryFunction "write_to_serial",      write_to_serial
00:A5C4 77726974655F746F	     1M      asciiz   "write_to_serial"
00:A5CC 5F73657269616C
00:A5D3 00
00:A5D4 60C8            	     2M      word     write_to_serial
                        	  2358:   makeAsmLibraryFunction "write_to_lcd",         write_to_lcd
00:A5D6 77726974655F746F	     1M      asciiz   "write_to_lcd"
00:A5DE 5F6C6364
00:A5E2 00
00:A5E3 6BC8            	     2M      word     write_to_lcd
                        	  2359:   makeAsmLibraryFunction "write_function",       write_function
00:A5E5 77726974655F6675	     1M      asciiz   "write_function"
00:A5ED 6E6374696F6E
00:A5F3 00
00:A5F4 1700            	     2M      word     write_function
                        	  2360:   makeAsmLibraryFunction "write_char",           write_char
00:A5F6 77726974655F6368	     1M      asciiz   "write_char"
00:A5FE 6172
00:A600 00
00:A601 BCC8            	     2M      word     write_char
                        	  2361:   makeAsmLibraryFunction "value",                VALUE
00:A603 76616C7565      	     1M      asciiz   "value"
00:A608 00
00:A609 0000            	     2M      word     VALUE
                        	  2362:   makeAsmLibraryFunction "value2",               VALUE2
00:A60B 76616C756532    	     1M      asciiz   "value2"
00:A611 00
00:A612 0300            	     2M      word     VALUE2
                        	  2363:   makeAsmLibraryFunction "typing_latency",       typing_latency
00:A614 747970696E675F6C	     1M      asciiz   "typing_latency"
00:A61C 6174656E6379
00:A622 00
00:A623 0D00            	     2M      word     typing_latency
                        	  2364:   makeAsmLibraryFunction "tknjmp",               TKNJMP
00:A625 746B6E6A6D70    	     1M      asciiz   "tknjmp"
00:A62B 00
00:A62C 928F            	     2M      word     TKNJMP
                        	  2365:   makeAsmLibraryFunction "start",                START
00:A62E 7374617274      	     1M      asciiz   "start"
00:A633 00
00:A634 31CF            	     2M      word     START
                        	  2366:   makeAsmLibraryFunction "srce",                 SRCE
00:A636 73726365        	     1M      asciiz   "srce"
00:A63A 00
00:A63B 0000            	     2M      word     SRCE
                        	  2367:   makeAsmLibraryFunction "serial_print_message", serial_print_message
00:A63D 73657269616C5F70	     1M      asciiz   "serial_print_message"
00:A645 72696E745F6D6573
00:A64D 73616765
00:A651 00
00:A652 E1C8            	     2M      word     serial_print_message
                        	  2368:   makeAsmLibraryFunction "serial_available",     serial_available
00:A654 73657269616C5F61	     1M      asciiz   "serial_available"
00:A65C 7661696C61626C65
00:A664 00
00:A665 87C8            	     2M      word     serial_available
                        	  2369:   makeAsmLibraryFunction "restart",              RESTART
00:A667 72657374617274  	     1M      asciiz   "restart"
00:A66E 00
00:A66F 55CF            	     2M      word     RESTART
                        	  2370:   makeAsmLibraryFunction "remain",               REMAIN
00:A671 72656D61696E    	     1M      asciiz   "remain"
00:A677 00
00:A678 0600            	     2M      word     REMAIN
                        	  2371:   makeAsmLibraryFunction "random",               random
00:A67A 72616E646F6D    	     1M      asciiz   "random"
00:A680 00
00:A681 0900            	     2M      word     random
                        	  2372:   makeAsmLibraryFunction "putsp",                PUTSP
00:A683 7075747370      	     1M      asciiz   "putsp"
00:A688 00
00:A689 B392            	     2M      word     PUTSP
                        	  2373:   makeAsmLibraryFunction "print",                print
00:A68B 7072696E74      	     1M      asciiz   "print"
00:A690 00
00:A691 2682            	     2M      word     print
                        	  2374:   makeAsmLibraryFunction "prchar",               PRCHAR
00:A693 707263686172    	     1M      asciiz   "prchar"
00:A699 00
00:A69A 8592            	     2M      word     PRCHAR
                        	  2375:   makeAsmLibraryFunction "prbyte",               PRBYTE
00:A69C 707262797465    	     1M      asciiz   "prbyte"
00:A6A2 00
00:A6A3 9D92            	     2M      word     PRBYTE
                        	  2376:   makeAsmLibraryFunction "pinmode",              pinmode
00:A6A5 70696E6D6F6465  	     1M      asciiz   "pinmode"
00:A6AC 00
00:A6AD E5C7            	     2M      word     pinmode
                        	  2377:   makeAsmLibraryFunction "lcd_wait",             lcd_wait
00:A6AF 6C63645F77616974	     1M      asciiz   "lcd_wait"
00:A6B7 00
00:A6B8 C6B7            	     2M      word     lcd_wait
                        	  2378:   makeAsmLibraryFunction "lcd_second_line",      lcd_second_line
00:A6BA 6C63645F7365636F	     1M      asciiz   "lcd_second_line"
00:A6C2 6E645F6C696E65
00:A6C9 00
00:A6CA 56B8            	     2M      word     lcd_second_line
                        	  2379:   makeAsmLibraryFunction "lcd_print_message",    lcd_print_message
00:A6CC 6C63645F7072696E	     1M      asciiz   "lcd_print_message"
00:A6D4 745F6D6573736167
00:A6DC 65
00:A6DD 00
00:A6DE 66B8            	     2M      word     lcd_print_message
                        	  2380:   makeAsmLibraryFunction "lcd_print_char",       lcd_print_char
00:A6E0 6C63645F7072696E	     1M      asciiz   "lcd_print_char"
00:A6E8 745F63686172
00:A6EE 00
00:A6EF 1CB8            	     2M      word     lcd_print_char
                        	  2381:   makeAsmLibraryFunction "lcd_instruction",      lcd_instruction
00:A6F1 6C63645F696E7374	     1M      asciiz   "lcd_instruction"
00:A6F9 72756374696F6E
00:A700 00
00:A701 FAB7            	     2M      word     lcd_instruction
                        	  2382:   makeAsmLibraryFunction "lcd_home",             lcd_home
00:A703 6C63645F686F6D65	     1M      asciiz   "lcd_home"
00:A70B 00
00:A70C 5EB8            	     2M      word     lcd_home
                        	  2383:   makeAsmLibraryFunction "lcd_get_address",      lcd_get_address
00:A70E 6C63645F6765745F	     1M      asciiz   "lcd_get_address"
00:A716 61646472657373
00:A71D 00
00:A71E DAB7            	     2M      word     lcd_get_address
                        	  2384:   makeAsmLibraryFunction "lcd_clear_display",    lcd_clear_display
00:A720 6C63645F636C6561	     1M      asciiz   "lcd_clear_display"
00:A728 725F646973706C61
00:A730 79
00:A731 00
00:A732 4EB8            	     2M      word     lcd_clear_display
                        	  2385:   makeAsmLibraryFunction "isxdigit",             isxdigit
00:A734 6973786469676974	     1M      asciiz   "isxdigit"
00:A73C 00
00:A73D 3E81            	     2M      word     isxdigit
                        	  2386:   makeAsmLibraryFunction "isupper",              isupper
00:A73F 69737570706572  	     1M      asciiz   "isupper"
00:A746 00
00:A747 0E81            	     2M      word     isupper
                        	  2387:   makeAsmLibraryFunction "isspace",              isspace
00:A749 69737370616365  	     1M      asciiz   "isspace"
00:A750 00
00:A751 4A81            	     2M      word     isspace
                        	  2388:   makeAsmLibraryFunction "islower",              islower
00:A753 69736C6F776572  	     1M      asciiz   "islower"
00:A75A 00
00:A75B 1A81            	     2M      word     islower
                        	  2389:   makeAsmLibraryFunction "isdigit",              isdigit
00:A75D 69736469676974  	     1M      asciiz   "isdigit"
00:A764 00
00:A765 3281            	     2M      word     isdigit
                        	  2390:   makeAsmLibraryFunction "iscntrl",              iscntrl
00:A767 6973636E74726C  	     1M      asciiz   "iscntrl"
00:A76E 00
00:A76F 5681            	     2M      word     iscntrl
                        	  2391:   makeAsmLibraryFunction "isalpha",              isalpha
00:A771 6973616C706861  	     1M      asciiz   "isalpha"
00:A778 00
00:A779 2681            	     2M      word     isalpha
                        	  2392:   makeAsmLibraryFunction "isalnum",              isalnum
00:A77B 6973616C6E756D  	     1M      asciiz   "isalnum"
00:A782 00
00:A783 6281            	     2M      word     isalnum
                        	  2393:   makeAsmLibraryFunction "hardware_init",        hardware_init
00:A785 6861726477617265	     1M      asciiz   "hardware_init"
00:A78D 5F696E6974
00:A792 00
00:A793 8DC8            	     2M      word     hardware_init
                        	  2394:   makeAsmLibraryFunction "getin",                GETIN
00:A795 676574696E      	     1M      asciiz   "getin"
00:A79A 00
00:A79B 76C8            	     2M      word     GETIN
                        	  2395:   makeAsmLibraryFunction "gen_random",           gen_random
00:A79D 67656E5F72616E64	     1M      asciiz   "gen_random"
00:A7A5 6F6D
00:A7A7 00
00:A7A8 DA8F            	     2M      word     gen_random
                        	  2396:   makeAsmLibraryFunction "exp_unary_minus",      exp_unary_minus
00:A7AA 6578705F756E6172	     1M      asciiz   "exp_unary_minus"
00:A7B2 795F6D696E7573
00:A7B9 00
00:A7BA 8AAB            	     2M      word     exp_unary_minus
                        	  2397:   makeAsmLibraryFunction "exp_true",             exp_true
00:A7BC 6578705F74727565	     1M      asciiz   "exp_true"
00:A7C4 00
00:A7C5 6DAA            	     2M      word     exp_true
                        	  2398:   makeAsmLibraryFunction "exp_subtract",         exp_subtract
00:A7C7 6578705F73756274	     1M      asciiz   "exp_subtract"
00:A7CF 72616374
00:A7D3 00
00:A7D4 57AA            	     2M      word     exp_subtract
                        	  2399:   makeAsmLibraryFunction "exp_shift_right",      exp_shift_right
00:A7D6 6578705F73686966	     1M      asciiz   "exp_shift_right"
00:A7DE 745F7269676874
00:A7E5 00
00:A7E6 50AB            	     2M      word     exp_shift_right
                        	  2400:   makeAsmLibraryFunction "exp_shift_left",       exp_shift_left
00:A7E8 6578705F73686966	     1M      asciiz   "exp_shift_left"
00:A7F0 745F6C656674
00:A7F6 00
00:A7F7 37AB            	     2M      word     exp_shift_left
                        	  2401:   makeAsmLibraryFunction "exp_not",              exp_not
00:A7F9 6578705F6E6F74  	     1M      asciiz   "exp_not"
00:A800 00
00:A801 7CAB            	     2M      word     exp_not
                        	  2402:   makeAsmLibraryFunction "exp_neq",              exp_neq
00:A803 6578705F6E6571  	     1M      asciiz   "exp_neq"
00:A80A 00
00:A80B 91AA            	     2M      word     exp_neq
                        	  2403:   makeAsmLibraryFunction "exp_negate",           exp_negate
00:A80D 6578705F6E656761	     1M      asciiz   "exp_negate"
00:A815 7465
00:A817 00
00:A818 69AB            	     2M      word     exp_negate
                        	  2404:   makeAsmLibraryFunction "exp_multiply",         exp_multiply
00:A81A 6578705F6D756C74	     1M      asciiz   "exp_multiply"
00:A822 69706C79
00:A826 00
00:A827 11AC            	     2M      word     exp_multiply
                        	  2405:   makeAsmLibraryFunction "exp_modulo",           exp_modulo
00:A829 6578705F6D6F6475	     1M      asciiz   "exp_modulo"
00:A831 6C6F
00:A833 00
00:A834 AAAC            	     2M      word     exp_modulo
                        	  2406:   makeAsmLibraryFunction "exp_low_byte",         exp_low_byte
00:A836 6578705F6C6F775F	     1M      asciiz   "exp_low_byte"
00:A83E 62797465
00:A842 00
00:A843 9EAB            	     2M      word     exp_low_byte
                        	  2407:   makeAsmLibraryFunction "exp_logical_or",       exp_logical_or
00:A845 6578705F6C6F6769	     1M      asciiz   "exp_logical_or"
00:A84D 63616C5F6F72
00:A853 00
00:A854 16AB            	     2M      word     exp_logical_or
                        	  2408:   makeAsmLibraryFunction "exp_logical_and",      exp_logical_and
00:A856 6578705F6C6F6769	     1M      asciiz   "exp_logical_and"
00:A85E 63616C5F616E64
00:A865 00
00:A866 25AB            	     2M      word     exp_logical_and
                        	  2409:   makeAsmLibraryFunction "exp_less_than",        exp_less_than
00:A868 6578705F6C657373	     1M      asciiz   "exp_less_than"
00:A870 5F7468616E
00:A875 00
00:A876 A5AA            	     2M      word     exp_less_than
                        	  2410:   makeAsmLibraryFunction "exp_leq",              exp_leq
00:A878 6578705F6C6571  	     1M      asciiz   "exp_leq"
00:A87F 00
00:A880 BBAA            	     2M      word     exp_leq
                        	  2411:   makeAsmLibraryFunction "exp_high_byte",        exp_high_byte
00:A882 6578705F68696768	     1M      asciiz   "exp_high_byte"
00:A88A 5F62797465
00:A88F 00
00:A890 A3AB            	     2M      word     exp_high_byte
                        	  2412:   makeAsmLibraryFunction "exp_greater_than",     exp_greater_than
00:A892 6578705F67726561	     1M      asciiz   "exp_greater_than"
00:A89A 7465725F7468616E
00:A8A2 00
00:A8A3 ACAA            	     2M      word     exp_greater_than
                        	  2413:   makeAsmLibraryFunction "exp_geq",              exp_geq
00:A8A5 6578705F676571  	     1M      asciiz   "exp_geq"
00:A8AC 00
00:A8AD CAAA            	     2M      word     exp_geq
                        	  2414:   makeAsmLibraryFunction "exp_false",            exp_false
00:A8AF 6578705F66616C73	     1M      asciiz   "exp_false"
00:A8B7 65
00:A8B8 00
00:A8B9 76AA            	     2M      word     exp_false
                        	  2415:   makeAsmLibraryFunction "exp_eql",              exp_eql
00:A8BB 6578705F65716C  	     1M      asciiz   "exp_eql"
00:A8C2 00
00:A8C3 7DAA            	     2M      word     exp_eql
                        	  2416:   makeAsmLibraryFunction "exp_divide",           exp_divide
00:A8C5 6578705F64697669	     1M      asciiz   "exp_divide"
00:A8CD 6465
00:A8CF 00
00:A8D0 4AAC            	     2M      word     exp_divide
                        	  2417:   makeAsmLibraryFunction "exp_bitwise_xor",      exp_bitwise_xor
00:A8D2 6578705F62697477	     1M      asciiz   "exp_bitwise_xor"
00:A8DA 6973655F786F72
00:A8E1 00
00:A8E2 FBAA            	     2M      word     exp_bitwise_xor
                        	  2418:   makeAsmLibraryFunction "exp_bitwise_or",       exp_bitwise_or
00:A8E4 6578705F62697477	     1M      asciiz   "exp_bitwise_or"
00:A8EC 6973655F6F72
00:A8F2 00
00:A8F3 D1AA            	     2M      word     exp_bitwise_or
                        	  2419:   makeAsmLibraryFunction "exp_bitwise_and",      exp_bitwise_and
00:A8F5 6578705F62697477	     1M      asciiz   "exp_bitwise_and"
00:A8FD 6973655F616E64
00:A904 00
00:A905 E6AA            	     2M      word     exp_bitwise_and
                        	  2420:   makeAsmLibraryFunction "exp_add",              exp_add
00:A907 6578705F616464  	     1M      asciiz   "exp_add"
00:A90E 00
00:A90F 43AA            	     2M      word     exp_add
                        	  2421:   makeAsmLibraryFunction "exp_abs_val",          exp_abs_val
00:A911 6578705F6162735F	     1M      asciiz   "exp_abs_val"
00:A919 76616C
00:A91C 00
00:A91D ACAB            	     2M      word     exp_abs_val
                        	  2422:   makeAsmLibraryFunction "display_in_decimal",   display_in_decimal
00:A91F 646973706C61795F	     1M      asciiz   "display_in_decimal"
00:A927 696E5F646563696D
00:A92F 616C
00:A931 00
00:A932 5291            	     2M      word     display_in_decimal
                        	  2423:   makeAsmLibraryFunction "digitalwrite",         digitalwrite
00:A934 6469676974616C77	     1M      asciiz   "digitalwrite"
00:A93C 72697465
00:A940 00
00:A941 14C8            	     2M      word     digitalwrite
                        	  2424:   makeAsmLibraryFunction "digitalread",          digitalread
00:A943 6469676974616C72	     1M      asciiz   "digitalread"
00:A94B 656164
00:A94E 00
00:A94F 43C8            	     2M      word     digitalread
                        	  2425:   makeAsmLibraryFunction "dest",                 DEST
00:A951 64657374        	     1M      asciiz   "dest"
00:A955 00
00:A956 0300            	     2M      word     DEST
                        	  2426:   makeAsmLibraryFunction "delay",                delay
00:A958 64656C6179      	     1M      asciiz   "delay"
00:A95D 00
00:A95E D590            	     2M      word     delay
                        	  2427:   makeAsmLibraryFunction "delay_1ms",            delay_1ms
00:A960 64656C61795F316D	     1M      asciiz   "delay_1ms"
00:A968 73
00:A969 00
00:A96A CB90            	     2M      word     delay_1ms
                        	  2428:   makeAsmLibraryFunction "crout",                CROUT
00:A96C 63726F7574      	     1M      asciiz   "crout"
00:A971 00
00:A972 2892            	     2M      word     CROUT
                        	  2429:   makeAsmLibraryFunction "crc_val",              crc_val
00:A974 6372635F76616C  	     1M      asciiz   "crc_val"
00:A97B 00
00:A97C 0600            	     2M      word     crc_val
                        	  2430:   makeAsmLibraryFunction "crc_num",              crc_num
00:A97E 6372635F6E756D  	     1M      asciiz   "crc_num"
00:A985 00
00:A986 0300            	     2M      word     crc_num
                        	  2431:   makeAsmLibraryFunction "crc_byte",             crc_byte
00:A988 6372635F62797465	     1M      asciiz   "crc_byte"
00:A990 00
00:A991 2590            	     2M      word     crc_byte
                        	  2432:   makeAsmLibraryFunction "crc_addr",             crc_addr
00:A993 6372635F61646472	     1M      asciiz   "crc_addr"
00:A99B 00
00:A99C 0000            	     2M      word     crc_addr
                        	  2433:   makeAsmLibraryFunction "crc16",                crc16
00:A99E 6372633136      	     1M      asciiz   "crc16"
00:A9A3 00
00:A9A4 FD8F            	     2M      word     crc16
                        	  2434:   makeAsmLibraryFunction "cout",                 COUT
00:A9A6 636F7574        	     1M      asciiz   "cout"
00:A9AA 00
00:A9AB AF93            	     2M      word     COUT
                        	  2435:   makeAsmLibraryFunction "comstl",               COMSTL
00:A9AD 636F6D73746C    	     1M      asciiz   "comstl"
00:A9B3 00
00:A9B4 2D92            	     2M      word     COMSTL
                        	  2436:   makeAsmLibraryFunction "call_y",               call_y
00:A9B6 63616C6C5F79    	     1M      asciiz   "call_y"
00:A9BC 00
00:A9BD 1200            	     2M      word     call_y
                        	  2437:   makeAsmLibraryFunction "call_x",               call_x
00:A9BF 63616C6C5F78    	     1M      asciiz   "call_x"
00:A9C5 00
00:A9C6 1100            	     2M      word     call_x
                        	  2438:   makeAsmLibraryFunction "call_s",               call_s
00:A9C8 63616C6C5F73    	     1M      asciiz   "call_s"
00:A9CE 00
00:A9CF 1400            	     2M      word     call_s
                        	  2439:   makeAsmLibraryFunction "call_p",               call_p
00:A9D1 63616C6C5F70    	     1M      asciiz   "call_p"
00:A9D7 00
00:A9D8 1300            	     2M      word     call_p
                        	  2440:   makeAsmLibraryFunction "call_a",               call_a
00:A9DA 63616C6C5F61    	     1M      asciiz   "call_a"
00:A9E0 00
00:A9E1 1000            	     2M      word     call_a
                        	  2441:   makeAsmLibraryFunction "binary_to_decimal",    binary_to_decimal
00:A9E3 62696E6172795F74	     1M      asciiz   "binary_to_decimal"
00:A9EB 6F5F646563696D61
00:A9F3 6C
00:A9F4 00
00:A9F5 7B91            	     2M      word     binary_to_decimal
                        	  2442: 
00:A9F7 00              	  2443:   dfb 0   ; end of table
                        	  2444: 
                        	  2445: 
                        	  2446: add_assembler_library_functions:
00:A9F8 A9C4            	  2447:   lda #<assembler_library_functions_table
00:A9FA 8500            	  2448:   sta REG
00:A9FC A9A5            	  2449:   lda #>assembler_library_functions_table
00:A9FE 8501            	  2450:   sta REG+1
                        	  2451: add_assembler_library_functions_loop:
00:AA00 A000            	  2452:   ldy #0
00:AA02 B100            	  2453:   lda (REG),Y
00:AA04 F03C            	  2454:   beq add_assembler_library_functions_done
00:AA06 A500            	  2455:   lda REG
00:AA08 8590            	  2456:   sta token_address
00:AA0A A501            	  2457:   lda REG+1
00:AA0C 8591            	  2458:   sta token_address+1
00:AA0E 6492            	  2459:   stz token_length
                        	  2460: ;
                        	  2461: ;  find name length
                        	  2462: ;
                        	  2463: add_assembler_library_functions_name_loop
00:AA10 C8              	  2464:   iny
00:AA11 E692            	  2465:   inc token_length
00:AA13 B100            	  2466:   lda (REG),Y
00:AA15 D0F9            	  2467:   bne add_assembler_library_functions_name_loop
00:AA17 5A              	  2468:   phy
00:AA18 209DB9          	  2469:   jsr CHKDUP
00:AA1B A943            	  2470:   lda #SYMBOL_CONSTANT  ; add the symbol as a constant for now
00:AA1D 20F6B8          	  2471:   jsr ADDSYM
00:AA20 7A              	  2472:   ply
                        	  2473: 
00:AA21 C8              	  2474:   iny             ; get next byte
00:AA22 B100            	  2475:   lda (REG),Y     ; get function address low-byte
00:AA24 5A              	  2476:   phy
00:AA25 A004            	  2477:   ldy #SYMDSP
00:AA27 9140            	  2478:   sta (SYMITM),Y  ; save function address low-byte
00:AA29 7A              	  2479:   ply
                        	  2480: 
00:AA2A C8              	  2481:   iny             ; get next byte
00:AA2B B100            	  2482:   lda (REG),Y     ; get function address high-byte
00:AA2D 5A              	  2483:   phy
00:AA2E A005            	  2484:   ldy #SYMDSP+1
00:AA30 9140            	  2485:   sta (SYMITM),Y  ; save function address high-byte
00:AA32 7A              	  2486:   ply
                        	  2487: 
00:AA33 C8              	  2488:   iny         ; get past that last byte
00:AA34 98              	  2489:   tya         ; move REG onto next entry
00:AA35 18              	  2490:   clc
00:AA36 6500            	  2491:   adc REG
00:AA38 8500            	  2492:   sta REG
00:AA3A A900            	  2493:   lda #0
00:AA3C 6501            	  2494:   adc REG+1
00:AA3E 8501            	  2495:   sta REG+1
00:AA40 80BE            	  2496:   bra add_assembler_library_functions_loop
                        	  2497: 
                        	  2498: add_assembler_library_functions_done:
00:AA42 60              	  2499:   rts
                        	  2500: 

Source: "gpascal.asm"
                        	   178:   .include "math.inc"

Source: "math.inc"
                        	     1: ;--------------------------------------------------
                        	     2: ; Maths routines. 3-byte operations on VALUE and VALUE2
                        	     3: ;
                        	     4: ;--------------------------------------------------
                        	     5: exp_add:
00:AA43 18              	     6:   clc
00:AA44 A500            	     7:   lda VALUE
00:AA46 6503            	     8:   adc VALUE2
00:AA48 8500            	     9:   sta VALUE
00:AA4A A501            	    10:   lda VALUE+1
00:AA4C 6504            	    11:   adc VALUE2+1
00:AA4E 8501            	    12:   sta VALUE+1
00:AA50 A502            	    13:   lda VALUE+2
00:AA52 6505            	    14:   adc VALUE2+2
00:AA54 8502            	    15:   sta VALUE+2
00:AA56 60              	    16:   rts
                        	    17: 
                        	    18: ;
                        	    19: ;  subtract VALUE2 from VALUE, store in VALUE, also set the sign bit
                        	    20: ;   and put the low order two bytes in X and Y
                        	    21: ;
                        	    22: exp_subtract:
00:AA57 38              	    23:   sec
00:AA58 A500            	    24:   lda VALUE
00:AA5A E503            	    25:   sbc VALUE2
00:AA5C 8500            	    26:   sta VALUE
00:AA5E A8              	    27:   tay
00:AA5F A501            	    28:   lda VALUE+1
00:AA61 E504            	    29:   sbc VALUE2+1
00:AA63 AA              	    30:   tax
00:AA64 8501            	    31:   sta VALUE+1
00:AA66 A502            	    32:   lda VALUE+2
00:AA68 E505            	    33:   sbc VALUE2+2
00:AA6A 8502            	    34:   sta VALUE+2
00:AA6C 60              	    35:   rts
                        	    36: 
                        	    37: exp_true:
00:AA6D A901            	    38:   lda #1
00:AA6F 8500            	    39:   sta VALUE
00:AA71 6401            	    40:   stz VALUE+1
00:AA73 6402            	    41:   stz VALUE+2
00:AA75 60              	    42:   rts
                        	    43: 
                        	    44: exp_false:
00:AA76 6400            	    45:   stz VALUE
00:AA78 6401            	    46:   stz VALUE+1
00:AA7A 6402            	    47:   stz VALUE+2
00:AA7C 60              	    48:   rts
                        	    49: 
                        	    50: exp_eql:
00:AA7D A500            	    51:   lda VALUE
00:AA7F C503            	    52:   cmp VALUE2
00:AA81 D0F3            	    53:   bne exp_false
00:AA83 A501            	    54:   lda VALUE+1
00:AA85 C504            	    55:   cmp VALUE2+1
00:AA87 D0ED            	    56:   bne exp_false
00:AA89 A502            	    57:   lda VALUE+2
00:AA8B C505            	    58:   cmp VALUE2+2
00:AA8D D0E7            	    59:   bne exp_false
00:AA8F 80DC            	    60:   bra exp_true
                        	    61: 
                        	    62: exp_neq:
00:AA91 A500            	    63:   lda VALUE
00:AA93 C503            	    64:   cmp VALUE2
00:AA95 D0D6            	    65:   bne exp_true
00:AA97 A501            	    66:   lda VALUE+1
00:AA99 C504            	    67:   cmp VALUE2+1
00:AA9B D0D0            	    68:   bne exp_true
00:AA9D A502            	    69:   lda VALUE+2
00:AA9F C505            	    70:   cmp VALUE2+2
00:AAA1 D0CA            	    71:   bne exp_true
00:AAA3 80D1            	    72:   bra exp_false
                        	    73: 
                        	    74: exp_less_than:
00:AAA5 2057AA          	    75:   jsr exp_subtract
00:AAA8 30C3            	    76:   bmi exp_true
00:AAAA 10CA            	    77:   bpl exp_false
                        	    78: 
                        	    79: exp_greater_than:
00:AAAC 2057AA          	    80:   jsr exp_subtract
00:AAAF 30C5            	    81:   bmi exp_false
00:AAB1 D0BA            	    82:   bne exp_true
00:AAB3 98              	    83:   tya
00:AAB4 D0B7            	    84:   bne exp_true
00:AAB6 8A              	    85:   txa
00:AAB7 D0B4            	    86:   bne exp_true
00:AAB9 10BB            	    87:   bpl exp_false
                        	    88: 
                        	    89: exp_leq:
00:AABB 2057AA          	    90:   jsr exp_subtract
00:AABE 30AD            	    91:   bmi exp_true
00:AAC0 D0B4            	    92:   bne exp_false
00:AAC2 98              	    93:   tya
00:AAC3 D0B1            	    94:   bne exp_false
00:AAC5 8A              	    95:   txa
00:AAC6 D0AE            	    96:   bne exp_false
00:AAC8 10A3            	    97:   bpl exp_true
                        	    98: 
                        	    99: exp_geq:
00:AACA 2057AA          	   100:   jsr exp_subtract
00:AACD 30A7            	   101:   bmi exp_false
00:AACF 109C            	   102:   bpl exp_true
                        	   103: 
                        	   104: exp_bitwise_or:
00:AAD1 A500            	   105:   lda VALUE
00:AAD3 0503            	   106:   ora VALUE2
00:AAD5 8500            	   107:   sta VALUE
00:AAD7 A8              	   108:   tay
00:AAD8 A501            	   109:   lda VALUE+1
00:AADA 0504            	   110:   ora VALUE2+1
00:AADC 8501            	   111:   sta VALUE+1
00:AADE AA              	   112:   tax
00:AADF A502            	   113:   lda VALUE+2
00:AAE1 0505            	   114:   ora VALUE2+2
00:AAE3 8502            	   115:   sta VALUE+2
00:AAE5 60              	   116:   rts
                        	   117: 
                        	   118: exp_bitwise_and:
00:AAE6 A500            	   119:   lda VALUE
00:AAE8 2503            	   120:   and VALUE2
00:AAEA 8500            	   121:   sta VALUE
00:AAEC A8              	   122:   tay
00:AAED A501            	   123:   lda VALUE+1
00:AAEF 2504            	   124:   and VALUE2+1
00:AAF1 8501            	   125:   sta VALUE+1
00:AAF3 AA              	   126:   tax
00:AAF4 A502            	   127:   lda VALUE+2
00:AAF6 2505            	   128:   and VALUE2+2
00:AAF8 8502            	   129:   sta VALUE+2
00:AAFA 60              	   130:   rts
                        	   131: 
                        	   132: exp_bitwise_xor:
00:AAFB A500            	   133:   lda VALUE
00:AAFD 4503            	   134:   eor VALUE2
00:AAFF 8500            	   135:   sta VALUE
00:AB01 A8              	   136:   tay
00:AB02 A501            	   137:   lda VALUE+1
00:AB04 4504            	   138:   eor VALUE2+1
00:AB06 8501            	   139:   sta VALUE+1
00:AB08 AA              	   140:   tax
00:AB09 A502            	   141:   lda VALUE+2
00:AB0B 4505            	   142:   eor VALUE2+2
00:AB0D 8502            	   143:   sta VALUE+2
00:AB0F 60              	   144:   rts
                        	   145: 
                        	   146: 
00:AB10 4C6DAA          	   147: exp_trueJ jmp exp_true
00:AB13 4C76AA          	   148: exp_falseJ jmp exp_false
                        	   149: 
                        	   150: exp_logical_or:
00:AB16 20D1AA          	   151:   jsr exp_bitwise_or
00:AB19 D0F5            	   152:   bne exp_trueJ
00:AB1B E000            	   153:   cpx #0
00:AB1D D0F1            	   154:   bne exp_trueJ
00:AB1F C000            	   155:   cpy #0
00:AB21 D0ED            	   156:   bne exp_trueJ
00:AB23 80EE            	   157:   bra exp_falseJ
                        	   158: 
                        	   159: exp_logical_and:
00:AB25 A500            	   160:   lda VALUE
00:AB27 0501            	   161:   ora VALUE+1
00:AB29 0502            	   162:   ora VALUE+2
00:AB2B F0E6            	   163:   beq exp_falseJ  ; if VALUE has all bits zero the logical "and" must be false
                        	   164: ;
                        	   165: ;  VALUE is non-zero, how about VALUE2?
                        	   166: ;
00:AB2D A503            	   167:   lda VALUE2
00:AB2F 0504            	   168:   ora VALUE2+1
00:AB31 0505            	   169:   ora VALUE2+2
00:AB33 F0DE            	   170:   beq exp_falseJ  ; if VALUE2 has all bits zero the logical "and" must be false
00:AB35 80D9            	   171:   bra exp_trueJ   ; both are non-zero, therefore the result is true
                        	   172: 
                        	   173: exp_shift_left:
00:AB37 A504            	   174:   lda VALUE2+1
00:AB39 0505            	   175:   ora VALUE2+2
00:AB3B D0D6            	   176:   bne exp_falseJ  ; big shifts will return zero
00:AB3D A503            	   177:   lda VALUE2
00:AB3F F00E            	   178:   beq exp_shift_left_done ; shift by zero? we are done then
00:AB41 AA              	   179:   tax
00:AB42 29E0            	   180:   and #$E0        ; maximum of 32 shifts
00:AB44 D0CD            	   181:   bne exp_falseJ
                        	   182: exp_shift_left_loop:
00:AB46 0600            	   183:   asl VALUE
00:AB48 2601            	   184:   rol VALUE+1
00:AB4A 2602            	   185:   rol VALUE+2
00:AB4C CA              	   186:   dex
00:AB4D D0F7            	   187:   bne exp_shift_left_loop
                        	   188: exp_shift_left_done:
00:AB4F 60              	   189:   rts
                        	   190: 
                        	   191: exp_shift_right:
00:AB50 A504            	   192:   lda VALUE2+1
00:AB52 0505            	   193:   ora VALUE2+2
00:AB54 D0BD            	   194:   bne exp_falseJ  ; big shifts will return zero
00:AB56 A503            	   195:   lda VALUE2
00:AB58 F00E            	   196:   beq exp_shift_right_done ; shift by zero? we are done then
00:AB5A AA              	   197:   tax
00:AB5B 29E0            	   198:   and #$E0        ; maximum of 32 shifts
00:AB5D D0B4            	   199:   bne exp_falseJ
                        	   200: exp_shift_right_loop:
00:AB5F 4602            	   201:   lsr VALUE+2
00:AB61 6601            	   202:   ror VALUE+1
00:AB63 6600            	   203:   ror VALUE
00:AB65 CA              	   204:   dex
00:AB66 D0F7            	   205:   bne exp_shift_right_loop
                        	   206: exp_shift_right_done:
00:AB68 60              	   207:   rts
                        	   208: 
                        	   209: exp_negate:
00:AB69 A500            	   210:   lda VALUE
00:AB6B 49FF            	   211:   eor #$FF
00:AB6D 8500            	   212:   sta VALUE
00:AB6F A501            	   213:   lda VALUE+1
00:AB71 49FF            	   214:   eor #$FF
00:AB73 8501            	   215:   sta VALUE+1
00:AB75 A502            	   216:   lda VALUE+2
00:AB77 49FF            	   217:   eor #$FF
00:AB79 8502            	   218:   sta VALUE+2
00:AB7B 60              	   219:   rts
                        	   220: 
                        	   221: exp_not:
00:AB7C A500            	   222:   lda VALUE
00:AB7E D093            	   223:   bne exp_falseJ
00:AB80 A501            	   224:   lda VALUE+1
00:AB82 D08F            	   225:   bne exp_falseJ
00:AB84 A502            	   226:   lda VALUE+2
00:AB86 D08B            	   227:   bne exp_falseJ
00:AB88 8086            	   228:   bra exp_trueJ
                        	   229: 
                        	   230: exp_unary_minus:
00:AB8A 38              	   231:   sec
00:AB8B A900            	   232:   lda #0
00:AB8D E500            	   233:   sbc VALUE
00:AB8F 8500            	   234:   sta VALUE
00:AB91 A900            	   235:   lda #0
00:AB93 E501            	   236:   sbc VALUE+1
00:AB95 8501            	   237:   sta VALUE+1
00:AB97 A900            	   238:   lda #0
00:AB99 E502            	   239:   sbc VALUE+2
00:AB9B 8502            	   240:   sta VALUE+2
00:AB9D 60              	   241:   rts
                        	   242: 
                        	   243: 
                        	   244: exp_low_byte:
00:AB9E 6401            	   245:   stz VALUE+1
00:ABA0 6402            	   246:   stz VALUE+2
00:ABA2 60              	   247:   rts
                        	   248: 
                        	   249: exp_high_byte:
00:ABA3 A501            	   250:   lda VALUE+1
00:ABA5 8500            	   251:   sta VALUE
00:ABA7 6401            	   252:   stz VALUE+1
00:ABA9 6402            	   253:   stz VALUE+2
00:ABAB 60              	   254:   rts
                        	   255: 
                        	   256: ;
                        	   257: ;  make VALUE positive
                        	   258: ;
                        	   259: exp_abs_val:
00:ABAC A502            	   260:   lda  VALUE+2  ; check high-order byte, see if negative
00:ABAE 1013            	   261:   bpl  exp_abs_val_done
                        	   262: exp_negate_val:
00:ABB0 38              	   263:   sec
00:ABB1 A900            	   264:   lda  #0
00:ABB3 E500            	   265:   sbc  VALUE
00:ABB5 8500            	   266:   sta  VALUE
00:ABB7 A900            	   267:   lda  #0
00:ABB9 E501            	   268:   sbc  VALUE+1
00:ABBB 8501            	   269:   sta  VALUE+1
00:ABBD A900            	   270:   lda  #0
00:ABBF E502            	   271:   sbc  VALUE+2
00:ABC1 8502            	   272:   sta  VALUE+2
                        	   273: exp_abs_val_done:
00:ABC3 60              	   274:   rts
                        	   275: 
                        	   276: ;
                        	   277: ;  make VALUE2 positive
                        	   278: ;
                        	   279: exp_abs_val2:
00:ABC4 A505            	   280:   lda  VALUE2+2  ; check high-order byte, see if negative
00:ABC6 1013            	   281:   bpl  exp_abs_val2_done
                        	   282: exp_negate_val2:
00:ABC8 38              	   283:   sec
00:ABC9 A900            	   284:   lda  #0
00:ABCB E503            	   285:   sbc  VALUE2
00:ABCD 8503            	   286:   sta  VALUE2
00:ABCF A900            	   287:   lda  #0
00:ABD1 E504            	   288:   sbc  VALUE2+1
00:ABD3 8504            	   289:   sta  VALUE2+1
00:ABD5 A900            	   290:   lda  #0
00:ABD7 E505            	   291:   sbc  VALUE2+2
00:ABD9 8505            	   292:   sta  VALUE2+2
                        	   293: exp_abs_val2_done:
00:ABDB 60              	   294:   rts
                        	   295: 
                        	   296: 
                        	   297: ZERRES:
00:ABDC A900            	   298:   lda  #0
00:ABDE 8552            	   299:   sta  RES
00:ABE0 8553            	   300:   sta  RES+1
00:ABE2 8554            	   301:   sta  RES+2
00:ABE4 60              	   302:   rts
                        	   303: 
                        	   304: exp_find_sign:
00:ABE5 20DCAB          	   305:    jsr  ZERRES     ; zero result
00:ABE8 A502            	   306:    lda  VALUE+2
00:ABEA 2980            	   307:    and  #$80
00:ABEC 855B            	   308:    sta  RMNDR
00:ABEE A505            	   309:    lda  VALUE2+2
00:ABF0 2980            	   310:    and  #$80
00:ABF2 455B            	   311:    eor  RMNDR
00:ABF4 855B            	   312:    sta  RMNDR     ; RMNDR is 0x80 if the result needs to be negative
00:ABF6 20ACAB          	   313:    jsr  exp_abs_val
00:ABF9 20C4AB          	   314:    jsr  exp_abs_val2
00:ABFC 60              	   315:    rts
                        	   316: ;
                        	   317: 
                        	   318: exp_fix_sign:
00:ABFD A55B            	   319:   lda  RMNDR
00:ABFF 100F            	   320:   bpl  exp_fix_sign_done      ; nothing needs to be changed
00:AC01 38              	   321:   sec                         ; subtract result from zero
00:AC02 A900            	   322:   lda  #0
00:AC04 E552            	   323:   sbc  RES
00:AC06 AA              	   324:   tax
00:AC07 A900            	   325:   lda  #0
00:AC09 E553            	   326:   sbc  RES+1
00:AC0B A8              	   327:   tay
00:AC0C A900            	   328:   lda  #0
00:AC0E E554            	   329:   sbc  RES+2
                        	   330: exp_fix_sign_done:
00:AC10 60              	   331:   rts
                        	   332: 
                        	   333: 
                        	   334: ;
                        	   335: ;  multiply VALUE1 by VALUE2 and store in VALUE
                        	   336: ;
                        	   337: ;  see: https://llx.com/Neil/a2/mult.html for a discussion
                        	   338: ;
                        	   339: 
                        	   340: exp_multiply:
00:AC11 20E5AB          	   341:   jsr exp_find_sign
00:AC14 A218            	   342:   ldx  #24       ; for all 24 bits
                        	   343: exp_multiply_loop:
00:AC16 0652            	   344:   asl  RES
00:AC18 2653            	   345:   rol  RES+1
00:AC1A 2654            	   346:   rol  RES+2                    ; shift RES left one bit
00:AC1C 0600            	   347:   asl  VALUE
00:AC1E 2601            	   348:   rol  VALUE+1
00:AC20 2602            	   349:   rol  VALUE+2                  ; shift one argument left one bit and get the low-order bit into carry
00:AC22 9013            	   350:   bcc  exp_multiply_no_add      ; if no low-order bit, don't add anything
00:AC24 18              	   351:   clc                           ; add the other argument to the result
00:AC25 A503            	   352:   lda  VALUE2
00:AC27 6552            	   353:   adc  RES
00:AC29 8552            	   354:   sta  RES
00:AC2B A504            	   355:   lda  VALUE2+1
00:AC2D 6553            	   356:   adc  RES+1
00:AC2F 8553            	   357:   sta  RES+1
00:AC31 A505            	   358:   lda  VALUE2+2
00:AC33 6554            	   359:   adc  RES+2
00:AC35 8554            	   360:   sta  RES+2
                        	   361: exp_multiply_no_add:
00:AC37 CA              	   362:   dex                      ; count bits
00:AC38 D0DC            	   363:   bne  exp_multiply_loop   ; go back if more to go
00:AC3A 20FDAB          	   364:   jsr  exp_fix_sign
00:AC3D A552            	   365:   lda  RES
00:AC3F 8500            	   366:   sta  VALUE
00:AC41 A553            	   367:   lda  RES+1
00:AC43 8501            	   368:   sta  VALUE+1
00:AC45 A554            	   369:   lda  RES+2
00:AC47 8502            	   370:   sta  VALUE+2
00:AC49 60              	   371:   rts
                        	   372: 
                        	   373: ;
                        	   374: ;  divide VALUE by VALUE2, store result in VALUE
                        	   375: ;
                        	   376: exp_divide:
00:AC4A 20E5AB          	   377:   jsr exp_find_sign
                        	   378: 
00:AC4D A503            	   379:   lda  VALUE2
00:AC4F 0504            	   380:   ora  VALUE2+1
00:AC51 0505            	   381:   ora  VALUE2+2
00:AC53 D005            	   382:   bne  exp_divide_not_zero  ; check not dividing by zero
00:AC55 A22F            	   383:   ldx  #47                  ; ERROR: divide by zero
00:AC57 4CB49E          	   384:   jmp  ass_error
                        	   385:   ;
                        	   386: exp_divide_not_zero:
00:AC5A 20DCAB          	   387:   jsr  ZERRES     ; zero result (RES) - leaves zero in A register
00:AC5D 8506            	   388:   sta  REMAIN
00:AC5F 8507            	   389:   sta  REMAIN+1
00:AC61 8508            	   390:   sta  REMAIN+2
00:AC63 A918            	   391:   lda  #24       ; for all 24 bits of the operands ...
00:AC65 858D            	   392:   sta  maths_work
                        	   393: exp_divide_loop:
00:AC67 0600            	   394:   asl  VALUE
00:AC69 2601            	   395:   rol  VALUE+1
00:AC6B 2602            	   396:   rol  VALUE+2    ; shift the dividend left one bit
00:AC6D 2606            	   397:   rol  REMAIN    ; the low-order bit of the dividend is shifted into the remainder
00:AC6F 2607            	   398:   rol  REMAIN+1
00:AC71 2608            	   399:   rol  REMAIN+2
00:AC73 38              	   400:   sec
00:AC74 A506            	   401:   lda  REMAIN    ; do a trial subtraction of: remainder - divisor
00:AC76 E503            	   402:   sbc  VALUE2
00:AC78 AA              	   403:   tax
00:AC79 A507            	   404:   lda  REMAIN+1
00:AC7B E504            	   405:   sbc  VALUE2+1
00:AC7D A8              	   406:   tay
00:AC7E A508            	   407:   lda  REMAIN+2
00:AC80 E505            	   408:   sbc  VALUE2+2
00:AC82 300B            	   409:   bmi  exp_divide_subtraction_negative      ; if the subtraction fails (is negative) then discard the result
00:AC84 8508            	   410:   sta  REMAIN+2  ; if it succeeds then the result of the subtraction is our new remainder
00:AC86 98              	   411:   tya
00:AC87 8507            	   412:   sta  REMAIN+1
00:AC89 8A              	   413:   txa
00:AC8A 8506            	   414:   sta  REMAIN
00:AC8C 38              	   415:   sec            ; shift a one-bit into the quotient
00:AC8D B001            	   416:   bcs  exp_divide_subtraction_positive
                        	   417: exp_divide_subtraction_negative:
00:AC8F 18              	   418:   clc            ; here if subtraction failed, quotient (RES) gets a 0-bit shifted in
                        	   419: exp_divide_subtraction_positive:
00:AC90 2652            	   420:   rol  RES       ; the carry bit (from above) is shifted into the quotient
00:AC92 2653            	   421:   rol  RES+1
00:AC94 2654            	   422:   rol  RES+2
00:AC96 C68D            	   423:   dec  maths_work      ; one less bit to go
00:AC98 D0CD            	   424:   bne  exp_divide_loop      ; repeat until 24 bits done
00:AC9A 20FDAB          	   425:   jsr  exp_fix_sign
00:AC9D A552            	   426:   lda  RES
00:AC9F 8500            	   427:   sta  VALUE
00:ACA1 A553            	   428:   lda  RES+1
00:ACA3 8501            	   429:   sta  VALUE+1
00:ACA5 A554            	   430:   lda  RES+2
00:ACA7 8502            	   431:   sta  VALUE+2
00:ACA9 60              	   432:   rts
                        	   433: 
                        	   434: exp_modulo:
00:ACAA 204AAC          	   435:   jsr exp_divide
00:ACAD A506            	   436:   lda REMAIN
00:ACAF 8500            	   437:   sta VALUE
00:ACB1 A507            	   438:   lda REMAIN+1
00:ACB3 8501            	   439:   sta VALUE+1
00:ACB5 A508            	   440:   lda REMAIN+2
00:ACB7 8502            	   441:   sta VALUE+2
00:ACB9 60              	   442:   rts
                        	   443: 

Source: "gpascal.asm"
                        	   179:   .include "interpreter.inc"

Source: "interpreter.inc"
                        	     1: ;--------------------------------------------------
                        	     2: ; Runtime P-code interpreter
                        	     3: ;
                        	     4: ;--------------------------------------------------
                        	     5: 
                        	     6: 
                        	     7: ;--------------------------------
                        	     8: ; P-codes - these are generated in the compilation phase and looked up
                        	     9: ;           in execution_address_table at runtime
                        	    10: ;
                        	    11: ; Note: some P-codes must appear in sequence, eg. PCODE_STO and PCODE_STOC
                        	    12: ;       That is because one refers to integers (STO) and one refers to characters (STOC)
                        	    13: ;       The code in various places is virtually identical except it adds 1 to the P-code
                        	    14: ;       for characters. These generally are the Load/Store operations.
                        	    15: ;--------------------------------
                        	    16: 
                        	    17: ; Not implemented yet: $05, $13, $15, $39
                        	    18: 
                        	    19: ;                 Code            Description                         Arguments
                        	    20: ;                 ----            -----------------------------       -----------------------
                        	    21: PCODE_LIT     = 	$00 ; Dec:  0 - Load constant                     - 3-byte literal (number)
                        	    22: PCODE_STACK   =   $01 ; Dec:  1 - Alter runtime stack to address    - 2-byte stack address
                        	    23: PCODE_NEG     = 	$02 ; Dec:  2 - Unary minus 0 - (sp)              - none
                        	    24: PCODE_LIB_CALL =  $03 ; Dec:  3 - Call library function/procedure   - absolute address
                        	    25: PCODE_ADD     = 	$04 ; Dec:  4 - Add (sp) to (sp - 1)              - none
                        	    26: PCODE_SUB     = 	$06 ; Dec:  6 - Subtract (sp) from (sp - 1)       - none
                        	    27: PCODE_MUL     = 	$08 ; Dec:  8 - Multiply (sp) * (sp - 1)          - none
                        	    28: PCODE_DIV     = 	$0A ; Dec: 10 - Divide (sp - 1) / (sp)            - none
                        	    29: PCODE_MOD     = 	$0B ; Dec: 11 - Modulus (sp - 1) MOD (sp)         - none
                        	    30: PCODE_ADRNN   = 	$0C ; Dec: 12 - Address of integer                - level, displ
                        	    31: PCODE_ADRNC   = 	$0D ; Dec: 13 - Address of character              - level, displ
                        	    32: PCODE_ADRAN   = 	$0E ; Dec: 14 - Address of integer array          - level, displ
                        	    33: PCODE_ADRAC   = 	$0F ; Dec: 15 - Address of character array        - level, displ
                        	    34: PCODE_EQL     = 	$10 ; Dec: 16 - Test (sp - 1) == (sp)             - none
                        	    35: PCODE_FINISHD = 	$11 ; Dec: 17 - Stop run (end program)            - none
                        	    36: PCODE_NEQ     = 	$12 ; Dec: 18 - Test (sp - 1) != (sp)             - none
                        	    37: PCODE_LSS     = 	$14 ; Dec: 20 - Test (sp - 1) < (sp)              - none
                        	    38: PCODE_GEQ     = 	$16 ; Dec: 22 - Test (sp - 1) >= (sp)             - none
                        	    39: PCODE_GTR     = 	$18 ; Dec: 24 - Test (sp - 1) > (sp)              - none
                        	    40: PCODE_LEQ     = 	$19 ; Dec: 25 - Test (sp - 1) <= (sp)             - none
                        	    41: PCODE_ORR     = 	$1A ; Dec: 26 - OR  (sp - 1) | (sp)               - none
                        	    42: PCODE_AND     = 	$1B ; Dec: 27 - AND (sp - 1) & (sp)               - none
                        	    43: PCODE_INP     = 	$1C ; Dec: 28 - Input number                      - none
                        	    44: PCODE_INPC    = 	$1D ; Dec: 29 - Input character                   - none
                        	    45: PCODE_OUT     = 	$1E ; Dec: 30 - Output number                     - none
                        	    46: PCODE_OUTC    = 	$1F ; Dec: 31 - Output character                  - none
                        	    47: PCODE_EOR     = 	$20 ; Dec: 32 - Not (sp) (logical negate)         - none
                        	    48: PCODE_OUH     = 	$21 ; Dec: 33 - Output hex number                 - none
                        	    49: PCODE_SHL     = 	$22 ; Dec: 34 - Shift left (sp) bits              - none
                        	    50: PCODE_OUS     = 	$23 ; Dec: 35 - Output string                     - length, string
                        	    51: PCODE_SHR     = 	$24 ; Dec: 36 - Shift right (sp) bits             - none
                        	    52: PCODE_INS     = 	$25 ; Dec: 37 - Input string into array           - max, level, displ
                        	    53: PCODE_INC     = 	$26 ; Dec: 38 - Increment (sp) by 1               - none
                        	    54: PCODE_CLL     = 	$27 ; Dec: 39 - Relative procedure/function call  - level, relative address
                        	    55: PCODE_DEC     = 	$28 ; Dec: 40 - Decrement (sp) by 1               - none
                        	    56: PCODE_RTN     = 	$29 ; Dec: 41 - Procedure/function return         - none
                        	    57: PCODE_MOV     = 	$2A ; Dec: 42 - Copy (sp) to (sp + 1)             - none
                        	    58: PCODE_CLA     = 	$2B ; Dec: 43 - Call absolute address             - none
                        	    59: PCODE_LOD     = 	$2C ; Dec: 44 - Load integer onto stack           - level, displ
                        	    60: PCODE_LODC    = 	$2D ; Dec: 45 - Load character onto stack         - level, displ
                        	    61: PCODE_LDA     = 	$2E ; Dec: 46 - Load absolute address integer     - none
                        	    62: PCODE_LDAC    = 	$2F ; Dec: 47 - Load absolute address character   - none
                        	    63: PCODE_LDI     = 	$30 ; Dec: 48 - Load integer indexed              - level, displ
                        	    64: PCODE_LDIC    = 	$31 ; Dec: 49 - Load character indexed            - level, displ
                        	    65: PCODE_STO     = 	$32 ; Dec: 50 - Store integer                     - level, displ
                        	    66: PCODE_STOC    = 	$33 ; Dec: 51 - Store character                   - level, displ
                        	    67: PCODE_STA     = 	$34 ; Dec: 52 - Store integer absolute address    - none
                        	    68: PCODE_STAC    = 	$35 ; Dec: 53 - Store character absolute address  - none
                        	    69: PCODE_STI     = 	$36 ; Dec: 54 - Store integer indexed             - level, displ
                        	    70: PCODE_STIC    = 	$37 ; Dec: 55 - Store character indexed           - level, displ
                        	    71: PCODE_ABSCLL  = 	$38 ; Dec: 56 - Absolute procedure/function call  - level, absolute address
                        	    72: PCODE_XOR     = 	$3A ; Dec: 58 - XOR (sp - 1) ^ (sp)               - none
                        	    73: PCODE_INT     = 	$3B ; Dec: 59 - Increment stack pointer           - increment
                        	    74: PCODE_JMP     = 	$3C ; Dec: 60 - Jump unconditionally              - relative address
                        	    75: PCODE_JMZ     = 	$3D ; Dec: 61 - Jump if (sp) zero                 - relative address
                        	    76: PCODE_JM1     = 	$3E ; Dec: 62 - Jump if (sp) not zero             - relative address
                        	    77: PCODE_OUTCR   =   $40 ; Dec: 64 - Output a carriage-return          - none
                        	    78: PCODE_LCD_WRITE_NUM = $42 ; Dec: 66 - Write number to LCD           - none
                        	    79: PCODE_LCD_WRITE_STR = $43 ; Dec: 67 - Write string to LCD           - none
                        	    80: PCODE_LCD_WRITE_HEX = $44 ; Dec: 68 - Write hex number to LCD       - none
                        	    81: PCODE_LCD_WRITE_CHR = $45 ; Dec: 69 - Write character to LCD        - none
                        	    82: 
                        	    83: PCODE_LAST    =   PCODE_LCD_WRITE_CHR  ; PUT THIS LAST! (error check)                  -
                        	    84: 
                        	    85: ; 0x80 to 0xFF - Load low literal (onto stack), where literal is P-code with 8-bit clear (ie. P-code & 0x7F)
                        	    86: 
                        	    87: 
                        	    88: ;
                        	    89: ;  P-code execution routine lookup.
                        	    90: ;  For symbolic version see list above
                        	    91: ;
                        	    92: ;  Y is zero when starting to execute these routines
                        	    93: ;
                        	    94: execution_address_table  =  *
00:ACBA EBAF            	    95:   word  EX_LIT             ; $00 = LIT     	Load constant
00:ACBC DFB3            	    96:   word  EX_NEW_STACK       ; $01 =          Change stack to addr
00:ACBE FDAF            	    97:   word  EX_NEG             ; $02 = NEG     	Unary minus: 0 - (sp)
00:ACC0 6BB5            	    98:   word  EX_LIB_CALL        ; $03 = LIB_CALL Library function call
00:ACC2 06B0            	    99:   word  EX_ADD             ; $04 = ADD     	Add (sp) to (sp - 1)
00:ACC4 19AF            	   100:   word  EX_INVINS          ; $05 =          NOT IMPLEMENTED
00:ACC6 0FB0            	   101:   word  EX_SUB             ; $06 = SUB     	Subtract (sp) from (sp - 1)
00:ACC8 19AF            	   102:   word  EX_INVINS          ; $07 =          NOT IMPLEMENTED
00:ACCA 1BB0            	   103:   word  EX_MUL             ; $08 = MUL     	Multiply (sp) * (sp - 1)
00:ACCC 19AF            	   104:   word  EX_INVINS          ; $09 =          NOT IMPLEMENTED
00:ACCE 56B0            	   105:   word  EX_DIV             ; $0A = DIV     	Divide (sp - 1) / (sp)
00:ACD0 2BB0            	   106:   word  EX_MOD             ; $0B = MOD     	Modulus (sp - 1) MOD (sp)
00:ACD2 CAB4            	   107:   word  EX_ADRNN           ; $0C = ADRNN   	Address of integer
00:ACD4 BAB4            	   108:   word  EX_ADRNC           ; $0D = ADRNC   	Address of character
00:ACD6 D8B4            	   109:   word  EX_ADRAN           ; $0E = ADRAN   	Address of integer array
00:ACD8 DEB4            	   110:   word  EX_ADRAC           ; $0F = ADRAC   	Address of character array
00:ACDA 73B0            	   111:   word  EX_EQL             ; $10 = EQL     	Test (sp - 1) == (sp)
00:ACDC 66AE            	   112:   word  EX_FINISHD         ; $11 = FINISHD 	Stop run (end program)
00:ACDE 8DB0            	   113:   word  EX_NEQ             ; $12 = NEQ     	Test (sp - 1) != (sp)
00:ACE0 19AF            	   114:   word  EX_INVINS          ; $13 =          NOT IMPLEMENTED
00:ACE2 96B0            	   115:   word  EX_LSS             ; $14 = LSS     	Test (sp - 1) < (sp)
00:ACE4 19AF            	   116:   word  EX_INVINS          ; $15 =          NOT IMPLEMENTED
00:ACE6 AEB0            	   117:   word  EX_GEQ             ; $16 = GEQ     	Test (sp - 1) >= (sp)
00:ACE8 19AF            	   118:   word  EX_INVINS          ; $17 =          NOT IMPLEMENTED
00:ACEA A2B0            	   119:   word  EX_GTR             ; $18 = GTR     	Test (sp - 1) > (sp)
00:ACEC BAB0            	   120:   word  EX_LEQ             ; $19 = LEQ     	Test (sp - 1) <= (sp)
00:ACEE CFB0            	   121:   word  EX_ORR             ; $1A = ORR     	OR  (sp - 1) | (sp)
00:ACF0 D8B0            	   122:   word  EX_AND             ; $1B = AND     	AND (sp - 1) & (sp)
00:ACF2 58B2            	   123:   word  EX_INP             ; $1C = INP     	Input number
00:ACF4 20B4            	   124:   word  EX_INPC            ; $1D = INPC    	Input character
00:ACF6 98B2            	   125:   word  EX_OUT             ; $1E = OUT     	Output number
00:ACF8 3AB4            	   126:   word  EX_OUTC            ; $1F = OUTC    	Output character
00:ACFA E1B0            	   127:   word  EX_EOR             ; $20 = EOR     	Not (sp) (logical negate)
00:ACFC ACB2            	   128:   word  EX_OUH             ; $21 = OUH     	Output hex number
00:ACFE EAB0            	   129:   word  EX_SHL             ; $22 = SHL     	Shift left (sp) bits
00:AD00 CCB2            	   130:   word  EX_OUS             ; $23 = OUS     	Output string
00:AD02 F6B0            	   131:   word  EX_SHR             ; $24 = SHR     	Shift right (sp) bits
00:AD04 5CB4            	   132:   word  EX_INS             ; $25 = INS     	Input string into array
00:AD06 02B1            	   133:   word  EX_INC             ; $26 = INC     	Increment (sp) by 1
00:AD08 06B3            	   134:   word  EX_CLL             ; $27 = CLL     	Relative procedure/function call
00:AD0A 1AB1            	   135:   word  EX_DEC             ; $28 = DEC     	Decrement (sp) by 1
00:AD0C 1FB2            	   136:   word  EX_RTN             ; $29 = RTN     	Procedure/function return
00:AD0E 32B1            	   137:   word  EX_MOV             ; $2A = MOV     	Copy (sp) to (sp + 1)
00:AD10 95B3            	   138:   word  EX_CLA             ; $2B = CLA     	Call absolute address
00:AD12 55B1            	   139:   word  EX_LOD             ; $2C = LOD     	Load integer onto stack
00:AD14 43B1            	   140:   word  EX_LODC            ; $2D = LODC    	Load character onto stack
00:AD16 76B1            	   141:   word  EX_LDA             ; $2E = LDA     	Load absolute address integer
00:AD18 6BB1            	   142:   word  EX_LDAC            ; $2F = LDAC    	Load absolute address character
00:AD1A B1B1            	   143:   word  EX_LDI             ; $30 = LDI     	Load integer indexed
00:AD1C ABB1            	   144:   word  EX_LDIC            ; $31 = LDIC    	Load character indexed
00:AD1E C4B1            	   145:   word  EX_STO             ; $32 = STO     	Store integer
00:AD20 B7B1            	   146:   word  EX_STOC            ; $33 = STOC    	Store character
00:AD22 D7B1            	   147:   word  EX_STA             ; $34 = STA     	Store integer absolute address
00:AD24 EDB1            	   148:   word  EX_STAC            ; $35 = STAC    	Store character absolute address
00:AD26 04B2            	   149:   word  EX_STI             ; $36 = STI     	Store integer indexed
00:AD28 F6B1            	   150:   word  EX_STIC            ; $37 = STIC    	Store character indexed
00:AD2A FFB2            	   151:   word  EX_ABSCLL          ; $38 = ABSCLL  	Absolute procedure/function call
00:AD2C 19AF            	   152:   word  EX_INVINS          ; $39 =          NOT IMPLEMENTED
00:AD2E C6B0            	   153:   word  EX_XOR             ; $3A = XOR     	XOR (sp - 1) ^ (sp)
00:AD30 B5B3            	   154:   word  EX_INT             ; $3B = INT     	Increment stack pointer
00:AD32 F1B3            	   155:   word  EX_JMP             ; $3C = JMP     	Jump unconditionally
00:AD34 04B4            	   156:   word  EX_JMZ             ; $3D = JMZ     	Jump if (sp) zero
00:AD36 15B4            	   157:   word  EX_JM1             ; $3E = JM1     	Jump if (sp) not zero
00:AD38 19AF            	   158:   word  EX_INVINS          ; $3F =          NOT IMPLEMENTED
00:AD3A C6AE            	   159:   word  EX_OUTCR           ; $40 = OUTCR   	Output a carriage-return
00:AD3C 19AF            	   160:   word  EX_INVINS          ; $41 =          NOT IMPLEMENTED
00:AD3E 9DB2            	   161:   word  EX_LCD_WRITE_NUM   ; $42 = LCD_WRITE_NUM  Write number to LCD
00:AD40 D1B2            	   162:   word  EX_LCD_WRITE_STR   ; $43 = LCD_WRITE_STR  Write string to LCD
00:AD42 B1B2            	   163:   word  EX_LCD_WRITE_HEX   ; $44 = LCD_WRITE_HEX  Write hex to LCD
00:AD44 3FB4            	   164:   word  EX_LCD_WRITE_CHR   ; $45 = LCD_WRITE_CHR  Write character to LCD
                        	   165: 
                        	   166: ;--------------------------------------------------------------------------
                        	   167: ;
                        	   168: ;  STACK FRAMES
                        	   169: ;
                        	   170: ;  The compiler can't know where variables are actually going to be stored because
                        	   171: ;  they will be relative to the (interpreter) stack (not the processor stack) which
                        	   172: ;  is an unknown address because procedures/functions can be called directly or from
                        	   173: ;  other procedures/functions.
                        	   174: ;
                        	   175: ;  Hence variables are referenced to BASE which is the base of the current stack frame,
                        	   176: ;  thus a variable will be a certain offset from that. However in the case of nested
                        	   177: ;  calls we need to go back to a previous stack frame. That is what the 6-byte "stack
                        	   178: ;  frame linkage data" is about.
                        	   179: ;
                        	   180: ;  Variables are referred to by a "level difference" and a displacement. For the current
                        	   181: ;  procedure the level difference will be zero, and thus the variable will be BASE +
                        	   182: ;  the offset for this particular variable.
                        	   183: ;
                        	   184: ;  For variables in earlier procedures/functions (ones which called this one) there will
                        	   185: ;  be a level difference, being the depth (lexically) between the called function and the
                        	   186: ;  one with the variable. For example, if foo calls bar, and bar recurses five times, foo
                        	   187: ;  and bar are still only one level apart, from the point of view of accessing foo's
                        	   188: ;  variables.
                        	   189: ;
                        	   190: ;  Thus, to find an address we need to "walk" back through the STATIC stack frame links
                        	   191: ;  (bytes 5 and 6 of the stack frame data) to find the appropriate stack frame, and then
                        	   192: ;  take the offset from that.
                        	   193: ;
                        	   194: ;  However for recursive calls, once a recursed call ends, we need to get back the stack
                        	   195: ;  frame of the caller, which will be different from the static frame. So, to restore the
                        	   196: ;  stack frame after a procedure/function ends, we must take the DYNAMIC stack frame address
                        	   197: ;  (bytes 3 and 4 of the stack frame data) to get back the previous stack frame. In fact,
                        	   198: ;  all procedures/functions do this, it's just that the static and dynamic stack frames will
                        	   199: ;  be the same if the procedure/function does not recurse.
                        	   200: ;
                        	   201: ;  Finally, the return address (in the P-codes) for the procedure/function call is also
                        	   202: ;  stored in the stack frame data (bytes 1 and 2 of the stack frame data) so that, after
                        	   203: ;  doing a return, we can restore the P-code address to the PCODE variable after the call.
                        	   204: ;
                        	   205: ;  When a procedure/function is called these 6 bytes are pushed onto the stack. Then, for
                        	   206: ;  some reason, the code moves the stack pointer back 6 (adds to it). Then as part of the
                        	   207: ;  procedure/function initialisation the stack pointer has 6 or 9 added to it, to allow
                        	   208: ;  for not overwriting this stack frame data, and in the case of functions, the extra 3
                        	   209: ;  bytes are for the returned value.
                        	   210: ;
                        	   211: ;  Note that the stack grows downwards, as it starts at "high memory" (whatever that is
                        	   212: ;  defined as, and grows downwards, taking the gap between the end of the P-codes and the
                        	   213: ;  end of memory.
                        	   214: ;
                        	   215: ;  Then the function will add additional spaces to the stack (ie. by subtracting from the
                        	   216: ;  stack pointer) to make room for variables declared in that procedure/function. Now we
                        	   217: ;  are ready to push data onto the stack as part of normal expression evalution. It follows
                        	   218: ;  from this that variables initially have undefined values, as they will contain whatever
                        	   219: ;  happened to be in the stack when this space was allocated.
                        	   220: ;
                        	   221: ;  The function GETADR resolves these addresses by starting with BASE, the stack frame base
                        	   222: ;  for the current procedure/function, and then using the static stack frame link to load a
                        	   223: ;  (temporary) new base, and repeating that until the level difference is zero. Then it adds
                        	   224: ;  the offset of the wanted variable to the stack base to derive the actual variable address.
                        	   225: ;
                        	   226: ;--------------------------------------------------------------------------
                        	   227: 
                        	   228: 
                        	   229: ;
00:AD46 20537461636B3A20	   230: DM1               asciiz  ' Stack: '
00:AD4E 00
00:AD4F 20426173653A2020	   231: DM2               asciiz  ' Base:  '
00:AD57 00
00:AD58 52756E6E696E670A	   232: running_message   asciiz  'Running\n'
00:AD60 00
                        	   233: 
                        	   234: ;
                        	   235: DEBUG    =  *
00:AD61 204392          	   236: DB11     jsr  DISPAD    ; display P-code address
00:AD64 A523            	   237:          lda  PCODE
00:AD66 8537            	   238:          sta  WORK
00:AD68 A524            	   239:          lda  PCODE+1
00:AD6A 8538            	   240:          sta  WORK+1
00:AD6C A204            	   241:          ldx  #4
00:AD6E 202AAE          	   242:          jsr  display_x_characters      ; display 4 bytes from WORK (ie. the P-codes)
00:AD71 202892          	   243:          jsr  CROUT
00:AD74 A649            	   244:          ldx  DBGFLG
00:AD76 3051            	   245:          bmi  DEBUG_DONE        ; trace only
00:AD78 A946            	   246:          lda  #<DM1             ; ' Stack: '
00:AD7A A2AD            	   247:          ldx  #>DM1
00:AD7C 202682          	   248:          jsr  print
00:AD7F A532            	   249:          lda  T+1
00:AD81 209D92          	   250:          jsr  PRBYTE        ; display the stack pointer address
00:AD84 A531            	   251:          lda  T
00:AD86 203D92          	   252:          jsr  DISHX         ; display hex and a space after
00:AD89 A93D            	   253:          lda  #'='
00:AD8B 20AF93          	   254:          jsr  COUT
00:AD8E A531            	   255:          lda  T
00:AD90 8537            	   256:          sta  WORK
00:AD92 A532            	   257:          lda  T+1
00:AD94 8538            	   258:          sta  WORK+1
00:AD96 A209            	   259:          ldx  #9         ; show 9 bytes on stack, namely 3 variables
00:AD98 202AAE          	   260:          jsr  display_x_characters
00:AD9B 202892          	   261:          jsr  CROUT
00:AD9E A94F            	   262:          lda  #<DM2       ; ' Base:  '
00:ADA0 A2AD            	   263:          ldx  #>DM2
00:ADA2 202682          	   264:          jsr  print
00:ADA5 A53C            	   265:          lda  BASE+1
00:ADA7 209D92          	   266:          jsr  PRBYTE      ; display the base pointer address
00:ADAA A53B            	   267:          lda  BASE
00:ADAC 203D92          	   268:          jsr  DISHX
00:ADAF A93D            	   269:          lda  #'='
00:ADB1 20AF93          	   270:          jsr  COUT
00:ADB4 A53B            	   271:          lda  BASE
00:ADB6 38              	   272:          sec
00:ADB7 E906            	   273:          sbc  #6    ; the linkage data is 6 bytes below the base
00:ADB9 8537            	   274:          sta  WORK
00:ADBB A53C            	   275:          lda  BASE+1
00:ADBD E900            	   276:          sbc  #0
00:ADBF 8538            	   277:          sta  WORK+1
00:ADC1 A206            	   278:          ldx  #6    ; show 6 bytes of base linkage data (return, dynamic link, static link)
00:ADC3 202AAE          	   279:          jsr  display_x_characters
00:ADC6 4C2892          	   280:          jmp  CROUT
                        	   281: 
00:ADC9 60              	   282: DEBUG_DONE rts
                        	   283: 
                        	   284: 
                        	   285: ;***********************************************
                        	   286: ; Interpreter initialization
                        	   287: ;***********************************************
                        	   288: 
                        	   289: INTERP   =  *
00:ADCA 08              	   290:   php
00:ADCB 68              	   291:   pla
00:ADCC 8513            	   292:   sta  call_p   ; make sure call_p has some reasonable value in it
                        	   293: ;
                        	   294: ;  Move the start of where the P-codes start into PCODE (our first P-code)
                        	   295: ;
00:ADCE A525            	   296:   lda  ACT_PCDA
00:ADD0 8523            	   297:   sta  PCODE
00:ADD2 A526            	   298:   lda  ACT_PCDA+1
00:ADD4 8524            	   299:   sta  PCODE+1
                        	   300: ;
                        	   301: ;  Running message
                        	   302: ;
00:ADD6 A958            	   303:   lda  #<running_message   ; Running
00:ADD8 A2AD            	   304:   ldx  #>running_message
00:ADDA 202682          	   305:   jsr  print
                        	   306: ;
                        	   307: ;  Running flag
                        	   308: ;
00:ADDD A00C            	   309:   ldy  #$0C
00:ADDF 843F            	   310:   sty  RUNNING
                        	   311: ;
                        	   312: ;  Set up the runtime stack pointer which is also our first stack frame base
                        	   313: ;
00:ADE1 A9FF            	   314:   lda  #<HIGHEST_RAM
00:ADE3 8531            	   315:   sta  T
00:ADE5 853B            	   316:   sta  BASE
00:ADE7 A93F            	   317:   lda  #>HIGHEST_RAM
00:ADE9 8532            	   318:   sta  T+1
00:ADEB 853C            	   319:   sta  BASE+1
                        	   320: 
00:ADED 4CDBAE          	   321:   jmp  MAIN ; start interpreting
                        	   322: ;
                        	   323: ;
                        	   324: ;
                        	   325: 
                        	   326: 
                        	   327: ;***********************************************
                        	   328: ;  INTERPRETER
                        	   329: ;***********************************************
                        	   330: 
                        	   331: ;
                        	   332: ;
00:ADF0 496C6C6567616C20	   333: DM5      asciiz  "Illegal instruction\n"
00:ADF8 696E737472756374
00:AE00 696F6E0A
00:AE04 00
00:AE05 427265616B202E2E	   334: DM6      asciiz  'Break ...\n'
00:AE0D 2E0A
00:AE0F 00
00:AE10 4572726F72206F63	   335: DM7      asciiz  "Error occurred at P-code "
00:AE18 6375727265642061
00:AE20 7420502D636F6465
00:AE28 20
00:AE29 00
                        	   336: 
                        	   337: ;
                        	   338: ; DISPLAY (X) CHARACTERS FROM (WORK)
                        	   339: ;
                        	   340: display_x_characters:
00:AE2A 8A              	   341:          txa
00:AE2B 48              	   342:          pha
00:AE2C 20B392          	   343:          jsr  PUTSP
00:AE2F 68              	   344:          pla
00:AE30 AA              	   345:          tax
00:AE31 A000            	   346: DIS5     ldy  #0
00:AE33 B137            	   347:          lda  (WORK),Y
00:AE35 E637            	   348:          inc  WORK
00:AE37 D002            	   349:          bne  DIS5_A
00:AE39 E638            	   350:          inc  WORK+1
                        	   351: DIS5_A   =  *
00:AE3B A8              	   352:          tay
00:AE3C 8A              	   353:          txa
00:AE3D 48              	   354:          pha
00:AE3E 98              	   355:          tya
00:AE3F 203D92          	   356:          jsr  DISHX
00:AE42 68              	   357:          pla
00:AE43 AA              	   358:          tax
00:AE44 CA              	   359:          dex
00:AE45 D0EA            	   360:          bne  DIS5
00:AE47 60              	   361:          rts
                        	   362: 
                        	   363: ;
                        	   364: ; Ding a bell - however we don't have it on this board
                        	   365: ;
                        	   366: BELL1    =  *
00:AE48 48              	   367:          pha
00:AE49 A900            	   368:          lda  #0
00:AE4B 853F            	   369:          sta  RUNNING
00:AE4D 202892          	   370:          jsr  CROUT
00:AE50 68              	   371:          pla
00:AE51 60              	   372:          rts
                        	   373: ;
                        	   374: ;
00:AE52 2048AE          	   375: RUNERR   jsr  BELL1
00:AE55 A910            	   376:          lda  #<DM7  ; Error occurred at P-code
00:AE57 A2AE            	   377:          ldx  #>DM7
00:AE59 202682          	   378:          jsr  print
00:AE5C A54E            	   379:          lda  LASTP+1
00:AE5E 209D92          	   380:          jsr  PRBYTE
00:AE61 A54D            	   381:          lda  LASTP
00:AE63 203D92          	   382:          jsr  DISHX
                        	   383: EX_FINISHD  =  *
00:AE66 A900            	   384:          lda  #0
00:AE68 202892          	   385:          jsr  CROUT
00:AE6B A97D            	   386:          lda  #<FIN_MSG
00:AE6D A2AE            	   387:          ldx  #>FIN_MSG
00:AE6F 202682          	   388:          jsr  print
00:AE72 648B            	   389:          stz  serial_in_byte_received  ; get rid of read-ahead
00:AE74 2076C8          	   390:          jsr  GETIN      ; wait till message seen
00:AE77 202892          	   391:          jsr  CROUT      ; output a newline in case they press space or something
00:AE7A 4C55CF          	   392:          jmp  RESTART
                        	   393: ;
00:AE7D 52756E2066696E69	   394: FIN_MSG  asciiz  'Run finished - press a key ...'
00:AE85 73686564202D2070
00:AE8D 726573732061206B
00:AE95 6579202E2E2E
00:AE9B 00
                        	   395: ;
                        	   396: ;
                        	   397: CHK_KBD  =  *
00:AE9C C90E            	   398:          cmp  #KEY_STOP_TRACE       ; Ctrl+N - stop tracing
00:AE9E D008            	   399:          bne  CHK_NOTN
00:AEA0 648B            	   400:          stz  serial_in_byte_received
00:AEA2 A900            	   401:          lda  #0
00:AEA4 8549            	   402:          sta  DBGFLG
00:AEA6 38              	   403:          sec
00:AEA7 60              	   404:          rts
00:AEA8 C914            	   405: CHK_NOTN cmp  #KEY_TRACE      ; Ctrl+T - start tracing
00:AEAA D00A            	   406:          bne  CHK_NOTT
00:AEAC 648B            	   407:          stz  serial_in_byte_received
00:AEAE A980            	   408:          lda  #$80
00:AEB0 8549            	   409:          sta  DBGFLG
00:AEB2 852E            	   410:          sta  DCODE
00:AEB4 38              	   411:          sec
00:AEB5 60              	   412:          rts
00:AEB6 C904            	   413: CHK_NOTT cmp  #KEY_DEBUG      ; Ctrl+D - start debugging
00:AEB8 D00A            	   414:          bne  CHK_NOTD
00:AEBA 648B            	   415:          stz  serial_in_byte_received
00:AEBC A901            	   416:          lda  #1
00:AEBE 8549            	   417:          sta  DBGFLG
00:AEC0 852E            	   418:          sta  DCODE
00:AEC2 38              	   419:          sec
00:AEC3 60              	   420:          rts
00:AEC4 18              	   421: CHK_NOTD clc
00:AEC5 60              	   422:          rts
                        	   423: ;
                        	   424: EX_OUTCR    =  *
00:AEC6 202892          	   425:   jsr  CROUT      ; OUTPUT C/R
00:AEC9 4CDBAE          	   426:   jmp  MAIN
                        	   427: ;
                        	   428: ;  Here for a "low literal" - a P-code with the 0x80 bit set. Clear that bit and push
                        	   429: ;   the resulting number onto the stack
                        	   430: ;
                        	   431: LOWLIT:
00:AECC E623            	   432:   inc  PCODE     ; increment P-code past the low literal
00:AECE D002            	   433:   bne  LOWLIT1
00:AED0 E624            	   434:   inc  PCODE+1
                        	   435: LOWLIT1:
00:AED2 8401            	   436:   sty  REG+1     ; Y and REGB were cleared below
00:AED4 297F            	   437:   and  #$7F
00:AED6 8500            	   438:   sta  REG
                        	   439: ;
                        	   440: ;  fall down to push this value
                        	   441: ;
                        	   442: 
                        	   443: 
                        	   444: ;
                        	   445: ; Push previous result (REG) and then drop down to do the next instruction
                        	   446: ;
                        	   447: MAINP:
00:AED8 20B8AF          	   448:  jsr  PSHTOP    ; push REG onto stack and go back to MAIN
                        	   449: 
                        	   450: ;
                        	   451: ;  Main interpreter loop - each instruction jumps back here (or to MAINP above if it
                        	   452: ;              needs to push a previous calculation result)
                        	   453: ;
                        	   454: MAIN:
00:AEDB A549            	   455:   lda  DBGFLG   ; debugging?
00:AEDD F003            	   456:   beq  MAIN_2   ; no
00:AEDF 2061AD          	   457:   jsr  DEBUG    ; yes - show debug info
                        	   458: MAIN_2   =  *
                        	   459: ; check if key pressed here, to abort, or turn on/off tracing or debugging
00:AEE2 A58B            	   460:   lda  serial_in_byte_received
00:AEE4 F00A            	   461:   beq  MAIN_OK
00:AEE6 C903            	   462:   cmp  #KEY_ABORT
00:AEE8 D003            	   463:   bne  MAIN_NOT_ABORT
00:AEEA 4C66AE          	   464:   jmp  EX_FINISHD
                        	   465: MAIN_NOT_ABORT = *
00:AEED 209CAE          	   466:   jsr  CHK_KBD          ; check for turning on trace, debug, etc.
                        	   467: MAIN_OK  =  *
00:AEF0 A523            	   468:   lda  PCODE             ; save P-code address as LASTP (for errors I presume)
00:AEF2 854D            	   469:   sta  LASTP
00:AEF4 A524            	   470:   lda  PCODE+1
00:AEF6 854E            	   471:   sta  LASTP+1
                        	   472: ;
                        	   473: ;  now grab the P-code
                        	   474: ;
00:AEF8 A000            	   475:   ldy  #0
00:AEFA 8402            	   476:   sty  REGB
00:AEFC B123            	   477:   lda  (PCODE),Y         ; get the P-code from the P-codes
00:AEFE 30CC            	   478:   bmi  LOWLIT            ; low literal - just handle it
00:AF00 C946            	   479:   cmp  #PCODE_LAST+1
00:AF02 B015            	   480:   bcs  EX_INVINS         ; error if off end of table
                        	   481: ;
                        	   482: ;  increment past this P-code
                        	   483: ;
                        	   484: MAIN_5   =  *
00:AF04 E623            	   485:   inc  PCODE
00:AF06 D002            	   486:   bne  MAIN_1
00:AF08 E624            	   487:   inc  PCODE+1
                        	   488: ;
                        	   489: ;  grab the execution handler from the execution_address_table
                        	   490: ;
                        	   491: MAIN_1   =  *
00:AF0A 0A              	   492:   asl  A             ; double the P-code because each address takes 2 bytes
00:AF0B AA              	   493:   tax
00:AF0C BDBAAC          	   494:   lda  execution_address_table,X      ; otherwise get the execution address
00:AF0F 8537            	   495:   sta  WORK
00:AF11 BDBBAC          	   496:   lda  execution_address_table+1,X    ; and the high-order byte
00:AF14 8538            	   497:   sta  WORK+1
00:AF16 6C3700          	   498:   jmp  (WORK)        ; execute the appropriate P-code implementation routine
                        	   499: 
                        	   500: ;
                        	   501: NOTIMP   =  *
                        	   502: EX_INVINS   =  *
00:AF19 A9F0            	   503:          LDA  #<DM5   ; Illegal Instruction
00:AF1B A2AD            	   504:          LDX  #>DM5
                        	   505: NOTIM1   =  *
00:AF1D 202682          	   506:          JSR  print
00:AF20 4C52AE          	   507:          JMP  RUNERR
                        	   508: ;
                        	   509: BREAK    =  *
00:AF23 A905            	   510:          LDA  #<DM6  ; Break ...
00:AF25 A2AE            	   511:          LDX  #>DM6
00:AF27 4C1DAF          	   512:          JMP  NOTIM1
                        	   513: 
                        	   514: 
00:AF2A A000            	   515: GETADR   LDY  #0
00:AF2C B123            	   516:          LDA  (PCODE),Y     ; level
00:AF2E 854B            	   517:          STA  COUNT1        ; count of levels to work through
00:AF30 A53C            	   518:          LDA  BASE+1        ; start with our stack base address
00:AF32 A63B            	   519:          LDX  BASE
                        	   520: GET2     =  *
00:AF34 853E            	   521:          STA  DATA+1        ; our data is relative to the stack base
00:AF36 863D            	   522:          STX  DATA
00:AF38 A8              	   523:          TAY
00:AF39 A54B            	   524:          LDA  COUNT1        ; any levels left?
00:AF3B F018            	   525:          BEQ  GETADR1       ; no, we can continue
00:AF3D 38              	   526:          SEC                ; yes
00:AF3E 8A              	   527:          TXA                ; subtract 2 from the base to get the static link
00:AF3F E902            	   528:          SBC  #2
00:AF41 8537            	   529:          STA  WORK
00:AF43 98              	   530:          TYA
00:AF44 E900            	   531:          SBC  #0
00:AF46 8538            	   532:          STA  WORK+1        ; BASE - 2 -> WORK
00:AF48 A000            	   533:          LDY  #0
00:AF4A B137            	   534:          LDA  (WORK),Y      ; grab contents of BASE-2
00:AF4C C8              	   535:          INY
00:AF4D AA              	   536:          TAX
00:AF4E B137            	   537:          LDA  (WORK),Y
00:AF50 C64B            	   538:          DEC  COUNT1        ; one less level
00:AF52 4C34AF          	   539:          JMP  GET2          ; keep going until we used all levels
                        	   540: 
                        	   541: GETADR1     =  *
00:AF55 A001            	   542:          LDY  #1            ; now get the offset
00:AF57 18              	   543:          CLC
00:AF58 B123            	   544:          LDA  (PCODE),Y     ; offset low-order byte
00:AF5A 653D            	   545:          ADC  DATA          ; add base
00:AF5C 853D            	   546:          STA  DATA
00:AF5E C8              	   547:          INY
00:AF5F B123            	   548:          LDA  (PCODE),Y     ; offset high-order byte
00:AF61 653E            	   549:          ADC  DATA+1        ; add base
00:AF63 853E            	   550:          STA  DATA+1        ; DATA now holds the data address
00:AF65 A523            	   551:          LDA  PCODE         ; add 3 to PCODE to skip level and offset
00:AF67 18              	   552:          CLC
00:AF68 6903            	   553:          ADC  #3
00:AF6A 8523            	   554:          STA  PCODE
00:AF6C 9002            	   555:          BCC  GET1_A
00:AF6E E624            	   556:          INC  PCODE+1
                        	   557: GET1_A   =  *
00:AF70 60              	   558:          RTS                ; done - we can use DATA to access whatever-it-is
                        	   559: 
                        	   560: ;
                        	   561: ;  Pull the top item on the runtime stack into REG (aka VALUE)
                        	   562: ;
                        	   563: PULTOP   =  *
00:AF71 A000            	   564:          LDY  #0
00:AF73 B131            	   565:          LDA  (T),Y
00:AF75 8500            	   566:          STA  REG
00:AF77 C8              	   567:          INY
00:AF78 B131            	   568:          LDA  (T),Y
00:AF7A 8501            	   569:          STA  REG+1
00:AF7C C8              	   570:          INY
00:AF7D B131            	   571:          LDA  (T),Y
00:AF7F 8502            	   572:          STA  REGB
00:AF81 A531            	   573:          LDA  T
00:AF83 18              	   574:          CLC      ; add 3 to the stack because we removed one integer from it
00:AF84 6903            	   575:          ADC  #3
00:AF86 8531            	   576:          STA  T
00:AF88 9002            	   577:          BCC  PUL_END
00:AF8A E632            	   578:          INC  T+1
                        	   579: PUL_END  =  *
00:AF8C A500            	   580:          LDA  REG
00:AF8E A601            	   581:          LDX  REG+1
00:AF90 A402            	   582:          LDY  REGB
00:AF92 60              	   583:          RTS
                        	   584: 
00:AF93 2071AF          	   585: PULBOTH  JSR  PULTOP     ; Pulls both of them - do one and then fall through to do the other
                        	   586: 
                        	   587: ;
                        	   588: ;  Pull the top item on the runtime stack into REG2 (aka VALUE2)
                        	   589: ;
                        	   590: PULTOP2  =  *
00:AF96 A000            	   591:          LDY  #0
00:AF98 B131            	   592:          LDA  (T),Y
00:AF9A 8503            	   593:          STA  REG2
00:AF9C C8              	   594:          INY
00:AF9D B131            	   595:          LDA  (T),Y
00:AF9F 8504            	   596:          STA  REG2+1
00:AFA1 C8              	   597:          INY
00:AFA2 B131            	   598:          LDA  (T),Y
00:AFA4 8505            	   599:          STA  REG2B
00:AFA6 A531            	   600:          LDA  T
00:AFA8 18              	   601:          CLC         ; add 3 to the stack because we removed one integer from it
00:AFA9 6903            	   602:          ADC  #3
00:AFAB 8531            	   603:          STA  T
00:AFAD 9002            	   604:          BCC  PUL2_END
00:AFAF E632            	   605:          INC  T+1
                        	   606: PUL2_END =  *
00:AFB1 A503            	   607:          LDA  REG2
00:AFB3 A604            	   608:          LDX  REG2+1
00:AFB5 A405            	   609:          LDY  REG2B
00:AFB7 60              	   610:          RTS
                        	   611: 
                        	   612: ;
                        	   613: ;  Push REG (aka VALUE) onto the runtime stack
                        	   614: ;
                        	   615: PSHTOP   =  *
00:AFB8 38              	   616:          SEC        ;  subtract 3 from the stack because we are about to add one integer to it
00:AFB9 A531            	   617:          LDA  T
00:AFBB E903            	   618:          SBC  #3
00:AFBD 8531            	   619:          STA  T
00:AFBF B002            	   620:          BCS  PSH1
00:AFC1 C632            	   621:          DEC  T+1
                        	   622: PSH1     =  *
00:AFC3 A000            	   623:          LDY  #0
00:AFC5 A500            	   624:          LDA  REG
00:AFC7 9131            	   625:          STA  (T),Y
00:AFC9 C8              	   626:          INY
00:AFCA A501            	   627:          LDA  REG+1
00:AFCC 9131            	   628:          STA  (T),Y
00:AFCE C8              	   629:          INY
00:AFCF A502            	   630:          LDA  REGB
00:AFD1 9131            	   631:          STA  (T),Y
00:AFD3 60              	   632:          RTS
                        	   633: ;
                        	   634: ;  get a literal (2 bytes) from the P-codes and put it into REG
                        	   635: ;
                        	   636: GETLIT   =  *
00:AFD4 A000            	   637:   ldy  #0
00:AFD6 B123            	   638:   lda  (PCODE),Y
00:AFD8 8500            	   639:   sta  REG
00:AFDA C8              	   640:   iny
00:AFDB B123            	   641:   lda  (PCODE),Y
00:AFDD 8501            	   642:   sta  REG+1
00:AFDF A523            	   643:   lda  PCODE
00:AFE1 18              	   644:   clc         ; P-code address goes up by 2
00:AFE2 6902            	   645:   adc  #2
00:AFE4 8523            	   646:   sta  PCODE
00:AFE6 9002            	   647:   bcc  GET_END
00:AFE8 E624            	   648:   inc  PCODE+1
                        	   649: GET_END:
00:AFEA 60              	   650:   rts
                        	   651: ;
                        	   652: ; load literal onto the stack (the literal is the next 3 bytes after the P-code)
                        	   653: ;
                        	   654: EX_LIT:
00:AFEB 20D4AF          	   655:   jsr  GETLIT   ; get the first 2 bytes
00:AFEE A000            	   656:   ldy  #0
00:AFF0 B123            	   657:   lda  (PCODE),Y    ; now the third byte
00:AFF2 8502            	   658:   sta  REGB
00:AFF4 E623            	   659:   inc  PCODE
00:AFF6 D002            	   660:   bne  LIT1
00:AFF8 E624            	   661:   inc  PCODE+1
                        	   662: LIT1:
00:AFFA 4CD8AE          	   663:   jmp  MAINP    ; now we can push it
                        	   664: ;
                        	   665: ;  Negate (0 - (sp) )
                        	   666: ;
                        	   667: EX_NEG:
00:AFFD 2071AF          	   668:   jsr PULTOP
00:B000 208AAB          	   669:   jsr exp_unary_minus
00:B003 4CD8AE          	   670:   jmp MAINP
                        	   671: ;
                        	   672: ;  Add (sp) to (sp -1)
                        	   673: ;
                        	   674: EX_ADD:
00:B006 2093AF          	   675:   JSR  PULBOTH
00:B009 2043AA          	   676:   jsr  exp_add
00:B00C 4CD8AE          	   677:   JMP  MAINP
                        	   678: ;
                        	   679: ;
                        	   680: ;  Add (sp) from (sp - 1)
                        	   681: ;
                        	   682: EX_SUB:
00:B00F 2096AF          	   683:   JSR  PULTOP2
00:B012 2071AF          	   684:   jsr  PULTOP
00:B015 2057AA          	   685:   jsr  exp_subtract
00:B018 4CD8AE          	   686:   JMP  MAINP
                        	   687: ;
                        	   688: ;  Multiply (sp) by (sp - 1)
                        	   689: ;
                        	   690: EX_MUL:
00:B01B 2093AF          	   691:   jsr PULBOTH
00:B01E 2011AC          	   692:   jsr exp_multiply
00:B021 4CD8AE          	   693:   jmp MAINP
                        	   694: 
                        	   695: ;
                        	   696: ;  we will take the current key (and return to the user)
                        	   697: ;  and zero it out anyway, so that consumes the key
                        	   698: ;
                        	   699: EX_GETKEY   =  *
00:B024 A58B            	   700:   lda  serial_in_byte_received
00:B026 648B            	   701:   stz  serial_in_byte_received
00:B028 4C7EB0          	   702:   jmp  TRUE2
                        	   703: ;
                        	   704: ;  Modulus (remainder)
                        	   705: ;
                        	   706: EX_MOD:
00:B02B 2096AF          	   707:   jsr PULTOP2
                        	   708: ;
                        	   709: ;  check for divide by zero because I want a run-time error message
                        	   710: ;
00:B02E A503            	   711:   lda VALUE2
00:B030 0504            	   712:   ora VALUE2+1
00:B032 0505            	   713:   ora VALUE2+2
00:B034 F009            	   714:   beq EX_DIVIDE_BY_ZERO
00:B036 2071AF          	   715:   jsr PULTOP
00:B039 20AAAC          	   716:   jsr exp_modulo
00:B03C 4CD8AE          	   717:   jmp MAINP
                        	   718: ;
                        	   719: 
                        	   720: EX_DIVIDE_BY_ZERO:
00:B03F A946            	   721:   lda  #<DIVBY0
00:B041 A2B0            	   722:   ldx  #>DIVBY0
00:B043 4C1DAF          	   723:   jmp  NOTIM1
                        	   724: 
00:B046 4469766964652062	   725: DIVBY0   asciiz  'Divide by zero\n'
00:B04E 79207A65726F0A
00:B055 00
                        	   726: ;
                        	   727: ;  Divide (sp - 1) by (sp)
                        	   728: ;
                        	   729: EX_DIV:
00:B056 2096AF          	   730:   jsr PULTOP2
00:B059 A503            	   731:   lda VALUE2
00:B05B 0504            	   732:   ora VALUE2+1
00:B05D 0505            	   733:   ora VALUE2+2
00:B05F F0DE            	   734:   beq EX_DIVIDE_BY_ZERO
00:B061 2071AF          	   735:   jsr PULTOP
00:B064 204AAC          	   736:   jsr exp_divide
00:B067 4CD8AE          	   737:   jmp MAINP
                        	   738: 
                        	   739: ;
                        	   740: ;  Absolute value of (sp)
                        	   741: ;
                        	   742: EX_ABS:
00:B06A 2071AF          	   743:   jsr  PULTOP
00:B06D 20ACAB          	   744:   jsr exp_abs_val
00:B070 4CD8AE          	   745:   jmp  MAINP
                        	   746: 
                        	   747: ; Equal
                        	   748: ;
                        	   749: EX_EQL:
00:B073 2093AF          	   750:   jsr PULBOTH
00:B076 207DAA          	   751:   jsr exp_eql
00:B079 4CD8AE          	   752:   jmp MAINP
                        	   753: 
                        	   754: ;
                        	   755: ;  Push 1
                        	   756: ;
                        	   757: TRUE:
00:B07C A901            	   758:   lda  #1
                        	   759: ;
                        	   760: ;  Push A into low-order byte, zero other two bytes
                        	   761: ;
                        	   762: TRUE2:
00:B07E 8500            	   763:   sta  REG
00:B080 A900            	   764:   lda  #0
00:B082 8501            	   765:   sta  REG+1
00:B084 8502            	   766:   sta  REGB
00:B086 4CD8AE          	   767:   jmp  MAINP
                        	   768: 
                        	   769: ;
                        	   770: ;  Push 0
                        	   771: ;
                        	   772: FALSE:
00:B089 A900            	   773:   lda  #0
00:B08B 80F1            	   774:   bra TRUE2
                        	   775: ;
                        	   776: ;  Not equal
                        	   777: ;
                        	   778: EX_NEQ:
00:B08D 2093AF          	   779:     jsr PULBOTH
00:B090 2091AA          	   780:     jsr exp_neq
00:B093 4CD8AE          	   781:     jmp MAINP
                        	   782: 
                        	   783: ;
                        	   784: ;  Less than
                        	   785: ;
                        	   786: EX_LSS:
00:B096 2096AF          	   787:   jsr PULTOP2
00:B099 2071AF          	   788:   jsr PULTOP
00:B09C 20A5AA          	   789:   jsr exp_less_than
00:B09F 4CD8AE          	   790:   jmp MAINP
                        	   791: 
                        	   792: ;
                        	   793: ;  Greater than
                        	   794: ;
                        	   795: EX_GTR:
00:B0A2 2096AF          	   796:   jsr PULTOP2
00:B0A5 2071AF          	   797:   jsr PULTOP
00:B0A8 20ACAA          	   798:   jsr exp_greater_than
00:B0AB 4CD8AE          	   799:   jmp MAINP
                        	   800: 
                        	   801: ;
                        	   802: ;  Greater than or equal
                        	   803: ;
                        	   804: EX_GEQ:
00:B0AE 2096AF          	   805:   jsr PULTOP2
00:B0B1 2071AF          	   806:   jsr PULTOP
00:B0B4 20CAAA          	   807:   jsr exp_geq
00:B0B7 4CD8AE          	   808:   jmp MAINP
                        	   809: 
                        	   810: ;
                        	   811: ;  Less than or equal
                        	   812: ;
                        	   813: EX_LEQ:
00:B0BA 2096AF          	   814:   jsr PULTOP2
00:B0BD 2071AF          	   815:   jsr PULTOP
00:B0C0 20BBAA          	   816:   jsr exp_leq
00:B0C3 4CD8AE          	   817:   jmp MAINP
                        	   818: 
                        	   819: ;
                        	   820: ;  Exclusive OR
                        	   821: ;
                        	   822: EX_XOR:
00:B0C6 2093AF          	   823:   jsr PULBOTH
00:B0C9 20FBAA          	   824:   jsr exp_bitwise_xor
00:B0CC 4CD8AE          	   825:   jmp MAINP
                        	   826: ;
                        	   827: ;  Or
                        	   828: ;
                        	   829: EX_ORR:
00:B0CF 2093AF          	   830:   jsr PULBOTH
00:B0D2 20D1AA          	   831:   jsr exp_bitwise_or
00:B0D5 4CD8AE          	   832:   jmp MAINP
                        	   833: 
                        	   834: ;
                        	   835: ;  And
                        	   836: ;
                        	   837: EX_AND:
00:B0D8 2093AF          	   838:   jsr  PULBOTH
00:B0DB 20E6AA          	   839:   jsr exp_bitwise_and
00:B0DE 4CD8AE          	   840:   jmp MAINP
                        	   841: 
                        	   842: ;
                        	   843: ;  Not
                        	   844: ;
                        	   845: EX_EOR:
00:B0E1 2071AF          	   846:   jsr PULTOP
00:B0E4 207CAB          	   847:   jsr exp_not
00:B0E7 4CD8AE          	   848:   jmp MAINP
                        	   849: ;
                        	   850: ; Shift left
                        	   851: ;
                        	   852: EX_SHL:
00:B0EA 2096AF          	   853:   jsr PULTOP2
00:B0ED 2071AF          	   854:   jsr PULTOP
00:B0F0 2037AB          	   855:   jsr exp_shift_left
00:B0F3 4CD8AE          	   856:   jmp MAINP
                        	   857: 
                        	   858: ;
                        	   859: ;  Shift right
                        	   860: ;
                        	   861: EX_SHR:
00:B0F6 2096AF          	   862:   jsr PULTOP2
00:B0F9 2071AF          	   863:   jsr PULTOP
00:B0FC 2050AB          	   864:   jsr exp_shift_right
00:B0FF 4CD8AE          	   865:   jmp MAINP
                        	   866: 
                        	   867: ;
                        	   868: ;  increment number on top of stack by one
                        	   869: ;
                        	   870: EX_INC:
00:B102 18              	   871:   clc
00:B103 B131            	   872:   lda  (T),Y
00:B105 6901            	   873:   adc  #1
00:B107 9131            	   874:   sta  (T),Y
00:B109 C8              	   875:   iny
00:B10A B131            	   876:   lda  (T),Y
00:B10C 6900            	   877:   adc  #0
00:B10E 9131            	   878:   sta  (T),Y
00:B110 C8              	   879:   iny
00:B111 B131            	   880:   lda  (T),Y
00:B113 6900            	   881:   adc  #0
00:B115 9131            	   882:   sta  (T),Y
00:B117 4CDBAE          	   883:   jmp  MAIN
                        	   884: ;
                        	   885: ;  decrement number on top of stack by one
                        	   886: ;
                        	   887: 
                        	   888: EX_DEC:
00:B11A 38              	   889:   sec
00:B11B B131            	   890:   lda  (T),Y
00:B11D E901            	   891:   sbc  #1
00:B11F 9131            	   892:   sta  (T),Y
00:B121 C8              	   893:   iny
00:B122 B131            	   894:   lda  (T),Y
00:B124 E900            	   895:   sbc  #0
00:B126 9131            	   896:   sta  (T),Y
00:B128 C8              	   897:   iny
00:B129 B131            	   898:   lda  (T),Y
00:B12B E900            	   899:   sbc  #0
00:B12D 9131            	   900:   sta  (T),Y
00:B12F 4CDBAE          	   901:   jmp  MAIN
                        	   902: 
                        	   903: ;
                        	   904: ;  Copy (sp) to (sp + 1)
                        	   905: ;
                        	   906: EX_MOV:
00:B132 B131            	   907:   lda  (T),Y  ; get item at top of stack
00:B134 8500            	   908:   sta REG
00:B136 C8              	   909:   iny
00:B137 B131            	   910:   lda  (T),Y
00:B139 8501            	   911:   sta REG+1
00:B13B C8              	   912:   iny
00:B13C B131            	   913:   lda  (T),Y
00:B13E 8502            	   914:   sta REGB
00:B140 4CD8AE          	   915:   jmp MAINP   ; push it
                        	   916: 
                        	   917: ;
                        	   918: ;  Load a single-character value (variable) onto the stack
                        	   919: ;
                        	   920: 
                        	   921: EX_LODC:
00:B143 202AAF          	   922:   jsr  GETADR
                        	   923: EX_LOD3:
00:B146 A002            	   924:   ldy  #2
                        	   925: EX_LOD3_A:
00:B148 A900            	   926:   lda  #0      ; since this is a character zero out the high-order bytes
00:B14A 8501            	   927:   sta  REG+1
00:B14C 8502            	   928:   sta  REGB
00:B14E B13D            	   929:   lda  (DATA),Y  ; (DATA) contains the lower-order byte
00:B150 8500            	   930:   sta  REG       ; REG will be pushed
00:B152 4CD8AE          	   931:   jmp  MAINP     ; push REG and go to MAIN
                        	   932: ;
                        	   933: ;  Load a 3-byte value (variable) onto the stack
                        	   934: ;
                        	   935: EX_LOD:
00:B155 202AAF          	   936:   jsr  GETADR
                        	   937: EX_LOD2:
00:B158 A000            	   938:   ldy  #0
00:B15A B13D            	   939:   lda  (DATA),Y    ; (DATA) contains the variable value
00:B15C 8500            	   940:   sta  REG
00:B15E C8              	   941:   iny
00:B15F B13D            	   942:   lda  (DATA),Y
00:B161 8501            	   943:   sta  REG+1
00:B163 C8              	   944:   iny
00:B164 B13D            	   945:   lda  (DATA),Y
00:B166 8502            	   946:   sta REGB
00:B168 4CD8AE          	   947:   jmp MAINP   ; push it
                        	   948: 
                        	   949: ;
                        	   950: ;  Load absolute address character
                        	   951: ;
                        	   952: EX_LDAC:
00:B16B 2071AF          	   953:   jsr  PULTOP
00:B16E 853D            	   954:   sta  DATA
00:B170 863E            	   955:   stx  DATA+1
00:B172 A000            	   956:   ldy  #0
00:B174 F0D2            	   957:   beq  EX_LOD3_A
                        	   958: ;
                        	   959: ;  Load absolute address integer
                        	   960: ;
                        	   961: EX_LDA:
00:B176 2071AF          	   962:   jsr  PULTOP
00:B179 853D            	   963:   sta  DATA
00:B17B 863E            	   964:   stx  DATA+1
00:B17D 4C58B1          	   965:   jmp  EX_LOD2
                        	   966: ;
                        	   967: ;  Get address of indexed character
                        	   968: ;
                        	   969: GETIDC:
00:B180 2096AF          	   970:   jsr  PULTOP2    ; pull index into REG2
00:B183 202AAF          	   971:   jsr  GETADR
00:B186 4C9DB1          	   972:   jmp  GETID2
                        	   973: ;
                        	   974: ;  Get address of indexed integer
                        	   975: ;
                        	   976: GETIDX   =  *
00:B189 2096AF          	   977:   jsr  PULTOP2  ; pull index into REG2
00:B18C 0603            	   978:   asl  REG2     ; now multiply by 3
00:B18E 2604            	   979:   rol  REG2+1
00:B190 18              	   980:   clc
00:B191 6503            	   981:   adc  REG2
00:B193 8503            	   982:   sta  REG2
00:B195 8A              	   983:   txa
00:B196 6504            	   984:   adc  REG2+1
00:B198 8504            	   985:   sta  REG2+1     ; TIMES 3
00:B19A 202AAF          	   986:   jsr  GETADR
                        	   987: ;
                        	   988: ;  Get address of indexed integer/character
                        	   989: ;
                        	   990: ;  It looks like arrays expand downwards
                        	   991: ;
                        	   992: GETID2:
00:B19D A53D            	   993:   lda  DATA     ; initial address
00:B19F 38              	   994:   sec           ; subtract subscript
00:B1A0 E503            	   995:   sbc  REG2
00:B1A2 853D            	   996:   sta  DATA
00:B1A4 A53E            	   997:   lda  DATA+1
00:B1A6 E504            	   998:   sbc  REG2+1
00:B1A8 853E            	   999:   sta  DATA+1
00:B1AA 60              	  1000:   rts
                        	  1001: ;
                        	  1002: ;  Load indexed character
                        	  1003: ;
                        	  1004: EX_LDIC:
00:B1AB 2080B1          	  1005:   jsr  GETIDC
00:B1AE 4C46B1          	  1006:   jmp  EX_LOD3
                        	  1007: ;
                        	  1008: ;  Load indexed integer
                        	  1009: ;
                        	  1010: EX_LDI:
00:B1B1 2089B1          	  1011:   jsr  GETIDX
00:B1B4 4C58B1          	  1012:   jmp  EX_LOD2
                        	  1013: ;
                        	  1014: ;  Store character
                        	  1015: ;
                        	  1016: EX_STOC:
00:B1B7 202AAF          	  1017:   jsr  GETADR
00:B1BA 2071AF          	  1018:   jsr  PULTOP
00:B1BD A002            	  1019:   ldy  #2   ; why?
                        	  1020: EX_STO5:
00:B1BF 913D            	  1021:   sta  (DATA),Y
00:B1C1 4CDBAE          	  1022:   jmp  MAIN
                        	  1023: ;
                        	  1024: ;  Store integer
                        	  1025: ;
                        	  1026: EX_STO:
00:B1C4 202AAF          	  1027:   jsr  GETADR   ; get its address
00:B1C7 2071AF          	  1028:   jsr  PULTOP   ; get the value to store
                        	  1029: EX_STO2:
00:B1CA A000            	  1030:   ldy  #0
00:B1CC 913D            	  1031:   sta  (DATA),Y
00:B1CE C8              	  1032:   iny
00:B1CF 8A              	  1033:   txa
00:B1D0 913D            	  1034:   sta  (DATA),Y
00:B1D2 A502            	  1035:   lda  REGB
00:B1D4 C8              	  1036:   iny
00:B1D5 D0E8            	  1037:   bne  EX_STO5
                        	  1038: ;
                        	  1039: ;  Store integer at absolute address
                        	  1040: ;
                        	  1041: EX_STA:
00:B1D7 2093AF          	  1042:   jsr  PULBOTH  ; get address into REG2 and value into REG
00:B1DA A000            	  1043:   ldy  #0
00:B1DC A500            	  1044:   lda  REG
00:B1DE 9103            	  1045:   sta  (REG2),Y
00:B1E0 C8              	  1046:   iny
00:B1E1 A501            	  1047:   lda  REG+1
00:B1E3 9103            	  1048:   sta  (REG2),Y
00:B1E5 C8              	  1049:   iny
00:B1E6 A502            	  1050:   lda  REGB
                        	  1051: EX_STA5:
00:B1E8 9103            	  1052:   sta  (REG2),Y
00:B1EA 4CDBAE          	  1053:   jmp  MAIN
                        	  1054: ;
                        	  1055: ;  Store character at absolute address
                        	  1056: ;
                        	  1057: EX_STAC:
00:B1ED 2093AF          	  1058:   jsr  PULBOTH  ; get address into REG2 and value into REG
00:B1F0 A500            	  1059:   lda  REG
00:B1F2 A000            	  1060:   ldy  #0
00:B1F4 F0F2            	  1061:   beq  EX_STA5
                        	  1062: ;
                        	  1063: ;   	Store character indexed
                        	  1064: ;
                        	  1065: EX_STIC:
00:B1F6 2071AF          	  1066:   jsr  PULTOP
00:B1F9 8545            	  1067:   sta  TEMP
00:B1FB 2080B1          	  1068:   jsr  GETIDC
00:B1FE A545            	  1069:   lda  TEMP
00:B200 A002            	  1070:   ldy  #2
00:B202 D0BB            	  1071:   bne  EX_STO5
                        	  1072: ;
                        	  1073: ;   	Store integer indexed
                        	  1074: ;
                        	  1075: EX_STI :
00:B204 2071AF          	  1076:   jsr  PULTOP
00:B207 8545            	  1077:   sta  TEMP
00:B209 8646            	  1078:   stx  TEMP+1
00:B20B 98              	  1079:   tya
00:B20C 48              	  1080:   pha
00:B20D 2089B1          	  1081:   jsr  GETIDX
00:B210 A000            	  1082:   ldy  #0
00:B212 A545            	  1083:   lda  TEMP
00:B214 913D            	  1084:   sta  (DATA),Y
00:B216 A546            	  1085:   lda  TEMP+1
00:B218 C8              	  1086:   iny
00:B219 913D            	  1087:   sta  (DATA),Y
00:B21B 68              	  1088:   pla
00:B21C C8              	  1089:   iny
00:B21D D0A0            	  1090:   bne  EX_STO5
                        	  1091: ;
                        	  1092: ;  Procedure/function return
                        	  1093: ;
                        	  1094: ;  Stack frame linkage data:
                        	  1095: ;
                        	  1096: ;    (from low to high address)
                        	  1097: ;
                        	  1098: ;    Return address <-- P-code to return to when function/procedure exits
                        	  1099: ;    Dynamic link   <-- The previous stack frame from the earlier function call
                        	  1100: ;    Static link    <-- The stack frame of the previous static function
                        	  1101: ;
                        	  1102: ;  Static and dynamic links will be the same except for recursive calls.
                        	  1103: ;
                        	  1104: ;  To unwind the stack we have to go back to the previous dynamic link (on a return)
                        	  1105: ;
                        	  1106: ;  However to find variables in previous lexical declarations we have to use the static link.
                        	  1107: ;
                        	  1108: ;
                        	  1109: EX_RTN:
                        	  1110: ;
                        	  1111: ;  Subtract 6 from the base address, put result into WORK
                        	  1112: ;
00:B21F 38              	  1113:   sec
00:B220 A53B            	  1114:   lda  BASE
00:B222 E906            	  1115:   sbc  #6
00:B224 8537            	  1116:   sta  WORK
00:B226 A53C            	  1117:   lda  BASE+1
00:B228 E900            	  1118:   sbc  #0
00:B22A 8538            	  1119:   sta  WORK+1
                        	  1120: ;
                        	  1121: ;  The return address was at the bottom of BASE, so put that into PCODE
                        	  1122: ;
00:B22C A000            	  1123:   ldy  #0
00:B22E B137            	  1124:   lda  (WORK),Y
00:B230 8523            	  1125:   sta  PCODE
00:B232 C8              	  1126:   iny
00:B233 B137            	  1127:   lda  (WORK),Y
00:B235 8524            	  1128:   sta  PCODE+1
                        	  1129: 
                        	  1130: ;
                        	  1131: ;  The base address becomes our new top of runtime stack
                        	  1132: ;
00:B237 A53C            	  1133:   lda  BASE+1
00:B239 8532            	  1134:   sta  T+1
00:B23B A53B            	  1135:   lda  BASE
00:B23D 8531            	  1136:   sta  T
                        	  1137: ;
                        	  1138: ;  The dynamic stack frame address is 4 bytes down from the BASE - put that into WORK
                        	  1139: ;
00:B23F 38              	  1140:   sec
00:B240 E904            	  1141:   sbc  #4
00:B242 8537            	  1142:   sta  WORK
00:B244 A53C            	  1143:   lda  BASE+1
00:B246 E900            	  1144:   sbc  #0
00:B248 8538            	  1145:   sta  WORK+1
                        	  1146: ;
                        	  1147: ;  Get the previous dynamic stack frame address and put it into BASE (in case of
                        	  1148: ;   recursive function calls)
                        	  1149: ;
00:B24A A000            	  1150:   ldy  #0
00:B24C B137            	  1151:   lda  (WORK),Y
00:B24E 853B            	  1152:   sta  BASE
00:B250 C8              	  1153:   iny
00:B251 B137            	  1154:   lda  (WORK),Y
00:B253 853C            	  1155:   sta  BASE+1
                        	  1156: ;
                        	  1157: ;  Stack, base and Pcode all changed, ready for next instruction
                        	  1158: ;
00:B255 4CDBAE          	  1159:   jmp  MAIN
                        	  1160: 
                        	  1161: ;
                        	  1162: ; Input a number into a variable
                        	  1163: ;
                        	  1164: EX_INP      =  *
00:B258 A980            	  1165:   lda #$80
00:B25A 853F            	  1166:   sta  RUNNING
00:B25C 208793          	  1167:   JSR  GET_LINE
00:B25F AD0002          	  1168:   lda  INBUF
00:B262 C903            	  1169:   cmp  #KEY_ABORT   ; check for aborting with Ctrl+C
00:B264 D003            	  1170:   bne  EX_INP_OK
00:B266 4CB3B4          	  1171:   jmp  ex_input_aborted
                        	  1172: 
                        	  1173: EX_INP_OK:
00:B269 A900            	  1174:   lda #<INBUF
00:B26B 858E            	  1175:   sta token_start
00:B26D A902            	  1176:   lda #>INBUF
00:B26F 858F            	  1177:   sta token_start+1
00:B271 6493            	  1178:   stz token_type
00:B273 20F2C8          	  1179:   jsr get_token
00:B276 C94E            	  1180:   cmp #TOKEN_NUMBER
00:B278 D016            	  1181:   bne BAD_INP
00:B27A A694            	  1182:   LDX  token_value
00:B27C A495            	  1183:   LDY  token_value+1
00:B27E A596            	  1184:   LDA  token_value+2
                        	  1185: INP3:
00:B280 8401            	  1186:   sty  REG+1
00:B282 8600            	  1187:   stx  REG
00:B284 8502            	  1188:   sta  REGB
00:B286 20B8AF          	  1189:   jsr  PSHTOP
00:B289 A20C            	  1190:   ldx  #12
00:B28B 863F            	  1191:   stx  RUNNING
00:B28D 4CDBAE          	  1192:   jmp  MAIN
                        	  1193: ;
                        	  1194: ;  bad number: set it to $800000
                        	  1195: ;
                        	  1196: BAD_INP:
00:B290 A980            	  1197:   lda #$80
00:B292 A200            	  1198:   ldx #0
00:B294 A000            	  1199:   ldy #0
00:B296 F0E8            	  1200:   beq INP3
                        	  1201: ;
                        	  1202: ; write a number to output
                        	  1203: ;
                        	  1204: EX_OUT:
00:B298 2060C8          	  1205:   jsr write_to_serial
00:B29B 8003            	  1206:   bra OUT_COMMON
                        	  1207: 
                        	  1208: EX_LCD_WRITE_NUM:
00:B29D 206BC8          	  1209:   jsr write_to_lcd
                        	  1210: 
                        	  1211: OUT_COMMON:
00:B2A0 2071AF          	  1212:   jsr  PULTOP
00:B2A3 205291          	  1213:   jsr  display_in_decimal
00:B2A6 2060C8          	  1214:   jsr  write_to_serial
00:B2A9 4CDBAE          	  1215:   jmp  MAIN
                        	  1216: ;
                        	  1217: ;
                        	  1218: ; Output 6 hex characters (3 bytes)
                        	  1219: ;
                        	  1220: EX_OUH:
00:B2AC 2060C8          	  1221:   jsr write_to_serial
00:B2AF 8003            	  1222:   bra EX_OUH_COMMON
                        	  1223: 
                        	  1224: EX_LCD_WRITE_HEX:
00:B2B1 206BC8          	  1225:   jsr write_to_lcd
                        	  1226: 
                        	  1227: EX_OUH_COMMON:
00:B2B4 2071AF          	  1228:   jsr  PULTOP
00:B2B7 A502            	  1229:   lda  REGB
00:B2B9 209D92          	  1230:   jsr  PRBYTE
00:B2BC A501            	  1231:   lda  REG+1
00:B2BE 209D92          	  1232:   jsr  PRBYTE
00:B2C1 A500            	  1233:   lda  REG
00:B2C3 209D92          	  1234:   jsr  PRBYTE
00:B2C6 2060C8          	  1235:   jsr  write_to_serial
00:B2C9 4CDBAE          	  1236:   jmp  MAIN
                        	  1237: ;
                        	  1238: ;  write a string to output
                        	  1239: ;
                        	  1240: EX_OUS      =  *
00:B2CC 2060C8          	  1241:   jsr write_to_serial
00:B2CF 8003            	  1242:   bra EX_OUS_COMMON
                        	  1243: 
                        	  1244: EX_LCD_WRITE_STR:
00:B2D1 206BC8          	  1245:   jsr write_to_lcd
                        	  1246: 
                        	  1247: EX_OUS_COMMON:
00:B2D4 A523            	  1248:   lda  PCODE
00:B2D6 18              	  1249:   clc
00:B2D7 6901            	  1250:   adc  #1
00:B2D9 8537            	  1251:   sta  WORK
00:B2DB A524            	  1252:   lda  PCODE+1
00:B2DD 6900            	  1253:   adc  #0
00:B2DF 8538            	  1254:   sta  WORK+1
00:B2E1 B123            	  1255:   lda  (PCODE),Y
00:B2E3 854B            	  1256:   sta  COUNT1     ; NO. OF CHARS
00:B2E5 18              	  1257:   clc
00:B2E6 6901            	  1258:   adc  #1
00:B2E8 6523            	  1259:   adc  PCODE
00:B2EA 8523            	  1260:   sta  PCODE
00:B2EC 9002            	  1261:   bcc  EX_OUS1
00:B2EE E624            	  1262:   inc  PCODE+1
                        	  1263: EX_OUS1:
00:B2F0 A537            	  1264:   lda  WORK
00:B2F2 A638            	  1265:   ldx  WORK+1
00:B2F4 A44B            	  1266:   ldy  COUNT1
00:B2F6 20B792          	  1267:   jsr  PT
00:B2F9 2060C8          	  1268:   jsr write_to_serial
00:B2FC 4CDBAE          	  1269:   jmp  MAIN
                        	  1270: 
                        	  1271: 
                        	  1272: 
                        	  1273: ;
                        	  1274: ;  Stack frame linkage data:
                        	  1275: ;
                        	  1276: ;    (from low to high address)
                        	  1277: ;
                        	  1278: ;    Return address <-- P-code to return to when function/procedure exits
                        	  1279: ;    Dynamic link   <-- The previous stack frame from the earlier function call
                        	  1280: ;    Static link    <-- The stack frame of the previous static function
                        	  1281: ;
                        	  1282: ;  Static and dynamic links will be the same except for recursive calls.
                        	  1283: ;
                        	  1284: ;  To unwind the stack we have to go back to the previous dynamic link (on a return)
                        	  1285: ;
                        	  1286: ;  However to find variables in previous lexical declarations we have to use the static link.
                        	  1287: ;
                        	  1288: ;
                        	  1289: ; Call absolute procedure - I don't think this is used in this version TBH
                        	  1290: ;
                        	  1291: ; Note: Y is zero when entering
                        	  1292: ;
                        	  1293: EX_ABSCLL   =  *
00:B2FF 8447            	  1294:   sty  CALL      ; zero out address to be called
00:B301 8448            	  1295:   sty  CALL+1    ; (offset therefore becomes absolute address)
00:B303 4C0EB3          	  1296:   jmp  EX_CLL_A
                        	  1297: ;
                        	  1298: ; Call relative procedure
                        	  1299: ;
                        	  1300: ; Note: Y is zero when entering
                        	  1301: ;
                        	  1302: EX_CLL      =  *
00:B306 A54D            	  1303:   lda  LASTP
00:B308 8547            	  1304:   sta  CALL
00:B30A A54E            	  1305:   lda  LASTP+1
00:B30C 8548            	  1306:   sta  CALL+1
                        	  1307: EX_CLL_A    =  *
00:B30E B123            	  1308:   lda  (PCODE),Y     ; level
00:B310 854B            	  1309:   sta  COUNT1
00:B312 C8              	  1310:   iny
00:B313 18              	  1311:   clc
00:B314 B123            	  1312:   lda  (PCODE),Y     ; relative address
00:B316 6547            	  1313:   adc  CALL          ; add to current P-code address
00:B318 8547            	  1314:   sta  CALL
00:B31A C8              	  1315:   iny
00:B31B B123            	  1316:   lda  (PCODE),Y
00:B31D 6548            	  1317:   adc  CALL+1
00:B31F 8548            	  1318:   sta  CALL+1
00:B321 A523            	  1319:   lda  PCODE         ; add 3 to P-code to bypass level / address
00:B323 18              	  1320:   clc                ; this will become our return address
00:B324 6903            	  1321:   adc  #3
00:B326 8523            	  1322:   sta  PCODE
00:B328 9002            	  1323:   bcc  EX_CLL4
00:B32A E624            	  1324:   inc  PCODE+1
                        	  1325: EX_CLL4     =  *
00:B32C A53C            	  1326:   lda  BASE+1
00:B32E A63B            	  1327:   ldx  BASE
                        	  1328: EX_CLL2     =  *
00:B330 853E            	  1329:   sta  DATA+1      ; this was BASE
00:B332 863D            	  1330:   stx  DATA
00:B334 A8              	  1331:   tay
00:B335 A54B            	  1332:   lda  COUNT1      ; this was the level
00:B337 F018            	  1333:   beq  EX_CLL3
00:B339 38              	  1334:   sec
00:B33A 8A              	  1335:   txa
00:B33B E902            	  1336:   sbc  #2          ; subtract 2 from BASE, store in WORK
00:B33D 8537            	  1337:   sta  WORK
00:B33F 98              	  1338:   tya
00:B340 E900            	  1339:   sbc  #0
00:B342 8538            	  1340:   sta  WORK+1
00:B344 A000            	  1341:   ldy  #0
00:B346 B137            	  1342:   lda  (WORK),Y
00:B348 C8              	  1343:   iny
00:B349 AA              	  1344:   tax
00:B34A B137            	  1345:   lda  (WORK),Y
00:B34C C64B            	  1346:   dec  COUNT1
00:B34E 4C30B3          	  1347:   jmp  EX_CLL2
                        	  1348: EX_CLL3     =  *
00:B351 A531            	  1349:   lda  T         ; our stack pointer
00:B353 8545            	  1350:   sta  TEMP      ; save it
00:B355 A532            	  1351:   lda  T+1
00:B357 8546            	  1352:   sta  TEMP+1
                        	  1353: ;
                        	  1354: ; this is as confusing as all-get-out but it looks like we
                        	  1355: ; are pushing onto the stack: DATA / BASE / PCODE (return address)
                        	  1356: ;  (which is why we saved T into TEMP so it didn't change during the pushes)
                        	  1357: ;
                        	  1358: 
00:B359 A53D            	  1359:   lda  DATA      ; put DATA into REG
00:B35B 8501            	  1360:   sta  REG+1
00:B35D A53E            	  1361:   lda  DATA+1
00:B35F 8502            	  1362:   sta  REGB
00:B361 A53C            	  1363:   lda  BASE+1
00:B363 8500            	  1364:   sta  REG
00:B365 20B8AF          	  1365:   jsr  PSHTOP      ; push REG (DATA + BASE[1])
00:B368 A53B            	  1366:   lda  BASE
00:B36A 8502            	  1367:   sta  REGB
00:B36C A545            	  1368:   lda  TEMP        ; old stack pointer
00:B36E 853B            	  1369:   sta  BASE        ; becomes BASE
00:B370 A546            	  1370:   lda  TEMP+1      ; ditto for other byte
00:B372 853C            	  1371:   sta  BASE+1
00:B374 A523            	  1372:   lda  PCODE       ; get ready to push current P-Code
00:B376 8500            	  1373:   sta  REG
00:B378 A524            	  1374:   lda  PCODE+1
00:B37A 8501            	  1375:   sta  REG+1
00:B37C 20B8AF          	  1376:   jsr  PSHTOP     ; push REG (BASE[0] + PCODE)
00:B37F A547            	  1377:   lda  CALL       ; now get the address of the place we want to call
00:B381 8523            	  1378:   sta  PCODE      ; and put it into PCODE
00:B383 A548            	  1379:   lda  CALL+1
00:B385 8524            	  1380:   sta  PCODE+1
00:B387 18              	  1381:   clc             ; add 6 to the stack pointer because we later emit the code to INT 6 (leave room for base stuff)
00:B388 A531            	  1382:   lda  T
00:B38A 6906            	  1383:   adc  #6
00:B38C 8531            	  1384:   sta  T
00:B38E 9002            	  1385:   bcc  EX_CLL5
00:B390 E632            	  1386:   inc  T+1
                        	  1387: EX_CLL5     =  *
00:B392 4CDBAE          	  1388:   jmp  MAIN        ; we are done, MAIN will now go to the called subroutine
                        	  1389: ;
                        	  1390: ;  Here for calling machine code from Pascal
                        	  1391: ;
                        	  1392: EX_CLA:
00:B395 2071AF          	  1393:   jsr  PULTOP      ; pull the address to be called from the stack
00:B398 A513            	  1394:   lda  call_p      ; status register
00:B39A 48              	  1395:   pha
00:B39B A510            	  1396:   lda  call_a      ; A register
00:B39D A611            	  1397:   ldx  call_x      ; X register
00:B39F A412            	  1398:   ldy  call_y      ; Y register
00:B3A1 28              	  1399:   plp              ; get status register back
00:B3A2 20B2B3          	  1400:   jsr  EX_CLL_JMP  ; call the subroutine
00:B3A5 08              	  1401:   php              ; save the status register
00:B3A6 8510            	  1402:   sta  call_a      ; store the A/X/Y register
00:B3A8 8611            	  1403:   stx  call_x
00:B3AA 8412            	  1404:   sty  call_y
00:B3AC 68              	  1405:   pla              ; get status register back
00:B3AD 8513            	  1406:   sta  call_p      ; save it
00:B3AF 4CDBAE          	  1407:   jmp  MAIN        ; done!
                        	  1408: 
00:B3B2 6C0000          	  1409: EX_CLL_JMP  jmp  (REG)
                        	  1410: ;
                        	  1411: ;
                        	  1412: ; increment stack pointer (that is, subtract the literal from it, as it grows downwards)
                        	  1413: ;
                        	  1414: EX_INT:
00:B3B5 20D4AF          	  1415:   jsr  GETLIT
00:B3B8 38              	  1416:   sec
00:B3B9 A531            	  1417:   lda  T
00:B3BB E500            	  1418:   sbc  REG
00:B3BD 8531            	  1419:   sta  T
00:B3BF A532            	  1420:   lda  T+1
00:B3C1 E501            	  1421:   sbc  REG+1
00:B3C3 8532            	  1422:   sta  T+1
00:B3C5 C544            	  1423:   cmp  END_PCD+1
00:B3C7 9003            	  1424:   bcc  INT_ERR
00:B3C9 4CDBAE          	  1425:   jmp  MAIN
                        	  1426: ;
                        	  1427: INT_ERR  =  *
00:B3CC A9D3            	  1428:   lda  #<INT_ERRM    ; stack full
00:B3CE A2B3            	  1429:   ldx  #>INT_ERRM
00:B3D0 4C1DAF          	  1430:   jmp  NOTIM1
                        	  1431: ;
00:B3D3 537461636B206675	  1432: INT_ERRM asciiz "Stack full\n"    ; stack full
00:B3DB 6C6C0A
00:B3DE 00
                        	  1433: ;
                        	  1434: 
                        	  1435: ;
                        	  1436: ;  Change the runtime stack to the address given (assuming stack is empty)
                        	  1437: ;   Done by the {%S nnnn} compiler directive.
                        	  1438: ;
                        	  1439: EX_NEW_STACK:
00:B3DF 20D4AF          	  1440:   jsr GETLIT
00:B3E2 A500            	  1441:   lda REG
00:B3E4 8531            	  1442:   sta T
00:B3E6 853B            	  1443:   sta BASE
00:B3E8 A501            	  1444:   lda REG+1
00:B3EA 8532            	  1445:   sta T+1
00:B3EC 853C            	  1446:   sta BASE+1
00:B3EE 4CDBAE          	  1447:   jmp MAIN
                        	  1448: 
                        	  1449: ;
                        	  1450: ;  Jump to the address following the P-code
                        	  1451: ;
                        	  1452: EX_JMP:
00:B3F1 20D4AF          	  1453:   jsr  GETLIT   ; get the address
00:B3F4 18              	  1454:   clc
00:B3F5 A500            	  1455:   lda  REG
00:B3F7 654D            	  1456:   adc  LASTP
00:B3F9 8523            	  1457:   sta  PCODE
00:B3FB A501            	  1458:   lda  REG+1
00:B3FD 654E            	  1459:   adc  LASTP+1
00:B3FF 8524            	  1460:   sta  PCODE+1
00:B401 4CDBAE          	  1461:   jmp  MAIN
                        	  1462: ;
                        	  1463: ;  Jump if the top of the stack is zero
                        	  1464: ;
                        	  1465: EX_JMZ:
00:B404 2071AF          	  1466:   jsr  PULTOP   ; puts REG into A
00:B407 0501            	  1467:   ora  REG+1
00:B409 0502            	  1468:   ora  REGB
00:B40B D002            	  1469:   bne  EX_NOJUMP
00:B40D F0E2            	  1470:   beq  EX_JMP
                        	  1471: ;
                        	  1472: ;  Don't jump, just move past the address (TODO: just add 2?)
                        	  1473: ;
                        	  1474: EX_NOJUMP:
00:B40F 20D4AF          	  1475:   jsr  GETLIT
00:B412 4CDBAE          	  1476:   jmp  MAIN
                        	  1477: ;
                        	  1478: ;  Jump if the top of the stack is non-zero
                        	  1479: ;
                        	  1480: EX_JM1:
00:B415 2071AF          	  1481:   jsr  PULTOP    ; puts REG into A
00:B418 0501            	  1482:   ora  REG+1
00:B41A 0502            	  1483:   ora  REGB
00:B41C D0D3            	  1484:   bne  EX_JMP
00:B41E F0EF            	  1485:   beq  EX_NOJUMP
                        	  1486: ;
                        	  1487: ;
                        	  1488: EX_INPC:
00:B420 2076C8          	  1489:   jsr GETIN
00:B423 C903            	  1490:   cmp  #KEY_ABORT   ; check for aborting with Ctrl+C
00:B425 D003            	  1491:   bne  EX_INPC_OK
00:B427 4CB3B4          	  1492:   jmp  ex_input_aborted
                        	  1493: 
                        	  1494: EX_INPC_OK:
00:B42A 209CAE          	  1495:   jsr CHK_KBD
00:B42D B0F1            	  1496:   bcs EX_INPC
00:B42F 8500            	  1497:   sta REG
00:B431 A900            	  1498:   lda #0
00:B433 8501            	  1499:   sta REG+1
00:B435 8502            	  1500:   sta REGB
00:B437 4CD8AE          	  1501:   jmp  MAINP
                        	  1502: ;
                        	  1503: EX_OUTC:
00:B43A 2060C8          	  1504:   jsr write_to_serial
00:B43D 8003            	  1505:   bra EX_OUTC_COMMON
                        	  1506: 
                        	  1507: EX_LCD_WRITE_CHR:
00:B43F 206BC8          	  1508:   jsr write_to_lcd
                        	  1509: 
                        	  1510: EX_OUTC_COMMON:
00:B442 2071AF          	  1511:   jsr  PULTOP
00:B445 A500            	  1512:   lda  REG
00:B447 20AF93          	  1513:   jsr  COUT
00:B44A 2060C8          	  1514:   jsr write_to_serial
00:B44D 4CDBAE          	  1515:   jmp  MAIN
                        	  1516:   ;
                        	  1517: 
                        	  1518: EX_LCDHOME:
00:B450 205EB8          	  1519:   jsr lcd_home
00:B453 4CDBAE          	  1520:   JMP MAIN
                        	  1521: 
                        	  1522: 
                        	  1523: EX_LCDCLEAR:
00:B456 204EB8          	  1524:   jsr lcd_clear_display
00:B459 4CDBAE          	  1525:   JMP MAIN
                        	  1526: 
                        	  1527: EX_INS      =  *
00:B45C B123            	  1528:   lda  (PCODE),Y   ; wanted length
00:B45E 8545            	  1529:   sta  TEMP
00:B460 E623            	  1530:   inc  PCODE
00:B462 D002            	  1531:   bne  EX_INS3
00:B464 E624            	  1532:   inc  PCODE+1
                        	  1533: EX_INS3     =  *
00:B466 208793          	  1534:   jsr  GET_LINE
00:B469 AD0002          	  1535:   lda  INBUF
00:B46C C903            	  1536:   cmp  #KEY_ABORT     ; check for them aborting the run on input
00:B46E F043            	  1537:   beq  ex_input_aborted
00:B470 209CAE          	  1538:   jsr  CHK_KBD
00:B473 B0F1            	  1539:   bcs  EX_INS3      ; we turned on/off tracing etc, ignore this line
00:B475 98              	  1540:   tya               ; length of line
00:B476 18              	  1541:   clc
00:B477 6901            	  1542:   adc  #1        ; why?
00:B479 C545            	  1543:   cmp  TEMP
00:B47B 9002            	  1544:   bcc  EX_INS1
00:B47D A545            	  1545:   lda  TEMP      ; use max allowed length rather than received length
                        	  1546: EX_INS1     =  *
00:B47F 8546            	  1547:   sta  TEMP+1    ; this is the length we are copying
00:B481 202AAF          	  1548:   jsr  GETADR    ; get address to put the line
00:B484 A003            	  1549:   ldy  #3        ; why?
00:B486 A200            	  1550:   ldx  #0
                        	  1551: ;
                        	  1552: ;  copying loop - arrays are stored downwards, so we subtract from DATA each time
                        	  1553: ;
                        	  1554: EX_INS2     =  *
00:B488 C63D            	  1555:   dec  DATA
00:B48A A53D            	  1556:   lda  DATA
00:B48C C9FF            	  1557:   cmp  #$FF
00:B48E D002            	  1558:   bne  EX_INS4
00:B490 C63E            	  1559:   dec  DATA+1
                        	  1560: EX_INS4     =  *
00:B492 BD0002          	  1561:   lda  INBUF,X
00:B495 913D            	  1562:   sta  (DATA),Y
00:B497 E8              	  1563:   inx
00:B498 C646            	  1564:   dec  TEMP+1      ; count of bytes to copy
00:B49A D0EC            	  1565:   bne  EX_INS2
00:B49C 4CDBAE          	  1566:   jmp  MAIN        ; stop now
                        	  1567:   ;
                        	  1568: 
00:B49F 0A45786563757469	  1569: execution_aborted_message asciiz "\nExecution aborted\n"
00:B4A7 6F6E2061626F7274
00:B4AF 65640A
00:B4B2 00
                        	  1570: 
                        	  1571: ex_input_aborted:
00:B4B3 A99F            	  1572:   lda #<execution_aborted_message
00:B4B5 A2B4            	  1573:   ldx #>execution_aborted_message
00:B4B7 4C1DAF          	  1574:   jmp NOTIM1
                        	  1575: ;
                        	  1576: ;
                        	  1577: EX_ADRNC    =  *
00:B4BA 202AAF          	  1578:   jsr  GETADR
                        	  1579: EX_ADRNC2   =  *
00:B4BD A53D            	  1580:   lda  DATA
00:B4BF 18              	  1581:   clc
00:B4C0 6902            	  1582:   adc  #2
00:B4C2 853D            	  1583:   sta  DATA
00:B4C4 9007            	  1584:   bcc  EX_ADRN2
00:B4C6 E63E            	  1585:   inc  DATA+1
00:B4C8 B003            	  1586:   bcs  EX_ADRN2
                        	  1587: EX_ADRNN    =  *
00:B4CA 202AAF          	  1588:   jsr  GETADR
                        	  1589: EX_ADRN2    =  *
00:B4CD A53D            	  1590:   lda  DATA
00:B4CF 8500            	  1591:   sta  REG
00:B4D1 A53E            	  1592:   lda  DATA+1
00:B4D3 8501            	  1593:   sta  REG+1
00:B4D5 4CD8AE          	  1594:   jmp  MAINP
                        	  1595: ;
                        	  1596: EX_ADRAN    =  *
00:B4D8 2089B1          	  1597:   jsr  GETIDX
00:B4DB 4CCDB4          	  1598:   jmp  EX_ADRN2
                        	  1599: ;
                        	  1600: EX_ADRAC    =  *
00:B4DE 2080B1          	  1601:    jsr  GETIDC
00:B4E1 4CBDB4          	  1602:    jmp  EX_ADRNC2
                        	  1603: ;
                        	  1604: ;
                        	  1605: ;
                        	  1606: 
                        	  1607: 
                        	  1608: ;
                        	  1609: ;  DIGITALREAD (pin) pin:0 to 15; pushes 0 or 1
                        	  1610: ;
                        	  1611: EX_DIGITALREAD = *
00:B4E4 2071AF          	  1612:   jsr PULTOP  ; which pin
00:B4E7 2043C8          	  1613:   jsr digitalread
00:B4EA D003            	  1614:   bne EX_DIGITALREAD_ONE
00:B4EC 4C89B0          	  1615:   jmp FALSE
                        	  1616: EX_DIGITALREAD_ONE:
00:B4EF 4C7CB0          	  1617:   jmp TRUE    ; done
                        	  1618: 
                        	  1619: ;
                        	  1620: ;  LCDPOS (line, column)
                        	  1621: ;
                        	  1622: 
                        	  1623: EX_LCDPOS = *
00:B4F2 2071AF          	  1624:   jsr PULTOP   ; x
00:B4F5 290F            	  1625:   and #$0F     ; max 15
00:B4F7 858C            	  1626:   sta hardware_work  ; save it
00:B4F9 2071AF          	  1627:   jsr PULTOP   ; y
00:B4FC 2901            	  1628:   and #1       ; can be 0 or 1
00:B4FE D002            	  1629:   bne EX_LCDPOS_1
00:B500 A940            	  1630:   lda #$40
                        	  1631: EX_LCDPOS_1:
00:B502 058C            	  1632:   ora hardware_work  ; or in the column
00:B504 0980            	  1633:   ora #$80     ; command to set the address
00:B506 20FAB7          	  1634:   jsr lcd_instruction
00:B509 4CDBAE          	  1635:   jmp MAIN
                        	  1636: 
                        	  1637: ;
                        	  1638: ;  RANDOM
                        	  1639: ;
                        	  1640: EX_RANDOM:
00:B50C 20DA8F          	  1641:   jsr gen_random
00:B50F A509            	  1642:   lda random
00:B511 8500            	  1643:   sta REG
00:B513 A50A            	  1644:   lda random+1
00:B515 8501            	  1645:   sta REG+1
00:B517 A50B            	  1646:   lda random+2
00:B519 8502            	  1647:   sta REGB
00:B51B 4CD8AE          	  1648:   jmp MAINP
                        	  1649: 
                        	  1650: 
                        	  1651: ;
                        	  1652: ;  LATENCY
                        	  1653: ;
                        	  1654: EX_LATENCY:
00:B51E A50D            	  1655:   lda typing_latency
00:B520 8500            	  1656:   sta REG
00:B522 A50E            	  1657:   lda typing_latency+1
00:B524 8501            	  1658:   sta REG+1
00:B526 A50F            	  1659:   lda typing_latency+2
00:B528 8502            	  1660:   sta REGB
00:B52A 4CD8AE          	  1661:   jmp MAINP
                        	  1662: 
                        	  1663: ; PULTOP puts stuff here thus:
                        	  1664: ;
                        	  1665: ;        LDA  REG
                        	  1666: ;        LDX  REG+1
                        	  1667: ;        LDY  REGB
                        	  1668: 
                        	  1669: EX_DELAY = *
00:B52D 2071AF          	  1670:   JSR  PULTOP  ; get the time interval in ms
                        	  1671:   ; (Y = high-order byte, X = lo-order byte)
00:B530 A600            	  1672:   ldx REG
00:B532 A501            	  1673:   lda REG+1
00:B534 297F            	  1674:   and #$7F
00:B536 A8              	  1675:   tay
00:B537 20D590          	  1676:   jsr delay
00:B53A 4CDBAE          	  1677:   jmp MAIN
                        	  1678: 
                        	  1679: ;
                        	  1680: ;  RANDOMSEED
                        	  1681: ;
                        	  1682: EX_RANDOMSEED = *
00:B53D 2071AF          	  1683:   JSR  PULTOP  ; get the seed
00:B540 850A            	  1684:   sta random+1
00:B542 860B            	  1685:   stx random+2
00:B544 840C            	  1686:   sty random+3
00:B546 A9FF            	  1687:   lda #$FF     ; ensure seed has some 1 bits
00:B548 8509            	  1688:   sta random
00:B54A 4CDBAE          	  1689:   jmp MAIN
                        	  1690: 
                        	  1691: ;
                        	  1692: ;  PINMODE (pin, mode) pin:0 to 15; mode: 0=read, 1=write
                        	  1693: ;
                        	  1694: EX_PINMODE = *
00:B54D 2071AF          	  1695:   jsr PULTOP  ; the mode
00:B550 AA              	  1696:   tax         ; input or output?
00:B551 DA              	  1697:   phx         ; save the mode
00:B552 2071AF          	  1698:   jsr PULTOP  ; which pin
00:B555 FA              	  1699:   plx         ; get mode back
00:B556 20E5C7          	  1700:   jsr pinmode ; pin in A, mode in X
00:B559 4CDBAE          	  1701:   jmp MAIN    ; done
                        	  1702: 
                        	  1703: ;
                        	  1704: ;  DIGITALWRITE (pin, value) pin:0 to 15; value: 0 or 1
                        	  1705: ;
                        	  1706: EX_DIGITALWRITE = *
00:B55C 2071AF          	  1707:   jsr PULTOP  ; the value
00:B55F AA              	  1708:   tax         ;
00:B560 DA              	  1709:   phx         ; save the value
00:B561 2071AF          	  1710:   jsr PULTOP  ; which pin
00:B564 FA              	  1711:   plx         ; get mode back
00:B565 2014C8          	  1712:   jsr digitalwrite ; pin in A, value in X
00:B568 4CDBAE          	  1713:   jmp MAIN    ; done
                        	  1714: 
                        	  1715: EX_LIB_CALL:
00:B56B 20D4AF          	  1716:   JSR  GETLIT
00:B56E 6C0000          	  1717:   jmp  (REG)
                        	  1718: 
                        	  1719: ;
                        	  1720: ;  Assert (expression)
                        	  1721: ;
                        	  1722: 
                        	  1723: EX_ASSERT:
00:B571 2071AF          	  1724:   jsr PULTOP  ; the value
00:B574 A500            	  1725:   lda REG
00:B576 0501            	  1726:   ora REG+1
00:B578 0502            	  1727:   ora REGB
00:B57A D00A            	  1728:   bne EX_ASSERT_OK
00:B57C A91E            	  1729:   lda #<assertion_failed_message  ; "Assertion failed"
00:B57E A297            	  1730:   ldx #>assertion_failed_message
00:B580 202682          	  1731:   jsr print
00:B583 4C52AE          	  1732:   jmp RUNERR
                        	  1733: 
                        	  1734: EX_ASSERT_OK:
00:B586 4CDBAE          	  1735:   jmp MAIN
                        	  1736: 

Source: "gpascal.asm"
                        	   180:   .include "interrupts.inc"

Source: "interrupts.inc"
                        	     1: 
00:B589 0A42524B20657865	     2: break_message     asciiz "\nBRK executed at address $"
00:B591 6375746564206174
00:B599 2061646472657373
00:B5A1 2024
00:B5A3 00
00:B5A4 2C2041203D2024  	     3: a_equals_message  asciiz ", A = $"
00:B5AB 00
00:B5AC 2C2058203D2024  	     4: x_equals_message  asciiz ", X = $"
00:B5B3 00
00:B5B4 2C2059203D2024  	     5: y_equals_message  asciiz ", Y = $"
00:B5BB 00
00:B5BC 2C2050203D2024  	     6: p_equals_message  asciiz ", P = $"
00:B5C3 00
00:B5C4 2C2053203D2024  	     7: s_equals_message  asciiz ", S = $"
00:B5CB 00
00:B5CC 2C206964203D2024	     8: id_equals_message asciiz ", id = $"
00:B5D4 00
                        	     9: 
                        	    10: ;--------------------------------------------------
                        	    11: ;  IRQ - here on BRK interrupt
                        	    12: ;--------------------------------------------------
                        	    13: brk_executed:
00:B5D5 8412            	    14:   sty call_y    ; save Y - we didn't touch that
00:B5D7 8614            	    15:   stx call_s    ; X still has the stack pointer in it
00:B5D9 FA              	    16:   plx           ; get X back
00:B5DA 8611            	    17:   stx call_x
00:B5DC 68              	    18:   pla           ; get A back
00:B5DD 8510            	    19:   sta call_a    ; save A
00:B5DF 68              	    20:   pla           ; get the processor flags from the stack
00:B5E0 8513            	    21:   sta call_p
00:B5E2 68              	    22:   pla           ; low-order address of BRK
00:B5E3 8515            	    23:   sta brk_address
00:B5E5 68              	    24:   pla           ; high order address of BRK
00:B5E6 8516            	    25:   sta brk_address+1
00:B5E8 58              	    26:   cli           ; allow interrupts now so we can print
                        	    27: 
                        	    28: ;
                        	    29: ;  display BRK info for the user
                        	    30: ;
                        	    31:   ;
                        	    32:   ;  subtract 2 from brk_address to get where it actually was
                        	    33:   ;
00:B5E9 38              	    34:   sec
00:B5EA A515            	    35:   lda brk_address
00:B5EC E902            	    36:   sbc #2
00:B5EE 8515            	    37:   sta brk_address
00:B5F0 A516            	    38:   lda brk_address+1
00:B5F2 E900            	    39:   sbc #0
00:B5F4 8516            	    40:   sta brk_address+1
00:B5F6 A989            	    41:   lda #<break_message
00:B5F8 A2B5            	    42:   ldx #>break_message
00:B5FA 202682          	    43:   jsr print
00:B5FD A516            	    44:   lda brk_address+1
00:B5FF 209D92          	    45:   jsr PRBYTE
00:B602 A515            	    46:   lda brk_address
00:B604 209D92          	    47:   jsr PRBYTE
                        	    48: ;
                        	    49: ;  show A, X, Y, P, S
                        	    50: ;
00:B607 A9A4            	    51:   lda #<a_equals_message
00:B609 A2B5            	    52:   ldx #>a_equals_message
00:B60B 202682          	    53:   jsr print
00:B60E A510            	    54:   lda call_a
00:B610 209D92          	    55:   jsr PRBYTE
00:B613 A9AC            	    56:   lda #<x_equals_message
00:B615 A2B5            	    57:   ldx #>x_equals_message
00:B617 202682          	    58:   jsr print
00:B61A A511            	    59:   lda call_x
00:B61C 209D92          	    60:   jsr PRBYTE
00:B61F A9B4            	    61:   lda #<y_equals_message
00:B621 A2B5            	    62:   ldx #>y_equals_message
00:B623 202682          	    63:   jsr print
00:B626 A512            	    64:   lda call_y
00:B628 209D92          	    65:   jsr PRBYTE
00:B62B A9BC            	    66:   lda #<p_equals_message
00:B62D A2B5            	    67:   ldx #>p_equals_message
00:B62F 202682          	    68:   jsr print
00:B632 A513            	    69:   lda call_p
00:B634 209D92          	    70:   jsr PRBYTE
00:B637 A9C4            	    71:   lda #<s_equals_message
00:B639 A2B5            	    72:   ldx #>s_equals_message
00:B63B 202682          	    73:   jsr print
00:B63E A514            	    74:   lda call_s
00:B640 209D92          	    75:   jsr PRBYTE
00:B643 A9CC            	    76:   lda #<id_equals_message
00:B645 A2B5            	    77:   ldx #>id_equals_message
00:B647 202682          	    78:   jsr print
                        	    79: ;
                        	    80: ;  advance one byte to get the break ID (byte after the BRK)
                        	    81: ;
00:B64A E615            	    82:   inc brk_address
00:B64C D002            	    83:   bne brk_executed1
00:B64E E616            	    84:   inc brk_address+1
                        	    85: brk_executed1:
00:B650 A000            	    86:   ldy #0
00:B652 B115            	    87:   lda (brk_address),Y
00:B654 209D92          	    88:   jsr PRBYTE
                        	    89: ;
                        	    90: ;  put brk_address back to where we should resume from
                        	    91: ;
00:B657 E615            	    92:   inc brk_address
00:B659 D002            	    93:   bne brk_executed2
00:B65B E616            	    94:   inc brk_address+1
                        	    95: brk_executed2:
                        	    96: 
00:B65D 202892          	    97:   jsr CROUT
                        	    98: ;
                        	    99: ;  display stack
                        	   100: ;
00:B660 A981            	   101:   lda #<stack_message
00:B662 A2B6            	   102:   ldx #>stack_message
00:B664 202682          	   103:   jsr print
00:B667 A514            	   104:   lda call_s
00:B669 18              	   105:   clc
00:B66A 6906            	   106:   adc #6  ; the interrupt pushed 3 we pushed 2, plus the stack points to the first UNUSED spot
00:B66C AA              	   107:   tax
                        	   108: brk_executed3:
00:B66D BD0001          	   109:   lda $100,x
00:B670 DA              	   110:   phx
00:B671 209D92          	   111:   jsr PRBYTE
00:B674 20B392          	   112:   jsr PUTSP
00:B677 FA              	   113:   plx
00:B678 E8              	   114:   inx
00:B679 D0F2            	   115:   bne brk_executed3
                        	   116: 
                        	   117: ;
                        	   118: ;  we are done now
                        	   119: ;
00:B67B 202892          	   120:   jsr CROUT
00:B67E 4CCC82          	   121:   jmp main_prompt
                        	   122: 
00:B681 537461636B3A20  	   123: stack_message asciiz "Stack: "
00:B688 00
                        	   124: 
00:B689 4CD5B5          	   125: brk_executedJ jmp brk_executed
                        	   126: 
                        	   127: ;--------------------------------------------------
                        	   128: ;  IRQ - here on maskable interrupt
                        	   129: ;--------------------------------------------------
                        	   130: 
                        	   131: irq:
00:B68C 48              	   132:   pha       ; save A and X
00:B68D DA              	   133:   phx
00:B68E BA              	   134:   tsx       ; get stack pointer
00:B68F E0FB            	   135:   cpx #$FB  ; should be lesss than $FB (since the interrupt pushed 3 and we pushed 2)
00:B691 9006            	   136:   bcc irq1
00:B693 A21B            	   137:   ldx #27   ; ERROR: stack full
00:B695 58              	   138:   cli       ; allow interrupts or error won't print
00:B696 4C6497          	   139:   jmp ERROR
                        	   140: 
                        	   141: irq1:
00:B699 BD0301          	   142:   lda $103,X    ; this will be the processor flags on the stack (3 up from where we are now)
00:B69C 2910            	   143:   and #$10      ; check BRK flag
00:B69E D0E9            	   144:   bne brk_executedJ
                        	   145: ;
                        	   146: ;  here for a hardware IRQ
                        	   147: ;
00:B6A0 ADFD7F          	   148:   lda VIA_IFR
00:B6A3 2940            	   149:   and #VIA_FLAG_TIMER1     ; Time out of T1
00:B6A5 D03B            	   150:   bne timer1_interrupt
                        	   151: 
00:B6A7 ADFD7F          	   152:   lda VIA_IFR
00:B6AA 2908            	   153:   and #VIA_FLAG_CB2        ; CB2 active edge
00:B6AC D003            	   154:   bne cb2_interrupt
                        	   155: 
00:B6AE 4C11B7          	   156:   jmp irq_done
                        	   157: 
                        	   158: ;
                        	   159: ;  here for incoming start bit
                        	   160: ;
                        	   161: cb2_interrupt:
                        	   162: 
00:B6B1 8DFE7F          	   163:   sta VIA_IER           ; turn off that interrupt
00:B6B4 8DFD7F          	   164:   sta VIA_IFR           ; indicate we noticed it
                        	   165: 
00:B6B7 DA              	   166:   phx
00:B6B8 5A              	   167:   phy
                        	   168: 
00:B6B9 A208            	   169:   ldx #8              ; count of bits
00:B6BB A020            	   170:   ldy #SERIAL_DELAY1  ; delay interval for first bit (allow for code above) TODO - probably needs to be less now
                        	   171: serial_in_loop:
                        	   172: ;
                        	   173: ; wait for bit time to be up
                        	   174: ;
00:B6BD 88              	   175:   dey
00:B6BE D0FD            	   176:   bne serial_in_loop
                        	   177: 
                        	   178:   .if SERIAL_DEBUGGING
                        	   179:     lda #SERIAL_DEBUG1_MASK     ; toggle debug flag (2 cycles)
                        	   180:     tsb VIA_PORTA               ; (6 cycles)
                        	   181:     trb VIA_PORTA               ; (6 cycles)
                        	   182:   .else
00:B6C0 EA              	   183:     NOP    ; take the same time so the timing isn't thrown out
00:B6C1 EA              	   184:     NOP    ; 2 cycles each
00:B6C2 EA              	   185:     NOP
00:B6C3 EA              	   186:     NOP
00:B6C4 EA              	   187:     NOP
00:B6C5 EA              	   188:     NOP
00:B6C6 EA              	   189:     NOP    ; total of 14 cycles
                        	   190:   .endif  ; SERIAL_DEBUGGING
                        	   191: 
00:B6C7 ADF17F          	   192:   lda VIA_PORTA
00:B6CA 6A              	   193:   ror A                 ; put incoming bit into carry
00:B6CB 668A            	   194:   ror serial_in_byte    ; shift one bit in
00:B6CD A023            	   195:   ldy #SERIAL_DELAY2    ; delay interval for remaining bits
00:B6CF CA              	   196:   dex
00:B6D0 D0EB            	   197:   bne serial_in_loop
                        	   198: 
00:B6D2 7A              	   199:   ply
00:B6D3 FA              	   200:   plx
                        	   201: ;
                        	   202: ;  re-enable interrupts on the falling edge
                        	   203: ;
00:B6D4 A988            	   204:   lda #VIA_FLAG_ENABLE | VIA_FLAG_CB2
00:B6D6 8DFE7F          	   205:   sta VIA_IER
00:B6D9 8DFD7F          	   206:   sta VIA_IFR   ; indicate we know about previous falling edges
                        	   207: 
                        	   208: ;
                        	   209: ;  move to place that we know it will be noticed
                        	   210: ;
00:B6DC A58A            	   211:   lda serial_in_byte
00:B6DE 858B            	   212:   sta serial_in_byte_received
                        	   213: 
00:B6E0 802F            	   214:   bra irq_done
                        	   215: 
                        	   216: ;
                        	   217: ;  here for time to send another outgoing bit
                        	   218: ;
                        	   219: timer1_interrupt :
                        	   220: 
00:B6E2 8DFD7F          	   221:   sta VIA_IFR           ; indicate we noticed it
00:B6E5 A589            	   222:   lda serial_out_bit    ; are we in fact sending a byte?
00:B6E7 F028            	   223:   beq irq_done          ; no, just exit
                        	   224: 
                        	   225:   .if SERIAL_DEBUGGING
                        	   226: 
                        	   227:   lda #SERIAL_DEBUG2_MASK     ; toggle debug flag (2 cycles)
                        	   228:   tsb VIA_PORTA               ; wash on   (6 cycles)
                        	   229:   trb VIA_PORTA               ; wash off  (6 cycles)
                        	   230:                               ; now, sand the floor
                        	   231:  .else
00:B6E9 EA              	   232:      NOP    ; take the same time so the timing isn't thrown out
00:B6EA EA              	   233:      NOP    ; 2 cycles each
00:B6EB EA              	   234:      NOP
00:B6EC EA              	   235:      NOP
00:B6ED EA              	   236:      NOP
00:B6EE EA              	   237:      NOP
00:B6EF EA              	   238:      NOP    ; total of 14 cycles
                        	   239:   .endif  ; SERIAL_DEBUGGING
                        	   240: 
00:B6F0 6688            	   241:   ror serial_out_byte+1  ; we don't care about the high-order bit
00:B6F2 6687            	   242:   ror serial_out_byte    ; get the low-order bit into Carry
00:B6F4 9007            	   243:   bcc write_zero
00:B6F6 A902            	   244:   lda #SERIAL_OUT_MASK   ; (send a 1 bit)
00:B6F8 0DF17F          	   245:   ora VIA_PORTA
00:B6FB 8005            	   246:   bra serial_send_count_bits
                        	   247: 
                        	   248: write_zero:
00:B6FD A9FD            	   249:   lda #~SERIAL_OUT_MASK  ; (send a 0 bit)
00:B6FF 2DF17F          	   250:   and VIA_PORTA
                        	   251: 
                        	   252: serial_send_count_bits:
00:B702 8DF17F          	   253:   sta VIA_PORTA          ; output this bit
00:B705 C689            	   254:   dec serial_out_bit     ; remember bit count for later
00:B707 D008            	   255:   bne irq_done
                        	   256: 
                        	   257: ; here when all bits have been sent
                        	   258: ; disable the timer as we don't need it any more
                        	   259: ; and this will be a flag that we can send another byte
                        	   260: 
00:B709 A940            	   261:   lda #VIA_FLAG_DISABLE | VIA_FLAG_TIMER1  ; cancel interrupt on T1 timeout
00:B70B 8DFE7F          	   262:   sta VIA_IER
00:B70E ADF47F          	   263:   lda VIA_T1C_L     ; clear interrupt flag
                        	   264: 
                        	   265: irq_done:
00:B711 FA              	   266:   plx   ; restore X
00:B712 68              	   267:   pla   ; restore A
00:B713 40              	   268:   rti
                        	   269: 

Source: "gpascal.asm"
                        	   181:   .include "lcd.inc"

Source: "lcd.inc"
                        	     1:   .if !EMULATOR
                        	     2:   .if LCD_SUPPORT
                        	     3: 
                        	     4: ;
                        	     5: ;  LCD stuff
                        	     6: ;
                        	     7: 
                        	     8: lcd_initialise:
                        	     9: ;
                        	    10: ;  LCD initialise
                        	    11: ;
                        	    12: 
00:B714 ADF37F          	    13:   lda VIA_DDRA
00:B717 09E0            	    14:   ora #(LCD_RW|LCD_RS|LCD_E)    ; set appropriate pins on Port A to output
00:B719 8DF37F          	    15:   sta VIA_DDRA
                        	    16: 
                        	    17:   ; see HD44780U documentation: "Initializing by Instruction" (page 46)
00:B71C 2095B7          	    18:   jsr lcd_prepare_to_write_instruction
00:B71F A930            	    19:   lda #$30
00:B721 20EEB7          	    20:   jsr lcd_write_instruction_nibble
                        	    21:   ; wait > 4.1 ms
00:B724 A214            	    22:   ldx #20
00:B726 A000            	    23:   ldy #0
00:B728 20D590          	    24:   jsr delay      ; 20 ms delay (in case of faster board clock speeds)
00:B72B 20EEB7          	    25:   jsr lcd_write_instruction_nibble
00:B72E 20CB90          	    26:   jsr delay_1ms  ; do it 4 times in case of faster board clock speeds
00:B731 20CB90          	    27:   jsr delay_1ms
00:B734 20CB90          	    28:   jsr delay_1ms
00:B737 20CB90          	    29:   jsr delay_1ms
00:B73A 20EEB7          	    30:   jsr lcd_write_instruction_nibble
00:B73D 20CB90          	    31:   jsr delay_1ms  ; do it 4 times in case of faster board clock speeds
00:B740 20CB90          	    32:   jsr delay_1ms
00:B743 20CB90          	    33:   jsr delay_1ms
00:B746 20CB90          	    34:   jsr delay_1ms
00:B749 A920            	    35:   lda #$20    ; switch to 4-bit mode
00:B74B 20EEB7          	    36:   jsr lcd_write_instruction_nibble
00:B74E 20CB90          	    37:   jsr delay_1ms  ; do it 4 times in case of faster board clock speeds
00:B751 20CB90          	    38:   jsr delay_1ms
00:B754 20CB90          	    39:   jsr delay_1ms
00:B757 20CB90          	    40:   jsr delay_1ms
                        	    41: ;
                        	    42: ;  now we can switch to sending 8-bits in two nibbles
                        	    43: ;
00:B75A A928            	    44:   lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
00:B75C 20FAB7          	    45:   jsr lcd_instruction
00:B75F A90E            	    46:   lda #%00001110 ; Display on; cursor on; blink off
00:B761 20FAB7          	    47:   jsr lcd_instruction
00:B764 A906            	    48:   lda #%00000110 ; Increment and shift cursor; don't shift display
00:B766 20FAB7          	    49:   jsr lcd_instruction
00:B769 204EB8          	    50:   jsr lcd_clear_display
00:B76C 60              	    51:   rts
                        	    52: 
                        	    53: lcd_prepare_to_read_register:
00:B76D ADF17F          	    54:   lda VIA_PORTA
00:B770 0940            	    55:   ora #LCD_RW             ; set RW bit  (ie. enable reading)
00:B772 295F            	    56:   and #<(~(LCD_RS|LCD_E)) ; Clear RS/E bits
00:B774 8DF17F          	    57:   sta VIA_PORTA
00:B777 ADF27F          	    58:   lda VIA_DDRB
00:B77A 290F            	    59:   and #$0F
00:B77C 8DF27F          	    60:   sta VIA_DDRB            ; we are reading from DDRB
00:B77F 60              	    61:   rts
                        	    62: 
                        	    63: lcd_prepare_to_write_data:
00:B780 48              	    64:   pha
00:B781 ADF17F          	    65:   lda VIA_PORTA
00:B784 293F            	    66:   and #<(~(LCD_RW|LCD_E))  ; clear RW and E (enable writing)
00:B786 0920            	    67:   ora #LCD_RS              ; setting this means we write a character
00:B788 8DF17F          	    68:   sta VIA_PORTA
00:B78B ADF27F          	    69:   lda VIA_DDRB
00:B78E 09F0            	    70:   ora #$F0      ; Set high-order pins on port B to output
00:B790 8DF27F          	    71:   sta VIA_DDRB
00:B793 68              	    72:   pla
00:B794 60              	    73:   rts
                        	    74: 
                        	    75: lcd_prepare_to_write_instruction:
00:B795 48              	    76:   pha
00:B796 ADF17F          	    77:   lda VIA_PORTA
00:B799 291F            	    78:   and #<(~(LCD_RW|LCD_RS|LCD_E))  ; clear RW, RS and E (enable writing)
00:B79B 8DF17F          	    79:   sta VIA_PORTA
00:B79E ADF27F          	    80:   lda VIA_DDRB
00:B7A1 09F0            	    81:   ora #$F0      ; Set high-order pins on port B to output
00:B7A3 8DF27F          	    82:   sta VIA_DDRB
00:B7A6 68              	    83:   pla
00:B7A7 60              	    84:   rts
                        	    85: 
                        	    86: lcd_set_enable:
00:B7A8 ADF17F          	    87:   lda VIA_PORTA
00:B7AB 0980            	    88:   ora #LCD_E
00:B7AD 8DF17F          	    89:   sta VIA_PORTA   ; Set enable (E)
00:B7B0 60              	    90:   rts
                        	    91: 
                        	    92: lcd_clear_enable:
00:B7B1 ADF17F          	    93:   lda VIA_PORTA
00:B7B4 297F            	    94:   and #<(~LCD_E)  ; Clear enable (E)
00:B7B6 8DF17F          	    95:   sta VIA_PORTA
00:B7B9 60              	    96:   rts
                        	    97: 
                        	    98: lcd_read_instruction_nibble:
00:B7BA 20A8B7          	    99:   jsr lcd_set_enable
00:B7BD ADF07F          	   100:   lda VIA_PORTB   ; read the data on port B
00:B7C0 48              	   101:   pha             ; save the data
00:B7C1 20B1B7          	   102:   jsr lcd_clear_enable
00:B7C4 68              	   103:   pla             ; get the data back
00:B7C5 60              	   104:   rts
                        	   105: 
                        	   106: ;
                        	   107: ; wait until LCD is not busy
                        	   108: ;
                        	   109: lcd_wait:
00:B7C6 5A              	   110:   phy
00:B7C7 48              	   111:   pha
00:B7C8 206DB7          	   112:   jsr lcd_prepare_to_read_register
                        	   113: lcdbusy:
00:B7CB 20BAB7          	   114:   jsr lcd_read_instruction_nibble
00:B7CE 2980            	   115:   and #$80        ; get busy flag
00:B7D0 A8              	   116:   tay             ; save busy status
00:B7D1 20BAB7          	   117:   jsr lcd_read_instruction_nibble   ; do second nibble
00:B7D4 98              	   118:   tya             ; get busy status back
00:B7D5 D0F4            	   119:   bne lcdbusy     ; if busy go back
                        	   120: ;
                        	   121: ;  here when not busy any more
                        	   122: ;
00:B7D7 68              	   123:   pla
00:B7D8 7A              	   124:   ply
00:B7D9 60              	   125:   rts
                        	   126: 
                        	   127: ;
                        	   128: ;  Find the current LCD (cursor) address - useful for knowing
                        	   129: ;  if we exceed the limit of line 1
                        	   130: ;
                        	   131: lcd_get_address:
00:B7DA 206DB7          	   132:   jsr lcd_prepare_to_read_register
00:B7DD 20BAB7          	   133:   jsr lcd_read_instruction_nibble
00:B7E0 2970            	   134:   and #$70        ; ignore busy bit, mask out other junk
00:B7E2 8586            	   135:   sta lcd_work
00:B7E4 20BAB7          	   136:   jsr lcd_read_instruction_nibble
00:B7E7 4A              	   137:   lsr A   ; shift this lot into low-order bits
00:B7E8 4A              	   138:   lsr A
00:B7E9 4A              	   139:   lsr A
00:B7EA 4A              	   140:   lsr A
00:B7EB 0586            	   141:   ora lcd_work    ; get the high-order bits back
00:B7ED 60              	   142:   rts
                        	   143: 
                        	   144: lcd_write_instruction_nibble:
00:B7EE 48              	   145:   pha
00:B7EF 8DF07F          	   146:   sta VIA_PORTB         ; set up the data
00:B7F2 20A8B7          	   147:   jsr lcd_set_enable    ; toggle enable
00:B7F5 20B1B7          	   148:   jsr lcd_clear_enable
00:B7F8 68              	   149:   pla
00:B7F9 60              	   150:   rts
                        	   151: 
                        	   152: ;
                        	   153: ;  send an instruction to the LCD
                        	   154: ;
                        	   155: lcd_instruction:
00:B7FA 20C6B7          	   156:   jsr lcd_wait
00:B7FD 2095B7          	   157:   jsr lcd_prepare_to_write_instruction
00:B800 20EEB7          	   158:   jsr lcd_write_instruction_nibble
00:B803 48              	   159:   pha
00:B804 0A              	   160:   asl a   ; move the low-order bits into the high-order bits
00:B805 0A              	   161:   asl a   ; because the high-order 4 bits are the active ones
00:B806 0A              	   162:   asl a
00:B807 0A              	   163:   asl a
00:B808 20EEB7          	   164:   jsr lcd_write_instruction_nibble
00:B80B 68              	   165:   pla
00:B80C 60              	   166:   rts
                        	   167: 
                        	   168: lcd_data_nibble:
00:B80D 48              	   169:   pha
00:B80E 2080B7          	   170:   jsr lcd_prepare_to_write_data
00:B811 8DF07F          	   171:   sta VIA_PORTB
00:B814 20A8B7          	   172:   jsr lcd_set_enable
00:B817 20B1B7          	   173:   jsr lcd_clear_enable
00:B81A 68              	   174:   pla
00:B81B 60              	   175:   rts
                        	   176: 
                        	   177: ;
                        	   178: ;  print a character to the LCD
                        	   179: ;
                        	   180: lcd_print_char:
00:B81C 20C6B7          	   181:   jsr lcd_wait  ; wait for previous write to finish
00:B81F C90A            	   182:   cmp #NL
00:B821 D004            	   183:   bne lcd_print_not_newline ; newline jumps to 2nd line
00:B823 2056B8          	   184:   jsr lcd_second_line       ; go to second line
00:B826 60              	   185:   rts                       ; and don't print the newline :)
                        	   186: 
                        	   187: lcd_print_not_newline:
00:B827 48              	   188:   pha                   ; save the character we want to print
00:B828 20DAB7          	   189:   jsr lcd_get_address
00:B82B C910            	   190:   cmp #16         ; 16 characters on the first line
00:B82D 900E            	   191:   bcc lcd_print_char_ok ; not there yet
00:B82F D005            	   192:   bne lcd_print_char_on_2nd_line  ; not < 16 and not == 16, must be > 16
                        	   193:   ; we have exactly 16, so drop down to address 64
00:B831 2056B8          	   194:   jsr lcd_second_line  ; at char 16 go to 2nd line (address 64)
00:B834 8007            	   195:   bra lcd_print_char_ok
                        	   196: 
                        	   197: lcd_print_char_on_2nd_line:
00:B836 C950            	   198:   cmp #80                  ; more than 16 characters on in 2nd line? (64 + 16)
00:B838 9003            	   199:   bcc lcd_print_char_ok    ; nah
00:B83A 204EB8          	   200:   jsr lcd_clear_display    ; yes, clear display then and start again
                        	   201: lcd_print_char_ok:
                        	   202: lcd_print_char_newline:
00:B83D 2080B7          	   203:   jsr lcd_prepare_to_write_data
00:B840 68              	   204:   pla                      ; get the character back
00:B841 200DB8          	   205:   jsr lcd_data_nibble
00:B844 48              	   206:   pha
00:B845 0A              	   207:   asl a     ; now send the low-order bits
00:B846 0A              	   208:   asl a
00:B847 0A              	   209:   asl a
00:B848 0A              	   210:   asl a
00:B849 200DB8          	   211:   jsr lcd_data_nibble
00:B84C 68              	   212:   pla
00:B84D 60              	   213:   rts
                        	   214: 
                        	   215: lcd_clear_display:
00:B84E 48              	   216:   pha
00:B84F A901            	   217:   lda #%00000001 ; Clear display
00:B851 20FAB7          	   218:   jsr lcd_instruction
00:B854 68              	   219:   pla
00:B855 60              	   220:   rts
                        	   221: 
                        	   222: lcd_second_line:
00:B856 48              	   223:   pha
00:B857 A9C0            	   224:   lda #$C0 ; set output address to 0x40 (set DDRAM address)
00:B859 20FAB7          	   225:   jsr lcd_instruction
00:B85C 68              	   226:   pla
00:B85D 60              	   227:   rts
                        	   228: 
                        	   229: lcd_home:
00:B85E 48              	   230:   pha
00:B85F A980            	   231:   lda #$80 ; set output address to 0 (set DDRAM address)
00:B861 20FAB7          	   232:   jsr lcd_instruction
00:B864 68              	   233:   pla
00:B865 60              	   234:   rts
                        	   235: 
                        	   236: 
                        	   237: ;
                        	   238: ;  print null-terminated message on LCD, message in A (lo) and X (hi)
                        	   239: ;  returns the length of the message in Y
                        	   240: ;
                        	   241: lcd_print_message:
00:B866 8503            	   242:   sta REG2
00:B868 8604            	   243:   stx REG2+1
00:B86A A000            	   244:   ldy #0
00:B86C 204EB8          	   245:   jsr lcd_clear_display
                        	   246: lcd_print:
00:B86F B103            	   247:   lda (REG2),y
00:B871 F006            	   248:   beq lcd_print_done
00:B873 201CB8          	   249:   jsr lcd_print_char
00:B876 C8              	   250:   iny
00:B877 80F6            	   251:   bra lcd_print
                        	   252: 
00:B879 60              	   253: lcd_print_done rts
                        	   254: 
                        	   255:   .else ; LCD_SUPPORT
                        	   256: 
                        	   257: lcd_print_char :
                        	   258: lcd_clear_display :
                        	   259: lcd_second_line:
                        	   260: lcd_print_message:
                        	   261: lcd_instruction:
                        	   262: lcd_get_address:
                        	   263: lcd_home:
                        	   264: lcd_wait:
                        	   265:     ldx #50     ; No LCD
                        	   266:     jmp ERROR
                        	   267: 
                        	   268: 
                        	   269:   .endif  ; (no) LCD_SUPPORT
                        	   270: 
                        	   271:   .endif  ; not emulator
                        	   272: 

Source: "gpascal.asm"
                        	   182:   .include "symbols.inc"

Source: "symbols.inc"
                        	     1: ;***********************************************
                        	     2: ; SYMBOL TABLE STUFF: Offsets from the start of a particular symbol
                        	     3: ; Stored as a linked list, where you search backwards so the more local one is found first
                        	     4: ;***********************************************
                        	     5: 
                        	     6: SYMPRV   =  0         ; address of previous symbol (for working backwards through symbols)
                        	     7: SYMLVL   =  2         ; nested level (eg. entering a procedure/function increments the level,
                        	     8:                       ;                   and leaving it decrements the level)
                        	     9:                       ; - used to detect duplicate symbols at the same level
                        	    10: SYMTYP   =  3         ; Symbol type: C = constant, V = variable, Y = function return value
                        	    11:                       ;              P = procedure, F = function, A = array
                        	    12:                       ;              p = library procedure, f = library function
                        	    13:                       ;  See defines below.
                        	    14: SYMDSP   =  4         ; if the symbol is a constant, what the value is (3 bytes)
                        	    15:                       ; if the symbol is a variable, array or function return then this is the offset (2 bytes)
                        	    16: SYMARG   =  6         ; if the symbol is a procedure/function, count of arguments (can be zero)
                        	    17: SYMSUB   =  6         ; MAX SUBSCRIPT+1 - for arrays, so this is the actual array length
                        	    18: SYMDAT   =  8         ; data type: 0 = integer, 1 = char
                        	    19: SYMLEN   =  9         ; length of the name, der
                        	    20: SYMNAM   =  10        ; name of symbol for SYMLEN characters, stored in upper-case
                        	    21: 
                        	    22: ;
                        	    23: ; Symbol types
                        	    24: ;
                        	    25: 
                        	    26: SYMBOL_CONSTANT          = 'C'
                        	    27: SYMBOL_VARIABLE          = 'V'
                        	    28: SYMBOL_FUNCTION_RETURN   = 'Y'
                        	    29: SYMBOL_PROCEDURE         = 'P'
                        	    30: SYMBOL_FUNCTION          = 'F'
                        	    31: SYMBOL_LIBRARY_PROCEDURE = 'Q'  ; library procedures and functions are implemented in assembler
                        	    32: SYMBOL_LIBRARY_FUNCTION  = 'R'
                        	    33: SYMBOL_ARRAY             = 'A'
                        	    34: 
                        	    35: 
                        	    36: 
                        	    37: ;
                        	    38: ;***********************************************
                        	    39: ;SEARCH SYMBOL TABLE - returns Z if not found (BEQ <not found>)
                        	    40: ;***********************************************
                        	    41: SEARCH   =  *
00:B87A A532            	    42:          lda  ENDSYM+1    ; get the end of the symbol table
00:B87C 8541            	    43:          sta  SYMITM+1    ; make it the current symbol
00:B87E A531            	    44:          lda  ENDSYM
00:B880 800B            	    45:          bra  SEA1
                        	    46: 
                        	    47: SEA_NEXT =  *
00:B882 A000            	    48:          ldy  #SYMPRV
00:B884 B140            	    49:          lda  (SYMITM),Y
00:B886 AA              	    50:          tax
00:B887 C8              	    51:          iny
00:B888 B140            	    52:          lda  (SYMITM),Y
00:B88A 8541            	    53:          sta  SYMITM+1   ; previous link
00:B88C 8A              	    54:          txa
                        	    55: ;
                        	    56: ;  go to the previous symbol table item
                        	    57: ;
                        	    58: SEA1     =  *
00:B88D 8540            	    59:          sta  SYMITM
00:B88F C52F            	    60:          cmp  STARTSYM
00:B891 D007            	    61:          bne  SEA2
00:B893 A541            	    62:          lda  SYMITM+1
00:B895 C530            	    63:          cmp  STARTSYM+1
00:B897 D001            	    64:          bne  SEA2       ; more to go
00:B899 60              	    65:          rts             ; finished if we are back at the start of the symbol table
                        	    66: 
                        	    67: SEA2     =  *
00:B89A A009            	    68:          ldy  #SYMLEN
00:B89C B140            	    69:          lda  (SYMITM),Y  ; get this item's length
00:B89E C592            	    70:          cmp  token_length      ; compare to the token legnth we got
00:B8A0 D0E0            	    71:          bne  SEA_NEXT    ; wrong length - try another
00:B8A2 A540            	    72:          lda  SYMITM      ; back to this symbol's start address
00:B8A4 18              	    73:          clc
00:B8A5 690A            	    74:          adc  #SYMNAM     ; add the offset of the name to it
00:B8A7 8503            	    75:          sta  DEST
00:B8A9 A541            	    76:          lda  SYMITM+1
00:B8AB 6900            	    77:          adc  #0
00:B8AD 8504            	    78:          sta  DEST+1      ; the memory location of the symbol name is in DEST
00:B8AF A590            	    79:          lda  token_address      ; now put the token's address into SRCE
00:B8B1 8500            	    80:          sta  SRCE
00:B8B3 A591            	    81:          lda  token_address+1
00:B8B5 8501            	    82:          sta  SRCE+1
00:B8B7 A492            	    83:          ldy  token_length
00:B8B9 202D92          	    84:          jsr  COMSTL      ; compare SRCE to DEST
00:B8BC D0C4            	    85:          bne  SEA_NEXT    ; not that one - try another
00:B8BE 2036BA          	    86:          jsr  GET_DAT     ; get the symbol's data type into DATTYP
00:B8C1 A002            	    87:          ldy  #SYMLVL     ; and level - why isn't this a function, huh?
00:B8C3 B140            	    88:          lda  (SYMITM),Y
00:B8C5 AA              	    89:          tax              ; level into X
00:B8C6 A003            	    90:          ldy  #SYMTYP
00:B8C8 B140            	    91:          lda  (SYMITM),Y  ; get type of symbol
00:B8CA 8536            	    92:          sta  BSAVE       ; symbol type -> BSAVE
00:B8CC C943            	    93:          cmp  #SYMBOL_CONSTANT       ; constant?
00:B8CE D013            	    94:          bne  SEA4        ; nah
                        	    95: ;
                        	    96: ;  symbol is a constant
                        	    97: ;
00:B8D0 A004            	    98:          ldy  #SYMDSP     ; if a constant, this is the value
00:B8D2 B140            	    99:          lda  (SYMITM),Y
00:B8D4 8594            	   100:          sta  token_value
00:B8D6 C8              	   101:          iny
00:B8D7 B140            	   102:          lda  (SYMITM),Y
00:B8D9 8595            	   103:          sta  token_value+1
00:B8DB C8              	   104:          iny
00:B8DC B140            	   105:          lda  (SYMITM),Y
00:B8DE 8596            	   106:          sta  token_value+2     ; token_value (3 bytes) now has the value in it
00:B8E0 4CEEB8          	   107:          jmp  SEA3
                        	   108: ;
                        	   109: ;  symbol is not a constant
                        	   110: ;
                        	   111: SEA4     =  *                           ; not constant
00:B8E3 C956            	   112:          cmp  #SYMBOL_VARIABLE          ; variable?
00:B8E5 F004            	   113:          beq  SEA5                      ; yes
00:B8E7 C959            	   114:          cmp  #SYMBOL_FUNCTION_RETURN   ; argument?
00:B8E9 D003            	   115:          bne  SEA3                      ; no - must be SYMBOL_ARRAY, SYMBOL_PROCEDURE or SYMBOL_FUNCTION
                        	   116: ;
                        	   117: ;  here for variables and function return values
                        	   118: ;
                        	   119: SEA5     =  *
00:B8EB 2091BA          	   120:          jsr  GET_OFF    ; get the variable's offset
                        	   121: SEA3     =  *
00:B8EE A536            	   122:          lda  BSAVE      ; A now has the symbol type in it
                        	   123: 
                        	   124: ; Types are: SYMBOL_CONSTANT, SYMBOL_VARIABLE, SYMBOL_FUNCTION_RETURN,
                        	   125: ;            SYMBOL_PROCEDURE, SYMBOL_FUNCTION, SYMBOL_ARRAY
                        	   126: 
00:B8F0 60              	   127:          rts             ; SHOULD SET 'NEQ' FLAG
                        	   128: 
                        	   129: 
00:B8F1 A225            	   130: SYM_FULL ldx  #37     ; ERROR: Symbol table full
00:B8F3 4C6497          	   131:          jmp  ERROR
                        	   132: 
                        	   133: ;***********************************************
                        	   134: ; ADD SYMBOL TO SYMBOL TABLE - going downwards until we hit the P-codes
                        	   135: ;  A = the symbol type
                        	   136: ;***********************************************
                        	   137: ADDSYM   =  *
00:B8F6 48              	   138:          pha            ; save the symbol type
                        	   139: 
00:B8F7 A631            	   140:          ldx  ENDSYM    ; get the end of the symbol table
00:B8F9 8640            	   141:          stx  SYMITM    ; make it the current symbol
00:B8FB A632            	   142:          ldx  ENDSYM+1
00:B8FD 8641            	   143:          stx  SYMITM+1
                        	   144: ;
                        	   145: ;  since we are going downwards, we need to subtract the fixed size of a symbol table item,
                        	   146: ;  plus the symbol length, from SYMITM
                        	   147: ;
00:B8FF 38              	   148:          sec            ; first subtract the token length
00:B900 A540            	   149:          lda  SYMITM
00:B902 E592            	   150:          sbc  token_length
00:B904 8540            	   151:          sta  SYMITM
00:B906 8503            	   152:          sta  DEST      ; put this spot into DEST for copying the name
00:B908 A541            	   153:          lda  SYMITM+1
00:B90A E900            	   154:          sbc  #0
00:B90C 8541            	   155:          sta  SYMITM+1
00:B90E 8504            	   156:          sta  DEST+1
00:B910 38              	   157:          sec            ; and now the fixed size
00:B911 A540            	   158:          lda  SYMITM
00:B913 E90A            	   159:          sbc  #SYMNAM
00:B915 8540            	   160:          sta  SYMITM
00:B917 A541            	   161:          lda  SYMITM+1
00:B919 E900            	   162:          sbc  #0
00:B91B 8541            	   163:          sta  SYMITM+1
                        	   164: ;
                        	   165: ;  check we haven't hit the P-codes
                        	   166: ;
00:B91D A902            	   167:          lda  #FLAG_ASSEMBLING
00:B91F 25BE            	   168:          and  system_flags
00:B921 D008            	   169:          bne  ADDSYM_NOT_FULL
00:B923 A524            	   170:          lda  PCODE+1
00:B925 C541            	   171:          cmp  SYMITM+1
00:B927 9002            	   172:          bcc  ADDSYM_NOT_FULL   ; less than - ok
00:B929 80C6            	   173:          bra  SYM_FULL          ; greater than or equal (high-order byte) - uh oh
                        	   174: ;
                        	   175: ;  ah, for assembling it is a pain to know whether the symbol table has overflowed, so I'm going
                        	   176: ;  to ignore that as a problem for now. Checking against PCODE will not work if the assembler output
                        	   177: ;  has been relocated to above the symbol table, and the only other thing we can compare against is
                        	   178: ;  the end of the source which we don't necessarily know.
                        	   179: ;
                        	   180: ;
                        	   181: ;  now put the previous start in as the link for the previous one for this item
                        	   182: ;
                        	   183: ADDSYM_NOT_FULL:
00:B92B A000            	   184:          ldy  #SYMPRV
00:B92D A531            	   185:          lda  ENDSYM
00:B92F 9140            	   186:          sta  (SYMITM),Y
00:B931 A532            	   187:          lda  ENDSYM+1
00:B933 C8              	   188:          iny
00:B934 9140            	   189:          sta  (SYMITM),Y
                        	   190: ;
                        	   191: ;  SYMITM now becomes the start of the symbol table
                        	   192: ;
00:B936 A540            	   193:          lda  SYMITM
00:B938 8531            	   194:          sta  ENDSYM
00:B93A A541            	   195:          lda  SYMITM+1
00:B93C 8532            	   196:          sta  ENDSYM+1
                        	   197: ;
                        	   198: ;  OK, we should be done linking it in.
                        	   199: ;  SYMITM now points to this (as yet unfilled-in) item and the first two bytes now point to
                        	   200: ;   where the symbols previously ended
                        	   201: ;
00:B93E 68              	   202:          pla                ; get symbol type back
00:B93F A003            	   203:          ldy  #SYMTYP
00:B941 9140            	   204:          sta  (SYMITM),Y    ; store the type which was in A
00:B943 A002            	   205:          ldy  #SYMLVL
00:B945 48              	   206:          pha                ; save symbol type again
00:B946 A522            	   207:          lda  LEVEL
00:B948 9140            	   208:          sta  (SYMITM),Y    ; store the level
00:B94A A009            	   209:          ldy  #SYMLEN
00:B94C A592            	   210:          lda  token_length
00:B94E 9140            	   211:          sta  (SYMITM),Y    ; store the token length
00:B950 A8              	   212:          tay
00:B951 88              	   213:          dey                ; make zero-relative
                        	   214: ADD1     =  *               ; copy the name across, in upper case
00:B952 B190            	   215:          lda  (token_address),Y
00:B954 20C48F          	   216:          jsr  MAKE_UPPER
00:B957 9103            	   217:          sta  (DEST),Y
00:B959 88              	   218:          dey
00:B95A 10F6            	   219:          bpl  ADD1      ; keep copying
                        	   220: 
                        	   221: ;
                        	   222: ;  we have added name to the table, now do the rest
                        	   223: ;
00:B95C 68              	   224:          pla                     ; get symbol type back again
00:B95D AA              	   225:          tax                     ; symbol type
00:B95E C943            	   226:          cmp  #SYMBOL_CONSTANT   ; CONSTANT??
00:B960 D013            	   227:          bne  ADD4
                        	   228: ;
                        	   229: ;  constant
                        	   230: ;
00:B962 A004            	   231:          ldy  #SYMDSP            ; put this token's value into SYMDSP offset from SYMITM (for 3 bytes)
00:B964 A594            	   232:          lda  token_value
00:B966 9140            	   233:          sta  (SYMITM),Y
00:B968 C8              	   234:          iny
00:B969 A595            	   235:          lda  token_value+1
00:B96B 9140            	   236:          sta  (SYMITM),Y
00:B96D C8              	   237:          iny
00:B96E A596            	   238:          lda  token_value+2
00:B970 9140            	   239:          sta  (SYMITM),Y
00:B972 4C91B9          	   240:          jmp  ADD9
                        	   241: ;
                        	   242: ;  not a constant
                        	   243: ;
                        	   244: ADD4     =  *
00:B975 A008            	   245:          ldy  #SYMDAT
00:B977 A901            	   246:          lda  #1            ; char type (?)
00:B979 9140            	   247:          sta  (SYMITM),Y
00:B97B 8A              	   248:          txa                ; get symbol type back
00:B97C C956            	   249:          cmp  #SYMBOL_VARIABLE
00:B97E D011            	   250:          bne  ADD9
                        	   251: ;
                        	   252: ;  variable type
                        	   253: ;
00:B980 A005            	   254:          ldy  #SYMDSP+1
00:B982 A521            	   255:          lda  FRAME+1       ; save frame
00:B984 9140            	   256:          sta  (SYMITM),Y
00:B986 88              	   257:          dey
00:B987 A520            	   258:          lda  FRAME
00:B989 9140            	   259:          sta  (SYMITM),Y
00:B98B E620            	   260:          inc  FRAME         ; add 1 to frame number
00:B98D D002            	   261:          bne  ADD9
00:B98F E621            	   262:          inc  FRAME+1
                        	   263: ADD9     =  *
00:B991 60              	   264:          rts
                        	   265: ;
                        	   266: 
                        	   267: ;
                        	   268: LOOKUP   =  *
00:B992 207AB8          	   269:          JSR  SEARCH
00:B995 D005            	   270:          BNE  LOOK1
00:B997 A20B            	   271:          LDX  #11     ; ERROR: Undeclared Identifier
00:B999 4C6497          	   272:          jmp  ERROR
00:B99C 60              	   273: LOOK1    RTS
                        	   274: ;
00:B99D 207AB8          	   275: CHKDUP   JSR  SEARCH
00:B9A0 F00A            	   276:          BEQ  DUP9
00:B9A2 8A              	   277:          TXA
00:B9A3 C522            	   278:          CMP  LEVEL
00:B9A5 D005            	   279:          BNE  DUP9
00:B9A7 A226            	   280:          LDX  #38   ; ERROR: Duplicate Identifier
00:B9A9 4C6497          	   281:          jmp  ERROR
00:B9AC 60              	   282: DUP9     RTS
                        	   283: 

Source: "gpascal.asm"
                        	   183:   .include "compiler.inc"

Source: "compiler.inc"
                        	     1: 
                        	     2: ;***********************************************
                        	     3: ; COMPILER
                        	     4: ;***********************************************
                        	     5: 
                        	     6: 
                        	     7: ;
                        	     8: ;
                        	     9: ;  Compiler directives:
                        	    10: ;
                        	    11: ;    {%L} - list during compile (source code and current P-code address)
                        	    12: ;    {%P} - show generated P-codes during compile - only works during compile (not syntax check)
                        	    13: ;    {%N} - stop listing during compile (cancels %L and %P)
                        	    14: ;    {%S <address>} - relocate symbol table to <address> - must be done before defining symbols
                        	    15: ;                     also generates an opcode to relocate the runtime stack
                        	    16: ;
                        	    17: ;   The % must directly follow the start of the comment.
                        	    18: ;
                        	    19: ;
                        	    20: ;  Comments:  (* some comment *) or { some comment }
                        	    21: ;             "(*" / "{", and "*)" / "}" are treated interchangeably so (* some comment } would work
                        	    22: ;  Comments cannot be nested.
                        	    23: ;
                        	    24: ;  Tips:
                        	    25: ;
                        	    26: ;   Procedures and functions must be declared at the START of a block, not in the middle.
                        	    27: ;   The order is important. CONST first, then VAR, then procedure/function declarations, then BEGIN
                        	    28: 
                        	    29: ;    eg.
                        	    30: ;
                        	    31: ;    const limit = 10;   { <-- this is the start of a block: CONST before VAR }
                        	    32: ;    var k: integer;     { we declare variables and constants here - BEFORE "begin" }
                        	    33: ;    line : array [100] of char;  { array }
                        	    34: ;    function foo;       { and functions and procedures - this is the start of another block}
                        	    35: ;    begin
                        	    36: ;      foo := 42         { assign to function return value }
                        	    37: ;    end;                { end of the function block - note semicolon }
                        	    38: ;    begin               { end of declarations - now we have the block statements }
                        	    39: ;     for k := 1 to limit do
                        	    40: ;       writeln ("square of ", k, " is ", k * k);
                        	    41: ;     write (foo)        { call function }
                        	    42: ;    end.
                        	    43: ;
                        	    44: ;    ARGUMENTS: If the procedure or function does not take arguments OMIT THE BRACKETS.
                        	    45: ;               Likewise, omit the brackets if you call the procedure or function (unlike C)
                        	    46: ;
                        	    47: ;    Semicolons SEPARATE statements, they don't terminate them.
                        	    48: ;
                        	    49: ; Warnings: * Functions which do not assign to the function return value give undefined results.
                        	    50: ;           * Multiplication discards high-order bits if result is too large.
                        	    51: ;           * Divide remainder is always positive (ie. MOD always gives a positive result, regardless of operand signs)
                        	    52: ;           * Function arguments are always integers and always return an integer.
                        	    53: ;           * One to three-byte strings can be used as integer constants
                        	    54: ;               eg. a := "abc"; write (a);   --> Result: 6513249 (ie. 0x636261 or "abc")
                        	    55: ;               The first character is the low-order byte in the number, explaining the above results.
                        	    56: ;           * Strings can start with single or double quotes, whatever starts the string must terminate it.
                        	    57: ;           * String literals can have the same character that started the string embedded, to do that put it twice.
                        	    58: ;             eg. 'Nick''s cat'
                        	    59: ;           * Array access it not range-checked.
                        	    60: ;           * Arrays start at zero. The array size declared is the maximum index (unlike C) so foo: array [10] of integ
                        	    61: ;               would declare an array of 11 elements, numbered from foo [0] to foo [10]
                        	    62: ;           * Maximum arguments to a procedure/function is 85 (255 / 3) due to internal coding
                        	    63: ;
                        	    64: 
                        	    65: 
                        	    66: ;
00:B9AD A2FF            	    67: COMPIL   LDX  #NEW_STK
00:B9AF 9A              	    68:   txs    ; set stack back to 0xFF
                        	    69: 
00:B9B0 20DA91          	    70:   jsr  INIT
00:B9B3 A901            	    71:   lda  #FLAG_COMPILING
00:B9B5 04BE            	    72:   tsb  system_flags
00:B9B7 201EC6          	    73:   jsr  add_pascal_library_functions
00:B9BA 20A0CE          	    74:   jsr  pas_get_token
00:B9BD 20A1C2          	    75:   jsr  BLOCK
00:B9C0 A92E            	    76:   lda  #'.'
00:B9C2 A209            	    77:   ldx  #9        ; ERROR: . expected
00:B9C4 2004CF          	    78:   jsr  CHKTKN
00:B9C7 A900            	    79:   lda  #0
00:B9C9 A213            	    80:   ldx  #19       ; ERROR: Incorrect Symbol
00:B9CB 20F4CE          	    81:   jsr  GETCHK
00:B9CE 202892          	    82:   jsr  CROUT
00:B9D1 A9DF            	    83:   lda  #<pcodes_ended_message  ; P-codes ended at
00:B9D3 A292            	    84:   ldx  #>pcodes_ended_message
00:B9D5 202682          	    85:   jsr  print
00:B9D8 A524            	    86:   lda  PCODE+1
00:B9DA 8544            	    87:   sta  END_PCD+1
00:B9DC 209D92          	    88:   jsr  PRBYTE
00:B9DF A523            	    89:   lda  PCODE
00:B9E1 8543            	    90:   sta  END_PCD
00:B9E3 205293          	    91:   jsr  PRBYTECR
00:B9E6 20A88E          	    92:   jsr  show_symbol_table_end
00:B9E9 20CD8E          	    93:   jsr  show_source_end
                        	    94: 
00:B9EC A9F2            	    95:   lda  #<compile_finished_message  ; <C>ompile finished: No Errors
00:B9EE A292            	    96:   ldx  #>compile_finished_message
00:B9F0 202682          	    97:   jsr  print
00:B9F3 A642            	    98:   ldx  SYNTAX
00:B9F5 D004            	    99:   bne  END_CMP
00:B9F7 A908            	   100:   lda  #FLAG_VALID_COMPILE
00:B9F9 04BE            	   101:   tsb  system_flags
                        	   102: END_CMP  =  *
00:B9FB 4CCC82          	   103:   jmp  main_prompt
                        	   104: ;
                        	   105: 
                        	   106: ;
                        	   107: CHKLHP   =  *
00:B9FE A928            	   108:          LDA  #'('
00:BA00 A21F            	   109:          LDX  #31     ; ERROR: ( expected
00:BA02 4CF4CE          	   110:          JMP  GETCHK
                        	   111: ;
                        	   112: CHKRHP   =  *
00:BA05 A929            	   113:          LDA  #')'
00:BA07 A216            	   114:          LDX  #22     ; ERROR: ) expected
00:BA09 2004CF          	   115:          JSR  CHKTKN
00:BA0C 4CA0CE          	   116:          JMP  pas_get_token
                        	   117: ;
                        	   118: GETSUB   =  *
00:BA0F 2018BA          	   119:          JSR  CHKLHB
00:BA12 2029BD          	   120:          JSR  EXPRES
00:BA15 4C22BA          	   121:          JMP  CHKRHB
                        	   122: ;
                        	   123: CHKLHB   =  *
00:BA18 A95B            	   124:          LDA  #'['
00:BA1A A221            	   125:          LDX  #33     ; ERROR: [ expected
00:BA1C 20F4CE          	   126:          JSR  GETCHK
00:BA1F 4CA0CE          	   127:          JMP  pas_get_token
                        	   128: ;
                        	   129: CHKRHB   =  *
00:BA22 A95D            	   130:          LDA  #']'
00:BA24 A222            	   131:          LDX  #34     ; ERROR: ] expected
00:BA26 2004CF          	   132:          JSR  CHKTKN
00:BA29 4CA0CE          	   133:          JMP  pas_get_token
                        	   134: ;
                        	   135: GET_LEV  =  *
00:BA2C A522            	   136:          LDA  LEVEL
00:BA2E A002            	   137:          LDY  #SYMLVL
00:BA30 38              	   138:          SEC
00:BA31 F140            	   139:          SBC  (SYMITM),Y
00:BA33 8527            	   140:          STA  DISPL
00:BA35 60              	   141:          RTS
                        	   142: ;
                        	   143: GET_DAT  =  *
00:BA36 A008            	   144:          LDY  #SYMDAT
00:BA38 B140            	   145:          LDA  (SYMITM),Y
00:BA3A 854A            	   146:          STA  DATTYP
00:BA3C 60              	   147:          RTS
                        	   148: ;
                        	   149: 
                        	   150: 
                        	   151: 
                        	   152: ; CONSTANT DEC
                        	   153: ;
                        	   154: CONDEC   =  *
00:BA3D A949            	   155:          LDA  #TOKEN_IDENTIFIER
00:BA3F A204            	   156:          LDX  #4        ; ERROR: Identifier expected
00:BA41 2004CF          	   157:          JSR  CHKTKN
00:BA44 20C992          	   158:          JSR  TKNWRK
00:BA47 A592            	   159:          LDA  token_length
00:BA49 48              	   160:          PHA
00:BA4A A93D            	   161:          LDA  #'='
00:BA4C A203            	   162:          LDX  #3        ; ERROR: = expected
00:BA4E 20F4CE          	   163:          JSR  GETCHK
00:BA51 20A0CE          	   164:          JSR  pas_get_token
00:BA54 2030BB          	   165:          JSR  CONST
00:BA57 20D492          	   166:          JSR  WRKTKN
00:BA5A 68              	   167:          PLA
00:BA5B 8592            	   168:          STA  token_length
00:BA5D 209DB9          	   169:          JSR  CHKDUP
00:BA60 A943            	   170:          LDA  #SYMBOL_CONSTANT
00:BA62 20F6B8          	   171:          JSR  ADDSYM
00:BA65 4CA0CE          	   172:          JMP  pas_get_token
                        	   173: ;
                        	   174: ;
                        	   175: ;--- SYMITM --> WORK
                        	   176: ;
                        	   177: SYMWRK   =  *
00:BA68 48              	   178:          PHA
00:BA69 A540            	   179:          LDA  SYMITM
00:BA6B 8537            	   180:          STA  WORK
00:BA6D A541            	   181:          LDA  SYMITM+1
00:BA6F 8538            	   182:          STA  WORK+1
00:BA71 68              	   183:          PLA
00:BA72 60              	   184:          RTS
                        	   185: ;
                        	   186: ;--- WORK --> SYMITM
                        	   187: ;
                        	   188: WRKSYM   =  *
00:BA73 48              	   189:          PHA
00:BA74 A537            	   190:          LDA  WORK
00:BA76 8540            	   191:          STA  SYMITM
00:BA78 A538            	   192:          LDA  WORK+1
00:BA7A 8541            	   193:          STA  SYMITM+1
00:BA7C 68              	   194:          PLA
00:BA7D 60              	   195:          RTS
                        	   196: ;
                        	   197: ; PUSH PCODE ONTO STACK
                        	   198: ;
                        	   199: PSHPCODE =  *
00:BA7E 8536            	   200:          STA  BSAVE
00:BA80 68              	   201:          PLA
00:BA81 AA              	   202:          TAX
00:BA82 68              	   203:          PLA
00:BA83 A8              	   204:          TAY
00:BA84 A524            	   205:          LDA  PCODE+1
00:BA86 48              	   206:          PHA
00:BA87 A523            	   207:          LDA  PCODE
00:BA89 48              	   208:          PHA
00:BA8A 98              	   209:          TYA
00:BA8B 48              	   210:          PHA
00:BA8C 8A              	   211:          TXA
00:BA8D 48              	   212:          PHA
00:BA8E A536            	   213:          LDA  BSAVE
00:BA90 60              	   214:          RTS
                        	   215: ;
                        	   216: ;  Get the offset of this current symbol into OFFSET
                        	   217: ;
                        	   218: GET_OFF  =  *
00:BA91 48              	   219:          PHA
00:BA92 A004            	   220:          LDY  #SYMDSP
00:BA94 B140            	   221:          LDA  (SYMITM),Y
00:BA96 8529            	   222:          STA  OFFSET
00:BA98 C8              	   223:          INY
00:BA99 B140            	   224:          LDA  (SYMITM),Y
00:BA9B 852A            	   225:          STA  OFFSET+1
00:BA9D A003            	   226:          LDY  #SYMTYP
00:BA9F B140            	   227:          LDA  (SYMITM),Y
00:BAA1 C956            	   228:          CMP  #SYMBOL_VARIABLE
00:BAA3 F008            	   229:          BEQ  GETO_1
00:BAA5 C941            	   230:          CMP  #SYMBOL_ARRAY
00:BAA7 F004            	   231:          BEQ  GETO_1
00:BAA9 C959            	   232:          CMP  #SYMBOL_FUNCTION_RETURN
00:BAAB D00D            	   233:          BNE  GETO_2
                        	   234: ;
                        	   235: ;  here if the symbol is a variable, array or function return value
                        	   236: ;   subtract the offset from -3
                        	   237: ;
                        	   238: GETO_1   =  *
00:BAAD 38              	   239:          SEC
00:BAAE A9FD            	   240:          LDA  #$FD
00:BAB0 E529            	   241:          SBC  OFFSET
00:BAB2 8529            	   242:          STA  OFFSET
00:BAB4 A9FF            	   243:          LDA  #$FF
00:BAB6 E52A            	   244:          SBC  OFFSET+1
00:BAB8 852A            	   245:          STA  OFFSET+1
                        	   246: GETO_2   =  *
00:BABA 68              	   247:          PLA
00:BABB 60              	   248:          RTS
                        	   249: ;
                        	   250: GETEXPR  =  *
00:BABC 20A0CE          	   251:          JSR  pas_get_token
00:BABF 4C29BD          	   252:          JMP  EXPRES
                        	   253: ;
                        	   254: ;
                        	   255: PCD_WRKD =  *
00:BAC2 48              	   256:          PHA
00:BAC3 A523            	   257:          LDA  PCODE
00:BAC5 8533            	   258:          STA  WORKD
00:BAC7 A524            	   259:          LDA  PCODE+1
00:BAC9 8534            	   260:          STA  WORKD+1
00:BACB 68              	   261:          PLA
00:BACC 60              	   262:          RTS
                        	   263: ;
                        	   264: WRK_OPND =  *
00:BACD 48              	   265:          PHA
00:BACE A537            	   266:          LDA  WORK
00:BAD0 852B            	   267:          STA  OPND
00:BAD2 A538            	   268:          LDA  WORK+1
00:BAD4 852C            	   269:          STA  OPND+1
00:BAD6 68              	   270:          PLA
00:BAD7 60              	   271:          RTS
                        	   272: ;
                        	   273: WRKD_WRK =  *
00:BAD8 48              	   274:          PHA
00:BAD9 A533            	   275:          LDA  WORKD
00:BADB 8537            	   276:          STA  WORK
00:BADD A534            	   277:          LDA  WORKD+1
00:BADF 8538            	   278:          STA  WORK+1
00:BAE1 68              	   279:          PLA
00:BAE2 60              	   280:          RTS
                        	   281: ;
                        	   282: WRK_WRKD =  *
00:BAE3 48              	   283:          PHA
00:BAE4 A537            	   284:          LDA  WORK
00:BAE6 8533            	   285:          STA  WORKD
00:BAE8 A538            	   286:          LDA  WORK+1
00:BAEA 8534            	   287:          STA  WORKD+1
00:BAEC 68              	   288:          PLA
00:BAED 60              	   289:          RTS
                        	   290: ;
                        	   291: GET_COMM =  *
00:BAEE A92C            	   292:          LDA  #','
00:BAF0 A220            	   293:          LDX  #32     ; ERROR: , expected
00:BAF2 4C04CF          	   294:          JMP  CHKTKN
                        	   295: ;
                        	   296: GET_ITEM =  *
00:BAF5 20EEBA          	   297:          JSR  GET_COMM   ; check for comma
00:BAF8 4CBCBA          	   298:          JMP  GETEXPR
                        	   299: ;
                        	   300: ;  Load (push) a constant (ie. a literal number)
                        	   301: ;
                        	   302: ;  Numbers in the range 0 to 0x7F are turned into a "low literal" which is a P-code
                        	   303: ;  with the 0x80 bit set. These then become a single-byte P-code which simply pushes
                        	   304: ;  that number onto the stack, thus saving having to have a 4-byte P-code being PCODE_LIT
                        	   305: ;  followed by a 3-byte number, 2 bytes of which would be zero.
                        	   306: ;
                        	   307: VAL_MOVE =  *
00:BAFB 48              	   308:          PHA
00:BAFC 18              	   309:          CLC
00:BAFD A594            	   310:          LDA  token_value
00:BAFF 8527            	   311:          STA  DISPL   ; why?
00:BB01 1001            	   312:          BPL  VAL_1   ; is it 0x00 to 0x7F?
00:BB03 38              	   313:          SEC          ; no, set carry bit
                        	   314: VAL_1    =  *
00:BB04 A595            	   315:          LDA  token_value+1
00:BB06 F001            	   316:          BEQ  VAL_2   ; is second byte 0x00?
00:BB08 38              	   317:          SEC          ; no, set carry bit
                        	   318: VAL_2    =  *
00:BB09 8529            	   319:          STA  OFFSET
00:BB0B A596            	   320:          LDA  token_value+2
00:BB0D 852A            	   321:          STA  OFFSET+1
00:BB0F F001            	   322:          BEQ  VAL_3   ; is third byte 0x00?
00:BB11 38              	   323:          SEC          ; no, set carry bit
                        	   324: VAL_3    =  *
00:BB12 9007            	   325:          BCC  VAL_5   ; did we ever set the carry bit?
00:BB14 A900            	   326:          LDA  #PCODE_LIT  ; yes, so just generate a "load literal"
00:BB16 20E1C6          	   327:          JSR  GENADR
00:BB19 68              	   328:          PLA
00:BB1A 60              	   329:          RTS
                        	   330: VAL_5    =  *
00:BB1B A594            	   331:          LDA  token_value   ; get the low-order byte back
00:BB1D 0980            	   332:          ORA  #$80    ; set the 0x80 bit as a flag
00:BB1F 20C8C6          	   333:          JSR  GENNOP  ; output one P-code
00:BB22 68              	   334:          PLA
00:BB23 60              	   335:          RTS
                        	   336: ;
                        	   337: ;
                        	   338: CHK_STAK =  *
00:BB24 BA              	   339:          TSX
00:BB25 8A              	   340:          TXA
00:BB26 C920            	   341:          CMP  #MAX_STK
00:BB28 9001            	   342:          BCC  STK_FULL
00:BB2A 60              	   343:          RTS
                        	   344: STK_FULL =  *
00:BB2B A21B            	   345: STK_ERR  LDX  #27     ; ERROR: Stack full
00:BB2D 4C6497          	   346:          jmp  ERROR      ; FULL
                        	   347: ;
                        	   348: ;
                        	   349: ; CONST get the value into token_value
                        	   350: ;
                        	   351: CONST    =  *
00:BB30 A593            	   352:          LDA  token_type
00:BB32 C94E            	   353:          CMP  #TOKEN_NUMBER
00:BB34 F01F            	   354:          BEQ  CONST9
00:BB36 C949            	   355:          CMP  #TOKEN_IDENTIFIER
00:BB38 F00D            	   356:          BEQ  CONST1
00:BB3A C922            	   357:          CMP  #TOKEN_STRING
00:BB3C D00E            	   358:          BNE  CONST3
00:BB3E A692            	   359:          LDX  token_length
00:BB40 E004            	   360:          CPX  #4
00:BB42 9011            	   361:          BCC  CONST9
00:BB44 4CD8BC          	   362:          JMP  FACERR1    ; STRING TOO BIG
00:BB47 207AB8          	   363: CONST1   JSR  SEARCH
00:BB4A D005            	   364:          BNE  CONST2
                        	   365: CONST3   =  *
00:BB4C A202            	   366:          LDX  #2        ; ERROR: Constant expected
00:BB4E 4C6497          	   367:          jmp  ERROR
00:BB51 C943            	   368: CONST2   CMP  #SYMBOL_CONSTANT
00:BB53 D0F7            	   369:          BNE  CONST3
00:BB55 60              	   370: CONST9   RTS
                        	   371: ;
                        	   372: ; VARIABLE DEC
                        	   373: ;
00:BB56 A949            	   374: VARDEC   LDA  #TOKEN_IDENTIFIER
00:BB58 A204            	   375:          LDX  #4      ; ERROR: Identifier expected
00:BB5A 2004CF          	   376:          JSR  CHKTKN
00:BB5D 209DB9          	   377:          JSR  CHKDUP
00:BB60 A956            	   378:          LDA  #SYMBOL_VARIABLE
00:BB62 20F6B8          	   379:          JSR  ADDSYM
00:BB65 4CA0CE          	   380:          JMP  pas_get_token
                        	   381: ;
                        	   382: ; SIMPLE EXPRESSION
                        	   383: ;
                        	   384: SIMEXP   =  *
00:BB68 A593            	   385:          LDA  token_type
00:BB6A C92B            	   386:          CMP  #'+'
00:BB6C F004            	   387:          BEQ  SIM1
00:BB6E C92D            	   388:          CMP  #'-'
00:BB70 D048            	   389:          BNE  SIM2
00:BB72 48              	   390: SIM1     PHA
00:BB73 20A0CE          	   391:          JSR  pas_get_token
00:BB76 20DABB          	   392:          JSR  TERM
00:BB79 68              	   393:          PLA
00:BB7A C92D            	   394:          CMP  #'-'
00:BB7C D005            	   395:          BNE  SIM3
00:BB7E A902            	   396:          LDA  #PCODE_NEG      ; NEG     	Negate (sp)
00:BB80 20C8C6          	   397:          JSR  GENNOP     ; NEGATE
00:BB83 A593            	   398: SIM3     LDA  token_type
00:BB85 C92B            	   399:          CMP  #'+'
00:BB87 F00D            	   400:          BEQ  SIM4
00:BB89 C92D            	   401:          CMP  #'-'
00:BB8B F009            	   402:          BEQ  SIM4
00:BB8D C98A            	   403:          CMP  #TOKEN_OR       ; OR
00:BB8F F005            	   404:          BEQ  SIM4
00:BB91 C9A4            	   405:          CMP  #TOKEN_XOR      ; XOR
00:BB93 F001            	   406:          BEQ  SIM4
00:BB95 60              	   407:          RTS
00:BB96 48              	   408: SIM4     PHA
00:BB97 20A0CE          	   409:          JSR  pas_get_token
00:BB9A 20DABB          	   410:          JSR  TERM
00:BB9D 68              	   411:          PLA
00:BB9E C92D            	   412:          CMP  #'-'
00:BBA0 F010            	   413:          BEQ  SIM5
00:BBA2 C92B            	   414:          CMP  #'+'
00:BBA4 F010            	   415:          BEQ  SIM6
00:BBA6 C9A4            	   416:          CMP  #TOKEN_XOR          ; XOR
00:BBA8 F016            	   417:          BEQ  SIM8
00:BBAA A91A            	   418:          LDA  #PCODE_ORR          ; ORR     	OR  (sp - 1) | (sp)
00:BBAC 20C8C6          	   419: SIM7     JSR  GENNOP
00:BBAF 4C83BB          	   420:          JMP  SIM3
00:BBB2 A906            	   421: SIM5     LDA  #PCODE_SUB          ; MINUS
00:BBB4 D0F6            	   422:          BNE  SIM7
00:BBB6 A904            	   423: SIM6     LDA  #PCODE_ADD          ; PLUS
00:BBB8 D0F2            	   424:          BNE  SIM7
00:BBBA 20DABB          	   425: SIM2     JSR  TERM
00:BBBD 4C83BB          	   426:          JMP  SIM3
00:BBC0 A93A            	   427: SIM8     LDA  #PCODE_XOR         ; XOR
00:BBC2 D0E8            	   428:          BNE  SIM7
                        	   429: ;
                        	   430: ; TERM
                        	   431: ;
00:BBC4 2A              	   432: TERMT1   ASC    '*'
00:BBC5 E7BB            	   433:          word   TERM1
00:BBC7 8B              	   434:          DFB    TOKEN_DIV    ; div
00:BBC8 E7BB            	   435:          word   TERM1
00:BBCA 2F              	   436:          ASC    '/'
00:BBCB E7BB            	   437:          word   TERM1
00:BBCD 8D              	   438:          DFB    TOKEN_AND    ; and
00:BBCE E7BB            	   439:          word   TERM1
00:BBD0 8C              	   440:          DFB    TOKEN_MOD    ; mod
00:BBD1 E7BB            	   441:          word   TERM1
00:BBD3 8E              	   442:          DFB    TOKEN_SHL    ; shl
00:BBD4 E7BB            	   443:          word   TERM1
00:BBD6 8F              	   444:          DFB    TOKEN_SHR    ; shr
00:BBD7 E7BB            	   445:          word   TERM1
00:BBD9 00              	   446:          DFB    0
                        	   447: ;
00:BBDA 2028BC          	   448: TERM     JSR  FACTOR
00:BBDD A2C4            	   449: TERM2    LDX  #<TERMT1
00:BBDF A0BB            	   450:          LDY  #>TERMT1
00:BBE1 A593            	   451:          LDA  token_type
00:BBE3 20928F          	   452:          JSR  TKNJMP
00:BBE6 60              	   453:          RTS
                        	   454: ;
00:BBE7 48              	   455: TERM1    PHA
00:BBE8 20A0CE          	   456:          JSR  pas_get_token
00:BBEB 2028BC          	   457:          JSR  FACTOR
00:BBEE 68              	   458:          PLA
00:BBEF A212            	   459:          LDX  #<TERMT3
00:BBF1 A0BC            	   460:          LDY  #>TERMT3
00:BBF3 20928F          	   461:          JSR  TKNJMP
                        	   462: ;
00:BBF6 A90A            	   463: TERM4    LDA  #PCODE_DIV       ; Divide (sp - 1) / (sp)
00:BBF8 20C8C6          	   464: TERM3    JSR  GENNOP
00:BBFB 4CDDBB          	   465:          JMP  TERM2
00:BBFE A91B            	   466: TERM5    LDA  #PCODE_AND        ; AND
00:BC00 D0F6            	   467:          BNE  TERM3
00:BC02 A90B            	   468: TERM6    LDA  #PCODE_MOD        ; MOD
00:BC04 D0F2            	   469:          BNE  TERM3
00:BC06 A922            	   470: TERM7    LDA  #PCODE_SHL       ; Shift left (sp) bits
00:BC08 D0EE            	   471:          BNE  TERM3
00:BC0A A924            	   472: TERM8    LDA  #PCODE_SHR       ; Shift right (sp) bits
00:BC0C D0EA            	   473:          BNE  TERM3
00:BC0E A908            	   474: TERM9    LDA  #PCODE_MUL        ; Multiply (sp) * (sp - 1)
00:BC10 D0E6            	   475:          BNE  TERM3
                        	   476: ;
00:BC12 8B              	   477: TERMT3   DFB    TOKEN_DIV     ; div
00:BC13 F6BB            	   478:          word   TERM4
00:BC15 2F              	   479:          ASC    '/'
00:BC16 F6BB            	   480:          word   TERM4
00:BC18 8D              	   481:          DFB    TOKEN_AND     ; and
00:BC19 FEBB            	   482:          word   TERM5
00:BC1B 8C              	   483:          DFB    TOKEN_MOD     ; mod
00:BC1C 02BC            	   484:          word   TERM6
00:BC1E 8E              	   485:          DFB    TOKEN_SHL     ; shl
00:BC1F 06BC            	   486:          word   TERM7
00:BC21 8F              	   487:          DFB    TOKEN_SHR     ; shr
00:BC22 0ABC            	   488:          word   TERM8
00:BC24 2A              	   489:          ASC    '*'
00:BC25 0EBC            	   490:          word   TERM9
00:BC27 00              	   491:          DFB  0
                        	   492: ;
                        	   493: ; FACTOR
                        	   494: ;
00:BC28 2024BB          	   495: FACTOR   JSR  CHK_STAK
00:BC2B A593            	   496:          LDA  token_type
00:BC2D A210            	   497:          LDX  #<FACTB1
00:BC2F A0BD            	   498:          LDY  #>FACTB1
00:BC31 20928F          	   499:          JSR  TKNJMP
00:BC34 A217            	   500:          LDX  #23     ; ERROR: Illegal factor
00:BC36 4C6497          	   501:          jmp  ERROR
                        	   502: ;
00:BC39 2092B9          	   503: IDENT    JSR  LOOKUP
00:BC3C C950            	   504: IDENT1   CMP  #SYMBOL_PROCEDURE
00:BC3E F004            	   505:          beq  IDENT1A
00:BC40 C951            	   506:          CMP  #SYMBOL_LIBRARY_PROCEDURE
00:BC42 D005            	   507:          BNE  IDENT2
                        	   508: IDENT1A:
00:BC44 A215            	   509:          LDX  #21     ; ERROR: Use of procedure Identifier in expression
00:BC46 4C6497          	   510:          jmp  ERROR
00:BC49 C959            	   511: IDENT2   CMP  #SYMBOL_FUNCTION_RETURN
00:BC4B D015            	   512:          BNE  IDENT2A
00:BC4D A000            	   513:          LDY  #SYMPRV      ; this symbol is actually the function return value symbol
00:BC4F B140            	   514:          LDA  (SYMITM),Y   ; so go to the previous symbol which will be the function
00:BC51 AA              	   515:          TAX               ; declaration symbol with the address of the function to be called
00:BC52 C8              	   516:          INY
00:BC53 B140            	   517:          LDA  (SYMITM),Y
00:BC55 8541            	   518:          STA  SYMITM+1
00:BC57 8A              	   519:          TXA
00:BC58 8540            	   520:          STA  SYMITM
00:BC5A A980            	   521:          lda  #$80       ; push 0 onto the stack which will be the default function return value
00:BC5C 20C8C6          	   522:          jsr  GENNOP     ; when the function returns this will be left on the top of the stack
00:BC5F 4CA9BF          	   523:          JMP  FNCPRC     ; with the function's assigned value in it (or zero if nothing assigned);
                        	   524: 
00:BC62 C952            	   525: IDENT2A  CMP #SYMBOL_LIBRARY_FUNCTION
00:BC64 D003            	   526:          bne IDENT3
00:BC66 4C78C6          	   527:          jmp  library_function_call
                        	   528: 
00:BC69 C941            	   529: IDENT3   CMP  #SYMBOL_ARRAY
00:BC6B F030            	   530:          BEQ  IDENT4
00:BC6D C943            	   531:          CMP  #SYMBOL_CONSTANT
00:BC6F D00E            	   532:          BNE  IDENT5
00:BC71 20FBBA          	   533:          JSR  VAL_MOVE
00:BC74 4C92BC          	   534:          JMP  IDENT7
                        	   535: ;
                        	   536: ;   Here for address of integer variable
                        	   537: ;
00:BC77 A90C            	   538: FACAD1   LDA  #PCODE_ADRNN
00:BC79 2081BC          	   539:          JSR  IDENT5_A
00:BC7C 4C05BA          	   540:          JMP  CHKRHP
                        	   541: ;
00:BC7F A92C            	   542: IDENT5   LDA  #PCODE_LOD   ; load integer onto stack
00:BC81 48              	   543: IDENT5_A PHA
                        	   544: ;
00:BC82 8636            	   545:          STX  BSAVE
00:BC84 A522            	   546:          LDA  LEVEL
00:BC86 38              	   547:          SEC
00:BC87 E536            	   548:          SBC  BSAVE
00:BC89 8527            	   549:          STA  DISPL
00:BC8B 68              	   550:          PLA
00:BC8C 18              	   551: IDENT6   CLC
00:BC8D 654A            	   552:          ADC  DATTYP
00:BC8F 20E1C6          	   553:          JSR  GENADR
00:BC92 4CA0CE          	   554: IDENT7   JMP  pas_get_token
                        	   555: ;
00:BC95 A90E            	   556: FACAD2   LDA  #PCODE_ADRAN  ; address of integer array
00:BC97 209FBC          	   557:          JSR  IDENT4_A
00:BC9A 4C05BA          	   558:          JMP  CHKRHP
                        	   559: ;
                        	   560: ;    Here for load indexed integer
                        	   561: ;
00:BC9D A930            	   562: IDENT4   LDA  #PCODE_LDI         ; Load integer indexed
00:BC9F 48              	   563: IDENT4_A PHA
                        	   564: ;
00:BCA0 2068BA          	   565:          JSR  SYMWRK
00:BCA3 205F92          	   566:          JSR  PSHWRK
00:BCA6 200FBA          	   567:          JSR  GETSUB
00:BCA9 207292          	   568:          JSR  PULWRK
00:BCAC 2073BA          	   569:          JSR  WRKSYM
00:BCAF 2036BA          	   570:          JSR  GET_DAT
00:BCB2 202CBA          	   571:          JSR  GET_LEV
00:BCB5 2091BA          	   572:          JSR  GET_OFF
00:BCB8 68              	   573:          PLA
00:BCB9 18              	   574:          CLC
00:BCBA 654A            	   575:          ADC  DATTYP
00:BCBC 4CE1C6          	   576:          JMP  GENADR
                        	   577: ;
                        	   578: ; ADDRESS (IDENTIFIER)
                        	   579: ;
                        	   580: ;
                        	   581: FACADR   =  *
00:BCBF 20FEB9          	   582:          JSR  CHKLHP
00:BCC2 2009CF          	   583:          JSR  GET_LOOK
00:BCC5 C956            	   584:          CMP  #SYMBOL_VARIABLE
00:BCC7 F0AE            	   585:          BEQ  FACAD1
00:BCC9 C941            	   586:          CMP  #SYMBOL_ARRAY
00:BCCB F0C8            	   587:          BEQ  FACAD2
00:BCCD A217            	   588:          LDX  #23     ; ERROR: Illegal factor
00:BCCF 4C6497          	   589:          jmp  ERROR
                        	   590: ;
                        	   591: ;
00:BCD2 A592            	   592: FACSTR   LDA  token_length
00:BCD4 C904            	   593:          CMP  #4
00:BCD6 9005            	   594:          BCC  FACNUM    ; BLT
00:BCD8 A21D            	   595: FACERR1  LDX  #29        ; ERROR: string literal too big
00:BCDA 4C6497          	   596:          jmp  ERROR
                        	   597: FACNUM   =  *
00:BCDD 20FBBA          	   598:          JSR  VAL_MOVE
00:BCE0 4C92BC          	   599:          JMP  IDENT7
                        	   600: ;
00:BCE3 20BCBA          	   601: PAREN    JSR  GETEXPR
00:BCE6 4C05BA          	   602:          JMP  CHKRHP
                        	   603: ;
00:BCE9 A900            	   604: FACMEM   LDA  #0          ; add zero below to get PCODE_LDA
00:BCEB 854A            	   605:          STA  DATTYP
00:BCED F004            	   606:          BEQ  FACM2
00:BCEF A901            	   607: FACMMC   LDA  #1          ; add one below to get PCODE_LDAC
00:BCF1 854A            	   608:          STA  DATTYP
00:BCF3 A54A            	   609: FACM2    LDA  DATTYP
00:BCF5 48              	   610:          PHA
00:BCF6 200FBA          	   611:          JSR  GETSUB
00:BCF9 68              	   612:          PLA
00:BCFA 18              	   613:          CLC
00:BCFB 692E            	   614:          ADC  #PCODE_LDA    ; Load absolute address integer or PCODE_LDAC if we added 1
00:BCFD D008            	   615:          BNE  GENNOP1
                        	   616: ;
00:BCFF 20A0CE          	   617: FACNOT   JSR  pas_get_token
00:BD02 2028BC          	   618:          JSR  FACTOR
00:BD05 A920            	   619:          LDA  #PCODE_EOR     ; Not (sp) (logical negate)
00:BD07 4CC8C6          	   620: GENNOP1  JMP  GENNOP
                        	   621: ;
00:BD0A 20C8C6          	   622: FACRND1  JSR  GENNOP
00:BD0D 4CA0CE          	   623:          JMP  pas_get_token
                        	   624: ;
                        	   625: ;
                        	   626: ;
00:BD10 49              	   627: FACTB1   DFB    TOKEN_IDENTIFIER
00:BD11 39BC            	   628:          word   IDENT
00:BD13 4E              	   629:          ASC    TOKEN_NUMBER
00:BD14 DDBC            	   630:          word   FACNUM
00:BD16 22              	   631: FACTQT1  DFB    TOKEN_STRING        ; QUOTE SYMBOL
00:BD17 D2BC            	   632:          word   FACSTR
00:BD19 28              	   633:          ASC    '('
00:BD1A E3BC            	   634:          word   PAREN
00:BD1C 91              	   635:          DFB    TOKEN_MEM
00:BD1D E9BC            	   636:          word   FACMEM     ; MEM
00:BD1F 90              	   637:          DFB    TOKEN_NOT
00:BD20 FFBC            	   638:          word   FACNOT
00:BD22 A2              	   639:          DFB    TOKEN_MEMC
00:BD23 EFBC            	   640:          word   FACMMC     ; MEMC
00:BD25 A9              	   641:          DFB    TOKEN_ADDRESS
00:BD26 BFBC            	   642:          word   FACADR
00:BD28 00              	   643:          DFB  0
                        	   644: ;
                        	   645: ; EXPRESSION
                        	   646: ;
00:BD29 2024BB          	   647: EXPRES   JSR  CHK_STAK
00:BD2C 2068BB          	   648:          JSR  SIMEXP
00:BD2F A593            	   649:          LDA  token_type
00:BD31 A239            	   650:          LDX  #<EXPTB1
00:BD33 A0BD            	   651:          LDY  #>EXPTB1
00:BD35 20928F          	   652:          JSR  TKNJMP
00:BD38 60              	   653:          RTS
                        	   654: ;
00:BD39 3D              	   655: EXPTB1   ASC    '='
00:BD3A 4CBD            	   656:          word   EXPR1
00:BD3C 55              	   657:          DFB    TOKEN_NEQ
00:BD3D 4CBD            	   658:          word   EXPR1
00:BD3F 3C              	   659:          ASC    '<'
00:BD40 4CBD            	   660:          word   EXPR1
00:BD42 80              	   661:          DFB    TOKEN_LEQ
00:BD43 4CBD            	   662:          word   EXPR1
00:BD45 81              	   663:          DFB    TOKEN_GEQ
00:BD46 4CBD            	   664:          word   EXPR1
00:BD48 3E              	   665:          ASC    '>'
00:BD49 4CBD            	   666:          word   EXPR1
00:BD4B 00              	   667:          DFB  0
                        	   668: ;
00:BD4C 48              	   669: EXPR1    PHA
00:BD4D 20A0CE          	   670:          JSR  pas_get_token
00:BD50 2068BB          	   671:          JSR  SIMEXP
00:BD53 68              	   672:          PLA
00:BD54 A25B            	   673:          LDX  #<EXPTB3
00:BD56 A0BD            	   674:          LDY  #>EXPTB3
00:BD58 20928F          	   675:          JSR  TKNJMP
                        	   676: ;
00:BD5B 3D              	   677: EXPTB3   ASC    '='
00:BD5C 6EBD            	   678:          word   EXPR2
00:BD5E 55              	   679:          ASC    TOKEN_NEQ
00:BD5F 74BD            	   680:          word   EXPR3
00:BD61 3C              	   681:          ASC    '<'
00:BD62 78BD            	   682:          word   EXPR4
00:BD64 81              	   683:          DFB    TOKEN_GEQ
00:BD65 7CBD            	   684:          word   EXPR5
00:BD67 3E              	   685:          ASC    '>'
00:BD68 80BD            	   686:          word   EXPR6
00:BD6A 80              	   687:          DFB    TOKEN_LEQ
00:BD6B 84BD            	   688:          word   EXPR7
00:BD6D 00              	   689:          DFB  0
                        	   690: ;
00:BD6E A910            	   691: EXPR2    LDA  #PCODE_EQL       ; EQL     	Test (sp - 1) == (sp)
00:BD70 20C8C6          	   692: EXPR8    JSR  GENNOP
00:BD73 60              	   693:          RTS
00:BD74 A912            	   694: EXPR3    LDA  #PCODE_NEQ       ; NEQ     	Test (sp - 1) != (sp)
00:BD76 D0F8            	   695:          BNE  EXPR8
00:BD78 A914            	   696: EXPR4    LDA  #PCODE_LSS       ; LSS     	Test (sp - 1) < (sp)
00:BD7A D0F4            	   697:          BNE  EXPR8
00:BD7C A916            	   698: EXPR5    LDA  #PCODE_GEQ       ; GEQ     	Test (sp - 1) >= (sp)
00:BD7E D0F0            	   699:          BNE  EXPR8
00:BD80 A918            	   700: EXPR6    LDA  #PCODE_GTR       ; GTR     	Test (sp - 1) > (sp)
00:BD82 D0EC            	   701:          BNE  EXPR8
00:BD84 A919            	   702: EXPR7    LDA  #PCODE_LEQ       ; LEQ     	Test (sp - 1) <= (sp)
00:BD86 D0E8            	   703:          BNE  EXPR8
                        	   704: ;
                        	   705: ; STATEMENT
                        	   706: ;
00:BD88 2024BB          	   707: STMNT    JSR  CHK_STAK
00:BD8B A593            	   708:          LDA  token_type
00:BD8D A295            	   709:          LDX  #<STMNT1
00:BD8F A0BD            	   710:          LDY  #>STMNT1
00:BD91 20928F          	   711:          JSR  TKNJMP
00:BD94 60              	   712:          RTS
                        	   713: ;
00:BD95 49              	   714: STMNT1   DFB    TOKEN_IDENTIFIER
00:BD96 C0BD            	   715:          word   ASSIGN
00:BD98 92              	   716:          DFB    TOKEN_IF
00:BD99 30C0            	   717:          word   IF
00:BD9B 9A              	   718:          DFB    TOKEN_FOR
00:BD9C 97C1            	   719:          word   FOR
00:BD9E 96              	   720:          DFB    TOKEN_WHILE
00:BD9F AAC0            	   721:          word   WHILE
00:BDA1 95              	   722:          DFB    TOKEN_CASE
00:BDA2 DCC0            	   723:          word   CASE
00:BDA4 98              	   724:          DFB    TOKEN_REPEAT
00:BDA5 86C0            	   725:          word   REPEAT
00:BDA7 88              	   726:          DFB    TOKEN_BEGIN
00:BDA8 70C0            	   727:          word   BEG
00:BDAA 9E              	   728:          DFB    TOKEN_READ
00:BDAB D8BE            	   729:          word   READ
00:BDAD 9D              	   730:          DFB    TOKEN_WRITE
00:BDAE 36BE            	   731:          word   WRITE
00:BDB0 91              	   732:          DFB    TOKEN_MEM
00:BDB1 81BF            	   733:          word   MEM
00:BDB3 9F              	   734:          DFB    TOKEN_CALL
00:BDB4 9CBF            	   735:          word   CALLSB
00:BDB6 A2              	   736:          DFB    TOKEN_MEMC
00:BDB7 86BF            	   737:          word   MEMC
00:BDB9 FF              	   738:          DFB    TOKEN_WRITELN
00:BDBA 27BE            	   739:          word   WRITELN
00:BDBC F1              	   740:          DB     TOKEN_LCDWRITE
00:BDBD 87BE            	   741:          word   STMNT_WRITE_LCD
00:BDBF 00              	   742:          DFB  0
                        	   743: ;
                        	   744: ; ASSIGNMENT - this is where we store an integer/char into a variable or array index
                        	   745: ;
00:BDC0 2092B9          	   746: ASSIGN   JSR  LOOKUP
00:BDC3 A2CF            	   747: ASS1     LDX  #<ASSTB1
00:BDC5 A0BD            	   748:          LDY  #>ASSTB1
00:BDC7 20928F          	   749:          JSR  TKNJMP
00:BDCA A218            	   750:          LDX  #24     ; ERROR: Type mismatch
00:BDCC 4C6497          	   751:          jmp  ERROR
                        	   752: ;
00:BDCF 41              	   753: ASSTB1   DFB   SYMBOL_ARRAY
00:BDD0 EABD            	   754:          word  ASSARR
00:BDD2 56              	   755:          DFB   SYMBOL_VARIABLE
00:BDD3 FCBD            	   756:          word  ASSVAR
00:BDD5 59              	   757:          DFB   SYMBOL_FUNCTION_RETURN
00:BDD6 FCBD            	   758:          word  ASSVAR
00:BDD8 50              	   759:          DFB   SYMBOL_PROCEDURE
00:BDD9 A9BF            	   760:          word  FNCPRC
00:BDDB 51              	   761:          DFB   SYMBOL_LIBRARY_PROCEDURE
00:BDDC 78C6            	   762:          word  library_function_call
00:BDDE 46              	   763:          DFB   SYMBOL_FUNCTION
00:BDDF E5BD            	   764:          word  assign_bad_identifier
00:BDE1 52              	   765:          DFB   SYMBOL_LIBRARY_FUNCTION
00:BDE2 E5BD            	   766:          word  assign_bad_identifier
00:BDE4 00              	   767:          DFB  0
                        	   768: 
                        	   769: assign_bad_identifier:
00:BDE5 A235            	   770:           ldx #53   ; ERROR: Use of function identifier in statement
00:BDE7 4C6497          	   771:           jmp ERROR
                        	   772: ;
00:BDEA 2068BA          	   773: ASSARR   JSR  SYMWRK
00:BDED 205F92          	   774:          JSR  PSHWRK
00:BDF0 A936            	   775:          LDA  #PCODE_STI    ; Store integer indexed
00:BDF2 18              	   776:          CLC
00:BDF3 654A            	   777:          ADC  DATTYP        ; A becomes PCODE_STIC (Store character indexed) if DATTYP == 1
00:BDF5 48              	   778:          PHA
00:BDF6 200FBA          	   779:          JSR  GETSUB
00:BDF9 4C0BBE          	   780:          JMP  ASS2
                        	   781: ;
00:BDFC 2068BA          	   782: ASSVAR   JSR  SYMWRK
00:BDFF 205F92          	   783:          JSR  PSHWRK
00:BE02 A932            	   784:          LDA  #PCODE_STO    ;  Store integer
00:BE04 18              	   785:          CLC
00:BE05 654A            	   786:          ADC  DATTYP        ; A becomes PCODE_STOC (Store character indexed) if DATTYP == 1
00:BE07 48              	   787:          PHA
00:BE08 20A0CE          	   788:          JSR  pas_get_token
00:BE0B A941            	   789: ASS2     LDA  #TOKEN_ASSIGN
00:BE0D A20D            	   790:          LDX  #13       ; ERROR: := expected
00:BE0F 2004CF          	   791:          JSR  CHKTKN
00:BE12 20BCBA          	   792:          JSR  GETEXPR
00:BE15 68              	   793:          PLA
00:BE16 207292          	   794:          JSR  PULWRK
00:BE19 2073BA          	   795:          JSR  WRKSYM
00:BE1C 48              	   796:          PHA
00:BE1D 202CBA          	   797:          JSR  GET_LEV
00:BE20 2091BA          	   798:          JSR  GET_OFF
00:BE23 68              	   799:          PLA
00:BE24 4CE1C6          	   800:          JMP  GENADR
                        	   801: ;
                        	   802: 
                        	   803: ;
                        	   804: ;
                        	   805: ; WRITELN
                        	   806: ;
00:BE27 20A0CE          	   807: WRITELN  JSR  pas_get_token     ; SEE IF ( PRESENT
00:BE2A C928            	   808:          CMP  #'('
00:BE2C D003            	   809:          BNE  WRITELN9   ; NOPE
00:BE2E 2039BE          	   810:          JSR  WRIT9
                        	   811: WRITELN9 =  *
00:BE31 A940            	   812:          LDA  #PCODE_OUTCR   ; OUTPUT C/R
00:BE33 4CC8C6          	   813:          JMP  GENNOP
                        	   814: ;
                        	   815: ;
                        	   816: ; WRITE
                        	   817: ;
00:BE36 20FEB9          	   818: WRITE    JSR  CHKLHP
00:BE39 20A0CE          	   819: WRIT9    JSR  pas_get_token
00:BE3C C922            	   820:          CMP  #TOKEN_STRING
00:BE3E D022            	   821:          BNE  WRIT1
00:BE40 A923            	   822:          LDA  #PCODE_OUS    ; Output string
00:BE42 2048BE          	   823:          JSR  W_STRING
00:BE45 4C72BE          	   824:          JMP  WRIT5
                        	   825: ;
                        	   826: W_STRING =  *
00:BE48 20C8C6          	   827:          JSR  GENNOP
00:BE4B A592            	   828:          LDA  token_length
00:BE4D 20C8C6          	   829:          JSR  GENNOP
00:BE50 A000            	   830:          LDY  #0
00:BE52 B90002          	   831: WRIT2    LDA  INBUF,Y
00:BE55 C8              	   832: WRIT10   INY
00:BE56 5A              	   833:          phy
00:BE57 20C8C6          	   834:          JSR  GENNOP
00:BE5A 7A              	   835:          ply
00:BE5B C692            	   836:          DEC  token_length
00:BE5D D0F3            	   837:          BNE  WRIT2
00:BE5F 4CA0CE          	   838:          JMP  pas_get_token
                        	   839: ;
                        	   840: WRIT1    =  *          ; here if not string
00:BE62 C9AB            	   841:          CMP  #TOKEN_CHR       ; CHR?
00:BE64 F015            	   842:          BEQ  W_CHR      ; yes
00:BE66 C9AC            	   843:          CMP  #TOKEN_HEX       ; HEX?
00:BE68 F019            	   844:          BEQ  W_HEX      ; yes
00:BE6A 2029BD          	   845:          JSR  EXPRES     ; just ordinary number - get it
00:BE6D A91E            	   846:          LDA  #PCODE_OUT        ; OUT     	Output number
00:BE6F 20C8C6          	   847:          JSR  GENNOP
00:BE72 A593            	   848: WRIT5    LDA  token_type
00:BE74 C92C            	   849:          CMP  #','
00:BE76 F0C1            	   850:          BEQ  WRIT9
00:BE78 4C05BA          	   851:          JMP  CHKRHP
                        	   852: ;
                        	   853: ; here for write (chr(x))
                        	   854: ;
                        	   855: W_CHR    =  *
00:BE7B A91F            	   856:          LDA  #PCODE_OUTC   ; OUTC    	Output character
                        	   857: W_CHR1   =  *
00:BE7D 2077BF          	   858:          JSR  WAIT_1     ; process expression in parentheses
00:BE80 4C72BE          	   859:          JMP  WRIT5      ; back for next item
                        	   860: ;
                        	   861: ; here for write (hex(x))
                        	   862: ;
                        	   863: W_HEX    =  *
00:BE83 A921            	   864:          LDA  #PCODE_OUH        ; OUH     	Output hex number
00:BE85 D0F6            	   865:          BNE  W_CHR1
                        	   866: 
                        	   867: ;
                        	   868: ;
                        	   869: ; WRITELCD: can write number, string, hex or chr
                        	   870: ;
00:BE87 20FEB9          	   871: STMNT_WRITE_LCD    JSR  CHKLHP
00:BE8A 20A0CE          	   872: WRITE_LCD9    JSR  pas_get_token
00:BE8D C922            	   873:          CMP  #TOKEN_STRING
00:BE8F D022            	   874:          BNE  WRITE_LCD1
00:BE91 A943            	   875:          LDA  #PCODE_LCD_WRITE_STR    ; Output string
00:BE93 2099BE          	   876:          JSR  WRITE_LCD_STRING
00:BE96 4CC3BE          	   877:          JMP  WRITE_LCD5
                        	   878: ;
                        	   879: WRITE_LCD_STRING =  *
00:BE99 20C8C6          	   880:          JSR  GENNOP
00:BE9C A592            	   881:          LDA  token_length
00:BE9E 20C8C6          	   882:          JSR  GENNOP
00:BEA1 A000            	   883:          LDY  #0
00:BEA3 B90002          	   884: WRITE_LCD2    LDA  INBUF,Y    ; strings are placed in INBUF during parsing
00:BEA6 C8              	   885:          INY
00:BEA7 5A              	   886:          phy
00:BEA8 20C8C6          	   887:          JSR  GENNOP
00:BEAB 7A              	   888:          ply
00:BEAC C692            	   889:          DEC  token_length
00:BEAE D0F3            	   890:          BNE  WRITE_LCD2
00:BEB0 4CA0CE          	   891:          JMP  pas_get_token
                        	   892: ;
                        	   893: WRITE_LCD1    =  *            ; here if not string
00:BEB3 C9AB            	   894:          CMP  #TOKEN_CHR      ; CHR?
00:BEB5 F015            	   895:          BEQ  WRITE_LDC_CHR   ; yes
00:BEB7 C9AC            	   896:          CMP  #TOKEN_HEX      ; HEX?
00:BEB9 F019            	   897:          BEQ  WRITE_LDC_HEX   ; yes
00:BEBB 2029BD          	   898:          JSR  EXPRES          ; just ordinary number - get it
00:BEBE A942            	   899:          LDA  #PCODE_LCD_WRITE_NUM        ; OUT     	Output number
00:BEC0 20C8C6          	   900:          JSR  GENNOP
00:BEC3 A593            	   901: WRITE_LCD5    LDA  token_type
00:BEC5 C92C            	   902:          CMP  #','
00:BEC7 F0C1            	   903:          BEQ  WRITE_LCD9
00:BEC9 4C05BA          	   904:          JMP  CHKRHP
                        	   905: ;
                        	   906: ; here for lcdwrite (chr(x))
                        	   907: ;
                        	   908: WRITE_LDC_CHR    =  *
00:BECC A945            	   909:          LDA  #PCODE_LCD_WRITE_CHR   ; OUTC    	Output character
                        	   910: WRITE_LDC_CHR1   =  *
00:BECE 2077BF          	   911:          JSR  WAIT_1          ; process expression in parentheses
00:BED1 4CC3BE          	   912:          JMP  WRITE_LCD5      ; back for next item
                        	   913: ;
                        	   914: ; here for lcdwrite (hex(x))
                        	   915: ;
                        	   916: WRITE_LDC_HEX    =  *
00:BED4 A944            	   917:          LDA  #PCODE_LCD_WRITE_HEX        ; OUH     	Output hex number
00:BED6 D0F6            	   918:          BNE  WRITE_LDC_CHR1
                        	   919: 
                        	   920: ;
                        	   921: ;
                        	   922: ; READ
                        	   923: ;
00:BED8 20FEB9          	   924: READ     jsr  CHKLHP    ; check for "("
00:BEDB 2009CF          	   925: READ8    jsr  GET_LOOK
00:BEDE 2068BA          	   926: READ2    jsr  SYMWRK      ; SYMITM --> WORK
00:BEE1 205F92          	   927:          jsr  PSHWRK
00:BEE4 A200            	   928:          ldx  #0
00:BEE6 864B            	   929:          stx  COUNT1      ; this will have 1 in it if we are reading into an array element
00:BEE8 C941            	   930:          cmp  #SYMBOL_ARRAY
00:BEEA F03B            	   931:          beq  READ3
00:BEEC C956            	   932:          cmp  #SYMBOL_VARIABLE
00:BEEE F005            	   933:          beq  READ9
00:BEF0 A20C            	   934:          ldx  #12     ; ERROR: Illegal Identifier
00:BEF2 4C6497          	   935:          jmp  ERROR
                        	   936: 
00:BEF5 20F2C8          	   937: READ9    jsr get_token
00:BEF8 A91C            	   938: READ11   lda  #PCODE_INP  ; Input number
00:BEFA 18              	   939:          clc
00:BEFB 654A            	   940:          adc  DATTYP      ; becomes PCODE_INPC (input character) if DATTYP == 1
00:BEFD 20C8C6          	   941:          jsr  GENNOP
00:BF00 207292          	   942:          jsr  PULWRK
00:BF03 2073BA          	   943:          jsr  WRKSYM      ; WORK --> SYMITM
00:BF06 2036BA          	   944:          jsr  GET_DAT
00:BF09 202CBA          	   945:          jsr  GET_LEV
00:BF0C 2091BA          	   946:          jsr  GET_OFF
00:BF0F A932            	   947:          lda  #PCODE_STO    ; Store integer
00:BF11 A64B            	   948:          ldx  COUNT1
00:BF13 F002            	   949:          beq  READ7
00:BF15 A936            	   950:          lda  #PCODE_STI    ; Store integer indexed
00:BF17 18              	   951: READ7    clc
00:BF18 654A            	   952:          adc  DATTYP        ; add 1 if a char to become PCODE_STOC / PCODE_STIC
00:BF1A 20E1C6          	   953:          jsr  GENADR
00:BF1D A593            	   954: READ7_A  lda  token_type
00:BF1F C92C            	   955:          cmp  #','
00:BF21 F0B8            	   956:          beq  READ8         ; get another variable to read into
                        	   957: ;
                        	   958: ;  done with READ statement
                        	   959: ;
00:BF23 2005BA          	   960:          jsr  CHKRHP        ; check for ")"
00:BF26 60              	   961:          rts
                        	   962: ;
                        	   963: ;  here for reading into an array
                        	   964: ;
00:BF27 A54A            	   965: READ3    lda  DATTYP
00:BF29 48              	   966:          pha              ; push data type of array
00:BF2A 20A0CE          	   967:          jsr  pas_get_token
00:BF2D C95B            	   968:          cmp  #'['
00:BF2F F025            	   969:          beq  READ3_A
00:BF31 68              	   970:          pla            ; get back data type of array
00:BF32 854A            	   971:          sta  DATTYP    ; 0 = integer, 1 = char
00:BF34 D005            	   972:          bne  READ3_B
00:BF36 A218            	   973:          ldx  #24       ; ERROR: Type mismatch (cannot read into array of integer)
00:BF38 4C6497          	   974:          jmp  ERROR
00:BF3B 207292          	   975: READ3_B  jsr  PULWRK
00:BF3E 2073BA          	   976:          jsr  WRKSYM     ; WORK --> SYMITM
00:BF41 A925            	   977:          lda  #PCODE_INS        ; READ STRING - Input string into array
00:BF43 20C8C6          	   978:          jsr  GENNOP
00:BF46 202CBA          	   979:          jsr  GET_LEV
00:BF49 2091BA          	   980:          jsr  GET_OFF
00:BF4C A006            	   981:          ldy  #SYMSUB
00:BF4E B140            	   982:          lda  (SYMITM),Y  ; maximum array size
00:BF50 20E1C6          	   983:          jsr  GENADR     ; A = length, not the P-code which we just output above
00:BF53 4C1DBF          	   984:          jmp  READ7_A
                        	   985: ;
                        	   986: ;  read into subscripted item
                        	   987: ;
00:BF56 20BCBA          	   988: READ3_A  jsr  GETEXPR   ; subscript
00:BF59 2022BA          	   989:          jsr  CHKRHB    ; check for "]"
00:BF5C E64B            	   990:          inc  COUNT1    ; flag for reading into array element
00:BF5E 68              	   991:          pla            ; get back data type of array
00:BF5F 854A            	   992:          sta  DATTYP    ; save
00:BF61 4CF8BE          	   993:          jmp  READ11
                        	   994: ;
                        	   995: 
                        	   996: ;
                        	   997: ;
00:BF64 20FEB9          	   998: TWO_OP   JSR  CHKLHP
00:BF67 20BCBA          	   999:          JSR  GETEXPR
00:BF6A 20F5BA          	  1000: ONE_OP2  JSR  GET_ITEM
00:BF6D 2005BA          	  1001: ONE_OP   JSR  CHKRHP
00:BF70 68              	  1002:          PLA
00:BF71 4CC8C6          	  1003:          JMP  GENNOP
                        	  1004: 
                        	  1005: 
                        	  1006: 
00:BF74 4CC8C6          	  1007: GENNOP2  JMP  GENNOP
                        	  1008: ;
                        	  1009: 
00:BF77 48              	  1010: WAIT_1   PHA
00:BF78 20FEB9          	  1011:          JSR  CHKLHP
00:BF7B 20BCBA          	  1012:          JSR  GETEXPR
00:BF7E 4C6DBF          	  1013:          JMP  ONE_OP
                        	  1014: ;
                        	  1015: ; MEM
                        	  1016: ;
00:BF81 A900            	  1017: MEM      LDA  #0        ; integer
00:BF83 48              	  1018:          PHA
00:BF84 F003            	  1019:          BEQ  MEM2
00:BF86 A901            	  1020: MEMC     LDA  #1        ; character
00:BF88 48              	  1021:          PHA
00:BF89 200FBA          	  1022: MEM2     JSR  GETSUB
00:BF8C A941            	  1023:          LDA  #TOKEN_ASSIGN
00:BF8E A20D            	  1024:          LDX  #13     ; ERROR: := expected
00:BF90 2004CF          	  1025:          JSR  CHKTKN
00:BF93 20BCBA          	  1026:          JSR  GETEXPR
00:BF96 68              	  1027:          PLA
00:BF97 18              	  1028:          CLC
00:BF98 6934            	  1029:          ADC  #PCODE_STA     ; Store integer absolute address (or PCODE_STAC if A == 1)
00:BF9A D0D8            	  1030:          BNE  GENNOP2
                        	  1031: ;
                        	  1032: ; CALL ABSOLUTE ADDRESS
                        	  1033: ;
00:BF9C 20FEB9          	  1034: CALLSB   JSR  CHKLHP
00:BF9F 20BCBA          	  1035:          JSR  GETEXPR
00:BFA2 2005BA          	  1036:          JSR  CHKRHP
00:BFA5 A92B            	  1037:          LDA  #PCODE_CLA    ; Call absolute address
00:BFA7 D0CB            	  1038:          BNE  GENNOP2
                        	  1039: ;
                        	  1040: ; FUNCTION OR PROCEDURE CALL
                        	  1041: ;
00:BFA9 A900            	  1042: FNCPRC   LDA  #0
00:BFAB 854B            	  1043:          STA  COUNT1      ; number of arguments
00:BFAD A006            	  1044:          LDY  #SYMARG
00:BFAF B140            	  1045:          LDA  (SYMITM),Y
00:BFB1 F033            	  1046:          BEQ  FNC1
00:BFB3 20FEB9          	  1047:          JSR  CHKLHP
00:BFB6 A54B            	  1048: FNC2     LDA  COUNT1    ; save on stack in case the expression calls functions
00:BFB8 48              	  1049:          PHA
00:BFB9 2068BA          	  1050:          JSR  SYMWRK
00:BFBC 205F92          	  1051:          JSR  PSHWRK
00:BFBF 20BCBA          	  1052:          JSR  GETEXPR
00:BFC2 207292          	  1053:          JSR  PULWRK
00:BFC5 2073BA          	  1054:          JSR  WRKSYM
00:BFC8 68              	  1055:          PLA            ; get number of arguments back
00:BFC9 854B            	  1056:          STA  COUNT1
00:BFCB E64B            	  1057:          INC  COUNT1    ; add 1 for the one we just processed
00:BFCD A593            	  1058:          LDA  token_type
00:BFCF C92C            	  1059:          CMP  #','
00:BFD1 F0E3            	  1060:          BEQ  FNC2
00:BFD3 A54B            	  1061:          LDA  COUNT1
00:BFD5 A006            	  1062:          LDY  #SYMARG
00:BFD7 D140            	  1063:          CMP  (SYMITM),Y   ; check we got the right number of arguments
00:BFD9 F005            	  1064:          BEQ  FNC3
00:BFDB A223            	  1065:          LDX  #35     ; ERROR: Parameters mismatched
00:BFDD 4C6497          	  1066:          jmp  ERROR
00:BFE0 2005BA          	  1067: FNC3     JSR  CHKRHP
00:BFE3 4CE9BF          	  1068:          JMP  FNC5
00:BFE6 20A0CE          	  1069: FNC1     JSR  pas_get_token
00:BFE9 202CBA          	  1070: FNC5     JSR  GET_LEV
00:BFEC 2091BA          	  1071:          JSR  GET_OFF
00:BFEF A008            	  1072:          LDY  #SYMDAT
00:BFF1 B140            	  1073:          LDA  (SYMITM),Y
00:BFF3 D011            	  1074:          BNE  FNC5A
00:BFF5 A529            	  1075:          LDA  OFFSET
00:BFF7 38              	  1076:          SEC
00:BFF8 E523            	  1077:          SBC  PCODE         ; calculate relative procedure address
00:BFFA 8529            	  1078:          STA  OFFSET
00:BFFC A52A            	  1079:          LDA  OFFSET+1
00:BFFE E524            	  1080:          SBC  PCODE+1
00:C000 852A            	  1081:          STA  OFFSET+1
00:C002 A927            	  1082:          LDA  #PCODE_CLL         ; Relative procedure/function call
00:C004 D002            	  1083:          BNE  FNC5B
00:C006 A938            	  1084: FNC5A    LDA  #PCODE_ABSCLL      ; Absolute procedure/function call
00:C008 20E1C6          	  1085: FNC5B    JSR  GENADR
00:C00B A54B            	  1086:          LDA  COUNT1    ; number of arguments
00:C00D F01B            	  1087:          BEQ  FNC4
00:C00F A54B            	  1088:          LDA  COUNT1     ; TIMES 3
00:C011 0A              	  1089:          ASL             ; multiply by two then add one more COUNT1
00:C012 B017            	  1090:          BCS  FNC6
00:C014 654B            	  1091:          ADC  COUNT1
00:C016 854B            	  1092:          STA  COUNT1
00:C018 B011            	  1093:          BCS  FNC6
00:C01A A900            	  1094:          LDA  #0
00:C01C 38              	  1095:          SEC
00:C01D E54B            	  1096:          SBC  COUNT1
00:C01F 852B            	  1097:          STA  OPND
00:C021 A9FF            	  1098:          LDA  #$FF
00:C023 852C            	  1099:          STA  OPND+1      ;  calculate: 0 - (number_of_arguments * 3)
00:C025 A93B            	  1100:          LDA  #PCODE_INT     ; Increment stack pointer (allow for arguments)
00:C027 2051C7          	  1101:          JSR  GENJMP
00:C02A 60              	  1102: FNC4     RTS
00:C02B A20F            	  1103: FNC6     LDX  #15       ; ERROR: compiler limits exceeded
00:C02D 4C6497          	  1104:          jmp  ERROR
                        	  1105: ;
                        	  1106: ;
                        	  1107: ; IF
                        	  1108: ;
00:C030 20BCBA          	  1109: IF       JSR  GETEXPR
00:C033 A993            	  1110:          LDA  #TOKEN_THEN
00:C035 A210            	  1111:          LDX  #16     ; ERROR: THEN expected
00:C037 2004CF          	  1112:          JSR  CHKTKN
00:C03A 20A0CE          	  1113:          JSR  pas_get_token
00:C03D 207EBA          	  1114:          JSR  PSHPCODE
00:C040 A93D            	  1115:          LDA  #PCODE_JMZ     ; JMZ     	Jump if (sp) zero
00:C042 204BC7          	  1116:          JSR  GENNJM
00:C045 2088BD          	  1117:          JSR  STMNT
00:C048 A593            	  1118:          LDA  token_type
00:C04A C994            	  1119:          CMP  #TOKEN_ELSE       ; ELSE
00:C04C F007            	  1120:          BEQ  IF1
00:C04E 207292          	  1121: IF2      JSR  PULWRK
00:C051 207FC7          	  1122:          JSR  FIXAD
00:C054 60              	  1123:          RTS
00:C055 207292          	  1124: IF1      JSR  PULWRK     ; HERE FOR ELSE
00:C058 20E3BA          	  1125:          JSR  WRK_WRKD
00:C05B 207EBA          	  1126:          JSR  PSHPCODE
00:C05E 2049C7          	  1127:          JSR  GENNJP
00:C061 20D8BA          	  1128:          JSR  WRKD_WRK
00:C064 207FC7          	  1129:          JSR  FIXAD
00:C067 20A0CE          	  1130:          JSR  pas_get_token
00:C06A 2088BD          	  1131:          JSR  STMNT
00:C06D 4C4EC0          	  1132:          JMP  IF2
                        	  1133: ;
                        	  1134: ; BEGIN
                        	  1135: ;
00:C070 20A0CE          	  1136: BEG      JSR  pas_get_token
00:C073 2088BD          	  1137:          JSR  STMNT
00:C076 A593            	  1138:          LDA  token_type
00:C078 C93B            	  1139:          CMP  #';'
00:C07A F0F4            	  1140:          BEQ  BEG
00:C07C A989            	  1141:          LDA  #TOKEN_END       ; END
00:C07E A211            	  1142:          LDX  #17         ; ERROR: ; or END expected
00:C080 2004CF          	  1143:          JSR  CHKTKN
00:C083 4CA0CE          	  1144:          JMP  pas_get_token
                        	  1145: ;
                        	  1146: ; REPEAT
                        	  1147: ;
00:C086 207EBA          	  1148: REPEAT   JSR  PSHPCODE
00:C089 20A0CE          	  1149: REP1     JSR  pas_get_token
00:C08C 2088BD          	  1150:          JSR  STMNT
00:C08F A593            	  1151:          LDA  token_type
00:C091 C93B            	  1152:          CMP  #';'
00:C093 F0F4            	  1153:          BEQ  REP1
00:C095 A999            	  1154:          LDA  #TOKEN_UNTIL
00:C097 A20A            	  1155:          LDX  #10           ; ERROR: ; expected
00:C099 2004CF          	  1156:          JSR  CHKTKN
00:C09C 20BCBA          	  1157:          JSR  GETEXPR
00:C09F 207292          	  1158:          JSR  PULWRK
00:C0A2 20CDBA          	  1159:          JSR  WRK_OPND
00:C0A5 A93D            	  1160:          LDA  #PCODE_JMZ         ; JMZ     	Jump if (sp) zero
00:C0A7 4C37C7          	  1161:          JMP  GENRJMP
                        	  1162: ;
                        	  1163: ; WHILE
                        	  1164: ;
00:C0AA 207EBA          	  1165: WHILE    JSR  PSHPCODE
00:C0AD 20BCBA          	  1166:          JSR  GETEXPR
00:C0B0 207EBA          	  1167:          JSR  PSHPCODE
00:C0B3 A93D            	  1168:          LDA  #PCODE_JMZ       ; JMZ     	Jump if (sp) zero
00:C0B5 204BC7          	  1169:          JSR  GENNJM
00:C0B8 A997            	  1170:          LDA  #TOKEN_DO
00:C0BA A212            	  1171:          LDX  #18             ; ERROR: DO expected
00:C0BC 2004CF          	  1172:          JSR  CHKTKN
00:C0BF 20A0CE          	  1173:          JSR  pas_get_token
00:C0C2 2088BD          	  1174:          JSR  STMNT
00:C0C5 207292          	  1175:          JSR  PULWRK
00:C0C8 20E3BA          	  1176:          JSR  WRK_WRKD
00:C0CB 207292          	  1177:          JSR  PULWRK
00:C0CE 20CDBA          	  1178:          JSR  WRK_OPND
00:C0D1 A93C            	  1179:          LDA  #PCODE_JMP     ; JMP     	Jump unconditionally
00:C0D3 2037C7          	  1180:          JSR  GENRJMP
00:C0D6 20D8BA          	  1181:          JSR  WRKD_WRK
00:C0D9 4C7FC7          	  1182:          JMP  FIXAD
                        	  1183: ;
                        	  1184: ; CASE
                        	  1185: ;
00:C0DC 20BCBA          	  1186: CASE     JSR  GETEXPR
00:C0DF A985            	  1187:          LDA  #TOKEN_OF       ; OF
00:C0E1 A21A            	  1188:          LDX  #26         ; ERROR: "of " expected
00:C0E3 2004CF          	  1189:          JSR  CHKTKN
00:C0E6 A901            	  1190:          LDA  #1
00:C0E8 854B            	  1191:          STA  COUNT1
00:C0EA A900            	  1192: CASE7    LDA  #0
00:C0EC 854C            	  1193:          STA  COUNT2
                        	  1194: CASE2    =  *
00:C0EE A92A            	  1195:          LDA  #PCODE_MOV  ; make copy of selector:  MOV     	Copy (sp) to (sp + 1)
00:C0F0 20C8C6          	  1196:          JSR  GENNOP
00:C0F3 20BCBA          	  1197:          JSR  GETEXPR    ; next expression to compare
00:C0F6 A910            	  1198:          LDA  #PCODE_EQL       ;  EQL     	Test (sp - 1) == (sp)
00:C0F8 20C8C6          	  1199:          JSR  GENNOP
00:C0FB A593            	  1200:          LDA  token_type
00:C0FD C93A            	  1201:          CMP  #':'
00:C0FF F014            	  1202:          BEQ  CASE1
00:C101 A92C            	  1203:          LDA  #','
00:C103 A205            	  1204:          LDX  #5      ; ERROR: , or : expected
00:C105 2004CF          	  1205:          JSR  CHKTKN
00:C108 207EBA          	  1206:          JSR  PSHPCODE
00:C10B A93E            	  1207:          LDA  #PCODE_JM1     ; JM1     	Jump if (sp) not zero
00:C10D 204BC7          	  1208:          JSR  GENNJM
00:C110 E64C            	  1209:          INC  COUNT2
00:C112 4CEEC0          	  1210:          JMP  CASE2
00:C115 20C2BA          	  1211: CASE1    JSR  PCD_WRKD
00:C118 A93D            	  1212:          LDA  #PCODE_JMZ     ; JMZ     	Jump if (sp) zero
00:C11A 204BC7          	  1213:          JSR  GENNJM
00:C11D A54C            	  1214:          LDA  COUNT2
00:C11F F00A            	  1215:          BEQ  CASE3
00:C121 207292          	  1216: CASE4    JSR  PULWRK
00:C124 207FC7          	  1217:          JSR  FIXAD
00:C127 C64C            	  1218:          DEC  COUNT2
00:C129 D0F6            	  1219:          BNE  CASE4
00:C12B 20D8BA          	  1220: CASE3    JSR  WRKD_WRK
00:C12E 205F92          	  1221:          JSR  PSHWRK
00:C131 20A0CE          	  1222:          JSR  pas_get_token
00:C134 A54B            	  1223:          LDA  COUNT1
00:C136 48              	  1224:          PHA
00:C137 2088BD          	  1225:          JSR  STMNT
00:C13A 68              	  1226:          PLA
00:C13B 854B            	  1227:          STA  COUNT1
00:C13D A593            	  1228:          LDA  token_type
00:C13F C994            	  1229:          CMP  #TOKEN_ELSE       ; ELSE
00:C141 F01B            	  1230:          BEQ  CASE5
00:C143 C93B            	  1231:          CMP  #';'
00:C145 D035            	  1232:          BNE  CASE6
00:C147 20C2BA          	  1233:          JSR  PCD_WRKD
00:C14A 2049C7          	  1234:          JSR  GENNJP
00:C14D 207292          	  1235:          JSR  PULWRK
00:C150 207FC7          	  1236:          JSR  FIXAD
00:C153 20D8BA          	  1237:          JSR  WRKD_WRK
00:C156 205F92          	  1238:          JSR  PSHWRK
00:C159 E64B            	  1239:          INC  COUNT1
00:C15B 4CEAC0          	  1240:          JMP  CASE7
00:C15E 20C2BA          	  1241: CASE5    JSR  PCD_WRKD
00:C161 2049C7          	  1242:          JSR  GENNJP
00:C164 207292          	  1243:          JSR  PULWRK
00:C167 207FC7          	  1244:          JSR  FIXAD
00:C16A 20D8BA          	  1245:          JSR  WRKD_WRK
00:C16D 205F92          	  1246:          JSR  PSHWRK
00:C170 20A0CE          	  1247:          JSR  pas_get_token
00:C173 A54B            	  1248:          LDA  COUNT1
00:C175 48              	  1249:          PHA
00:C176 2088BD          	  1250:          JSR  STMNT
00:C179 68              	  1251:          PLA
00:C17A 854B            	  1252:          STA  COUNT1
00:C17C A989            	  1253: CASE6    LDA  #TOKEN_END       ; END
00:C17E A211            	  1254:          LDX  #17         ; ERROR: ; or END expected
00:C180 2004CF          	  1255:          JSR  CHKTKN
00:C183 A54B            	  1256:          LDA  COUNT1
00:C185 F00A            	  1257:          BEQ  CASE8
00:C187 207292          	  1258: CASE9    JSR  PULWRK
00:C18A 207FC7          	  1259:          JSR  FIXAD
00:C18D C64B            	  1260:          DEC  COUNT1
00:C18F D0F6            	  1261:          BNE  CASE9
00:C191 205DC2          	  1262: CASE8    JSR  FOR6
00:C194 4CA0CE          	  1263:          JMP  pas_get_token
                        	  1264: ;
                        	  1265: ; FOR
                        	  1266: ;
00:C197 A949            	  1267: FOR      LDA  #TOKEN_IDENTIFIER
00:C199 A204            	  1268:          LDX  #4      ; ERROR:  Identifier expected
00:C19B 20F4CE          	  1269:          JSR  GETCHK
00:C19E 2092B9          	  1270:          JSR  LOOKUP
00:C1A1 C956            	  1271: FOR1     CMP  #SYMBOL_VARIABLE
00:C1A3 F009            	  1272:          BEQ  FOR2
00:C1A5 C959            	  1273:          CMP  #SYMBOL_FUNCTION_RETURN
00:C1A7 F005            	  1274:          BEQ  FOR2
00:C1A9 A20C            	  1275:          LDX  #12   ; ERROR: Illegal Identifier
00:C1AB 4C6497          	  1276:          jmp  ERROR
00:C1AE 20FCBD          	  1277: FOR2     JSR  ASSVAR
00:C1B1 2068BA          	  1278:          JSR  SYMWRK
00:C1B4 A900            	  1279:          LDA  #0
00:C1B6 854B            	  1280:          STA  COUNT1
00:C1B8 A593            	  1281:          LDA  token_type
00:C1BA C99B            	  1282:          CMP  #TOKEN_TO       ; TO
00:C1BC F009            	  1283:          BEQ  FOR3
00:C1BE A99C            	  1284:          LDA  #TOKEN_DOWNTO       ; DOWNTO
00:C1C0 A21C            	  1285:          LDX  #28       ; ERROR: TO or DOWNTO expected
00:C1C2 2004CF          	  1286:          JSR  CHKTKN
00:C1C5 C64B            	  1287:          DEC  COUNT1
00:C1C7 A54B            	  1288: FOR3     LDA  COUNT1
00:C1C9 48              	  1289:          PHA
00:C1CA 205F92          	  1290:          JSR  PSHWRK
00:C1CD 20BCBA          	  1291:          JSR  GETEXPR
00:C1D0 207292          	  1292:          JSR  PULWRK
00:C1D3 2073BA          	  1293:          JSR  WRKSYM
00:C1D6 68              	  1294:          PLA
00:C1D7 854B            	  1295:          STA  COUNT1
00:C1D9 207EBA          	  1296:          JSR  PSHPCODE
00:C1DC A92A            	  1297:          LDA  #PCODE_MOV     ; MOV     	Copy (sp) to (sp + 1)
00:C1DE 20C8C6          	  1298:          JSR  GENNOP
00:C1E1 202CBA          	  1299:          JSR  GET_LEV
00:C1E4 2091BA          	  1300:          JSR  GET_OFF
00:C1E7 2036BA          	  1301:          JSR  GET_DAT
00:C1EA 18              	  1302:          CLC
00:C1EB 692C            	  1303:          ADC  #PCODE_LOD  ; Load integer onto stack or PCODE_LODC if a char
00:C1ED 20E1C6          	  1304:          JSR  GENADR
00:C1F0 A916            	  1305:          LDA  #PCODE_GEQ        ; UP (GEQ): GEQ     	Test (sp - 1) >= (sp)
00:C1F2 A64B            	  1306:          LDX  COUNT1
00:C1F4 F002            	  1307:          BEQ  FOR4
00:C1F6 A919            	  1308:          LDA  #PCODE_LEQ        ; DOWN (LEQ): LEQ     	Test (sp - 1) <= (sp)
00:C1F8 20C8C6          	  1309: FOR4     JSR  GENNOP
00:C1FB 207EBA          	  1310:          JSR  PSHPCODE
00:C1FE A93D            	  1311:          LDA  #PCODE_JMZ       ;  JMZ     	Jump if (sp) zero
00:C200 204BC7          	  1312:          JSR  GENNJM
00:C203 A54B            	  1313:          LDA  COUNT1
00:C205 48              	  1314:          PHA
00:C206 2068BA          	  1315:          JSR  SYMWRK
00:C209 205F92          	  1316:          JSR  PSHWRK
00:C20C A997            	  1317:          LDA  #TOKEN_DO
00:C20E A212            	  1318:          LDX  #18       ; ERROR: DO expected
00:C210 2004CF          	  1319:          JSR  CHKTKN
00:C213 20A0CE          	  1320:          JSR  pas_get_token
00:C216 2088BD          	  1321:          JSR  STMNT
00:C219 207292          	  1322:          JSR  PULWRK
00:C21C 2073BA          	  1323:          JSR  WRKSYM
00:C21F 202CBA          	  1324:          JSR  GET_LEV
00:C222 2036BA          	  1325:          JSR  GET_DAT
00:C225 2091BA          	  1326:          JSR  GET_OFF
00:C228 A54A            	  1327:          LDA  DATTYP
00:C22A 18              	  1328:          CLC
00:C22B 692C            	  1329:          ADC  #PCODE_LOD       ; LOD     	Load integer onto stack
00:C22D 20E1C6          	  1330:          JSR  GENADR
00:C230 68              	  1331:          PLA
00:C231 854B            	  1332:          STA  COUNT1
00:C233 A926            	  1333:          LDA  #PCODE_INC     ; INC     	Increment (sp) by 1
00:C235 A64B            	  1334:          LDX  COUNT1
00:C237 F002            	  1335:          BEQ  FOR5
00:C239 A928            	  1336:          LDA  #PCODE_DEC        ; DEC     	Decrement (sp) by 1
00:C23B 20C8C6          	  1337: FOR5     JSR  GENNOP
00:C23E A932            	  1338:          LDA  #PCODE_STO       ; STO     	Store integer
00:C240 18              	  1339:          CLC
00:C241 654A            	  1340:          ADC  DATTYP          ; may become PCODE_STOC if a char
00:C243 20E1C6          	  1341:          JSR  GENADR
00:C246 207292          	  1342:          JSR  PULWRK
00:C249 20E3BA          	  1343:          JSR  WRK_WRKD
00:C24C 207292          	  1344:          JSR  PULWRK
00:C24F 20CDBA          	  1345:          JSR  WRK_OPND
00:C252 A93C            	  1346:          LDA  #PCODE_JMP       ; JMP     	Jump unconditionally
00:C254 2037C7          	  1347:          JSR  GENRJMP
00:C257 20D8BA          	  1348:          JSR  WRKD_WRK
00:C25A 207FC7          	  1349:          JSR  FIXAD
00:C25D A9FF            	  1350: FOR6     LDA  #$FF
00:C25F 852C            	  1351:          STA  OPND+1
00:C261 A9FD            	  1352:          LDA  #$FD
00:C263 852B            	  1353:          STA  OPND
00:C265 A93B            	  1354:          LDA  #PCODE_INT       ;  INT     	Increment stack pointer
00:C267 4C51C7          	  1355:          JMP  GENJMP
                        	  1356: 
                        	  1357: 
                        	  1358: ;***********************************************
                        	  1359: ; MORE OF THE COMPILER (PROCESSING A 'BLOCK')
                        	  1360: ;***********************************************
                        	  1361: 
                        	  1362: CHKGET   =  *
00:C26A 2004CF          	  1363:          JSR  CHKTKN
00:C26D 4CA0CE          	  1364:          JMP  pas_get_token
                        	  1365: ;
                        	  1366: ;  copy WORK to token_value
                        	  1367: ;
                        	  1368: WRK_VAL  =  *
00:C270 48              	  1369:          PHA
00:C271 A537            	  1370:          LDA  WORK
00:C273 8594            	  1371:          STA  token_value
00:C275 A538            	  1372:          LDA  WORK+1
00:C277 8595            	  1373:          STA  token_value+1
00:C279 68              	  1374:          PLA
00:C27A 60              	  1375:          RTS
                        	  1376: ;
                        	  1377: ;  copy VALUE to WORK
                        	  1378: ;
                        	  1379: VAL_WRK  =  *
00:C27B 48              	  1380:          PHA
00:C27C A594            	  1381:          LDA  token_value
00:C27E 8537            	  1382:          STA  WORK
00:C280 A595            	  1383:          LDA  token_value+1
00:C282 8538            	  1384:          STA  WORK+1
00:C284 68              	  1385:          PLA
00:C285 60              	  1386:          RTS
                        	  1387: ;
                        	  1388: ;  copy ENDSYM to WORK
                        	  1389: ;
                        	  1390: END_WRK  =  *
00:C286 48              	  1391:          PHA
00:C287 A531            	  1392:          LDA  ENDSYM
00:C289 8537            	  1393:          STA  WORK
00:C28B A532            	  1394:          LDA  ENDSYM+1
00:C28D 8538            	  1395:          STA  WORK+1
00:C28F 68              	  1396:          PLA
00:C290 60              	  1397:          RTS
                        	  1398: ;
                        	  1399: ;***********************************************
                        	  1400: ;
                        	  1401: ;
                        	  1402: ; BLOCK
                        	  1403: ;
00:C291 82              	  1404: BLCKT1   DFB  TOKEN_CONST
00:C292 E8C2            	  1405:          word BLKCNS
00:C294 83              	  1406: BLCKT2   DFB  TOKEN_VAR
00:C295 FFC2            	  1407:          word BLKVAR
00:C297 86              	  1408: BLCKT3   DFB  TOKEN_PROCEDURE
00:C298 3CC4            	  1409:          word BLKPRC
00:C29A 87              	  1410:          DFB  TOKEN_FUNCTION
00:C29B 5CC4            	  1411:          word BLKFNC
00:C29D 88              	  1412:          DFB  TOKEN_BEGIN
00:C29E 24C5            	  1413:          word BLKBEG
00:C2A0 00              	  1414:          DFB  0
                        	  1415: ;
                        	  1416: ;
00:C2A1 2024BB          	  1417: BLOCK    JSR  CHK_STAK
00:C2A4 A900            	  1418:          LDA  #0
00:C2A6 8521            	  1419:          STA  FRAME+1
00:C2A8 A906            	  1420:          LDA  #6
00:C2AA 8520            	  1421:          STA  FRAME
00:C2AC A539            	  1422:          LDA  PRCITM
00:C2AE 8537            	  1423:          STA  WORK
00:C2B0 A63A            	  1424:          LDX  PRCITM+1
00:C2B2 8638            	  1425:          STX  WORK+1
00:C2B4 053A            	  1426:          ORA  PRCITM+1
00:C2B6 F014            	  1427:          BEQ  BLK1
                        	  1428: 
                        	  1429: ;
00:C2B8 A004            	  1430: BLK1A    LDY  #SYMDSP
00:C2BA A523            	  1431:          LDA  PCODE
00:C2BC 9137            	  1432:          STA  (WORK),Y
00:C2BE C8              	  1433:          INY
00:C2BF A524            	  1434:          LDA  PCODE+1
00:C2C1 9137            	  1435:          STA  (WORK),Y
00:C2C3 A900            	  1436:          LDA  #0
00:C2C5 A008            	  1437:          LDY  #SYMDAT
00:C2C7 9137            	  1438:          STA  (WORK),Y   ; FLAG RELATIVE PROCEDURE
00:C2C9 4CD4C2          	  1439:          JMP  BLK2
00:C2CC A523            	  1440: BLK1     LDA  PCODE
00:C2CE 8537            	  1441:          STA  WORK
00:C2D0 A524            	  1442:          LDA  PCODE+1
00:C2D2 8538            	  1443:          STA  WORK+1
00:C2D4 205F92          	  1444: BLK2     JSR  PSHWRK
00:C2D7 2049C7          	  1445:          JSR  GENNJP
00:C2DA A291            	  1446:          LDX  #<BLCKT1
00:C2DC A0C2            	  1447:          LDY  #>BLCKT1
00:C2DE A593            	  1448: BLK4     LDA  token_type
00:C2E0 20928F          	  1449:          JSR  TKNJMP
00:C2E3 A219            	  1450:          LDX  #25       ; ERROR: BEGIN expected
00:C2E5 4C6497          	  1451:          jmp  ERROR
                        	  1452: ;
                        	  1453: ;
                        	  1454: ; CONSTANT
                        	  1455: ;
00:C2E8 20A0CE          	  1456: BLKCNS   JSR  pas_get_token
00:C2EB 203DBA          	  1457: BLKCN1   JSR  CONDEC
00:C2EE A93B            	  1458:          LDA  #';'
00:C2F0 A20A            	  1459:          LDX  #10       ; ERROR: ; expected
00:C2F2 206AC2          	  1460:          JSR  CHKGET
00:C2F5 A294            	  1461:          LDX  #<BLCKT2
00:C2F7 A0C2            	  1462:          LDY  #>BLCKT2
00:C2F9 20928F          	  1463:          JSR  TKNJMP
00:C2FC 4CEBC2          	  1464:          JMP  BLKCN1
                        	  1465: ;
                        	  1466: ; VARIABLE
                        	  1467: ;
00:C2FF A900            	  1468: BLKVAR   LDA  #0
00:C301 854B            	  1469:          STA  COUNT1
00:C303 20A0CE          	  1470: BLKVR1   JSR  pas_get_token
00:C306 2056BB          	  1471: BLKVR6   JSR  VARDEC    ; check we have an identifier, add it to the symbol table, get another token
00:C309 E64B            	  1472:          INC  COUNT1    ; how many variables in this declaration
00:C30B 1003            	  1473:          BPL  BLKVR7
00:C30D 4C7DC3          	  1474:          JMP  BLKV13     ; ERROR  - compiler limits exceeded (more than 127 variables?)
00:C310 A593            	  1475: BLKVR7   LDA  token_type
00:C312 C92C            	  1476:          CMP  #','
00:C314 F0ED            	  1477:          BEQ  BLKVR1    ; back for another
00:C316 A93A            	  1478:          LDA  #':'
00:C318 A205            	  1479:          LDX  #5        ; ERROR: , or : expected
00:C31A 206AC2          	  1480:          JSR  CHKGET
00:C31D C984            	  1481:          CMP  #TOKEN_ARRAY   ; ARRAY
00:C31F F043            	  1482:          BEQ  BLKVR2
00:C321 C9FE            	  1483:          CMP  #TOKEN_INTEGER ; INTEGER
00:C323 F00A            	  1484:          BEQ  BLKVR8
00:C325 A9A1            	  1485:          LDA  #TOKEN_CHAR    ; CHAR
00:C327 A224            	  1486:          LDX  #36            ; ERROR: Data Type not recognised
00:C329 2004CF          	  1487:          JSR  CHKTKN
00:C32C 4C24C4          	  1488:          JMP  BLKVR3
                        	  1489: 
                        	  1490: ;
                        	  1491: ;  integer variable
                        	  1492: ;
00:C32F 20C9C3          	  1493: BLKVR8   JSR  BLKVR9  ; subtract COUNT1 from FRAME, put WORK into VALUE, put ENDSYM into WORK
                        	  1494: BLKV10   = *
00:C332 A008            	  1495:          LDY  #SYMDAT
00:C334 A900            	  1496:          LDA  #0         ; INTEGER TYPE
00:C336 9137            	  1497:          STA  (WORK),Y
00:C338 A520            	  1498:          LDA  FRAME
00:C33A A004            	  1499:          LDY  #SYMDSP
00:C33C 9137            	  1500:          STA  (WORK),Y
00:C33E C8              	  1501:          INY
00:C33F A521            	  1502:          LDA  FRAME+1
00:C341 9137            	  1503:          STA  (WORK),Y
00:C343 18              	  1504:          CLC
00:C344 A520            	  1505:          LDA  FRAME
00:C346 6903            	  1506:          ADC  #3
00:C348 8520            	  1507:          STA  FRAME
00:C34A 9002            	  1508:          BCC  BLKV10_A
00:C34C E621            	  1509:          INC  FRAME+1
                        	  1510: BLKV10_A =  *
00:C34E C64B            	  1511:          DEC  COUNT1
00:C350 D003            	  1512:          BNE  BLKV10_B
00:C352 4C24C4          	  1513:          JMP  BLKVR3
                        	  1514: 
                        	  1515: BLKV10_B = *
                        	  1516: ;
                        	  1517: ;  more in the list, go to the previous symbol
                        	  1518: ;
00:C355 A000            	  1519:          LDY  #SYMPRV
00:C357 B137            	  1520:          LDA  (WORK),Y
00:C359 AA              	  1521:          TAX
00:C35A C8              	  1522:          INY
00:C35B B137            	  1523:          LDA  (WORK),Y
00:C35D 8538            	  1524:          STA  WORK+1
00:C35F 8A              	  1525:          TXA
00:C360 8537            	  1526:          STA  WORK       ; PREVIOUS ITEM
00:C362 80CE            	  1527:          BRA  BLKV10
                        	  1528: 
                        	  1529: ;
                        	  1530: ; ARRAY [ N ] OF ...
                        	  1531: ;
00:C364 2018BA          	  1532: BLKVR2   JSR  CHKLHB
00:C367 2030BB          	  1533:          JSR  CONST     ; get how many are in the array
00:C36A A596            	  1534:          LDA  token_value+2   ; can't be more than 65536
00:C36C D00F            	  1535:          BNE  BLKV13
00:C36E A594            	  1536:          LDA  token_value     ; add 1 to the count since array [3] of char means 4 elements
00:C370 18              	  1537:          CLC
00:C371 6901            	  1538:          ADC  #1
00:C373 8594            	  1539:          STA  token_value
00:C375 A595            	  1540:          LDA  token_value+1
00:C377 3004            	  1541:          BMI  BLKV13
00:C379 6900            	  1542:          ADC  #0
00:C37B 1005            	  1543:          BPL  BLKVR4
00:C37D A20F            	  1544: BLKV13   LDX  #15       ; ERROR: compiler limits exceeded
00:C37F 4C6497          	  1545:          jmp  ERROR
00:C382 8595            	  1546: BLKVR4   STA  token_value+1
00:C384 207BC2          	  1547:          JSR  VAL_WRK   ; put the value (array count) in WORK
00:C387 20A0CE          	  1548:          JSR  pas_get_token
00:C38A 2022BA          	  1549:          JSR  CHKRHB
00:C38D A901            	  1550:          LDA  #1        ; char
00:C38F 854A            	  1551:          STA  DATTYP
00:C391 A985            	  1552:          LDA  #TOKEN_OF  ; OF
00:C393 A21A            	  1553:          LDX  #26        ; ERROR: "of " expected
00:C395 206AC2          	  1554:          JSR  CHKGET
00:C398 C9FE            	  1555:          CMP  #TOKEN_INTEGER  ; INTEGER
00:C39A D020            	  1556:          BNE  BLKV11
00:C39C C64A            	  1557:          DEC  DATTYP    ; DATTYP of 0 is integer, and 1 is char
00:C39E 2070C2          	  1558:          JSR  WRK_VAL   ; get the array count back into token_value
                        	  1559: ;
                        	  1560: ; MULTIPLY token_value BY 3
                        	  1561: ;
00:C3A1 A594            	  1562:          LDA  token_value
00:C3A3 A695            	  1563:          LDX  token_value+1
00:C3A5 0694            	  1564:          ASL  token_value
00:C3A7 2695            	  1565:          ROL  token_value+1
00:C3A9 B0D2            	  1566:          BCS  BLKV13
00:C3AB 6594            	  1567:          ADC  token_value
00:C3AD 8594            	  1568:          STA  token_value
00:C3AF 8A              	  1569:          TXA
00:C3B0 6595            	  1570:          ADC  token_value+1
00:C3B2 B0C9            	  1571:          BCS  BLKV13
00:C3B4 8595            	  1572:          STA  token_value+1
00:C3B6 207BC2          	  1573:          JSR  VAL_WRK     ; put the array count (times 3) back into WORK
00:C3B9 4CC3C3          	  1574:          JMP  BLKV12
                        	  1575:  ;
                        	  1576:  ;  here for array of char
                        	  1577:  ;
00:C3BC A9A1            	  1578: BLKV11   LDA  #TOKEN_CHAR       ; CHAR
00:C3BE A224            	  1579:          LDX  #36           ; ERROR: Data Type not recognised
00:C3C0 2004CF          	  1580:          JSR  CHKTKN
00:C3C3 20C9C3          	  1581: BLKV12   JSR  BLKVR9        ; we are COUNT1 frames back
00:C3C6 4CE2C3          	  1582:          JMP  BLKVR5
                        	  1583: 
                        	  1584: BLKVR9   =  *
00:C3C9 A520            	  1585:          LDA  FRAME         ; subtract COUNT1 (the variable position) from the frame number
00:C3CB 38              	  1586:          SEC
00:C3CC E54B            	  1587:          SBC  COUNT1
00:C3CE 8520            	  1588:          STA  FRAME
00:C3D0 A521            	  1589:          LDA  FRAME+1
00:C3D2 E900            	  1590:          SBC  #0
00:C3D4 8521            	  1591:          STA  FRAME+1
00:C3D6 2070C2          	  1592:          JSR  WRK_VAL     ; copy WORK to VALUE (array count, possibly multiplied by 3)
00:C3D9 A531            	  1593:          LDA  ENDSYM      ; end of symbol table into WORK
00:C3DB 8537            	  1594:          STA  WORK
00:C3DD A532            	  1595:          LDA  ENDSYM+1
00:C3DF 8538            	  1596:          STA  WORK+1
00:C3E1 60              	  1597:          RTS
                        	  1598: 
                        	  1599: ;
                        	  1600: ;  we should be here with ENDSYM in WORK (for walking back through the symbol table for all the variables we just decla
                        	  1601: ;  COUNT1 will be the number of symbols we have to fix up
                        	  1602: ;
                        	  1603: BLKVR5   = *
00:C3E2 A003            	  1604:          ldy  #SYMTYP
00:C3E4 A941            	  1605:          lda  #SYMBOL_ARRAY
00:C3E6 9137            	  1606:          sta  (WORK),Y    ; make symbol type array
00:C3E8 A004            	  1607:          ldy  #SYMDSP
00:C3EA A520            	  1608:          lda  FRAME       ; FRAME is the displacement
00:C3EC 9137            	  1609:          sta  (WORK),Y
00:C3EE C8              	  1610:          iny
00:C3EF A521            	  1611:          lda  FRAME+1
00:C3F1 9137            	  1612:          sta  (WORK),Y
00:C3F3 A594            	  1613:          lda  token_value       ; array count (multiplied by 3 in the case of integers)
00:C3F5 18              	  1614:          clc
00:C3F6 6520            	  1615:          adc  FRAME       ; add to the stack frame address
00:C3F8 8520            	  1616:          sta  FRAME
00:C3FA A595            	  1617:          lda  token_value+1
00:C3FC 6521            	  1618:          adc  FRAME+1
00:C3FE 8521            	  1619:          sta  FRAME+1
00:C400 A008            	  1620:          ldy  #SYMDAT
00:C402 A54A            	  1621:          lda  DATTYP       ; save the data type in the symbol
00:C404 9137            	  1622:          sta  (WORK),Y
00:C406 A006            	  1623:          ldy  #SYMSUB
00:C408 A594            	  1624:          lda  token_value        ; max subscript + 1
00:C40A 9137            	  1625:          sta  (WORK),Y
00:C40C A595            	  1626:          lda  token_value+1
00:C40E C8              	  1627:          iny
00:C40F 9137            	  1628:          sta  (WORK),Y
00:C411 C64B            	  1629:          dec  COUNT1
00:C413 F00F            	  1630:          beq  BLKVR3
                        	  1631: ;
                        	  1632: ;  onto the previous symbol
                        	  1633: ;
00:C415 A000            	  1634:          ldy  #SYMPRV
00:C417 B137            	  1635:          lda  (WORK),Y
00:C419 AA              	  1636:          tax
00:C41A C8              	  1637:          iny
00:C41B B137            	  1638:          lda  (WORK),Y
00:C41D 8538            	  1639:          sta  WORK+1
00:C41F 8A              	  1640:          txa
00:C420 8537            	  1641:          sta  WORK       ; PREVIOUS ITEM
00:C422 80BE            	  1642:          bra  BLKVR5
                        	  1643: ;
                        	  1644: ;  here at end of variable declaration (after INTEGER / CHAR)
                        	  1645: ;
00:C424 A93B            	  1646: BLKVR3   LDA  #';'
00:C426 A20A            	  1647:          LDX  #10       ; ERROR: ; expected
00:C428 20F4CE          	  1648:          JSR  GETCHK
00:C42B 20A0CE          	  1649:          JSR  pas_get_token
00:C42E A297            	  1650:          LDX  #<BLCKT3  ; now look for procedure / function / begin
00:C430 A0C2            	  1651:          LDY  #>BLCKT3
00:C432 20928F          	  1652:          JSR  TKNJMP    ; if not there, look for another variable declaration
00:C435 A900            	  1653:          LDA  #0        ; zero variables in this list so far
00:C437 854B            	  1654:          STA  COUNT1
00:C439 4C06C3          	  1655:          JMP  BLKVR6
                        	  1656: ;
                        	  1657: ; PROCEDURE DECLARATION
                        	  1658: ;
00:C43C A949            	  1659: BLKPRC   LDA  #'I'
00:C43E A204            	  1660:          LDX  #4         ; ERROR: Identifier expected
00:C440 20F4CE          	  1661:          JSR  GETCHK
00:C443 A900            	  1662:          LDA  #0
00:C445 854B            	  1663:          STA  COUNT1    ; no function return value
00:C447 209DB9          	  1664:          JSR  CHKDUP
00:C44A A950            	  1665:          LDA  #SYMBOL_PROCEDURE
00:C44C 20F6B8          	  1666:          JSR  ADDSYM
00:C44F E622            	  1667:          INC  LEVEL
00:C451 A540            	  1668:          LDA  SYMITM
00:C453 8539            	  1669:          STA  PRCITM    ; PRCITM is the symbol of the procedure/function
00:C455 A541            	  1670:          LDA  SYMITM+1
00:C457 853A            	  1671:          STA  PRCITM+1
00:C459 4C7EC4          	  1672:          JMP  BLKPR1
                        	  1673: ;
                        	  1674: ; FUNCTION DECLARATION
                        	  1675: ;
00:C45C A949            	  1676: BLKFNC   LDA  #TOKEN_IDENTIFIER
00:C45E A204            	  1677:          LDX  #4      ; ERROR: Identifier expected
00:C460 20F4CE          	  1678:          JSR  GETCHK
00:C463 209DB9          	  1679:          JSR  CHKDUP
00:C466 A946            	  1680:          LDA  #SYMBOL_FUNCTION
00:C468 20F6B8          	  1681:          JSR  ADDSYM
00:C46B E622            	  1682:          INC  LEVEL
00:C46D A901            	  1683:          LDA  #1
00:C46F 854B            	  1684:          STA  COUNT1    ; we have the function return as a symbol
00:C471 A540            	  1685:          LDA  SYMITM
00:C473 8539            	  1686:          STA  PRCITM   ; PRCITM is the symbol of the procedure/function
00:C475 A541            	  1687:          LDA  SYMITM+1
00:C477 853A            	  1688:          STA  PRCITM+1
00:C479 A959            	  1689:          LDA  #SYMBOL_FUNCTION_RETURN ; for assigning the results to
00:C47B 20F6B8          	  1690:          JSR  ADDSYM
                        	  1691: ;
                        	  1692: ; PROCEDURE AND FUNCTION COMMON CODE
                        	  1693: ;
00:C47E A54B            	  1694: BLKPR1   LDA  COUNT1
00:C480 854C            	  1695:          STA  COUNT2    ; remember if we had 0 or 1 extra symbols (function return)
00:C482 2086C2          	  1696:          JSR  END_WRK
00:C485 205F92          	  1697:          JSR  PSHWRK
00:C488 A520            	  1698:          LDA  FRAME
00:C48A 8537            	  1699:          STA  WORK
00:C48C A521            	  1700:          LDA  FRAME+1
00:C48E 8538            	  1701:          STA  WORK+1
00:C490 205F92          	  1702:          JSR  PSHWRK
00:C493 20A0CE          	  1703:          JSR  pas_get_token
00:C496 C928            	  1704:          CMP  #'('      ; opening bracket after procedure/function name?
00:C498 D016            	  1705:          BNE  BLKPR2
00:C49A 20A0CE          	  1706: BLKPR3   JSR  pas_get_token
00:C49D 2056BB          	  1707:          JSR  VARDEC
00:C4A0 E64B            	  1708:          INC  COUNT1    ; count arguments
00:C4A2 1003            	  1709:          BPL  BLKPR6
00:C4A4 4C7DC3          	  1710:          JMP  BLKV13
00:C4A7 A593            	  1711: BLKPR6   LDA  token_type
00:C4A9 C92C            	  1712:          CMP  #','
00:C4AB F0ED            	  1713:          BEQ  BLKPR3
00:C4AD 2005BA          	  1714:          JSR  CHKRHP
00:C4B0 A539            	  1715: BLKPR2   LDA  PRCITM      ; here after argument list, if any
00:C4B2 8537            	  1716:          STA  WORK
00:C4B4 A53A            	  1717:          LDA  PRCITM+1
00:C4B6 8538            	  1718:          STA  WORK+1
00:C4B8 A006            	  1719:          LDY  #SYMARG
00:C4BA A54B            	  1720:          LDA  COUNT1
00:C4BC 38              	  1721:          SEC
00:C4BD E54C            	  1722:          SBC  COUNT2      ; subtract 0 or 1 depending on if this is a function or not
00:C4BF 9137            	  1723:          STA  (WORK),Y    ; store the number of arguments to this procedure/function
00:C4C1 A93B            	  1724:          LDA  #';'
00:C4C3 A20A            	  1725:          LDX  #10         ; ERROR: ; expected
00:C4C5 2004CF          	  1726:          JSR  CHKTKN
00:C4C8 A54B            	  1727:          LDA  COUNT1
00:C4CA F02C            	  1728:          BEQ  BLKPR4
00:C4CC 2086C2          	  1729:          JSR  END_WRK     ; ENDSYM -> WORK
00:C4CF A2FD            	  1730:          LDX  #$FD        ; X = -3
                        	  1731: ; WORK starts off pointing to the procedure/function symbol
                        	  1732: BLKPR5   = *
00:C4D1 A008            	  1733:          LDY  #SYMDAT
00:C4D3 A900            	  1734:          LDA  #0
00:C4D5 9137            	  1735:          STA  (WORK),Y    ; data type = integer
00:C4D7 A004            	  1736:          LDY  #SYMDSP
00:C4D9 8A              	  1737:          TXA
00:C4DA 9137            	  1738:          STA  (WORK),Y
00:C4DC 38              	  1739:          SEC
00:C4DD E903            	  1740:          SBC  #3
00:C4DF AA              	  1741:          TAX
00:C4E0 A9FF            	  1742:          LDA  #$FF
00:C4E2 C8              	  1743:          INY
00:C4E3 9137            	  1744:          STA  (WORK),Y
00:C4E5 C64B            	  1745:          DEC  COUNT1
00:C4E7 F00F            	  1746:          beq  BLKPR4
                        	  1747: ;
                        	  1748: ;  back to previous symbol
                        	  1749: ;
00:C4E9 A000            	  1750:          LDY  #SYMPRV
00:C4EB B137            	  1751:          LDA  (WORK),Y
00:C4ED 48              	  1752:          PHA
00:C4EE C8              	  1753:          INY
00:C4EF B137            	  1754:          LDA  (WORK),Y
00:C4F1 8538            	  1755:          STA  WORK+1
00:C4F3 68              	  1756:          PLA
00:C4F4 8537            	  1757:          STA  WORK
00:C4F6 80D9            	  1758:          bra  BLKPR5
00:C4F8 20A0CE          	  1759: BLKPR4   JSR  pas_get_token
00:C4FB 20A1C2          	  1760:          JSR  BLOCK
00:C4FE C622            	  1761:          DEC  LEVEL
00:C500 207292          	  1762:          JSR  PULWRK
00:C503 A537            	  1763:          LDA  WORK
00:C505 8520            	  1764:          STA  FRAME
00:C507 A538            	  1765:          LDA  WORK+1
00:C509 8521            	  1766:          STA  FRAME+1
00:C50B 207292          	  1767:          JSR  PULWRK
00:C50E A537            	  1768:          LDA  WORK
00:C510 8531            	  1769:          STA  ENDSYM
00:C512 A538            	  1770:          LDA  WORK+1
00:C514 8532            	  1771:          STA  ENDSYM+1
00:C516 A93B            	  1772:          LDA  #';'
00:C518 A20A            	  1773:          LDX  #10       ; ERROR: ; expected
00:C51A 206AC2          	  1774:          JSR  CHKGET
00:C51D A297            	  1775:          LDX  #<BLCKT3
00:C51F A0C2            	  1776:          LDY  #>BLCKT3
00:C521 4CDEC2          	  1777:          JMP  BLK4
                        	  1778: ;
                        	  1779: ; BEGIN (COMPOUND STATEMENT)
                        	  1780: ;
00:C524 20A0CE          	  1781: BLKBEG   JSR  pas_get_token
00:C527 207292          	  1782:          JSR  PULWRK
00:C52A A522            	  1783:          LDA  LEVEL
00:C52C D006            	  1784:          BNE  BLKB1
00:C52E 207FC7          	  1785: BLKB3    JSR  FIXAD
00:C531 4C50C5          	  1786:          JMP  BLKB2
00:C534 2073BA          	  1787: BLKB1    JSR  WRKSYM
00:C537 A004            	  1788:          LDY  #SYMDSP
00:C539 B140            	  1789:          LDA  (SYMITM),Y
00:C53B 8537            	  1790:          STA  WORK
00:C53D C8              	  1791:          INY
00:C53E B140            	  1792:          LDA  (SYMITM),Y
00:C540 8538            	  1793:          STA  WORK+1
00:C542 A004            	  1794:          LDY  #SYMDSP
00:C544 A523            	  1795:          LDA  PCODE
00:C546 9140            	  1796:          STA  (SYMITM),Y
00:C548 A524            	  1797:          LDA  PCODE+1
00:C54A C8              	  1798:          INY
00:C54B 9140            	  1799:          STA  (SYMITM),Y
00:C54D 4C2EC5          	  1800:          JMP  BLKB3
00:C550 A520            	  1801: BLKB2    LDA  FRAME
00:C552 852B            	  1802:          STA  OPND
00:C554 A521            	  1803:          LDA  FRAME+1
00:C556 852C            	  1804:          STA  OPND+1
00:C558 A93B            	  1805:          LDA  #PCODE_INT         ; INT     	Increment stack pointer
00:C55A 2051C7          	  1806:          JSR  GENJMP
00:C55D 2088BD          	  1807: BLKB5    JSR  STMNT
00:C560 A593            	  1808:          LDA  token_type
00:C562 C93B            	  1809:          CMP  #';'
00:C564 D006            	  1810:          BNE  BLKB4
00:C566 20A0CE          	  1811:          JSR  pas_get_token
00:C569 4C5DC5          	  1812:          JMP  BLKB5
00:C56C A989            	  1813: BLKB4    LDA  #TOKEN_END       ; END
00:C56E A211            	  1814:          LDX  #17         ; ERROR: ; or END expected
00:C570 206AC2          	  1815:          JSR  CHKGET
00:C573 A929            	  1816:          LDA  #PCODE_RTN  ; OK - we are at the end of a block - this is a procedure/function return
00:C575 A622            	  1817:          LDX  LEVEL       ; OR - if we are at level 0, then that is the end of the program
00:C577 D002            	  1818:          BNE  BLKB6
00:C579 A911            	  1819:          LDA  #PCODE_FINISHD        ; Opcode: FINISHED 	Stop run (end program)
                        	  1820: TEST1    =  *
00:C57B 4CC8C6          	  1821: BLKB6    JMP  GENNOP
                        	  1822: ;
                        	  1823: 
                        	  1824: 
                        	  1825: ;
                        	  1826: ;  Writing library functions is quite easy:
                        	  1827: ;
                        	  1828: ;   1. For each of the n arguments that they have (could be zero) do a PULTOP to get
                        	  1829: ;      that value from the runtime stack into REG. Or, PULTOP2 to get the value into REG2.
                        	  1830: ;      For two arguments you can do PULBOTH to get them into REG and REG2.
                        	  1831: ;   2. Do whatever the function/procedure is supposed to do with those arguments
                        	  1832: ;   3. If a procedure, you are finished: JMP MAIN
                        	  1833: ;      For a function, put the result into REG, and then JMP MAINP
                        	  1834: ;      - or - (equivalently): JSR PSHTOP, JMP MAIN
                        	  1835: ;
                        	  1836: ;  Note: PULTOP puts the value into REG and also: A, X and Y registers where A is the low-order
                        	  1837: ;        byte, X the middle byte, and Y the high-order byte.
                        	  1838: ;
                        	  1839: 
                        	  1840: ;                         Name           function or procedure   Args Execution address
                        	  1841: pascal_library_functions_table:
                        	  1842: ;
                        	  1843: ;    functions
                        	  1844: ;
                        	  1845:   makePasLibraryFunction "ABS",          SYMBOL_LIBRARY_FUNCTION,  1, EX_ABS
00:C57E 414253          	     1M      asciiz   "ABS"
00:C581 00
00:C582 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:C583 01              	     3M      dfb      1
00:C584 6AB0            	     4M      word     EX_ABS
                        	  1846:   makePasLibraryFunction "DIGITALREAD",  SYMBOL_LIBRARY_FUNCTION,  1, EX_DIGITALREAD
00:C586 4449474954414C52	     1M      asciiz   "DIGITALREAD"
00:C58E 454144
00:C591 00
00:C592 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:C593 01              	     3M      dfb      1
00:C594 E4B4            	     4M      word     EX_DIGITALREAD
                        	  1847:   makePasLibraryFunction "GETKEY",       SYMBOL_LIBRARY_FUNCTION,  0, EX_GETKEY
00:C596 4745544B4559    	     1M      asciiz   "GETKEY"
00:C59C 00
00:C59D 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:C59E 00              	     3M      dfb      0
00:C59F 24B0            	     4M      word     EX_GETKEY
                        	  1848:   makePasLibraryFunction "RANDOM",       SYMBOL_LIBRARY_FUNCTION,  0, EX_RANDOM
00:C5A1 52414E444F4D    	     1M      asciiz   "RANDOM"
00:C5A7 00
00:C5A8 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:C5A9 00              	     3M      dfb      0
00:C5AA 0CB5            	     4M      word     EX_RANDOM
                        	  1849:   makePasLibraryFunction "LATENCY",      SYMBOL_LIBRARY_FUNCTION,  0, EX_LATENCY
00:C5AC 4C4154454E4359  	     1M      asciiz   "LATENCY"
00:C5B3 00
00:C5B4 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:C5B5 00              	     3M      dfb      0
00:C5B6 1EB5            	     4M      word     EX_LATENCY
                        	  1850: ;
                        	  1851: ;      procedures
                        	  1852: ;
                        	  1853:   makePasLibraryFunction "ASSERT",       SYMBOL_LIBRARY_PROCEDURE, 1, EX_ASSERT
00:C5B8 415353455254    	     1M      asciiz   "ASSERT"
00:C5BE 00
00:C5BF 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C5C0 01              	     3M      dfb      1
00:C5C1 71B5            	     4M      word     EX_ASSERT
                        	  1854:   makePasLibraryFunction "DELAY",        SYMBOL_LIBRARY_PROCEDURE, 1, EX_DELAY
00:C5C3 44454C4159      	     1M      asciiz   "DELAY"
00:C5C8 00
00:C5C9 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C5CA 01              	     3M      dfb      1
00:C5CB 2DB5            	     4M      word     EX_DELAY
                        	  1855:   makePasLibraryFunction "DIGITALWRITE", SYMBOL_LIBRARY_PROCEDURE, 2, EX_DIGITALWRITE
00:C5CD 4449474954414C57	     1M      asciiz   "DIGITALWRITE"
00:C5D5 52495445
00:C5D9 00
00:C5DA 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C5DB 02              	     3M      dfb      2
00:C5DC 5CB5            	     4M      word     EX_DIGITALWRITE
                        	  1856:   makePasLibraryFunction "LCDCLEAR",     SYMBOL_LIBRARY_PROCEDURE, 0, EX_LCDCLEAR
00:C5DE 4C4344434C454152	     1M      asciiz   "LCDCLEAR"
00:C5E6 00
00:C5E7 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C5E8 00              	     3M      dfb      0
00:C5E9 56B4            	     4M      word     EX_LCDCLEAR
                        	  1857:   makePasLibraryFunction "LCDHOME",      SYMBOL_LIBRARY_PROCEDURE, 0, EX_LCDHOME
00:C5EB 4C4344484F4D45  	     1M      asciiz   "LCDHOME"
00:C5F2 00
00:C5F3 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C5F4 00              	     3M      dfb      0
00:C5F5 50B4            	     4M      word     EX_LCDHOME
                        	  1858:   makePasLibraryFunction "LCDPOS",       SYMBOL_LIBRARY_PROCEDURE, 2, EX_LCDPOS
00:C5F7 4C4344504F53    	     1M      asciiz   "LCDPOS"
00:C5FD 00
00:C5FE 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C5FF 02              	     3M      dfb      2
00:C600 F2B4            	     4M      word     EX_LCDPOS
                        	  1859:   makePasLibraryFunction "PINMODE",      SYMBOL_LIBRARY_PROCEDURE, 2, EX_PINMODE
00:C602 50494E4D4F4445  	     1M      asciiz   "PINMODE"
00:C609 00
00:C60A 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C60B 02              	     3M      dfb      2
00:C60C 4DB5            	     4M      word     EX_PINMODE
                        	  1860:   makePasLibraryFunction "RANDOMSEED",   SYMBOL_LIBRARY_PROCEDURE, 1, EX_RANDOMSEED
00:C60E 52414E444F4D5345	     1M      asciiz   "RANDOMSEED"
00:C616 4544
00:C618 00
00:C619 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C61A 01              	     3M      dfb      1
00:C61B 3DB5            	     4M      word     EX_RANDOMSEED
00:C61D 00              	  1861:   dfb 0   ; end of table
                        	  1862: 
                        	  1863: add_pascal_library_functions:
00:C61E A97E            	  1864:   lda #<pascal_library_functions_table
00:C620 8500            	  1865:   sta REG
00:C622 A9C5            	  1866:   lda #>pascal_library_functions_table
00:C624 8501            	  1867:   sta REG+1
                        	  1868: add_pascal_library_functions_loop:
00:C626 A000            	  1869:   ldy #0
00:C628 B100            	  1870:   lda (REG),Y
00:C62A F04B            	  1871:   beq add_pascal_library_functions_done
00:C62C A500            	  1872:   lda REG
00:C62E 8590            	  1873:   sta token_address
00:C630 A501            	  1874:   lda REG+1
00:C632 8591            	  1875:   sta token_address+1
00:C634 6492            	  1876:   stz token_length
                        	  1877: ;
                        	  1878: ;  find name length
                        	  1879: ;
                        	  1880: add_pascal_library_functions_name_loop
00:C636 C8              	  1881:   iny
00:C637 E692            	  1882:   inc token_length
00:C639 B100            	  1883:   lda (REG),Y
00:C63B D0F9            	  1884:   bne add_pascal_library_functions_name_loop
00:C63D 5A              	  1885:   phy
00:C63E A943            	  1886:   lda #SYMBOL_CONSTANT  ; add the symbol as a constant for now
00:C640 20F6B8          	  1887:   jsr ADDSYM
00:C643 7A              	  1888:   ply
                        	  1889: 
00:C644 C8              	  1890:   iny             ; get past the 0x00
00:C645 B100            	  1891:   lda (REG),Y     ; get symbol type
00:C647 5A              	  1892:   phy
00:C648 A003            	  1893:   ldy #SYMTYP
00:C64A 9140            	  1894:   sta (SYMITM),Y  ; change symbol type to be correct
00:C64C 7A              	  1895:   ply
                        	  1896: 
00:C64D C8              	  1897:   iny             ; get next byte
00:C64E B100            	  1898:   lda (REG),Y     ; get number of arguments
00:C650 5A              	  1899:   phy
00:C651 A006            	  1900:   ldy #SYMARG
00:C653 9140            	  1901:   sta (SYMITM),Y  ; save number of arguments
00:C655 7A              	  1902:   ply
                        	  1903: 
00:C656 C8              	  1904:   iny             ; get next byte
00:C657 B100            	  1905:   lda (REG),Y     ; get function address low-byte
00:C659 5A              	  1906:   phy
00:C65A A004            	  1907:   ldy #SYMDSP
00:C65C 9140            	  1908:   sta (SYMITM),Y  ; save function address low-byte
00:C65E 7A              	  1909:   ply
                        	  1910: 
00:C65F C8              	  1911:   iny             ; get next byte
00:C660 B100            	  1912:   lda (REG),Y     ; get function address high-byte
00:C662 5A              	  1913:   phy
00:C663 A005            	  1914:   ldy #SYMDSP+1
00:C665 9140            	  1915:   sta (SYMITM),Y  ; save function address high-byte
00:C667 7A              	  1916:   ply
                        	  1917: 
00:C668 C8              	  1918:   iny         ; get past that last byte
00:C669 98              	  1919:   tya         ; move REG onto next entry
00:C66A 18              	  1920:   clc
00:C66B 6500            	  1921:   adc REG
00:C66D 8500            	  1922:   sta REG
00:C66F A900            	  1923:   lda #0
00:C671 6501            	  1924:   adc REG+1
00:C673 8501            	  1925:   sta REG+1
00:C675 80AF            	  1926:   bra add_pascal_library_functions_loop
                        	  1927: 
                        	  1928: add_pascal_library_functions_done:
00:C677 60              	  1929:   rts
                        	  1930: 
                        	  1931: 
                        	  1932: library_function_call:
                        	  1933: 
00:C678 A900            	  1934:   lda  #0
00:C67A 854B            	  1935:   sta  COUNT1      ; number of arguments
00:C67C A006            	  1936:   ldy  #SYMARG
00:C67E B140            	  1937:   lda  (SYMITM),Y
00:C680 F032            	  1938:   beq  library_function_call_1
                        	  1939: 
                        	  1940: ;
                        	  1941: ;  here if it has arguments - push them on the stack
                        	  1942: ;
                        	  1943: 
00:C682 20FEB9          	  1944:   jsr  CHKLHP
                        	  1945: library_function_call_2
00:C685 A54B            	  1946:   lda  COUNT1    ; save on stack in case the expression calls functions
00:C687 48              	  1947:   pha
00:C688 2068BA          	  1948:   jsr  SYMWRK
00:C68B 205F92          	  1949:   jsr  PSHWRK
00:C68E 20BCBA          	  1950:   jsr  GETEXPR
00:C691 207292          	  1951:   jsr  PULWRK
00:C694 2073BA          	  1952:   jsr  WRKSYM
00:C697 68              	  1953:   pla            ; get number of arguments back
00:C698 854B            	  1954:   sta  COUNT1
00:C69A E64B            	  1955:   inc  COUNT1    ; add 1 for the one we just processed
00:C69C A593            	  1956:   lda  token_type
00:C69E C92C            	  1957:   cmp  #','
00:C6A0 F0E3            	  1958:   beq  library_function_call_2
                        	  1959: 
00:C6A2 A54B            	  1960:   lda  COUNT1
00:C6A4 A006            	  1961:   ldy  #SYMARG
00:C6A6 D140            	  1962:   cmp  (SYMITM),Y   ; check we got the right number of arguments
00:C6A8 F005            	  1963:   beq  library_function_call_3
                        	  1964: 
00:C6AA A223            	  1965:   ldx  #35     ; ERROR: Parameters mismatched
00:C6AC 4C6497          	  1966:   jmp  ERROR
                        	  1967: library_function_call_3:
00:C6AF 2005BA          	  1968:   jsr  CHKRHP
00:C6B2 8003            	  1969:   bra  library_function_call_5
                        	  1970: 
                        	  1971: ;
                        	  1972: ;  here for no arguments
                        	  1973: ;
                        	  1974: 
                        	  1975: library_function_call_1:
00:C6B4 20A0CE          	  1976:   jsr  pas_get_token      ; one token look-ahead
                        	  1977: 
                        	  1978: library_function_call_5:
00:C6B7 A004            	  1979:   ldy  #SYMDSP
00:C6B9 B140            	  1980:   lda  (SYMITM),Y
00:C6BB 852B            	  1981:   sta  OPND
00:C6BD C8              	  1982:   iny
00:C6BE B140            	  1983:   lda  (SYMITM),Y
00:C6C0 852C            	  1984:   sta  OPND+1
00:C6C2 A903            	  1985:   lda  #PCODE_LIB_CALL
00:C6C4 2051C7          	  1986:   jsr  GENJMP
00:C6C7 60              	  1987:   rts
                        	  1988: 
                        	  1989: 
                        	  1990: ;***********************************************
                        	  1991: ; GENERATE P-CODES - NO OPERANDS
                        	  1992: ;***********************************************
                        	  1993: GENNOP   =  *
00:C6C8 A442            	  1994:          LDY  SYNTAX
00:C6CA D011            	  1995:          BNE  GEN1      ; no storing/displaying if syntax-only compile
00:C6CC 9123            	  1996:          STA  (PCODE),Y
00:C6CE 48              	  1997:          PHA
00:C6CF 204392          	  1998:          JSR  DISPAD
00:C6D2 68              	  1999:          PLA
00:C6D3 A62E            	  2000:          LDX  DCODE
00:C6D5 F006            	  2001:          BEQ  GEN1
00:C6D7 203D92          	  2002:          JSR  DISHX
00:C6DA 202892          	  2003:          JSR  CROUT
                        	  2004: GEN1     =  *
00:C6DD A901            	  2005:          LDA  #1      ; 1-byte P-code
00:C6DF D035            	  2006:          BNE  GEN2_B
                        	  2007: ;***********************************************
                        	  2008: ; GENERATE P-CODES - WITH ADDRESS (3-bytes stored in DISPL (1)/OFFSET(2))
                        	  2009: ;***********************************************
                        	  2010: GENADR   =  *
00:C6E1 A442            	  2011:          LDY  SYNTAX
00:C6E3 D02F            	  2012:          BNE  GEN2    ; no storing/displaying if syntax-only compile
00:C6E5 9123            	  2013:          STA  (PCODE),Y
00:C6E7 48              	  2014:          PHA
00:C6E8 A527            	  2015:          LDA  DISPL
00:C6EA C8              	  2016:          INY
00:C6EB 9123            	  2017:          STA  (PCODE),Y
00:C6ED A529            	  2018:          LDA  OFFSET
00:C6EF C8              	  2019:          INY
00:C6F0 9123            	  2020:          STA  (PCODE),Y
00:C6F2 A52A            	  2021:          LDA  OFFSET+1
00:C6F4 C8              	  2022:          INY
00:C6F5 9123            	  2023:          STA  (PCODE),Y
00:C6F7 204392          	  2024:          JSR  DISPAD
00:C6FA 68              	  2025:          PLA
00:C6FB A62E            	  2026:          LDX  DCODE
00:C6FD F015            	  2027:          BEQ  GEN2
00:C6FF 203D92          	  2028:          JSR  DISHX
00:C702 A527            	  2029:          LDA  DISPL
00:C704 203D92          	  2030:          JSR  DISHX
00:C707 A529            	  2031:          LDA  OFFSET
00:C709 203D92          	  2032:          JSR  DISHX
00:C70C A52A            	  2033:          LDA  OFFSET+1
00:C70E 203D92          	  2034:          JSR  DISHX
00:C711 202892          	  2035:          JSR  CROUT
                        	  2036: GEN2     =  *
00:C714 A904            	  2037:          LDA  #4      ; 4-byte P-code
                        	  2038: GEN2_B   =  *
00:C716 18              	  2039:          CLC
00:C717 6523            	  2040:          ADC  PCODE
00:C719 8523            	  2041:          STA  PCODE
00:C71B 9002            	  2042:          BCC  GEN2_A
00:C71D E624            	  2043:          INC  PCODE+1
                        	  2044: GEN2_A   =  *
00:C71F A542            	  2045:          LDA  SYNTAX
00:C721 D013            	  2046:          BNE  GEN2_C      ; no storing/displaying if syntax-only compile
00:C723 A524            	  2047:          LDA  PCODE+1     ; see if P-codes full
00:C725 C532            	  2048:          CMP  ENDSYM+1   ; in other words, have we hit the symbol table?
00:C727 900D            	  2049:          BCC  GEN2_C      ; less than
00:C729 D006            	  2050:          BNE  GEN_FULL
00:C72B A523            	  2051:          LDA  PCODE
00:C72D C531            	  2052:          CMP  ENDSYM   ; TODO - what?
00:C72F 9005            	  2053:          BCC  GEN2_C
00:C731 A201            	  2054: GEN_FULL LDX  #1         ; MEM FULL
00:C733 4C6497          	  2055:          jmp  ERROR
                        	  2056: GEN2_C   =  *
00:C736 60              	  2057: DISP9    RTS
                        	  2058: ;***********************************************
                        	  2059: ; GENERATE P-CODES - JUMP ADDRESS (relative to current P-code address in OPND)
                        	  2060: ;***********************************************
                        	  2061: GENRJMP  =  *
00:C737 48              	  2062:          PHA
00:C738 A52B            	  2063:          LDA  OPND
00:C73A 38              	  2064:          SEC
00:C73B E523            	  2065:          SBC  PCODE
00:C73D 852B            	  2066:          STA  OPND      ; subtract P-code address to find difference
00:C73F A52C            	  2067:          LDA  OPND+1
00:C741 E524            	  2068:          SBC  PCODE+1
00:C743 852C            	  2069:          STA  OPND+1
00:C745 68              	  2070:          PLA
00:C746 4C51C7          	  2071:          JMP  GENJMP
                        	  2072: ;
                        	  2073: GENNJP   =  *
00:C749 A93C            	  2074:          LDA  #PCODE_JMP       ; JMP
                        	  2075: 
                        	  2076: ; Generate jump, P-code is in "A" register (eg. PCODE_JMZ, PCODE_JM1)
                        	  2077: ;
                        	  2078: ;  Note: the destination here is 0000, however FIXAD will be called later to fix up
                        	  2079: ;        the jump, once we know what the destination will be (ie. further down the code)
                        	  2080: ;
00:C74B A200            	  2081: GENNJM   LDX  #0
00:C74D 862B            	  2082:          STX  OPND
00:C74F 862C            	  2083:          STX  OPND+1
                        	  2084: ;
                        	  2085: ;***********************************************
                        	  2086: ; GENERATE P-CODES - JUMP ADDRESS (absolute address in OPND)
                        	  2087: ;   also used in other places, like increment stack address
                        	  2088: ;***********************************************
                        	  2089: GENJMP   =  *
00:C751 A442            	  2090:          LDY  SYNTAX
00:C753 D025            	  2091:          BNE  GEN3     ; no storing/displaying if syntax-only compile
00:C755 9123            	  2092:          STA  (PCODE),Y
00:C757 48              	  2093:          PHA
00:C758 A52B            	  2094:          LDA  OPND
00:C75A C8              	  2095:          INY
00:C75B 9123            	  2096:          STA  (PCODE),Y
00:C75D A52C            	  2097:          LDA  OPND+1
00:C75F C8              	  2098:          INY
00:C760 9123            	  2099:          STA  (PCODE),Y
00:C762 204392          	  2100:          JSR  DISPAD
00:C765 68              	  2101:          PLA
00:C766 A62E            	  2102:          LDX  DCODE
00:C768 F010            	  2103:          BEQ  GEN3
00:C76A 203D92          	  2104:          JSR  DISHX
00:C76D A52B            	  2105:          LDA  OPND
00:C76F 203D92          	  2106:          JSR  DISHX
00:C772 A52C            	  2107:          LDA  OPND+1
00:C774 203D92          	  2108:          JSR  DISHX
00:C777 202892          	  2109:          JSR  CROUT
                        	  2110: GEN3     =  *
00:C77A A903            	  2111:          LDA  #3        ; 3-byte P-code
00:C77C 4C16C7          	  2112:          JMP  GEN2_B
                        	  2113: 
                        	  2114: ;***********************************************
                        	  2115: ; FIXUP ADDRESSES
                        	  2116: ;***********************************************
                        	  2117: FIXAD    =  *
00:C77F A442            	  2118:          LDY  SYNTAX
00:C781 D039            	  2119:          BNE  FIXAD1
00:C783 A001            	  2120:          LDY  #1
00:C785 A523            	  2121:          LDA  PCODE
00:C787 38              	  2122:          SEC
00:C788 E537            	  2123:          SBC  WORK
00:C78A 9137            	  2124:          STA  (WORK),Y
00:C78C C8              	  2125:          INY
00:C78D A524            	  2126:          LDA  PCODE+1
00:C78F E538            	  2127:          SBC  WORK+1
00:C791 9137            	  2128:          STA  (WORK),Y
00:C793 A52E            	  2129:          LDA  DCODE
00:C795 F025            	  2130:          BEQ  FIXAD1
00:C797 A9BD            	  2131:          LDA  #<FIXM1
00:C799 A2C7            	  2132:          LDX  #>FIXM1
00:C79B 202682          	  2133:          JSR  print
00:C79E A538            	  2134:          LDA  WORK+1
00:C7A0 209D92          	  2135:          JSR  PRBYTE
00:C7A3 A537            	  2136:          LDA  WORK
00:C7A5 203D92          	  2137:          JSR  DISHX
00:C7A8 A9C6            	  2138:          LDA  #<FIXM2
00:C7AA A2C7            	  2139:          LDX  #>FIXM2
00:C7AC 202682          	  2140:          JSR  print
00:C7AF A524            	  2141:          LDA  PCODE+1
00:C7B1 209D92          	  2142:          JSR  PRBYTE
00:C7B4 A523            	  2143:          LDA  PCODE
00:C7B6 203D92          	  2144:          JSR  DISHX
00:C7B9 4C2892          	  2145:          JMP  CROUT
00:C7BC 60              	  2146: FIXAD1    rts
                        	  2147: 
00:C7BD 4A756D7020617420	  2148: FIXM1    asciiz  'Jump at '
00:C7C5 00
00:C7C6 6368616E67656420	  2149: FIXM2    asciiz  'changed to '   ; changed to
00:C7CE 746F20
00:C7D1 00
                        	  2150: 
                        	  2151: 

Source: "gpascal.asm"
                        	   184:   .include "hardware.inc"

Source: "hardware.inc"
                        	     1: 
                        	     2: ; VIA - Versatile Interface Adapter (W65C22) hardware
                        	     3: 
                        	     4: VIA_PORTB   = $7FF0   ; input/output register "B"
                        	     5: VIA_PORTA   = $7FF1   ; input/output register "A"
                        	     6: VIA_DDRB    = $7FF2   ; data direction register "B"
                        	     7: VIA_DDRA    = $7FF3   ; data direction register "A"
                        	     8: VIA_T1C_L   = $7FF4   ; T1 write: latch (L), read: counter (L)
                        	     9: VIA_T1C_H   = $7FF5   ; T1 high_order counter
                        	    10: VIA_T1L_L   = $7FF6   ; T1 low_order latches
                        	    11: VIA_T1L_H   = $7FF7   ; T1 high_order latches
                        	    12: VIA_T2C_L   = $7FF8   ; T2 write: latch (L), read: counter (L)
                        	    13: VIA_T2C_H   = $7FF9   ; T2 high_order counter
                        	    14: VIA_SR      = $7FFA   ; shift register
                        	    15: VIA_ACR     = $7FFB   ; auxilliary control register
                        	    16: VIA_PCR     = $7FFC   ; peripheral control register
                        	    17: VIA_IFR     = $7FFD   ; interrupt flag register
                        	    18: VIA_IER     = $7FFE   ; interrupt enable register
                        	    19: 
                        	    20: VIA_FLAG_ENABLE   = %10000000 ; high-order bit set enables the flag
                        	    21: VIA_FLAG_DISABLE  = %00000000 ; high-order bit clear disables the flag
                        	    22: VIA_FLAG_TIMER1   = %01000000
                        	    23: VIA_FLAG_TIMER2   = %00100000
                        	    24: VIA_FLAG_CB1      = %00010000
                        	    25: VIA_FLAG_CB2      = %00001000
                        	    26: VIA_FLAG_SHIFT    = %00000100
                        	    27: VIA_FLAG_CA1      = %00000010
                        	    28: VIA_FLAG_CA2      = %00000001
                        	    29: 
                        	    30: ;
                        	    31: ; VIA Port A pin masks
                        	    32: ;
                        	    33: 
                        	    34: SERIAL_IN_MASK     = %00000001   ; serial in on PA0 (also connect to CB2) (to FTDI TxD pin - pin 4)
                        	    35: SERIAL_OUT_MASK    = %00000010   ; serial out on PA1 (to FTDI RxD pin - pin 5)
                        	    36: SERIAL_DEBUG1_MASK = %00000100   ; serial debugging on PA2
                        	    37: SERIAL_DEBUG2_MASK = %00001000   ; serial debugging on PA3
                        	    38: SERIAL_SPARE2_MASK = %00010000   ; spare VIA pins (PA4)
                        	    39: 
                        	    40: 
                        	    41: ;***********************************************
                        	    42: ;  Functions added for Ben's Board
                        	    43: ;***********************************************
                        	    44: 
                        	    45: ;
                        	    46: ;  Converts a pin number in the range 0 to 15 to a mask
                        	    47: ;  eg. 00000001, 00000010, 00000100 and so on
                        	    48: ;
                        	    49: ;  Returns mask in Y
                        	    50: ;
                        	    51: ;  Returns with Z set if the range was 0 to 7 an
                        	    52: ;  and Z clear if the range was 8 to 15
                        	    53: ;
                        	    54: pin_number_to_mask = *
00:C7D2 48              	    55:   pha         ; save for a moment
00:C7D3 2907            	    56:   and #$7     ; make in range 0 to 7
00:C7D5 A8              	    57:   tay
00:C7D6 A901            	    58:   lda #1      ; initial mask
                        	    59: pin_number_to_mask_loop:
00:C7D8 C000            	    60:   cpy #0
00:C7DA F004            	    61:   beq pin_number_to_mask_done
00:C7DC 0A              	    62:   asl A
00:C7DD 88              	    63:   dey
00:C7DE 80F8            	    64:   bra pin_number_to_mask_loop
                        	    65: pin_number_to_mask_done:
00:C7E0 A8              	    66:   tay         ; save mask in Y
00:C7E1 68              	    67:   pla
00:C7E2 2908            	    68:   and #$8     ; DDRA or DDRB ?
00:C7E4 60              	    69:   rts
                        	    70: 
                        	    71: ;
                        	    72: ;  pin in A, mode in X
                        	    73: ;
                        	    74: pinmode:
00:C7E5 868C            	    75:   stx hardware_work ; input or output
00:C7E7 20D2C7          	    76:   jsr pin_number_to_mask  ; convert to appropriate mask bit
00:C7EA D00A            	    77:   bne pinmode_B        ; Z is clear if it is DDRB
00:C7EC A9F3            	    78:   lda #<VIA_DDRA
00:C7EE 8500            	    79:   sta REG
00:C7F0 A97F            	    80:   lda #>VIA_DDRA
00:C7F2 8501            	    81:   sta REG+1
00:C7F4 8008            	    82:   bra pinmode_C
                        	    83: pinmode_B:
00:C7F6 A9F2            	    84:   lda #<VIA_DDRB
00:C7F8 8500            	    85:   sta REG
00:C7FA A97F            	    86:   lda #>VIA_DDRB
00:C7FC 8501            	    87:   sta REG+1
                        	    88: ;
                        	    89: ;  The DDR register is now in REG
                        	    90: ;
                        	    91: pinmode_C:
00:C7FE A58C            	    92:   lda hardware_work     ; input or output?
00:C800 D00A            	    93:   bne pinmode_OUTPUT
                        	    94: ;
                        	    95: ;  here to set input mode
                        	    96: ;
00:C802 98              	    97:   tya       ; get the mask back
00:C803 A000            	    98:   ldy #0
00:C805 49FF            	    99:   eor #$FF  ; negate the mask
00:C807 3100            	   100:   and (REG),y
00:C809 9100            	   101:   sta (REG),y
00:C80B 60              	   102:   rts       ; done
                        	   103: ;
                        	   104: ;  here to set output mode
                        	   105: ;
                        	   106: pinmode_OUTPUT:
00:C80C 98              	   107:   tya          ; get the mask back
00:C80D A000            	   108:   ldy #0
00:C80F 1100            	   109:   ora (REG),y  ; or in with the existing DDR register
00:C811 9100            	   110:   sta (REG),y  ; and write it back
00:C813 60              	   111:   rts          ; done
                        	   112: 
                        	   113: 
                        	   114: ;
                        	   115: ;  DIGITALWRITE (pin, value) pin:0 to 15; value: 0 or 1 : pin in A, mode in X
                        	   116: ;
                        	   117: digitalwrite = *
00:C814 868C            	   118:   stx hardware_work ; save what to write (0 or 1)
00:C816 20D2C7          	   119:   jsr pin_number_to_mask  ; convert to appropriate mask bit
00:C819 D00A            	   120:   bne digitalwrite_B        ; Z is clear if it is PORTB
00:C81B A9F1            	   121:   lda #<VIA_PORTA
00:C81D 8500            	   122:   sta REG
00:C81F A97F            	   123:   lda #>VIA_PORTA
00:C821 8501            	   124:   sta REG+1
00:C823 8008            	   125:   bra digitalwrite_C
                        	   126: digitalwrite_B:
00:C825 A9F0            	   127:   lda #<VIA_PORTB
00:C827 8500            	   128:   sta REG
00:C829 A97F            	   129:   lda #>VIA_PORTB
00:C82B 8501            	   130:   sta REG+1
                        	   131: ;
                        	   132: ;  The PORT register is now in REG
                        	   133: ;
                        	   134: digitalwrite_C:
00:C82D A58C            	   135:   lda hardware_work
00:C82F D00A            	   136:   bne digitalwrite_ONE  ; any non-zero value is writing a 1
                        	   137: ;
                        	   138: ;  here to write a zero
                        	   139: ;
00:C831 98              	   140:   tya
00:C832 A000            	   141:   ldy #0
00:C834 49FF            	   142:   eor #$FF  ; negate the mask
00:C836 3100            	   143:   and (REG),y
00:C838 9100            	   144:   sta (REG),y
00:C83A 60              	   145:   rts       ; done
                        	   146: 
                        	   147: ;
                        	   148: ;  here to write a one
                        	   149: ;
                        	   150: digitalwrite_ONE:
00:C83B 98              	   151:   tya          ; get the mask back
00:C83C A000            	   152:   ldy #0
00:C83E 1100            	   153:   ora (REG),y  ; or in with the existing DDR register
00:C840 9100            	   154:   sta (REG),y  ; and write it back
00:C842 60              	   155:   rts          ; done
                        	   156: 
                        	   157: 
                        	   158: ;
                        	   159: ;  DIGITALREAD (pin) pin:0 to 15; Pin to read is in in A. returns or non-zero in A.
                        	   160: ;
                        	   161: digitalread = *
00:C843 20D2C7          	   162:   jsr pin_number_to_mask  ; convert to appropriate mask bit
00:C846 D00A            	   163:   bne digitalread_B        ; Z is clear if it is PORTB
00:C848 A9F1            	   164:   lda #<VIA_PORTA
00:C84A 8500            	   165:   sta REG
00:C84C A97F            	   166:   lda #>VIA_PORTA
00:C84E 8501            	   167:   sta REG+1
00:C850 8008            	   168:   bra digitalread_C
                        	   169: digitalread_B:
00:C852 A9F0            	   170:   lda #<VIA_PORTB
00:C854 8500            	   171:   sta REG
00:C856 A97F            	   172:   lda #>VIA_PORTB
00:C858 8501            	   173:   sta REG+1
                        	   174: ;
                        	   175: ;  The PORT register is now in REG
                        	   176: ;
                        	   177: digitalread_C:
00:C85A 98              	   178:   tya         ; get the mask back
00:C85B A000            	   179:   ldy #0
00:C85D 3100            	   180:   and (REG),y ; get that bit
00:C85F 60              	   181:   rts
                        	   182: 
                        	   183: 
                        	   184: 
                        	   185: ;
                        	   186: ;  Functions to change where writing is done
                        	   187: ;
                        	   188: write_to_serial:
00:C860 48              	   189:   pha
00:C861 A9BC            	   190:   lda  #<write_char
00:C863 8517            	   191:   sta  write_function
00:C865 A9C8            	   192:   lda  #>write_char
00:C867 8518            	   193:   sta  write_function+1
00:C869 68              	   194:   pla
00:C86A 60              	   195:   rts
                        	   196: 
                        	   197: write_to_lcd:
00:C86B 48              	   198:   pha
00:C86C A91C            	   199:   lda  #<lcd_print_char
00:C86E 8517            	   200:   sta  write_function
00:C870 A9B8            	   201:   lda  #>lcd_print_char
00:C872 8518            	   202:   sta  write_function+1
00:C874 68              	   203:   pla
00:C875 60              	   204:   rts
                        	   205: 
                        	   206: 
                        	   207: 
                        	   208: ; ---------------------------
                        	   209: ; Simulate kernel interfaces
                        	   210: ; ---------------------------
                        	   211: ; We interface by reading/writing to special
                        	   212: ; RAM that is implemented in the emulator
                        	   213: 
                        	   214: 
                        	   215: 
                        	   216:     .if EMULATOR
                        	   217: 
                        	   218: ;
                        	   219: ;  Emulator testing
                        	   220: ;
                        	   221: CHRIN    =  *
                        	   222:          lda  $7F22
                        	   223:          rts
                        	   224: 
                        	   225: write_char   =  *
                        	   226:          sta  $7F23
                        	   227:          rts
                        	   228: 
                        	   229: 
                        	   230: GETIN    =  *
                        	   231:          lda  $7F29
                        	   232:          rts
                        	   233: 
                        	   234: hardware_init rts
                        	   235: 
                        	   236: ;
                        	   237: ;  put debug number in A
                        	   238: ;
                        	   239: EMULATOR_DEBUG = *
                        	   240:          sta $7F46
                        	   241:          rts
                        	   242: 
                        	   243: START_TRACE = *
                        	   244:          sta $7F47
                        	   245:          rts
                        	   246: 
                        	   247: STOP_TRACE = *
                        	   248:          sta $7F48
                        	   249:          rts
                        	   250: ;
                        	   251: ;  not applicable in emulator
                        	   252: ;
                        	   253: lcd_print_message   rts
                        	   254: lcd_clear_display   rts
                        	   255: lcd_print_char      rts
                        	   256: lcd_second_line     rts
                        	   257: lcd_instruction     rts
                        	   258: lcd_get_address     rts
                        	   259: lcd_wait            rts
                        	   260: lcd_home            rts
                        	   261: lcd_initialise      rts
                        	   262: serial_available    rts
                        	   263: serial_print_message rts
                        	   264: 
                        	   265:   .else
                        	   266: 
                        	   267: ;
                        	   268: ;  Ben's Board
                        	   269: ;
                        	   270: 
                        	   271: ;
                        	   272: ;  typing_latency could be used as a seed for the random number generator
                        	   273: ;    - the exact time between keypresses would be somewhat unpredictable
                        	   274: ;
                        	   275: CHRIN  = *
                        	   276: GETIN    =  *
00:C876 E60D            	   277:          inc typing_latency
00:C878 D006            	   278:          bne GETIN1
00:C87A E60E            	   279:          inc typing_latency+1
00:C87C D002            	   280:          bne GETIN1
00:C87E E60F            	   281:          inc typing_latency+2
                        	   282: GETIN1:
00:C880 A58B            	   283:          lda serial_in_byte_received
00:C882 F0F2            	   284:          beq GETIN    ; nothing yet
00:C884 648B            	   285:          stz serial_in_byte_received
00:C886 60              	   286:          rts
                        	   287: 
                        	   288: serial_available = *
00:C887 A58B            	   289:          lda serial_in_byte_received
00:C889 60              	   290:          rts
                        	   291: 
                        	   292: 
00:C88A 60              	   293: EMULATOR_DEBUG rts
00:C88B 60              	   294: START_TRACE rts
00:C88C 60              	   295: STOP_TRACE rts
                        	   296: 
                        	   297: 
                        	   298: ;
                        	   299: ;  set up serial hardware
                        	   300: ;
                        	   301: 
                        	   302: hardware_init:
                        	   303: 
00:C88D ADF17F          	   304:   lda VIA_PORTA
00:C890 0902            	   305:   ora #SERIAL_OUT_MASK  ; set 1 bit (idle serial comms)
00:C892 8DF17F          	   306:   sta VIA_PORTA
                        	   307: 
                        	   308:   ; set output enable bits
00:C895 A91E            	   309:   lda #(SERIAL_OUT_MASK | SERIAL_DEBUG1_MASK | SERIAL_DEBUG2_MASK | SERIAL_SPARE2_MASK)
00:C897 8DF37F          	   310:   sta VIA_DDRA
                        	   311: 
00:C89A A940            	   312:   lda #%01000000      ; continuous interrupts on T1
00:C89C 8DFB7F          	   313:   sta VIA_ACR
                        	   314: 
00:C89F A9D0            	   315:   lda #<BIT_INTERVAL  ; ie. baud rate interval
00:C8A1 8DF47F          	   316:   sta VIA_T1C_L       ; for sending bits
00:C8A4 A900            	   317:   lda #>BIT_INTERVAL
00:C8A6 8DF57F          	   318:   sta VIA_T1C_H       ; this starts the counter
                        	   319: 
                        	   320:   ; set up for serial input
                        	   321: 
00:C8A9 A988            	   322:   lda #VIA_FLAG_ENABLE | VIA_FLAG_CB2  ; interrupt on CB2 falling edge
00:C8AB 8DFE7F          	   323:   sta VIA_IER
                        	   324: 
00:C8AE A9FF            	   325:   lda #$FF         ; clear all interrupt flags
00:C8B0 8DFD7F          	   326:   sta VIA_IFR
                        	   327: 
                        	   328:   .if LCD_SUPPORT
00:C8B3 2014B7          	   329:   jsr lcd_initialise
                        	   330:   .endif
                        	   331: 
00:C8B6 648A            	   332:   stz serial_in_byte    ; non-zero means an interrupt put in incoming byte there
00:C8B8 6489            	   333:   stz serial_out_bit
                        	   334: 
00:C8BA 58              	   335:   cli         ; enable interrupts
00:C8BB 60              	   336:   rts
                        	   337: 
                        	   338: 
                        	   339: ;
                        	   340: ;  Write a character (in A) to the serial port.
                        	   341: ;   Interrupts MUST be enabled for this to work!
                        	   342: ;
                        	   343: write_char:
00:C8BC 48              	   344:   pha                   ; save original character
00:C8BD 0A              	   345:   asl a                 ; shift in a zero which will be the start bit
00:C8BE 8587            	   346:   sta serial_out_byte
00:C8C0 A9FF            	   347:   lda #0xff             ; will become the stop bit(s)
00:C8C2 2A              	   348:   rol a                 ; rotate in the high-order bit from the data byte
00:C8C3 8588            	   349:   sta serial_out_byte+1
00:C8C5 A90B            	   350:   lda #11               ; 8 data bits, one start bit, two stop bits
00:C8C7 8589            	   351:   sta serial_out_bit    ; number of bits to shift out
00:C8C9 A9D0            	   352:   lda #<BIT_INTERVAL    ; ie. baud rate interval
00:C8CB 8DF47F          	   353:   sta VIA_T1C_L         ; for sending bits
00:C8CE A900            	   354:   lda #>BIT_INTERVAL
00:C8D0 8DF57F          	   355:   sta VIA_T1C_H         ; this starts the counter
00:C8D3 A9C0            	   356:   lda #VIA_FLAG_ENABLE | VIA_FLAG_TIMER1  ; interrupt on T1 timeout
00:C8D5 8DFE7F          	   357:   sta VIA_IER
                        	   358: 
                        	   359: ;
                        	   360: ; wait for this byte to finish - otherwise it might interfere with many things
                        	   361: ;
                        	   362: 
                        	   363: write_char_loop:
00:C8D8 ADFE7F          	   364:   lda VIA_IER
00:C8DB 2940            	   365:   and #VIA_FLAG_TIMER1  ; are T1 interrupts enabled?
00:C8DD D0F9            	   366:   bne write_char_loop   ; loop until this character sent
00:C8DF 68              	   367:   pla                   ; get character back
00:C8E0 60              	   368:   rts
                        	   369: 
                        	   370: 
                        	   371: ;
                        	   372: ;  sends null-terminated message to serial port, message in A (lo) and X (hi)
                        	   373: ;  returns the length of the message in Y
                        	   374: ;
                        	   375: serial_print_message:
00:C8E1 8503            	   376:   sta REG2
00:C8E3 8604            	   377:   stx REG2+1
00:C8E5 A000            	   378:   ldy #0
                        	   379: serial_print:
00:C8E7 B103            	   380:   lda (REG2),y
00:C8E9 F006            	   381:   beq serial_print_done
00:C8EB 20BCC8          	   382:   jsr write_char
00:C8EE C8              	   383:   iny
00:C8EF 80F6            	   384:   bra serial_print
                        	   385: 
00:C8F1 60              	   386: serial_print_done rts
                        	   387: 
                        	   388:   .endif  ; not EMULATOR
                        	   389: 
                        	   390: 

Source: "gpascal.asm"
                        	   185:   .include "gtoken.inc"

Source: "gtoken.inc"
                        	     1: ;
                        	     2: ;  get_token
                        	     3: ;
                        	     4: ;  Gets a lexical token from the specified address.
                        	     5: ;
                        	     6: ;  - Start parsing at token_start (this should be the first character of the token)
                        	     7: ;  - The first found character (after spaces, comments, newlines) is in token_address
                        	     8: ;      - this is mainly used for knowing what the identifier is so we can put it in the symbol table
                        	     9: ;      - strings are put into INBUF after processing, so token_address is not as useful in that case
                        	    10: ;  - The length is in token_length (in the case of strings, this is the processed length)
                        	    11: ;  - The type is in token_type - zero would mean end of file
                        	    12: ;
                        	    13: ;  The types are one of the token codes below
                        	    14: ;
                        	    15: ;  Tokens which start with a letter and are possibly followed by letters, numbers, and
                        	    16: ;    the underscore character become TOKEN_IDENTIFIER.
                        	    17: ;
                        	    18: ;  Tokens starting with a number (TOKEN_NUMBER) are parsed for the value which is placed into token_value.
                        	    19: ;
                        	    20: ;  Tokens starting with a single or double quote are parsed for the internal string (TOKEN_STRING)
                        	    21: ;  which is placed in INBUF. The internal string has internal double-quotes turned
                        	    22: ;  into single quotes, and sequences like \n or \x42 turned into their appropriate characters.
                        	    23: ;
                        	    24: ;  String tokens which are up to 3 bytes long also have the 3 bytes placed into token_value.
                        	    25: ;
                        	    26: ;  Hex and binary tokens are parsed for their value which is placed into token_value.
                        	    27: ;
                        	    28: ;  Various 2-character tokens are given their own code (eg. <> == != := << >> and so on).
                        	    29: ;
                        	    30: ;  Spaces and comments are skipped, however Pascal directives inside comments are processed
                        	    31: ;
                        	    32: ;  Newlines are skipped in Pascal but returned as a token in assembler (ASSEMBLING == true)
                        	    33: ;  If newlines are skipped then token_line is called to handle listing the line (the line
                        	    34: ;   we are about to process, not the previous line)
                        	    35: ;
                        	    36: ; Rewritten in February 2022 to be easier to read and have well-defined work variables (zero-page variables)
                        	    37: 
                        	    38: ; multi-byte token codes (single byte tokens are themselves)
                        	    39: 
                        	    40: TOKEN_ASSIGN     = 'A'   ; :=
                        	    41: TOKEN_IDENTIFIER = 'I'   ; alpha-numeric identifiers
                        	    42: TOKEN_NUMBER     = 'N'   ; numbers
                        	    43: TOKEN_STRING     = '"'   ; string literal
                        	    44: TOKEN_LEQ        = $80   ; <=
                        	    45: TOKEN_GEQ        = $81   ; >=
                        	    46: TOKEN_NEQ        = 'U'   ; <>
                        	    47: 
                        	    48: ;
                        	    49: ;  the ones below are used in the assembler
                        	    50: ;
                        	    51: TOKEN_EQUALITY    = 'E'     ; ==
                        	    52: TOKEN_SHIFT_LEFT  = 'L'     ; <<
                        	    53: TOKEN_SHIFT_RIGHT = 'R'     ; >>
                        	    54: TOKEN_UNARY_MINUS = 'M'     ; -
                        	    55: TOKEN_LOW_BYTE    = 'V'     ; eg. lda #<foo
                        	    56: TOKEN_HIGH_BYTE   = 'W'     ; eg. lda #>foo
                        	    57: TOKEN_LOGICAL_AND = 'X'     ; &&
                        	    58: TOKEN_LOGICAL_OR  = 'Y'     ; ||
                        	    59: TOKEN_INEQUALITY  = 'Z'     ; !=
                        	    60: 
                        	    61: 
                        	    62: get_token:
00:C8F2 A593            	    63:   lda token_type      ; remember previous token for checking if + or - stand on their own
00:C8F4 8598            	    64:   sta token_work
                        	    65: get_token_loop:
00:C8F6 A000            	    66:   ldy #0              ; offset into the token address
00:C8F8 8497            	    67:   sty token_sign      ; Y is zero at this point
00:C8FA 8494            	    68:   sty token_value     ; no value yet
00:C8FC 8495            	    69:   sty token_value+1
00:C8FE 8496            	    70:   sty token_value+2
                        	    71: 
                        	    72: gc_skip_spaces:
00:C900 B18E            	    73:   lda (token_start),y
00:C902 F034            	    74:   beq gc_done         ; 0x00 means end, so return it WITHOUT incrementing the pointer
00:C904 C90A            	    75:   cmp #NL             ; newline need special handling
00:C906 F00D            	    76:   beq gc_newline
00:C908 204A81          	    77:   jsr isspace
00:C90B 9043            	    78:   bcc gc_not_space
00:C90D E68E            	    79:   inc token_start     ; increment pointer because spaces can be any length
00:C90F D0EF            	    80:   bne gc_skip_spaces
00:C911 E68F            	    81:   inc token_start+1
00:C913 80EB            	    82:   bra gc_skip_spaces
                        	    83: 
                        	    84: ;
                        	    85: ;  got a newline - if assembling, return that so we know where lines end
                        	    86: ;  otherwise just call token_line to display the next line and press on looking
                        	    87: ;  for tokens.
                        	    88: ;
                        	    89: gc_newline:
00:C915 A902            	    90:   lda #FLAG_ASSEMBLING
00:C917 25BE            	    91:   and system_flags
00:C919 D014            	    92:   bne gc_newline_assembling    ; return the newline as a token
00:C91B C8              	    93:   iny              ; length in Y (ie. one)
00:C91C E68E            	    94:   inc token_start
00:C91E D002            	    95:   bne gc_newline1
00:C920 E68F            	    96:   inc token_start+1
                        	    97: gc_newline1:
00:C922 A58E            	    98:   lda token_start
00:C924 859C            	    99:   sta token_line_start
00:C926 A58F            	   100:   lda token_start+1
00:C928 859D            	   101:   sta token_line_start+1
00:C92A 2092C9          	   102:   jsr token_line        ; list the next line
00:C92D 80C7            	   103:   bra get_token_loop    ; look for another token
                        	   104: 
                        	   105: gc_newline_assembling:
00:C92F A90A            	   106:   lda #NL       ; get the newline back
00:C931 4C36C9          	   107:   jmp gc_single_byte_token
                        	   108: 
                        	   109: ;
                        	   110: ;  wrap up getting a token:
                        	   111: ;
                        	   112: ;   - save the type
                        	   113: ;   - save the current address as token_address
                        	   114: ;   - add the length to token_start ready for next time
                        	   115: ;
                        	   116: gc_single_byte_already_known:
00:C934 A593            	   117:   lda token_type        ; get back saved token type
                        	   118: gc_single_byte_token:
00:C936 A001            	   119:   ldy #1
                        	   120: gc_done:
00:C938 8492            	   121:   sty token_length      ; Y has our length
00:C93A 8593            	   122:   sta token_type        ; A has our type
00:C93C 18              	   123:   clc
00:C93D A58E            	   124:   lda token_start
00:C93F 8590            	   125:   sta token_address     ; save the starting address of the token
00:C941 6592            	   126:   adc token_length      ; now add its length
00:C943 858E            	   127:   sta token_start       ; that gives the ending address
                        	   128: 
00:C945 A58F            	   129:   lda token_start+1     ; repeat for high-order byte
00:C947 8591            	   130:   sta token_address+1
00:C949 6900            	   131:   adc #0
00:C94B 858F            	   132:   sta token_start+1
                        	   133: 
00:C94D A593            	   134:   lda token_type        ; get token type back into A
00:C94F 60              	   135:   rts
                        	   136: 
                        	   137: ;
                        	   138: ;  not a space (or newline) so this must be the actual start of it
                        	   139: ;
                        	   140: 
                        	   141: gc_not_space:
                        	   142: 
                        	   143: ;
                        	   144: ;  first look for classes of characters (ie. alpha, numeric)
                        	   145: ;
00:C950 202681          	   146:   jsr isalpha
00:C953 9026            	   147:   bcc gc_not_alpha
                        	   148: 
                        	   149: ;
                        	   150: ;  find end of identifier
                        	   151: ;
                        	   152: gc_alpha_loop:
00:C955 C8              	   153:   iny
00:C956 D005            	   154:   bne gc_alpha_ok   ; if it becomes zero now, we have 256+ long identifier
00:C958 A20C            	   155:   ldx #12       ; ERROR: Illegal Identifier (too long)
00:C95A 4C6497          	   156:   jmp ERROR
                        	   157: 
                        	   158: gc_alpha_ok:
00:C95D A940            	   159:   lda #FLAG_ONLY_ALPHA
00:C95F 24BE            	   160:   bit system_flags
00:C961 D00F            	   161:   bne gc_alpha_alpha_only
00:C963 B18E            	   162:   lda (token_start),y
00:C965 206281          	   163:   jsr isalnum
00:C968 B0EB            	   164:   bcs gc_alpha_loop
00:C96A C95F            	   165:   cmp #'_'
00:C96C F0E7            	   166:   beq gc_alpha_loop
                        	   167: 
                        	   168: ;
                        	   169: ; end of identifier
                        	   170: ;
                        	   171: gc_alpha_done:
00:C96E A949            	   172:   lda #TOKEN_IDENTIFIER
00:C970 80C6            	   173:   bra gc_done
                        	   174: 
                        	   175: 
                        	   176: gc_alpha_alpha_only:
00:C972 B18E            	   177:   lda (token_start),y
00:C974 202681          	   178:   jsr isalpha
00:C977 B0DC            	   179:   bcs gc_alpha_loop
00:C979 80F3            	   180:   bra gc_alpha_done
                        	   181: 
                        	   182: ;
                        	   183: ; now see if it is a digit
                        	   184: ;
                        	   185: gc_not_alpha:
00:C97B 203281          	   186:   jsr isdigit
00:C97E 9007            	   187:   bcc gc_not_digit
                        	   188: 
00:C980 20E1C9          	   189:   jsr atoi
00:C983 A94E            	   190:   lda  #TOKEN_NUMBER
00:C985 80B1            	   191:   bra  gc_done
                        	   192: 
                        	   193: ;
                        	   194: ;  not alpha and not digit - so let's consider:
                        	   195: ;   * prefixes: $ for hex and % for binary
                        	   196: ;   *  + or - in front of numbers or on their own
                        	   197: ;   * single character tokens, eg. =, (, ) and so on
                        	   198: ;   * double-character tokens, eg. ==, >= << and so on
                        	   199: ;   * strings, eg. "foo"
                        	   200: ;
                        	   201: ;  we'll do a jump on the first character
                        	   202: ;
                        	   203: gc_not_digit:
00:C987 8593            	   204:   sta token_type            ; remember it in case of possible two-byte sequences
00:C989 A26F            	   205:   ldx #<gtoken_table
00:C98B A0CA            	   206:   ldy #>gtoken_table
00:C98D 20928F          	   207:   jsr TKNJMP
00:C990 80A2            	   208:   bra gc_single_byte_already_known  ; it is what it is
                        	   209: 
                        	   210: ;
                        	   211: ;  here when get_token discovers a newline - print the next line if wanted
                        	   212: ;
                        	   213: 
                        	   214: token_line:
                        	   215: ;
                        	   216: ;  count lines
                        	   217: ;
00:C992 E6A2            	   218:   inc current_line
00:C994 D002            	   219:   bne token_line1
00:C996 E6A3            	   220:   inc current_line+1
                        	   221: token_line1:
                        	   222: ;
                        	   223: ;  compiling or assembling?
                        	   224: ;
00:C998 A901            	   225:   lda #FLAG_COMPILING
00:C99A 0902            	   226:   ora #FLAG_ASSEMBLING
00:C99C 25BE            	   227:   and system_flags
00:C99E F040            	   228:   beq token_line_done ; no - no listing
                        	   229: ;
                        	   230: ;  listing wanted?
                        	   231: ;
00:C9A0 A904            	   232:   lda #FLAG_LIST_SOURCE
00:C9A2 25BE            	   233:   and system_flags
00:C9A4 D00D            	   234:   bne token_line_listing ; yes
                        	   235: 
                        	   236: ;
                        	   237: ;  no listing - show an asterisk every 15 lines
                        	   238: ;
00:C9A6 A5A2            	   239:   lda current_line
00:C9A8 290F            	   240:   and #$0F
00:C9AA D034            	   241:   bne token_line_done
00:C9AC A92A            	   242:   lda #'*'
00:C9AE 20AF93          	   243:   jsr COUT
00:C9B1 802D            	   244:   bra token_line_done
                        	   245: 
                        	   246: token_line_listing:
00:C9B3 A52E            	   247:   lda DCODE
00:C9B5 48              	   248:   pha
00:C9B6 A901            	   249:   lda #1
00:C9B8 852E            	   250:   sta DCODE
00:C9BA 204392          	   251:   jsr DISPAD
00:C9BD 68              	   252:   pla
00:C9BE 852E            	   253:   sta DCODE
00:C9C0 201E8C          	   254:   jsr show_current_line_number
                        	   255: 
00:C9C3 A59C            	   256:   lda token_line_start
00:C9C5 8598            	   257:   sta token_work
00:C9C7 A59D            	   258:   lda token_line_start+1
00:C9C9 8599            	   259:   sta token_work+1
                        	   260: 
                        	   261: token_line_loop:
00:C9CB A000            	   262:   ldy #0
00:C9CD B198            	   263:   lda (token_work),Y
00:C9CF F00F            	   264:   beq token_line_done
00:C9D1 48              	   265:   pha
00:C9D2 20AF93          	   266:   jsr COUT
00:C9D5 E698            	   267:   inc token_work
00:C9D7 D002            	   268:   bne token_line_loop1
00:C9D9 E699            	   269:   inc token_work+1
                        	   270: token_line_loop1:
00:C9DB 68              	   271:   pla
00:C9DC C90A            	   272:   cmp #NL
00:C9DE D0EB            	   273:   bne token_line_loop
                        	   274: 
                        	   275: token_line_done:
00:C9E0 60              	   276:   rts
                        	   277: 
                        	   278: 
                        	   279: ;
                        	   280: ;  atoi
                        	   281: ;
                        	   282: ; get a decimal number - returns carry flag set if bad number and running
                        	   283: ;   (if compiling and a bad number gives an error)
                        	   284: ;
                        	   285: ;  token_start : the start address of the number
                        	   286: ;  Y : offset into token_start
                        	   287: ;  token_sign : non-zero if negative
                        	   288: ;
                        	   289: ;  returns: token_value  and carry clear (if no error)
                        	   290: ;           carry set if error (for use at runtime)
                        	   291: ;           Y at offset of first non-numeric character
                        	   292: 
                        	   293: atoi:
00:C9E1 38              	   294:   sec
00:C9E2 E930            	   295:   sbc  #'0'   ;  ; subtract out ASCII stuff, save first digit
00:C9E4 8594            	   296:   sta  token_value
00:C9E6 6495            	   297:   stz  token_value+1
00:C9E8 6496            	   298:   stz  token_value+2
                        	   299: atoi_loop    =  *
00:C9EA C8              	   300:   iny
00:C9EB B18E            	   301:   lda  (token_start),y
00:C9ED 203281          	   302:   jsr  isdigit
00:C9F0 B009            	   303:   bcs  atoi_more      ; more digits
                        	   304: ;
                        	   305: ; end of number - make negative if we got a sign earlier
                        	   306: ;
00:C9F2 A597            	   307:   lda  token_sign
00:C9F4 F003            	   308:   beq  atoi_positive    ; not signed
                        	   309: ;
                        	   310: ;  make negative
                        	   311: ;
00:C9F6 205BCA          	   312:   jsr negate_token_value
                        	   313: ;
                        	   314: ;  done! clear carry and return
                        	   315: ;
                        	   316: atoi_positive:
00:C9F9 18              	   317:   clc                   ; indicate no error for numeric conversion
00:C9FA 60              	   318:   rts
                        	   319: ;
                        	   320: ;  Multiply previous value by 10, add in new digit
                        	   321: ;
                        	   322: atoi_more    =  *
00:C9FB 38              	   323:   sec
00:C9FC E930            	   324:   sbc  #'0'
00:C9FE 859B            	   325:   sta  token_digit
00:CA00 0694            	   326:   asl  token_value         ; multiply token_value by 2
00:CA02 2695            	   327:   rol  token_value+1
00:CA04 2696            	   328:   rol  token_value+2
00:CA06 3048            	   329:   bmi  atoi_error
                        	   330: 
00:CA08 A594            	   331:   lda  token_value         ; save token_value*2 in token_work
00:CA0A 8598            	   332:   sta  token_work
00:CA0C A595            	   333:   lda  token_value+1
00:CA0E 8599            	   334:   sta  token_work+1
00:CA10 A596            	   335:   lda  token_value+2
00:CA12 859A            	   336:   sta  token_work+2
                        	   337: 
00:CA14 0694            	   338:   asl  token_value         ; now token_value is multiplied by 4
00:CA16 2695            	   339:   rol  token_value+1
00:CA18 2696            	   340:   rol  token_value+2
00:CA1A 3034            	   341:   bmi  atoi_error
                        	   342: 
00:CA1C 0694            	   343:   asl  token_value         ; now token_value is multiplied by 8
00:CA1E 2695            	   344:   rol  token_value+1
00:CA20 2696            	   345:   rol  token_value+2
00:CA22 302C            	   346:   bmi  atoi_error
                        	   347: 
00:CA24 A598            	   348:   lda  token_work          ; now add back in token_value*2 (giving token_value*10)
00:CA26 6594            	   349:   adc  token_value
00:CA28 8594            	   350:   sta  token_value
00:CA2A A599            	   351:   lda  token_work+1
00:CA2C 6595            	   352:   adc  token_value+1
00:CA2E 8595            	   353:   sta  token_value+1
00:CA30 A59A            	   354:   lda  token_work+2
00:CA32 6596            	   355:   adc  token_value+2
00:CA34 8596            	   356:   sta  token_value+2
00:CA36 3018            	   357:   bmi  atoi_error      ; if negative, the number was too big
00:CA38 18              	   358:   clc
00:CA39 A594            	   359:   lda  token_value     ; now take the value and add in our new digit
00:CA3B 659B            	   360:   adc  token_digit
00:CA3D 8594            	   361:   sta  token_value
00:CA3F A900            	   362:   lda #0
00:CA41 6595            	   363:   adc  token_value+1   ; increment next byte if necessary
00:CA43 8595            	   364:   sta  token_value+1
00:CA45 A900            	   365:   lda #0
00:CA47 6596            	   366:   adc  token_value+2
00:CA49 8596            	   367:   sta  token_value+2
00:CA4B 3003            	   368:   bmi  atoi_error
00:CA4D 4CEAC9          	   369:   jmp  atoi_loop     ; onwards for next digit
                        	   370: 
                        	   371: atoi_error    =  *
00:CA50 A53F            	   372:   lda  RUNNING
00:CA52 1002            	   373:   bpl  atoi_not_running
00:CA54 38              	   374:   sec             ; otherwise set carry and return
00:CA55 60              	   375:   rts
                        	   376: atoi_not_running  =  *
00:CA56 A21E            	   377:   ldx  #30       ; ERROR: Number out of Range
00:CA58 4C6497          	   378:   jmp  ERROR
                        	   379: 
                        	   380: ;
                        	   381: ;  for negative numbers, subtract token_value from zero
                        	   382: ;
                        	   383: negate_token_value:
00:CA5B 38              	   384:   sec
00:CA5C A900            	   385:   lda  #0
00:CA5E E594            	   386:   sbc  token_value
00:CA60 8594            	   387:   sta  token_value
00:CA62 A900            	   388:   lda  #0
00:CA64 E595            	   389:   sbc  token_value+1
00:CA66 8595            	   390:   sta  token_value+1
00:CA68 A900            	   391:   lda  #0
00:CA6A E596            	   392:   sbc  token_value+2
00:CA6C 8596            	   393:   sta  token_value+2
00:CA6E 60              	   394:   rts
                        	   395: 
                        	   396: 
                        	   397: gtoken_table:
                        	   398:   tknjmpItem '(',gc_lh_paren
00:CA6F 28              	     1M    dfb   '('
00:CA70 B7CA            	     2M    word  gc_lh_paren
                        	   399:   tknjmpItem '{',gc_lh_brace
00:CA72 7B              	     1M    dfb   '{'
00:CA73 B3CA            	     2M    word  gc_lh_brace
                        	   400:   tknjmpItem '"',gc_quote
00:CA75 22              	     1M    dfb   '"'
00:CA76 A6CB            	     2M    word  gc_quote
                        	   401:   tknjmpItem SINGLE_QUOTE,gc_quote
00:CA78 27              	     1M    dfb   SINGLE_QUOTE
00:CA79 A6CB            	     2M    word  gc_quote
                        	   402:   tknjmpItem '$',gc_dollar
00:CA7B 24              	     1M    dfb   '$'
00:CA7C 74CC            	     2M    word  gc_dollar
                        	   403:   tknjmpItem '%',gc_percent
00:CA7E 25              	     1M    dfb   '%'
00:CA7F CECC            	     2M    word  gc_percent
                        	   404:   tknjmpItem ':',gc_colon
00:CA81 3A              	     1M    dfb   ':'
00:CA82 F8CC            	     2M    word  gc_colon
                        	   405:   tknjmpItem '<',gc_less_than
00:CA84 3C              	     1M    dfb   '<'
00:CA85 09CD            	     2M    word  gc_less_than
                        	   406:   tknjmpItem '>',gc_greater_than
00:CA87 3E              	     1M    dfb   '>'
00:CA88 2CCD            	     2M    word  gc_greater_than
                        	   407:   tknjmpItem '-',gc_minus
00:CA8A 2D              	     1M    dfb   '-'
00:CA8B 46CD            	     2M    word  gc_minus
                        	   408:   tknjmpItem '+',gc_plus
00:CA8D 2B              	     1M    dfb   '+'
00:CA8E 48CD            	     2M    word  gc_plus
                        	   409:   tknjmpItem '&',gc_ampersand
00:CA90 26              	     1M    dfb   '&'
00:CA91 67CD            	     2M    word  gc_ampersand
                        	   410:   tknjmpItem '|',gc_bar
00:CA93 7C              	     1M    dfb   '|'
00:CA94 78CD            	     2M    word  gc_bar
                        	   411:   tknjmpItem '=',gc_equals
00:CA96 3D              	     1M    dfb   '='
00:CA97 89CD            	     2M    word  gc_equals
                        	   412:   tknjmpItem '!',gc_bang
00:CA99 21              	     1M    dfb   '!'
00:CA9A 9ACD            	     2M    word  gc_bang
                        	   413:   tknjmpItem ';',gc_semicolon
00:CA9C 3B              	     1M    dfb   ';'
00:CA9D 6DCB            	     2M    word  gc_semicolon
00:CA9F 00              	   414:   dfb        0   ; end of table
                        	   415: 
                        	   416: gtoken_directive_table:
                        	   417:   tknjmpItem 'S',gc_directive_symbols
00:CAA0 53              	     1M    dfb   'S'
00:CAA1 1FCB            	     2M    word  gc_directive_symbols
                        	   418:   tknjmpItem 'L',gc_directive_list
00:CAA3 4C              	     1M    dfb   'L'
00:CAA4 57CB            	     2M    word  gc_directive_list
                        	   419:   tknjmpItem 'P',gc_directive_pcodes
00:CAA6 50              	     1M    dfb   'P'
00:CAA7 5ECB            	     2M    word  gc_directive_pcodes
                        	   420:   tknjmpItem 'N',gc_directive_nolist
00:CAA9 4E              	     1M    dfb   'N'
00:CAAA 64CB            	     2M    word  gc_directive_nolist
00:CAAC 00              	   421:   dfb        0
                        	   422: 
                        	   423: ; single byte token, in A
00:CAAD 4C36C9          	   424: gc_single_byte_tokenJ jmp gc_single_byte_token
                        	   425: ; single byte token in token_type
00:CAB0 4C34C9          	   426: gc_single_byte_already_knownJ jmp gc_single_byte_already_known
                        	   427: 
                        	   428: gc_lh_brace:
00:CAB3 A000            	   429:   ldy #0
00:CAB5 800E            	   430:   bra gc_pascal_comment
                        	   431: gc_lh_paren:
00:CAB7 A902            	   432:   lda #FLAG_ASSEMBLING
00:CAB9 25BE            	   433:   and system_flags
00:CABB D0F3            	   434:   bne gc_single_byte_already_knownJ
00:CABD A001            	   435:   ldy #1
00:CABF B18E            	   436:   lda (token_start),Y
00:CAC1 C92A            	   437:   cmp #'*'      ; was it: (* ?
00:CAC3 D0EB            	   438:   bne gc_single_byte_already_knownJ  ; nope
                        	   439: 
                        	   440: ;
                        	   441: ;  Y will be 0 or 1 depending on the sort of starting comment
                        	   442: ;  first look for % which indicates a compiler directive
                        	   443: ;
                        	   444: gc_pascal_comment:
00:CAC5 C8              	   445:   iny
00:CAC6 B18E            	   446:   lda (token_start),Y
00:CAC8 C925            	   447:   cmp #'%'   ; directive?
00:CACA D018            	   448:   bne gc_pascal_comment_find_end
00:CACC C8              	   449:   iny
00:CACD B18E            	   450:   lda (token_start),Y ; get the directive: S, L, P or N
00:CACF 48              	   451:   pha   ; save the directive for now
00:CAD0 98              	   452:   tya
                        	   453: ;
                        	   454: ;  make token_start point to where we are up to, so we can skip the comment, even if it is long
                        	   455: ;
00:CAD1 38              	   456:   sec               ; I actually want to be one past where the directive letter is
00:CAD2 658E            	   457:   adc token_start
00:CAD4 858E            	   458:   sta token_start
00:CAD6 A900            	   459:   lda #0
00:CAD8 658F            	   460:   adc token_start+1
00:CADA 858F            	   461:   sta token_start+1
00:CADC 68              	   462:   pla   ; get the directive back
00:CADD A2A0            	   463:   ldx #<gtoken_directive_table
00:CADF A0CA            	   464:   ldy #>gtoken_directive_table
00:CAE1 20928F          	   465:   jsr TKNJMP  ; do the directive handler
                        	   466: ;
                        	   467: ;  fall through if not found and just find the end of the comment
                        	   468: ;
                        	   469: 
                        	   470: gc_pascal_comment_find_end:
00:CAE4 A000            	   471:   ldy #0    ; we normalised token_start to be where we want to start
00:CAE6 B18E            	   472:   lda (token_start),Y
00:CAE8 D005            	   473:   bne gc_comment_not_eof
00:CAEA A207            	   474:   ldx  #7           ; NO } FOUND
00:CAEC 4C6497          	   475:   jmp  ERROR
                        	   476: gc_comment_not_eof:
00:CAEF C90A            	   477:   cmp #NL
00:CAF1 D005            	   478:   bne gc_comment_not_newline
00:CAF3 2092C9          	   479:   jsr token_line    ; handle the newline (we can't be assembling or we wouldn't be here)
00:CAF6 800F            	   480:   bra gc_comment_keep_looking
                        	   481: gc_comment_not_newline:
00:CAF8 C97D            	   482:   cmp #'}'
00:CAFA F013            	   483:   beq gc_comment_found_end
00:CAFC C92A            	   484:   cmp #'*'
00:CAFE D007            	   485:   bne gc_comment_keep_looking
00:CB00 C8              	   486:   iny
00:CB01 B18E            	   487:   lda (token_start),Y
00:CB03 C929            	   488:   cmp #')'
00:CB05 F008            	   489:   beq gc_comment_found_end
                        	   490: 
                        	   491: ;
                        	   492: ;  skip this byte and keep looking for the end of comment
                        	   493: ;
                        	   494: gc_comment_keep_looking:
00:CB07 E68E            	   495:   inc token_start
00:CB09 D0D9            	   496:   bne gc_pascal_comment_find_end
00:CB0B E68F            	   497:   inc token_start+1
00:CB0D 80D5            	   498:   bra gc_pascal_comment_find_end
                        	   499: 
                        	   500: ;
                        	   501: ;  found end of comment, so move token_start to this character
                        	   502: ;   (the one past the end of the comment) and try again for a token
                        	   503: ;
                        	   504: gc_comment_found_end:
00:CB0F C8              	   505:   iny   ; get past end of comment
00:CB10 98              	   506:   tya
00:CB11 18              	   507:   clc
00:CB12 658E            	   508:   adc token_start
00:CB14 858E            	   509:   sta token_start
00:CB16 A900            	   510:   lda #0
00:CB18 658F            	   511:   adc token_start+1
00:CB1A 858F            	   512:   sta token_start+1
00:CB1C 4CF6C8          	   513:   jmp get_token_loop
                        	   514: 
                        	   515: ;
                        	   516: ;  {%S $nnnn}
                        	   517: ;  symbol table relocation
                        	   518: ;
                        	   519: gc_directive_symbols:
00:CB1F 20F6C8          	   520:    jsr  get_token_loop     ; re-call get_token to find the address
00:CB22 C94E            	   521:    cmp  #TOKEN_NUMBER ; number?
00:CB24 F005            	   522:    beq  gc_directive_symbols_ok      ; yes
00:CB26 A202            	   523:    ldx  #2
00:CB28 4C6497          	   524:    jmp  ERROR      ; 'Constant expected'
                        	   525: 
                        	   526: gc_directive_symbols_ok:
                        	   527:   ;
                        	   528:   ;  check we haven't generated any code
                        	   529:   ;
00:CB2B A523            	   530:   lda PCODE
00:CB2D C525            	   531:   cmp ACT_PCDA
00:CB2F D021            	   532:   bne gc_directive_symbols_too_late
00:CB31 A524            	   533:   lda PCODE+1
00:CB33 C526            	   534:   cmp ACT_PCDA+1
00:CB35 D01B            	   535:   bne gc_directive_symbols_too_late
                        	   536: 
00:CB37 A594            	   537:   lda  token_value
00:CB39 8531            	   538:   sta  ENDSYM
00:CB3B 852F            	   539:   sta  STARTSYM
00:CB3D 852B            	   540:   sta  OPND
00:CB3F A595            	   541:   lda  token_value+1
00:CB41 8532            	   542:   sta  ENDSYM+1        ; store symbol table address
00:CB43 8530            	   543:   sta  STARTSYM+1
00:CB45 852C            	   544:   sta  OPND+1
00:CB47 A901            	   545:   lda  #PCODE_STACK    ; change runtime stack
00:CB49 2051C7          	   546:   jsr  GENJMP
                        	   547: ;
                        	   548: ;  put the library functions back
                        	   549: ;
00:CB4C 201EC6          	   550:   jsr  add_pascal_library_functions
                        	   551: 
00:CB4F 4CE4CA          	   552:   jmp  gc_pascal_comment_find_end     ; go back and find the end of the comment
                        	   553: ;
                        	   554: 
                        	   555: gc_directive_symbols_too_late:
00:CB52 A233            	   556:   ldx #51        ; code already generated
00:CB54 4C6497          	   557:   JMP  ERROR
                        	   558: 
                        	   559: 
                        	   560: ;
                        	   561: ;  {%L} - list source
                        	   562: ;
                        	   563: gc_directive_list:
00:CB57 A904            	   564:   lda #FLAG_LIST_SOURCE
00:CB59 04BE            	   565:   tsb system_flags
00:CB5B 4CE4CA          	   566:   jmp gc_pascal_comment_find_end
                        	   567: 
                        	   568: ;
                        	   569: ;  {%P} - list source and P-codes
                        	   570: ;
                        	   571: gc_directive_pcodes:
00:CB5E A901            	   572:   lda #1
00:CB60 852E            	   573:   sta DCODE
00:CB62 80F3            	   574:   bra gc_directive_list   ; also list source
                        	   575: ;
                        	   576: ;  {%N} - do not list source or P-codes
                        	   577: ;
                        	   578: gc_directive_nolist:
00:CB64 A904            	   579:   lda #FLAG_LIST_SOURCE
00:CB66 14BE            	   580:   trb system_flags    ; clear both of the above flags
00:CB68 642E            	   581:   stz DCODE
00:CB6A 4CE4CA          	   582:   jmp gc_pascal_comment_find_end
                        	   583: 
                        	   584: ;
                        	   585: ;  semicolons start comments in the assembler
                        	   586: ;
                        	   587: gc_semicolon:
00:CB6D A902            	   588:   lda #FLAG_ASSEMBLING
00:CB6F 25BE            	   589:   and system_flags
00:CB71 D003            	   590:   bne gc_assembler_comment_find_end
00:CB73 4C34C9          	   591:   jmp gc_single_byte_already_known
                        	   592: 
                        	   593: gc_assembler_comment_find_end:
00:CB76 A000            	   594:   ldy #0
00:CB78 B18E            	   595:   lda (token_start),Y
00:CB7A D005            	   596:   bne gc_assembler_comment_not_eof
00:CB7C A90A            	   597:   lda #NL
00:CB7E 8593            	   598:   sta token_type
00:CB80 60              	   599:   rts     ; exit without incrementing token_start
                        	   600: 
                        	   601: gc_assembler_comment_not_eof:
00:CB81 C90A            	   602:   cmp #NL
00:CB83 D003            	   603:   bne gc_assembler_comment_keep_looking
00:CB85 4C36C9          	   604:   jmp gc_single_byte_token
                        	   605: ;
                        	   606: ;  skip this byte and keep looking for the newline at the end of comment
                        	   607: ;
                        	   608: gc_assembler_comment_keep_looking:
00:CB88 E68E            	   609:   inc token_start
00:CB8A D0EA            	   610:   bne gc_assembler_comment_find_end
00:CB8C E68F            	   611:   inc token_start+1
00:CB8E 80E6            	   612:   bra gc_assembler_comment_find_end
                        	   613: 
                        	   614: 
                        	   615: gc_backslash_tokens:
00:CB90 41              	   616:          DFB  'A',$07  ; bell ($07)
00:CB91 07
00:CB92 42              	   617:          DFB  'B',$08  ; backspace ($08)
00:CB93 08
00:CB94 45              	   618:          DFB  'E',$1B  ; escape  (0x1B)
00:CB95 1B
00:CB96 46              	   619:          DFB  'F',$0C  ; formfeed ($0C)
00:CB97 0C
00:CB98 4E              	   620:          DFB  'N',$0A  ; newline  (0x0A)
00:CB99 0A
00:CB9A 52              	   621:          DFB  'R',$0D  ; carriage return (0x0D)
00:CB9B 0D
00:CB9C 54              	   622:          DFB  'T',$09  ; horizontal tab (0x09)
00:CB9D 09
00:CB9E 56              	   623:          DFB  'V',$0B  ; vertical tab (0x0B)
00:CB9F 0B
00:CBA0 5C              	   624:          DFB  $5C,$5C  ; backslash
00:CBA1 5C
00:CBA2 22              	   625:          DFB  '"','"'  ; double quote
00:CBA3 22
00:CBA4 27              	   626:          DFB  SINGLE_QUOTE,SINGLE_QUOTE  ; single quote
00:CBA5 27
                        	   627: gc_backslash_tokens_end = *
                        	   628: gc_backslash_tokens_length = gc_backslash_tokens_end - gc_backslash_tokens
                        	   629: 
                        	   630: ;
                        	   631: ;  quoted string
                        	   632: ;
                        	   633: ;  resolve double quotes and backslash sequences and store it in INBUF
                        	   634: ;
                        	   635: ;
                        	   636: gc_quote:
00:CBA6 8598            	   637:   sta token_work    ; remember which sort
00:CBA8 A000            	   638:   ldy #0            ; back to the start
00:CBAA 6492            	   639:   stz token_length  ; zero-length string so far
00:CBAC A58E            	   640:   lda token_start
00:CBAE 8590            	   641:   sta token_address   ; save the starting address of the token (not that it matters too much)
00:CBB0 A58F            	   642:   lda token_start+1   ; repeat for high-order byte
00:CBB2 8591            	   643:   sta token_address+1
                        	   644: 
                        	   645: gc_quote_loop:
00:CBB4 C8              	   646:   iny                 ; onto next character
00:CBB5 B18E            	   647:   lda (token_start),Y ; get the next character in the string
00:CBB7 F004            	   648:   beq gc_quote_bad
00:CBB9 C90A            	   649:   cmp  #NL
00:CBBB D005            	   650:   bne  gc_quote_loop_not_end_of_line
                        	   651: 
                        	   652: gc_quote_bad:
00:CBBD A208            	   653:   ldx  #8         ; MISSING QUOTE: Incorrect string
00:CBBF 4C6497          	   654:   jmp  ERROR
                        	   655: 
                        	   656: gc_quote_loop_not_end_of_line:
00:CBC2 C598            	   657:   cmp  token_work  ; same as start quote?
00:CBC4 D037            	   658:   bne  gc_quote_not_finished       ; no
00:CBC6 C8              	   659:   iny
00:CBC7 B18E            	   660:   lda (token_start),Y ; see if another quote follows
00:CBC9 C598            	   661:   cmp  token_work
00:CBCB F05A            	   662:   beq  gc_quote_not_backslash      ; embedded quote (ie. two quotes in a row)? Store a single quote symbol
                        	   663:   ;
                        	   664:   ;  here at end of quoted string
                        	   665:   ;
00:CBCD 8498            	   666:   sty  token_work  ; remember how far through our input we are
00:CBCF A003            	   667:   ldy  #3          ; OK, we have the final quote, so is the string <= 3 characters long?
00:CBD1 C492            	   668:   cpy  token_length
00:CBD3 9002            	   669:   bcc  gc_quote_long_string   ; BLT - no
00:CBD5 A492            	   670:   ldy  token_length           ; yes - load its actual length into Y (ie. 0, 1, 2, 3)
                        	   671: gc_quote_long_string:
00:CBD7 88              	   672:   dey      ; zero-relative
00:CBD8 3008            	   673:   bmi  gc_quote_copied_value   ; keep going into the length done
00:CBDA B90002          	   674:   lda  INBUF,Y   ; store the (up to) 3 bytes into VALUE as the token value
00:CBDD 999400          	   675:   sta  token_value,Y
00:CBE0 D0F5            	   676:   bne  gc_quote_long_string   ; keep going until we hit the 0x00 at the end
                        	   677: 
                        	   678: gc_quote_copied_value:
00:CBE2 A592            	   679:   lda  token_length    ; now see how long it is?
00:CBE4 D005            	   680:   bne  gc_quote_done     ; don't allow zero length strings
00:CBE6 A20E            	   681:   ldx  #14        ; BAD STRING: literal string of zero length
00:CBE8 4C6497          	   682:   jmp  ERROR
                        	   683: 
                        	   684: gc_quote_done:
00:CBEB 18              	   685:   clc
00:CBEC A58E            	   686:   lda token_start       ; bump up our token_start address to past the quoted string
00:CBEE 6598            	   687:   adc token_work        ; now add its (actual) length, not the length afer mucking around
00:CBF0 858E            	   688:   sta token_start       ; that gives the ending address
00:CBF2 A58F            	   689:   lda token_start+1   ; repeat for high-order byte
00:CBF4 6900            	   690:   adc #0
00:CBF6 858F            	   691:   sta token_start+1
00:CBF8 A922            	   692:   lda  #TOKEN_STRING   ; it's a string token
00:CBFA 8593            	   693:   sta  token_type
00:CBFC 60              	   694:   rts
                        	   695: 
                        	   696: 
                        	   697: gc_quote_not_finished:
00:CBFD C95C            	   698:   cmp #$5C    ; backslash?
00:CBFF D026            	   699:   bne  gc_quote_not_backslash
                        	   700: ;
                        	   701: ;  backslash - see what follows
                        	   702: ;
00:CC01 C8              	   703:   iny
00:CC02 B18E            	   704:   lda (token_start),Y ; the character after the backslash
00:CC04 F0B7            	   705:   beq gc_quote_bad    ; nothing? bad
00:CC06 20C48F          	   706:   jsr MAKE_UPPER
00:CC09 C958            	   707:   cmp #'X'
00:CC0B F038            	   708:   beq gc_quote_hex_character
00:CC0D A200            	   709:   ldx #0
                        	   710: gc_quote_backslash_loop:
00:CC0F DD90CB          	   711:   cmp gc_backslash_tokens,X
00:CC12 F00F            	   712:   beq gc_quote_found_backslash_character   ; good match
00:CC14 E8              	   713:   inx
00:CC15 E8              	   714:   inx
00:CC16 E016            	   715:   cpx #gc_backslash_tokens_length
00:CC18 90F5            	   716:   bcc gc_quote_backslash_loop
                        	   717: gc_quote_bad_string:
00:CC1A A208            	   718:   ldx #8
00:CC1C 4C6497          	   719:   jmp ERROR   ; ERROR: Incorrect string
                        	   720: 
                        	   721: gc_quote_hex_character_done:
00:CC1F A594            	   722:   lda token_value
00:CC21 8004            	   723:   bra gc_quote_not_backslash
                        	   724: 
                        	   725: gc_quote_found_backslash_character:
00:CC23 E8              	   726:   inx
00:CC24 BD90CB          	   727:   lda gc_backslash_tokens,X  ; get its replacement
                        	   728: 
                        	   729: gc_quote_not_backslash:
00:CC27 A692            	   730:   ldx  token_length
00:CC29 9D0002          	   731:   sta  INBUF,x           ; store it in INBUF
00:CC2C E692            	   732:   inc  token_length
00:CC2E F003            	   733:   beq  gc_quote_too_long
00:CC30 4CB4CB          	   734:   jmp  gc_quote_loop     ; keep adding to string
                        	   735: 
                        	   736: 
                        	   737: gc_quote_too_long:
                        	   738:   ;            string over 255 characters long - error!
00:CC33 A21D            	   739:   ldx   #29  ; ERROR: string literal too big
00:CC35 4C6497          	   740:   jmp  ERROR
                        	   741: 
                        	   742: ;
                        	   743: ;  "fix" a hex digit by making it upper-case, then subtracting 7 if it is A-F
                        	   744: ;   then subtracting '0' so we get a number in the range 0x00 to 0x0F in A
                        	   745: ;
                        	   746: gc_fix_hex:
00:CC38 20C48F          	   747:   jsr  MAKE_UPPER
00:CC3B C941            	   748:   cmp  #'A'
00:CC3D 9002            	   749:   bcc  gc_fix_hex_not_a_to_f
00:CC3F E907            	   750:   sbc  #7
                        	   751: gc_fix_hex_not_a_to_f:
00:CC41 38              	   752:   sec
00:CC42 E930            	   753:   sbc  #'0'
00:CC44 60              	   754:   rts
                        	   755: 
                        	   756: gc_quote_hex_character:
00:CC45 C8              	   757:   iny
00:CC46 F0EB            	   758:   beq  gc_quote_too_long
00:CC48 B18E            	   759:   lda  (token_start),Y ; the character after the backslash
00:CC4A 203E81          	   760:   jsr  isxdigit
00:CC4D 90CB            	   761:   bcc  gc_quote_bad_string  ; what? should be hex
00:CC4F 2038CC          	   762:   jsr  gc_fix_hex
00:CC52 8594            	   763:   sta  token_value  ; first nibble
00:CC54 C8              	   764:   iny
00:CC55 F0DC            	   765:   beq  gc_quote_too_long
00:CC57 B18E            	   766:   lda  (token_start),Y ; a second hex character?
00:CC59 F0BF            	   767:   beq  gc_quote_bad_string
00:CC5B 203E81          	   768:   jsr  isxdigit
00:CC5E 9011            	   769:   bcc  gc_quote_hex_character_one_only
00:CC60 2038CC          	   770:   jsr  gc_fix_hex
00:CC63 0694            	   771:   asl  token_value    ; shift existing value 4 bits left
00:CC65 0694            	   772:   asl  token_value
00:CC67 0694            	   773:   asl  token_value
00:CC69 0694            	   774:   asl  token_value
00:CC6B 0594            	   775:   ora  token_value
00:CC6D 8594            	   776:   sta  token_value
00:CC6F 80AE            	   777:   bra  gc_quote_hex_character_done
                        	   778: 
                        	   779: gc_quote_hex_character_one_only:
00:CC71 88              	   780:   dey         ; undo add since we didn't find another hex character
00:CC72 80AB            	   781:   bra gc_quote_hex_character_done
                        	   782: 
                        	   783: ;
                        	   784: ;  $nnnnnn where nnnnnn is one or more hex digits
                        	   785: ;    if no hex digits, then it is the token '$'
                        	   786: ;
                        	   787: gc_dollar:
00:CC74 A001            	   788:   ldy  #1    ; start with the character after the dollar
00:CC76 B18E            	   789:   lda  (token_start),Y ; followed by a hex character?
00:CC78 203E81          	   790:   jsr  isxdigit
00:CC7B B003            	   791:   bcs  gc_hex_literal
00:CC7D 4C34C9          	   792:   jmp  gc_single_byte_already_known
                        	   793: 
                        	   794: gc_hex_literal:
00:CC80 2038CC          	   795:   jsr gc_fix_hex
00:CC83 8594            	   796:   sta token_value       ; store the first digit
00:CC85 6495            	   797:   stz token_value+1
00:CC87 6496            	   798:   stz token_value+2
                        	   799: gc_hex_loop:
00:CC89 C8              	   800:   iny
00:CC8A B18E            	   801:   lda (token_start),Y ; followed by another hex character?
00:CC8C 203E81          	   802:   jsr isxdigit
00:CC8F 9033            	   803:   bcc gc_hex_done
00:CC91 2038CC          	   804:   jsr gc_fix_hex
                        	   805: ;
                        	   806: ;  shift the existing value left 4 bits to make room for the new nibble
                        	   807: ;
00:CC94 0694            	   808:   asl  token_value        ; token_value shifted left 1 bit
00:CC96 2695            	   809:   rol  token_value+1
00:CC98 2696            	   810:   rol  token_value+2
00:CC9A B02D            	   811:   bcs  gc_hex_too_big
00:CC9C 0694            	   812:   asl  token_value        ; token_value shifted left 2 bits
00:CC9E 2695            	   813:   rol  token_value+1
00:CCA0 2696            	   814:   rol  token_value+2
00:CCA2 B025            	   815:   bcs  gc_hex_too_big
00:CCA4 0694            	   816:   asl  token_value        ; token_value shifted left 3 bits
00:CCA6 2695            	   817:   rol  token_value+1
00:CCA8 2696            	   818:   rol  token_value+2
00:CCAA B01D            	   819:   bcs  gc_hex_too_big
00:CCAC 0694            	   820:   asl  token_value        ; token_value shifted left 4 bits
00:CCAE 2695            	   821:   rol  token_value+1
00:CCB0 2696            	   822:   rol  token_value+2
00:CCB2 B015            	   823:   bcs  gc_hex_too_big
00:CCB4 6594            	   824:   adc  token_value        ; now add in this last digit (carry will be clear)
00:CCB6 8594            	   825:   sta  token_value        ; store the new result
00:CCB8 90CF            	   826:   bcc  gc_hex_loop
00:CCBA E695            	   827:   inc  token_value+1
00:CCBC 90CB            	   828:   bcc  gc_hex_loop
00:CCBE E695            	   829:   inc  token_value+1
00:CCC0 B007            	   830:   bcs  gc_hex_too_big
00:CCC2 80C5            	   831:   bra  gc_hex_loop
                        	   832: 
                        	   833: gc_hex_done:
00:CCC4 A94E            	   834:   lda #TOKEN_NUMBER
00:CCC6 4C38C9          	   835:   jmp gc_done
                        	   836: 
                        	   837: gc_hex_too_big:
00:CCC9 A21E            	   838:   ldx  #30       ; ERROR: Number out of Range
00:CCCB 4C6497          	   839:   jmp  ERROR
                        	   840: 
                        	   841: ;
                        	   842: ;  %nnnnnn where nnnnnn is one or more binary digits
                        	   843: ;    if no binary digits, then it is the token '%'
                        	   844: ;
                        	   845: 
                        	   846: gc_percent:
00:CCCE A001            	   847:   ldy  #1    ; start with the character after the %
00:CCD0 B18E            	   848:   lda  (token_start),Y ; followed by a binary character?
00:CCD2 206E81          	   849:   jsr  isbinary
00:CCD5 B003            	   850:   bcs  gc_binary_literal
00:CCD7 4C34C9          	   851:   jmp  gc_single_byte_already_known
                        	   852: 
                        	   853: gc_binary_literal:
00:CCDA E930            	   854:   sbc #'0'              ; we know carry is set
00:CCDC 8594            	   855:   sta token_value       ; store the first digit
00:CCDE 6495            	   856:   stz token_value+1
00:CCE0 6496            	   857:   stz token_value+2
                        	   858: gc_binary_loop:
00:CCE2 C8              	   859:   iny
00:CCE3 B18E            	   860:   lda (token_start),Y ; followed by another binary character?
00:CCE5 206E81          	   861:   jsr isbinary
00:CCE8 90DA            	   862:   bcc gc_hex_done
00:CCEA E930            	   863:   sbc #'0'              ; we know carry is set
                        	   864: 
00:CCEC 6A              	   865:   ror A   ; get the new bit into Carry
00:CCED 2694            	   866:   rol token_value
00:CCEF 2695            	   867:   rol token_value+1
00:CCF1 2696            	   868:   rol token_value+2
00:CCF3 90ED            	   869:   bcc gc_binary_loop
00:CCF5 4CC9CC          	   870:   jmp gc_hex_too_big   ; number too large
                        	   871: 
                        	   872: ;
                        	   873: ;  token : might be :=
                        	   874: ;
                        	   875: gc_colon:
00:CCF8 A001            	   876:   ldy  #1               ; get the next character
00:CCFA B18E            	   877:   lda  (token_start),Y  ; followed by = ?
00:CCFC C93D            	   878:   cmp  #'='
00:CCFE F003            	   879:   beq  gc_assign
00:CD00 4C34C9          	   880:   jmp  gc_single_byte_already_known
                        	   881: 
                        	   882: gc_assign:
00:CD03 A941            	   883:   lda #TOKEN_ASSIGN
00:CD05 C8              	   884:   iny
00:CD06 4C38C9          	   885:   jmp gc_done
                        	   886: 
                        	   887: ;
                        	   888: ;  token: < might be <=, <>, <<
                        	   889: ;
                        	   890: gc_less_than:
00:CD09 A001            	   891:   ldy  #1               ; get the next character
00:CD0B B18E            	   892:   lda  (token_start),Y  ; followed by = ?
00:CD0D C8              	   893:   iny                   ; make it a 2-byte token
00:CD0E C93D            	   894:   cmp  #'='
00:CD10 F00B            	   895:   beq  gc_leq
00:CD12 C93E            	   896:   cmp  #'>'
00:CD14 F00C            	   897:   beq  gc_neq
00:CD16 C93C            	   898:   cmp  #'<'
00:CD18 F00D            	   899:   beq  gc_shift_left
00:CD1A 4C34C9          	   900:   jmp  gc_single_byte_already_known
                        	   901: 
                        	   902: gc_leq:
00:CD1D A980            	   903:   lda #TOKEN_LEQ
00:CD1F 4C38C9          	   904:   jmp gc_done
                        	   905: 
                        	   906: gc_neq:
00:CD22 A955            	   907:   lda #TOKEN_NEQ
00:CD24 4C38C9          	   908:   jmp gc_done
                        	   909: 
                        	   910: gc_shift_left:
00:CD27 A94C            	   911:   lda #TOKEN_SHIFT_LEFT
00:CD29 4C38C9          	   912:   jmp gc_done
                        	   913: 
                        	   914: ;
                        	   915: ;  token: > might be <>=, >>
                        	   916: ;
                        	   917: gc_greater_than:
00:CD2C A001            	   918:   ldy  #1               ; get the next character
00:CD2E B18E            	   919:   lda  (token_start),Y  ; followed by = ?
00:CD30 C8              	   920:   iny                   ; make it a 2-byte token
00:CD31 C93D            	   921:   cmp  #'='
00:CD33 F007            	   922:   beq  gc_geq
00:CD35 C93E            	   923:   cmp  #'>'
00:CD37 F008            	   924:   beq  gc_shift_right
                        	   925: 
                        	   926: gc_single_byte_already_knownJ2:
00:CD39 4C34C9          	   927:   jmp  gc_single_byte_already_known
                        	   928: 
                        	   929: gc_geq:
00:CD3C A981            	   930:   lda #TOKEN_GEQ
00:CD3E 4C38C9          	   931:   jmp gc_done
                        	   932: 
                        	   933: gc_shift_right:
00:CD41 A952            	   934:   lda #TOKEN_SHIFT_RIGHT
00:CD43 4C38C9          	   935:   jmp gc_done
                        	   936: 
                        	   937: 
                        	   938: ;
                        	   939: ;  minus and plus sign
                        	   940: ;
                        	   941: 
                        	   942: gc_minus:
00:CD46 8597            	   943:   sta token_sign
                        	   944: gc_plus:
                        	   945: 
                        	   946: ;
                        	   947: ;  new stuff - treat a sign as a token on its own if the previous token was one of:
                        	   948: ;    a) a number
                        	   949: ;    b) an identifier
                        	   950: ;    c) a RH bracket
                        	   951: ;
                        	   952: ;  So, for example: 2+3 is three tokens, but 2+-5 is also three, as the -5 becomes one token
                        	   953: ;
00:CD48 A598            	   954:   lda  token_work            ; saved previous token on entry to get_token
00:CD4A C94E            	   955:   cmp  #TOKEN_NUMBER
00:CD4C F0EB            	   956:   beq  gc_single_byte_already_knownJ2
00:CD4E C949            	   957:   cmp  #TOKEN_IDENTIFIER
00:CD50 F0E7            	   958:   beq  gc_single_byte_already_knownJ2
00:CD52 C929            	   959:   cmp  #')'
00:CD54 F0E3            	   960:   beq  gc_single_byte_already_knownJ2
                        	   961: ;
                        	   962: ;  if not, see if this is a signed number (ie. it is directly followed by a digit)
                        	   963: ;
00:CD56 A001            	   964:   ldy  #1               ; get the next character
00:CD58 B18E            	   965:   lda  (token_start),Y  ; followed by a digit?
00:CD5A 203281          	   966:   jsr  isdigit
00:CD5D 90DA            	   967:   bcc  gc_single_byte_already_knownJ2
00:CD5F 20E1C9          	   968:   jsr atoi
00:CD62 A94E            	   969:   lda  #TOKEN_NUMBER
00:CD64 4C38C9          	   970:   jmp  gc_done
                        	   971: 
                        	   972: 
                        	   973: ;
                        	   974: ;  token: & might be &&
                        	   975: ;
                        	   976: gc_ampersand:
00:CD67 A001            	   977:   ldy  #1               ; get the next character
00:CD69 B18E            	   978:   lda  (token_start),Y  ; followed by & ?
00:CD6B C926            	   979:   cmp  #'&'
00:CD6D F003            	   980:   beq  gc_logical_and
00:CD6F 4C34C9          	   981:   jmp  gc_single_byte_already_known
                        	   982: 
                        	   983: gc_logical_and:
00:CD72 A958            	   984:   lda #TOKEN_LOGICAL_AND
00:CD74 C8              	   985:   iny
00:CD75 4C38C9          	   986:   jmp gc_done
                        	   987: 
                        	   988: ;
                        	   989: ;  token: | might be ||
                        	   990: ;
                        	   991: gc_bar:
00:CD78 A001            	   992:   ldy  #1               ; get the next character
00:CD7A B18E            	   993:   lda  (token_start),Y  ; followed by | ?
00:CD7C C97C            	   994:   cmp  #'|'
00:CD7E F003            	   995:   beq  gc_logical_or
00:CD80 4C34C9          	   996:   jmp  gc_single_byte_already_known
                        	   997: 
                        	   998: gc_logical_or:
00:CD83 A959            	   999:   lda #TOKEN_LOGICAL_OR
00:CD85 C8              	  1000:   iny
00:CD86 4C38C9          	  1001:   jmp gc_done
                        	  1002: 
                        	  1003: ;
                        	  1004: ;  token: = might be ==
                        	  1005: ;
                        	  1006: gc_equals:
00:CD89 A001            	  1007:   ldy  #1               ; get the next character
00:CD8B B18E            	  1008:   lda  (token_start),Y  ; followed by = ?
00:CD8D C93D            	  1009:   cmp  #'='
00:CD8F F003            	  1010:   beq  gc_equality
00:CD91 4C34C9          	  1011:   jmp  gc_single_byte_already_known
                        	  1012: 
                        	  1013: gc_equality:
00:CD94 A945            	  1014:   lda #TOKEN_EQUALITY
00:CD96 C8              	  1015:   iny
00:CD97 4C38C9          	  1016:   jmp gc_done
                        	  1017: 
                        	  1018: ;
                        	  1019: ;  token: ! might be !=
                        	  1020: ;
                        	  1021: gc_bang:
00:CD9A A001            	  1022:   ldy  #1               ; get the next character
00:CD9C B18E            	  1023:   lda  (token_start),Y  ; followed by = ?
00:CD9E C93D            	  1024:   cmp  #'='
00:CDA0 F003            	  1025:   beq  gc_inequality
00:CDA2 4C34C9          	  1026:   jmp  gc_single_byte_already_known
                        	  1027: 
                        	  1028: gc_inequality:
00:CDA5 A95A            	  1029:   lda #TOKEN_INEQUALITY
00:CDA7 C8              	  1030:   iny
00:CDA8 4C38C9          	  1031:   jmp gc_done
                        	  1032: 
                        	  1033: 
                        	  1034: 
                        	  1035: ; Pascal tokens
                        	  1036: 
                        	  1037: TOKEN_CONST     = $82
                        	  1038: TOKEN_VAR       = $83
                        	  1039: TOKEN_ARRAY     = $84
                        	  1040: TOKEN_OF        = $85
                        	  1041: TOKEN_PROCEDURE = $86
                        	  1042: TOKEN_FUNCTION  = $87
                        	  1043: TOKEN_BEGIN     = $88
                        	  1044: TOKEN_END       = $89
                        	  1045: TOKEN_OR        = $8A
                        	  1046: TOKEN_DIV       = $8B
                        	  1047: TOKEN_MOD       = $8C
                        	  1048: TOKEN_AND       = $8D
                        	  1049: TOKEN_SHL       = $8E
                        	  1050: TOKEN_SHR       = $8F
                        	  1051: TOKEN_NOT       = $90
                        	  1052: TOKEN_MEM       = $91
                        	  1053: TOKEN_IF        = $92
                        	  1054: TOKEN_THEN      = $93
                        	  1055: TOKEN_ELSE      = $94
                        	  1056: TOKEN_CASE      = $95
                        	  1057: TOKEN_WHILE     = $96
                        	  1058: TOKEN_DO        = $97
                        	  1059: TOKEN_REPEAT    = $98
                        	  1060: TOKEN_UNTIL     = $99
                        	  1061: TOKEN_FOR       = $9A
                        	  1062: TOKEN_TO        = $9B
                        	  1063: TOKEN_DOWNTO    = $9C
                        	  1064: TOKEN_WRITE     = $9D
                        	  1065: TOKEN_READ      = $9E
                        	  1066: TOKEN_CALL      = $9F
                        	  1067: TOKEN_CHAR      = $A1
                        	  1068: TOKEN_MEMC      = $A2
                        	  1069: TOKEN_XOR       = $A4
                        	  1070: TOKEN_ADDRESS   = $A9
                        	  1071: TOKEN_CHR       = $AB
                        	  1072: TOKEN_HEX       = $AC
                        	  1073: ; $B0 to $DE used by message tokens
                        	  1074: TOKEN_LCDWRITE  = $F1
                        	  1075: TOKEN_INTEGER   = $FE
                        	  1076: TOKEN_WRITELN   = $FF
                        	  1077: 
                        	  1078: 
                        	  1079: 
                        	  1080: ; RESERVED WORD TABLE
                        	  1081: ;
                        	  1082: ;***********************************************
                        	  1083:          .macro makeToken  ; MACRO DEFINITION FOR TOKENS: Length, token number, token name
                        	  1084:          DFB  \1
                        	  1085:          DFB  \2
                        	  1086:          text  \3
                        	  1087:          .endmacro           ; END OF MACRO
                        	  1088: 
                        	  1089: ;
                        	  1090: ; Reserved words are identified internally by their code (eg. $86 for PROCEDURE)
                        	  1091: ;
                        	  1092: ;  They are also stored "tokenised" and expanded out when you list the source
                        	  1093: ;
                        	  1094: ; Other tokens are:
                        	  1095: ;  * Punctuation (eg. "<", ">", "=", ".", "(", ")", "$", "+", "-"
                        	  1096: ;  * Identifiers: "I"        (eg. MY_VARIABLE)
                        	  1097: ;  * Constant numbers: "N"   (eg. -1234 and $1234)
                        	  1098: ;  * Literal strings:  '"' (quote symbol)  (eg. "Nick")
                        	  1099: ;  * Double-character punctuation:
                        	  1100: ;       <= : $80
                        	  1101: ;       >= : $81
                        	  1102: ;       Unequal (<>) : "U"
                        	  1103: ;       Assignment (:=) : "A"
                        	  1104: ;
                        	  1105: ; Comments are skipped: (* some comment *)
                        	  1106: ;
                        	  1107: ;
                        	  1108: ; However comments can have compiler directives embedded, eg. (*%A $4000) - put P-codes at $4000
                        	  1109: ;    (*%L*) - list during compile
                        	  1110: ;    (*%N*) - stop listing during compile (cancels %L and %P)
                        	  1111: ;    (*%P*) - show P-codes during compile
                        	  1112: ;    (*%A  $nnnn *) - put P-codes at address $nnnn - must be at START of program
                        	  1113: ;
                        	  1114: ;
                        	  1115: 
                        	  1116: ;              Length   Code             Name
                        	  1117: ;                  --   --------------- ---------------
                        	  1118: RSVWRD   =  *
                        	  1119:    makeToken   5, TOKEN_CONST     ,"CONST"
00:CDAB 05              	     1M          DFB  5
00:CDAC 82              	     2M          DFB  TOKEN_CONST     
00:CDAD 434F4E5354      	     3M          text  "CONST"
                        	  1120:    makeToken   3, TOKEN_VAR       ,"VAR"
00:CDB2 03              	     1M          DFB  3
00:CDB3 83              	     2M          DFB  TOKEN_VAR       
00:CDB4 564152          	     3M          text  "VAR"
                        	  1121:    makeToken   5, TOKEN_ARRAY     ,"ARRAY"
00:CDB7 05              	     1M          DFB  5
00:CDB8 84              	     2M          DFB  TOKEN_ARRAY     
00:CDB9 4152524159      	     3M          text  "ARRAY"
                        	  1122:    makeToken   2, TOKEN_OF        ,"OF"
00:CDBE 02              	     1M          DFB  2
00:CDBF 85              	     2M          DFB  TOKEN_OF        
00:CDC0 4F46            	     3M          text  "OF"
                        	  1123:    makeToken   9, TOKEN_PROCEDURE ,"PROCEDURE"
00:CDC2 09              	     1M          DFB  9
00:CDC3 86              	     2M          DFB  TOKEN_PROCEDURE 
00:CDC4 50524F4345445552	     3M          text  "PROCEDURE"
00:CDCC 45
                        	  1124:    makeToken   8, TOKEN_FUNCTION  ,"FUNCTION"
00:CDCD 08              	     1M          DFB  8
00:CDCE 87              	     2M          DFB  TOKEN_FUNCTION  
00:CDCF 46554E4354494F4E	     3M          text  "FUNCTION"
                        	  1125:    makeToken   5, TOKEN_BEGIN     ,"BEGIN"
00:CDD7 05              	     1M          DFB  5
00:CDD8 88              	     2M          DFB  TOKEN_BEGIN     
00:CDD9 424547494E      	     3M          text  "BEGIN"
                        	  1126:    makeToken   3, TOKEN_END       ,"END"
00:CDDE 03              	     1M          DFB  3
00:CDDF 89              	     2M          DFB  TOKEN_END       
00:CDE0 454E44          	     3M          text  "END"
                        	  1127:    makeToken   2, TOKEN_OR        ,"OR"
00:CDE3 02              	     1M          DFB  2
00:CDE4 8A              	     2M          DFB  TOKEN_OR        
00:CDE5 4F52            	     3M          text  "OR"
                        	  1128:    makeToken   3, TOKEN_DIV       ,"DIV"
00:CDE7 03              	     1M          DFB  3
00:CDE8 8B              	     2M          DFB  TOKEN_DIV       
00:CDE9 444956          	     3M          text  "DIV"
                        	  1129:    makeToken   3, TOKEN_MOD       ,"MOD"
00:CDEC 03              	     1M          DFB  3
00:CDED 8C              	     2M          DFB  TOKEN_MOD       
00:CDEE 4D4F44          	     3M          text  "MOD"
                        	  1130:    makeToken   3, TOKEN_AND       ,"AND"
00:CDF1 03              	     1M          DFB  3
00:CDF2 8D              	     2M          DFB  TOKEN_AND       
00:CDF3 414E44          	     3M          text  "AND"
                        	  1131:    makeToken   3, TOKEN_SHL       ,"SHL"
00:CDF6 03              	     1M          DFB  3
00:CDF7 8E              	     2M          DFB  TOKEN_SHL       
00:CDF8 53484C          	     3M          text  "SHL"
                        	  1132:    makeToken   3, TOKEN_SHR       ,"SHR"
00:CDFB 03              	     1M          DFB  3
00:CDFC 8F              	     2M          DFB  TOKEN_SHR       
00:CDFD 534852          	     3M          text  "SHR"
                        	  1133:    makeToken   3, TOKEN_NOT       ,"NOT"
00:CE00 03              	     1M          DFB  3
00:CE01 90              	     2M          DFB  TOKEN_NOT       
00:CE02 4E4F54          	     3M          text  "NOT"
                        	  1134:    makeToken   3, TOKEN_MEM       ,"MEM"
00:CE05 03              	     1M          DFB  3
00:CE06 91              	     2M          DFB  TOKEN_MEM       
00:CE07 4D454D          	     3M          text  "MEM"
                        	  1135:    makeToken   2, TOKEN_IF        ,"IF"
00:CE0A 02              	     1M          DFB  2
00:CE0B 92              	     2M          DFB  TOKEN_IF        
00:CE0C 4946            	     3M          text  "IF"
                        	  1136:    makeToken   4, TOKEN_THEN      ,"THEN"
00:CE0E 04              	     1M          DFB  4
00:CE0F 93              	     2M          DFB  TOKEN_THEN      
00:CE10 5448454E        	     3M          text  "THEN"
                        	  1137:    makeToken   4, TOKEN_ELSE      ,"ELSE"
00:CE14 04              	     1M          DFB  4
00:CE15 94              	     2M          DFB  TOKEN_ELSE      
00:CE16 454C5345        	     3M          text  "ELSE"
                        	  1138:    makeToken   4, TOKEN_CASE      ,"CASE"
00:CE1A 04              	     1M          DFB  4
00:CE1B 95              	     2M          DFB  TOKEN_CASE      
00:CE1C 43415345        	     3M          text  "CASE"
                        	  1139:    makeToken   5, TOKEN_WHILE     ,"WHILE"
00:CE20 05              	     1M          DFB  5
00:CE21 96              	     2M          DFB  TOKEN_WHILE     
00:CE22 5748494C45      	     3M          text  "WHILE"
                        	  1140:    makeToken   2, TOKEN_DO        ,"DO"
00:CE27 02              	     1M          DFB  2
00:CE28 97              	     2M          DFB  TOKEN_DO        
00:CE29 444F            	     3M          text  "DO"
                        	  1141:    makeToken   6, TOKEN_REPEAT    ,"REPEAT"
00:CE2B 06              	     1M          DFB  6
00:CE2C 98              	     2M          DFB  TOKEN_REPEAT    
00:CE2D 524550454154    	     3M          text  "REPEAT"
                        	  1142:    makeToken   5, TOKEN_UNTIL     ,"UNTIL"
00:CE33 05              	     1M          DFB  5
00:CE34 99              	     2M          DFB  TOKEN_UNTIL     
00:CE35 554E54494C      	     3M          text  "UNTIL"
                        	  1143:    makeToken   3, TOKEN_FOR       ,"FOR"
00:CE3A 03              	     1M          DFB  3
00:CE3B 9A              	     2M          DFB  TOKEN_FOR       
00:CE3C 464F52          	     3M          text  "FOR"
                        	  1144:    makeToken   2, TOKEN_TO        ,"TO"
00:CE3F 02              	     1M          DFB  2
00:CE40 9B              	     2M          DFB  TOKEN_TO        
00:CE41 544F            	     3M          text  "TO"
                        	  1145:    makeToken   6, TOKEN_DOWNTO    ,"DOWNTO"
00:CE43 06              	     1M          DFB  6
00:CE44 9C              	     2M          DFB  TOKEN_DOWNTO    
00:CE45 444F574E544F    	     3M          text  "DOWNTO"
                        	  1146:    makeToken   5, TOKEN_WRITE     ,"WRITE"
00:CE4B 05              	     1M          DFB  5
00:CE4C 9D              	     2M          DFB  TOKEN_WRITE     
00:CE4D 5752495445      	     3M          text  "WRITE"
                        	  1147:    makeToken   4, TOKEN_READ      ,"READ"
00:CE52 04              	     1M          DFB  4
00:CE53 9E              	     2M          DFB  TOKEN_READ      
00:CE54 52454144        	     3M          text  "READ"
                        	  1148:    makeToken   4, TOKEN_CALL      ,"CALL"
00:CE58 04              	     1M          DFB  4
00:CE59 9F              	     2M          DFB  TOKEN_CALL      
00:CE5A 43414C4C        	     3M          text  "CALL"
                        	  1149:    makeToken   4, TOKEN_CHAR      ,"CHAR"
00:CE5E 04              	     1M          DFB  4
00:CE5F A1              	     2M          DFB  TOKEN_CHAR      
00:CE60 43484152        	     3M          text  "CHAR"
                        	  1150:    makeToken   4, TOKEN_MEMC      ,"MEMC"
00:CE64 04              	     1M          DFB  4
00:CE65 A2              	     2M          DFB  TOKEN_MEMC      
00:CE66 4D454D43        	     3M          text  "MEMC"
                        	  1151:    makeToken   3, TOKEN_XOR       ,"XOR"
00:CE6A 03              	     1M          DFB  3
00:CE6B A4              	     2M          DFB  TOKEN_XOR       
00:CE6C 584F52          	     3M          text  "XOR"
                        	  1152:    makeToken   7, TOKEN_ADDRESS   ,"ADDRESS"
00:CE6F 07              	     1M          DFB  7
00:CE70 A9              	     2M          DFB  TOKEN_ADDRESS   
00:CE71 41444452455353  	     3M          text  "ADDRESS"
                        	  1153:    makeToken   3, TOKEN_CHR       ,"CHR"
00:CE78 03              	     1M          DFB  3
00:CE79 AB              	     2M          DFB  TOKEN_CHR       
00:CE7A 434852          	     3M          text  "CHR"
                        	  1154:    makeToken   3, TOKEN_HEX       ,"HEX"
00:CE7D 03              	     1M          DFB  3
00:CE7E AC              	     2M          DFB  TOKEN_HEX       
00:CE7F 484558          	     3M          text  "HEX"
                        	  1155:    makeToken   7, TOKEN_INTEGER   ,"INTEGER"
00:CE82 07              	     1M          DFB  7
00:CE83 FE              	     2M          DFB  TOKEN_INTEGER   
00:CE84 494E5445474552  	     3M          text  "INTEGER"
                        	  1156:    makeToken   7, TOKEN_WRITELN   ,"WRITELN"
00:CE8B 07              	     1M          DFB  7
00:CE8C FF              	     2M          DFB  TOKEN_WRITELN   
00:CE8D 57524954454C4E  	     3M          text  "WRITELN"
                        	  1157:    makeToken   8, TOKEN_LCDWRITE  ,"LCDWRITE"
00:CE94 08              	     1M          DFB  8
00:CE95 F1              	     2M          DFB  TOKEN_LCDWRITE  
00:CE96 4C43445752495445	     3M          text  "LCDWRITE"
                        	  1158: 
                        	  1159: 
00:CE9E 00              	  1160: RSVEND   DFB  0,0        ; END OF TABLE
00:CE9F 00
                        	  1161: ;
                        	  1162: 
                        	  1163: ;
                        	  1164: ;  Pascal get_token
                        	  1165: ;
                        	  1166: ;  Used in the Pascal section. Does a get_token, and then if an identifier is found tries to look
                        	  1167: ;  it up.
                        	  1168: ;
                        	  1169: pas_get_token:
00:CEA0 20F2C8          	  1170:   jsr get_token
00:CEA3 F004            	  1171:   beq pas_get_token_eof   ; branch to make sure Z flag stays set
00:CEA5 C949            	  1172:   cmp #TOKEN_IDENTIFIER
00:CEA7 F001            	  1173:   beq pas_gc_identifier
                        	  1174: pas_get_token_eof:
00:CEA9 60              	  1175:   rts
                        	  1176: ;
                        	  1177: ;  here if get_token got an identifier
                        	  1178: ;
                        	  1179: pas_gc_identifier:
00:CEAA A9AB            	  1180:   lda  #<RSVWRD
00:CEAC 8598            	  1181:   sta  token_work
00:CEAE A9CD            	  1182:   lda  #>RSVWRD
00:CEB0 8599            	  1183:   sta  token_work+1
                        	  1184: pas_gc_loop:
00:CEB2 A000            	  1185:   ldy  #0
00:CEB4 B198            	  1186:   lda  (token_work),Y
00:CEB6 D003            	  1187:   bne  pas_gc_more        ; MORE TO GO
00:CEB8 A949            	  1188:   lda  #TOKEN_IDENTIFIER
00:CEBA 60              	  1189:   rts
                        	  1190: ;
                        	  1191: ; SEARCH for RESERVED WORD
                        	  1192: ;
                        	  1193: pas_gc_more:
00:CEBB B198            	  1194:   lda  (token_work),Y     ; length of word in table
00:CEBD C592            	  1195:   cmp  token_length       ; same?
00:CEBF D022            	  1196:   bne  pas_gc_no_match    ; no - can't be it then
00:CEC1 A8              	  1197:   tay                     ; length
00:CEC2 A590            	  1198:   lda  token_address      ; put token start address into SRCE
00:CEC4 8500            	  1199:   sta  SRCE
00:CEC6 A591            	  1200:   lda  token_address+1
00:CEC8 8501            	  1201:   sta  SRCE+1
00:CECA A598            	  1202:   lda  token_work         ; put current token_work+2 into DEST
00:CECC 18              	  1203:   clc
00:CECD 6902            	  1204:   adc  #2
00:CECF 8503            	  1205:   sta  DEST
00:CED1 A599            	  1206:   lda  token_work+1
00:CED3 6900            	  1207:   adc  #0
00:CED5 8504            	  1208:   sta  DEST+1
00:CED7 200182          	  1209:   jsr  str_ic_compare
00:CEDA D007            	  1210:   bne  pas_gc_no_match      ; NOT FOUND
00:CEDC A001            	  1211:   ldy  #1
00:CEDE B198            	  1212:   lda  (token_work),Y
00:CEE0 8593            	  1213:   sta  token_type
00:CEE2 60              	  1214:   rts
                        	  1215: pas_gc_no_match    =  *
00:CEE3 A000            	  1216:   ldy  #0
00:CEE5 B198            	  1217:   lda  (token_work),Y     ; token_work points to reserved word entry
00:CEE7 18              	  1218:   clc
00:CEE8 6902            	  1219:   adc  #2         ; add 2 to bypass length and code
00:CEEA 6598            	  1220:   adc  token_work
00:CEEC 8598            	  1221:   sta  token_work         ; put it back
00:CEEE 90C2            	  1222:   bcc  pas_gc_loop
00:CEF0 E699            	  1223:   inc  token_work+1       ; handle overflow
00:CEF2 80BE            	  1224:   bra  pas_gc_loop     ; try for another
                        	  1225: 
                        	  1226: 
                        	  1227: 
                        	  1228: ;***********************************************
                        	  1229: ; GET A TOKEN - CHECK THAT IT
                        	  1230: ; IS THE SAME AS IN "A", IF NOT
                        	  1231: ; CALL ERROR "X"
                        	  1232: ;***********************************************
                        	  1233: GETCHK:
00:CEF4 DA              	  1234:   phx   ; save error number
00:CEF5 48              	  1235:   pha   ; save wanted token type
00:CEF6 20A0CE          	  1236:   jsr pas_get_token
00:CEF9 68              	  1237:   pla   ; get it back
00:CEFA C593            	  1238:   cmp token_type
00:CEFC F004            	  1239:   beq CHKOK
00:CEFE FA              	  1240:   plx   ; get error number back
                        	  1241: CHKNOK   =  *
00:CEFF 4C6497          	  1242:   jmp ERROR
                        	  1243: CHKOK    =  *
00:CF02 FA              	  1244:   plx   ; get error number back
00:CF03 60              	  1245:   rts
                        	  1246: 
                        	  1247: ;***********************************************
                        	  1248: ; CHECK TOKEN AGREES WITH "A",
                        	  1249: ; IF NOT, GIVE ERROR "X"
                        	  1250: ;***********************************************
                        	  1251: CHKTKN:
00:CF04 C593            	  1252:   cmp  token_type
00:CF06 D0F7            	  1253:   bne  CHKNOK
00:CF08 60              	  1254:   rts
                        	  1255: 
                        	  1256: ;***********************************************
                        	  1257: ;
                        	  1258: ; GET NEXT TOKEN - MUST BE IDENTIFIER
                        	  1259: ; THEN LOOK IT UP IN SYMBOL TABLE
                        	  1260: ;***********************************************
                        	  1261: 
                        	  1262: GET_LOOK:
00:CF09 A949            	  1263:   lda  #TOKEN_IDENTIFIER
00:CF0B A204            	  1264:   ldx  #4      ; ERROR: Identifier expected
00:CF0D 20F4CE          	  1265:   jsr  GETCHK
00:CF10 4C92B9          	  1266:   jmp  LOOKUP
                        	  1267: 

Source: "gpascal.asm"
                        	   186: 
                        	   187: 
                        	   188:   .if LCD_SUPPORT
00:CF13 4E69636B27732047	   189: LCD_welcome asciiz "Nick's G-Pascal\nCompiler v4.0"
00:CF1B 2D50617363616C0A
00:CF23 436F6D70696C6572
00:CF2B 2076342E30
00:CF30 00
                        	   190:   .endif
                        	   191: 
                        	   192: ;
                        	   193: ; here for cold start - clear text file to null etc. etc.
                        	   194: ;
                        	   195: START    =  *
00:CF31 D8              	   196:   cld             ; cancel decimal mode
00:CF32 78              	   197:   sei             ; no interrupts yet
00:CF33 A2FF            	   198:   ldx  #NEW_STK
00:CF35 9A              	   199:   txs             ; set up stack pointer
00:CF36 8609            	   200:   stx random      ; initialise random numbers
00:CF38 860A            	   201:   stx random+1
00:CF3A 860B            	   202:   stx random+2
00:CF3C 860C            	   203:   stx random+3
00:CF3E 208DC8          	   204:   jsr hardware_init
                        	   205: ;
                        	   206: ;  Put 0x00 at start of source
                        	   207: ;
00:CF41 A900            	   208:   lda  #<TEXT_START
00:CF43 8500            	   209:   sta  REG
00:CF45 A903            	   210:   lda  #>TEXT_START
00:CF47 8501            	   211:   sta  REG+1
00:CF49 A900            	   212:   lda  #0
00:CF4B A8              	   213:   tay
00:CF4C 9100            	   214:   sta  (REG),Y     ; null edit file
00:CF4E 84BE            	   215:   sty  system_flags
00:CF50 AA              	   216:   tax
00:CF51 58              	   217:   cli             ; allow interrupts after a reset
00:CF52 4C5ACF          	   218:   jmp  REST1
                        	   219: ;
                        	   220: RESTART  =  *
00:CF55 A2FF            	   221:   ldx  #NEW_STK
00:CF57 9A              	   222:   txs             ; reset stack
00:CF58 58              	   223:   cli             ; allow interrupts after a NMI
00:CF59 D8              	   224:   cld             ; cancel decimal mode
                        	   225: ;
                        	   226: REST1    =  *
                        	   227:   .if LCD_SUPPORT
                        	   228:     ;
                        	   229:     ;  put message on the LCD screen to prove it is working
                        	   230:     ;
00:CF5A A913            	   231:     lda  #<LCD_welcome  ; G-pascal compiler
00:CF5C A2CF            	   232:     ldx  #>LCD_welcome
00:CF5E 2066B8          	   233:     jsr lcd_print_message
                        	   234:   .endif
                        	   235: 
                        	   236: ;
                        	   237: ;  now direct output to the serial port
                        	   238: ;
00:CF61 2060C8          	   239:   jsr  write_to_serial   ; set up outputting function
00:CF64 A900            	   240:   lda  #0
00:CF66 853F            	   241:   sta  RUNNING
00:CF68 4CC582          	   242:   jmp  main_start    ; go to "shell"
                        	   243: 
                        	   244: 
                        	   245: ;
                        	   246: ;  processor hardware vectors
                        	   247: ;
                        	   248:   .org $FFFA
01:FFFA 55CF            	   249:   .word RESTART   ; non-maskable interrupt (NMI)
01:FFFC 31CF            	   250:   .word START     ; reset vector
01:FFFE 8CB6            	   251:   .word irq       ; maskable interrupt (IRQ)
                        	   252: 


Symbols by name:
ACT_PCDA                         S:0025
ADD1                             E:B952
ADD4                             E:B975
ADD9                             E:B991
ADDSYM                           E:B8F6
ADDSYM_NOT_FULL                  A:B92B
ASS1                             A:BDC3
ASS2                             A:BE0B
ASSARR                           A:BDEA
ASSEMBLE                         A:9842
ASSEMBLE_PASS                    A:9854
ASSEMBLE_SECOND_PASS             A:984F
ASSIGN                           A:BDC0
ASSTB1                           A:BDCF
ASSVAR                           A:BDFC
ASS_COUNT                        S:0072
ASS_EMIT_COUNT                   S:006F
ASS_OPCODE_WORK                  S:0070
ASS_OPERAND                      S:006B
ASS_OPERAND_ABSOLUTE             E:0001
ASS_OPERAND_ABSOLUTE_INDEXED_IN  E:0002
ASS_OPERAND_ABSOLUTE_INDEXED_WI  E:0003
ASS_OPERAND_ABSOLUTE_INDEXED_WI  E:0004
ASS_OPERAND_ABSOLUTE_INDIRECT    E:0005
ASS_OPERAND_ACCUMULATOR_A        E:0006
ASS_OPERAND_IMMEDIATE            E:0007
ASS_OPERAND_IMPLIED              E:0008
ASS_OPERAND_STRING               E:0011
ASS_OPERAND_ZERO_PAGE            E:000B
ASS_OPERAND_ZERO_PAGE_AND_ABSOL  E:0012
ASS_OPERAND_ZERO_PAGE_INDEXED_I  E:000C
ASS_OPERAND_ZERO_PAGE_INDEXED_W  E:000D
ASS_OPERAND_ZERO_PAGE_INDEXED_W  E:000E
ASS_OPERAND_ZERO_PAGE_INDIRECT   E:000F
ASS_OPERAND_ZERO_PAGE_INDIRECT_  E:0010
ASS_PASS                         S:0076
ASS_VALUE                        S:0073
BACKSPACE                        E:0008
BAD_INP                          A:B290
BASE                             S:003B
BAUD_RATE                        E:12C0
BEG                              A:C070
BELL1                            E:AE48
BIT_INTERVAL                     E:00D0
BLCKT1                           A:C291
BLCKT2                           A:C294
BLCKT3                           A:C297
BLK1                             A:C2CC
BLK1A                            A:C2B8
BLK2                             A:C2D4
BLK4                             A:C2DE
BLKB1                            A:C534
BLKB2                            A:C550
BLKB3                            A:C52E
BLKB4                            A:C56C
BLKB5                            A:C55D
BLKB6                            A:C57B
BLKBEG                           A:C524
BLKCN1                           A:C2EB
BLKCNS                           A:C2E8
BLKFNC                           A:C45C
BLKPR1                           A:C47E
BLKPR2                           A:C4B0
BLKPR3                           A:C49A
BLKPR4                           A:C4F8
BLKPR5                           E:C4D1
BLKPR6                           A:C4A7
BLKPRC                           A:C43C
BLKV10                           E:C332
BLKV10_A                         E:C34E
BLKV10_B                         E:C355
BLKV11                           A:C3BC
BLKV12                           A:C3C3
BLKV13                           A:C37D
BLKVAR                           A:C2FF
BLKVR1                           A:C303
BLKVR2                           A:C364
BLKVR3                           A:C424
BLKVR4                           A:C382
BLKVR5                           E:C3E2
BLKVR6                           A:C306
BLKVR7                           A:C310
BLKVR8                           A:C32F
BLKVR9                           E:C3C9
BLOCK                            A:C2A1
BSAVE                            S:0036
CALL                             S:0047
CALLSB                           A:BF9C
CASE                             A:C0DC
CASE1                            A:C115
CASE2                            E:C0EE
CASE3                            A:C12B
CASE4                            A:C121
CASE5                            A:C15E
CASE6                            A:C17C
CASE7                            A:C0EA
CASE8                            A:C191
CASE9                            A:C187
CHKDUP                           A:B99D
CHKGET                           E:C26A
CHKLHB                           E:BA18
CHKLHP                           E:B9FE
CHKNOK                           E:CEFF
CHKOK                            E:CF02
CHKRHB                           E:BA22
CHKRHP                           E:BA05
CHKTKN                           A:CF04
CHK_KBD                          E:AE9C
CHK_NOTD                         A:AEC4
CHK_NOTN                         A:AEA8
CHK_NOTT                         A:AEB6
CHK_RUN                          A:936B
CHK_STAK                         E:BB24
CHK_VAL                          E:9358
CHK_VAL9                         E:936A
CHRIN                            E:C876
CLOCK_RATE                       E:4240
COMPIL                           A:B9AD
COMS8                            A:923A
COMS9                            A:9239
COMSTL                           E:922D
CONDEC                           E:BA3D
CONST                            E:BB30
CONST1                           A:BB47
CONST2                           A:BB51
CONST3                           E:BB4C
CONST9                           A:BB55
COUNT1                           S:004B
COUNT2                           S:004C
COUT                             A:93AF
COUT_CALL                        A:93B9
CR                               E:000D
CROUT                            E:9228
DATA                             S:003D
DATTYP                           S:004A
DB11                             A:AD61
DBGFLG                           S:0049
DCODE                            S:002E
DEBUG                            E:AD61
DEBUG_DONE                       A:ADC9
DEST                             E:0003
DIRECTIVES                       E:9FCB
DIS5                             A:AE31
DIS5_A                           E:AE3B
DISHX                            A:923D
DISP9                            A:C736
DISPAD                           E:9243
DISPAD2                          A:925E
DISPL                            S:0027
DIVBY0                           A:B046
DM1                              A:AD46
DM2                              A:AD4F
DM5                              A:ADF0
DM6                              A:AE05
DM7                              A:AE10
DUP9                             A:B9AC
EFLAG_ALLOW_ZERO_FROM            E:0002
EFLAG_FIND                       E:0010
EFLAG_LOAD                       E:0004
EFLAG_NO_LINE_NUMBERS            E:0080
EFLAG_REPLACE                    E:0020
EFLAG_SAVE                       E:0008
EFLAG_SHOW_LINE                  E:0001
EFLAG_SUPPRESS_NEWLINE           E:0040
EMULATOR                         E:0000
EMULATOR_DEBUG                   A:C88A
ENDSYM                           S:0031
END_CMP                          E:B9FB
END_EDITOR_INPUT                 E:001B
END_PCD                          S:0043
END_WRK                          E:C286
ERR1                             E:9777
ERR3                             E:978B
ERR5                             E:979B
ERR6                             E:97A1
ERR7                             E:976D
ERRLIT                           A:9758
ERRNO                            S:0035
ERROR                            A:9764
EXPR1                            A:BD4C
EXPR2                            A:BD6E
EXPR3                            A:BD74
EXPR4                            A:BD78
EXPR5                            A:BD7C
EXPR6                            A:BD80
EXPR7                            A:BD84
EXPR8                            A:BD70
EXPRES                           A:BD29
EXPTB1                           A:BD39
EXPTB3                           A:BD5B
EX_ABS                           A:B06A
EX_ABSCLL                        E:B2FF
EX_ADD                           A:B006
EX_ADRAC                         E:B4DE
EX_ADRAN                         E:B4D8
EX_ADRN2                         E:B4CD
EX_ADRNC                         E:B4BA
EX_ADRNC2                        E:B4BD
EX_ADRNN                         E:B4CA
EX_AND                           A:B0D8
EX_ASSERT                        A:B571
EX_ASSERT_OK                     A:B586
EX_CLA                           A:B395
EX_CLL                           E:B306
EX_CLL2                          E:B330
EX_CLL3                          E:B351
EX_CLL4                          E:B32C
EX_CLL5                          E:B392
EX_CLL_A                         E:B30E
EX_CLL_JMP                       A:B3B2
EX_DEC                           A:B11A
EX_DELAY                         E:B52D
EX_DIGITALREAD                   E:B4E4
EX_DIGITALREAD_ONE               A:B4EF
EX_DIGITALWRITE                  E:B55C
EX_DIV                           A:B056
EX_DIVIDE_BY_ZERO                A:B03F
EX_EOR                           A:B0E1
EX_EQL                           A:B073
EX_FINISHD                       E:AE66
EX_GEQ                           A:B0AE
EX_GETKEY                        E:B024
EX_GTR                           A:B0A2
EX_INC                           A:B102
EX_INP                           E:B258
EX_INPC                          A:B420
EX_INPC_OK                       A:B42A
EX_INP_OK                        A:B269
EX_INS                           E:B45C
EX_INS1                          E:B47F
EX_INS2                          E:B488
EX_INS3                          E:B466
EX_INS4                          E:B492
EX_INT                           A:B3B5
EX_INVINS                        E:AF19
EX_JM1                           A:B415
EX_JMP                           A:B3F1
EX_JMZ                           A:B404
EX_LATENCY                       A:B51E
EX_LCDCLEAR                      A:B456
EX_LCDHOME                       A:B450
EX_LCDPOS                        E:B4F2
EX_LCDPOS_1                      A:B502
EX_LCD_WRITE_CHR                 A:B43F
EX_LCD_WRITE_HEX                 A:B2B1
EX_LCD_WRITE_NUM                 A:B29D
EX_LCD_WRITE_STR                 A:B2D1
EX_LDA                           A:B176
EX_LDAC                          A:B16B
EX_LDI                           A:B1B1
EX_LDIC                          A:B1AB
EX_LEQ                           A:B0BA
EX_LIB_CALL                      A:B56B
EX_LIT                           A:AFEB
EX_LOD                           A:B155
EX_LOD2                          A:B158
EX_LOD3                          A:B146
EX_LOD3_A                        A:B148
EX_LODC                          A:B143
EX_LSS                           A:B096
EX_MOD                           A:B02B
EX_MOV                           A:B132
EX_MUL                           A:B01B
EX_NEG                           A:AFFD
EX_NEQ                           A:B08D
EX_NEW_STACK                     A:B3DF
EX_NOJUMP                        A:B40F
EX_ORR                           A:B0CF
EX_OUH                           A:B2AC
EX_OUH_COMMON                    A:B2B4
EX_OUS                           E:B2CC
EX_OUS1                          A:B2F0
EX_OUS_COMMON                    A:B2D4
EX_OUT                           A:B298
EX_OUTC                          A:B43A
EX_OUTCR                         E:AEC6
EX_OUTC_COMMON                   A:B442
EX_PINMODE                       E:B54D
EX_RANDOM                        A:B50C
EX_RANDOMSEED                    E:B53D
EX_RTN                           A:B21F
EX_SHL                           A:B0EA
EX_SHR                           A:B0F6
EX_STA                           A:B1D7
EX_STA5                          A:B1E8
EX_STAC                          A:B1ED
EX_STI                           A:B204
EX_STIC                          A:B1F6
EX_STO                           A:B1C4
EX_STO2                          A:B1CA
EX_STO5                          A:B1BF
EX_STOC                          A:B1B7
EX_SUB                           A:B00F
EX_XOR                           A:B0C6
FACAD1                           A:BC77
FACAD2                           A:BC95
FACADR                           E:BCBF
FACERR1                          A:BCD8
FACM2                            A:BCF3
FACMEM                           A:BCE9
FACMMC                           A:BCEF
FACNOT                           A:BCFF
FACNUM                           E:BCDD
FACRND1                          A:BD0A
FACSTR                           A:BCD2
FACTB1                           A:BD10
FACTOR                           A:BC28
FACTQT1                          A:BD16
FALSE                            A:B089
FFLAG_GLOBAL                     E:0002
FFLAG_IGNORE_CASE                E:0001
FFLAG_QUIET                      E:0004
FIN_MSG                          A:AE7D
FIXAD                            E:C77F
FIXAD1                           A:C7BC
FIXM1                            A:C7BD
FIXM2                            A:C7C6
FLAG_ABORTED                     E:0080
FLAG_ASSEMBLING                  E:0002
FLAG_COMPILING                   E:0001
FLAG_LIST_SOURCE                 E:0004
FLAG_ONLY_ALPHA                  E:0040
FLAG_VALID_ASSEMBLE              E:0010
FLAG_VALID_COMPILE               E:0008
FNC1                             A:BFE6
FNC2                             A:BFB6
FNC3                             A:BFE0
FNC4                             A:C02A
FNC5                             A:BFE9
FNC5A                            A:C006
FNC5B                            A:C008
FNC6                             A:C02B
FNCPRC                           A:BFA9
FOR                              A:C197
FOR1                             A:C1A1
FOR2                             A:C1AE
FOR3                             A:C1C7
FOR4                             A:C1F8
FOR5                             A:C23B
FOR6                             A:C25D
FRAME                            S:0020
FROM                             E:0040
GEN1                             E:C6DD
GEN2                             E:C714
GEN2_A                           E:C71F
GEN2_B                           E:C716
GEN2_C                           E:C736
GEN3                             E:C77A
GENADR                           E:C6E1
GENJMP                           E:C751
GENNJM                           A:C74B
GENNJP                           E:C749
GENNOP                           E:C6C8
GENNOP1                          A:BD07
GENNOP2                          A:BF74
GENRJMP                          E:C737
GEN_FULL                         A:C731
GET1                             A:9389
GET1_A                           E:AF70
GET2                             E:AF34
GET3                             A:93A6
GETADR                           A:AF2A
GETADR1                          E:AF55
GETCHK                           A:CEF4
GETEXPR                          E:BABC
GETID2                           A:B19D
GETIDC                           A:B180
GETIDX                           E:B189
GETIN                            E:C876
GETIN1                           A:C880
GETLIT                           E:AFD4
GETLN1                           E:9387
GETLN_OVERFLOW                   A:93AC
GETO_1                           E:BAAD
GETO_2                           E:BABA
GETSUB                           E:BA0F
GET_COMM                         E:BAEE
GET_DAT                          E:BA36
GET_END                          A:AFEA
GET_ITEM                         E:BAF5
GET_LEV                          E:BA2C
GET_LINE                         E:9387
GET_LOOK                         A:CF09
GET_OFF                          E:BA91
HIGHEST_RAM                      E:3FFF
IDENT                            A:BC39
IDENT1                           A:BC3C
IDENT1A                          A:BC44
IDENT2                           A:BC49
IDENT2A                          A:BC62
IDENT3                           A:BC69
IDENT4                           A:BC9D
IDENT4_A                         A:BC9F
IDENT5                           A:BC7F
IDENT5_A                         A:BC81
IDENT6                           A:BC8C
IDENT7                           A:BC92
IF                               A:C030
IF1                              A:C055
IF2                              A:C04E
INBUF                            S:0200
INBUF_SIZE                       E:0100
INIT                             E:91DA
INIT9                            A:9227
INIT_SECOND_PASS                 A:91E6
INP3                             A:B280
INTERP                           E:ADCA
INT_ERR                          E:B3CC
INT_ERRM                         A:B3D3
JMP1                             E:8F9A
JMP2                             E:8FA2
JMP3                             E:8FB7
KEY_ABORT                        E:0003
KEY_DEBUG                        E:0004
KEY_STOP_TRACE                   E:000E
KEY_TRACE                        E:0014
LASTP                            S:004D
LCD_E                            E:0080
LCD_RS                           E:0020
LCD_RW                           E:0040
LCD_SUPPORT                      E:0001
LCD_welcome                      A:CF13
LEVEL                            S:0022
LINE_CNT                         S:0019
LIST                             S:001D
LIT1                             A:AFFA
LOOK1                            A:B99C
LOOKUP                           E:B992
LOWLIT                           A:AECC
LOWLIT1                          A:AED2
MAIN                             A:AEDB
MAINP                            A:AED8
MAIN_1                           E:AF0A
MAIN_2                           E:AEE2
MAIN_NOT_ABORT                   E:AEED
MAIN_OK                          E:AEF0
MAKE_LOWER_DONE                  E:8FD9
MAKE_UPPER                       E:8FC4
MAKE_UPPER_DONE                  E:8FCE
MAX_STK                          E:0020
MCAND                            S:0055
MEM                              A:BF81
MEM2                             A:BF89
MEMC                             A:BF86
NEW_STK                          E:00FF
NL                               E:000A
NOSCE                            A:91C9
NOTIM1                           E:AF1D
OFFSET                           S:0029
ONE_OP                           A:BF6D
ONE_OP2                          A:BF6A
OPCODE                           S:006C
OPCODE_3_CHAR_BRANCH             E:A08F
OPCODE_3_CHAR_IMPLIED            E:A0B4
OPCODE_4_CHAR_BRANCH             E:A03E
OPCODE_4_CHAR_ZERO_PAGE          E:A131
OPCODE_ASS_OPERAND_ABSOLUTE      E:A182
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A1EE
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A1F3
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A238
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A23B
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A260
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A27C
OPCODE_ASS_OPERAND_ABSOLUTE_TOK  E:A1EB
OPCODE_ASS_OPERAND_ACCUMULATOR_  E:A263
OPCODE_ASS_OPERAND_IMMEDIATE     E:A281
OPCODE_ASS_OPERAND_IMMEDIATE_TO  E:A2B2
OPCODE_ASS_OPERAND_ZERO_PAGE     E:A2B5
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A319
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A33A
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A33D
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A386
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A389
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A392
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A3B6
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A3D7
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A3B3
OPCODE_ASS_OPERAND_ZERO_PAGE_TO  E:A316
OPCODE_LEN                       S:006E
OPCODE_LOOKUP_HANDLER            E:0004
OPCODE_LOOKUP_OPCODE_LENGTH      E:0000
OPCODE_LOOKUP_OPCODE_TABLE       E:0002
OPCODE_LOOKUP_OPERAND_TYPE       E:0001
OPCODE_LOOKUP_TABLE              E:9F28
OPCODE_LOOKUP_TABLE_SIZE         E:0006
OPND                             S:002B
OUT_COMMON                       A:B2A0
PAREN                            A:BCE3
PCD_WRKD                         E:BAC2
PCODE                            S:0023
PCODE_ABSCLL                     E:0038
PCODE_ADD                        E:0004
PCODE_ADRAN                      E:000E
PCODE_ADRNN                      E:000C
PCODE_AND                        E:001B
PCODE_CLA                        E:002B
PCODE_CLL                        E:0027
PCODE_DEC                        E:0028
PCODE_DIV                        E:000A
PCODE_EOR                        E:0020
PCODE_EQL                        E:0010
PCODE_FINISHD                    E:0011
PCODE_GEQ                        E:0016
PCODE_GTR                        E:0018
PCODE_INC                        E:0026
PCODE_INP                        E:001C
PCODE_INS                        E:0025
PCODE_INT                        E:003B
PCODE_JM1                        E:003E
PCODE_JMP                        E:003C
PCODE_JMZ                        E:003D
PCODE_LAST                       E:0045
PCODE_LCD_WRITE_CHR              E:0045
PCODE_LCD_WRITE_HEX              E:0044
PCODE_LCD_WRITE_NUM              E:0042
PCODE_LCD_WRITE_STR              E:0043
PCODE_LDA                        E:002E
PCODE_LDI                        E:0030
PCODE_LEQ                        E:0019
PCODE_LIB_CALL                   E:0003
PCODE_LIT                        E:0000
PCODE_LOD                        E:002C
PCODE_LSS                        E:0014
PCODE_MOD                        E:000B
PCODE_MOV                        E:002A
PCODE_MUL                        E:0008
PCODE_NEG                        E:0002
PCODE_NEQ                        E:0012
PCODE_ORR                        E:001A
PCODE_OUH                        E:0021
PCODE_OUS                        E:0023
PCODE_OUT                        E:001E
PCODE_OUTC                       E:001F
PCODE_OUTCR                      E:0040
PCODE_RTN                        E:0029
PCODE_SHL                        E:0022
PCODE_SHR                        E:0024
PCODE_STA                        E:0034
PCODE_STACK                      E:0001
PCODE_STI                        E:0036
PCODE_STO                        E:0032
PCODE_SUB                        E:0006
PCODE_XOR                        E:003A
PRBYTE                           A:929D
PRBYTECR                         E:9352
PRCHAR                           E:9285
PRCITM                           S:0039
PRHEX                            A:92A6
PRHEX1                           A:92B0
PRHEXZ                           A:92A8
PSH1                             E:AFC3
PSH9                             A:9271
PSHPCODE                         E:BA7E
PSHTOP                           E:AFB8
PSHWRK                           E:925F
PT                               A:92B7
PT6                              A:92BF
PUL2_END                         E:AFB1
PULBOTH                          A:AF93
PULTOP                           E:AF71
PULTOP2                          E:AF96
PULWRK                           E:9272
PUL_END                          E:AF8C
PUTSP                            E:92B3
READ                             A:BED8
READ11                           A:BEF8
READ2                            A:BEDE
READ3                            A:BF27
READ3_A                          A:BF56
READ3_B                          A:BF3B
READ7                            A:BF17
READ7_A                          A:BF1D
READ8                            A:BEDB
READ9                            A:BEF5
REG                              E:0000
REG2                             E:0003
REG2B                            E:0005
REGB                             E:0002
REMAIN                           S:0006
REP1                             A:C089
REPEAT                           A:C086
RES                              S:0052
REST1                            E:CF5A
RESTART                          E:CF55
RMNDR                            S:005B
RSVEND                           A:CE9E
RSVWRD                           E:CDAB
RUNERR                           A:AE52
RUNNING                          S:003F
SEA1                             E:B88D
SEA2                             E:B89A
SEA3                             E:B8EE
SEA4                             E:B8E3
SEA5                             E:B8EB
SEARCH                           E:B87A
SEA_NEXT                         E:B882
SERIAL_DEBUG1_MASK               E:0004
SERIAL_DEBUG2_MASK               E:0008
SERIAL_DEBUGGING                 E:0000
SERIAL_DELAY1                    E:0020
SERIAL_DELAY2                    E:0023
SERIAL_OUT_MASK                  E:0002
SERIAL_SPARE2_MASK               E:0010
SIM1                             A:BB72
SIM2                             A:BBBA
SIM3                             A:BB83
SIM4                             A:BB96
SIM5                             A:BBB2
SIM6                             A:BBB6
SIM7                             A:BBAC
SIM8                             A:BBC0
SIMEXP                           E:BB68
SINGLE_QUOTE                     E:0027
SRCE                             E:0000
START                            E:CF31
STARTSYM                         S:002F
START_OF_ROM                     E:8000
START_TRACE                      A:C88B
STK_ERR                          A:BB2B
STK_FULL                         E:BB2B
STMNT                            A:BD88
STMNT1                           A:BD95
STMNT_WRITE_LCD                  A:BE87
STOP_TRACE                       A:C88C
ST_SYMTBL_LIST_CHECK             E:8DA3
ST_SYMTBL_LIST_DONE              E:8E38
ST_SYMTBL_LIST_LINE              E:8DB2
ST_SYMTBL_LIST_NAME              E:8E27
ST_SYMTBL_LIST_NEXT              E:8D98
SYMARG                           E:0006
SYMBOL_ARRAY                     E:0041
SYMBOL_CONSTANT                  E:0043
SYMBOL_FUNCTION                  E:0046
SYMBOL_FUNCTION_RETURN           E:0059
SYMBOL_LIBRARY_FUNCTION          E:0052
SYMBOL_LIBRARY_PROCEDURE         E:0051
SYMBOL_PROCEDURE                 E:0050
SYMBOL_TABLE_START               E:3FFF
SYMBOL_VARIABLE                  E:0056
SYMDAT                           E:0008
SYMDSP                           E:0004
SYMITM                           S:0040
SYMLEN                           E:0009
SYMLVL                           E:0002
SYMNAM                           E:000A
SYMPRV                           E:0000
SYMSUB                           E:0006
SYMTYP                           E:0003
SYMWRK                           E:BA68
SYM_FULL                         A:B8F1
SYNTAX                           S:0042
T                                E:0031
TEMP                             S:0045
TERM                             A:BBDA
TERM1                            A:BBE7
TERM2                            A:BBDD
TERM3                            A:BBF8
TERM4                            A:BBF6
TERM5                            A:BBFE
TERM6                            A:BC02
TERM7                            A:BC06
TERM8                            A:BC0A
TERM9                            A:BC0E
TERMT1                           A:BBC4
TERMT3                           A:BC12
TEXT_START                       E:0300
TKNJMP                           E:8F92
TKNWRK                           E:92C9
TOKEN_ADDRESS                    E:00A9
TOKEN_AND                        E:008D
TOKEN_ARRAY                      E:0084
TOKEN_ASSIGN                     E:0041
TOKEN_BEGIN                      E:0088
TOKEN_CALL                       E:009F
TOKEN_CASE                       E:0095
TOKEN_CHAR                       E:00A1
TOKEN_CHR                        E:00AB
TOKEN_CONST                      E:0082
TOKEN_DIV                        E:008B
TOKEN_DO                         E:0097
TOKEN_DOWNTO                     E:009C
TOKEN_ELSE                       E:0094
TOKEN_END                        E:0089
TOKEN_EQUALITY                   E:0045
TOKEN_FOR                        E:009A
TOKEN_FUNCTION                   E:0087
TOKEN_GEQ                        E:0081
TOKEN_HEX                        E:00AC
TOKEN_HIGH_BYTE                  E:0057
TOKEN_IDENTIFIER                 E:0049
TOKEN_IF                         E:0092
TOKEN_INEQUALITY                 E:005A
TOKEN_INTEGER                    E:00FE
TOKEN_LCDWRITE                   E:00F1
TOKEN_LEQ                        E:0080
TOKEN_LOGICAL_AND                E:0058
TOKEN_LOGICAL_OR                 E:0059
TOKEN_LOW_BYTE                   E:0056
TOKEN_MEM                        E:0091
TOKEN_MEMC                       E:00A2
TOKEN_MOD                        E:008C
TOKEN_NEQ                        E:0055
TOKEN_NOT                        E:0090
TOKEN_NUMBER                     E:004E
TOKEN_OF                         E:0085
TOKEN_OR                         E:008A
TOKEN_PROCEDURE                  E:0086
TOKEN_READ                       E:009E
TOKEN_REPEAT                     E:0098
TOKEN_SHIFT_LEFT                 E:004C
TOKEN_SHIFT_RIGHT                E:0052
TOKEN_SHL                        E:008E
TOKEN_SHR                        E:008F
TOKEN_STRING                     E:0022
TOKEN_THEN                       E:0093
TOKEN_TO                         E:009B
TOKEN_UNARY_MINUS                E:004D
TOKEN_UNTIL                      E:0099
TOKEN_VAR                        E:0083
TOKEN_WHILE                      E:0096
TOKEN_WRITE                      E:009D
TOKEN_WRITELN                    E:00FF
TOKEN_XOR                        E:00A4
TRUE                             A:B07C
TRUE2                            A:B07E
TWO_OP                           A:BF64
VALUE                            S:0000
VALUE2                           S:0003
VAL_1                            E:BB04
VAL_2                            E:BB09
VAL_3                            E:BB12
VAL_5                            E:BB1B
VAL_MOVE                         E:BAFB
VAL_WRK                          E:C27B
VARDEC                           A:BB56
VIA_ACR                          E:7FFB
VIA_DDRA                         E:7FF3
VIA_DDRB                         E:7FF2
VIA_FLAG_CB2                     E:0008
VIA_FLAG_DISABLE                 E:0000
VIA_FLAG_ENABLE                  E:0080
VIA_FLAG_TIMER1                  E:0040
VIA_IER                          E:7FFE
VIA_IFR                          E:7FFD
VIA_PORTA                        E:7FF1
VIA_PORTB                        E:7FF0
VIA_T1C_H                        E:7FF5
VIA_T1C_L                        E:7FF4
WAIT_1                           A:BF77
WHILE                            A:C0AA
WORK                             S:0037
WORKD                            S:0033
WRIT1                            E:BE62
WRIT10                           A:BE55
WRIT2                            A:BE52
WRIT5                            A:BE72
WRIT9                            A:BE39
WRITE                            A:BE36
WRITELN                          A:BE27
WRITELN9                         E:BE31
WRITE_LCD1                       E:BEB3
WRITE_LCD2                       A:BEA3
WRITE_LCD5                       A:BEC3
WRITE_LCD9                       A:BE8A
WRITE_LCD_STRING                 E:BE99
WRITE_LDC_CHR                    E:BECC
WRITE_LDC_CHR1                   E:BECE
WRITE_LDC_HEX                    E:BED4
WRKD_WRK                         E:BAD8
WRKSYM                           E:BA73
WRKTKN                           E:92D4
WRK_OPND                         E:BACD
WRK_VAL                          E:C270
WRK_WRKD                         E:BAE3
W_CHR                            E:BE7B
W_CHR1                           E:BE7D
W_HEX                            E:BE83
W_STRING                         E:BE48
ZERRES                           A:ABDC
a_equals_message                 A:B5A4
add_assembler_library_functions  A:A9F8
add_assembler_library_functions  A:AA42
add_assembler_library_functions  A:AA00
add_assembler_library_functions  A:AA10
add_pascal_library_functions     A:C61E
add_pascal_library_functions_do  A:C677
add_pascal_library_functions_lo  A:C626
add_pascal_library_functions_na  A:C636
asm_do_asc                       E:A43F
asm_do_asc_loop                  A:A44C
asm_do_asc_next                  A:A455
asm_do_asc_ok                    A:A44A
asm_do_assert                    A:A3DA
asm_do_assert_failed             A:A3E9
asm_do_blk                       A:A511
asm_do_blk_done                  A:A52E
asm_do_blk_loop                  A:A521
asm_do_constant_expected         A:A486
asm_do_constant_expectedJ        A:A3EE
asm_do_constant_expectedJ2       A:A547
asm_do_dfb                       A:A494
asm_do_dfb_multiple              A:A4A2
asm_do_dfb_multiple_done         A:A4C0
asm_do_dfb_multiple_loop         A:A4AF
asm_do_dfb_too_big               A:A4C1
asm_do_dfw                       A:A4D4
asm_do_dfw_multiple              A:A4E2
asm_do_dfw_multiple_done         A:A501
asm_do_dfw_multiple_loop         A:A4F0
asm_do_equ                       A:A463
asm_do_equ_have_label            A:A474
asm_do_list                      E:A3F1
asm_do_list1                     A:A42F
asm_do_list_first_pass           A:A43E
asm_do_list_no_operand           A:A411
asm_do_list_not                  A:A42B
asm_do_list_ok                   A:A415
asm_do_nolist                    A:A400
asm_do_nolist_ok                 A:A40B
asm_do_org                       A:A480
asm_do_org_ok                    A:A48B
asm_do_reserve                   A:A52F
asm_do_string                    A:A45A
asm_do_sym                       A:A54A
asm_do_sym_done                  A:A563
asm_emit_one_byte                A:A4C6
asm_emit_two_bytes               A:A502
ass_absolute_another_value       A:9ACB
ass_added_symbol                 A:9900
ass_already_emitted              A:9E99
ass_bad_identifier               A:98BB
ass_bad_indirect                 A:9A32
ass_bad_zp_indirect_indexed      A:9A6C
ass_branch_backwards             A:9EE4
ass_branch_ok                    A:9EE8
ass_branch_out_of_range          A:9EEE
ass_check_label_changed          A:996E
ass_check_no_more_tokens         A:9BC6
ass_check_no_more_tokens_ok      A:9BD5
ass_check_we_have_x_or_y         A:9A73
ass_check_we_have_x_or_y_ok      A:9A8F
ass_current_label                S:0083
ass_done                         A:9B83
ass_done1                        A:9BA5
ass_done_jump                    A:9879
ass_done_message                 A:9BA8
ass_done_second_pass             A:9B8D
ass_emit                         A:9E76
ass_emit1                        A:9EB1
ass_emit2                        A:9E8A
ass_emit3                        A:9EAB
ass_emit4                        A:9EA4
ass_emit_absolute                A:9F1D
ass_emit_bytes                   S:0077
ass_emit_immediate               A:9F0A
ass_emit_immediate_too_high      A:9F18
ass_emit_zero_page               A:9EF7
ass_emit_zero_page_too_high      A:9F05
ass_error                        A:9EB4
ass_error1                       A:9EBB
ass_evaluate_operator            A:9E4F
ass_expression_apply_operator    A:9E0E
ass_expression_apply_operator_b  A:9E4A
ass_expression_cannot_be_unary   A:9DBA
ass_expression_found_value       A:9D48
ass_expression_loop              A:9CFB
ass_expression_loop1             A:9D2C
ass_expression_loop1a            A:9D15
ass_expression_loop2             A:9D59
ass_expression_loop3             A:9D68
ass_expression_loop3a            A:9D77
ass_expression_loop3b            A:9D6C
ass_expression_loop3c            A:9D7C
ass_expression_loop4             A:9D82
ass_expression_loop6             A:9DE0
ass_expression_loop7             A:9DC9
ass_expression_loopJ             A:9D7F
ass_expression_loop_initial      A:9CFE
ass_expression_not_small_string  A:9D27
ass_expression_number            A:9D02
ass_expression_unary             A:9E37
ass_finish_line                  A:986E
ass_finish_lineJ                 A:9998
ass_finish_lineJ2                A:991A
ass_fixup_bbr_branch             A:9EBE
ass_fixup_branch                 A:9ECB
ass_get_value                    A:9CE1
ass_identifier                   A:98C0
ass_identifier_operand           A:99D6
ass_illegal_opcode               A:9925
ass_immediate                    A:99BA
ass_indexed                      A:9AA4
ass_indexed_x                    A:9AC2
ass_indirect                     A:99CD
ass_indirect_with_bracket        A:9A37
ass_label_not_found_yet          A:9D40
ass_line                         A:987C
ass_line1                        A:988B
ass_lookup_existing_label        A:98EA
ass_lookup_loop                  A:9E52
ass_lookup_save_address          A:98F4
ass_no_operand                   A:998E
ass_not_colon                    A:9912
ass_not_colon2                   A:991D
ass_not_unary_greater_than       A:9DA4
ass_not_unary_less_than          A:9D9A
ass_not_unary_minus              A:9D90
ass_not_x_or_y                   A:9A71
ass_opcode                       A:992D
ass_opcode2                      A:9983
ass_opcode_found                 A:9E70
ass_operand                      A:999B
ass_operand_value                A:99F7
ass_string                       A:99AD
ass_symbol_address_changed       A:997E
ass_value_done                   A:9A9B
ass_value_not_indirect           A:9A91
ass_value_not_indirectJ          A:9A2F
ass_zp_indirect_indexed          A:9A4B
assembler_library_functions_tab  A:A5C4
assertion_failed_message         A:971E
assign_bad_identifier            A:BDE5
atoi                             A:C9E1
atoi_error                       E:CA50
atoi_loop                        E:C9EA
atoi_more                        E:C9FB
atoi_not_running                 E:CA56
atoi_positive                    A:C9F9
bad_command                      A:82A2
bad_delimiter_message            A:86A7
bad_flag_message                 A:8811
bcd_output_digit                 A:9170
bcd_positive                     A:915E
bcd_result                       S:0060
bcd_skip_zeroes                  A:9165
bcd_table                        E:90F2
bcd_unpack                       A:90DF
bcd_work                         S:005C
binary_to_decimal                A:917B
binary_to_decimal_loop           A:9186
binary_to_decimal_next           A:91AB
break_message                    A:B589
brk_address                      S:0015
brk_executed                     A:B5D5
brk_executed1                    A:B650
brk_executed2                    A:B65D
brk_executed3                    A:B66D
brk_executedJ                    A:B689
brk_resumed                      A:8CA6
bytes_message                    A:907B
call_a                           S:0010
call_assembler                   A:937D
call_handler                     A:8F4A
call_p                           S:0013
call_s                           S:0014
call_x                           S:0011
call_y                           S:0012
cb2_interrupt                    A:B6B1
character_types_table            E:8006
compile_finished_message         A:92F2
crc16                            E:8FFD
crc16_loop                       E:9009
crc16_next                       A:9016
crc16_skip                       A:901C
crc_addr                         E:0000
crc_byte                         E:9025
crc_done                         A:9024
crc_helper1                      A:9055
crc_message                      A:9058
crc_num                          E:0003
crc_source                       E:9083
crc_val                          E:0006
current_line                     S:00A2
delay                            E:90D5
delay_1ms                        E:90CB
delay_1ms_loop                   A:90CE
digitalread                      E:C843
digitalread_B                    A:C852
digitalread_C                    A:C85A
digitalwrite                     E:C814
digitalwrite_B                   A:C825
digitalwrite_C                   A:C82D
digitalwrite_ONE                 A:C83B
display_in_decimal               E:9152
display_x_characters             A:AE2A
editor_assemble                  A:8F07
editor_bad_delimiter             A:86B6
editor_bad_number                A:856D
editor_bad_range                 A:8614
editor_check_no_more             A:8638
editor_check_no_more_ok          A:8647
editor_compile                   A:8E91
editor_debug                     A:8E73
editor_default_range             A:854F
editor_delete                    A:8B6E
editor_delete_have_range         A:8B90
editor_delete_line_count_done    A:8BE9
editor_delete_line_count_loop    A:8BC9
editor_delete_line_count_not_do  A:8BD5
editor_delete_line_count_not_ne  A:8BE1
editor_do_replace                A:8986
editor_do_replace_copy_done      A:89CB
editor_do_replace_smaller        A:89C8
editor_do_the_replace            A:88EC
editor_easy_replace              A:88F9
editor_easy_replace_done         A:890A
editor_easy_replace_loop         A:88FD
editor_find                      A:873B
editor_find_bug                  A:8779
editor_find_case_sensitive       A:88AA
editor_find_found_it             A:88CE
editor_find_found_it1            A:88D4
editor_find_get_flags            A:87D3
editor_find_inner_loop           A:8893
editor_find_loop                 A:888F
editor_find_no_match             A:88B8
editor_find_or_replacing         A:888B
editor_find_problem              A:86BA
editor_find_second_delimiter_lo  A:8786
editor_find_skip_this            A:88B4
editor_find_test_character       A:88AB
editor_find_third_delimiter_loo  A:87AD
editor_flags                     S:00BC
editor_flags1                    A:87F3
editor_flags2                    A:87FD
editor_flags3                    A:8807
editor_flags_loop                A:87D5
editor_get_delimiter             A:86E4
editor_get_number                A:8577
editor_get_number_done           A:85D8
editor_get_number_none           A:85DA
editor_get_number_not_identifie  A:85B2
editor_get_number_ok             A:85C8
editor_get_range                 A:8648
editor_get_range_done            A:8692
editor_get_range_hyphen          A:867A
editor_get_range_number          A:867F
editor_handlers                  A:8330
editor_help                      A:8533
editor_help_done                 A:854C
editor_help_info                 A:83BE
editor_help_loop                 A:853B
editor_info                      E:8E85
editor_insert                    A:89FA
editor_insert_at_start           A:8A16
editor_insert_backspace          A:8AB3
editor_insert_backspace_not_at_  A:8ABF
editor_insert_common             A:8A24
editor_insert_done               A:8AD2
editor_insert_done_with_newline  A:8AE4
editor_insert_loop               A:8A63
editor_insert_loop1              A:8AA3
editor_insert_no_line_number     A:8A74
editor_insert_not_newline        A:8A99
editor_line_number_too_big       A:85FB
editor_list                      A:8747
editor_list_aborted              A:887E
editor_list_check_to_line        A:893A
editor_list_check_to_line_ok     A:894A
editor_list_completely_done      A:8983
editor_list_doing_find           A:876D
editor_list_done                 A:8966
editor_list_doneJ                A:8851
editor_list_fix_target_string    A:881F
editor_list_fixup_loop           A:8827
editor_list_get_on_with_it       A:883A
editor_list_got_from_point       A:8784
editor_list_have_source          A:884B
editor_list_loop                 A:8857
editor_list_loopJ                A:8963
editor_list_no_line_number       A:8928
editor_list_no_line_numberJ      A:8854
editor_list_not_find             A:8837
editor_list_not_finding          A:891B
editor_list_not_newline          A:8952
editor_list_skip_newline         A:895D
editor_load                      A:89F6
editor_memory                    A:8CCC
editor_memory_aborted            A:8D39
editor_memory_ascii              A:8D41
editor_memory_done               A:8D36
editor_memory_loop               A:8CE3
editor_memory_loop1              A:8D04
editor_memory_loop2              A:8D16
editor_memory_loop3              A:8D26
editor_memory_not_control        A:8D49
editor_memory_not_high           A:8D4F
editor_memory_show_ascii         A:8D3F
editor_memory_show_dot           A:8D4D
editor_newline_processing        A:8930
editor_no_closing_delimiter      A:8712
editor_no_closing_delimiterJ     A:8781
editor_no_closing_delimiter_mes  A:86FC
editor_no_find_string            A:872D
editor_no_lines                  A:8B17
editor_recover                   A:8E4D
editor_recover_not_needed        A:8E69
editor_replace                   A:8733
editor_replacement_loop          A:888D
editor_run                       A:8E9F
editor_save                      A:8741
editor_syntax                    A:8E98
editor_test                      A:8CBA
editor_too_full                  A:8AFF
editor_too_full_loop             A:8B06
editor_trace                     A:8E7C
error1                           A:97BB
error_find_next                  A:97B2
error_found                      A:97DC
error_loop                       A:97AE
error_next                       A:97AD
error_not_found                  A:97C4
error_not_found_message          A:97E9
errors_table                     A:93BC
ex_input_aborted                 A:B4B3
execution_aborted_message        A:B49F
execution_address_table          E:ACBA
exp_abs_val                      A:ABAC
exp_abs_val2                     A:ABC4
exp_abs_val2_done                A:ABDB
exp_abs_val_done                 A:ABC3
exp_add                          A:AA43
exp_bitwise_and                  A:AAE6
exp_bitwise_or                   A:AAD1
exp_bitwise_xor                  A:AAFB
exp_divide                       A:AC4A
exp_divide_loop                  A:AC67
exp_divide_not_zero              A:AC5A
exp_divide_subtraction_negative  A:AC8F
exp_divide_subtraction_positive  A:AC90
exp_done                         A:9DF1
exp_done_error                   A:9DF7
exp_done_ok                      A:9DFC
exp_eql                          A:AA7D
exp_evaluation_function          S:007F
exp_false                        A:AA76
exp_falseJ                       A:AB13
exp_find_sign                    A:ABE5
exp_fix_sign                     A:ABFD
exp_fix_sign_done                A:AC10
exp_geq                          A:AACA
exp_get_operator                 A:9C4C
exp_get_operator_ok              A:9C55
exp_get_precedence               A:9CBA
exp_get_precedence_found         A:9CD0
exp_get_precedence_loop          A:9CBC
exp_greater_than                 A:AAAC
exp_high_byte                    A:ABA3
exp_leq                          A:AABB
exp_less_than                    A:AAA5
exp_logical_and                  A:AB25
exp_logical_or                   A:AB16
exp_low_byte                     A:AB9E
exp_modulo                       A:ACAA
exp_multiply                     A:AC11
exp_multiply_loop                A:AC16
exp_multiply_no_add              A:AC37
exp_negate                       A:AB69
exp_negate_val                   A:ABB0
exp_negate_val2                  A:ABC8
exp_neq                          A:AA91
exp_no_operators_left            A:9DE8
exp_not                          A:AB7C
exp_operator                     S:007D
exp_operator_precedence          S:007E
exp_operator_stack_count         S:007C
exp_pop_operator                 A:9C3C
exp_pop_operator_ok              A:9C45
exp_pop_value                    E:9C01
exp_pop_value_ok                 A:9C0A
exp_precedence_table             A:9C5A
exp_precedence_table_end         E:9CBA
exp_push_operator                A:9C2A
exp_push_operator_ok             A:9C35
exp_push_value                   E:9BD6
exp_push_value_memory_full       A:9BDC
exp_push_value_not_full          A:9BF0
exp_push_value_ok                A:9BE1
exp_shift_left                   A:AB37
exp_shift_left_done              A:AB4F
exp_shift_left_loop              A:AB46
exp_shift_right                  A:AB50
exp_shift_right_done             A:AB68
exp_shift_right_loop             A:AB5F
exp_subtract                     A:AA57
exp_true                         A:AA6D
exp_trueJ                        A:AB10
exp_unary_minus                  A:AB8A
exp_unary_ok                     S:0081
exp_value_stack                  S:0079
exp_value_stack_count            S:007B
find_count                       S:00B9
find_delimiter                   S:00B4
find_flags                       S:00BD
find_from                        S:00B0
find_len                         S:00B3
find_line                        A:8C55
find_line_eof                    A:8C88
find_line_loop                   A:8C63
find_line_next                   A:8C72
find_line_same_line              A:8C80
find_pos                         S:00B2
find_source_end                  A:8C89
find_source_end_done             E:8CA5
find_source_end_loop             E:8C91
find_source_end_wrap             E:8C9F
find_string_too_long             A:86DE
find_string_too_longJ            A:877E
find_string_too_long_message     A:86C0
find_to                          S:00B1
found_message                    A:8693
found_this_line                  S:00BB
from_line                        S:009E
from_msg                         A:869B
gc_alpha_alpha_only              A:C972
gc_alpha_done                    A:C96E
gc_alpha_loop                    A:C955
gc_alpha_ok                      A:C95D
gc_ampersand                     A:CD67
gc_assembler_comment_find_end    A:CB76
gc_assembler_comment_keep_looki  A:CB88
gc_assembler_comment_not_eof     A:CB81
gc_assign                        A:CD03
gc_backslash_tokens              A:CB90
gc_backslash_tokens_end          E:CBA6
gc_backslash_tokens_length       E:0016
gc_bang                          A:CD9A
gc_bar                           A:CD78
gc_binary_literal                A:CCDA
gc_binary_loop                   A:CCE2
gc_colon                         A:CCF8
gc_comment_found_end             A:CB0F
gc_comment_keep_looking          A:CB07
gc_comment_not_eof               A:CAEF
gc_comment_not_newline           A:CAF8
gc_directive_list                A:CB57
gc_directive_nolist              A:CB64
gc_directive_pcodes              A:CB5E
gc_directive_symbols             A:CB1F
gc_directive_symbols_ok          A:CB2B
gc_directive_symbols_too_late    A:CB52
gc_dollar                        A:CC74
gc_done                          A:C938
gc_equality                      A:CD94
gc_equals                        A:CD89
gc_fix_hex                       A:CC38
gc_fix_hex_not_a_to_f            A:CC41
gc_geq                           A:CD3C
gc_greater_than                  A:CD2C
gc_hex_done                      A:CCC4
gc_hex_literal                   A:CC80
gc_hex_loop                      A:CC89
gc_hex_too_big                   A:CCC9
gc_inequality                    A:CDA5
gc_leq                           A:CD1D
gc_less_than                     A:CD09
gc_lh_brace                      A:CAB3
gc_lh_paren                      A:CAB7
gc_logical_and                   A:CD72
gc_logical_or                    A:CD83
gc_minus                         A:CD46
gc_neq                           A:CD22
gc_newline                       A:C915
gc_newline1                      A:C922
gc_newline_assembling            A:C92F
gc_not_alpha                     A:C97B
gc_not_digit                     A:C987
gc_not_space                     A:C950
gc_pascal_comment                A:CAC5
gc_pascal_comment_find_end       A:CAE4
gc_percent                       A:CCCE
gc_plus                          A:CD48
gc_quote                         A:CBA6
gc_quote_backslash_loop          A:CC0F
gc_quote_bad                     A:CBBD
gc_quote_bad_string              A:CC1A
gc_quote_copied_value            A:CBE2
gc_quote_done                    A:CBEB
gc_quote_found_backslash_charac  A:CC23
gc_quote_hex_character           A:CC45
gc_quote_hex_character_done      A:CC1F
gc_quote_hex_character_one_only  A:CC71
gc_quote_long_string             A:CBD7
gc_quote_loop                    A:CBB4
gc_quote_loop_not_end_of_line    A:CBC2
gc_quote_not_backslash           A:CC27
gc_quote_not_finished            A:CBFD
gc_quote_too_long                A:CC33
gc_semicolon                     A:CB6D
gc_shift_left                    A:CD27
gc_shift_right                   A:CD41
gc_single_byte_already_known     A:C934
gc_single_byte_already_knownJ    A:CAB0
gc_single_byte_already_knownJ2   A:CD39
gc_single_byte_token             A:C936
gc_single_byte_tokenJ            A:CAAD
gc_skip_spaces                   A:C900
gen_random                       A:8FDA
gen_random1                      A:8FFC
get_token                        A:C8F2
get_token_loop                   A:C8F6
gtoken_directive_table           A:CAA0
gtoken_table                     A:CA6F
handlerLookup                    A:8F0A
handler_find_length              A:8F12
handler_found_directive          A:8F38
handler_found_length             A:8F1B
handler_loop                     A:8F0C
handler_next                     A:8F1F
handler_same_length              A:8F2F
handlers_done                    A:8F48
hardware_init                    A:C88D
hardware_work                    S:008C
id_equals_message                A:B5CC
info_message                     A:A564
insert_last_char                 E:00B0
insert_limit                     S:00A4
introduction                     A:8255
irq                              A:B68C
irq1                             A:B699
irq_done                         A:B711
is_xxx_fail                      A:8106
is_xxx_pass                      A:810A
isalnum                          E:8162
isalpha                          E:8126
isbin                            A:8176
isbinary                         E:816E
iscntrl                          E:8156
isdigit                          E:8132
islower                          E:811A
isspace                          E:814A
isupper                          E:810E
isxdigit                         E:813E
lcd_clear_display                A:B84E
lcd_clear_enable                 A:B7B1
lcd_data_nibble                  A:B80D
lcd_get_address                  A:B7DA
lcd_home                         A:B85E
lcd_initialise                   A:B714
lcd_instruction                  A:B7FA
lcd_prepare_to_read_register     A:B76D
lcd_prepare_to_write_data        A:B780
lcd_prepare_to_write_instructio  A:B795
lcd_print                        A:B86F
lcd_print_char                   A:B81C
lcd_print_char_newline           A:B83D
lcd_print_char_ok                A:B83D
lcd_print_char_on_2nd_line       A:B836
lcd_print_done                   A:B879
lcd_print_message                A:B866
lcd_print_not_newline            A:B827
lcd_read_instruction_nibble      A:B7BA
lcd_second_line                  A:B856
lcd_set_enable                   A:B7A8
lcd_wait                         A:B7C6
lcd_work                         S:0086
lcd_write_instruction_nibble     A:B7EE
lcdbusy                          A:B7CB
library_function_call            A:C678
library_function_call_1          A:C6B4
library_function_call_2          A:C685
library_function_call_3          A:C6AF
library_function_call_5          A:C6B7
line_number_lt_1000              A:8C34
line_number_output_spaces        A:8C43
lines_deleted_message            A:8C13
list_symbols                     E:A56F
list_symbols_check               E:A589
list_symbols_done                E:A5C3
list_symbols_line                E:A598
list_symbols_name                E:A5B2
list_symbols_next                E:A57E
load_message                     A:89D4
m_alnum                          E:0080
m_alpha                          E:0004
m_cntrl                          E:0040
m_digit                          E:0008
m_lower                          E:0002
m_space                          E:0020
m_upper                          E:0001
m_xdigit                         E:0010
main_loop                        A:82E6
main_loop_not_run                A:8312
main_prompt                      A:82CC
main_start                       A:82C5
maths_work                       S:008D
mem_move_dest                    S:00A8
mem_move_len                     S:00AA
mem_move_src                     S:00A6
memory_filled_up                 A:8B45
memory_full                      A:8B2A
movedown                         A:817A
movedown1                        A:819D
movedown2                        A:8190
movedown_done                    A:819C
movedown_loop                    A:8186
moveup                           A:81A6
moveup3                          A:81D8
moveup_done                      A:81E4
moveup_loop                      A:81CE
moveup_next                      E:81E5
negate_token_value               A:CA5B
no_find_message                  A:8718
no_valid_compile_message         A:9328
notbin                           A:8178
number_bad_range_message         A:8605
number_expected_message          A:855C
number_too_large_message         A:85DC
opcode_lookup                    A:9ADA
opcode_lookup_correct_length     A:9B05
opcode_lookup_correct_operand    A:9B33
opcode_lookup_loop               A:9AEC
opcode_lookup_loop_done          A:9B4A
opcode_lookup_loop_unknown       A:9B7F
opcode_lookup_next_table         A:9AF6
opcode_lookup_no_handler         A:9B49
opcode_lookup_ok                 A:9B82
p_equals_message                 A:B5BC
partial_handler_Lookup           A:8F4D
partial_handler_done             A:8F91
partial_handler_found_directive  A:8F7D
partial_handler_next             A:8F66
partial_handler_next_found_item  A:8F6D
partial_handler_next_item        A:8F4F
partial_handler_next_loop        A:8F57
partial_handler_skipped_string   A:8F84
pas_gc_identifier                A:CEAA
pas_gc_loop                      A:CEB2
pas_gc_more                      A:CEBB
pas_gc_no_match                  E:CEE3
pas_get_token                    A:CEA0
pas_get_token_eof                A:CEA9
pascal_library_functions_table   A:C57E
pcodes_ended_message             A:92DF
pin_number_to_mask               E:C7D2
pin_number_to_mask_done          A:C7E0
pin_number_to_mask_loop          A:C7D8
pinmode                          A:C7E5
pinmode_B                        A:C7F6
pinmode_C                        A:C7FE
pinmode_OUTPUT                   A:C80C
prchar_not_control               A:9298
print                            A:8226
print_done                       A:824C
print_loop                       A:8234
print_not_abort                  A:8242
prompt                           A:829F
random                           S:0009
recover_done                     A:8E3B
recover_not_needed               A:8E41
rep_diff                         S:00B7
rep_from                         S:00B5
rep_to                           S:00B6
run_assembler                    A:9377
running_message                  A:AD58
s_equals_message                 A:B5C4
serial_available                 E:C887
serial_in_byte                   S:008A
serial_in_byte_received          S:008B
serial_in_loop                   A:B6BD
serial_out_bit                   S:0089
serial_out_byte                  S:0087
serial_print                     A:C8E7
serial_print_done                A:C8F1
serial_print_message             A:C8E1
serial_send_count_bits           A:B702
show_current_line                A:97F9
show_current_line_done           A:983E
show_current_line_loop           A:981B
show_current_line_loop_print_on  A:9833
show_current_line_number         A:8C1E
show_current_line_number_done    A:8C4F
show_source_end                  A:8ECD
show_source_start                A:8EF5
show_symbol_table_end            A:8EA8
show_symbols                     S:0082
source_ended_message             A:8EBA
source_length_message            A:906B
source_starts_message            A:8EE2
stack_message                    A:B681
str_compare                      A:81F0
str_compare_done                 A:81FE
str_ic_compare                   A:8201
str_ic_compare_done              A:8223
str_ic_compare_fixed_dest        A:821E
str_ic_compare_fixed_srce        A:8210
str_work                         S:0085
symbol_table_ended_message       A:9310
symbol_table_message             A:8D66
system_flags                     S:00BE
this_line                        S:00AC
this_line_addr                   S:00AE
timer1_interrupt                 A:B6E2
to_line                          S:00A0
to_msg                           A:86A2
token_address                    S:0090
token_digit                      S:009B
token_length                     S:0092
token_line                       A:C992
token_line1                      A:C998
token_line_done                  A:C9E0
token_line_listing               A:C9B3
token_line_loop                  A:C9CB
token_line_loop1                 A:C9DB
token_line_start                 S:009C
token_sign                       S:0097
token_start                      S:008E
token_type                       S:0093
token_value                      S:0094
token_work                       S:0098
too_much_on_line                 A:861E
typing_latency                   S:000D
write_char                       A:C8BC
write_char_loop                  A:C8D8
write_function                   S:0017
write_to_lcd                     A:C86B
write_to_serial                  A:C860
write_zero                       A:B6FD
wtf_loop                         A:9B6E
x_equals_message                 A:B5AC
y_equals_message                 A:B5B4

Symbols by value:
0000 EMULATOR
0000 OPCODE_LOOKUP_OPCODE_LENGTH
0000 PCODE_LIT
0000 REG
0000 SERIAL_DEBUGGING
0000 SRCE
0000 SYMPRV
0000 VALUE
0000 VIA_FLAG_DISABLE
0000 crc_addr
0001 ASS_OPERAND_ABSOLUTE
0001 EFLAG_SHOW_LINE
0001 FFLAG_IGNORE_CASE
0001 FLAG_COMPILING
0001 LCD_SUPPORT
0001 OPCODE_LOOKUP_OPERAND_TYPE
0001 PCODE_STACK
0001 m_upper
0002 ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
0002 EFLAG_ALLOW_ZERO_FROM
0002 FFLAG_GLOBAL
0002 FLAG_ASSEMBLING
0002 OPCODE_LOOKUP_OPCODE_TABLE
0002 PCODE_NEG
0002 REGB
0002 SERIAL_OUT_MASK
0002 SYMLVL
0002 m_lower
0003 ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
0003 DEST
0003 KEY_ABORT
0003 PCODE_LIB_CALL
0003 REG2
0003 SYMTYP
0003 VALUE2
0003 crc_num
0004 ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
0004 EFLAG_LOAD
0004 FFLAG_QUIET
0004 FLAG_LIST_SOURCE
0004 KEY_DEBUG
0004 OPCODE_LOOKUP_HANDLER
0004 PCODE_ADD
0004 SERIAL_DEBUG1_MASK
0004 SYMDSP
0004 m_alpha
0005 ASS_OPERAND_ABSOLUTE_INDIRECT
0005 REG2B
0006 ASS_OPERAND_ACCUMULATOR_A
0006 OPCODE_LOOKUP_TABLE_SIZE
0006 PCODE_SUB
0006 REMAIN
0006 SYMARG
0006 SYMSUB
0006 crc_val
0007 ASS_OPERAND_IMMEDIATE
0008 ASS_OPERAND_IMPLIED
0008 BACKSPACE
0008 EFLAG_SAVE
0008 FLAG_VALID_COMPILE
0008 PCODE_MUL
0008 SERIAL_DEBUG2_MASK
0008 SYMDAT
0008 VIA_FLAG_CB2
0008 m_digit
0009 SYMLEN
0009 random
000A NL
000A PCODE_DIV
000A SYMNAM
000B ASS_OPERAND_ZERO_PAGE
000B PCODE_MOD
000C ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
000C PCODE_ADRNN
000D ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
000D CR
000D typing_latency
000E ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
000E KEY_STOP_TRACE
000E PCODE_ADRAN
000F ASS_OPERAND_ZERO_PAGE_INDIRECT
0010 ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
0010 EFLAG_FIND
0010 FLAG_VALID_ASSEMBLE
0010 PCODE_EQL
0010 SERIAL_SPARE2_MASK
0010 call_a
0010 m_xdigit
0011 ASS_OPERAND_STRING
0011 PCODE_FINISHD
0011 call_x
0012 ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE
0012 PCODE_NEQ
0012 call_y
0013 call_p
0014 KEY_TRACE
0014 PCODE_LSS
0014 call_s
0015 brk_address
0016 PCODE_GEQ
0016 gc_backslash_tokens_length
0017 write_function
0018 PCODE_GTR
0019 LINE_CNT
0019 PCODE_LEQ
001A PCODE_ORR
001B END_EDITOR_INPUT
001B PCODE_AND
001C PCODE_INP
001D LIST
001E PCODE_OUT
001F PCODE_OUTC
0020 EFLAG_REPLACE
0020 FRAME
0020 LCD_RS
0020 MAX_STK
0020 PCODE_EOR
0020 SERIAL_DELAY1
0020 m_space
0021 PCODE_OUH
0022 LEVEL
0022 PCODE_SHL
0022 TOKEN_STRING
0023 PCODE
0023 PCODE_OUS
0023 SERIAL_DELAY2
0024 PCODE_SHR
0025 ACT_PCDA
0025 PCODE_INS
0026 PCODE_INC
0027 DISPL
0027 PCODE_CLL
0027 SINGLE_QUOTE
0028 PCODE_DEC
0029 OFFSET
0029 PCODE_RTN
002A PCODE_MOV
002B OPND
002B PCODE_CLA
002C PCODE_LOD
002E DCODE
002E PCODE_LDA
002F STARTSYM
0030 PCODE_LDI
0031 ENDSYM
0031 T
0032 PCODE_STO
0033 WORKD
0034 PCODE_STA
0035 ERRNO
0036 BSAVE
0036 PCODE_STI
0037 WORK
0038 PCODE_ABSCLL
0039 PRCITM
003A PCODE_XOR
003B BASE
003B PCODE_INT
003C PCODE_JMP
003D DATA
003D PCODE_JMZ
003E PCODE_JM1
003F RUNNING
0040 EFLAG_SUPPRESS_NEWLINE
0040 FLAG_ONLY_ALPHA
0040 FROM
0040 LCD_RW
0040 PCODE_OUTCR
0040 SYMITM
0040 VIA_FLAG_TIMER1
0040 m_cntrl
0041 SYMBOL_ARRAY
0041 TOKEN_ASSIGN
0042 PCODE_LCD_WRITE_NUM
0042 SYNTAX
0043 END_PCD
0043 PCODE_LCD_WRITE_STR
0043 SYMBOL_CONSTANT
0044 PCODE_LCD_WRITE_HEX
0045 PCODE_LAST
0045 PCODE_LCD_WRITE_CHR
0045 TEMP
0045 TOKEN_EQUALITY
0046 SYMBOL_FUNCTION
0047 CALL
0049 DBGFLG
0049 TOKEN_IDENTIFIER
004A DATTYP
004B COUNT1
004C COUNT2
004C TOKEN_SHIFT_LEFT
004D LASTP
004D TOKEN_UNARY_MINUS
004E TOKEN_NUMBER
0050 SYMBOL_PROCEDURE
0051 SYMBOL_LIBRARY_PROCEDURE
0052 RES
0052 SYMBOL_LIBRARY_FUNCTION
0052 TOKEN_SHIFT_RIGHT
0055 MCAND
0055 TOKEN_NEQ
0056 SYMBOL_VARIABLE
0056 TOKEN_LOW_BYTE
0057 TOKEN_HIGH_BYTE
0058 TOKEN_LOGICAL_AND
0059 SYMBOL_FUNCTION_RETURN
0059 TOKEN_LOGICAL_OR
005A TOKEN_INEQUALITY
005B RMNDR
005C bcd_work
0060 bcd_result
006B ASS_OPERAND
006C OPCODE
006E OPCODE_LEN
006F ASS_EMIT_COUNT
0070 ASS_OPCODE_WORK
0072 ASS_COUNT
0073 ASS_VALUE
0076 ASS_PASS
0077 ass_emit_bytes
0079 exp_value_stack
007B exp_value_stack_count
007C exp_operator_stack_count
007D exp_operator
007E exp_operator_precedence
007F exp_evaluation_function
0080 EFLAG_NO_LINE_NUMBERS
0080 FLAG_ABORTED
0080 LCD_E
0080 TOKEN_LEQ
0080 VIA_FLAG_ENABLE
0080 m_alnum
0081 TOKEN_GEQ
0081 exp_unary_ok
0082 TOKEN_CONST
0082 show_symbols
0083 TOKEN_VAR
0083 ass_current_label
0084 TOKEN_ARRAY
0085 TOKEN_OF
0085 str_work
0086 TOKEN_PROCEDURE
0086 lcd_work
0087 TOKEN_FUNCTION
0087 serial_out_byte
0088 TOKEN_BEGIN
0089 TOKEN_END
0089 serial_out_bit
008A TOKEN_OR
008A serial_in_byte
008B TOKEN_DIV
008B serial_in_byte_received
008C TOKEN_MOD
008C hardware_work
008D TOKEN_AND
008D maths_work
008E TOKEN_SHL
008E token_start
008F TOKEN_SHR
0090 TOKEN_NOT
0090 token_address
0091 TOKEN_MEM
0092 TOKEN_IF
0092 token_length
0093 TOKEN_THEN
0093 token_type
0094 TOKEN_ELSE
0094 token_value
0095 TOKEN_CASE
0096 TOKEN_WHILE
0097 TOKEN_DO
0097 token_sign
0098 TOKEN_REPEAT
0098 token_work
0099 TOKEN_UNTIL
009A TOKEN_FOR
009B TOKEN_TO
009B token_digit
009C TOKEN_DOWNTO
009C token_line_start
009D TOKEN_WRITE
009E TOKEN_READ
009E from_line
009F TOKEN_CALL
00A0 to_line
00A1 TOKEN_CHAR
00A2 TOKEN_MEMC
00A2 current_line
00A4 TOKEN_XOR
00A4 insert_limit
00A6 mem_move_src
00A8 mem_move_dest
00A9 TOKEN_ADDRESS
00AA mem_move_len
00AB TOKEN_CHR
00AC TOKEN_HEX
00AC this_line
00AE this_line_addr
00B0 find_from
00B0 insert_last_char
00B1 find_to
00B2 find_pos
00B3 find_len
00B4 find_delimiter
00B5 rep_from
00B6 rep_to
00B7 rep_diff
00B9 find_count
00BB found_this_line
00BC editor_flags
00BD find_flags
00BE system_flags
00D0 BIT_INTERVAL
00F1 TOKEN_LCDWRITE
00FE TOKEN_INTEGER
00FF NEW_STK
00FF TOKEN_WRITELN
0100 INBUF_SIZE
0200 INBUF
0300 TEXT_START
12C0 BAUD_RATE
3FFF HIGHEST_RAM
3FFF SYMBOL_TABLE_START
7FF0 VIA_PORTB
7FF1 VIA_PORTA
7FF2 VIA_DDRB
7FF3 VIA_DDRA
7FF4 VIA_T1C_L
7FF5 VIA_T1C_H
7FFB VIA_ACR
7FFD VIA_IFR
7FFE VIA_IER
8000 START_OF_ROM
8006 character_types_table
8106 is_xxx_fail
810A is_xxx_pass
810E isupper
811A islower
8126 isalpha
8132 isdigit
813E isxdigit
814A isspace
8156 iscntrl
8162 isalnum
816E isbinary
8176 isbin
8178 notbin
817A movedown
8186 movedown_loop
8190 movedown2
819C movedown_done
819D movedown1
81A6 moveup
81CE moveup_loop
81D8 moveup3
81E4 moveup_done
81E5 moveup_next
81F0 str_compare
81FE str_compare_done
8201 str_ic_compare
8210 str_ic_compare_fixed_srce
821E str_ic_compare_fixed_dest
8223 str_ic_compare_done
8226 print
8234 print_loop
8242 print_not_abort
824C print_done
8255 introduction
829F prompt
82A2 bad_command
82C5 main_start
82CC main_prompt
82E6 main_loop
8312 main_loop_not_run
8330 editor_handlers
83BE editor_help_info
8533 editor_help
853B editor_help_loop
854C editor_help_done
854F editor_default_range
855C number_expected_message
856D editor_bad_number
8577 editor_get_number
85B2 editor_get_number_not_identifier
85C8 editor_get_number_ok
85D8 editor_get_number_done
85DA editor_get_number_none
85DC number_too_large_message
85FB editor_line_number_too_big
8605 number_bad_range_message
8614 editor_bad_range
861E too_much_on_line
8638 editor_check_no_more
8647 editor_check_no_more_ok
8648 editor_get_range
867A editor_get_range_hyphen
867F editor_get_range_number
8692 editor_get_range_done
8693 found_message
869B from_msg
86A2 to_msg
86A7 bad_delimiter_message
86B6 editor_bad_delimiter
86BA editor_find_problem
86C0 find_string_too_long_message
86DE find_string_too_long
86E4 editor_get_delimiter
86FC editor_no_closing_delimiter_message
8712 editor_no_closing_delimiter
8718 no_find_message
872D editor_no_find_string
8733 editor_replace
873B editor_find
8741 editor_save
8747 editor_list
876D editor_list_doing_find
8779 editor_find_bug
877E find_string_too_longJ
8781 editor_no_closing_delimiterJ
8784 editor_list_got_from_point
8786 editor_find_second_delimiter_loop
87AD editor_find_third_delimiter_loop
87D3 editor_find_get_flags
87D5 editor_flags_loop
87F3 editor_flags1
87FD editor_flags2
8807 editor_flags3
8811 bad_flag_message
881F editor_list_fix_target_string
8827 editor_list_fixup_loop
8837 editor_list_not_find
883A editor_list_get_on_with_it
884B editor_list_have_source
8851 editor_list_doneJ
8854 editor_list_no_line_numberJ
8857 editor_list_loop
887E editor_list_aborted
888B editor_find_or_replacing
888D editor_replacement_loop
888F editor_find_loop
8893 editor_find_inner_loop
88AA editor_find_case_sensitive
88AB editor_find_test_character
88B4 editor_find_skip_this
88B8 editor_find_no_match
88CE editor_find_found_it
88D4 editor_find_found_it1
88EC editor_do_the_replace
88F9 editor_easy_replace
88FD editor_easy_replace_loop
890A editor_easy_replace_done
891B editor_list_not_finding
8928 editor_list_no_line_number
8930 editor_newline_processing
893A editor_list_check_to_line
894A editor_list_check_to_line_ok
8952 editor_list_not_newline
895D editor_list_skip_newline
8963 editor_list_loopJ
8966 editor_list_done
8983 editor_list_completely_done
8986 editor_do_replace
89C8 editor_do_replace_smaller
89CB editor_do_replace_copy_done
89D4 load_message
89F6 editor_load
89FA editor_insert
8A16 editor_insert_at_start
8A24 editor_insert_common
8A63 editor_insert_loop
8A74 editor_insert_no_line_number
8A99 editor_insert_not_newline
8AA3 editor_insert_loop1
8AB3 editor_insert_backspace
8ABF editor_insert_backspace_not_at_start
8AD2 editor_insert_done
8AE4 editor_insert_done_with_newline
8AFF editor_too_full
8B06 editor_too_full_loop
8B17 editor_no_lines
8B2A memory_full
8B45 memory_filled_up
8B6E editor_delete
8B90 editor_delete_have_range
8BC9 editor_delete_line_count_loop
8BD5 editor_delete_line_count_not_done
8BE1 editor_delete_line_count_not_newline
8BE9 editor_delete_line_count_done
8C13 lines_deleted_message
8C1E show_current_line_number
8C34 line_number_lt_1000
8C43 line_number_output_spaces
8C4F show_current_line_number_done
8C55 find_line
8C63 find_line_loop
8C72 find_line_next
8C80 find_line_same_line
8C88 find_line_eof
8C89 find_source_end
8C91 find_source_end_loop
8C9F find_source_end_wrap
8CA5 find_source_end_done
8CA6 brk_resumed
8CBA editor_test
8CCC editor_memory
8CE3 editor_memory_loop
8D04 editor_memory_loop1
8D16 editor_memory_loop2
8D26 editor_memory_loop3
8D36 editor_memory_done
8D39 editor_memory_aborted
8D3F editor_memory_show_ascii
8D41 editor_memory_ascii
8D49 editor_memory_not_control
8D4D editor_memory_show_dot
8D4F editor_memory_not_high
8D66 symbol_table_message
8D98 ST_SYMTBL_LIST_NEXT
8DA3 ST_SYMTBL_LIST_CHECK
8DB2 ST_SYMTBL_LIST_LINE
8E27 ST_SYMTBL_LIST_NAME
8E38 ST_SYMTBL_LIST_DONE
8E3B recover_done
8E41 recover_not_needed
8E4D editor_recover
8E69 editor_recover_not_needed
8E73 editor_debug
8E7C editor_trace
8E85 editor_info
8E91 editor_compile
8E98 editor_syntax
8E9F editor_run
8EA8 show_symbol_table_end
8EBA source_ended_message
8ECD show_source_end
8EE2 source_starts_message
8EF5 show_source_start
8F07 editor_assemble
8F0A handlerLookup
8F0C handler_loop
8F12 handler_find_length
8F1B handler_found_length
8F1F handler_next
8F2F handler_same_length
8F38 handler_found_directive
8F48 handlers_done
8F4A call_handler
8F4D partial_handler_Lookup
8F4F partial_handler_next_item
8F57 partial_handler_next_loop
8F66 partial_handler_next
8F6D partial_handler_next_found_item_length
8F7D partial_handler_found_directive
8F84 partial_handler_skipped_string
8F91 partial_handler_done
8F92 TKNJMP
8F9A JMP1
8FA2 JMP2
8FB7 JMP3
8FC4 MAKE_UPPER
8FCE MAKE_UPPER_DONE
8FD9 MAKE_LOWER_DONE
8FDA gen_random
8FFC gen_random1
8FFD crc16
9009 crc16_loop
9016 crc16_next
901C crc16_skip
9024 crc_done
9025 crc_byte
9055 crc_helper1
9058 crc_message
906B source_length_message
907B bytes_message
9083 crc_source
90CB delay_1ms
90CE delay_1ms_loop
90D5 delay
90DF bcd_unpack
90F2 bcd_table
9152 display_in_decimal
915E bcd_positive
9165 bcd_skip_zeroes
9170 bcd_output_digit
917B binary_to_decimal
9186 binary_to_decimal_loop
91AB binary_to_decimal_next
91C9 NOSCE
91DA INIT
91E6 INIT_SECOND_PASS
9227 INIT9
9228 CROUT
922D COMSTL
9239 COMS9
923A COMS8
923D DISHX
9243 DISPAD
925E DISPAD2
925F PSHWRK
9271 PSH9
9272 PULWRK
9285 PRCHAR
9298 prchar_not_control
929D PRBYTE
92A6 PRHEX
92A8 PRHEXZ
92B0 PRHEX1
92B3 PUTSP
92B7 PT
92BF PT6
92C9 TKNWRK
92D4 WRKTKN
92DF pcodes_ended_message
92F2 compile_finished_message
9310 symbol_table_ended_message
9328 no_valid_compile_message
9352 PRBYTECR
9358 CHK_VAL
936A CHK_VAL9
936B CHK_RUN
9377 run_assembler
937D call_assembler
9387 GETLN1
9387 GET_LINE
9389 GET1
93A6 GET3
93AC GETLN_OVERFLOW
93AF COUT
93B9 COUT_CALL
93BC errors_table
971E assertion_failed_message
9758 ERRLIT
9764 ERROR
976D ERR7
9777 ERR1
978B ERR3
979B ERR5
97A1 ERR6
97AD error_next
97AE error_loop
97B2 error_find_next
97BB error1
97C4 error_not_found
97DC error_found
97E9 error_not_found_message
97F9 show_current_line
981B show_current_line_loop
9833 show_current_line_loop_print_one_character
983E show_current_line_done
9842 ASSEMBLE
984F ASSEMBLE_SECOND_PASS
9854 ASSEMBLE_PASS
986E ass_finish_line
9879 ass_done_jump
987C ass_line
988B ass_line1
98BB ass_bad_identifier
98C0 ass_identifier
98EA ass_lookup_existing_label
98F4 ass_lookup_save_address
9900 ass_added_symbol
9912 ass_not_colon
991A ass_finish_lineJ2
991D ass_not_colon2
9925 ass_illegal_opcode
992D ass_opcode
996E ass_check_label_changed
997E ass_symbol_address_changed
9983 ass_opcode2
998E ass_no_operand
9998 ass_finish_lineJ
999B ass_operand
99AD ass_string
99BA ass_immediate
99CD ass_indirect
99D6 ass_identifier_operand
99F7 ass_operand_value
9A2F ass_value_not_indirectJ
9A32 ass_bad_indirect
9A37 ass_indirect_with_bracket
9A4B ass_zp_indirect_indexed
9A6C ass_bad_zp_indirect_indexed
9A71 ass_not_x_or_y
9A73 ass_check_we_have_x_or_y
9A8F ass_check_we_have_x_or_y_ok
9A91 ass_value_not_indirect
9A9B ass_value_done
9AA4 ass_indexed
9AC2 ass_indexed_x
9ACB ass_absolute_another_value
9ADA opcode_lookup
9AEC opcode_lookup_loop
9AF6 opcode_lookup_next_table
9B05 opcode_lookup_correct_length
9B33 opcode_lookup_correct_operand
9B49 opcode_lookup_no_handler
9B4A opcode_lookup_loop_done
9B6E wtf_loop
9B7F opcode_lookup_loop_unknown
9B82 opcode_lookup_ok
9B83 ass_done
9B8D ass_done_second_pass
9BA5 ass_done1
9BA8 ass_done_message
9BC6 ass_check_no_more_tokens
9BD5 ass_check_no_more_tokens_ok
9BD6 exp_push_value
9BDC exp_push_value_memory_full
9BE1 exp_push_value_ok
9BF0 exp_push_value_not_full
9C01 exp_pop_value
9C0A exp_pop_value_ok
9C2A exp_push_operator
9C35 exp_push_operator_ok
9C3C exp_pop_operator
9C45 exp_pop_operator_ok
9C4C exp_get_operator
9C55 exp_get_operator_ok
9C5A exp_precedence_table
9CBA exp_get_precedence
9CBA exp_precedence_table_end
9CBC exp_get_precedence_loop
9CD0 exp_get_precedence_found
9CE1 ass_get_value
9CFB ass_expression_loop
9CFE ass_expression_loop_initial
9D02 ass_expression_number
9D15 ass_expression_loop1a
9D27 ass_expression_not_small_string
9D2C ass_expression_loop1
9D40 ass_label_not_found_yet
9D48 ass_expression_found_value
9D59 ass_expression_loop2
9D68 ass_expression_loop3
9D6C ass_expression_loop3b
9D77 ass_expression_loop3a
9D7C ass_expression_loop3c
9D7F ass_expression_loopJ
9D82 ass_expression_loop4
9D90 ass_not_unary_minus
9D9A ass_not_unary_less_than
9DA4 ass_not_unary_greater_than
9DBA ass_expression_cannot_be_unary
9DC9 ass_expression_loop7
9DE0 ass_expression_loop6
9DE8 exp_no_operators_left
9DF1 exp_done
9DF7 exp_done_error
9DFC exp_done_ok
9E0E ass_expression_apply_operator
9E37 ass_expression_unary
9E4A ass_expression_apply_operator_bug
9E4F ass_evaluate_operator
9E52 ass_lookup_loop
9E70 ass_opcode_found
9E76 ass_emit
9E8A ass_emit2
9E99 ass_already_emitted
9EA4 ass_emit4
9EAB ass_emit3
9EB1 ass_emit1
9EB4 ass_error
9EBB ass_error1
9EBE ass_fixup_bbr_branch
9ECB ass_fixup_branch
9EE4 ass_branch_backwards
9EE8 ass_branch_ok
9EEE ass_branch_out_of_range
9EF7 ass_emit_zero_page
9F05 ass_emit_zero_page_too_high
9F0A ass_emit_immediate
9F18 ass_emit_immediate_too_high
9F1D ass_emit_absolute
9F28 OPCODE_LOOKUP_TABLE
9FCB DIRECTIVES
A03E OPCODE_4_CHAR_BRANCH
A08F OPCODE_3_CHAR_BRANCH
A0B4 OPCODE_3_CHAR_IMPLIED
A131 OPCODE_4_CHAR_ZERO_PAGE
A182 OPCODE_ASS_OPERAND_ABSOLUTE
A1EB OPCODE_ASS_OPERAND_ABSOLUTE_TOKENISED
A1EE OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
A1F3 OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
A238 OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X_TOKENISED
A23B OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
A260 OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y_TOKENISED
A263 OPCODE_ASS_OPERAND_ACCUMULATOR_A
A27C OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT
A281 OPCODE_ASS_OPERAND_IMMEDIATE
A2B2 OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED
A2B5 OPCODE_ASS_OPERAND_ZERO_PAGE
A316 OPCODE_ASS_OPERAND_ZERO_PAGE_TOKENISED
A319 OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
A33A OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT_TOKENISED
A33D OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
A386 OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X_TOKENISED
A389 OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
A392 OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT
A3B3 OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_TOKENISED
A3B6 OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
A3D7 OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y_TOKENISED
A3DA asm_do_assert
A3E9 asm_do_assert_failed
A3EE asm_do_constant_expectedJ
A3F1 asm_do_list
A400 asm_do_nolist
A40B asm_do_nolist_ok
A411 asm_do_list_no_operand
A415 asm_do_list_ok
A42B asm_do_list_not
A42F asm_do_list1
A43E asm_do_list_first_pass
A43F asm_do_asc
A44A asm_do_asc_ok
A44C asm_do_asc_loop
A455 asm_do_asc_next
A45A asm_do_string
A463 asm_do_equ
A474 asm_do_equ_have_label
A480 asm_do_org
A486 asm_do_constant_expected
A48B asm_do_org_ok
A494 asm_do_dfb
A4A2 asm_do_dfb_multiple
A4AF asm_do_dfb_multiple_loop
A4C0 asm_do_dfb_multiple_done
A4C1 asm_do_dfb_too_big
A4C6 asm_emit_one_byte
A4D4 asm_do_dfw
A4E2 asm_do_dfw_multiple
A4F0 asm_do_dfw_multiple_loop
A501 asm_do_dfw_multiple_done
A502 asm_emit_two_bytes
A511 asm_do_blk
A521 asm_do_blk_loop
A52E asm_do_blk_done
A52F asm_do_reserve
A547 asm_do_constant_expectedJ2
A54A asm_do_sym
A563 asm_do_sym_done
A564 info_message
A56F list_symbols
A57E list_symbols_next
A589 list_symbols_check
A598 list_symbols_line
A5B2 list_symbols_name
A5C3 list_symbols_done
A5C4 assembler_library_functions_table
A9F8 add_assembler_library_functions
AA00 add_assembler_library_functions_loop
AA10 add_assembler_library_functions_name_loop
AA42 add_assembler_library_functions_done
AA43 exp_add
AA57 exp_subtract
AA6D exp_true
AA76 exp_false
AA7D exp_eql
AA91 exp_neq
AAA5 exp_less_than
AAAC exp_greater_than
AABB exp_leq
AACA exp_geq
AAD1 exp_bitwise_or
AAE6 exp_bitwise_and
AAFB exp_bitwise_xor
AB10 exp_trueJ
AB13 exp_falseJ
AB16 exp_logical_or
AB25 exp_logical_and
AB37 exp_shift_left
AB46 exp_shift_left_loop
AB4F exp_shift_left_done
AB50 exp_shift_right
AB5F exp_shift_right_loop
AB68 exp_shift_right_done
AB69 exp_negate
AB7C exp_not
AB8A exp_unary_minus
AB9E exp_low_byte
ABA3 exp_high_byte
ABAC exp_abs_val
ABB0 exp_negate_val
ABC3 exp_abs_val_done
ABC4 exp_abs_val2
ABC8 exp_negate_val2
ABDB exp_abs_val2_done
ABDC ZERRES
ABE5 exp_find_sign
ABFD exp_fix_sign
AC10 exp_fix_sign_done
AC11 exp_multiply
AC16 exp_multiply_loop
AC37 exp_multiply_no_add
AC4A exp_divide
AC5A exp_divide_not_zero
AC67 exp_divide_loop
AC8F exp_divide_subtraction_negative
AC90 exp_divide_subtraction_positive
ACAA exp_modulo
ACBA execution_address_table
AD46 DM1
AD4F DM2
AD58 running_message
AD61 DB11
AD61 DEBUG
ADC9 DEBUG_DONE
ADCA INTERP
ADF0 DM5
AE05 DM6
AE10 DM7
AE2A display_x_characters
AE31 DIS5
AE3B DIS5_A
AE48 BELL1
AE52 RUNERR
AE66 EX_FINISHD
AE7D FIN_MSG
AE9C CHK_KBD
AEA8 CHK_NOTN
AEB6 CHK_NOTT
AEC4 CHK_NOTD
AEC6 EX_OUTCR
AECC LOWLIT
AED2 LOWLIT1
AED8 MAINP
AEDB MAIN
AEE2 MAIN_2
AEED MAIN_NOT_ABORT
AEF0 MAIN_OK
AF0A MAIN_1
AF19 EX_INVINS
AF1D NOTIM1
AF2A GETADR
AF34 GET2
AF55 GETADR1
AF70 GET1_A
AF71 PULTOP
AF8C PUL_END
AF93 PULBOTH
AF96 PULTOP2
AFB1 PUL2_END
AFB8 PSHTOP
AFC3 PSH1
AFD4 GETLIT
AFEA GET_END
AFEB EX_LIT
AFFA LIT1
AFFD EX_NEG
B006 EX_ADD
B00F EX_SUB
B01B EX_MUL
B024 EX_GETKEY
B02B EX_MOD
B03F EX_DIVIDE_BY_ZERO
B046 DIVBY0
B056 EX_DIV
B06A EX_ABS
B073 EX_EQL
B07C TRUE
B07E TRUE2
B089 FALSE
B08D EX_NEQ
B096 EX_LSS
B0A2 EX_GTR
B0AE EX_GEQ
B0BA EX_LEQ
B0C6 EX_XOR
B0CF EX_ORR
B0D8 EX_AND
B0E1 EX_EOR
B0EA EX_SHL
B0F6 EX_SHR
B102 EX_INC
B11A EX_DEC
B132 EX_MOV
B143 EX_LODC
B146 EX_LOD3
B148 EX_LOD3_A
B155 EX_LOD
B158 EX_LOD2
B16B EX_LDAC
B176 EX_LDA
B180 GETIDC
B189 GETIDX
B19D GETID2
B1AB EX_LDIC
B1B1 EX_LDI
B1B7 EX_STOC
B1BF EX_STO5
B1C4 EX_STO
B1CA EX_STO2
B1D7 EX_STA
B1E8 EX_STA5
B1ED EX_STAC
B1F6 EX_STIC
B204 EX_STI
B21F EX_RTN
B258 EX_INP
B269 EX_INP_OK
B280 INP3
B290 BAD_INP
B298 EX_OUT
B29D EX_LCD_WRITE_NUM
B2A0 OUT_COMMON
B2AC EX_OUH
B2B1 EX_LCD_WRITE_HEX
B2B4 EX_OUH_COMMON
B2CC EX_OUS
B2D1 EX_LCD_WRITE_STR
B2D4 EX_OUS_COMMON
B2F0 EX_OUS1
B2FF EX_ABSCLL
B306 EX_CLL
B30E EX_CLL_A
B32C EX_CLL4
B330 EX_CLL2
B351 EX_CLL3
B392 EX_CLL5
B395 EX_CLA
B3B2 EX_CLL_JMP
B3B5 EX_INT
B3CC INT_ERR
B3D3 INT_ERRM
B3DF EX_NEW_STACK
B3F1 EX_JMP
B404 EX_JMZ
B40F EX_NOJUMP
B415 EX_JM1
B420 EX_INPC
B42A EX_INPC_OK
B43A EX_OUTC
B43F EX_LCD_WRITE_CHR
B442 EX_OUTC_COMMON
B450 EX_LCDHOME
B456 EX_LCDCLEAR
B45C EX_INS
B466 EX_INS3
B47F EX_INS1
B488 EX_INS2
B492 EX_INS4
B49F execution_aborted_message
B4B3 ex_input_aborted
B4BA EX_ADRNC
B4BD EX_ADRNC2
B4CA EX_ADRNN
B4CD EX_ADRN2
B4D8 EX_ADRAN
B4DE EX_ADRAC
B4E4 EX_DIGITALREAD
B4EF EX_DIGITALREAD_ONE
B4F2 EX_LCDPOS
B502 EX_LCDPOS_1
B50C EX_RANDOM
B51E EX_LATENCY
B52D EX_DELAY
B53D EX_RANDOMSEED
B54D EX_PINMODE
B55C EX_DIGITALWRITE
B56B EX_LIB_CALL
B571 EX_ASSERT
B586 EX_ASSERT_OK
B589 break_message
B5A4 a_equals_message
B5AC x_equals_message
B5B4 y_equals_message
B5BC p_equals_message
B5C4 s_equals_message
B5CC id_equals_message
B5D5 brk_executed
B650 brk_executed1
B65D brk_executed2
B66D brk_executed3
B681 stack_message
B689 brk_executedJ
B68C irq
B699 irq1
B6B1 cb2_interrupt
B6BD serial_in_loop
B6E2 timer1_interrupt
B6FD write_zero
B702 serial_send_count_bits
B711 irq_done
B714 lcd_initialise
B76D lcd_prepare_to_read_register
B780 lcd_prepare_to_write_data
B795 lcd_prepare_to_write_instruction
B7A8 lcd_set_enable
B7B1 lcd_clear_enable
B7BA lcd_read_instruction_nibble
B7C6 lcd_wait
B7CB lcdbusy
B7DA lcd_get_address
B7EE lcd_write_instruction_nibble
B7FA lcd_instruction
B80D lcd_data_nibble
B81C lcd_print_char
B827 lcd_print_not_newline
B836 lcd_print_char_on_2nd_line
B83D lcd_print_char_newline
B83D lcd_print_char_ok
B84E lcd_clear_display
B856 lcd_second_line
B85E lcd_home
B866 lcd_print_message
B86F lcd_print
B879 lcd_print_done
B87A SEARCH
B882 SEA_NEXT
B88D SEA1
B89A SEA2
B8E3 SEA4
B8EB SEA5
B8EE SEA3
B8F1 SYM_FULL
B8F6 ADDSYM
B92B ADDSYM_NOT_FULL
B952 ADD1
B975 ADD4
B991 ADD9
B992 LOOKUP
B99C LOOK1
B99D CHKDUP
B9AC DUP9
B9AD COMPIL
B9FB END_CMP
B9FE CHKLHP
BA05 CHKRHP
BA0F GETSUB
BA18 CHKLHB
BA22 CHKRHB
BA2C GET_LEV
BA36 GET_DAT
BA3D CONDEC
BA68 SYMWRK
BA73 WRKSYM
BA7E PSHPCODE
BA91 GET_OFF
BAAD GETO_1
BABA GETO_2
BABC GETEXPR
BAC2 PCD_WRKD
BACD WRK_OPND
BAD8 WRKD_WRK
BAE3 WRK_WRKD
BAEE GET_COMM
BAF5 GET_ITEM
BAFB VAL_MOVE
BB04 VAL_1
BB09 VAL_2
BB12 VAL_3
BB1B VAL_5
BB24 CHK_STAK
BB2B STK_ERR
BB2B STK_FULL
BB30 CONST
BB47 CONST1
BB4C CONST3
BB51 CONST2
BB55 CONST9
BB56 VARDEC
BB68 SIMEXP
BB72 SIM1
BB83 SIM3
BB96 SIM4
BBAC SIM7
BBB2 SIM5
BBB6 SIM6
BBBA SIM2
BBC0 SIM8
BBC4 TERMT1
BBDA TERM
BBDD TERM2
BBE7 TERM1
BBF6 TERM4
BBF8 TERM3
BBFE TERM5
BC02 TERM6
BC06 TERM7
BC0A TERM8
BC0E TERM9
BC12 TERMT3
BC28 FACTOR
BC39 IDENT
BC3C IDENT1
BC44 IDENT1A
BC49 IDENT2
BC62 IDENT2A
BC69 IDENT3
BC77 FACAD1
BC7F IDENT5
BC81 IDENT5_A
BC8C IDENT6
BC92 IDENT7
BC95 FACAD2
BC9D IDENT4
BC9F IDENT4_A
BCBF FACADR
BCD2 FACSTR
BCD8 FACERR1
BCDD FACNUM
BCE3 PAREN
BCE9 FACMEM
BCEF FACMMC
BCF3 FACM2
BCFF FACNOT
BD07 GENNOP1
BD0A FACRND1
BD10 FACTB1
BD16 FACTQT1
BD29 EXPRES
BD39 EXPTB1
BD4C EXPR1
BD5B EXPTB3
BD6E EXPR2
BD70 EXPR8
BD74 EXPR3
BD78 EXPR4
BD7C EXPR5
BD80 EXPR6
BD84 EXPR7
BD88 STMNT
BD95 STMNT1
BDC0 ASSIGN
BDC3 ASS1
BDCF ASSTB1
BDE5 assign_bad_identifier
BDEA ASSARR
BDFC ASSVAR
BE0B ASS2
BE27 WRITELN
BE31 WRITELN9
BE36 WRITE
BE39 WRIT9
BE48 W_STRING
BE52 WRIT2
BE55 WRIT10
BE62 WRIT1
BE72 WRIT5
BE7B W_CHR
BE7D W_CHR1
BE83 W_HEX
BE87 STMNT_WRITE_LCD
BE8A WRITE_LCD9
BE99 WRITE_LCD_STRING
BEA3 WRITE_LCD2
BEB3 WRITE_LCD1
BEC3 WRITE_LCD5
BECC WRITE_LDC_CHR
BECE WRITE_LDC_CHR1
BED4 WRITE_LDC_HEX
BED8 READ
BEDB READ8
BEDE READ2
BEF5 READ9
BEF8 READ11
BF17 READ7
BF1D READ7_A
BF27 READ3
BF3B READ3_B
BF56 READ3_A
BF64 TWO_OP
BF6A ONE_OP2
BF6D ONE_OP
BF74 GENNOP2
BF77 WAIT_1
BF81 MEM
BF86 MEMC
BF89 MEM2
BF9C CALLSB
BFA9 FNCPRC
BFB6 FNC2
BFE0 FNC3
BFE6 FNC1
BFE9 FNC5
C006 FNC5A
C008 FNC5B
C02A FNC4
C02B FNC6
C030 IF
C04E IF2
C055 IF1
C070 BEG
C086 REPEAT
C089 REP1
C0AA WHILE
C0DC CASE
C0EA CASE7
C0EE CASE2
C115 CASE1
C121 CASE4
C12B CASE3
C15E CASE5
C17C CASE6
C187 CASE9
C191 CASE8
C197 FOR
C1A1 FOR1
C1AE FOR2
C1C7 FOR3
C1F8 FOR4
C23B FOR5
C25D FOR6
C26A CHKGET
C270 WRK_VAL
C27B VAL_WRK
C286 END_WRK
C291 BLCKT1
C294 BLCKT2
C297 BLCKT3
C2A1 BLOCK
C2B8 BLK1A
C2CC BLK1
C2D4 BLK2
C2DE BLK4
C2E8 BLKCNS
C2EB BLKCN1
C2FF BLKVAR
C303 BLKVR1
C306 BLKVR6
C310 BLKVR7
C32F BLKVR8
C332 BLKV10
C34E BLKV10_A
C355 BLKV10_B
C364 BLKVR2
C37D BLKV13
C382 BLKVR4
C3BC BLKV11
C3C3 BLKV12
C3C9 BLKVR9
C3E2 BLKVR5
C424 BLKVR3
C43C BLKPRC
C45C BLKFNC
C47E BLKPR1
C49A BLKPR3
C4A7 BLKPR6
C4B0 BLKPR2
C4D1 BLKPR5
C4F8 BLKPR4
C524 BLKBEG
C52E BLKB3
C534 BLKB1
C550 BLKB2
C55D BLKB5
C56C BLKB4
C57B BLKB6
C57E pascal_library_functions_table
C61E add_pascal_library_functions
C626 add_pascal_library_functions_loop
C636 add_pascal_library_functions_name_loop
C677 add_pascal_library_functions_done
C678 library_function_call
C685 library_function_call_2
C6AF library_function_call_3
C6B4 library_function_call_1
C6B7 library_function_call_5
C6C8 GENNOP
C6DD GEN1
C6E1 GENADR
C714 GEN2
C716 GEN2_B
C71F GEN2_A
C731 GEN_FULL
C736 DISP9
C736 GEN2_C
C737 GENRJMP
C749 GENNJP
C74B GENNJM
C751 GENJMP
C77A GEN3
C77F FIXAD
C7BC FIXAD1
C7BD FIXM1
C7C6 FIXM2
C7D2 pin_number_to_mask
C7D8 pin_number_to_mask_loop
C7E0 pin_number_to_mask_done
C7E5 pinmode
C7F6 pinmode_B
C7FE pinmode_C
C80C pinmode_OUTPUT
C814 digitalwrite
C825 digitalwrite_B
C82D digitalwrite_C
C83B digitalwrite_ONE
C843 digitalread
C852 digitalread_B
C85A digitalread_C
C860 write_to_serial
C86B write_to_lcd
C876 CHRIN
C876 GETIN
C880 GETIN1
C887 serial_available
C88A EMULATOR_DEBUG
C88B START_TRACE
C88C STOP_TRACE
C88D hardware_init
C8BC write_char
C8D8 write_char_loop
C8E1 serial_print_message
C8E7 serial_print
C8F1 serial_print_done
C8F2 get_token
C8F6 get_token_loop
C900 gc_skip_spaces
C915 gc_newline
C922 gc_newline1
C92F gc_newline_assembling
C934 gc_single_byte_already_known
C936 gc_single_byte_token
C938 gc_done
C950 gc_not_space
C955 gc_alpha_loop
C95D gc_alpha_ok
C96E gc_alpha_done
C972 gc_alpha_alpha_only
C97B gc_not_alpha
C987 gc_not_digit
C992 token_line
C998 token_line1
C9B3 token_line_listing
C9CB token_line_loop
C9DB token_line_loop1
C9E0 token_line_done
C9E1 atoi
C9EA atoi_loop
C9F9 atoi_positive
C9FB atoi_more
CA50 atoi_error
CA56 atoi_not_running
CA5B negate_token_value
CA6F gtoken_table
CAA0 gtoken_directive_table
CAAD gc_single_byte_tokenJ
CAB0 gc_single_byte_already_knownJ
CAB3 gc_lh_brace
CAB7 gc_lh_paren
CAC5 gc_pascal_comment
CAE4 gc_pascal_comment_find_end
CAEF gc_comment_not_eof
CAF8 gc_comment_not_newline
CB07 gc_comment_keep_looking
CB0F gc_comment_found_end
CB1F gc_directive_symbols
CB2B gc_directive_symbols_ok
CB52 gc_directive_symbols_too_late
CB57 gc_directive_list
CB5E gc_directive_pcodes
CB64 gc_directive_nolist
CB6D gc_semicolon
CB76 gc_assembler_comment_find_end
CB81 gc_assembler_comment_not_eof
CB88 gc_assembler_comment_keep_looking
CB90 gc_backslash_tokens
CBA6 gc_backslash_tokens_end
CBA6 gc_quote
CBB4 gc_quote_loop
CBBD gc_quote_bad
CBC2 gc_quote_loop_not_end_of_line
CBD7 gc_quote_long_string
CBE2 gc_quote_copied_value
CBEB gc_quote_done
CBFD gc_quote_not_finished
CC0F gc_quote_backslash_loop
CC1A gc_quote_bad_string
CC1F gc_quote_hex_character_done
CC23 gc_quote_found_backslash_character
CC27 gc_quote_not_backslash
CC33 gc_quote_too_long
CC38 gc_fix_hex
CC41 gc_fix_hex_not_a_to_f
CC45 gc_quote_hex_character
CC71 gc_quote_hex_character_one_only
CC74 gc_dollar
CC80 gc_hex_literal
CC89 gc_hex_loop
CCC4 gc_hex_done
CCC9 gc_hex_too_big
CCCE gc_percent
CCDA gc_binary_literal
CCE2 gc_binary_loop
CCF8 gc_colon
CD03 gc_assign
CD09 gc_less_than
CD1D gc_leq
CD22 gc_neq
CD27 gc_shift_left
CD2C gc_greater_than
CD39 gc_single_byte_already_knownJ2
CD3C gc_geq
CD41 gc_shift_right
CD46 gc_minus
CD48 gc_plus
CD67 gc_ampersand
CD72 gc_logical_and
CD78 gc_bar
CD83 gc_logical_or
CD89 gc_equals
CD94 gc_equality
CD9A gc_bang
CDA5 gc_inequality
CDAB RSVWRD
CE9E RSVEND
CEA0 pas_get_token
CEA9 pas_get_token_eof
CEAA pas_gc_identifier
CEB2 pas_gc_loop
CEBB pas_gc_more
CEE3 pas_gc_no_match
CEF4 GETCHK
CEFF CHKNOK
CF02 CHKOK
CF04 CHKTKN
CF09 GET_LOOK
CF13 LCD_welcome
CF31 START
CF55 RESTART
CF5A REST1
4240 CLOCK_RATE
