Sections:
00: "seg8000" (8000-D15E)
01: "segfffa" (FFFA-0)


Source: "gpascal.asm"
                        	     1: ;***********************************************
                        	     2: ; G-PASCAL COMPILER
                        	     3: ; for Ben Eater's breadboard computer
                        	     4: ;
                        	     5: ; Author: Nick Gammon
                        	     6: ; Date: 20 January 2022
                        	     7: ;
                        	     8: ; To compile:
                        	     9: ;
                        	    10: ;  vasm6502_oldstyle gpascal.asm -wdc02 -esc -Fbin -o gpascal.bin -dotdir -L gpascal.list
                        	    11: ;
                        	    12: ; To program EEPROM:
                        	    13: ;
                        	    14: ;  minipro -p AT28C256 -w gpascal.bin
                        	    15: ;
                        	    16: ;
                        	    17: ;
                        	    18: ; To communicate, I suggest: miniterm /dev/ttyUSB0 4800 -e
                        	    19: ;
                        	    20: ;   Miniterm: Ctrl+]        : to exit.
                        	    21: ;             Ctrl+T Ctrl+H : help
                        	    22: ;             Ctrl+T Ctrl+E : toggle local echo
                        	    23: ;
                        	    24: ;
                        	    25: ;  Copyright 2022 by Nick Gammon
                        	    26: ;
                        	    27: ;  Permission is hereby granted, free of charge, to any person obtaining a copy
                        	    28: ;  of this software and associated documentation files (the "Software"), to deal
                        	    29: ;  in the Software without restriction, including without limitation the rights
                        	    30: ;  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                        	    31: ;  copies of the Software, and to permit persons to whom the Software is
                        	    32: ;  furnished to do so, subject to the following conditions:
                        	    33: ;
                        	    34: ;  The above copyright notice and this permission notice shall be included in all
                        	    35: ;  copies or substantial portions of the Software.
                        	    36: ;
                        	    37: ;  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                        	    38: ;  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                        	    39: ;  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                        	    40: ;  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                        	    41: ;  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                        	    42: ;  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
                        	    43: ;  SOFTWARE.
                        	    44: ;
                        	    45: ;***********************************************
                        	    46: ;
                        	    47: 
                        	    48: ; Note: BCC == BLT and BCS == BGE
                        	    49: ;
                        	    50: 
                        	    51: ;
                        	    52: ;  CONDITIONAL COMPILES
                        	    53: 
                        	    54: EMULATOR = 0          ; for testing on a PC running an emulator
                        	    55: LCD_SUPPORT = 1       ; 1 = support LCD, 0 = not. Unset if you have removed the LCD.
                        	    56: SERIAL_DEBUGGING = 0  ; if set, toggle VIA PA2 when reading a bit, and PA3 when writing a bit
                        	    57:                       ;  DO NOT USE I2C if this is on, as I2C functions use these two pins
                        	    58: 
                        	    59: ;
                        	    60: ;  CONFIGURATION
                        	    61: ;
                        	    62: CLOCK_RATE   = 1000000   ; 1 Mhz
                        	    63: START_OF_ROM = $8000     ; where the ROM chip starts
                        	    64: HIGHEST_RAM  = $3FFF      ; original board hardware
                        	    65: ;HIGHEST_RAM  = $5FFF    ; with suggested additional AND gate
                        	    66: 
                        	    67: ;
                        	    68: ;  serial output
                        	    69: ;
                        	    70: BAUD_RATE    = 4800         ; baud
                        	    71: BIT_INTERVAL = CLOCK_RATE / BAUD_RATE ; time between bits in Âµs
                        	    72: 
                        	    73: ;
                        	    74: ;  serial input - input commences on the interrupt generated by the falling edge
                        	    75: ;    of the start bit. Bits are then clocked in with a timed loop.
                        	    76: ;  - these delays can be tweaked if you believe the serial input is not being
                        	    77: ;    sampled at the right moment, confirm by turning SERIAL_DEBUGGING on
                        	    78: ;    and checking the debugging pulses compared to the middle of the bit times
                        	    79: ;    with an oscilloscope or logic analyser
                        	    80: ;
                        	    81: SERIAL_DELAY1 = 48    ; initial delay (count) - higher because it is 1.5 bit times
                        	    82: SERIAL_DELAY2 = 35    ; subsequent delays between bits (count)
                        	    83: 
                        	    84: SYMBOL_TABLE_START = HIGHEST_RAM  ; symbol table pointer (ENDSYM) is decremented before being used
                        	    85: 
                        	    86: STACK            =  $100  ; hardware stack address
                        	    87: SPACE            =  $20   ; uh-huh
                        	    88: SINGLE_QUOTE     =  $27
                        	    89: NL               =  $0A   ; newline
                        	    90: CR               =  $0D   ; carriage-return
                        	    91: BACKSPACE        =  $08   ; backspace
                        	    92: 
                        	    93: MAX_STK          =  32
                        	    94: NEW_STK          =  $FF
                        	    95: 
                        	    96:     .if EMULATOR
                        	    97: END_EDITOR_INPUT =  '`'   ; backtick terminates input
                        	    98:     .else
                        	    99: END_EDITOR_INPUT =  $1B   ; Esc terminates editor input
                        	   100:     .endif
                        	   101: 
                        	   102: KEY_DEBUG      = 'D'-$40   ; Ctrl+D start debugging
                        	   103: KEY_TRACE      = 'T'-$40   ; Ctrl+T start tracing
                        	   104: KEY_STOP_TRACE = 'N'-$40   ; Ctrl+N stop tracing
                        	   105: KEY_ABORT      = 'C'-$40   ; Ctrl+C abort execution
                        	   106: 
                        	   107: 
                        	   108:   .if LCD_SUPPORT
                        	   109: ;
                        	   110: ;  Pins connected from the VIA to the LCD
                        	   111: ;
                        	   112: LCD_RS             = %00100000  ; PA 5 - 0 = instruction, 1 = data
                        	   113: LCD_RW             = %01000000  ; PA 6 - 0 = write, 1 = read
                        	   114: LCD_E              = %10000000  ; PA 7 - toggle (0 -> 1 -> 0) to clock out a command or data
                        	   115:   .endif
                        	   116: 
                        	   117:   .include "zp_variables.inc"

Source: "zp_variables.inc"
                        	     1: ;***********************************************
                        	     2: ;
                        	     3: ; Zero-page variables (currently 64 (decimal) bytes are free for your use).
                        	     4: ;  I suggest using the high ones and working down in case there is a change to the code.
                        	     5: ;  For example, start with 0xFF, then 0xFE and so on.
                        	     6: ;
                        	     7: ;***********************************************
                        	     8: 
                        	     9:   .dsect
                        	    10: 
                        	    11: 
                        	    12: ;
                        	    13: ;  General work-areas for arithmetic routines (eg. add, subtract, divide, multiply)
                        	    14: ;   3-byte signed numbers: -8388608 to +8388607
                        	    15: ;
00:0000 00              	    16: VALUE    reserve 3    ; the current value of the token (ie. if a number)
00:0001 *
00:0003 00              	    17: VALUE2   reserve 3    ; used by the assembler expression evaluator
00:0004 *
                        	    18: 
                        	    19: ; SRCE and DEST used in compiler and editor, particularly for string comparisons
                        	    20: ;   (re-using VALUE and VALUE2)
                        	    21: 
                        	    22: SRCE     =  VALUE
                        	    23: DEST     =  VALUE2
                        	    24: 
00:0006 00              	    25: REMAIN   reserve 3    ; division remainder
00:0007 *
                        	    26: 
                        	    27: ;
                        	    28: ;  work "register" - re-using VALUE and VALUE2 again
                        	    29: ;
                        	    30: REG   = VALUE
                        	    31: REGB  = VALUE+2
                        	    32: REG2  = VALUE2
                        	    33: REG2B = VALUE2+2
                        	    34: 
                        	    35: ;
                        	    36: ;  re-using above for CRC-16 calculations
                        	    37: ;
                        	    38: crc_addr = VALUE      ; the address to take a CRC of (2 bytes)
                        	    39: crc_num  = VALUE2     ; the number of bytes to take a CRC of (2 bytes)
                        	    40: crc_val  = REMAIN     ; the current CRC value (2 bytes)
                        	    41: 
                        	    42: ;
                        	    43: ;  current random number - change this to reseed it
                        	    44: ;
00:0009 00              	    45: random         reserve 4 ; 32-bit random number
00:000A *
00:000D 00              	    46: typing_latency reserve 3 ; incremented while waiting for input
00:000E *
                        	    47: 
                        	    48: ;
                        	    49: ;  Used for seeding registers when calling machine code from Pascal
                        	    50: ;
00:0010 00              	    51: call_a reserve 1      ; used when doing a machine code call:  A register
00:0011 00              	    52: call_x reserve 1      ;  ditto: X register
00:0012 00              	    53: call_y reserve 1      ;  ditto: Y register
00:0013 00              	    54: call_p reserve 1      ;  ditto: status register
00:0014 00              	    55: call_s reserve 1      ; stack register, used by BRK
00:0015 00              	    56: brk_address reserve 2 ; BRK address
00:0016 *
                        	    57: 
                        	    58: ;
                        	    59: ;  address of write function (2 bytes)
                        	    60: ;
                        	    61: ;  This is called by "character out" function COUT. It writes the character in "A" to
                        	    62: ;   serial port or LCD. You could conceivably put another function address here if
                        	    63: ;   you wanted to capture output (eg. from calling DISP_BIN) and putting it somewhere else
                        	    64: ;   like into a series of memory locations, or to output to SPI.
                        	    65: ;  The functions write_to_serial and write_to_lcd
                        	    66: ;   put the appropriate outputting functions into this location.
                        	    67: ;
00:0017 00              	    68: write_function reserve 2  ; address of function to write to serial or LCD
00:0018 *
                        	    69: 
                        	    70: 
00:0019 00              	    71: LINE_CNT  reserve 2   ; line counter during compile
00:001A *
                        	    72: LINE_NO  =  LINE_CNT
                        	    73: 
00:001B 00              	    74: WX       reserve 2    ; 2-byte address used during compilation (reserved word lookup)
00:001C *
00:001D 00              	    75: LIST     reserve 1    ; 0 = no listing, 1 = list source during compile
00:001E 00              	    76: DIGIT    reserve 1    ; used only in GET_NUM to process a decimal number
00:001F 00              	    77: SIGN     reserve 1    ; used in compiling and inputting a number - is there a minus sign?
                        	    78: 
00:0020 00              	    79: FRAME    reserve 2    ; stack frame number - not totally certain but it used for procedure calls at runtime
00:0021 *
00:0022 00              	    80: LEVEL    reserve 1    ; current nested procedure/function level (how far we are nested)
00:0023 00              	    81: PCODE    reserve 2    ; current P-code address (increments during compile and running)
00:0024 *
                        	    82: PNTR     =  PCODE     ; 2-byte work pointer used in editor (eg. in find/replace etc.)
00:0025 00              	    83: ACT_PCDA reserve 2    ; start of P-codes (after source) - does not increment
00:0026 *
00:0027 00              	    84: DISPL    reserve 2    ; level? ahhh ... I don't know
00:0028 *
00:0029 00              	    85: OFFSET   reserve 2    ; variable offset? maybe just a work area
00:002A *
00:002B 00              	    86: OPND     reserve 3    ; jump operand ... not sure
00:002C *
00:002E 00              	    87: DCODE    reserve 1     ; 0 = no display, 1 = display P-codes during compile
00:002F 00              	    88: STARTSYM reserve 2    ; start of symbol table
00:0030 *
00:0031 00              	    89: ENDSYM   reserve 2    ; end of symbol table - used for reverse searching symbols
00:0032 *
                        	    90: T        =  ENDSYM     ; stack pointer 2 bytes
00:0033 00              	    91: WORKD    reserve 2    ; work area for holding P-code address
00:0034 *
00:0035 00              	    92: ERRNO    reserve 1    ; current error number, if ERROR called
00:0036 00              	    93: BSAVE    reserve 1    ; seems to be used to save "A" register, lol
00:0037 00              	    94: WORK     reserve 2    ; work area, used for pushing 2-bytes onto the (processor) stack
00:0038 *
00:0039 00              	    95: PRCITM   reserve 2    ; seems to hold the current procedure/function symbol
00:003A *
00:003B 00              	    96: BASE     reserve 2    ; the base interpreter stack frame (for this procedure)
00:003C *
                        	    97: TO       =  BASE      ; Used in editor (from/to list ranges, and copying text)
00:003D 00              	    98: DATA     reserve 2    ; 2-byte address work-area for calculating the address of a variable at runtime
00:003E *
00:003F 00              	    99: RUNNING  reserve 1    ; 0x40 - in editor, 0x80 - executing - affects stuff like numeric conversion
00:0040 00              	   100: SYMITM   reserve 2    ; current symbol table item (found by searching)
00:0041 *
                        	   101: FROM     =  SYMITM    ; Used in editor (from/to list ranges, and copying text)
00:0042 00              	   102: SYNTAX   reserve 1    ; 0 = full compile, 1 = syntax-only compile (no writing to memory)
00:0043 00              	   103: END_PCD  reserve 2    ; where the P-codes ended after a compile
00:0044 *
00:0045 00              	   104: TEMP     reserve 2    ; temporary work area?
00:0046 *
00:0047 00              	   105: CALL     reserve 2    ; the procedure address we are calling
00:0048 *
00:0049 00              	   106: DBGFLG   reserve 1    ; 0 = not debugging, 1 = debugging, $80 = tracing
00:004A 00              	   107: DATTYP   reserve 1    ; 0 for integers and 1 for characters
00:004B 00              	   108: COUNT1   reserve 1    ; work counter
00:004C 00              	   109: COUNT2   reserve 1    ; and another
00:004D 00              	   110: LASTP    reserve 2    ; 2-byte last P-code address executed at runtime (start of this P-code)
00:004E *
00:004F 00              	   111: IO_A     reserve 1    ; dunno
00:0050 00              	   112: IO_Y     reserve 1    ; seems to be used to save and restore Y
00:0051 00              	   113: IO_X     reserve 1    ;  ditto for X
00:0052 00              	   114: RES      reserve 3    ; multiplication result
00:0053 *
00:0055 00              	   115: MCAND    reserve 3    ; multiplicand
00:0056 *
                        	   116: DIVISOR  = MCAND      ; divisor for division (shares with multiplicand for multiplication)
00:0058 00              	   117: DVDN     reserve 3    ; dividend
00:0059 *
00:005B 00              	   118: RMNDR    reserve 1    ; for division, 0 if positive, 0x80 if negative
00:005C 00              	   119: bcd_work    reserve 4    ; work area for converting binary to decimal (packed)
00:005D *
00:0060 00              	   120: bcd_result  reserve 8    ; work area for turning numbers into printable (unpacked)
00:0061 *
00:0068 00              	   121: QT_TGL   reserve 1    ; quote toggle
00:0069 00              	   122: QUOT_SYM reserve 1     ; current quote symbol
00:006A 00              	   123: QT_SIZE  reserve 1    ; number of characters in reserved words
00:006B 00              	   124: ASS_OPERAND reserve 1 ; assembler operand type = see defines below
00:006C 00              	   125: OPCODE   reserve 2    ; address of opcode in assembler
00:006D *
00:006E 00              	   126: OPCODE_LEN reserve 1  ; length of opcode
00:006F 00              	   127: ASS_EMIT_COUNT reserve 1 ; number of bytes emitted on this line
00:0070 00              	   128: ASS_OPCODE_WORK reserve 2; for opcode lookups
00:0071 *
00:0072 00              	   129: ASS_COUNT reserve 1 ; for counting opcode matches
00:0073 00              	   130: ASS_VALUE reserve 3 ; the assembler operand (address or immediate) will be here
00:0074 *
00:0076 00              	   131: ASS_PASS  reserve 1 ; which assembler pass we are up to
00:0077 00              	   132: ass_emit_bytes reserve 2 ; how many bytes the assembler emitted altogether
00:0078 *
00:0079 00              	   133: exp_value_stack reserve 2  ; address of assembler value stack
00:007A *
00:007B 00              	   134: exp_value_stack_count reserve 1 ; how far through value stack we are (0 = empty)
00:007C 00              	   135: exp_operator_stack_count reserve 1 ;  how far through operator stack we are (0 = empty)
00:007D 00              	   136: exp_operator reserve 1  ; current operator for expression evaluation
00:007E 00              	   137: exp_operator_precedence reserve 1 ; current operator precedence
00:007F 00              	   138: exp_evaluation_function reserve 2 ; function to evaluate an expression
00:0080 *
00:0081 00              	   139: exp_unary_ok reserve 1  ; true if the next token can be a unary operator (like: - < >)
00:0082 00              	   140: show_symbols reserve 1  ; true to list the symbol table after an assemble
00:0083 00              	   141: ass_current_label reserve 2 ; current symbol table address of the label on this line
00:0084 *
00:0085 00              	   142: str_work reserve 1      ; work byte for string compares
                        	   143:   .if LCD_SUPPORT
00:0086 00              	   144: lcd_work  reserve 1 ; used by the LCD routines
                        	   145:   .endif
                        	   146: 
                        	   147: ;
                        	   148: ;  serial work
                        	   149: ;
00:0087 00              	   150: serial_out_byte reserve 2 ; current byte we are sending
00:0088 *
00:0089 00              	   151: serial_out_bit  reserve 1 ; current bit count
00:008A 00              	   152: serial_in_byte  reserve 1 ; current byte we are receiving
00:008B 00              	   153: serial_in_byte_received  reserve 1 ; last received byte
                        	   154: 
                        	   155: ;
                        	   156: ; hardware
                        	   157: ;
00:008C 00              	   158: hardware_work  reserve 1  ; work for use during interpreting
                        	   159: 
                        	   160: ;
                        	   161: ; maths
                        	   162: ;
00:008D 00              	   163: maths_work  reserve 1 ; work for multiply/divide
                        	   164: ;
                        	   165: ;  for get_token
                        	   166: ;
00:008E 00              	   167: token_start      reserve 2  ; where to start looking for a token
00:008F *
00:0090 00              	   168: token_address    reserve 2  ; where the token actually started
00:0091 *
00:0092 00              	   169: token_length     reserve 1  ; length of the token
00:0093 00              	   170: token_type       reserve 1  ; what type of token it is
00:0094 00              	   171: token_value      reserve 3  ; the value of numeric tokens
00:0095 *
00:0097 00              	   172: token_sign       reserve 1  ; non-zero if negative value
00:0098 00              	   173: token_work       reserve 3  ; temporary work area - also used by handlerLookup
00:0099 *
00:009B 00              	   174: token_digit      reserve 1  ; used by get_token
00:009C 00              	   175: token_line_start reserve 2  ; where the current line starts
00:009D *
                        	   176: 
                        	   177: ;
                        	   178: ;  for editor
                        	   179: ;
00:009E 00              	   180: from_line       reserve 2     ; list, delete, modify: FROM line number
00:009F *
00:00A0 00              	   181: to_line         reserve 2     ; list, delete, modify: TO line number
00:00A1 *
00:00A2 00              	   182: current_line    reserve 2     ; current editor line number
00:00A3 *
00:00A4 00              	   183: insert_limit    reserve 2     ; maximum we can input to
00:00A5 *
00:00A6 00              	   184: mem_move_src    reserve 2     ; for copying memory - source of move
00:00A7 *
00:00A8 00              	   185: mem_move_dest   reserve 2     ; for copying memory - destination of move
00:00A9 *
00:00AA 00              	   186: mem_move_len    reserve 2     ; for copying memory - length of move
00:00AB *
00:00AC 00              	   187: this_line       reserve 2     ; which line we are searching for
00:00AD *
00:00AE 00              	   188: this_line_addr  reserve 2     ; address of the "this" line
00:00AF *
00:00B0 00              	   189: find_from       reserve 1     ; editor find: from offset in INBUF (start of target string)
00:00B1 00              	   190: find_to         reserve 1     ; editor find: to offset in INBUF (end of target string)
00:00B2 00              	   191: find_pos        reserve 1     ; which offset in the current line we are currently searching from
00:00B3 00              	   192: find_len        reserve 1     ; the length of the find text
00:00B4 00              	   193: find_delimiter  reserve 1     ; the find/replace delimiter
00:00B5 00              	   194: rep_from        reserve 1     ; editor replace: start of replacement string
00:00B6 00              	   195: rep_to          reserve 1     ; editor replace: end of replacement string
00:00B7 00              	   196: rep_diff        reserve 2     ; difference in find/replace string lengths (signed 2 bytes)
00:00B8 *
00:00B9 00              	   197: find_count      reserve 2     ; count of find/replace
00:00BA *
00:00BB 00              	   198: found_this_line reserve 1     ; did we find something on this line?
                        	   199: insert_last_char = find_from  ; the last character we inserted in INSERT/LOAD mode
                        	   200: 
00:00BC 00              	   201: editor_flags    reserve 1     ; various flags, see below
                        	   202: 
                        	   203: EFLAG_SHOW_LINE        = %00000001    ; set after receiving a newline, so we display the next line
                        	   204: EFLAG_ALLOW_ZERO_FROM  = %00000010    ; for use with MEMORY, allow them to start from $0000
                        	   205: EFLAG_LOAD             = %00000100    ; doing a LOAD, do not show line numbers when inserting
                        	   206: EFLAG_SAVE             = %00001000    ; doing a SAVE, do not show line numbers
                        	   207: EFLAG_FIND             = %00010000    ; doing a FIND
                        	   208: EFLAG_REPLACE          = %00100000    ; doing a REPLACE
                        	   209: EFLAG_SUPPRESS_NEWLINE = %01000000    ; don't show newlines
                        	   210: EFLAG_NO_LINE_NUMBERS  = %10000000    ; don't show line numbers
                        	   211: 
00:00BD 00              	   212: find_flags     reserve 1      ; find/replace flags, see below
                        	   213: 
                        	   214: FFLAG_IGNORE_CASE = %00000001
                        	   215: FFLAG_GLOBAL      = %00000010
                        	   216: FFLAG_QUIET       = %00000100
                        	   217: 
                        	   218: ;
                        	   219: ;  system flags
                        	   220: ;
                        	   221: 
00:00BE 00              	   222: system_flags    reserve 1    ; general flags
                        	   223: 
                        	   224: FLAG_COMPILING      = %00000001
                        	   225: FLAG_ASSEMBLING     = %00000010
                        	   226: FLAG_LIST_SOURCE    = %00000100
                        	   227: FLAG_VALID_COMPILE  = %00001000
                        	   228: FLAG_VALID_ASSEMBLE = %00010000
                        	   229: FLAG_RUNNING        = %00100000
                        	   230: FLAG_ONLY_ALPHA     = %01000000   ; for editor, so you can L5 to do LIST 5
                        	   231: FLAG_ABORTED        = %10000000   ; Ctrl+C pressed during printing
                        	   232: 

Source: "gpascal.asm"
                        	   118: 
                        	   119: ;
                        	   120: ;  A general work-buffer is allocated from $200 to $2FF for use during keyboard input, and also
                        	   121: ;  for converting strings during tokenisation (eg. two quotes in a row to one quote, and handling
                        	   122: ;  string escape sequences). It is also used during assembly as a 256-byte operator stack.
                        	   123: ;
                        	   124:   .org $200
                        	   125: INBUF_SIZE = 256          ; we use this for string storage during tokenisation
01:0200 00              	   126: INBUF  reserve INBUF_SIZE ; and also for preprocessing string literals (eg. backslash expansion)
01:0201 *
                        	   127: TEXT_START = *            ; where source goes in memory (currently $300)
                        	   128:   .dend
                        	   129: 
                        	   130: 
                        	   131: 
                        	   132: ;------------------------------------------
                        	   133: ;  Macros
                        	   134: ;------------------------------------------
                        	   135: 
                        	   136:  .macro tknjmpItem ; tknjmp entry: token, handler
                        	   137:    dfb   \1
                        	   138:    word  \2
                        	   139:  .endmacro
                        	   140: 
                        	   141:  .macro makeHandler ; table of words and handlers: word, handler
                        	   142:    asciiz   \1
                        	   143:    word  \2
                        	   144:  .endmacro
                        	   145: 
                        	   146: ;
                        	   147: ; makePasLibraryFunction NAME (SYMNAM), TYPE (SYMTYP), ARG_COUNT (SYMARG), EXECUTION_ADDRESS (SYMDSP)
                        	   148: ;
                        	   149: ;   TYPE = SYMBOL_LIBRARY_PROCEDURE or SYMBOL_LIBRARY_FUNCTION
                        	   150:    .macro makePasLibraryFunction
                        	   151:      asciiz   \1
                        	   152:      dfb      \2
                        	   153:      dfb      \3
                        	   154:      word     \4
                        	   155:    .endmacro
                        	   156: 
                        	   157: ;
                        	   158: ; makeAsmLibraryFunction NAME (SYMNAM), EXECUTION_ADDRESS (SYMDSP)
                        	   159: ;
                        	   160:    .macro makeAsmLibraryFunction
                        	   161:      asciiz   \1
                        	   162:      word     \2
                        	   163:    .endmacro
                        	   164: 
                        	   165:   ORG  START_OF_ROM   ; normally $8000 in the case of Ben Eater's board
                        	   166: 
00:8000 4C29D1          	   167:   JMP  START   ; where RESET takes us - a cold start
00:8003 4C45D1          	   168:   JMP  RESTART ; where NMI takes us - a warm start
                        	   169: 
                        	   170: ;***********************************************
                        	   171: ; INCLUDES
                        	   172: ;***********************************************
                        	   173: 
                        	   174:   .include "memory.inc"

Source: "memory.inc"
                        	     1: ;---------------------------
                        	     2: ; standard library stuff
                        	     3: ;---------------------------
                        	     4: 
                        	     5: ;
                        	     6: ;  character type masks
                        	     7: ;
                        	     8: m_upper   = %00000001    ; $01
                        	     9: m_lower   = %00000010    ; $02
                        	    10: m_alpha   = %00000100    ; $04
                        	    11: m_digit   = %00001000    ; $08
                        	    12: m_xdigit  = %00010000    ; $10
                        	    13: m_space   = %00100000    ; $20
                        	    14: m_cntrl   = %01000000    ; $40
                        	    15: m_alnum   = %10000000    ; $80
                        	    16: 
                        	    17: ;
                        	    18: ;  for fast checks which corrupt registers
                        	    19: ;
                        	    20: ;    ldx THE_CHARACTER_TO_BE_TESTED
                        	    21: ;    lda character_types_table,X
                        	    22: ;    bne IS_IN_THAT_CLASS
                        	    23: ;
                        	    24: 
                        	    25: character_types_table = *
00:8006 40              	    26:   dfb $40,$40,$40,$40,$40,$40,$40,$40    ; 0x00
00:8007 40
00:8008 40
00:8009 40
00:800A 40
00:800B 40
00:800C 40
00:800D 40
00:800E 40              	    27:   dfb $40,$60,$60,$60,$60,$60,$40,$40    ; 0x08
00:800F 60
00:8010 60
00:8011 60
00:8012 60
00:8013 60
00:8014 40
00:8015 40
00:8016 40              	    28:   dfb $40,$40,$40,$40,$40,$40,$40,$40    ; 0x10
00:8017 40
00:8018 40
00:8019 40
00:801A 40
00:801B 40
00:801C 40
00:801D 40
00:801E 40              	    29:   dfb $40,$40,$40,$40,$40,$40,$40,$40    ; 0x18
00:801F 40
00:8020 40
00:8021 40
00:8022 40
00:8023 40
00:8024 40
00:8025 40
00:8026 20              	    30:   dfb $20,$00,$00,$00,$00,$00,$00,$00    ; 0x20   !"#$%&'
00:8027 00
00:8028 00
00:8029 00
00:802A 00
00:802B 00
00:802C 00
00:802D 00
00:802E 00              	    31:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x28  ()*+,-./
00:802F 00
00:8030 00
00:8031 00
00:8032 00
00:8033 00
00:8034 00
00:8035 00
00:8036 98              	    32:   dfb $98,$98,$98,$98,$98,$98,$98,$98    ; 0x30  01234567
00:8037 98
00:8038 98
00:8039 98
00:803A 98
00:803B 98
00:803C 98
00:803D 98
00:803E 98              	    33:   dfb $98,$98,$00,$00,$00,$00,$00,$00    ; 0x38  89:;<=>?
00:803F 98
00:8040 00
00:8041 00
00:8042 00
00:8043 00
00:8044 00
00:8045 00
00:8046 00              	    34:   dfb $00,$95,$95,$95,$95,$95,$95,$85    ; 0x40  @ABCDEFG
00:8047 95
00:8048 95
00:8049 95
00:804A 95
00:804B 95
00:804C 95
00:804D 85
00:804E 85              	    35:   dfb $85,$85,$85,$85,$85,$85,$85,$85    ; 0x48  HIJKLMNO
00:804F 85
00:8050 85
00:8051 85
00:8052 85
00:8053 85
00:8054 85
00:8055 85
00:8056 85              	    36:   dfb $85,$85,$85,$85,$85,$85,$85,$85    ; 0x50  PQRSTUVW
00:8057 85
00:8058 85
00:8059 85
00:805A 85
00:805B 85
00:805C 85
00:805D 85
00:805E 85              	    37:   dfb $85,$85,$85,$00,$00,$00,$00,$00    ; 0x58  XYZ[\]^_
00:805F 85
00:8060 85
00:8061 00
00:8062 00
00:8063 00
00:8064 00
00:8065 00
00:8066 00              	    38:   dfb $00,$96,$96,$96,$96,$96,$96,$86    ; 0x60  `abcdefg
00:8067 96
00:8068 96
00:8069 96
00:806A 96
00:806B 96
00:806C 96
00:806D 86
00:806E 86              	    39:   dfb $86,$86,$86,$86,$86,$86,$86,$86    ; 0x68  hijklmno
00:806F 86
00:8070 86
00:8071 86
00:8072 86
00:8073 86
00:8074 86
00:8075 86
00:8076 86              	    40:   dfb $86,$86,$86,$86,$86,$86,$86,$86    ; 0x70  pqrstuvw
00:8077 86
00:8078 86
00:8079 86
00:807A 86
00:807B 86
00:807C 86
00:807D 86
00:807E 86              	    41:   dfb $86,$86,$86,$00,$00,$00,$00,$40    ; 0x78  xyz{|}~
00:807F 86
00:8080 86
00:8081 00
00:8082 00
00:8083 00
00:8084 00
00:8085 40
00:8086 00              	    42:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x80
00:8087 00
00:8088 00
00:8089 00
00:808A 00
00:808B 00
00:808C 00
00:808D 00
00:808E 00              	    43:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x88
00:808F 00
00:8090 00
00:8091 00
00:8092 00
00:8093 00
00:8094 00
00:8095 00
00:8096 00              	    44:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x90
00:8097 00
00:8098 00
00:8099 00
00:809A 00
00:809B 00
00:809C 00
00:809D 00
00:809E 00              	    45:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x98
00:809F 00
00:80A0 00
00:80A1 00
00:80A2 00
00:80A3 00
00:80A4 00
00:80A5 00
00:80A6 00              	    46:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xA0
00:80A7 00
00:80A8 00
00:80A9 00
00:80AA 00
00:80AB 00
00:80AC 00
00:80AD 00
00:80AE 00              	    47:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xA8
00:80AF 00
00:80B0 00
00:80B1 00
00:80B2 00
00:80B3 00
00:80B4 00
00:80B5 00
00:80B6 00              	    48:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xB0
00:80B7 00
00:80B8 00
00:80B9 00
00:80BA 00
00:80BB 00
00:80BC 00
00:80BD 00
00:80BE 00              	    49:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xB8
00:80BF 00
00:80C0 00
00:80C1 00
00:80C2 00
00:80C3 00
00:80C4 00
00:80C5 00
00:80C6 00              	    50:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xC0
00:80C7 00
00:80C8 00
00:80C9 00
00:80CA 00
00:80CB 00
00:80CC 00
00:80CD 00
00:80CE 00              	    51:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xC8
00:80CF 00
00:80D0 00
00:80D1 00
00:80D2 00
00:80D3 00
00:80D4 00
00:80D5 00
00:80D6 00              	    52:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xD0
00:80D7 00
00:80D8 00
00:80D9 00
00:80DA 00
00:80DB 00
00:80DC 00
00:80DD 00
00:80DE 00              	    53:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xD8
00:80DF 00
00:80E0 00
00:80E1 00
00:80E2 00
00:80E3 00
00:80E4 00
00:80E5 00
00:80E6 00              	    54:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xE0
00:80E7 00
00:80E8 00
00:80E9 00
00:80EA 00
00:80EB 00
00:80EC 00
00:80ED 00
00:80EE 00              	    55:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xE8
00:80EF 00
00:80F0 00
00:80F1 00
00:80F2 00
00:80F3 00
00:80F4 00
00:80F5 00
00:80F6 00              	    56:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xF0
00:80F7 00
00:80F8 00
00:80F9 00
00:80FA 00
00:80FB 00
00:80FC 00
00:80FD 00
00:80FE 00              	    57:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xF8
00:80FF 00
00:8100 00
00:8101 00
00:8102 00
00:8103 00
00:8104 00
00:8105 00
                        	    58: 
                        	    59: ;
                        	    60: ;  character type tests: test character in A, Carry set if true, carry clear if false
                        	    61: ;    -no registers changed
                        	    62: ;
                        	    63: is_xxx_fail:
00:8106 FA              	    64:   plx
00:8107 68              	    65:   pla
00:8108 18              	    66:   clc
00:8109 60              	    67:   rts
                        	    68: 
                        	    69: is_xxx_pass:
00:810A FA              	    70:   plx
00:810B 68              	    71:   pla
00:810C 38              	    72:   sec
00:810D 60              	    73:   rts
                        	    74: 
                        	    75:   .macro isXXX
                        	    76: \1 = *
                        	    77:   pha
                        	    78:   phx
                        	    79:   tax
                        	    80:   lda character_types_table,x
                        	    81:   and #\2
                        	    82:   beq is_xxx_fail
                        	    83:   bra is_xxx_pass
                        	    84:   .endmacro
                        	    85: 
                        	    86: ;
                        	    87: ;  generate the various character type tests - done by fast table lookup
                        	    88: ;
                        	    89:   isXXX isupper,  m_upper
                        	     1M isupper = *
00:810E 48              	     2M   pha
00:810F DA              	     3M   phx
00:8110 AA              	     4M   tax
00:8111 BD0680          	     5M   lda character_types_table,x
00:8114 2901            	     6M   and #m_upper
00:8116 F0EE            	     7M   beq is_xxx_fail
00:8118 80F0            	     8M   bra is_xxx_pass
                        	    90:   isXXX islower,  m_lower
                        	     1M islower = *
00:811A 48              	     2M   pha
00:811B DA              	     3M   phx
00:811C AA              	     4M   tax
00:811D BD0680          	     5M   lda character_types_table,x
00:8120 2902            	     6M   and #m_lower
00:8122 F0E2            	     7M   beq is_xxx_fail
00:8124 80E4            	     8M   bra is_xxx_pass
                        	    91:   isXXX isalpha,  m_alpha
                        	     1M isalpha = *
00:8126 48              	     2M   pha
00:8127 DA              	     3M   phx
00:8128 AA              	     4M   tax
00:8129 BD0680          	     5M   lda character_types_table,x
00:812C 2904            	     6M   and #m_alpha
00:812E F0D6            	     7M   beq is_xxx_fail
00:8130 80D8            	     8M   bra is_xxx_pass
                        	    92:   isXXX isdigit,  m_digit
                        	     1M isdigit = *
00:8132 48              	     2M   pha
00:8133 DA              	     3M   phx
00:8134 AA              	     4M   tax
00:8135 BD0680          	     5M   lda character_types_table,x
00:8138 2908            	     6M   and #m_digit
00:813A F0CA            	     7M   beq is_xxx_fail
00:813C 80CC            	     8M   bra is_xxx_pass
                        	    93:   isXXX isxdigit, m_xdigit
                        	     1M isxdigit = *
00:813E 48              	     2M   pha
00:813F DA              	     3M   phx
00:8140 AA              	     4M   tax
00:8141 BD0680          	     5M   lda character_types_table,x
00:8144 2910            	     6M   and #m_xdigit
00:8146 F0BE            	     7M   beq is_xxx_fail
00:8148 80C0            	     8M   bra is_xxx_pass
                        	    94:   isXXX isspace,  m_space
                        	     1M isspace = *
00:814A 48              	     2M   pha
00:814B DA              	     3M   phx
00:814C AA              	     4M   tax
00:814D BD0680          	     5M   lda character_types_table,x
00:8150 2920            	     6M   and #m_space
00:8152 F0B2            	     7M   beq is_xxx_fail
00:8154 80B4            	     8M   bra is_xxx_pass
                        	    95:   isXXX iscntrl,  m_cntrl
                        	     1M iscntrl = *
00:8156 48              	     2M   pha
00:8157 DA              	     3M   phx
00:8158 AA              	     4M   tax
00:8159 BD0680          	     5M   lda character_types_table,x
00:815C 2940            	     6M   and #m_cntrl
00:815E F0A6            	     7M   beq is_xxx_fail
00:8160 80A8            	     8M   bra is_xxx_pass
                        	    96:   isXXX isalnum,  m_alnum
                        	     1M isalnum = *
00:8162 48              	     2M   pha
00:8163 DA              	     3M   phx
00:8164 AA              	     4M   tax
00:8165 BD0680          	     5M   lda character_types_table,x
00:8168 2980            	     6M   and #m_alnum
00:816A F09A            	     7M   beq is_xxx_fail
00:816C 809C            	     8M   bra is_xxx_pass
                        	    97: 
                        	    98: ;
                        	    99: ;  ran out of bits so implemented this one manually
                        	   100: ;
                        	   101: isbinary   =  *
00:816E C930            	   102:          cmp  #'0'
00:8170 F004            	   103:          beq  isbin
00:8172 C931            	   104:          cmp  #'1'
00:8174 D002            	   105:          bne  notbin
                        	   106: isbin:
00:8176 38              	   107:          sec
00:8177 60              	   108:          rts
                        	   109: notbin:
00:8178 18              	   110:          clc
00:8179 60              	   111:          rts
                        	   112: 
                        	   113: ;
                        	   114: ; Move memory down  (mem_move_dest is < mem_move_src)
                        	   115: ;
                        	   116: ;  Copies first byte first, working upwards
                        	   117: ;
                        	   118: ; mem_move_src = source start address
                        	   119: ; mem_move_dest = destination start address
                        	   120: ; mem_move_len = number of bytes mem_move_dest move
                        	   121: ;
                        	   122: movedown:
00:817A A5AA            	   123:   lda mem_move_len
00:817C 05AB            	   124:   ora mem_move_len+1
00:817E F01C            	   125:   beq movedown_done
00:8180 A000            	   126:   ldy #0
00:8182 8498            	   127:   sty  token_work      ; counter
00:8184 8499            	   128:   sty  token_work+1
                        	   129: ;
                        	   130: ;  copy one byte, increment counter
                        	   131: ;
                        	   132: movedown_loop:
00:8186 B1A6            	   133:   lda (mem_move_src),Y
00:8188 91A8            	   134:   sta (mem_move_dest),Y
00:818A E698            	   135:   inc token_work
00:818C D002            	   136:   bne movedown2
00:818E E699            	   137:   inc token_work+1
                        	   138: ;
                        	   139: ;  see if length reached
                        	   140: ;
                        	   141: movedown2:
                        	   142: 
00:8190 A598            	   143:   lda  token_work
00:8192 C5AA            	   144:   cmp  mem_move_len
00:8194 D007            	   145:   bne  movedown1
00:8196 A599            	   146:   lda  token_work+1
00:8198 C5AB            	   147:   cmp  mem_move_len+1
00:819A D001            	   148:   bne  movedown1
                        	   149: movedown_done:
00:819C 60              	   150:   rts
                        	   151: 
                        	   152: ;
                        	   153: ; increment Y, and increment high-order address bytes if necessary
                        	   154: ;
                        	   155: movedown1:
00:819D C8              	   156:   iny
00:819E D0E6            	   157:   bne  movedown_loop
00:81A0 E6A7            	   158:   inc  mem_move_src+1
00:81A2 E6A9            	   159:   inc  mem_move_dest+1
00:81A4 80E0            	   160:   bra  movedown_loop
                        	   161: 
                        	   162: ; Move memory up (mem_move_dest is > mem_move_src)
                        	   163: ;
                        	   164: ;   Copies last byte first, moving downwards
                        	   165: ;
                        	   166: ; mem_move_src = source start address
                        	   167: ; mem_move_dest = destination start address
                        	   168: ; mem_move_len = number of bytes mem_move_dest move
                        	   169: ;
                        	   170: moveup:
00:81A6 A5AA            	   171:   lda mem_move_len
00:81A8 05AB            	   172:   ora mem_move_len+1
00:81AA F038            	   173:   beq moveup_done
00:81AC A000            	   174:   ldy #0
00:81AE 8498            	   175:   sty  token_work      ; counter
00:81B0 8499            	   176:   sty  token_work+1
                        	   177:   ;
                        	   178:   ;  calculate final address of source
                        	   179:   ;
00:81B2 18              	   180:   clc
00:81B3 A5A6            	   181:   lda mem_move_src
00:81B5 65AA            	   182:   adc mem_move_len
00:81B7 85A6            	   183:   sta mem_move_src
00:81B9 A5A7            	   184:   lda mem_move_src+1
00:81BB 65AB            	   185:   adc mem_move_len+1
00:81BD 85A7            	   186:   sta mem_move_src+1
                        	   187:   ;
                        	   188:   ;  calculate final address of destination
                        	   189:   ;
00:81BF 18              	   190:   clc
00:81C0 A5A8            	   191:   lda mem_move_dest
00:81C2 65AA            	   192:   adc mem_move_len
00:81C4 85A8            	   193:   sta mem_move_dest
00:81C6 A5A9            	   194:   lda mem_move_dest+1
00:81C8 65AB            	   195:   adc mem_move_len+1
00:81CA 85A9            	   196:   sta mem_move_dest+1
00:81CC 8017            	   197:   bra moveup_next   ; have to decrement first
                        	   198: ;
                        	   199: ; move one byte, count moves
                        	   200: ;
                        	   201: moveup_loop:
00:81CE B1A6            	   202:   lda (mem_move_src),Y
00:81D0 91A8            	   203:   sta (mem_move_dest),Y
00:81D2 E698            	   204:   inc token_work
00:81D4 D002            	   205:   bne moveup3
00:81D6 E699            	   206:   inc token_work+1
                        	   207: moveup3:
                        	   208: ;
                        	   209: ;  see if length reached
                        	   210: ;
00:81D8 A598            	   211:   lda token_work
00:81DA C5AA            	   212:   cmp mem_move_len
00:81DC D007            	   213:   bne moveup_next
00:81DE A599            	   214:   lda token_work+1
00:81E0 C5AB            	   215:   cmp mem_move_len+1
00:81E2 D001            	   216:   bne moveup_next
                        	   217: moveup_done:
00:81E4 60              	   218:   rts
                        	   219: ;
                        	   220: ;  decrement Y, and decrement high-order address bytes if necessary
                        	   221: ;
                        	   222: moveup_next   =  *
00:81E5 88              	   223:   dey
00:81E6 C0FF            	   224:   cpy #$FF
00:81E8 D0E4            	   225:   bne moveup_loop
00:81EA C6A7            	   226:   dec mem_move_src+1
00:81EC C6A9            	   227:   dec mem_move_dest+1
00:81EE 80DE            	   228:   bra moveup_loop
                        	   229: 
                        	   230: ;
                        	   231: ;
                        	   232: ; String compare - case significant (max 128 byte strings)
                        	   233: ;
                        	   234: ; SRCE = source start address
                        	   235: ; DEST = destination start address
                        	   236: ; Y    = length of both strings (range 1 to 128)
                        	   237: ;
                        	   238: ;  returns Z set if strings are equal
                        	   239: ;
                        	   240: 
                        	   241: str_compare:
00:81F0 88              	   242:   dey             ; make zero-relative
00:81F1 300B            	   243:   bmi str_compare_done
00:81F3 B100            	   244:   lda (SRCE),y
00:81F5 8585            	   245:   sta str_work
00:81F7 B103            	   246:   lda (DEST),y
00:81F9 C585            	   247:   cmp str_work
00:81FB F0F3            	   248:   beq str_compare
00:81FD 60              	   249:   rts   ; no match, zero flag not set
                        	   250: str_compare_done:
00:81FE A900            	   251:   lda #0    ; set Z flag
00:8200 60              	   252:   rts
                        	   253: 
                        	   254: ;
                        	   255: ; String compare - case NOT significant (max 128 byte strings)
                        	   256: ;
                        	   257: ; SRCE = source start address
                        	   258: ; DEST = destination start address
                        	   259: ; Y    = length of both strings (range 1 to 128)
                        	   260: ;
                        	   261: ;  returns Z set if strings are equal
                        	   262: ;
                        	   263: 
                        	   264: str_ic_compare:
00:8201 88              	   265:   dey
00:8202 301F            	   266:   bmi str_ic_compare_done
00:8204 B100            	   267:   lda (SRCE),y
00:8206 C97B            	   268:   cmp #'z'+1
00:8208 B006            	   269:   bcs str_ic_compare_fixed_srce  ; BGE
00:820A C961            	   270:   cmp #'a'
00:820C 9002            	   271:   bcc str_ic_compare_fixed_srce  ; BLT
00:820E E920            	   272:   sbc #$20    ; make upper-case
                        	   273: str_ic_compare_fixed_srce:
00:8210 8585            	   274:   sta str_work
00:8212 B103            	   275:   lda (DEST),y
00:8214 C97B            	   276:   cmp #'z'+1
00:8216 B006            	   277:   bcs str_ic_compare_fixed_dest  ; BGE
00:8218 C961            	   278:   cmp #'a'
00:821A 9002            	   279:   bcc str_ic_compare_fixed_dest  ; BLT
00:821C E920            	   280:   sbc #$20    ; make upper-case
                        	   281: str_ic_compare_fixed_dest:
00:821E C585            	   282:   cmp str_work
00:8220 F0DF            	   283:   beq str_ic_compare
00:8222 60              	   284:   rts       ; no match, zero flag not set
                        	   285: str_ic_compare_done:
00:8223 A900            	   286:   lda #0    ; set Z flag
00:8225 60              	   287:   rts
                        	   288: 
                        	   289: 

Source: "gpascal.asm"
                        	   175:   .include "editor.inc"

Source: "editor.inc"
                        	     1: ;-------------------------------------------------
                        	     2: ;
                        	     3: ;  Shell, and text editor
                        	     4: ;
                        	     5: ;-------------------------------------------------
                        	     6: 
                        	     7: 
                        	     8: ;-------------------------------------------------
                        	     9: ;  print null-terminated message, message in A (lo) and X (hi)
                        	    10: ;  returns the length of the message in Y
                        	    11: ;-------------------------------------------------
                        	    12: print:
00:8226 A8              	    13:   tay   ; save A
00:8227 A503            	    14:   lda REG2 ; save REG2
00:8229 48              	    15:   pha
00:822A A504            	    16:   lda REG2+1  ; save REG2+1
00:822C 48              	    17:   pha
00:822D 98              	    18:   tya   ; get original A back
00:822E 8503            	    19:   sta REG2
00:8230 8604            	    20:   stx REG2+1
00:8232 A000            	    21:   ldy #0
                        	    22: print_loop:
00:8234 A58B            	    23:   lda  serial_in_byte_received
00:8236 F00A            	    24:   beq  print_not_abort
00:8238 C903            	    25:   cmp  #KEY_ABORT
00:823A D010            	    26:   bne  print_done
00:823C A980            	    27:   lda  #FLAG_ABORTED    ; set aborted flag
00:823E 04BE            	    28:   tsb  system_flags
00:8240 800A            	    29:   bra  print_done
                        	    30: print_not_abort:
00:8242 B103            	    31:   lda (REG2),y
00:8244 F006            	    32:   beq print_done
00:8246 201994          	    33:   jsr COUT
00:8249 C8              	    34:   iny
00:824A D0E8            	    35:   bne print_loop  ; give up if we overflow
                        	    36: print_done:
00:824C 648B            	    37:   stz serial_in_byte_received
                        	    38: ;
                        	    39: ;  get REG2 back
                        	    40: ;
00:824E 68              	    41:   pla
00:824F 8504            	    42:   sta REG2+1
00:8251 68              	    43:   pla
00:8252 8503            	    44:   sta REG2
00:8254 60              	    45:   rts
                        	    46: 
00:8255 472D50617363616C	    47: introduction asc    "G-Pascal compiler, version 4.01.\n"
00:825D 20636F6D70696C65
00:8265 722C207665727369
00:826D 6F6E20342E30312E
00:8275 0A
00:8276 5772697474656E20	    48:              asciiz "Written by Nick Gammon.\nType H for help.\n"
00:827E 6279204E69636B20
00:8286 47616D6D6F6E2E0A
00:828E 5479706520482066
00:8296 6F722068656C702E
00:829E 0A
00:829F 00
00:82A0 3A20            	    49: prompt       asciiz ": "
00:82A2 00
00:82A3 556E6B6E6F776E20	    50: bad_command  asciiz "Unknown command, type H for help.\n"
00:82AB 636F6D6D616E642C
00:82B3 2074797065204820
00:82BB 666F722068656C70
00:82C3 2E0A
00:82C5 00
                        	    51: 
                        	    52: ;-------------------------------------------------
                        	    53: ; Start here after Reset or NMI - show introduction
                        	    54: ;-------------------------------------------------
                        	    55: 
                        	    56: main_start:
00:82C6 A955            	    57:   lda #<introduction
00:82C8 A282            	    58:   ldx #>introduction
00:82CA 202682          	    59:   jsr print
                        	    60: 
                        	    61: main_prompt:
00:82CD A2FF            	    62:   ldx  #NEW_STK
00:82CF 9A              	    63:   txs
00:82D0 D8              	    64:   cld
                        	    65: 
00:82D1 A9A0            	    66:   lda #<prompt
00:82D3 A282            	    67:   ldx #>prompt
00:82D5 202682          	    68:   jsr print
                        	    69: 
00:82D8 20F193          	    70:   jsr  GET_LINE
                        	    71: 
00:82DB A900            	    72:   lda #<INBUF
00:82DD 858E            	    73:   sta token_start
00:82DF A902            	    74:   lda #>INBUF
00:82E1 858F            	    75:   sta token_start+1
                        	    76: 
00:82E3 A901            	    77:   lda #1
00:82E5 853F            	    78:   sta RUNNING
                        	    79: 
                        	    80: ;-------------------------------------------------
                        	    81: ; EDITOR (SHELL) MAIN LOOP
                        	    82: ;-------------------------------------------------
                        	    83: 
                        	    84: main_loop:
00:82E7 64BC            	    85:   stz editor_flags  ; no flags yet
00:82E9 64BD            	    86:   stz find_flags    ;  ditto
00:82EB A901            	    87:   lda #FLAG_COMPILING
00:82ED 0902            	    88:   ora #FLAG_ASSEMBLING
00:82EF 14BE            	    89:   trb system_flags  ; not compiling or assembling now
                        	    90: 
00:82F1 A940            	    91:   lda #FLAG_ONLY_ALPHA
00:82F3 04BE            	    92:   tsb system_flags  ; we only want alpha commands, thus we can enter L1 and be the same as List 1
                        	    93: 
00:82F5 208DC9          	    94:   jsr get_token
00:82F8 F0D3            	    95:   beq main_prompt   ; no input
                        	    96: 
                        	    97: ;
                        	    98: ;  Shortcut: If the input is "R" or "r" followed directly by a newline, assume they want to Run
                        	    99: ;
00:82FA C949            	   100:   cmp #TOKEN_IDENTIFIER
00:82FC D015            	   101:   bne main_loop_not_run
                        	   102: 
00:82FE A000            	   103:   ldy #0
00:8300 B190            	   104:   lda (token_address),y
00:8302 202E90          	   105:   jsr MAKE_UPPER
00:8305 C952            	   106:   cmp #'R'
00:8307 D00A            	   107:   bne main_loop_not_run
00:8309 C8              	   108:   iny
00:830A B190            	   109:   lda (token_address),y
00:830C C90A            	   110:   cmp #NL
00:830E D003            	   111:   bne main_loop_not_run
00:8310 4C038F          	   112:   jmp editor_run
                        	   113: 
                        	   114: ;
                        	   115: ;  Not a RUN shortcut, look up the command in our table
                        	   116: ;
                        	   117: main_loop_not_run:
                        	   118: ;
                        	   119: ;  set up our input line as where to find tokens
                        	   120: ;
00:8313 A590            	   121:   lda token_address
00:8315 8500            	   122:   sta SRCE
00:8317 A591            	   123:   lda token_address+1
00:8319 8501            	   124:   sta SRCE+1
                        	   125: 
                        	   126: ;
                        	   127: ;  get editor handlers
                        	   128: ;
00:831B A931            	   129:   lda #<editor_handlers
00:831D 8503            	   130:   sta DEST
00:831F A983            	   131:   lda #>editor_handlers
00:8321 8504            	   132:   sta DEST+1
                        	   133: 
                        	   134: ;
                        	   135: ;  get the token length and look up the handler
                        	   136: ;
00:8323 A592            	   137:   lda token_length
00:8325 20B78F          	   138:   jsr partial_handler_Lookup
                        	   139: 
                        	   140: ;
                        	   141: ;  if we returned, unknown command
                        	   142: ;
00:8328 A9A3            	   143:   lda #<bad_command
00:832A A282            	   144:   ldx #>bad_command
00:832C 202682          	   145:   jsr print
00:832F 809C            	   146:   bra  main_prompt
                        	   147: 
                        	   148: 
                        	   149: editor_handlers:
                        	   150:   makeHandler "LIST",    editor_list
00:8331 4C495354        	     1M    asciiz   "LIST"
00:8335 00
00:8336 7C87            	     2M    word  editor_list
                        	   151:   makeHandler "INSERT",  editor_insert
00:8338 494E53455254    	     1M    asciiz   "INSERT"
00:833E 00
00:833F 2F8A            	     2M    word  editor_insert
                        	   152:   makeHandler "LOAD",    editor_load
00:8341 4C4F4144        	     1M    asciiz   "LOAD"
00:8345 00
00:8346 2B8A            	     2M    word  editor_load
                        	   153:   makeHandler "DELETE",  editor_delete
00:8348 44454C455445    	     1M    asciiz   "DELETE"
00:834E 00
00:834F BD8B            	     2M    word  editor_delete
                        	   154:   makeHandler "HELP",    editor_help
00:8351 48454C50        	     1M    asciiz   "HELP"
00:8355 00
00:8356 3485            	     2M    word  editor_help
                        	   155:   makeHandler "COMPILE" ,editor_compile
00:8358 434F4D50494C45  	     1M    asciiz   "COMPILE" 
00:835F 00
00:8360 EF8E            	     2M    word  editor_compile
                        	   156:   makeHandler "SYNTAX",  editor_syntax
00:8362 53594E544158    	     1M    asciiz   "SYNTAX"
00:8368 00
00:8369 F98E            	     2M    word  editor_syntax
                        	   157:   makeHandler "SAVE",    editor_save
00:836B 53415645        	     1M    asciiz   "SAVE"
00:836F 00
00:8370 7687            	     2M    word  editor_save
                        	   158: ;  makeHandler "TEST",    editor_test
                        	   159:   makeHandler "MEMORY",  editor_memory
00:8372 4D454D4F5259    	     1M    asciiz   "MEMORY"
00:8378 00
00:8379 158D            	     2M    word  editor_memory
                        	   160:  ; makeHandler "SYMTBL", editor_symbol_table_list
                        	   161:   makeHandler "INFO",    editor_info
00:837B 494E464F        	     1M    asciiz   "INFO"
00:837F 00
00:8380 E08E            	     2M    word  editor_info
                        	   162:   makeHandler "TRACE",   editor_trace
00:8382 5452414345      	     1M    asciiz   "TRACE"
00:8387 00
00:8388 D48E            	     2M    word  editor_trace
                        	   163:   makeHandler "DEBUG",   editor_debug
00:838A 4445425547      	     1M    asciiz   "DEBUG"
00:838F 00
00:8390 C88E            	     2M    word  editor_debug
                        	   164:   makeHandler "ASSEMBLE",editor_assemble
00:8392 415353454D424C45	     1M    asciiz   "ASSEMBLE"
00:839A 00
00:839B 6E8F            	     2M    word  editor_assemble
                        	   165:   makeHandler "FIND",    editor_find
00:839D 46494E44        	     1M    asciiz   "FIND"
00:83A1 00
00:83A2 7087            	     2M    word  editor_find
                        	   166:   makeHandler "REPLACE", editor_replace
00:83A4 5245504C414345  	     1M    asciiz   "REPLACE"
00:83AB 00
00:83AC 6887            	     2M    word  editor_replace
                        	   167:   makeHandler "RUN",     editor_run
00:83AE 52554E          	     1M    asciiz   "RUN"
00:83B1 00
00:83B2 038F            	     2M    word  editor_run
                        	   168:   makeHandler "RECOVER", editor_recover
00:83B4 5245434F564552  	     1M    asciiz   "RECOVER"
00:83BB 00
00:83BC 9F8E            	     2M    word  editor_recover
00:83BE 00              	   169:   dfb 0
                        	   170: 
                        	   171: editor_help_info:
00:83BF 417661696C61626C	   172:   asc "Available actions:\n\n"
00:83C7 6520616374696F6E
00:83CF 733A0A0A
00:83D3 4C6973742F534176	   173:   asc "List/SAve   line_number_range\n"
00:83DB 652020206C696E65
00:83E3 5F6E756D6265725F
00:83EB 72616E67650A
00:83F1 44656C6574652020	   174:   asc "Delete      line_number_range\n"
00:83F9 202020206C696E65
00:8401 5F6E756D6265725F
00:8409 72616E67650A
00:840F 496E736572742F4C	   175:   asc "Insert/LOad after_line\n"
00:8417 4F61642061667465
00:841F 725F6C696E650A
00:8426 46696E6420202020	   176:   asc "Find        line_number_range /target/flags\n"
00:842E 202020206C696E65
00:8436 5F6E756D6265725F
00:843E 72616E6765202F74
00:8446 61726765742F666C
00:844E 6167730A
00:8452 5265706C61636520	   177:   asc "Replace     line_number_range /target/replacement/flags\n"
00:845A 202020206C696E65
00:8462 5F6E756D6265725F
00:846A 72616E6765202F74
00:8472 61726765742F7265
00:847A 706C6163656D656E
00:8482 742F666C6167730A
00:848A 0A              	   178:   asc "\n"
00:848B 48656C700A      	   179:   asc "Help\n"
00:8490 494E666F0A      	   180:   asc "INfo\n"
00:8495 4D656D6F72792020	   181:   asc "Memory      first_address last_address\n"
00:849D 2020202066697273
00:84A5 745F616464726573
00:84AD 73206C6173745F61
00:84B5 6464726573730A
00:84BC 436F6D70696C652F	   182:   asc "Compile/Syntax/Assemble\n"
00:84C4 53796E7461782F41
00:84CC 7373656D626C650A
00:84D4 52556E2F44454275	   183:   asc "RUn/DEBug/Trace\n"
00:84DC 672F54726163650A
00:84E4 5245436F7665720A	   184:   asc "RECover\n"
00:84EC 28416374696F6E73	   185:   asc "(Actions may be abbreviated)\n"
00:84F4 206D617920626520
00:84FC 6162627265766961
00:8504 746564290A
00:8509 28466C6167733A20	   186:   asc "(Flags: 'I'gnore case, 'G'lobal, 'Q'uiet)\n"
00:8511 274927676E6F7265
00:8519 20636173652C2027
00:8521 47276C6F62616C2C
00:8529 2027512775696574
00:8531 290A
00:8533 00              	   187:   dfb 0
                        	   188: 
                        	   189: 
                        	   190: ;--------------------------------------------
                        	   191: ;  HELP
                        	   192: ;--------------------------------------------
                        	   193: editor_help:
00:8534 205986          	   194:   jsr editor_check_no_more
00:8537 A9BF            	   195:   lda #<editor_help_info
00:8539 8500            	   196:   sta REG
00:853B A983            	   197:   lda #>editor_help_info
00:853D 8501            	   198:   sta REG+1
                        	   199: editor_help_loop:
00:853F A000            	   200:   ldy #0
00:8541 B100            	   201:   lda (REG),Y
00:8543 F00B            	   202:   beq editor_help_done
00:8545 201994          	   203:   jsr COUT
00:8548 E600            	   204:   inc REG
00:854A D0F3            	   205:   bne editor_help_loop
00:854C E601            	   206:   inc REG+1
00:854E 80EF            	   207:   bra editor_help_loop
                        	   208: editor_help_done:
00:8550 4CCD82          	   209:   jmp main_prompt
                        	   210: 
                        	   211: ;
                        	   212: ;  Sets default range from 1 to 65535
                        	   213: ;
                        	   214: editor_default_range:
                        	   215: ;
                        	   216: ;  default to all lines
                        	   217: ;
00:8553 A901            	   218:   lda #1
00:8555 859E            	   219:   sta from_line
00:8557 649F            	   220:   stz from_line+1
00:8559 A9FF            	   221:   lda #$FF
00:855B 85A0            	   222:   sta to_line
00:855D 85A1            	   223:   sta to_line+1
00:855F 60              	   224:   rts
                        	   225: 
                        	   226: number_expected_message:
00:8560 4E756D6265722065	   227:   asciiz "Number expected\n"
00:8568 787065637465640A
00:8570 00
                        	   228: 
                        	   229: editor_bad_number:
00:8571 A960            	   230:   lda #<number_expected_message
00:8573 A285            	   231:   ldx #>number_expected_message
00:8575 202682          	   232:   jsr print
00:8578 4CCD82          	   233:   jmp main_prompt
                        	   234: 
                        	   235: ;
                        	   236: ;  get a number for the editor: accepts eof or newline as "no number"
                        	   237: ;  otherwise must be a number and in the range 0x0001 to 0xFFFF
                        	   238: ;  returns carry set if a number (in token_value) and carry clear if
                        	   239: ;  no number. Raises an error otherwise
                        	   240: ;
                        	   241: editor_get_number:
00:857B 203BCF          	   242:   jsr pas_get_token   ; use this to find END as a token
00:857E F065            	   243:   beq editor_get_number_none ; no token? return with carry set
00:8580 C90A            	   244:   cmp #NL
00:8582 F061            	   245:   beq editor_get_number_none ; newline counts as no token
00:8584 C94E            	   246:   cmp #TOKEN_NUMBER
00:8586 F04B            	   247:   beq editor_get_number_ok
00:8588 C989            	   248:   cmp #TOKEN_END
00:858A F05B            	   249:   beq editor_get_number_end
00:858C C949            	   250:   cmp #TOKEN_IDENTIFIER
00:858E D02D            	   251:   bne editor_get_number_not_identifier
00:8590 A592            	   252:   lda token_length
00:8592 C903            	   253:   cmp #3
00:8594 D0DB            	   254:   bne editor_bad_number
00:8596 A000            	   255:   ldy #0
00:8598 B190            	   256:   lda (token_address),y
00:859A 202E90          	   257:   jsr MAKE_UPPER
00:859D C941            	   258:   cmp #'A'
00:859F D0D0            	   259:   bne editor_bad_number
00:85A1 C8              	   260:   iny
00:85A2 B190            	   261:   lda (token_address),y
00:85A4 202E90          	   262:   jsr MAKE_UPPER
00:85A7 C94C            	   263:   cmp #'L'
00:85A9 D0C6            	   264:   bne editor_bad_number
00:85AB C8              	   265:   iny
00:85AC B190            	   266:   lda (token_address),y
00:85AE 202E90          	   267:   jsr MAKE_UPPER
00:85B1 C94C            	   268:   cmp #'L'
00:85B3 D0BC            	   269:   bne editor_bad_number
00:85B5 205385          	   270:   jsr editor_default_range
00:85B8 205986          	   271:   jsr editor_check_no_more ; can't have ALL - something
00:85BB 8028            	   272:   bra editor_get_number_none
                        	   273: ;
                        	   274: ;  find / replace can go straight to the delimiter
                        	   275: ;
                        	   276: editor_get_number_not_identifier:
00:85BD A910            	   277:   lda #EFLAG_FIND
00:85BF 0920            	   278:   ora #EFLAG_REPLACE
00:85C1 25BC            	   279:   and editor_flags
00:85C3 F0AC            	   280:   beq editor_bad_number
00:85C5 A592            	   281:   lda token_length
00:85C7 C901            	   282:   cmp #1
00:85C9 D0A6            	   283:   bne editor_bad_number
                        	   284: ;
                        	   285: ;  go back one character, we need get_token to find this again later
                        	   286: ;
00:85CB C68E            	   287:   dec token_start
00:85CD D016            	   288:   bne editor_get_number_none
00:85CF C68F            	   289:   dec token_start+1
00:85D1 8012            	   290:   bra editor_get_number_none
                        	   291: 
                        	   292: editor_get_number_ok:
00:85D3 A596            	   293:   lda token_value+2         ; must be a number
00:85D5 D03C            	   294:   bne editor_line_number_too_big
00:85D7 A5BC            	   295:   lda editor_flags
00:85D9 2902            	   296:   and #EFLAG_ALLOW_ZERO_FROM
00:85DB D006            	   297:   bne editor_get_number_done
00:85DD A594            	   298:   lda token_value
00:85DF 0595            	   299:   ora token_value+1
00:85E1 F030            	   300:   beq editor_line_number_too_big  ; too small actually
                        	   301: editor_get_number_done:
00:85E3 38              	   302:   sec
00:85E4 60              	   303:   rts
                        	   304: 
                        	   305: editor_get_number_none:
00:85E5 18              	   306:   clc
00:85E6 60              	   307:   rts
                        	   308: 
                        	   309: ;
                        	   310: ;  the word "END" will count as the highest possible line number
                        	   311: ;
                        	   312: editor_get_number_end:
00:85E7 A9FF            	   313:   lda #$FF
00:85E9 8594            	   314:   sta token_value
00:85EB 8595            	   315:   sta token_value+1
00:85ED 6496            	   316:   stz token_value+2
00:85EF 205986          	   317:   jsr editor_check_no_more ; can't have END - something
00:85F2 38              	   318:   sec
00:85F3 60              	   319:   rts
                        	   320: 
                        	   321: number_too_large_message:
00:85F4 4E756D6265722074	   322:   asciiz "Number too large or too small\n"
00:85FC 6F6F206C61726765
00:8604 206F7220746F6F20
00:860C 736D616C6C0A
00:8612 00
                        	   323: 
                        	   324: editor_line_number_too_big:
00:8613 A9F4            	   325:   lda #<number_too_large_message
00:8615 A285            	   326:   ldx #>number_too_large_message
00:8617 202682          	   327:   jsr print
00:861A 4CCD82          	   328:   jmp main_prompt
                        	   329: 
                        	   330: number_bad_range_message:
00:861D 52616E676520696E	   331:   asciiz "Range invalid\n"
00:8625 76616C69640A
00:862B 00
                        	   332: 
                        	   333: editor_bad_range:
00:862C A91D            	   334:   lda #<number_bad_range_message
00:862E A286            	   335:   ldx #>number_bad_range_message
00:8630 202682          	   336:   jsr print
00:8633 4CCD82          	   337:   jmp main_prompt
                        	   338: 
                        	   339: too_much_on_line:
00:8636 556E657870656374	   340:   asciiz "Unexpected trailing input on line\n"
00:863E 656420747261696C
00:8646 696E6720696E7075
00:864E 74206F6E206C696E
00:8656 650A
00:8658 00
                        	   341: 
                        	   342: ;
                        	   343: ;  check that all is left on the line is spaces
                        	   344: ;
                        	   345: editor_check_no_more:
00:8659 A000            	   346:   ldy #0
                        	   347: editor_check_no_more_loop:
00:865B B18E            	   348:   lda (token_start),y
00:865D F016            	   349:   beq editor_check_no_more_ok   ; end of file
00:865F C90A            	   350:   cmp #NL
00:8661 F012            	   351:   beq editor_check_no_more_ok   ; newline is OK
00:8663 204A81          	   352:   jsr isspace
00:8666 9003            	   353:   bcc editor_check_no_more_failed ; not spaces is bad
00:8668 C8              	   354:   iny
00:8669 D0F0            	   355:   bne editor_check_no_more_loop   ; skip spaces
                        	   356: 
                        	   357: editor_check_no_more_failed:
00:866B A936            	   358:   lda #<too_much_on_line
00:866D A286            	   359:   ldx #>too_much_on_line
00:866F 202682          	   360:   jsr print
00:8672 4CCD82          	   361:   jmp main_prompt
                        	   362: editor_check_no_more_ok:
00:8675 60              	   363:   rts
                        	   364: 
                        	   365: 
                        	   366: 
                        	   367: ;--------------------------------------------
                        	   368: ;  get a range of line numbers (eg. L 1,10; D 4; M 6,10 )
                        	   369: ;--------------------------------------------
                        	   370: 
                        	   371: editor_get_range:
                        	   372: 
                        	   373: 
                        	   374: ;
                        	   375: ;  get the first line number (if any)
                        	   376: ;
00:8676 207B85          	   377:   jsr editor_get_number
00:8679 9049            	   378:   bcc editor_get_range_done ; no token? take defaults
                        	   379: ;
                        	   380: ;  store the from line
                        	   381: ;
00:867B A594            	   382:   lda token_value
00:867D 859E            	   383:   sta from_line
00:867F 85A0            	   384:   sta to_line
00:8681 A595            	   385:   lda token_value+1
00:8683 859F            	   386:   sta from_line+1
00:8685 85A1            	   387:   sta to_line+1
                        	   388: 
                        	   389: ;
                        	   390: ;  comma or hyphen?
                        	   391: ;
00:8687 208DC9          	   392:   jsr get_token
00:868A F038            	   393:   beq editor_get_range_done   ; line done, just the single line wanted
                        	   394: 
00:868C C92D            	   395:   cmp #'-'
00:868E F01C            	   396:   beq editor_get_range_hyphen
00:8690 C94E            	   397:   cmp #TOKEN_NUMBER
00:8692 F01D            	   398:   beq editor_get_range_number
00:8694 C989            	   399:   cmp #TOKEN_END
00:8696 F019            	   400:   beq editor_get_range_number
00:8698 C92C            	   401:   cmp #','
00:869A F010            	   402:   beq editor_get_range_hyphen
                        	   403: ;
                        	   404: ;  find and replace may have another character after the first line number
                        	   405: ;  which isn't a second line number or a hyphen/comma
                        	   406: ;
00:869C A910            	   407:   lda #EFLAG_FIND
00:869E 0920            	   408:   ora #EFLAG_REPLACE
00:86A0 25BC            	   409:   and editor_flags
00:86A2 F088            	   410:   beq editor_bad_range
                        	   411: 
                        	   412: ;
                        	   413: ;  go back one character, we need get_token to find this again later
                        	   414: ;
00:86A4 C68E            	   415:   dec token_start
00:86A6 D01C            	   416:   bne editor_get_range_done
00:86A8 C68F            	   417:   dec token_start+1
00:86AA 8018            	   418:   bra editor_get_range_done
                        	   419: 
                        	   420: editor_get_range_hyphen:
                        	   421: ;
                        	   422: ;  get the second line number
                        	   423: ;
00:86AC 207B85          	   424:   jsr editor_get_number
00:86AF 9014            	   425:   bcc editor_bad_rangeJ
                        	   426: 
                        	   427: editor_get_range_number:
00:86B1 A594            	   428:   lda token_value
00:86B3 85A0            	   429:   sta to_line
00:86B5 A595            	   430:   lda token_value+1
00:86B7 85A1            	   431:   sta to_line+1
                        	   432: 
                        	   433: ;
                        	   434: ;  make sure range ascends
                        	   435: ;
00:86B9 38              	   436:   sec
00:86BA A5A0            	   437:   lda to_line
00:86BC E59E            	   438:   sbc from_line
00:86BE A5A1            	   439:   lda to_line+1
00:86C0 E59F            	   440:   sbc from_line+1
00:86C2 9001            	   441:   bcc editor_bad_rangeJ    ; <sigh> because of the way SBC works
                        	   442: 
                        	   443: editor_get_range_done:
00:86C4 60              	   444:   rts
                        	   445: 
00:86C5 4C2C86          	   446: editor_bad_rangeJ jmp editor_bad_range
                        	   447: 
                        	   448: ;
                        	   449: 
00:86C8 20666F756E640A  	   450: found_message asciiz  ' found\n'
00:86CF 00
                        	   451: 
                        	   452: 
                        	   453: 
00:86D0 46726F6D3A20    	   454: from_msg: asciiz "From: "
00:86D6 00
00:86D7 20746F20        	   455: to_msg:   asciiz " to "
00:86DB 00
                        	   456: 
00:86DC 4261642064656C69	   457: bad_delimiter_message asciiz "Bad delimiter\n"
00:86E4 6D697465720A
00:86EA 00
                        	   458: 
                        	   459: editor_bad_delimiter:
00:86EB A9DC            	   460:   lda #<bad_delimiter_message
00:86ED A286            	   461:   ldx #>bad_delimiter_message
                        	   462: editor_find_problem:
00:86EF 202682          	   463:   jsr print
00:86F2 4CCD82          	   464:   jmp main_prompt
                        	   465: 
00:86F5 46696E642F726570	   466: find_string_too_long_message asciiz "Find/replace string too long\n"
00:86FD 6C61636520737472
00:8705 696E6720746F6F20
00:870D 6C6F6E670A
00:8712 00
                        	   467: 
                        	   468: find_string_too_long:
00:8713 A9F5            	   469:   lda #<find_string_too_long_message
00:8715 A286            	   470:   ldx #>find_string_too_long_message
00:8717 80D6            	   471:   bra editor_find_problem
                        	   472: 
                        	   473: editor_get_delimiter:
00:8719 208DC9          	   474:   jsr get_token
00:871C C949            	   475:   cmp #TOKEN_IDENTIFIER
00:871E F0CB            	   476:   beq editor_bad_delimiter
00:8720 C94E            	   477:   cmp #TOKEN_NUMBER
00:8722 F0C7            	   478:   beq editor_bad_delimiter
00:8724 C922            	   479:   cmp #TOKEN_STRING
00:8726 F0C3            	   480:   beq editor_bad_delimiter
00:8728 A692            	   481:   ldx token_length
00:872A E001            	   482:   cpx #1
00:872C D0BD            	   483:   bne editor_bad_delimiter
00:872E 85B4            	   484:   sta find_delimiter
00:8730 60              	   485:   rts
                        	   486: 
00:8731 4E6F20636C6F7369	   487: editor_no_closing_delimiter_message asciiz "No closing delimiter\n"
00:8739 6E672064656C696D
00:8741 697465720A
00:8746 00
                        	   488: 
                        	   489: editor_no_closing_delimiter:
00:8747 A931            	   490:   lda #<editor_no_closing_delimiter_message
00:8749 A287            	   491:   ldx #>editor_no_closing_delimiter_message
00:874B 80A2            	   492:   bra editor_find_problem
                        	   493: 
00:874D 5461726765742073	   494: no_find_message asciiz "Target string empty\n"
00:8755 7472696E6720656D
00:875D 7074790A
00:8761 00
                        	   495: 
                        	   496: editor_no_find_string:
00:8762 A94D            	   497:   lda #<no_find_message
00:8764 A287            	   498:   ldx #>no_find_message
00:8766 8087            	   499:   bra editor_find_problem
                        	   500: 
                        	   501: ;--------------------------------------------
                        	   502: ;  LIST / SAVE / FIND / REPLACE / MODIFY
                        	   503: ;
                        	   504: ;  This rather complex routine lists the source between from_line and to_line
                        	   505: ;   In the process it can show or omit line numbers  (omit for SAVE)
                        	   506: ;  Also, it can find the target text, and optionally replace it with the replacement text
                        	   507: ;  In find/replace mode the lines are not shown unless they had something found (unless
                        	   508: ;   the Quiet flag is set)
                        	   509: ;
                        	   510: ;--------------------------------------------
                        	   511: 
                        	   512: editor_replace:
00:8768 A920            	   513:   lda #EFLAG_REPLACE
00:876A 0910            	   514:   ora #EFLAG_FIND   ; makes things simpler later on
00:876C 85BC            	   515:   sta editor_flags
00:876E 800C            	   516:   bra editor_list
                        	   517: 
                        	   518: editor_find:
                        	   519: 
00:8770 A910            	   520:   lda #EFLAG_FIND
00:8772 85BC            	   521:   sta editor_flags
00:8774 8006            	   522:   bra editor_list
                        	   523: 
                        	   524: editor_save
                        	   525: 
00:8776 A980            	   526:   lda #EFLAG_NO_LINE_NUMBERS
00:8778 0908            	   527:   ora #EFLAG_SAVE
00:877A 85BC            	   528:   sta editor_flags
                        	   529: 
                        	   530: ;
                        	   531: ;  main entry point - get the from and to lines
                        	   532: ;
                        	   533: editor_list:
00:877C 205385          	   534:   jsr editor_default_range
00:877F 207686          	   535:   jsr editor_get_range
                        	   536: 
                        	   537: ;
                        	   538: ;  turn the from_line into an address and put it into PCODE
                        	   539: ;
00:8782 A59E            	   540:   lda from_line
00:8784 85AC            	   541:   sta this_line
00:8786 A59F            	   542:   lda from_line+1
00:8788 85AD            	   543:   sta this_line+1
00:878A 209E8C          	   544:   jsr find_line    ; find the "from" line address (this_line in fact)
00:878D A5AE            	   545:   lda this_line_addr
00:878F 8523            	   546:   sta PCODE
00:8791 A5AF            	   547:   lda this_line_addr+1
00:8793 8524            	   548:   sta PCODE+1
00:8795 64B9            	   549:   stz find_count
00:8797 64BA            	   550:   stz find_count+1
                        	   551: 
                        	   552: ;
                        	   553: ;  for FIND and REPLACE, get the first delimiter
                        	   554: ;
00:8799 A5BC            	   555:   lda editor_flags
00:879B 2910            	   556:   and #EFLAG_FIND
00:879D D003            	   557:   bne editor_list_doing_find
00:879F 4C6C88          	   558:   jmp editor_list_not_find
                        	   559: 
                        	   560: editor_list_doing_find:
00:87A2 201987          	   561:   jsr editor_get_delimiter
                        	   562: ;
                        	   563: ;  token_next should now be the start of what we are searching for
                        	   564: ;
00:87A5 38              	   565:   sec
00:87A6 A58E            	   566:   lda token_start
00:87A8 E900            	   567:   sbc #<INBUF
00:87AA 85B0            	   568:   sta find_from
00:87AC B00B            	   569:   bcs editor_list_got_from_point ; delimiter should be a single byte
                        	   570: 
                        	   571: editor_find_bug:
00:87AE A214            	   572:   ldx #20  ; ERROR: bug
00:87B0 4CCE97          	   573:   jmp ERROR
                        	   574: 
00:87B3 4C1387          	   575: find_string_too_longJ         jmp find_string_too_long
00:87B6 4C4787          	   576: editor_no_closing_delimiterJ  jmp editor_no_closing_delimiter
                        	   577: 
                        	   578: editor_list_got_from_point:
                        	   579: 
                        	   580: ;
                        	   581: ;  Now find closing delimiter by a simple scan as we will pass who-knows-what on the way
                        	   582: ;
00:87B9 A6B0            	   583:   ldx find_from
                        	   584: editor_find_second_delimiter_loop:
00:87BB E8              	   585:   inx
00:87BC BD0002          	   586:   lda INBUF,x
00:87BF F0F5            	   587:   beq editor_no_closing_delimiterJ
00:87C1 C90A            	   588:   cmp #NL
00:87C3 F0F1            	   589:   beq editor_no_closing_delimiterJ
00:87C5 C5B4            	   590:   cmp find_delimiter
00:87C7 D0F2            	   591:   bne editor_find_second_delimiter_loop
                        	   592: 
                        	   593: ;
                        	   594: ;  found the closing delimiter
                        	   595: ;
00:87C9 86B1            	   596:   stx find_to
00:87CB E4B0            	   597:   cpx find_from
00:87CD F093            	   598:   beq editor_no_find_string
                        	   599: ;
                        	   600: ;  maximum 127 byte find string
                        	   601: ;
00:87CF 38              	   602:   sec
00:87D0 A5B1            	   603:   lda find_to
00:87D2 E5B0            	   604:   sbc find_from
00:87D4 30DD            	   605:   bmi find_string_too_longJ
00:87D6 85B3            	   606:   sta find_len    ; save for later memory move calculations
                        	   607: 
00:87D8 A920            	   608:   lda #EFLAG_REPLACE
00:87DA 25BC            	   609:   and editor_flags
00:87DC F02A            	   610:   beq editor_find_get_flags
                        	   611: 
                        	   612: ;
                        	   613: ;  doing a replace - find second delimiter
                        	   614: ;
                        	   615: 
00:87DE 86B5            	   616:   stx rep_from
00:87E0 E6B5            	   617:   inc rep_from    ; get past the delimiter
                        	   618: 
                        	   619: editor_find_third_delimiter_loop:
00:87E2 E8              	   620:   inx
00:87E3 BD0002          	   621:   lda INBUF,x
00:87E6 F0CE            	   622:   beq editor_no_closing_delimiterJ
00:87E8 C90A            	   623:   cmp #NL
00:87EA F0CA            	   624:   beq editor_no_closing_delimiterJ
00:87EC C5B4            	   625:   cmp find_delimiter
00:87EE D0F2            	   626:   bne editor_find_third_delimiter_loop
                        	   627: 
                        	   628: ;
                        	   629: ;  found the replacement closing delimiter
00:87F0 86B6            	   630:   stx rep_to
                        	   631: 
                        	   632: ;
                        	   633: ;  maximum 127 byte replacement string
                        	   634: ;
00:87F2 38              	   635:   sec
00:87F3 A5B6            	   636:   lda rep_to
00:87F5 E5B5            	   637:   sbc rep_from
00:87F7 30BA            	   638:   bmi find_string_too_longJ
                        	   639: 
                        	   640: ;
                        	   641: ;  now find the signed difference between the find and replace strings
                        	   642: ;  namely: (rep_to - rep_from) - find_len
                        	   643: ;
00:87F9 64B8            	   644:   stz rep_diff+1
00:87FB 38              	   645:   sec
00:87FC A5B6            	   646:   lda rep_to
00:87FE E5B5            	   647:   sbc rep_from
00:8800 E5B3            	   648:   sbc find_len
00:8802 85B7            	   649:   sta rep_diff
00:8804 1002            	   650:   bpl editor_find_get_flags
00:8806 C6B8            	   651:   dec rep_diff+1   ; make that $ff
                        	   652: 
                        	   653: ;
                        	   654: ; get any find/replace flags
                        	   655: ;
                        	   656: editor_find_get_flags:
00:8808 64BD            	   657:   stz find_flags
                        	   658: 
                        	   659: editor_flags_loop:
00:880A E8              	   660:   inx
00:880B BD0002          	   661:   lda INBUF,X
00:880E C90A            	   662:   cmp #NL
00:8810 F042            	   663:   beq editor_list_fix_target_string
00:8812 204A81          	   664:   jsr isspace
00:8815 B0F3            	   665:   bcs editor_flags_loop
00:8817 202E90          	   666:   jsr MAKE_UPPER
00:881A C951            	   667:   cmp #'Q'
00:881C D00A            	   668:   bne editor_flags1
00:881E A904            	   669:   lda #FFLAG_QUIET
00:8820 04BD            	   670:   tsb find_flags
00:8822 A980            	   671:   lda #EFLAG_NO_LINE_NUMBERS
00:8824 04BC            	   672:   tsb editor_flags
00:8826 80E2            	   673:   bra editor_flags_loop
                        	   674: editor_flags1:
00:8828 C947            	   675:   cmp #'G'
00:882A D006            	   676:   bne editor_flags2
00:882C A902            	   677:   lda #FFLAG_GLOBAL
00:882E 04BD            	   678:   tsb find_flags
00:8830 80D8            	   679:   bra editor_flags_loop
                        	   680: editor_flags2:
00:8832 C949            	   681:   cmp #'I'
00:8834 D006            	   682:   bne editor_flags3
00:8836 A901            	   683:   lda #FFLAG_IGNORE_CASE
00:8838 04BD            	   684:   tsb find_flags
00:883A 80CE            	   685:   bra editor_flags_loop
                        	   686: editor_flags3:
00:883C A946            	   687:   lda #<bad_flag_message
00:883E A288            	   688:   ldx #>bad_flag_message
00:8840 202682          	   689:   jsr print
00:8843 4CCD82          	   690:   jmp main_prompt
                        	   691: 
00:8846 556E6B6E6F776E20	   692: bad_flag_message: asciiz "Unknown flag\n"
00:884E 666C61670A
00:8853 00
                        	   693: 
                        	   694: editor_list_fix_target_string:
                        	   695: 
00:8854 A901            	   696:   lda #FFLAG_IGNORE_CASE
00:8856 25BD            	   697:   and find_flags
00:8858 F015            	   698:   beq editor_list_get_on_with_it
                        	   699: 
                        	   700: ;
                        	   701: ;  for case insensitive compare force target to be upper case
                        	   702: ;
00:885A A6B0            	   703:   ldx find_from
                        	   704: editor_list_fixup_loop:
00:885C E4B1            	   705:   cpx find_to
00:885E F00F            	   706:   beq editor_list_get_on_with_it
00:8860 BD0002          	   707:   lda INBUF,X
00:8863 202E90          	   708:   jsr MAKE_UPPER
00:8866 9D0002          	   709:   sta INBUF,X
00:8869 E8              	   710:   inx
00:886A 80F0            	   711:   bra editor_list_fixup_loop
                        	   712: 
                        	   713: 
                        	   714: editor_list_not_find:
                        	   715: ;
                        	   716: ;  we should have no more tokens now
                        	   717: ;
00:886C 205986          	   718:   jsr editor_check_no_more
                        	   719: 
                        	   720: editor_list_get_on_with_it:
                        	   721: ;
                        	   722: ;  make sure current_line is correct
                        	   723: ;
00:886F A59E            	   724:   lda from_line
00:8871 85A2            	   725:   sta current_line
00:8873 A59F            	   726:   lda from_line+1
00:8875 85A3            	   727:   sta current_line+1
                        	   728: 
                        	   729: ;
                        	   730: ;  exit immediately if no source from here on
                        	   731: ;
00:8877 A000            	   732:   ldy #0
00:8879 B123            	   733:   lda (PCODE),Y
00:887B D003            	   734:   bne editor_list_have_source
00:887D 4C9B89          	   735:   jmp editor_list_done
                        	   736: 
                        	   737: editor_list_have_source:
00:8880 A901            	   738:   lda #EFLAG_SHOW_LINE
00:8882 04BC            	   739:   tsb editor_flags
00:8884 8006            	   740:   bra editor_list_loop
                        	   741: 
00:8886 4C9B89          	   742: editor_list_doneJ jmp editor_list_done
00:8889 4C5D89          	   743: editor_list_no_line_numberJ jmp editor_list_no_line_number
                        	   744: 
                        	   745: editor_list_loop:
00:888C A58B            	   746:   lda serial_in_byte_received
00:888E C903            	   747:   cmp  #KEY_ABORT
00:8890 F021            	   748:   beq  editor_list_aborted
00:8892 64BB            	   749:   stz  found_this_line
00:8894 A000            	   750:   ldy #0
00:8896 B123            	   751:   lda (PCODE),Y
00:8898 F0EC            	   752:   beq editor_list_doneJ
00:889A A5BC            	   753:   lda editor_flags
00:889C 2901            	   754:   and #EFLAG_SHOW_LINE
00:889E F0E9            	   755:   beq  editor_list_no_line_numberJ
00:88A0 A5BC            	   756:   lda editor_flags
00:88A2 2908            	   757:   and #EFLAG_SAVE
00:88A4 D0E3            	   758:   bne editor_list_no_line_numberJ
                        	   759: ;
                        	   760: ;  At this exact point we know we are at the start of a line
                        	   761: ;  and we aren't doing a Save. Now, if we are doing a Find then
                        	   762: ;  we need to know if this line (from here to the next newline)
                        	   763: ;  matches our find string, and if not, to skip it
                        	   764: 
00:88A6 A940            	   765:   lda #EFLAG_SUPPRESS_NEWLINE
00:88A8 14BC            	   766:   trb editor_flags              ; we can show newlines now
                        	   767: 
00:88AA A5BC            	   768:   lda editor_flags
00:88AC 2910            	   769:   and #EFLAG_FIND
00:88AE D010            	   770:   bne editor_find_or_replacing
                        	   771: 
00:88B0 4C5089          	   772:   jmp  editor_list_not_finding
                        	   773: 
                        	   774: ;
                        	   775: ;  Here when Ctrl+C pressed
                        	   776: ;
                        	   777: editor_list_aborted:
00:88B3 A232            	   778:   ldx #50
00:88B5 A000            	   779:   ldy #0
00:88B7 203F91          	   780:   jsr delay   ; 50 ms delay to allow serial to settle
00:88BA 209292          	   781:   jsr CROUT
00:88BD 4C9B89          	   782:   jmp editor_list_done
                        	   783: 
                        	   784: editor_find_or_replacing:
                        	   785: 
                        	   786: ;
                        	   787: ;  here if finding or replacing
                        	   788: ;
                        	   789: 
00:88C0 A900            	   790:   lda #0
                        	   791: 
                        	   792: ;
                        	   793: ;  we come back here for multiple replacements with a new starting pos
                        	   794: ;
                        	   795: editor_replacement_loop:
00:88C2 85B2            	   796:   sta find_pos    ; searching line from beginning (or not, if doing a multiple replace)
                        	   797: 
                        	   798: editor_find_loop:
00:88C4 A6B0            	   799:   ldx find_from   ; out target string position in INBUF
00:88C6 A4B2            	   800:   ldy find_pos    ; where we are on the line
                        	   801: editor_find_inner_loop:
00:88C8 E4B1            	   802:   cpx find_to     ; reached end of target, found the string!
00:88CA F037            	   803:   beq editor_find_found_it
00:88CC B123            	   804:   lda (PCODE),Y
00:88CE C90A            	   805:   cmp #NL
00:88D0 F01B            	   806:   beq editor_find_no_match ; hit end of line without matching
                        	   807: 
                        	   808: ;
                        	   809: ;  force to upper-case if required
                        	   810: ;
00:88D2 48              	   811:   pha
00:88D3 A901            	   812:   lda #FFLAG_IGNORE_CASE
00:88D5 25BD            	   813:   and find_flags
00:88D7 F006            	   814:   beq editor_find_case_sensitive
00:88D9 68              	   815:   pla
00:88DA 202E90          	   816:   jsr MAKE_UPPER
00:88DD 8001            	   817:   bra editor_find_test_character
                        	   818: editor_find_case_sensitive:
00:88DF 68              	   819:   pla
                        	   820: editor_find_test_character:
00:88E0 DD0002          	   821:   cmp INBUF,X     ; does source byte match target byte?
00:88E3 D004            	   822:   bne editor_find_skip_this
00:88E5 C8              	   823:   iny
00:88E6 E8              	   824:   inx
00:88E7 80DF            	   825:   bra editor_find_inner_loop
                        	   826: 
                        	   827: editor_find_skip_this:
00:88E9 E6B2            	   828:   inc find_pos
00:88EB D0D7            	   829:   bne editor_find_loop  ; if it wraps, give up
                        	   830: 
                        	   831: ;
                        	   832: ;  we are at the newline without a match, increment PCODE to match
                        	   833: ;  where we are and go onto newline processing
                        	   834: ;
                        	   835: editor_find_no_match:
00:88ED A5BB            	   836:    lda found_this_line
00:88EF D05F            	   837:    bne editor_list_not_finding
00:88F1 18              	   838:    clc
00:88F2 98              	   839:    tya
00:88F3 6523            	   840:    adc PCODE
00:88F5 8523            	   841:    sta PCODE
00:88F7 A900            	   842:    lda #0
00:88F9 6524            	   843:    adc PCODE+1
00:88FB 8524            	   844:    sta PCODE+1
00:88FD A940            	   845:    lda #EFLAG_SUPPRESS_NEWLINE
00:88FF 04BC            	   846:    tsb editor_flags
00:8901 8062            	   847:    bra editor_newline_processing
                        	   848: 
                        	   849: ;
                        	   850: ;  here when find succeeded
                        	   851: ;
                        	   852: editor_find_found_it:
00:8903 E6B9            	   853:   inc find_count
00:8905 D002            	   854:   bne editor_find_found_it1
00:8907 E6BA            	   855:   inc find_count+1
                        	   856: editor_find_found_it1:
00:8909 A901            	   857:   lda #1
00:890B 85BB            	   858:   sta found_this_line
00:890D A920            	   859:   lda #EFLAG_REPLACE
00:890F 25BC            	   860:   and editor_flags
00:8911 D00E            	   861:   bne editor_do_the_replace
                        	   862: 
00:8913 A902            	   863:   lda #FFLAG_GLOBAL
00:8915 25BD            	   864:   and find_flags
00:8917 F037            	   865:   beq editor_list_not_finding   ; one replace is enough
                        	   866: 
                        	   867: ;
                        	   868: ;  add the find length to Y (moving past what we just found)
                        	   869: ;
                        	   870: ;
00:8919 18              	   871:   clc
00:891A A5B2            	   872:   lda find_pos
00:891C 65B3            	   873:   adc find_len
00:891E 4CC288          	   874:   jmp editor_replacement_loop
                        	   875: 
                        	   876: ;
                        	   877: ;  here when replacing
                        	   878: ;
                        	   879: editor_do_the_replace:
00:8921 A908            	   880:   lda #FLAG_VALID_COMPILE   ; compile or assemble no longer valid
00:8923 0910            	   881:   ora #FLAG_VALID_ASSEMBLE
00:8925 14BE            	   882:   trb system_flags
                        	   883: 
00:8927 A5B7            	   884:   lda rep_diff ; same length?
00:8929 F003            	   885:   beq editor_easy_replace
00:892B 4CBB89          	   886:   jmp editor_do_replace
                        	   887: 
                        	   888: editor_easy_replace:
00:892E A4B2            	   889:   ldy find_pos
00:8930 A6B5            	   890:   ldx rep_from
                        	   891: editor_easy_replace_loop:
00:8932 E4B6            	   892:   cpx rep_to
00:8934 F009            	   893:   beq editor_easy_replace_done
00:8936 BD0002          	   894:   lda INBUF,x
00:8939 9123            	   895:   sta (PCODE),y
00:893B C8              	   896:   iny
00:893C E8              	   897:   inx
00:893D D0F3            	   898:   bne editor_easy_replace_loop  ; keep replacing
                        	   899: 
                        	   900: editor_easy_replace_done:
00:893F A902            	   901:   lda #FFLAG_GLOBAL
00:8941 25BD            	   902:   and find_flags
00:8943 F00B            	   903:   beq editor_list_not_finding   ; one replace is enough
                        	   904: 
                        	   905: ;
                        	   906: ;  add the replacement length to Y (moving past what we just replaced)
                        	   907: ;   the replacement length is rep_to - rep_from
                        	   908: ;
00:8945 18              	   909:   clc
00:8946 A5B2            	   910:   lda find_pos
00:8948 65B6            	   911:   adc rep_to
00:894A 38              	   912:   sec
00:894B E5B5            	   913:   sbc rep_from
00:894D 4CC288          	   914:   jmp editor_replacement_loop
                        	   915: 
                        	   916: ;
                        	   917: ;
                        	   918: ;  display the line number
                        	   919: ;
                        	   920: editor_list_not_finding:
00:8950 A901            	   921:   lda #EFLAG_SHOW_LINE
00:8952 14BC            	   922:   trb editor_flags      ; cancel flag until next newline
00:8954 A980            	   923:   lda #EFLAG_NO_LINE_NUMBERS
00:8956 25BC            	   924:   and editor_flags
00:8958 D003            	   925:   bne editor_list_no_line_number
00:895A 20608C          	   926:   jsr show_current_line_number
                        	   927: 
                        	   928: editor_list_no_line_number:
00:895D A000            	   929:   ldy  #0
00:895F B123            	   930:   lda  (PCODE),Y
00:8961 C90A            	   931:   cmp  #NL
00:8963 D022            	   932:   bne  editor_list_not_newline
                        	   933: 
                        	   934: editor_newline_processing:
00:8965 A901            	   935:   lda  #EFLAG_SHOW_LINE
00:8967 04BC            	   936:   tsb  editor_flags
00:8969 E6A2            	   937:   inc  current_line
00:896B D002            	   938:   bne  editor_list_check_to_line
00:896D E6A3            	   939:   inc  current_line+1
                        	   940: 
                        	   941: ;
                        	   942: ;  see if we hit the wanted "to" line
                        	   943: ;
                        	   944: editor_list_check_to_line:
00:896F A5A3            	   945:   lda  current_line+1
00:8971 C5A1            	   946:   cmp  to_line+1
00:8973 900A            	   947:   bcc  editor_list_check_to_line_ok
00:8975 D024            	   948:   bne  editor_list_done
00:8977 A5A2            	   949:   lda  current_line
00:8979 C5A0            	   950:   cmp  to_line
00:897B 9002            	   951:   bcc  editor_list_check_to_line_ok
00:897D D01C            	   952:   bne  editor_list_done
                        	   953: 
                        	   954: editor_list_check_to_line_ok:
                        	   955: 
00:897F A940            	   956:   lda #EFLAG_SUPPRESS_NEWLINE
00:8981 25BC            	   957:   and editor_flags
00:8983 D00D            	   958:   bne editor_list_skip_newline
00:8985 A90A            	   959:   lda #NL   ; put the newline back
                        	   960: 
                        	   961: ;
                        	   962: ;  just echo the character, and increment the memory address
                        	   963: ;
                        	   964: editor_list_not_newline:
00:8987 AA              	   965:   tax
00:8988 A904            	   966:   lda #FFLAG_QUIET
00:898A 25BD            	   967:   and find_flags
00:898C D004            	   968:   bne editor_list_skip_newline
00:898E 8A              	   969:   txa
00:898F 20EF92          	   970:   jsr PRCHAR
                        	   971: 
                        	   972: editor_list_skip_newline:
00:8992 E623            	   973:   inc PCODE
00:8994 D002            	   974:   bne editor_list_loopJ
00:8996 E624            	   975:   inc PCODE+1
                        	   976: 
                        	   977: editor_list_loopJ:
00:8998 4C8C88          	   978:   jmp editor_list_loop
                        	   979: 
                        	   980: editor_list_done:
00:899B 209292          	   981:   jsr CROUT
                        	   982: 
00:899E A5B9            	   983:   lda find_count
00:89A0 05BA            	   984:   ora find_count+1
00:89A2 F014            	   985:   beq  editor_list_completely_done
00:89A4 A5B9            	   986:   lda find_count
00:89A6 8500            	   987:   sta REG
00:89A8 A5BA            	   988:   lda find_count+1
00:89AA 8501            	   989:   sta REG+1
00:89AC 6402            	   990:   stz REGB
00:89AE 20BC91          	   991:   jsr display_in_decimal
00:89B1 A9C8            	   992:   lda #<found_message
00:89B3 A286            	   993:   ldx #>found_message
00:89B5 202682          	   994:   jsr print
                        	   995: 
                        	   996: editor_list_completely_done:
00:89B8 4CCD82          	   997:   jmp main_prompt
                        	   998: 
                        	   999: ;
                        	  1000: ;  This if for replacing when the lengths differ
                        	  1001: ;
                        	  1002: editor_do_replace:
                        	  1003: ;
                        	  1004: ; add our current find_pos to PCODE to get where we are in memory
                        	  1005: ;
00:89BB 18              	  1006:   clc
00:89BC A523            	  1007:   lda  PCODE
00:89BE 48              	  1008:   pha   ; save where we currently are
00:89BF 65B2            	  1009:   adc  find_pos
00:89C1 85A6            	  1010:   sta  mem_move_src
00:89C3 A524            	  1011:   lda  PCODE+1
00:89C5 48              	  1012:   pha
00:89C6 6900            	  1013:   adc  #0
00:89C8 85A7            	  1014:   sta  mem_move_src+1
                        	  1015: 
                        	  1016: ;
                        	  1017: ;  add the source string length as we don't need to copy that
                        	  1018: ;
00:89CA 18              	  1019:   clc
00:89CB A5A6            	  1020:   lda mem_move_src
00:89CD 65B3            	  1021:   adc find_len
00:89CF 85A6            	  1022:   sta mem_move_src
00:89D1 A5A7            	  1023:   lda mem_move_src+1
00:89D3 6900            	  1024:   adc #0
00:89D5 85A7            	  1025:   sta mem_move_src+1
                        	  1026: 
                        	  1027: ;
                        	  1028: ;  the move destination is the source plus the replacement length
                        	  1029: ;   (ie. a gap of the difference in bytes)
                        	  1030: 
00:89D7 18              	  1031:   clc
00:89D8 A5A6            	  1032:   lda mem_move_src
00:89DA 65B7            	  1033:   adc rep_diff
00:89DC 85A8            	  1034:   sta mem_move_dest
00:89DE A5A7            	  1035:   lda mem_move_src+1
00:89E0 65B8            	  1036:   adc rep_diff+1
00:89E2 85A9            	  1037:   sta mem_move_dest+1
                        	  1038: 
                        	  1039: 
00:89E4 20D28C          	  1040:   jsr find_source_end   ; goes into PCODE
                        	  1041: ;
                        	  1042: ;  the length to move will be (the end of the source) - (the start of the move)
                        	  1043: ;
00:89E7 38              	  1044:   sec
00:89E8 A523            	  1045:   lda PCODE
00:89EA E5A6            	  1046:   sbc mem_move_src
00:89EC 85AA            	  1047:   sta mem_move_len
00:89EE A524            	  1048:   lda PCODE+1
00:89F0 E5A7            	  1049:   sbc mem_move_src+1
00:89F2 85AB            	  1050:   sta mem_move_len+1
                        	  1051: 
00:89F4 A5B8            	  1052:   lda rep_diff+1
00:89F6 3005            	  1053:   bmi editor_do_replace_smaller
00:89F8 20A681          	  1054:   jsr moveup      ; replacing with larger string
00:89FB 8003            	  1055:   bra editor_do_replace_copy_done
                        	  1056: 
                        	  1057: editor_do_replace_smaller:
00:89FD 207A81          	  1058:   jsr movedown    ; replacing with smaller string
                        	  1059: 
                        	  1060: editor_do_replace_copy_done:
                        	  1061: ;
                        	  1062: ;  get the current source address back
                        	  1063: ;
00:8A00 68              	  1064:   pla
00:8A01 8524            	  1065:   sta  PCODE+1
00:8A03 68              	  1066:   pla
00:8A04 8523            	  1067:   sta  PCODE
00:8A06 4C2E89          	  1068:   jmp  editor_easy_replace    ; now move in new string
                        	  1069: 
                        	  1070: 
00:8A09 456E74657220736F	  1071: load_message asciiz "Enter source, terminate with Esc\n"
00:8A11 757263652C207465
00:8A19 726D696E61746520
00:8A21 7769746820457363
00:8A29 0A
00:8A2A 00
                        	  1072: 
                        	  1073: ;--------------------------------------------
                        	  1074: ;  INSERT / LOAD
                        	  1075: ;--------------------------------------------
                        	  1076: editor_load:
                        	  1077: 
00:8A2B A904            	  1078:   lda #EFLAG_LOAD
00:8A2D 85BC            	  1079:   sta editor_flags
                        	  1080: 
                        	  1081: editor_insert:
00:8A2F 207B85          	  1082:   jsr editor_get_number
00:8A32 9015            	  1083:   bcc editor_insert_at_start
                        	  1084: 
                        	  1085:   ;
                        	  1086:   ; I really want to insert AFTER this line so I'll add 1 to whatever line number they gave
                        	  1087:   ; To insert at the start use Insert without a line number
                        	  1088:   ;
00:8A34 18              	  1089:   clc
00:8A35 A594            	  1090:   lda token_value
00:8A37 6901            	  1091:   adc #1
00:8A39 85AC            	  1092:   sta this_line
00:8A3B A595            	  1093:   lda token_value+1
00:8A3D 6900            	  1094:   adc #0
00:8A3F 85AD            	  1095:   sta this_line+1
                        	  1096: 
00:8A41 205986          	  1097:   jsr editor_check_no_more
00:8A44 209E8C          	  1098:   jsr find_line    ; find the "from" line address
00:8A47 800E            	  1099:   bra editor_insert_common
                        	  1100: 
                        	  1101: editor_insert_at_start:
00:8A49 A900            	  1102:   lda #<TEXT_START
00:8A4B 85AE            	  1103:   sta this_line_addr
00:8A4D A903            	  1104:   lda #>TEXT_START
00:8A4F 85AF            	  1105:   sta this_line_addr+1
00:8A51 A901            	  1106:   lda #1
00:8A53 85A2            	  1107:   sta current_line    ; current line number (1)
00:8A55 64A3            	  1108:   stz current_line+1
                        	  1109: 
                        	  1110: editor_insert_common:
00:8A57 20D28C          	  1111:   jsr find_source_end
                        	  1112: 
                        	  1113: ;
                        	  1114: ;  move existing source to end of RAM
                        	  1115: ;
00:8A5A 38              	  1116:   sec
00:8A5B A523            	  1117:   lda PCODE
00:8A5D E5AE            	  1118:   sbc this_line_addr
00:8A5F 85AA            	  1119:   sta mem_move_len
00:8A61 A524            	  1120:   lda PCODE+1
00:8A63 E5AF            	  1121:   sbc this_line_addr+1
00:8A65 85AB            	  1122:   sta mem_move_len+1
                        	  1123: 
                        	  1124: ;
                        	  1125: ;  find where to move to
                        	  1126: ;
00:8A67 38              	  1127:   sec
00:8A68 A9FF            	  1128:   lda #<HIGHEST_RAM
00:8A6A E5AA            	  1129:   sbc mem_move_len
00:8A6C 85A8            	  1130:   sta mem_move_dest
00:8A6E 85A4            	  1131:   sta insert_limit
00:8A70 A93F            	  1132:   lda #>HIGHEST_RAM
00:8A72 E5AB            	  1133:   sbc mem_move_len+1
00:8A74 85A9            	  1134:   sta mem_move_dest+1
00:8A76 85A5            	  1135:   sta insert_limit+1
                        	  1136: 
                        	  1137: ;
                        	  1138: ;  the source of the move
                        	  1139: ;
00:8A78 A5AE            	  1140:   lda this_line_addr
00:8A7A 85A6            	  1141:   sta mem_move_src
00:8A7C A5AF            	  1142:   lda this_line_addr+1
00:8A7E 85A7            	  1143:   sta mem_move_src+1
                        	  1144: 
00:8A80 20A681          	  1145:   jsr moveup
                        	  1146: 
                        	  1147: ;
                        	  1148: ;  put input at from_line_addr
                        	  1149: ;
                        	  1150: 
00:8A83 A5AE            	  1151:   lda this_line_addr
00:8A85 8523            	  1152:   sta PCODE
00:8A87 A5AF            	  1153:   lda this_line_addr+1
00:8A89 8524            	  1154:   sta PCODE+1
                        	  1155: 
00:8A8B A909            	  1156:   lda  #<load_message
00:8A8D A28A            	  1157:   ldx  #>load_message
00:8A8F 202682          	  1158:   jsr  print
                        	  1159: 
                        	  1160: ;
                        	  1161: ;  show the first line number
                        	  1162: ;
                        	  1163: 
00:8A92 A901            	  1164:   lda #EFLAG_SHOW_LINE
00:8A94 04BC            	  1165:   tsb editor_flags
00:8A96 A000            	  1166:   ldy #0    ; offset from PCODE for inserting (should always be zero)
00:8A98 A200            	  1167:   ldx #0    ; last character we inserted
                        	  1168: 
                        	  1169: editor_insert_loop:
00:8A9A A904            	  1170:   lda #EFLAG_LOAD         ; no line numbers on load
00:8A9C 25BC            	  1171:   and editor_flags
00:8A9E D00B            	  1172:   bne editor_insert_no_line_number
                        	  1173: 
00:8AA0 A5BC            	  1174:   lda editor_flags
00:8AA2 2901            	  1175:   and #EFLAG_SHOW_LINE
00:8AA4 F005            	  1176:   beq  editor_insert_no_line_number
                        	  1177: ;
                        	  1178: ;  display the line number
                        	  1179: ;
                        	  1180: 
00:8AA6 64BC            	  1181:   stz editor_flags      ; cancel flag until next newline
00:8AA8 20608C          	  1182:   jsr show_current_line_number
                        	  1183: 
                        	  1184: editor_insert_no_line_number:
00:8AAB 200FC9          	  1185:   jsr  CHRIN
00:8AAE C90D            	  1186:   cmp  #CR                          ; carriage-return?
00:8AB0 F0F9            	  1187:   beq  editor_insert_no_line_number ; yes, ignore
00:8AB2 C91B            	  1188:   cmp  #END_EDITOR_INPUT            ; Esc?
00:8AB4 F04F            	  1189:   beq  editor_insert_done
00:8AB6 C908            	  1190:   cmp  #BACKSPACE
00:8AB8 F029            	  1191:   beq  editor_insert_backspace
00:8ABA C90A            	  1192:   cmp  #NL
00:8ABC D00C            	  1193:   bne  editor_insert_not_newline
00:8ABE A901            	  1194:   lda  #EFLAG_SHOW_LINE
00:8AC0 04BC            	  1195:   tsb  editor_flags
00:8AC2 A90A            	  1196:   lda  #NL            ; get the newline back
00:8AC4 E6A2            	  1197:   inc  current_line
00:8AC6 D002            	  1198:   bne  editor_insert_not_newline
00:8AC8 E6A3            	  1199:   inc  current_line+1
                        	  1200: editor_insert_not_newline:
00:8ACA 9123            	  1201:   sta  (PCODE),y
00:8ACC AA              	  1202:   tax                ; for detecting final newline
00:8ACD E623            	  1203:   inc  PCODE
00:8ACF D002            	  1204:   bne  editor_insert_loop1
00:8AD1 E624            	  1205:   inc  PCODE+1
                        	  1206: 
                        	  1207: editor_insert_loop1:
00:8AD3 A5A5            	  1208:   lda  insert_limit+1
00:8AD5 C524            	  1209:   cmp  PCODE+1
00:8AD7 B0C1            	  1210:   bcs  editor_insert_loop   ; carry is SET if we didn't borrow
00:8AD9 D056            	  1211:   bne  editor_too_full
00:8ADB A5A4            	  1212:   lda  insert_limit
00:8ADD C523            	  1213:   cmp  PCODE
00:8ADF F050            	  1214:   beq  editor_too_full
00:8AE1 80B7            	  1215:   bra  editor_insert_loop
                        	  1216: 
                        	  1217: ;
                        	  1218: ;  backspace reduces our pointer by one, unless we are at the start
                        	  1219: ;
                        	  1220: editor_insert_backspace:
00:8AE3 A523            	  1221:   lda PCODE
00:8AE5 C5AE            	  1222:   cmp this_line_addr
00:8AE7 D006            	  1223:   bne editor_insert_backspace_not_at_start
00:8AE9 A524            	  1224:   lda PCODE+1
00:8AEB C5AF            	  1225:   cmp this_line_addr+1
00:8AED F0AB            	  1226:   beq editor_insert_loop    ; at start, ignore backspace
                        	  1227: 
                        	  1228: editor_insert_backspace_not_at_start:
00:8AEF 38              	  1229:   sec                       ; move source pointer back one
00:8AF0 A523            	  1230:   lda PCODE
00:8AF2 E901            	  1231:   sbc #1
00:8AF4 8523            	  1232:   sta PCODE
00:8AF6 A524            	  1233:   lda PCODE+1
00:8AF8 E900            	  1234:   sbc #0
00:8AFA 8524            	  1235:   sta PCODE+1
00:8AFC B123            	  1236:   lda (PCODE),y
00:8AFE AA              	  1237:   tax                      ; this is now the last character we inserted
                        	  1238: ;
                        	  1239: ;  however we don't want them backspacing over a previous line, so if we detect a newline
                        	  1240: ;  just go back up and put it back (and increment PCODE back to where it was)
                        	  1241: ;
00:8AFF C90A            	  1242:   cmp #NL
00:8B01 F0C7            	  1243:   beq editor_insert_not_newline
00:8B03 8095            	  1244:   bra editor_insert_loop
                        	  1245: 
                        	  1246: editor_insert_done:
00:8B05 8A              	  1247:   txa
00:8B06 F00E            	  1248:   beq editor_insert_done_with_newline   ; nothing got inserted at all
00:8B08 C90A            	  1249:   cmp #NL
00:8B0A F00A            	  1250:   beq editor_insert_done_with_newline  ; skip inserting a newline if we just got a newline
                        	  1251: ;
                        	  1252: ;  They finished inserting, but without a newline ... add one
                        	  1253: ;
00:8B0C A90A            	  1254:   lda #NL
00:8B0E 9123            	  1255:   sta (PCODE),y
00:8B10 E623            	  1256:   inc PCODE
00:8B12 D002            	  1257:   bne editor_insert_done_with_newline
00:8B14 E624            	  1258:   inc PCODE+1
                        	  1259: 
                        	  1260: ;
                        	  1261: ;  they are done - copy the rest back to the end of where they just inserted
                        	  1262: ;
                        	  1263: editor_insert_done_with_newline:
                        	  1264: 
00:8B16 64BE            	  1265:   stz system_flags     ; compile is not valid any more
                        	  1266: 
00:8B18 A523            	  1267:   lda PCODE
00:8B1A 85A8            	  1268:   sta mem_move_dest
00:8B1C A524            	  1269:   lda PCODE+1
00:8B1E 85A9            	  1270:   sta mem_move_dest+1
                        	  1271: 
00:8B20 A5A4            	  1272:   lda insert_limit
00:8B22 85A6            	  1273:   sta mem_move_src
00:8B24 A5A5            	  1274:   lda insert_limit+1
00:8B26 85A7            	  1275:   sta mem_move_src+1
                        	  1276: 
00:8B28 207A81          	  1277:   jsr movedown
                        	  1278: 
00:8B2B 209292          	  1279:   jsr CROUT   ; put a newline after the ESC character
00:8B2E 4CCD82          	  1280:   jmp main_prompt
                        	  1281: 
                        	  1282: editor_too_full:
00:8B31 A95C            	  1283:   lda #<memory_full
00:8B33 A28B            	  1284:   ldx #>memory_full
00:8B35 202682          	  1285:   jsr print
                        	  1286: ;
                        	  1287: ;  consume input so it isn't mistaken for a command
                        	  1288: ;
                        	  1289: editor_too_full_loop:
00:8B38 200FC9          	  1290:   jsr CHRIN
00:8B3B C91B            	  1291:   cmp #END_EDITOR_INPUT
00:8B3D D0F9            	  1292:   bne editor_too_full_loop
                        	  1293: ;
                        	  1294: ;  another message, they may miss the first one during a bulk load
                        	  1295: ;
00:8B3F A977            	  1296:   lda #<memory_filled_up
00:8B41 A28B            	  1297:   ldx #>memory_filled_up
00:8B43 202682          	  1298:   jsr print
00:8B46 4C058B          	  1299:   jmp editor_insert_done
                        	  1300: 
00:8B49 4E6F2072616E6765	  1301: editor_no_lines  asciiz "No range supplied\n"
00:8B51 20737570706C6965
00:8B59 640A
00:8B5B 00
00:8B5C 0A0A4D656D6F7279	  1302: memory_full      asciiz "\n\nMemory full - press Esc\n"
00:8B64 2066756C6C202D20
00:8B6C 7072657373204573
00:8B74 630A
00:8B76 00
00:8B77 0A0A4E6F20726F6F	  1303: memory_filled_up asciiz "\n\nNo room for source during load/input\n\n"
00:8B7F 6D20666F7220736F
00:8B87 7572636520647572
00:8B8F 696E67206C6F6164
00:8B97 2F696E7075740A0A
00:8B9F 00
                        	  1304: 
                        	  1305: ;
                        	  1306: ;  subroutine to check we got a range for certain actions
                        	  1307: ;
                        	  1308: editor_argument_check:
00:8BA0 A000            	  1309:   ldy #0
                        	  1310: ;
                        	  1311: ;  skip spaces to make sure we got a range
                        	  1312: ;
                        	  1313: editor_argument_check_loop:
00:8BA2 B18E            	  1314:   lda (token_start),y
00:8BA4 F00C            	  1315:   beq editor_argument_check_failed
00:8BA6 C90A            	  1316:   cmp #NL
00:8BA8 F008            	  1317:   beq editor_argument_check_failed
00:8BAA 204A81          	  1318:   jsr isspace
00:8BAD 900D            	  1319:   bcc editor_argument_check_got_argument
00:8BAF C8              	  1320:   iny
00:8BB0 D0F0            	  1321:   bne editor_argument_check_loop
                        	  1322: 
                        	  1323: ;
                        	  1324: ;  only found spaces, not good enough
                        	  1325: ;
                        	  1326: editor_argument_check_failed:
00:8BB2 A949            	  1327:   lda #<editor_no_lines
00:8BB4 A28B            	  1328:   ldx #>editor_no_lines
00:8BB6 202682          	  1329:   jsr print
00:8BB9 4CCD82          	  1330:   jmp  main_prompt
                        	  1331: 
                        	  1332: editor_argument_check_got_argument:
00:8BBC 60              	  1333:   rts
                        	  1334: 
                        	  1335: 
                        	  1336: ;--------------------------------------------
                        	  1337: ;  DELETE
                        	  1338: ;--------------------------------------------
                        	  1339: editor_delete:
                        	  1340: ;
                        	  1341: ;  default to no lines
                        	  1342: ;
00:8BBD 649E            	  1343:   stz from_line
00:8BBF 649F            	  1344:   stz from_line+1
00:8BC1 64A0            	  1345:   stz to_line
00:8BC3 64A1            	  1346:   stz to_line+1
                        	  1347: 
00:8BC5 64B9            	  1348:   stz find_count      ; delete count in this case
00:8BC7 64BA            	  1349:   stz find_count+1
00:8BC9 20A08B          	  1350:   jsr editor_argument_check ; cannot get away with no arguments
                        	  1351: 
00:8BCC 207686          	  1352:   jsr editor_get_range
00:8BCF 205986          	  1353:   jsr editor_check_no_more
                        	  1354: 
00:8BD2 A59E            	  1355:   lda from_line
00:8BD4 85AC            	  1356:   sta this_line
00:8BD6 A59F            	  1357:   lda from_line+1
00:8BD8 85AD            	  1358:   sta this_line+1
00:8BDA 209E8C          	  1359:   jsr find_line       ; find the "from" line address
00:8BDD A5AE            	  1360:   lda this_line_addr  ; that becomes the destination of the move
00:8BDF 85A8            	  1361:   sta mem_move_dest
00:8BE1 A5AF            	  1362:   lda this_line_addr+1
00:8BE3 85A9            	  1363:   sta mem_move_dest+1
00:8BE5 64AA            	  1364:   stz mem_move_len
00:8BE7 64AB            	  1365:   stz mem_move_len+1
                        	  1366: ;
                        	  1367: ;  now we'll work our way up until we get to the to_line, however we'll
                        	  1368: ;  add one because we want the final address to actually be the start of
                        	  1369: ;  the NEXT line
                        	  1370: ;
00:8BE9 18              	  1371:   clc
00:8BEA A5A0            	  1372:   lda to_line
00:8BEC 6901            	  1373:   adc #1
00:8BEE 85AC            	  1374:   sta this_line
00:8BF0 A5A1            	  1375:   lda to_line+1
00:8BF2 6900            	  1376:   adc #0
00:8BF4 85AD            	  1377:   sta this_line+1
00:8BF6 20AC8C          	  1378:   jsr find_line_loop    ; find the "to" line address
00:8BF9 A5AE            	  1379:   lda this_line_addr  ; that becomes the destination of the move
00:8BFB 85A6            	  1380:   sta mem_move_src
00:8BFD A5AF            	  1381:   lda this_line_addr+1
00:8BFF 85A7            	  1382:   sta mem_move_src+1
                        	  1383: 
                        	  1384: ;
                        	  1385: ;  count how many lines we delete by counting newlines from
                        	  1386: ;   mem_move_dest to mem_move_src
                        	  1387: ;
                        	  1388: 
00:8C01 A5A8            	  1389:   lda mem_move_dest
00:8C03 8523            	  1390:   sta PCODE
00:8C05 A5A9            	  1391:   lda mem_move_dest+1
00:8C07 8524            	  1392:   sta PCODE+1
00:8C09 A000            	  1393:   ldy #0
                        	  1394: 
                        	  1395: editor_delete_line_count_loop:
00:8C0B A523            	  1396:   lda PCODE
00:8C0D C5A6            	  1397:   cmp mem_move_src
00:8C0F D006            	  1398:   bne editor_delete_line_count_not_done
00:8C11 A524            	  1399:   lda PCODE+1
00:8C13 C5A7            	  1400:   cmp mem_move_src+1
00:8C15 F014            	  1401:   beq editor_delete_line_count_done
                        	  1402: 
                        	  1403: editor_delete_line_count_not_done:
00:8C17 B123            	  1404:   lda (PCODE),y
00:8C19 C90A            	  1405:   cmp #NL
00:8C1B D006            	  1406:   bne editor_delete_line_count_not_newline
00:8C1D E6B9            	  1407:   inc find_count
00:8C1F D002            	  1408:   bne editor_delete_line_count_not_newline
00:8C21 E6BA            	  1409:   inc find_count+1
                        	  1410: editor_delete_line_count_not_newline:
00:8C23 E623            	  1411:   inc PCODE
00:8C25 D0E4            	  1412:   bne editor_delete_line_count_loop
00:8C27 E624            	  1413:   inc PCODE+1
00:8C29 80E0            	  1414:   bra editor_delete_line_count_loop
                        	  1415: 
                        	  1416: ;
                        	  1417: ;  now find where the source ends
                        	  1418: ;  PCODE will now be at the first line to not be deleted
                        	  1419: ;
                        	  1420: editor_delete_line_count_done:
                        	  1421: 
00:8C2B 20DA8C          	  1422:   jsr find_source_end_loop
00:8C2E 38              	  1423:   sec
00:8C2F A523            	  1424:   lda PCODE
00:8C31 E5AE            	  1425:   sbc this_line_addr
00:8C33 85AA            	  1426:   sta mem_move_len
00:8C35 A524            	  1427:   lda PCODE+1
00:8C37 E5AF            	  1428:   sbc this_line_addr+1
00:8C39 85AB            	  1429:   sta mem_move_len+1
00:8C3B 207A81          	  1430:   jsr movedown  ; that should do it
                        	  1431: 
00:8C3E A5B9            	  1432:   lda find_count
00:8C40 8500            	  1433:   sta REG
00:8C42 A5BA            	  1434:   lda find_count+1
00:8C44 8501            	  1435:   sta REG+1
00:8C46 6402            	  1436:   stz REGB
00:8C48 20BC91          	  1437:   jsr display_in_decimal
00:8C4B A955            	  1438:   lda #<lines_deleted_message
00:8C4D A28C            	  1439:   ldx #>lines_deleted_message
00:8C4F 202682          	  1440:   jsr print
00:8C52 4CCD82          	  1441:   jmp main_prompt
                        	  1442: 
00:8C55 2064656C65746564	  1443: lines_deleted_message asciiz " deleted.\n"
00:8C5D 2E0A
00:8C5F 00
                        	  1444: 
                        	  1445: ;--------------------------------------------
                        	  1446: ;  show current line number with leading spaces
                        	  1447: ;--------------------------------------------
                        	  1448: show_current_line_number:
00:8C60 48              	  1449:   pha
00:8C61 DA              	  1450:   phx
00:8C62 5A              	  1451:   phy
                        	  1452: ;
                        	  1453: ;  get the line number into REG ready for printing
                        	  1454: ;
00:8C63 A5A2            	  1455:   lda current_line
00:8C65 8500            	  1456:   sta REG
00:8C67 A6A3            	  1457:   ldx current_line+1
00:8C69 8601            	  1458:   stx REG+1
00:8C6B A000            	  1459:   ldy #0        ; count of leading spaces
00:8C6D 8402            	  1460:   sty REGB
00:8C6F E003            	  1461:   cpx #>1000    ; if the number is >= 1000 don't print any spaces
00:8C71 9006            	  1462:   bcc line_number_lt_1000
00:8C73 D013            	  1463:   bne line_number_output_spaces
00:8C75 C9E8            	  1464:   cmp #<1000
00:8C77 B00F            	  1465:   bcs line_number_output_spaces
                        	  1466: line_number_lt_1000:
00:8C79 C8              	  1467:   iny           ; output one space
00:8C7A E000            	  1468:   cpx  #0       ; if line number > 255 then one space is all we need
00:8C7C D00A            	  1469:   bne  line_number_output_spaces
00:8C7E C964            	  1470:   cmp  #100     ; if line number >= 100 then one space is all we need
00:8C80 B006            	  1471:   bcs  line_number_output_spaces
00:8C82 C8              	  1472:   iny           ; output two spaces
00:8C83 C90A            	  1473:   cmp  #10      ; if line number >= 10 then two spaces are all we need
00:8C85 B001            	  1474:   bcs  line_number_output_spaces
00:8C87 C8              	  1475:   iny           ; output three spaces
                        	  1476: line_number_output_spaces:
00:8C88 C000            	  1477:   cpy #0            ; leading spaces in front of line number
00:8C8A F008            	  1478:   beq  show_current_line_number_done
00:8C8C 5A              	  1479:   phy
00:8C8D 201D93          	  1480:   jsr  PUTSP      ; output the space
00:8C90 7A              	  1481:   ply
00:8C91 88              	  1482:   dey             ; count them
00:8C92 D0F4            	  1483:   bne  line_number_output_spaces  ; more spaces to go
                        	  1484: show_current_line_number_done:
00:8C94 20BC91          	  1485:   jsr  display_in_decimal    ; now the actual number
00:8C97 201D93          	  1486:   jsr  PUTSP      ; and a space after it
00:8C9A 7A              	  1487:   ply
00:8C9B FA              	  1488:   plx
00:8C9C 68              	  1489:   pla
00:8C9D 60              	  1490:   rts
                        	  1491: 
                        	  1492: ;--------------------------------------------
                        	  1493: ;  find_line
                        	  1494: ;
                        	  1495: ;  finds address of this_line in memory - returns in this_line_addr
                        	  1496: ;--------------------------------------------
                        	  1497: find_line:
00:8C9E A901            	  1498:   lda #1
00:8CA0 85A2            	  1499:   sta current_line    ; current line number (1)
00:8CA2 64A3            	  1500:   stz current_line+1
00:8CA4 A900            	  1501:   lda #<TEXT_START   ; start at start of source
00:8CA6 85AE            	  1502:   sta this_line_addr
00:8CA8 A903            	  1503:   lda #>TEXT_START
00:8CAA 85AF            	  1504:   sta this_line_addr+1
                        	  1505: find_line_loop:
00:8CAC A000            	  1506:   ldy #0
00:8CAE A5A2            	  1507:   lda current_line
00:8CB0 C5AC            	  1508:   cmp this_line
00:8CB2 D007            	  1509:   bne find_line_next
00:8CB4 A5A3            	  1510:   lda current_line+1
00:8CB6 C5AD            	  1511:   cmp this_line+1
00:8CB8 D001            	  1512:   bne find_line_next
00:8CBA 60              	  1513:   rts
                        	  1514: find_line_next:
00:8CBB B1AE            	  1515:   lda (this_line_addr),Y
00:8CBD F012            	  1516:   beq find_line_eof
00:8CBF C90A            	  1517:   cmp #NL
00:8CC1 D006            	  1518:   bne find_line_same_line
00:8CC3 E6A2            	  1519:   inc current_line       ; add 1 to our line number counter
00:8CC5 D002            	  1520:   bne find_line_same_line
00:8CC7 E6A3            	  1521:   inc current_line+1
                        	  1522: find_line_same_line:
00:8CC9 E6AE            	  1523:   inc this_line_addr     ; onto next address - which means that a newline
00:8CCB D0DF            	  1524:   bne find_line_loop     ; will actually end up being the start of the new
00:8CCD E6AF            	  1525:   inc this_line_addr+1   ; line, which is what we want
00:8CCF 80DB            	  1526:   bra find_line_loop
                        	  1527: find_line_eof:           ; we are pointing to 0x00 - make that the address
00:8CD1 60              	  1528:   rts
                        	  1529: 
                        	  1530: 
                        	  1531: 
                        	  1532: ;***********************************************
                        	  1533: ; Find text end
                        	  1534: ;***********************************************
                        	  1535: find_source_end:
00:8CD2 A900            	  1536:   lda  #<TEXT_START        ; start at start of source
00:8CD4 8523            	  1537:   sta  PCODE
00:8CD6 A903            	  1538:   lda  #>TEXT_START
00:8CD8 8524            	  1539:   sta  PCODE+1
                        	  1540: find_source_end_loop =  *
00:8CDA A000            	  1541:   ldy  #0
00:8CDC B123            	  1542:   lda  (PCODE),Y             ; keep going until 0x00 indicates end of source
00:8CDE F008            	  1543:   beq  find_source_end_wrap
00:8CE0 E623            	  1544:   inc  PCODE
00:8CE2 D0F6            	  1545:   bne  find_source_end_loop
00:8CE4 E624            	  1546:   inc  PCODE+1
00:8CE6 80F2            	  1547:   bra  find_source_end_loop
                        	  1548: ;
                        	  1549: ;  include final 0x00
                        	  1550: ;
                        	  1551: find_source_end_wrap =  *
00:8CE8 E623            	  1552:   inc  PCODE
00:8CEA D002            	  1553:   bne  find_source_end_done
00:8CEC E624            	  1554:   inc  PCODE+1
                        	  1555: find_source_end_done =  *
00:8CEE 60              	  1556:   rts
                        	  1557: 
                        	  1558: ;
                        	  1559: ;  testing BRK handling
                        	  1560: ;
00:8CEF 0A526573756D6564	  1561: brk_resumed asciiz "\nResumed after BRK\n"
00:8CF7 2061667465722042
00:8CFF 524B0A
00:8D02 00
                        	  1562: 
                        	  1563: editor_test:
00:8D03 A912            	  1564:   lda #$12
00:8D05 A223            	  1565:   ldx #$23
00:8D07 A042            	  1566:   ldy #$42
00:8D09 C912            	  1567:   cmp #$12
00:8D0B 00              	  1568:   brk
00:8D0C 99              	  1569:   dfb $99   ; break number
00:8D0D A9EF            	  1570:   lda #<brk_resumed
00:8D0F A28C            	  1571:   ldx #>brk_resumed
00:8D11 202682          	  1572:   jsr print
00:8D14 60              	  1573:   rts
                        	  1574: 
                        	  1575: ;
                        	  1576: ;  memory dump
                        	  1577: ;
                        	  1578: editor_memory:
00:8D15 20A08B          	  1579:   jsr editor_argument_check  ; check they supplied some sort of range
00:8D18 205385          	  1580:   jsr editor_default_range
00:8D1B A902            	  1581:   lda #EFLAG_ALLOW_ZERO_FROM
00:8D1D 85BC            	  1582:   sta editor_flags
00:8D1F 207686          	  1583:   jsr editor_get_range
00:8D22 205986          	  1584:   jsr editor_check_no_more
00:8D25 64A2            	  1585:   stz current_line      ; count of bytes shown
00:8D27 A59E            	  1586:   lda from_line
00:8D29 85AE            	  1587:   sta this_line_addr
00:8D2B A59F            	  1588:   lda from_line+1
00:8D2D 85AF            	  1589:   sta this_line_addr+1
                        	  1590: 
                        	  1591: editor_memory_loop:
00:8D2F A58B            	  1592:   lda serial_in_byte_received
00:8D31 C903            	  1593:   cmp  #KEY_ABORT
00:8D33 F056            	  1594:   beq  editor_memory_aborted
                        	  1595: 
00:8D35 A5A2            	  1596:   lda current_line
00:8D37 D017            	  1597:   bne editor_memory_loop1
                        	  1598: ;
                        	  1599: ;  show address
                        	  1600: ;
00:8D39 A924            	  1601:   lda #'$'
00:8D3B 201994          	  1602:   jsr COUT
00:8D3E A59F            	  1603:   lda from_line+1
00:8D40 200793          	  1604:   jsr PRBYTE
00:8D43 A59E            	  1605:   lda from_line
00:8D45 200793          	  1606:   jsr PRBYTE
00:8D48 A93A            	  1607:   lda #':'
00:8D4A 201994          	  1608:   jsr COUT
00:8D4D 201D93          	  1609:   jsr PUTSP
                        	  1610: editor_memory_loop1:
00:8D50 A000            	  1611:   ldy #0
00:8D52 B19E            	  1612:   lda (from_line),Y
00:8D54 200793          	  1613:   jsr PRBYTE
00:8D57 201D93          	  1614:   jsr PUTSP
00:8D5A E6A2            	  1615:   inc current_line
00:8D5C E69E            	  1616:   inc from_line
00:8D5E D002            	  1617:   bne editor_memory_loop2
00:8D60 E69F            	  1618:   inc from_line+1
                        	  1619: editor_memory_loop2:
                        	  1620: ;
                        	  1621: ;  if we wrap around back to zero, stop
                        	  1622: ;
00:8D62 A59E            	  1623:   lda from_line
00:8D64 059F            	  1624:   ora from_line+1
00:8D66 F020            	  1625:   beq editor_memory_done
00:8D68 A59F            	  1626:   lda from_line+1
00:8D6A C5A1            	  1627:   cmp to_line+1
00:8D6C 900A            	  1628:   bcc editor_memory_loop3   ; less than
00:8D6E D018            	  1629:   bne editor_memory_done    ; greater than
00:8D70 A59E            	  1630:   lda from_line             ; equal, so try low-order byte
00:8D72 C5A0            	  1631:   cmp to_line
00:8D74 9002            	  1632:   bcc editor_memory_loop3   ; less than
00:8D76 D010            	  1633:   bne editor_memory_done    ; greater than
                        	  1634: editor_memory_loop3:
00:8D78 A5A2            	  1635:   lda current_line
00:8D7A C910            	  1636:   cmp #16
00:8D7C 90B1            	  1637:   bcc editor_memory_loop
00:8D7E 201D93          	  1638:   jsr PUTSP
00:8D81 20918D          	  1639:   jsr editor_memory_show_ascii
00:8D84 64A2            	  1640:   stz current_line      ; count of bytes shown
00:8D86 80A7            	  1641:   bra editor_memory_loop
                        	  1642: 
                        	  1643: editor_memory_done:
00:8D88 20918D          	  1644:   jsr editor_memory_show_ascii
                        	  1645: editor_memory_aborted:
00:8D8B 209292          	  1646:   jsr CROUT
00:8D8E 4CCD82          	  1647:   jmp  main_prompt
                        	  1648: 
                        	  1649: editor_memory_show_ascii:
                        	  1650: ;
                        	  1651: ;  now the ASCII equivalents
                        	  1652: ;
00:8D91 A000            	  1653:   ldy #0
                        	  1654: editor_memory_ascii:
00:8D93 B1AE            	  1655:   lda (this_line_addr),Y
00:8D95 C920            	  1656:   cmp #$20
00:8D97 B002            	  1657:   bcs editor_memory_not_control
00:8D99 8004            	  1658:   bra editor_memory_show_dot
                        	  1659: editor_memory_not_control:
00:8D9B C97F            	  1660:   cmp #$7F
00:8D9D 9002            	  1661:   bcc editor_memory_not_high
                        	  1662: editor_memory_show_dot
00:8D9F A92E            	  1663:   lda #'.'
                        	  1664: editor_memory_not_high:
00:8DA1 201994          	  1665:   jsr COUT
00:8DA4 201D93          	  1666:   jsr PUTSP
00:8DA7 C8              	  1667:   iny
00:8DA8 C6A2            	  1668:   dec current_line
00:8DAA D0E7            	  1669:   bne editor_memory_ascii
                        	  1670: ;
                        	  1671: ;  adjust the ASCII printing address
                        	  1672: ;
00:8DAC A59E            	  1673:   lda from_line
00:8DAE 85AE            	  1674:   sta this_line_addr
00:8DB0 A59F            	  1675:   lda from_line+1
00:8DB2 85AF            	  1676:   sta this_line_addr+1
                        	  1677: 
00:8DB4 209292          	  1678:   jsr CROUT
00:8DB7 60              	  1679:   rts
                        	  1680: 
                        	  1681: 
                        	  1682: 
                        	  1683: 
00:8DB8 4164647220507265	  1684: symbol_table_message asciiz "Addr Prev L  T Dsp  Ar Da Ln Name\n"
00:8DC0 76204C2020542044
00:8DC8 7370202041722044
00:8DD0 61204C6E204E616D
00:8DD8 650A
00:8DDA 00
                        	  1685: 
                        	  1686: editor_symbol_table_list  = *
00:8DDB A9B8            	  1687:   lda #<symbol_table_message
00:8DDD A28D            	  1688:   ldx #>symbol_table_message
00:8DDF 202682          	  1689:   jsr print
                        	  1690: 
00:8DE2 A532            	  1691:   lda  ENDSYM+1    ; get the end of the symbol table
00:8DE4 8541            	  1692:   sta  SYMITM+1    ; make it the current symbol
00:8DE6 A531            	  1693:   lda  ENDSYM
00:8DE8 800B            	  1694:   bra  ST_SYMTBL_LIST_CHECK
                        	  1695: 
                        	  1696: ST_SYMTBL_LIST_NEXT =  *
00:8DEA A000            	  1697:   ldy  #SYMPRV
00:8DEC B140            	  1698:   lda  (SYMITM),Y
00:8DEE AA              	  1699:   tax
00:8DEF C8              	  1700:   iny
00:8DF0 B140            	  1701:   lda  (SYMITM),Y
00:8DF2 8541            	  1702:   sta  SYMITM+1   ; previous link
00:8DF4 8A              	  1703:   txa
                        	  1704: ;
                        	  1705: ;  go to the previous symbol table item
                        	  1706: ;
                        	  1707: ST_SYMTBL_LIST_CHECK     =  *
00:8DF5 8540            	  1708:   sta  SYMITM
00:8DF7 C9FF            	  1709:   cmp  #<SYMBOL_TABLE_START
00:8DF9 D009            	  1710:   bne  ST_SYMTBL_LIST_LINE
00:8DFB A541            	  1711:   lda  SYMITM+1
00:8DFD C93F            	  1712:   cmp  #>SYMBOL_TABLE_START
00:8DFF D003            	  1713:   bne  ST_SYMTBL_LIST_LINE       ; more to go
00:8E01 4C8A8E          	  1714:   jmp  ST_SYMTBL_LIST_DONE       ; finished if symitm and symitm+1 are both zero
                        	  1715: 
                        	  1716: ST_SYMTBL_LIST_LINE = *
00:8E04 A541            	  1717:   lda  SYMITM+1
00:8E06 200793          	  1718:   jsr  PRBYTE
00:8E09 A540            	  1719:   lda  SYMITM
00:8E0B 200793          	  1720:   jsr  PRBYTE
00:8E0E A920            	  1721:   lda  #' '
00:8E10 20EF92          	  1722:   jsr  PRCHAR
00:8E13 A001            	  1723:   ldy  #SYMPRV+1
00:8E15 B140            	  1724:   lda  (SYMITM),Y
00:8E17 200793          	  1725:   jsr  PRBYTE
00:8E1A 88              	  1726:   dey
00:8E1B B140            	  1727:   lda  (SYMITM),Y
00:8E1D 200793          	  1728:   jsr  PRBYTE
00:8E20 A920            	  1729:   lda  #' '
00:8E22 20EF92          	  1730:   jsr  PRCHAR
00:8E25 A002            	  1731:   ldy  #SYMLVL
00:8E27 B140            	  1732:   lda  (SYMITM),Y  ; level
00:8E29 200793          	  1733:   jsr  PRBYTE
00:8E2C A920            	  1734:   lda  #' '
00:8E2E 20EF92          	  1735:   jsr  PRCHAR
00:8E31 A003            	  1736:   ldy  #SYMTYP
00:8E33 B140            	  1737:   lda  (SYMITM),Y  ; type
00:8E35 20EF92          	  1738:   jsr  PRCHAR
00:8E38 A920            	  1739:   lda  #' '
00:8E3A 20EF92          	  1740:   jsr  PRCHAR
00:8E3D A004            	  1741:   ldy  #SYMDSP
00:8E3F C8              	  1742:   iny
00:8E40 B140            	  1743:   lda  (SYMITM),Y  ; displacement
00:8E42 200793          	  1744:   jsr  PRBYTE
00:8E45 88              	  1745:   dey
00:8E46 B140            	  1746:   lda  (SYMITM),Y  ; displacement
00:8E48 200793          	  1747:   jsr  PRBYTE
00:8E4B A920            	  1748:   lda  #' '
00:8E4D 20EF92          	  1749:   jsr  PRCHAR
00:8E50 A006            	  1750:   ldy  #SYMARG
00:8E52 B140            	  1751:   lda  (SYMITM),Y  ; argument count
00:8E54 200793          	  1752:   jsr  PRBYTE
00:8E57 A920            	  1753:   lda  #' '
00:8E59 20EF92          	  1754:   jsr  PRCHAR
00:8E5C A008            	  1755:   ldy  #SYMDAT
00:8E5E B140            	  1756:   lda  (SYMITM),Y  ; data type
00:8E60 200793          	  1757:   jsr  PRBYTE
00:8E63 A920            	  1758:   lda  #' '
00:8E65 20EF92          	  1759:   jsr  PRCHAR
00:8E68 A009            	  1760:   ldy  #SYMLEN
00:8E6A B140            	  1761:   lda  (SYMITM),Y  ; length
00:8E6C 48              	  1762:   pha
00:8E6D 200793          	  1763:   jsr  PRBYTE
00:8E70 A920            	  1764:   lda  #' '
00:8E72 20EF92          	  1765:   jsr  PRCHAR
00:8E75 A00A            	  1766:   ldy  #SYMNAM
00:8E77 68              	  1767:   pla
00:8E78 AA              	  1768:   tax
                        	  1769: ST_SYMTBL_LIST_NAME = *
00:8E79 B140            	  1770:   lda  (SYMITM),Y  ; name
00:8E7B 5A              	  1771:   phy
00:8E7C 20EF92          	  1772:   jsr  PRCHAR
00:8E7F 7A              	  1773:   ply
00:8E80 C8              	  1774:   iny
00:8E81 CA              	  1775:   dex
00:8E82 D0F5            	  1776:   bne ST_SYMTBL_LIST_NAME
00:8E84 209292          	  1777:   jsr CROUT
00:8E87 4CEA8D          	  1778:   jmp ST_SYMTBL_LIST_NEXT
                        	  1779: 
                        	  1780: ST_SYMTBL_LIST_DONE = *
                        	  1781: 
00:8E8A 4CCD82          	  1782:   jmp main_prompt
                        	  1783: 
                        	  1784: 
00:8E8D 446F6E650A      	  1785: recover_done asciiz "Done\n"
00:8E92 00
00:8E93 4E6F74206E656564	  1786: recover_not_needed asciiz "Not needed\n"
00:8E9B 65640A
00:8E9E 00
                        	  1787: 
                        	  1788: ;
                        	  1789: ; Recover: if the first byte of the source is 0x00, change it to a space
                        	  1790: ;
                        	  1791: editor_recover:
00:8E9F 205986          	  1792:   jsr editor_check_no_more
00:8EA2 A900            	  1793:   lda  #<TEXT_START
00:8EA4 8540            	  1794:   sta  FROM
00:8EA6 A903            	  1795:   lda  #>TEXT_START
00:8EA8 8541            	  1796:   sta  FROM+1
00:8EAA A000            	  1797:   ldy  #0
00:8EAC B140            	  1798:   lda  (FROM),Y
00:8EAE D00E            	  1799:   bne  editor_recover_not_needed
00:8EB0 A920            	  1800:   lda  #' '
00:8EB2 9140            	  1801:   sta  (FROM),Y
00:8EB4 A98D            	  1802:   lda #<recover_done
00:8EB6 A28E            	  1803:   ldx #>recover_done
00:8EB8 202682          	  1804:   jsr print
00:8EBB 4CCD82          	  1805:   jmp main_prompt
                        	  1806: 
                        	  1807: editor_recover_not_needed:
00:8EBE A993            	  1808:   lda #<recover_not_needed
00:8EC0 A28E            	  1809:   ldx #>recover_not_needed
00:8EC2 202682          	  1810:   jsr print
00:8EC5 4CCD82          	  1811:   jmp main_prompt
                        	  1812: 
                        	  1813: 
                        	  1814: editor_debug:
00:8EC8 205986          	  1815:   jsr editor_check_no_more
00:8ECB A901            	  1816:   lda #1
00:8ECD 8549            	  1817:   sta  DBGFLG
00:8ECF 852E            	  1818:   sta  DCODE
00:8ED1 4CD593          	  1819:   jmp  CHK_RUN
                        	  1820: 
                        	  1821: editor_trace:
00:8ED4 205986          	  1822:   jsr editor_check_no_more
00:8ED7 A980            	  1823:   lda  #$80
00:8ED9 8549            	  1824:   sta  DBGFLG
00:8EDB 852E            	  1825:   sta  DCODE
00:8EDD 4CD593          	  1826:   jmp  CHK_RUN
                        	  1827: 
                        	  1828: 
                        	  1829: editor_info  = *
00:8EE0 205986          	  1830:   jsr editor_check_no_more
00:8EE3 205C8F          	  1831:   jsr show_source_start
00:8EE6 20348F          	  1832:   jsr show_source_end
00:8EE9 20ED90          	  1833:   jsr crc_source
00:8EEC 4CCD82          	  1834:   jmp main_prompt
                        	  1835: 
                        	  1836: editor_compile:
00:8EEF 205986          	  1837:   jsr editor_check_no_more
00:8EF2 A900            	  1838:   lda  #0
00:8EF4 8542            	  1839:   sta  SYNTAX
00:8EF6 4C46BA          	  1840:   jmp  COMPIL
                        	  1841: 
                        	  1842: editor_syntax:
00:8EF9 205986          	  1843:   jsr editor_check_no_more
00:8EFC A901            	  1844:   lda #1
00:8EFE 8542            	  1845:   sta  SYNTAX
00:8F00 4C46BA          	  1846:   jmp  COMPIL
                        	  1847: 
                        	  1848: editor_run:
00:8F03 205986          	  1849:   jsr editor_check_no_more
00:8F06 A900            	  1850:   lda  #0
00:8F08 8549            	  1851:   sta  DBGFLG
00:8F0A 852E            	  1852:   sta  DCODE
00:8F0C 4CD593          	  1853:   jmp  CHK_RUN
                        	  1854: 
                        	  1855:   ;
                        	  1856: show_symbol_table_end:
00:8F0F A97A            	  1857:   lda  #<symbol_table_ended_message    ; Symbol table ended at
00:8F11 A293            	  1858:   ldx  #>symbol_table_ended_message
00:8F13 202682          	  1859:   jsr  print
00:8F16 A532            	  1860:   lda  ENDSYM+1
00:8F18 200793          	  1861:   jsr  PRBYTE
00:8F1B A531            	  1862:   lda  ENDSYM
00:8F1D 20BC93          	  1863:   jsr  PRBYTECR
00:8F20 60              	  1864:   rts
                        	  1865: 
                        	  1866: 
00:8F21 536F757263652065	  1867: source_ended_message asciiz "Source ends   at $"
00:8F29 6E64732020206174
00:8F31 2024
00:8F33 00
                        	  1868: show_source_end:
00:8F34 A921            	  1869:   lda #<source_ended_message
00:8F36 A28F            	  1870:   ldx #>source_ended_message
00:8F38 202682          	  1871:   jsr print
00:8F3B 20D28C          	  1872:   jsr find_source_end
00:8F3E A524            	  1873:   lda PCODE+1
00:8F40 200793          	  1874:   jsr PRBYTE
00:8F43 A523            	  1875:   lda PCODE
00:8F45 20BC93          	  1876:   jsr PRBYTECR
00:8F48 60              	  1877:   rts
                        	  1878: 
00:8F49 536F757263652073	  1879: source_starts_message asciiz "Source starts at $"    ; source starts at
00:8F51 7461727473206174
00:8F59 2024
00:8F5B 00
                        	  1880: show_source_start:
00:8F5C A949            	  1881:   lda #<source_starts_message
00:8F5E A28F            	  1882:   ldx #>source_starts_message
00:8F60 202682          	  1883:   jsr print
00:8F63 A903            	  1884:   lda #>TEXT_START
00:8F65 200793          	  1885:   jsr PRBYTE
00:8F68 A900            	  1886:   lda #<TEXT_START
00:8F6A 20BC93          	  1887:   jsr PRBYTECR
00:8F6D 60              	  1888:   rts
                        	  1889: 
                        	  1890: editor_assemble:
00:8F6E 205986          	  1891:   jsr editor_check_no_more
00:8F71 4CAC98          	  1892:   jmp ASSEMBLE
                        	  1893: 
                        	  1894: 
                        	  1895: 
                        	  1896: 
                        	  1897: ;16-bit number comparison...
                        	  1898: ;
                        	  1899: ;         lda #>x               ; MSB of 1st number
                        	  1900: ;         cmp #>y               ; MSB of 2nd number
                        	  1901: ;         bcc islower           ; X < Y
                        	  1902: ;
                        	  1903: ;         bne ishigher          ; X > Y
                        	  1904: ;
                        	  1905: ;         lda #<x               ; LSB of 1st number
                        	  1906: ;         cmp #<y               ; LSB of 2nd number
                        	  1907: ;         bcc islower           ; X < Y
                        	  1908: ;
                        	  1909: ;         beq issame            ; X = Y
                        	  1910: ;
                        	  1911: ;         bne ishigher          ; X > Y
                        	  1912: ;
                        	  1913: ;
                        	  1914: 

Source: "gpascal.asm"
                        	   176:   .include "utilities.inc"

Source: "utilities.inc"
                        	     1: ;
                        	     2: ;  function to look up a handler for a word (eg. assembler directive)
                        	     3: ;
                        	     4: ;  word in SRCE
                        	     5: ;
                        	     6: ;  table of words/handlers in DEST
                        	     7: ;
                        	     8: ;  length of word in A
                        	     9: ;
                        	    10: ;  see makeHandler for making the table
                        	    11: ;
                        	    12: ;  Basically:
                        	    13: ;    asciiz "foo"
                        	    14: ;    word   foo_handler
                        	    15: ;
                        	    16: ;  In other words:
                        	    17: ;    makeHandler "foo",foo_handler
                        	    18: ;
                        	    19: ;  Returns with carry set if no match, otherwise calls the handler which should clear carry
                        	    20: ;
                        	    21: 
                        	    22: handlerLookup:
00:8F74 8598            	    23:   sta token_work    ; save length
                        	    24: 
                        	    25: ;
                        	    26: ;  find the length of the word
                        	    27: ;
                        	    28: handler_loop:
00:8F76 A000            	    29:   ldy #0
00:8F78 B103            	    30:   lda (DEST),y
00:8F7A F036            	    31:   beq handlers_done
                        	    32: handler_find_length:
00:8F7C B103            	    33:   lda (DEST),y
00:8F7E F005            	    34:   beq handler_found_length
00:8F80 C8              	    35:   iny
00:8F81 F02F            	    36:   beq handlers_done   ; sanity clause
00:8F83 80F7            	    37:   bra handler_find_length
                        	    38: handler_found_length:
                        	    39: 
                        	    40: ;  lda #'i'
                        	    41: ;  jsr ass_debug_point
                        	    42: 
00:8F85 C498            	    43:   cpy token_work
00:8F87 F010            	    44:   beq handler_same_length
                        	    45: ;
                        	    46: ;  not the same length, or no match on the string
                        	    47: ;
                        	    48: handler_next:
00:8F89 98              	    49:   tya
00:8F8A 18              	    50:   clc
00:8F8B 6903            	    51:   adc #3  ; skip the 0x00 and the execution address
00:8F8D 6503            	    52:   adc DEST
00:8F8F 8503            	    53:   sta DEST
00:8F91 A504            	    54:   lda DEST+1
00:8F93 6900            	    55:   adc #0
00:8F95 8504            	    56:   sta DEST+1
00:8F97 80DD            	    57:   bra handler_loop
                        	    58: 
                        	    59: handler_same_length:
                        	    60: 
                        	    61: ;  lda #'j'
                        	    62: ;  jsr ass_debug_point
                        	    63: 
00:8F99 5A              	    64:   phy  ; save the length
00:8F9A 209792          	    65:   jsr COMSTL
00:8F9D F003            	    66:   beq  handler_found_directive
00:8F9F 7A              	    67:   ply
00:8FA0 80E7            	    68:   bra handler_next
                        	    69: handler_found_directive:
00:8FA2 7A              	    70:   ply  ; get the length back
00:8FA3 C8              	    71:   iny  ; skip past the 0x00 byte
00:8FA4 B103            	    72:   lda (DEST),y
00:8FA6 8599            	    73:   sta token_work+1
00:8FA8 C8              	    74:   iny
00:8FA9 B103            	    75:   lda (DEST),y
00:8FAB 859A            	    76:   sta token_work+2
00:8FAD 20B48F          	    77:   jsr call_handler
00:8FB0 18              	    78:   clc
00:8FB1 60              	    79:   rts
                        	    80: 
                        	    81: handlers_done:
                        	    82: ;  lda #'h'
                        	    83: ;  jsr ass_debug_point
00:8FB2 38              	    84:   sec     ; error flag
00:8FB3 60              	    85:   rts
                        	    86: 
                        	    87: call_handler:
                        	    88: ;  lda #'g'
                        	    89: ;  jsr ass_debug_point
                        	    90: 
00:8FB4 6C9900          	    91:   jmp (token_work+1)   ; do handler - it will RTS for us
                        	    92: 
                        	    93: 
                        	    94: ;
                        	    95: ;  function to look up a handler for a word on a partial match (eg. editor command)
                        	    96: ;
                        	    97: ;  word in SRCE
                        	    98: ;
                        	    99: ;  table of words/handlers in DEST - in UPPER CASE
                        	   100: ;
                        	   101: ;  length of word in A
                        	   102: ;
                        	   103: ;  see makeHandler for making the table
                        	   104: ;
                        	   105: ;  Basically:
                        	   106: ;    asciiz "FOO"
                        	   107: ;    word   foo_handler
                        	   108: ;
                        	   109: ;  In other words:
                        	   110: ;    makeHandler "FOO",foo_handler
                        	   111: ;
                        	   112: ;  Returns if no match, otherwise jumps to the handler and thus doesn't return
                        	   113: ;
                        	   114: 
                        	   115: partial_handler_Lookup:
00:8FB7 8598            	   116:   sta token_work    ; save length
                        	   117: ;
                        	   118: ;  here for a new table item
                        	   119: ;
                        	   120: partial_handler_next_item:
00:8FB9 A000            	   121:   ldy #0
00:8FBB B103            	   122:   lda (DEST),y
00:8FBD F03C            	   123:   beq partial_handler_done
00:8FBF A698            	   124:   ldx token_work        ; source length
                        	   125: partial_handler_next_loop:
                        	   126: ;
                        	   127: ;  ensure the nth character matches until the source runs out
                        	   128: ;
00:8FC1 B100            	   129:   lda (SRCE),y
00:8FC3 202E90          	   130:   jsr MAKE_UPPER
00:8FC6 D103            	   131:   cmp (DEST),y
00:8FC8 D006            	   132:   bne partial_handler_next
00:8FCA C8              	   133:   iny
00:8FCB CA              	   134:   dex     ; one less count
00:8FCC F019            	   135:   beq partial_handler_found_directive ; source has finished and we found the directive
00:8FCE 80F1            	   136:   bra partial_handler_next_loop       ; try matching the next one
                        	   137: ;
                        	   138: ;  no match on the string - advance Y to the end of the destination string
                        	   139: ;
                        	   140: partial_handler_next:
00:8FD0 B103            	   141:   lda (DEST),y
00:8FD2 F003            	   142:   beq partial_handler_next_found_item_length
00:8FD4 C8              	   143:   iny
00:8FD5 80F9            	   144:   bra partial_handler_next
                        	   145: partial_handler_next_found_item_length:
00:8FD7 98              	   146:   tya     ; length of the word in the table
00:8FD8 18              	   147:   clc
00:8FD9 6903            	   148:   adc #3  ; skip the 0x00 and the execution address
00:8FDB 6503            	   149:   adc DEST
00:8FDD 8503            	   150:   sta DEST
00:8FDF A504            	   151:   lda DEST+1
00:8FE1 6900            	   152:   adc #0
00:8FE3 8504            	   153:   sta DEST+1
00:8FE5 80D2            	   154:   bra partial_handler_next_item
                        	   155: 
                        	   156: partial_handler_found_directive:
00:8FE7 B103            	   157:   lda (DEST),y
00:8FE9 F003            	   158:   beq partial_handler_skipped_string
00:8FEB C8              	   159:   iny
00:8FEC 80F9            	   160:   bra partial_handler_found_directive
                        	   161: partial_handler_skipped_string:
00:8FEE C8              	   162:   iny  ; skip past the 0x00 byte
00:8FEF B103            	   163:   lda (DEST),y
00:8FF1 8599            	   164:   sta token_work+1
00:8FF3 C8              	   165:   iny
00:8FF4 B103            	   166:   lda (DEST),y
00:8FF6 859A            	   167:   sta token_work+2
00:8FF8 6C9900          	   168:   jmp (token_work+1)   ; do partial_partial_handler_ - it will RTS for us
                        	   169: 
                        	   170: partial_handler_done:
00:8FFB 60              	   171:   rts
                        	   172: 
                        	   173: ;***********************************************
                        	   174: ; JUMP ON TOKEN
                        	   175: ; X/Y = START OF TABLE
                        	   176: ; END OF TABLE IS A NULL
                        	   177: ; A = TOKEN
                        	   178: ;***********************************************
                        	   179: TKNJMP   =  *
00:8FFC 8600            	   180:          stx  REG     ; save table address
00:8FFE 8401            	   181:          sty  REG+1
                        	   182: 
00:9000 202E90          	   183:          jsr MAKE_UPPER
00:9003 AA              	   184:          tax          ; save the token
                        	   185: JMP1     =  *
00:9004 A000            	   186:          ldy  #0
00:9006 B100            	   187:          lda  (REG),Y
00:9008 D002            	   188:          bne  JMP2
                        	   189: ; failed to find the token
00:900A 8A              	   190:          txa          ; retore the token
00:900B 60              	   191:          rts
                        	   192: JMP2     =  *
00:900C 8A              	   193:          txa          ; get token back
00:900D D100            	   194:          cmp  (REG),Y
00:900F D010            	   195:          bne  JMP3    ; branch if not found
00:9011 68              	   196:          pla
00:9012 68              	   197:          pla          ; remove return address for TKNJMP call
00:9013 C8              	   198:          iny          ; move Y on to routine address
00:9014 B100            	   199:          lda  (REG),Y ; get low order byte of routine
00:9016 8503            	   200:          sta  REG2
00:9018 C8              	   201:          iny          ; next byte
00:9019 B100            	   202:          lda  (REG),Y ; get high order byte
00:901B 8504            	   203:          sta  REG2+1
00:901D 8A              	   204:          txa          ; get token back
00:901E 6C0300          	   205:          jmp  (REG2)  ; go to routine
                        	   206: JMP3     =  *
00:9021 A500            	   207:          lda  REG     ; skip this token sequence
00:9023 18              	   208:          clc
00:9024 6903            	   209:          adc  #3
00:9026 8500            	   210:          sta  REG
00:9028 90DA            	   211:          bcc  JMP1
00:902A E601            	   212:          inc  REG+1
00:902C 80D6            	   213:          bra  JMP1    ; try again
                        	   214: 
                        	   215: ;
                        	   216: 
                        	   217: 
                        	   218: ;***********************************************
                        	   219: ;
                        	   220: ; Case conversion
                        	   221: ;
                        	   222: ;***********************************************
                        	   223: 
                        	   224: 
                        	   225: MAKE_UPPER = *
00:902E C97B            	   226:          CMP  #('z'+1)
00:9030 B006            	   227:          BCS  MAKE_UPPER_DONE
00:9032 C961            	   228:          CMP  #'a'
00:9034 9002            	   229:          BCC  MAKE_UPPER_DONE
00:9036 E920            	   230:          SBC  #$20  ; make upper-case - we want carry set so there is no borrow
                        	   231: MAKE_UPPER_DONE = *
00:9038 60              	   232:          RTS
                        	   233: 
                        	   234: MAKE_LOWER = *
00:9039 C941            	   235:          CMP  #'A'
00:903B 9006            	   236:          BCC  MAKE_LOWER_DONE
00:903D C95B            	   237:          CMP  #('Z'+1)
00:903F B002            	   238:          BCS  MAKE_LOWER_DONE
00:9041 6920            	   239:          ADC  #$20  ; make upper-case - we want carry clear so there is no carry
                        	   240: MAKE_LOWER_DONE = *
00:9043 60              	   241:          RTS
                        	   242: 
                        	   243: 
                        	   244: ;
                        	   245: ;  generate the next random number
                        	   246: ;
                        	   247: gen_random:
00:9044 0609            	   248:     asl random
00:9046 260A            	   249:     rol random+1
00:9048 260B            	   250:     rol random+2
00:904A 260C            	   251:     rol random+3
00:904C 9018            	   252:     bcc gen_random1
00:904E A509            	   253:     lda random
00:9050 49B7            	   254:     eor #$B7
00:9052 8509            	   255:     sta random
00:9054 A50A            	   256:     lda random+1
00:9056 491D            	   257:     eor #$1D
00:9058 850A            	   258:     sta random+1
00:905A A50B            	   259:     lda random+2
00:905C 49C1            	   260:     eor #$C1
00:905E 850B            	   261:     sta random+2
00:9060 A50C            	   262:     lda random+3
00:9062 4904            	   263:     eor #$04
00:9064 850C            	   264:     sta random+3
                        	   265: gen_random1:
00:9066 60              	   266:     rts
                        	   267: 
                        	   268: 
                        	   269: 
                        	   270: ;
                        	   271: ;  From: http://www.6502.org/source/integers/crc-more.html
                        	   272: ;
                        	   273: ;   jacksum  -a crc:16,1021,FFFF,false,false,0 -X SOME_FILE
                        	   274: ;
                        	   275: ;   https://jacksum.net/en/index.html
                        	   276: ;
                        	   277: ;   With a starting CRC of $FFFF, the binary string $01 $02 $03 $04 should evaluate to $89C3.
                        	   278: ;
                        	   279: ;   Start at crc_addr, for crc_num bytes
                        	   280: ;
                        	   281: crc16 = *
                        	   282: ;
                        	   283: ;  initialise CRC
                        	   284: ;
00:9067 A9FF            	   285:   lda #$FF
00:9069 8506            	   286:   sta crc_val
00:906B 8507            	   287:   sta crc_val+1
00:906D A503            	   288:   lda crc_num
00:906F 0504            	   289:   ora crc_num+1
00:9071 F01B            	   290:   beq crc_done
                        	   291: 
                        	   292: ;
                        	   293: ;  here for each byte
                        	   294: ;
                        	   295: crc16_loop  = *
00:9073 A000            	   296:   ldy #0
00:9075 B100            	   297:   lda (crc_addr),y  ; get next byte
00:9077 208F90          	   298:   jsr crc_byte
                        	   299:   ;
                        	   300:   ;  onto next address
                        	   301:   ;
00:907A E600            	   302:   inc crc_addr
00:907C D002            	   303:   bne crc16_next
00:907E E601            	   304:   inc crc_addr+1       ; Step to next byte
                        	   305: crc16_next:
                        	   306:   ;
                        	   307:   ; now do a 16-bit decrement
                        	   308:   ;
00:9080 A503            	   309:   LDA crc_num
00:9082 D002            	   310:   BNE crc16_skip    ; decrement the high-order byte if we are about to wrap
00:9084 C604            	   311:   DEC crc_num+1
                        	   312: crc16_skip:
00:9086 C603            	   313:   DEC crc_num       ; decrement the low-order byte
00:9088 D0E9            	   314:   BNE crc16_loop    ; not zero, keep going
00:908A A504            	   315:   LDA crc_num+1     ; are we zero here too?
00:908C D0E5            	   316:   BNE crc16_loop    ; not yet
                        	   317: 
                        	   318: crc_done:
00:908E 60              	   319:   rts
                        	   320: 
                        	   321: ;
                        	   322: ;  do a CRC of one byte (in A) updating crc_val
                        	   323: ;
                        	   324: crc_byte = *
00:908F 4507            	   325:   eor crc_val+1     ; A contained the data
00:9091 8507            	   326:   sta crc_val+1     ; XOR it into high byte
00:9093 4A              	   327:   lsr               ; right shift A 4 bits
00:9094 4A              	   328:   lsr               ; to make top of x^12 term
00:9095 4A              	   329:   lsr               ; ($1...)
00:9096 4A              	   330:   lsr
00:9097 AA              	   331:   tax               ; save it
00:9098 0A              	   332:   asl               ; then make top of x^5 term
00:9099 4506            	   333:   eor crc_val       ; and XOR that with low byte
00:909B 8506            	   334:   sta crc_val       ; and save
00:909D 8A              	   335:   txa               ; restore partial term
00:909E 4507            	   336:   eor crc_val+1     ; and update high byte
00:90A0 8507            	   337:   sta crc_val+1     ; and save
00:90A2 0A              	   338:   asl               ; left shift three
00:90A3 0A              	   339:   asl               ; the rest of the terms
00:90A4 0A              	   340:   asl               ; have feedback from x^12
00:90A5 AA              	   341:   tax               ; save bottom of x^12
00:90A6 0A              	   342:   asl               ; left shift two more
00:90A7 0A              	   343:   asl               ; watch the carry flag
00:90A8 4507            	   344:   eor crc_val+1     ; bottom of x^5 ($..2.)
00:90AA A8              	   345:   tay               ; save high byte
00:90AB 8A              	   346:   txa               ; fetch temp value
00:90AC 2A              	   347:   rol               ; bottom of x^12, middle of x^5!
00:90AD 4506            	   348:   eor crc_val       ; finally update low byte
00:90AF 8507            	   349:   sta crc_val+1     ; then swap high and low bytes
00:90B1 8406            	   350:   sty crc_val
00:90B3 60              	   351:   rts
                        	   352: 
                        	   353: 
                        	   354: crc_helper = *
00:90B4 5A              	   355:   phy
00:90B5 DA              	   356:   phx
00:90B6 208F90          	   357:   jsr crc_byte
00:90B9 E603            	   358:   inc crc_num
00:90BB D002            	   359:   bne crc_helper1
00:90BD E604            	   360:   inc crc_num+1
                        	   361: crc_helper1:
00:90BF FA              	   362:   plx
00:90C0 7A              	   363:   ply
00:90C1 60              	   364:   rts
                        	   365: 
00:90C2 536F757263652043	   366: crc_message asciiz "Source CRC       $"               ; source CRC
00:90CA 5243202020202020
00:90D2 2024
00:90D4 00
00:90D5 536F75726365206C	   367: source_length_message asciiz "Source length: "    ; source length
00:90DD 656E6774683A20
00:90E4 00
00:90E5 2062797465730A  	   368: bytes_message asciiz " bytes\n"
00:90EC 00
                        	   369: 
                        	   370: crc_source = *
00:90ED 20D28C          	   371:   jsr find_source_end
                        	   372: 
                        	   373: ;
                        	   374: ;  move existing source to end of RAM
                        	   375: ;
00:90F0 18              	   376:   clc             ; don't count the final 0x00 byte
00:90F1 A523            	   377:   lda PCODE
00:90F3 E900            	   378:   sbc #<TEXT_START
00:90F5 8503            	   379:   sta crc_num
00:90F7 A524            	   380:   lda PCODE+1
00:90F9 E903            	   381:   sbc #>TEXT_START
00:90FB 8504            	   382:   sta crc_num+1
                        	   383: ;
                        	   384: ;  Show the length of the source
                        	   385: ;
00:90FD A9D5            	   386:   lda #<source_length_message
00:90FF A290            	   387:   ldx #>source_length_message
00:9101 202682          	   388:   jsr print
00:9104 A503            	   389:   lda crc_num
00:9106 8500            	   390:   sta REG
00:9108 A504            	   391:   lda crc_num+1
00:910A 8501            	   392:   sta REG+1
00:910C 6402            	   393:   stz REGB
00:910E 20BC91          	   394:   jsr display_in_decimal
00:9111 A9E5            	   395:   lda #<bytes_message
00:9113 A290            	   396:   ldx #>bytes_message
00:9115 202682          	   397:   jsr print
                        	   398: 
                        	   399: ;
                        	   400: ;  now the CRC
                        	   401: ;
00:9118 A900            	   402:   lda #<TEXT_START
00:911A 8500            	   403:   sta crc_addr
00:911C A903            	   404:   lda #>TEXT_START
00:911E 8501            	   405:   sta crc_addr+1
00:9120 206790          	   406:   jsr crc16
00:9123 A9C2            	   407:   lda  #<crc_message            ;  source CRC
00:9125 A290            	   408:   ldx  #>crc_message            ;
00:9127 202682          	   409:   jsr  print
00:912A A507            	   410:   lda crc_val+1
00:912C 200793          	   411:   jsr PRBYTE
00:912F A506            	   412:   lda crc_val
00:9131 20BC93          	   413:   jsr PRBYTECR
00:9134 60              	   414:   rts
                        	   415: 
                        	   416: 
                        	   417: ;
                        	   418: ;  delays for roughly 1 ms - changes no registers
                        	   419: ;
                        	   420: delay_1ms = *
00:9135 DA              	   421:          phx
00:9136 A26C            	   422:          ldx #108
                        	   423: delay_1ms_loop:
00:9138 EA              	   424:          nop
00:9139 EA              	   425:          nop
00:913A CA              	   426:          dex
00:913B D0FB            	   427:          bne delay_1ms_loop
00:913D FA              	   428:          plx
00:913E 60              	   429:          rts
                        	   430: 
                        	   431: ;
                        	   432: ; delay for YYXX ms (Y = high-order byte, X = lo-order byte)
                        	   433: ;  maximum delay 0x7FFF, that is 32767 ms
                        	   434: ;  Changes X and Y
                        	   435: ;
                        	   436: delay = *
00:913F 203591          	   437:   jsr delay_1ms
00:9142 CA              	   438:   dex
00:9143 D0FA            	   439:   bne delay
00:9145 88              	   440:   dey
00:9146 10F7            	   441:   bpl delay
00:9148 60              	   442:   rts
                        	   443: 
                        	   444: 
                        	   445: ;--------------------------------------------------------------------------
                        	   446: ;
                        	   447: ;  BINARY TO DECIMAL CONVERSION
                        	   448: ;
                        	   449: ;  This works as follows:
                        	   450: ;
                        	   451: ;  1. First the number is checked if it is negative (sign bit set).
                        	   452: ;  2. If so, a "-" is output and the number subtracted from zero to make it positive.
                        	   453: ;  3. Our next step is to set a BCD (binary coded decimal) output area to all zeroes.
                        	   454: ;      In BCD, the number 1234 is actually stored as 0x1234.
                        	   455: ;      With BCD mode turned on in the processor, doing adds results in an early carry
                        	   456: ;      so that numbers add "the decimal way" rather than the binary way.
                        	   457: ;  4. Then we a loop of 24 iterations (one for each bit) which adds the appropriate number from bcd_table
                        	   458: ;      if that bit was set in the original value.
                        	   459: ;  5. The function bcd_unpack is then called to convert the BCD format into ASCII format. It takes each
                        	   460: ;     nibble and adds 0x30 ('0') to it, and saves that in bcd_result.
                        	   461: ;  6. At this stage bcd_result has a 8-digit ASCII number in it.
                        	   462: ;  7. We then skip leading zeroes in bcd_result.
                        	   463: ;  8. Finally the remaining digits in bcd_result are output.
                        	   464: ;
                        	   465: ;
                        	   466: ;   I'm not sure where the idea for this came from. There was no Internet when this was written in 1979
                        	   467: ;   so it is possibly (probably) my own.
                        	   468: ;   My original implementation, although similar, was more complex than this one, which I found at:
                        	   469: ;              http://www.6502.org/source/integers/hex2dec.htm
                        	   470: ;
                        	   471: ;   Other suggestions for binary to decimal conversion I found recently do not employ this method. One
                        	   472: ;   technique (as described by Ben Eater here: https://www.youtube.com/watch?v=v3-a-zqKfgA ) is to
                        	   473: ;   repeatedly divide by 10 and use the remainder as the digit. This has to be done until the result of
                        	   474: ;   the division is zero. Dividing a 3-byte number by 10 on an 8-bit machine is not particularly fast,
                        	   475: ;   as it involves an inner loop of 24 iterations (one for each bit) and this would have to be done for
                        	   476: ;   each digit, so the number of loops of 24 iterations would increase for each digit. Therefore an
                        	   477: ;   8-digit number (like 80000000) would take 144 iterations in the divide loop. Then the digits have to
                        	   478: ;   be reversed because the remainder gives you the low-order decimal digit first.
                        	   479: ;
                        	   480: ;   Another technique is the "Double dabble" routine.
                        	   481: ;
                        	   482: ;     https://en.wikipedia.org/wiki/Double_dabble
                        	   483: ;
                        	   484: ;   The method below seems fairly efficient, as the inner loop only does anything substantial if a
                        	   485: ;     1-bit is detected. Thus large numbers can be produced quite efficiently, however it would be a
                        	   486: ;     bit slower if the input number had a lot of 1-bits set.
                        	   487: ;
                        	   488: ;   Considering that this is only used when outputting to serial, itself a slow process, speed is not
                        	   489: ;   really the issue here.
                        	   490: ;
                        	   491: ;   - Nick Gammon
                        	   492: ;
                        	   493: ;
                        	   494: ;--------------------------------------------------------------------------
                        	   495: ;
                        	   496: ; Converts BCD to ASCII
                        	   497: ;
                        	   498: bcd_unpack:
00:9149 48              	   499:   pha  ; save the number for later
                        	   500: ;
                        	   501: ;  shift right 4 bits
                        	   502: ;
00:914A 4A              	   503:   lsr A
00:914B 4A              	   504:   lsr A
00:914C 4A              	   505:   lsr A
00:914D 4A              	   506:   lsr A
00:914E 0930            	   507:   ora #'0'          ; make printable
00:9150 9560            	   508:   sta bcd_result,X  ; save in bcd_result
00:9152 E8              	   509:   inx
00:9153 68              	   510:   pla               ; get the original character back
00:9154 290F            	   511:   and #$0F          ; take low-order bits and make printable
00:9156 0930            	   512:   ora #'0'
00:9158 9560            	   513:   sta bcd_result,X  ; save in bcd_result
00:915A E8              	   514:   inx
00:915B 60              	   515:   rts               ; done!
                        	   516: 
                        	   517: ;
                        	   518: ;
                        	   519: ; Table for adding into the BCD result.
                        	   520: ;
                        	   521: bcd_table  =  *
00:915C 00              	   522:   dfb $00,$00,$00,$01   ; 0000001
00:915D 00
00:915E 00
00:915F 01
00:9160 00              	   523:   dfb $00,$00,$00,$02   ; 0000002
00:9161 00
00:9162 00
00:9163 02
00:9164 00              	   524:   dfb $00,$00,$00,$04   ; 0000004
00:9165 00
00:9166 00
00:9167 04
00:9168 00              	   525:   dfb $00,$00,$00,$08   ; 0000008
00:9169 00
00:916A 00
00:916B 08
00:916C 00              	   526:   dfb $00,$00,$00,$16   ; 0000016
00:916D 00
00:916E 00
00:916F 16
00:9170 00              	   527:   dfb $00,$00,$00,$32   ; 0000032
00:9171 00
00:9172 00
00:9173 32
00:9174 00              	   528:   dfb $00,$00,$00,$64   ; 0000064
00:9175 00
00:9176 00
00:9177 64
00:9178 00              	   529:   dfb $00,$00,$01,$28   ; 0000128
00:9179 00
00:917A 01
00:917B 28
00:917C 00              	   530:   dfb $00,$00,$02,$56   ; 0000256
00:917D 00
00:917E 02
00:917F 56
00:9180 00              	   531:   dfb $00,$00,$05,$12   ; 0000512
00:9181 00
00:9182 05
00:9183 12
00:9184 00              	   532:   dfb $00,$00,$10,$24   ; 0001024
00:9185 00
00:9186 10
00:9187 24
00:9188 00              	   533:   dfb $00,$00,$20,$48   ; 0002048
00:9189 00
00:918A 20
00:918B 48
00:918C 00              	   534:   dfb $00,$00,$40,$96   ; 0004096
00:918D 00
00:918E 40
00:918F 96
00:9190 00              	   535:   dfb $00,$00,$81,$92   ; 0008192
00:9191 00
00:9192 81
00:9193 92
00:9194 00              	   536:   dfb $00,$01,$63,$84   ; 0016384
00:9195 01
00:9196 63
00:9197 84
00:9198 00              	   537:   dfb $00,$03,$27,$68   ; 0032768
00:9199 03
00:919A 27
00:919B 68
00:919C 00              	   538:   dfb $00,$06,$55,$36   ; 0065536
00:919D 06
00:919E 55
00:919F 36
00:91A0 00              	   539:   dfb $00,$13,$10,$72   ; 0131072
00:91A1 13
00:91A2 10
00:91A3 72
00:91A4 00              	   540:   dfb $00,$26,$21,$44   ; 0262144
00:91A5 26
00:91A6 21
00:91A7 44
00:91A8 00              	   541:   dfb $00,$52,$42,$88   ; 0524288
00:91A9 52
00:91AA 42
00:91AB 88
00:91AC 01              	   542:   dfb $01,$04,$85,$76   ; 1048576
00:91AD 04
00:91AE 85
00:91AF 76
00:91B0 02              	   543:   dfb $02,$09,$71,$52   ; 2097152
00:91B1 09
00:91B2 71
00:91B3 52
00:91B4 04              	   544:   dfb $04,$19,$43,$04   ; 4194304
00:91B5 19
00:91B6 43
00:91B7 04
00:91B8 08              	   545:   dfb $08,$38,$86,$08   ; 8388608
00:91B9 38
00:91BA 86
00:91BB 08
                        	   546: 
                        	   547: ;--------------------------------------------------------------------------
                        	   548: ; display_in_decimal - start here - VALUE will be zero after this is executed
                        	   549: ;--------------------------------------------------------------------------
                        	   550: 
                        	   551: display_in_decimal  =  *
00:91BC A502            	   552:   lda  VALUE+2
00:91BE 1008            	   553:   bpl  bcd_positive
                        	   554: ;
                        	   555: ;  if the number is negative, output a minus sign and make it positive
                        	   556: ;
00:91C0 A92D            	   557:   lda  #'-'
00:91C2 201994          	   558:   jsr  COUT
00:91C5 201CAC          	   559:   jsr  exp_unary_minus
                        	   560: ;
                        	   561: ;  number is now positive
                        	   562: ;
                        	   563: bcd_positive:
                        	   564: 
00:91C8 20E591          	   565:   jsr binary_to_decimal   ; do the conversion
                        	   566: 
00:91CB A207            	   567:   ldx  #7         ; zero suppress count (always keep the last zero)
00:91CD A000            	   568:   ldy  #0
                        	   569: ;
                        	   570: ;  this is skipping the leading zeroes
                        	   571: ;
                        	   572: bcd_skip_zeroes:
00:91CF B96000          	   573:   lda  bcd_result,Y
00:91D2 C930            	   574:   cmp  #'0'
00:91D4 D004            	   575:   bne  bcd_output_digit
00:91D6 C8              	   576:   iny
00:91D7 CA              	   577:   dex
00:91D8 D0F5            	   578:   bne  bcd_skip_zeroes
                        	   579: ;
                        	   580: ;  now we have a non-zero, start outputting them
                        	   581: ;
                        	   582: ;  Y points to how far we are through bcd_result
                        	   583: ;  X is how many digits to go
                        	   584: ;
                        	   585: bcd_output_digit:
00:91DA B96000          	   586:   lda  bcd_result,Y
00:91DD 201994          	   587:   jsr  COUT
00:91E0 C8              	   588:   iny
00:91E1 CA              	   589:   dex
00:91E2 10F6            	   590:   bpl  bcd_output_digit
                        	   591: ;
                        	   592: ;  done!
                        	   593: ;
00:91E4 60              	   594:   rts
                        	   595: 
                        	   596: ;--------------------------------------------------------------------------
                        	   597: ;
                        	   598: ;  Binary to decimal routine: Converts VALUE into bcd_result (8 digits)
                        	   599: ;
                        	   600: ;  See: http://www.6502.org/source/integers/hex2dec.htm
                        	   601: ;
                        	   602: ;  - VALUE will be zero after this is executed
                        	   603: ;
                        	   604: ;--------------------------------------------------------------------------
                        	   605: binary_to_decimal:
00:91E5 F8              	   606:   sed                 ; decimal mode for adds below
00:91E6 645C            	   607:   stz  bcd_work       ; zero our result area (4 bytes = 8 digits)
00:91E8 645D            	   608:   stz  bcd_work+1
00:91EA 645E            	   609:   stz  bcd_work+2
00:91EC 645F            	   610:   stz  bcd_work+3
                        	   611: 
00:91EE A25C            	   612:   ldx  #(4*23)        ; X points to the start of the highest entry
                        	   613: 
                        	   614: binary_to_decimal_loop:
00:91F0 0600            	   615:   asl VALUE      ;  shift out high-order bit into Carry
00:91F2 2601            	   616:   rol VALUE+1
00:91F4 2602            	   617:   rol VALUE+2
00:91F6 901D            	   618:   bcc binary_to_decimal_next  ; if carry clear, no add needs to be done
                        	   619: ;
                        	   620: ;  that bit was set, so add the appropriate BCD number from the table (eg. 1, 2, 4, 8, 16 and so on)
                        	   621: ;
00:91F8 18              	   622:   clc
00:91F9 A55C            	   623:   lda bcd_work
00:91FB 7D5F91          	   624:   adc bcd_table+3,X
00:91FE 855C            	   625:   sta bcd_work
00:9200 A55D            	   626:   lda bcd_work+1
00:9202 7D5E91          	   627:   adc bcd_table+2,X
00:9205 855D            	   628:   sta bcd_work+1
00:9207 A55E            	   629:   lda bcd_work+2
00:9209 7D5D91          	   630:   adc bcd_table+1,X
00:920C 855E            	   631:   sta bcd_work+2
00:920E A55F            	   632:   lda bcd_work+3
00:9210 7D5C91          	   633:   adc bcd_table,X
00:9213 855F            	   634:   sta bcd_work+3
                        	   635: 
                        	   636: binary_to_decimal_next:
00:9215 CA              	   637:   dex      ; back to the previous table item
00:9216 CA              	   638:   dex
00:9217 CA              	   639:   dex
00:9218 CA              	   640:   dex
00:9219 10D5            	   641:   bpl binary_to_decimal_loop
00:921B D8              	   642:   cld     ; decimal mode off
                        	   643: 
                        	   644: 
                        	   645: ;
                        	   646: ;  convert BCD to ASCII - note that UNPACK increments x by two each time
                        	   647: ;    - the results are in bcd_result - an 8-character field
                        	   648: ;
                        	   649: ;  We unpack the high-order bytes first, naturally
                        	   650: ;
00:921C A200            	   651:   ldx  #0
00:921E A55F            	   652:   lda  bcd_work+3
00:9220 204991          	   653:   jsr  bcd_unpack
00:9223 A55E            	   654:   lda  bcd_work+2
00:9225 204991          	   655:   jsr  bcd_unpack
00:9228 A55D            	   656:   lda  bcd_work+1
00:922A 204991          	   657:   jsr  bcd_unpack
00:922D A55C            	   658:   lda  bcd_work
00:922F 204991          	   659:   jsr  bcd_unpack
00:9232 60              	   660:   rts
                        	   661: 
00:9233 4E6F20736F757263	   662: NOSCE    asciiz  'No source file.\n'   ; No source file
00:923B 652066696C652E0A
00:9243 00
                        	   663: 
                        	   664: ;***********************************************
                        	   665: ;
                        	   666: ; Initialize a compile or assembly
                        	   667: ;
                        	   668: ;***********************************************
                        	   669: 
                        	   670: 
                        	   671: INIT     =  *
                        	   672: ;
                        	   673: ;  set up symbol table pointer
                        	   674: ;
                        	   675: 
00:9244 A93F            	   676:   lda  #>SYMBOL_TABLE_START
00:9246 8532            	   677:   sta  ENDSYM+1
00:9248 8530            	   678:   sta  STARTSYM+1
00:924A A9FF            	   679:   lda  #<SYMBOL_TABLE_START
00:924C 8531            	   680:   sta  ENDSYM
00:924E 852F            	   681:   sta  STARTSYM
                        	   682: 
                        	   683: INIT_SECOND_PASS:   ; for assembler
                        	   684: 
00:9250 A900            	   685:   lda  #0
00:9252 851D            	   686:   sta  LIST            ; not listing
00:9254 8522            	   687:   sta  LEVEL           ; variable level zero
00:9256 852E            	   688:   sta  DCODE
00:9258 853F            	   689:   sta  RUNNING         ; not running
00:925A 8539            	   690:   sta  PRCITM
00:925C 853A            	   691:   sta  PRCITM+1
00:925E 8502            	   692:   sta  REGB
00:9260 8593            	   693:   sta  token_type
00:9262 64BE            	   694:   stz  system_flags
00:9264 A901            	   695:   lda #1
00:9266 85A2            	   696:   sta  current_line        ; we are currently on line 1
00:9268 64A3            	   697:   stz  current_line+1
                        	   698: 
                        	   699: ;
                        	   700: ;  set up for reading first byte of source
                        	   701: ;
00:926A A900            	   702:   lda  #<TEXT_START
00:926C 858E            	   703:   sta  token_start
00:926E 859C            	   704:   sta  token_line_start
00:9270 A903            	   705:   lda  #>TEXT_START
00:9272 858F            	   706:   sta  token_start+1
00:9274 859D            	   707:   sta  token_line_start+1
00:9276 20D28C          	   708:   jsr  find_source_end
00:9279 A523            	   709:   lda  PCODE
00:927B 8525            	   710:   sta  ACT_PCDA
00:927D A524            	   711:   lda  PCODE+1
00:927F 8526            	   712:   sta  ACT_PCDA+1
00:9281 A000            	   713:   ldy  #0
00:9283 B18E            	   714:   lda  (token_start),y
00:9285 D00A            	   715:   bne  INIT9
00:9287 A933            	   716:   lda  #<NOSCE
00:9289 A292            	   717:   ldx  #>NOSCE
00:928B 202682          	   718:   jsr  print                      ; No source file
00:928E 4CCD82          	   719:   jmp  main_prompt
00:9291 60              	   720: INIT9    rts
                        	   721: 
                        	   722: 
                        	   723: 
                        	   724: 
                        	   725: ;
                        	   726: CROUT    =  *             ; show a newline
00:9292 A90A            	   727:   lda  #NL         ; was a carriage-return in legacy, now is newline
00:9294 4C1994          	   728:   jmp  COUT
                        	   729: ;
                        	   730: ;***********************************************
                        	   731: ; COMPARE STRING - compare SRCE to DEST, assumes DEST is upper-case
                        	   732: ;                - length in Y (therefore max 255 characters)
                        	   733: ;                - zero flag set if match (therefore do a BEQ to see if strings match)
                        	   734: ;***********************************************
                        	   735: COMSTL   =  *
00:9297 88              	   736:          dey
00:9298 300A            	   737:          bmi  COMS8
00:929A B100            	   738:          lda  (SRCE),Y
00:929C 202E90          	   739:          jsr MAKE_UPPER
00:929F D103            	   740:          cmp  (DEST),Y
00:92A1 F0F4            	   741:          beq  COMSTL
00:92A3 60              	   742: COMS9    rts             ; NOT EQUAL
00:92A4 A900            	   743: COMS8    lda  #0
00:92A6 60              	   744:          rts             ; EQUAL
                        	   745: 
                        	   746: ;***********************************************
                        	   747: ; DISPLAY A LINE
                        	   748: ;
                        	   749: 
                        	   750: ;
                        	   751: ; DISPLAY IN HEX
                        	   752: ;
00:92A7 200793          	   753: DISHX    jsr  PRBYTE
00:92AA 4C1D93          	   754:          jmp  PUTSP
                        	   755: ;
                        	   756: 
                        	   757: ;***********************************************
                        	   758: ; DISPLAY PCODE ADDRESS
                        	   759: ;***********************************************
                        	   760: DISPAD   =  *
00:92AD A52E            	   761:          lda  DCODE
00:92AF F017            	   762:          beq  DISPAD2
                        	   763: DISPAD1  =  *
00:92B1 A928            	   764:          lda  #'('
00:92B3 201994          	   765:          jsr  COUT
00:92B6 A524            	   766:          lda  PCODE+1
00:92B8 200793          	   767:          jsr  PRBYTE
00:92BB A523            	   768:          lda  PCODE
00:92BD 200793          	   769:          jsr  PRBYTE
00:92C0 A929            	   770:          lda  #')'
00:92C2 201994          	   771:          jsr  COUT
00:92C5 4C1D93          	   772:          jmp  PUTSP
00:92C8 60              	   773: DISPAD2  rts
                        	   774: ;
                        	   775: 
                        	   776: ;***********************************************
                        	   777: ; PUSH 'WORK' ONTO STACK
                        	   778: ;***********************************************
                        	   779: PSHWRK   =  *
00:92C9 8536            	   780:          sta  BSAVE
00:92CB 68              	   781:          pla
00:92CC AA              	   782:          tax
00:92CD 68              	   783:          pla
00:92CE A8              	   784:          tay
00:92CF A538            	   785:          lda  WORK+1
00:92D1 48              	   786:          pha
00:92D2 A537            	   787:          lda  WORK
00:92D4 48              	   788:          pha
00:92D5 98              	   789:          tya
00:92D6 48              	   790:          pha
00:92D7 8A              	   791:          txa
00:92D8 48              	   792:          pha
00:92D9 A536            	   793:          lda  BSAVE
00:92DB 60              	   794: PSH9     rts
                        	   795: ;
                        	   796: ;***********************************************
                        	   797: ; PULL 'WORK' FROM STACK
                        	   798: ;***********************************************
                        	   799: PULWRK   =  *
00:92DC 8536            	   800:          sta  BSAVE
00:92DE 68              	   801:          pla
00:92DF AA              	   802:          tax
00:92E0 68              	   803:          pla
00:92E1 A8              	   804:          tay
00:92E2 68              	   805:          pla
00:92E3 8537            	   806:          sta  WORK
00:92E5 68              	   807:          pla
00:92E6 8538            	   808:          sta  WORK+1
00:92E8 98              	   809:          tya
00:92E9 48              	   810:          pha
00:92EA 8A              	   811:          txa
00:92EB 48              	   812:          pha
00:92EC A536            	   813:          lda  BSAVE
00:92EE 60              	   814:          rts
                        	   815: ;
                        	   816: ;***********************************************
                        	   817: ; PRINTING SUBROUTINES
                        	   818: ; Control characters print with a ^ in front of them, eg. ^A
                        	   819: ;***********************************************
                        	   820: PRCHAR   =  *
00:92EF 48              	   821:   pha
00:92F0 C90A            	   822:   cmp #NL
00:92F2 F00E            	   823:   beq prchar_not_control
00:92F4 C920            	   824:   cmp #$20
00:92F6 B00A            	   825:   bcs prchar_not_control
00:92F8 48              	   826:   pha
00:92F9 A95E            	   827:   lda #'^'
00:92FB 201994          	   828:   jsr COUT
00:92FE 68              	   829:   pla
00:92FF 18              	   830:   clc
00:9300 6940            	   831:   adc #$40  ; make 0x01 print as ^A
                        	   832: prchar_not_control:
00:9302 201994          	   833:   jsr  COUT
00:9305 68              	   834:   pla
00:9306 60              	   835:   rts
                        	   836: ;
                        	   837: ; Prints A in hex
                        	   838: ;
                        	   839: PRBYTE:
00:9307 48              	   840:   pha
00:9308 4A              	   841:   lsr
00:9309 4A              	   842:   lsr
00:930A 4A              	   843:   lsr
00:930B 4A              	   844:   lsr
00:930C 201293          	   845:   jsr  PRHEXZ    ; first nibble
00:930F 68              	   846:   pla            ; now do other nibble
                        	   847: PRHEX:
00:9310 290F            	   848:   and  #$0F
                        	   849: PRHEXZ:
00:9312 0930            	   850:   ora  #'0'
00:9314 C93A            	   851:   cmp  #'0' + $0A
00:9316 9002            	   852:   bcc  PRHEX1
00:9318 6926            	   853:   adc  #$26  ; (carry is set: adding 7 to make 0x0a become 'a')
                        	   854: PRHEX1:
00:931A 4CEF92          	   855:   jmp  PRCHAR
                        	   856: ;
                        	   857: PUTSP    =  *
00:931D A920            	   858:   lda  #' '
00:931F 80F9            	   859:   bra  PRHEX1
                        	   860: ;
                        	   861: ;
                        	   862: ;  PT - put text
                        	   863: ;   Low-order address in A, high-order address in X, count in Y
                        	   864: ;
                        	   865: ;
                        	   866: PT:
00:9321 8503            	   867:   sta  REG2
00:9323 8604            	   868:   stx  REG2+1
00:9325 98              	   869:   tya    ; count of bytes to print
00:9326 AA              	   870:   tax    ; put that into X
00:9327 A000            	   871:   ldy  #0
                        	   872: PT6:
00:9329 B103            	   873:   lda  (REG2),Y    ; next character
00:932B 201994          	   874:   jsr COUT         ; show it
00:932E C8              	   875:   iny
00:932F CA              	   876:   dex
00:9330 D0F7            	   877:   bne  PT6
00:9332 60              	   878:   rts
                        	   879: ;
                        	   880: ;
                        	   881: ;
                        	   882: ;---- token_address --> WORK
                        	   883: ;
                        	   884: TKNWRK   =  *
00:9333 48              	   885:          PHA
00:9334 A590            	   886:          LDA  token_address
00:9336 8537            	   887:          STA  WORK
00:9338 A591            	   888:          LDA  token_address+1
00:933A 8538            	   889:          STA  WORK+1
00:933C 68              	   890:          PLA
00:933D 60              	   891:          RTS
                        	   892: ;
                        	   893: ;---- WORK --> token_address
                        	   894: ;
                        	   895: WRKTKN   =  *
00:933E 48              	   896:          PHA
00:933F A537            	   897:          LDA  WORK
00:9341 8590            	   898:          STA  token_address
00:9343 A538            	   899:          LDA  WORK+1
00:9345 8591            	   900:          STA  token_address+1
00:9347 68              	   901:          PLA
00:9348 60              	   902:          RTS
                        	   903: ;
                        	   904: 
                        	   905: 
                        	   906: ;***********************************************
                        	   907: ; MENU, FILE HANDLING
                        	   908: ;***********************************************
                        	   909: ;
00:9349 502D636F64657320	   910: pcodes_ended_message        asciiz  "P-codes ended at $"
00:9351 656E646564206174
00:9359 2024
00:935B 00
00:935C 436F6D70696C6520	   911: compile_finished_message    asciiz  "Compile finished: No errors.\n"
00:9364 66696E6973686564
00:936C 3A204E6F20657272
00:9374 6F72732E0A
00:9379 00
00:937A 53796D626F6C2074	   912: symbol_table_ended_message  asciiz "Symbol table ended at $"
00:9382 61626C6520656E64
00:938A 65642061742024
00:9391 00
00:9392 4E6F2076616C6964	   913: no_valid_compile_message    asciiz  'No valid compile or assemble done before\n'
00:939A 20636F6D70696C65
00:93A2 206F722061737365
00:93AA 6D626C6520646F6E
00:93B2 65206265666F7265
00:93BA 0A
00:93BB 00
                        	   914: ;
                        	   915: PRBYTECR =  *
00:93BC 200793          	   916:          JSR  PRBYTE
00:93BF 4C9292          	   917:          JMP  CROUT
                        	   918: ;
                        	   919: ;
                        	   920: ;
                        	   921: CHK_VAL  =  *
00:93C2 A908            	   922:          LDA  #FLAG_VALID_COMPILE
00:93C4 0910            	   923:          ORA  #FLAG_VALID_ASSEMBLE
00:93C6 25BE            	   924:          and  system_flags
00:93C8 D00A            	   925:          BNE  CHK_VAL9
00:93CA A992            	   926:          LDA  #<no_valid_compile_message    ; No valid Compile or Assemble done before
00:93CC A293            	   927:          LDX  #>no_valid_compile_message
00:93CE 202682          	   928:          JSR  print
00:93D1 4CCD82          	   929:          JMP  main_prompt
                        	   930: CHK_VAL9 =  *
                        	   931: BELL1X   =  *          ; no bell yet
00:93D4 60              	   932:          RTS
                        	   933: ;
00:93D5 20C293          	   934: CHK_RUN  JSR  CHK_VAL
00:93D8 A910            	   935:          lda  #FLAG_VALID_ASSEMBLE
00:93DA 25BE            	   936:          and  system_flags
00:93DC D003            	   937:          bne  run_assembler
00:93DE 4C5CAE          	   938:          JMP  INTERP
                        	   939: run_assembler:
00:93E1 20E793          	   940:          jsr call_assembler
00:93E4 4CF8AE          	   941:          JMP  EX_FINISHD
                        	   942: ;
                        	   943: ;  let's assume they put a RTS at the end of their code
                        	   944: ;
                        	   945: call_assembler:
00:93E7 A9EA            	   946:          LDA  #<running_message   ; Running
00:93E9 A2AD            	   947:          LDX  #>running_message
00:93EB 202682          	   948:          JSR  print
00:93EE 6C2500          	   949:          JMP (ACT_PCDA)
                        	   950: 
                        	   951: ;
                        	   952: 
                        	   953: ;
                        	   954: ; Get a line, read byte by byte until we get a newline, store in INBUF
                        	   955: ;   returns length in Y - handles backspace, ignores carriage-return
                        	   956: ;
                        	   957: GET_LINE =  *
                        	   958: GETLN1   =  *
00:93F1 A000            	   959:   ldy  #0
                        	   960: GET1:
00:93F3 200FC9          	   961:   jsr  CHRIN
00:93F6 C90D            	   962:   cmp  #CR       ; carriage-return?
00:93F8 F0F9            	   963:   beq  GET1       ; ignore it
00:93FA 990002          	   964:   sta  INBUF,Y    ; SAVE IN BUFFER
00:93FD C8              	   965:   iny
00:93FE F016            	   966:   beq  GETLN_OVERFLOW       ; overflow
00:9400 C90A            	   967:   cmp  #NL        ; END OF LINE?
00:9402 F00C            	   968:   beq  GET3       ; yes
00:9404 C908            	   969:   cmp  #BACKSPACE ; backspace?
00:9406 D0EB            	   970:   bne  GET1       ; no - keep adding to buffer
                        	   971: ;
                        	   972: ;  here for backspace
                        	   973: ;
00:9408 88              	   974:   dey  ; get rid of backspace
00:9409 88              	   975:   dey  ; get rid of character we backspaced over
00:940A C0FF            	   976:   cpy  #$FF
00:940C F0E3            	   977:   beq  GETLN1   ; if Y underflowed, go back to zero
00:940E 80E3            	   978:   bra GET1
                        	   979: 
                        	   980: GET3:
00:9410 A900            	   981:   lda  #0
00:9412 990002          	   982:   sta  INBUF,Y    ; turn newline into 0x00
00:9415 60              	   983:   rts             ; RETURN
                        	   984: ;
                        	   985: ;  here on INBUF overflow
                        	   986: ;
                        	   987: GETLN_OVERFLOW:
00:9416 88              	   988:   dey           ; get back to 255 (last byte)
00:9417 80F7            	   989:   bra  GET3     ; store a zero there
                        	   990: 
                        	   991: 
                        	   992: ;
                        	   993: ;  output a character - saves all registers
                        	   994: ;
                        	   995: COUT:
00:9419 48              	   996:   pha
00:941A DA              	   997:   phx
00:941B 5A              	   998:   phy
00:941C 202394          	   999:   jsr COUT_CALL   ; call the current outputting routine
00:941F 7A              	  1000:   ply
00:9420 FA              	  1001:   plx
00:9421 68              	  1002:   pla
00:9422 60              	  1003:   rts
                        	  1004: 
                        	  1005: 
                        	  1006: COUT_CALL:
00:9423 6C1700          	  1007:   jmp (write_function)
                        	  1008: 
                        	  1009: 

Source: "gpascal.asm"
                        	   177:   .include "errors.inc"

Source: "errors.inc"
                        	     1: 
                        	     2: errors_table:
00:9426 4D656D6F72792066	     3:   asciiz "Memory full"                               ;  1
00:942E 756C6C
00:9431 00
00:9432 436F6E7374616E74	     4:   asciiz "Constant expected"                         ;  2
00:943A 2065787065637465
00:9442 64
00:9443 00
00:9444 3D20657870656374	     5:   asciiz "= expected"                                ;  3
00:944C 6564
00:944E 00
00:944F 4964656E74696669	     6:   asciiz "Identifier expected"                       ;  4
00:9457 6572206578706563
00:945F 746564
00:9462 00
00:9463 2C206F72203A2065	     7:   asciiz ", or : expected"                           ;  5
00:946B 78706563746564
00:9472 00
00:9473 427567          	     8:   asciiz "Bug"                                       ;  6
00:9476 00
00:9477 2A29206F72207D20	     9:   asciiz "*) or } expected"                          ;  7
00:947F 6578706563746564
00:9487 00
00:9488 496E636F72726563	    10:   asciiz "Incorrect string"                          ;  8
00:9490 7420737472696E67
00:9498 00
00:9499 2E20657870656374	    11:   asciiz ". expected"                                ;  9
00:94A1 6564
00:94A3 00
00:94A4 3B20657870656374	    12:   asciiz "; expected"                                ; 10
00:94AC 6564
00:94AE 00
00:94AF 556E6465636C6172	    13:   asciiz "Undeclared identifier"                     ; 11
00:94B7 6564206964656E74
00:94BF 6966696572
00:94C4 00
00:94C5 496C6C6567616C20	    14:   asciiz "Illegal identifier"                        ; 12
00:94CD 6964656E74696669
00:94D5 6572
00:94D7 00
00:94D8 3A3D206578706563	    15:   asciiz ":= expected"                               ; 13
00:94E0 746564
00:94E3 00
00:94E4 4C69746572616C20	    16:   asciiz "Literal string of zero length"             ; 14
00:94EC 737472696E67206F
00:94F4 66207A65726F206C
00:94FC 656E677468
00:9501 00
00:9502 436F6D70696C6572	    17:   asciiz "Compiler limits exceeded"                  ; 15
00:950A 206C696D69747320
00:9512 6578636565646564
00:951A 00
00:951B 5448454E20657870	    18:   asciiz "THEN expected"                             ; 16
00:9523 6563746564
00:9528 00
00:9529 3B206F7220454E44	    19:   asciiz "; or END expected"                         ; 17
00:9531 2065787065637465
00:9539 64
00:953A 00
00:953B 444F206578706563	    20:   asciiz "DO expected"                               ; 18
00:9543 746564
00:9546 00
00:9547 496E636F72726563	    21:   asciiz "Incorrect symbol"                          ; 19
00:954F 742073796D626F6C
00:9557 00
00:9558 427567          	    22:   asciiz "Bug"                                       ; 20
00:955B 00
00:955C 557365206F662070	    23:   asciiz "Use of procedure identifier in expression" ; 21
00:9564 726F636564757265
00:956C 206964656E746966
00:9574 69657220696E2065
00:957C 787072657373696F
00:9584 6E
00:9585 00
00:9586 2920657870656374	    24:   asciiz ") expected"                                ; 22
00:958E 6564
00:9590 00
00:9591 496C6C6567616C20	    25:   asciiz "Illegal factor"                            ; 23
00:9599 666163746F72
00:959F 00
00:95A0 54797065206D6973	    26:   asciiz "Type mismatch"                             ; 24
00:95A8 6D61746368
00:95AD 00
00:95AE 424547494E206578	    27:   asciiz "BEGIN expected"                            ; 25
00:95B6 706563746564
00:95BC 00
00:95BD 4F46206578706563	    28:   asciiz "OF expected"                               ; 26
00:95C5 746564
00:95C8 00
00:95C9 537461636B206675	    29:   asciiz "Stack full"                                ; 27
00:95D1 6C6C
00:95D3 00
00:95D4 544F206F7220444F	    30:   asciiz "TO or DOWNTO expected"                     ; 28
00:95DC 574E544F20657870
00:95E4 6563746564
00:95E9 00
00:95EA 537472696E67206C	    31:   asciiz "String literal too big"                    ; 29
00:95F2 69746572616C2074
00:95FA 6F6F20626967
00:9600 00
00:9601 4E756D626572206F	    32:   asciiz "Number out of range"                       ; 30
00:9609 7574206F66207261
00:9611 6E6765
00:9614 00
00:9615 2820657870656374	    33:   asciiz "( expected"                                ; 31
00:961D 6564
00:961F 00
00:9620 2C20657870656374	    34:   asciiz ", expected"                                ; 32
00:9628 6564
00:962A 00
00:962B 5B20657870656374	    35:   asciiz "[ expected"                                ; 33
00:9633 6564
00:9635 00
00:9636 5D20657870656374	    36:   asciiz "] expected"                                ; 34
00:963E 6564
00:9640 00
00:9641 506172616D657465	    37:   asciiz "Parameters mismatched"                     ; 35
00:9649 7273206D69736D61
00:9651 7463686564
00:9656 00
00:9657 4461746120747970	    38:   asciiz "Data type not recognised"                  ; 36
00:965F 65206E6F74207265
00:9667 636F676E69736564
00:966F 00
00:9670 53796D626F6C2074	    39:   asciiz "Symbol table full"                         ; 37
00:9678 61626C652066756C
00:9680 6C
00:9681 00
00:9682 4475706C69636174	    40:   asciiz "Duplicate identifier"                      ; 38
00:968A 65206964656E7469
00:9692 66696572
00:9696 00
00:9697 56616C7565206578	    41:   asciiz "Value expected"                            ; 39
00:969F 706563746564
00:96A5 00
00:96A6 496C6C6567616C20	    42:   asciiz "Illegal opcode"                            ; 40
00:96AE 6F70636F6465
00:96B4 00
00:96B5 496C6C6567616C20	    43:   asciiz "Illegal addressing mode"                   ; 41
00:96BD 6164647265737369
00:96C5 6E67206D6F6465
00:96CC 00
00:96CD 4272616E6368206F	    44:   asciiz "Branch out of range"                       ; 42
00:96D5 7574206F66207261
00:96DD 6E6765
00:96E0 00
00:96E1 4E656564207A6572	    45:   asciiz "Need zero page address"                    ; 43
00:96E9 6F20706167652061
00:96F1 646472657373
00:96F7 00
00:96F8 4F706572616E6420	    46:   asciiz "Operand too large"                         ; 44
00:9700 746F6F206C617267
00:9708 65
00:9709 00
00:970A 53796D626F6C2061	    47:   asciiz "Symbol address changed"                    ; 45
00:9712 6464726573732063
00:971A 68616E676564
00:9720 00
00:9721 4578707265737369	    48:   asciiz "Expression too complex"                    ; 46
00:9729 6F6E20746F6F2063
00:9731 6F6D706C6578
00:9737 00
00:9738 4469766964652062	    49:   asciiz "Divide by zero"                            ; 47
00:9740 79207A65726F
00:9746 00
00:9747 4C6162656C207265	    50:   asciiz "Label required"                            ; 48
00:974F 717569726564
00:9755 00
00:9756 53796D626F6C2074	    51:   asciiz "Symbol table in use"                       ; 49
00:975E 61626C6520696E20
00:9766 757365
00:9769 00
00:976A 4E6F204C4344    	    52:   asciiz "No LCD"                                    ; 50
00:9770 00
00:9771 436F646520616C72	    53:   asciiz "Code already generated"                    ; 51
00:9779 656164792067656E
00:9781 657261746564
00:9787 00
                        	    54: assertion_failed_message:   ; used by Pascal assert function
00:9788 417373657274696F	    55:   asciiz "Assertion failed"                          ; 52
00:9790 6E206661696C6564
00:9798 00
00:9799 557365206F662066	    56:   asciiz "Use of function identifier in statement"   ; 53
00:97A1 756E6374696F6E20
00:97A9 6964656E74696669
00:97B1 657220696E207374
00:97B9 6174656D656E74
00:97C0 00
00:97C1 00              	    57:   dfb 0
                        	    58: 
                        	    59: ;***********************************************
                        	    60: ; DISPLAY ERROR - this does not return to the caller
                        	    61: ;  but to main_prompt
                        	    62: ;  Error number in X
                        	    63: ;***********************************************
00:97C2 2A2A2A204572726F	    64: ERRLIT   asciiz  '*** Error: '
00:97CA 723A20
00:97CD 00
                        	    65: 
00:97CE 8635            	    66: ERROR    stx  ERRNO
00:97D0 A53F            	    67:          lda  RUNNING
00:97D2 F003            	    68:          beq  ERR7
00:97D4 4C0B98          	    69:          jmp  ERR6
                        	    70: ERR7     =  *
00:97D7 A51D            	    71:          lda  LIST
00:97D9 D006            	    72:          bne  ERR1
00:97DB 209292          	    73:          jsr  CROUT
00:97DE 206398          	    74:          jsr  show_current_line
                        	    75: ERR1     =  *
00:97E1 A590            	    76:          lda  token_address
00:97E3 38              	    77:          sec
00:97E4 E59C            	    78:          sbc  token_line_start  ; TODO: what about high-order byte?
00:97E6 48              	    79:          pha             ; CHARS UP TO ERROR POINT
00:97E7 A9C2            	    80:          lda  #<ERRLIT   ; *** Error
00:97E9 A297            	    81:          ldx  #>ERRLIT
00:97EB 202682          	    82:          jsr  print
00:97EE 68              	    83:          pla
00:97EF 18              	    84:          clc
00:97F0 6901            	    85:          adc   #1
00:97F2 8545            	    86:          sta  TEMP       ; BYTES TO ERROR POINT
00:97F4 AA              	    87:          tax
                        	    88: ERR3     =  *
00:97F5 201D93          	    89:          jsr  PUTSP
00:97F8 CA              	    90:          dex
00:97F9 D0FA            	    91:          bne  ERR3
00:97FB A95E            	    92:          lda  #'^'
00:97FD 201994          	    93:          jsr  COUT
00:9800 209292          	    94:          jsr  CROUT
00:9803 A209            	    95:          ldx  #9
                        	    96: ERR5     =  *
00:9805 201D93          	    97:          jsr  PUTSP
00:9808 CA              	    98:          dex
00:9809 D0FA            	    99:          bne  ERR5
                        	   100: ERR6     =  *
00:980B A926            	   101:   lda #<errors_table
00:980D 8500            	   102:   sta REG
00:980F A994            	   103:   lda #>errors_table
00:9811 8501            	   104:   sta REG+1
00:9813 A200            	   105:   ldx #0
00:9815 A000            	   106:   ldy #0
                        	   107: error_next:
00:9817 E8              	   108:   inx
                        	   109: error_loop:
00:9818 E435            	   110:   cpx ERRNO
00:981A F02A            	   111:   beq error_found
                        	   112: error_find_next:
00:981C B100            	   113:   lda (REG),Y
00:981E 48              	   114:   pha
00:981F E600            	   115:   inc REG
00:9821 D002            	   116:   bne error1
00:9823 E601            	   117:   inc REG+1
                        	   118: error1:
00:9825 68              	   119:   pla           ; get the previous byte
00:9826 D0F4            	   120:   bne error_find_next
00:9828 B100            	   121:   lda (REG),Y   ; a null after a null?
00:982A F002            	   122:   beq error_not_found
00:982C 80E9            	   123:   bra error_next  ; we got a null, so add 1 to our current error number (X)
                        	   124: 
                        	   125: error_not_found:
00:982E A953            	   126:   lda #<error_not_found_message
00:9830 A298            	   127:   ldx #>error_not_found_message
00:9832 202682          	   128:   jsr print
00:9835 A535            	   129:   lda ERRNO
00:9837 8500            	   130:   sta REG
00:9839 6401            	   131:   stz REG+1
00:983B 6402            	   132:   stz REGB
00:983D 20BC91          	   133:   jsr display_in_decimal
00:9840 209292          	   134:   jsr CROUT
00:9843 4CCD82          	   135:   jmp main_prompt
                        	   136: 
                        	   137: error_found:
00:9846 A500            	   138:   lda REG
00:9848 A601            	   139:   ldx REG+1
00:984A 202682          	   140:   jsr print
00:984D 209292          	   141:   jsr CROUT
00:9850 4CCD82          	   142:   jmp  main_prompt
                        	   143: 
00:9853 556E6B6E6F776E20	   144: error_not_found_message asciiz "Unknown error: "
00:985B 6572726F723A20
00:9862 00
                        	   145: 
                        	   146: show_current_line:
00:9863 A928            	   147:   lda #'('
00:9865 201994          	   148:   jsr COUT
00:9868 A524            	   149:   lda PCODE+1
00:986A 200793          	   150:   jsr PRBYTE
00:986D A523            	   151:   lda PCODE
00:986F 200793          	   152:   jsr PRBYTE
00:9872 A929            	   153:   lda #')'
00:9874 201994          	   154:   jsr COUT
00:9877 201D93          	   155:   jsr PUTSP
00:987A 20608C          	   156:   jsr show_current_line_number
00:987D A59C            	   157:   lda token_line_start
00:987F 85A6            	   158:   sta mem_move_src
00:9881 A59D            	   159:   lda token_line_start+1
00:9883 85A7            	   160:   sta mem_move_src+1
                        	   161: 
                        	   162: show_current_line_loop:
00:9885 A000            	   163:   ldy #0
00:9887 B1A6            	   164:   lda (mem_move_src),Y
00:9889 F01D            	   165:   beq show_current_line_done
00:988B C90A            	   166:   cmp #NL
00:988D F019            	   167:   beq show_current_line_done
00:988F C920            	   168:   cmp #$20
00:9891 B00A            	   169:   bcs show_current_line_loop_print_one_character
00:9893 48              	   170:   pha
00:9894 A95E            	   171:   lda #'^'
00:9896 201994          	   172:   jsr COUT
00:9899 68              	   173:   pla
00:989A 18              	   174:   clc
00:989B 6940            	   175:   adc #$40  ; make 0x01 print as ^A
                        	   176: show_current_line_loop_print_one_character:
00:989D 201994          	   177:   jsr COUT    ; show that byte
00:98A0 E6A6            	   178:   inc mem_move_src
00:98A2 D0E1            	   179:   bne show_current_line_loop
00:98A4 E6A7            	   180:   inc mem_move_src+1
00:98A6 80DD            	   181:   bra show_current_line_loop
                        	   182: 
                        	   183: show_current_line_done:
00:98A8 209292          	   184:   jsr CROUT
00:98AB 60              	   185:   rts
                        	   186: 

Source: "gpascal.asm"
                        	   178:   .include "assembler.inc"

Source: "assembler.inc"
                        	     1: ;***********************************************
                        	     2: ;
                        	     3: ; Assembler
                        	     4: ;
                        	     5: ;***********************************************
                        	     6: 
                        	     7: ;***********************************************
                        	     8: ; Assembler operand types
                        	     9: ;***********************************************
                        	    10: 
                        	    11: ASS_OPERAND_ABSOLUTE                           =  1      ; a
                        	    12: ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT          =  2      ; (a,x)
                        	    13: ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X            =  3      ; a,x
                        	    14: ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y            =  4      ; a,y
                        	    15: ASS_OPERAND_ABSOLUTE_INDIRECT                  =  5      ; (a)
                        	    16: ASS_OPERAND_ACCUMULATOR_A                      =  6      ; A
                        	    17: ASS_OPERAND_IMMEDIATE                          =  7      ; #
                        	    18: ASS_OPERAND_IMPLIED                            =  8      ; i
                        	    19: ASS_OPERAND_PROGRAM_COUNTER_RELATIVE           =  9      ; r
                        	    20: ASS_OPERAND_STACK                              = 10      ; s
                        	    21: ASS_OPERAND_ZERO_PAGE                          = 11      ; zp
                        	    22: ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT         = 12      ; (zp,x)
                        	    23: ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X           = 13      ; zp,x
                        	    24: ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y           = 14      ; zp,y
                        	    25: ASS_OPERAND_ZERO_PAGE_INDIRECT                 = 15      ; (zp)
                        	    26: ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y  = 16      ; (zp),y
                        	    27: ASS_OPERAND_STRING                             = 17      ; "But does it get goat's blood out?"
                        	    28: ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE             = 18      ; zp,r
                        	    29: 
                        	    30: ;
                        	    31: ;  Entry point for assembler
                        	    32: ;
                        	    33: ASSEMBLE:
                        	    34: 
00:98AC A2FF            	    35:    ldx  #NEW_STK
00:98AE 9A              	    36:    txs    ; set stack back to 0xFF
00:98AF 6476            	    37:    stz  ASS_PASS  ; first pass
00:98B1 204492          	    38:    jsr  INIT       ; sets up pointers, calls LINE
00:98B4 208AAA          	    39:    jsr  add_assembler_library_functions  ; add our inbuilt functions to the symbol table
00:98B7 8005            	    40:    bra  ASSEMBLE_PASS
                        	    41: 
                        	    42: ASSEMBLE_SECOND_PASS:
00:98B9 E676            	    43:    inc  ASS_PASS
00:98BB 205092          	    44:    jsr  INIT_SECOND_PASS    ; don't re-initialise the symbol table
                        	    45: ASSEMBLE_PASS:
00:98BE 64A2            	    46:    stz  current_line  ; we'll got for zero, not one
                        	    47: 
00:98C0 A902            	    48:    lda  #FLAG_ASSEMBLING
00:98C2 04BE            	    49:    tsb  system_flags
                        	    50: 
                        	    51: ;
                        	    52: ;  no listing yet
                        	    53: ;
00:98C4 642E            	    54:    stz  DCODE
00:98C6 641D            	    55:    stz  LIST
00:98C8 6442            	    56:    stz  SYNTAX
00:98CA 6482            	    57:    stz  show_symbols
                        	    58: ;
                        	    59: ; zero line count
                        	    60: ;
00:98CC 6419            	    61:    stz  LINE_CNT
00:98CE 641A            	    62:    stz  LINE_CNT+1
                        	    63: 
                        	    64: ;
                        	    65: ;  and emitted bytes count
                        	    66: ;
00:98D0 6477            	    67:    stz ass_emit_bytes
00:98D2 6478            	    68:    stz ass_emit_bytes+1
                        	    69: 
                        	    70: ;
                        	    71: ; no previous token
                        	    72: ;
00:98D4 6493            	    73:    stz  token_type
00:98D6 800E            	    74:    bra ass_line
                        	    75: 
                        	    76: ass_finish_line:
00:98D8 A593            	    77:    lda token_type
00:98DA C90A            	    78:    cmp #NL
00:98DC F008            	    79:    beq ass_line
00:98DE A213            	    80:    ldx #19    ; Incorrect Symbol
00:98E0 4C0E9F          	    81:    jmp ass_error
                        	    82: 
                        	    83: ass_done_jump:
00:98E3 4CE19B          	    84:    jmp ass_done
                        	    85: ;
                        	    86: ;  here for the start of a line
                        	    87: ;
                        	    88: ass_line:
00:98E6 A576            	    89:   lda ASS_PASS    ; only showing codes on 2nd pass
00:98E8 F00B            	    90:   beq ass_line1
00:98EA A56F            	    91:   lda ASS_EMIT_COUNT  ; only need a newline if we actually output a code
00:98EC F007            	    92:   beq ass_line1
00:98EE A52E            	    93:   lda DCODE           ; is showing codes on?
00:98F0 F003            	    94:   beq ass_line1
00:98F2 209292          	    95:   jsr CROUT
                        	    96: ass_line1:
00:98F5 A000            	    97:   ldy #0
00:98F7 B18E            	    98:   lda (token_start),y ; quick test so we don't list a non-existent line
00:98F9 F0E8            	    99:   beq ass_done_jump
                        	   100: 
00:98FB A58E            	   101:   lda token_start
00:98FD 859C            	   102:   sta token_line_start
00:98FF A58F            	   103:   lda token_start+1
00:9901 859D            	   104:   sta token_line_start+1
00:9903 202DCA          	   105:   jsr token_line        ; list the next line
                        	   106: 
00:9906 646B            	   107:   stz ASS_OPERAND   ; no operand yet
00:9908 646F            	   108:   stz ASS_EMIT_COUNT
00:990A 6483            	   109:   stz ass_current_label
00:990C 6484            	   110:   stz ass_current_label+1
                        	   111: 
00:990E 208DC9          	   112:   jsr get_token
                        	   113: 
00:9911 C949            	   114:   cmp #TOKEN_IDENTIFIER  ; could be a label if in column 1
00:9913 F011            	   115:   beq ass_identifier
00:9915 C93D            	   116:   cmp #'='               ; = directive is OK
00:9917 F00D            	   117:   beq ass_identifier
                        	   118: 
00:9919 C90A            	   119:   cmp #NL
00:991B F0C9            	   120:   beq ass_line
                        	   121: 
00:991D C900            	   122:   cmp #0
00:991F F0C2            	   123:   beq ass_done_jump
                        	   124: 
                        	   125: ass_bad_identifier:
00:9921 A204            	   126:   ldx #4      ; Identifier expected
00:9923 4C0E9F          	   127:   JMP ass_error
                        	   128: 
                        	   129: ass_identifier:
                        	   130: 
                        	   131: ;
                        	   132: ;  if the identifier is at the start of the line, it is a label, not an opcode
                        	   133: ;
00:9926 A590            	   134:   lda token_address
00:9928 C59C            	   135:   cmp token_line_start
00:992A D063            	   136:   bne ass_opcode
00:992C A591            	   137:   lda token_address+1
00:992E C59D            	   138:   cmp token_line_start+1
00:9930 D05D            	   139:   bne ass_opcode
                        	   140: 
00:9932 A593            	   141:   lda token_type         ; can't have = as an identifier
00:9934 C93D            	   142:   cmp #'='               ; or "="
00:9936 F0E9            	   143:   beq ass_bad_identifier
                        	   144: 
                        	   145: ;
                        	   146: ;  here for label - on the first pass, add it to the symbol table, on the second pass look it up
                        	   147: ;
00:9938 A576            	   148:   lda ASS_PASS
00:993A D014            	   149:   bne ass_lookup_existing_label
                        	   150: ;
                        	   151: ;  here for first pass
                        	   152: ;
00:993C 2036BA          	   153:   jsr CHKDUP
                        	   154: ;
                        	   155: ; not a duplicate - add it
                        	   156: ;
00:993F A523            	   157:   lda PCODE
00:9941 8594            	   158:   sta token_value
00:9943 A524            	   159:   lda PCODE+1
00:9945 8595            	   160:   sta token_value+1
00:9947 6496            	   161:   stz token_value+2
00:9949 A943            	   162:   lda #SYMBOL_CONSTANT
00:994B 208FB9          	   163:   jsr ADDSYM
00:994E 8016            	   164:   bra ass_added_symbol
                        	   165: 
                        	   166: ;
                        	   167: ;  here for second pass
                        	   168: ;
                        	   169: ass_lookup_existing_label:
00:9950 2013B9          	   170:   jsr SEARCH  ; look it up
00:9953 D005            	   171:   bne ass_lookup_save_address  ; it should be!
00:9955 A206            	   172:   ldx #6  ; ERROR: bug
00:9957 4C0E9F          	   173:   jmp ass_error
                        	   174: 
                        	   175: ass_lookup_save_address:
00:995A A594            	   176:   lda token_value
00:995C 8573            	   177:   sta ASS_VALUE
00:995E A595            	   178:   lda token_value+1
00:9960 8574            	   179:   sta ASS_VALUE+1
00:9962 A596            	   180:   lda token_value+2
00:9964 8575            	   181:   sta ASS_VALUE+2
                        	   182: 
                        	   183: ;
                        	   184: ;  the symbol has either been added, or looked up to make sure it is still there
                        	   185: ;
                        	   186: ass_added_symbol:
                        	   187: 
                        	   188: ;
                        	   189: ;  remember its address in case we have an EQU directive
                        	   190: ;
00:9966 A540            	   191:   lda SYMITM
00:9968 8583            	   192:   sta ass_current_label
00:996A A541            	   193:   lda SYMITM+1
00:996C 8584            	   194:   sta ass_current_label+1
                        	   195: 
                        	   196: ;
                        	   197: ;  get whatever is after the label
                        	   198: ;
00:996E 208DC9          	   199:   jsr get_token
00:9971 C93A            	   200:   cmp #':'
00:9973 D003            	   201:   bne ass_not_colon
00:9975 208DC9          	   202:   jsr get_token  ; skip the colon
                        	   203: ass_not_colon:
00:9978 C90A            	   204:   cmp #NL     ; newline means this is just a label line
00:997A D003            	   205:   bne ass_not_colon2
00:997C 4CD898          	   206:   jmp ass_finish_line
                        	   207: 
                        	   208: ass_not_colon2:
00:997F C949            	   209:   cmp #TOKEN_IDENTIFIER  ; should be an opcode now
00:9981 F00C            	   210:   beq ass_opcode
00:9983 C93D            	   211:   cmp #'='               ; = directive is OK
00:9985 F008            	   212:   beq ass_opcode
                        	   213: 
                        	   214: ass_illegal_opcode:
00:9987 200793          	   215:   jsr PRBYTE
00:998A A228            	   216:   ldx #40      ; ERROR: illegal opcode
00:998C 4C0E9F          	   217:   JMP ass_error
                        	   218: 
                        	   219: ass_opcode:
                        	   220: 
                        	   221: ;
                        	   222: ;  this will be our assembler mnemonic or directive so save its start point and length
                        	   223: ;
                        	   224: 
00:998F A690            	   225:   ldx token_address
00:9991 866C            	   226:   stx OPCODE
00:9993 A691            	   227:   ldx token_address+1
00:9995 866D            	   228:   stx OPCODE+1
00:9997 A692            	   229:   ldx token_length
00:9999 866E            	   230:   stx OPCODE_LEN
                        	   231: 
                        	   232: ;
                        	   233: ;  if we had a label on the line, check its address hasn't changed (on the second pass)
                        	   234: ;   UNLESS it is an EQU directive in which case it probably did change
                        	   235: ;
00:999B A576            	   236:   lda ASS_PASS
00:999D F046            	   237:   beq ass_opcode2
00:999F A583            	   238:   lda ass_current_label
00:99A1 0584            	   239:   ora ass_current_label+1   ; was there a label?
00:99A3 F040            	   240:   beq ass_opcode2    ; nope
00:99A5 A593            	   241:   lda token_type
00:99A7 C93D            	   242:   cmp #'='
00:99A9 F03A            	   243:   beq ass_opcode2   ; don't check on "=" directive
00:99AB A592            	   244:   lda token_length
00:99AD C903            	   245:   cmp #3
00:99AF D034            	   246:   bne ass_opcode2   ; can't be EQU
                        	   247: ;
                        	   248: ; this is truly crap, but I am feeling lazy
                        	   249: ;
00:99B1 A000            	   250:   ldy #0
00:99B3 B190            	   251:   lda (token_address),y
00:99B5 202E90          	   252:   jsr MAKE_UPPER
00:99B8 C945            	   253:   cmp #'E'
00:99BA D014            	   254:   bne ass_check_label_changed
00:99BC C8              	   255:   iny
00:99BD B190            	   256:   lda (token_address),y
00:99BF 202E90          	   257:   jsr MAKE_UPPER
00:99C2 C951            	   258:   cmp #'Q'
00:99C4 D00A            	   259:   bne ass_check_label_changed
00:99C6 C8              	   260:   iny
00:99C7 B190            	   261:   lda (token_address),y
00:99C9 202E90          	   262:   jsr MAKE_UPPER
00:99CC C955            	   263:   cmp #'U'
00:99CE F015            	   264:   beq ass_opcode2
                        	   265: 
                        	   266: ;
                        	   267: ;  we looked up the label earlier, when it was the current token,
                        	   268: ;   and we saved its value in ASS_VALUE
                        	   269: ;
                        	   270: 
                        	   271: ass_check_label_changed:
00:99D0 A523            	   272:   lda PCODE
00:99D2 C573            	   273:   cmp ASS_VALUE
00:99D4 D00A            	   274:   bne ass_symbol_address_changed
00:99D6 A524            	   275:   lda PCODE+1
00:99D8 C574            	   276:   cmp ASS_VALUE+1
00:99DA D004            	   277:   bne ass_symbol_address_changed
00:99DC A575            	   278:   lda ASS_VALUE+2   ; 3rd byte should be zero
00:99DE F005            	   279:   beq ass_opcode2
                        	   280: 
                        	   281: ass_symbol_address_changed:
00:99E0 A22D            	   282:   ldx #45     ; ERROR: Symbol address changed
00:99E2 4C0E9F          	   283:   jmp ass_error
                        	   284: 
                        	   285: 
                        	   286: 
                        	   287: ass_opcode2:
                        	   288: ;
                        	   289: ;  look up operand
                        	   290: ;
                        	   291: 
00:99E5 208DC9          	   292:   jsr get_token
00:99E8 C90A            	   293:   cmp #NL           ; or end of line?
00:99EA D00D            	   294:   bne ass_operand
                        	   295: 
                        	   296: ;
                        	   297: ;  here when the opcode is followed by (spaces) or a newline
                        	   298: ;
00:99EC A908            	   299:   lda #ASS_OPERAND_IMPLIED
00:99EE 856B            	   300:   sta ASS_OPERAND
00:99F0 20389B          	   301:   jsr opcode_lookup
00:99F3 20249C          	   302:   jsr ass_check_no_more_tokens
                        	   303: ass_finish_lineJ:
00:99F6 4CD898          	   304:   jmp ass_finish_line
                        	   305: 
                        	   306: ass_operand:
00:99F9 C923            	   307:   cmp #'#'  ; immediate?
00:99FB F01B            	   308:   beq ass_immediate
00:99FD C928            	   309:   cmp #'('  ; indirect?
00:99FF F02A            	   310:   beq ass_indirect
00:9A01 C949            	   311:   cmp #TOKEN_IDENTIFIER
00:9A03 F02F            	   312:   beq ass_identifier_operand
00:9A05 C922            	   313:   cmp #TOKEN_STRING
00:9A07 F002            	   314:   beq ass_string
                        	   315: ;
                        	   316: ;  here for some kind of numeric address
                        	   317: ;
00:9A09 804A            	   318:   bra ass_operand_value
                        	   319: 
                        	   320: ;
                        	   321: ;  Here for a string as an operand, should be a compiler directive, eg.  ASC "Hello, world"
                        	   322: ;
                        	   323: ass_string:
00:9A0B A911            	   324:   lda #ASS_OPERAND_STRING
00:9A0D 856B            	   325:   sta ASS_OPERAND
00:9A0F 20389B          	   326:   jsr opcode_lookup
00:9A12 208DC9          	   327:   jsr get_token  ; NOW get the next token
00:9A15 4CD898          	   328:   jmp ass_finish_line
                        	   329: 
                        	   330: ;
                        	   331: ;  immediate, that is:  #<expression>
                        	   332: ;
                        	   333: ass_immediate:
00:9A18 A907            	   334:   lda #ASS_OPERAND_IMMEDIATE
00:9A1A 856B            	   335:   sta ASS_OPERAND
00:9A1C 208DC9          	   336:   jsr get_token
00:9A1F 203B9D          	   337:   jsr ass_get_value
00:9A22 20249C          	   338:   jsr ass_check_no_more_tokens
00:9A25 20389B          	   339:   jsr opcode_lookup
00:9A28 4CD898          	   340:   jmp ass_finish_line
                        	   341: 
                        	   342: ;
                        	   343: ;  indirect, that is: (expression) OR (expression,X) OR (expression),Y
                        	   344: ;
                        	   345: ass_indirect:
00:9A2B A905            	   346:   lda #ASS_OPERAND_ABSOLUTE_INDIRECT  ; first guess
00:9A2D 856B            	   347:   sta ASS_OPERAND
00:9A2F 208DC9          	   348:   jsr get_token    ; skip the bracket
00:9A32 8021            	   349:   bra ass_operand_value
                        	   350: 
                        	   351: ;
                        	   352: ;  some sort of identifier, possibly the start of an expression or maybe just "A"
                        	   353: ;
                        	   354: ass_identifier_operand:
                        	   355: 
                        	   356: ;
                        	   357: ;  see if the operand is just the letter "A"
                        	   358: ;
00:9A34 A592            	   359:   lda token_length
00:9A36 C901            	   360:   cmp #1
00:9A38 D01B            	   361:   bne ass_operand_value
00:9A3A A000            	   362:   ldy #0
00:9A3C B190            	   363:   lda (token_address),Y
00:9A3E 202E90          	   364:   jsr MAKE_UPPER
00:9A41 C941            	   365:   cmp #'A'
00:9A43 D010            	   366:   bne ass_operand_value
00:9A45 A906            	   367:   lda #ASS_OPERAND_ACCUMULATOR_A
00:9A47 856B            	   368:   sta ASS_OPERAND
00:9A49 208DC9          	   369:   jsr get_token  ; skip past A
00:9A4C 20249C          	   370:   jsr ass_check_no_more_tokens
00:9A4F 20389B          	   371:   jsr opcode_lookup
00:9A52 4CD898          	   372:   jmp ass_finish_line
                        	   373: 
                        	   374: ;
                        	   375: ;  a number or identifier - evaluate as an expression
                        	   376: ;
                        	   377: ass_operand_value:
                        	   378: 
00:9A55 A593            	   379:   lda token_type ; get token back
00:9A57 203B9D          	   380:   jsr ass_get_value  ; should have some sort of address now in VALUE
                        	   381: ;
                        	   382: ;  we come back with the first non-value token loaded in TOKEN
                        	   383: ;  now see if we originally had a bracket, so this must be one of those indirect things
                        	   384: ;
00:9A5A A56B            	   385:   lda ASS_OPERAND
00:9A5C C905            	   386:   cmp #ASS_OPERAND_ABSOLUTE_INDIRECT
00:9A5E D02D            	   387:   bne ass_value_not_indirectJ
00:9A60 A593            	   388:   lda token_type   ; now we should have a comma or a bracket
00:9A62 C929            	   389:   cmp #')'
00:9A64 F02F            	   390:   beq ass_indirect_with_bracket
                        	   391: ;
                        	   392: ;  We had an opening bracket but not a closing bracket. Must be a comma then
                        	   393: ;
                        	   394: 
00:9A66 A92C            	   395:   lda #','
00:9A68 A220            	   396:   ldx #32  ; ERROR: , expected
00:9A6A 209FCF          	   397:   jsr CHKTKN
                        	   398: ;
                        	   399: ;  now we must have X
                        	   400: ;
00:9A6D 20D19A          	   401:   jsr ass_check_we_have_x_or_y
00:9A70 901E            	   402:   bcc ass_bad_indirect
00:9A72 C958            	   403:   cmp #'X'
00:9A74 D01A            	   404:   bne ass_bad_indirect
00:9A76 A902            	   405:   lda #ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
00:9A78 856B            	   406:   sta ASS_OPERAND
00:9A7A A929            	   407:   lda #')'
00:9A7C A216            	   408:   ldx #22  ; ERROR: ) expected
00:9A7E 208FCF          	   409:   jsr GETCHK
00:9A81 208DC9          	   410:   jsr get_token
00:9A84 20249C          	   411:   jsr ass_check_no_more_tokens
00:9A87 20389B          	   412:   jsr opcode_lookup
00:9A8A 4CD898          	   413:   jmp ass_finish_line
                        	   414: 
00:9A8D 4CEF9A          	   415: ass_value_not_indirectJ jmp ass_value_not_indirect
                        	   416: 
                        	   417: ass_bad_indirect:
00:9A90 A229            	   418:   ldx #41  ; ERROR: illegal addressing mode
00:9A92 4C0E9F          	   419:   jmp ass_error
                        	   420: 
                        	   421: 
                        	   422: ;
                        	   423: ;  we have some sort of indirect expression followed by a bracket, so see if there is ",Y" after it
                        	   424: ;
                        	   425: ass_indirect_with_bracket:
                        	   426: ;
                        	   427: ;  can only be (a), (zp) or (zp),y
                        	   428: ;
00:9A95 208DC9          	   429:   jsr get_token
00:9A98 C92C            	   430:   cmp #','
00:9A9A F00D            	   431:   beq ass_zp_indirect_indexed
00:9A9C 20249C          	   432:   jsr ass_check_no_more_tokens
00:9A9F A905            	   433:   lda #ASS_OPERAND_ABSOLUTE_INDIRECT
00:9AA1 856B            	   434:   sta ASS_OPERAND
00:9AA3 20389B          	   435:   jsr opcode_lookup
00:9AA6 4CD898          	   436:   jmp ass_finish_line
                        	   437: 
                        	   438: 
                        	   439: ;
                        	   440: ;  For indirect followed by a comma, we must have Y and nothing else
                        	   441: ;  Also, the operand must be a zero-page address
                        	   442: ;
                        	   443: ass_zp_indirect_indexed:
00:9AA9 20D19A          	   444:   jsr ass_check_we_have_x_or_y
00:9AAC 90E2            	   445:   bcc ass_bad_indirect
00:9AAE C959            	   446:   cmp #'Y'
00:9AB0 D0DE            	   447:   bne ass_bad_indirect
00:9AB2 A574            	   448:   lda ASS_VALUE+1
00:9AB4 D014            	   449:   bne ass_bad_zp_indirect_indexed
00:9AB6 A575            	   450:   lda ASS_VALUE+2
00:9AB8 D010            	   451:   bne ass_bad_zp_indirect_indexed
00:9ABA A910            	   452:   lda #ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
00:9ABC 856B            	   453:   sta ASS_OPERAND
00:9ABE 208DC9          	   454:   jsr get_token  ; skip the Y
00:9AC1 20249C          	   455:   jsr ass_check_no_more_tokens
00:9AC4 20389B          	   456:   jsr opcode_lookup
00:9AC7 4CD898          	   457:   jmp ass_finish_line
                        	   458: 
                        	   459: ass_bad_zp_indirect_indexed:
00:9ACA A22B            	   460:   ldx #43
00:9ACC 4C0E9F          	   461:   jmp ass_error
                        	   462: 
                        	   463: ass_not_x_or_y:
00:9ACF 18              	   464:   clc
00:9AD0 60              	   465:   rts
                        	   466: 
                        	   467: ;
                        	   468: ;  we had (<expression>),<something> so check that <something> is X or Y
                        	   469: ;   sets carry if it is
                        	   470: ;
                        	   471: ass_check_we_have_x_or_y:
00:9AD1 208DC9          	   472:   jsr get_token
00:9AD4 C949            	   473:   cmp #TOKEN_IDENTIFIER
00:9AD6 D0F7            	   474:   bne ass_not_x_or_y
00:9AD8 A592            	   475:   lda token_length
00:9ADA C901            	   476:   cmp #1
00:9ADC D0F1            	   477:   bne ass_not_x_or_y
00:9ADE A000            	   478:   ldy #0
00:9AE0 B190            	   479:   lda (token_address),y
00:9AE2 202E90          	   480:   jsr MAKE_UPPER
00:9AE5 C959            	   481:   cmp #'Y'
00:9AE7 F004            	   482:   beq ass_check_we_have_x_or_y_ok
00:9AE9 C958            	   483:   cmp #'X'
00:9AEB D0E2            	   484:   bne ass_not_x_or_y
                        	   485: ass_check_we_have_x_or_y_ok:
00:9AED 38              	   486:   sec
00:9AEE 60              	   487:   rts
                        	   488: 
                        	   489: ;
                        	   490: ;  we had a non-indirect expression, so was it followed by a comma?
                        	   491: ;
                        	   492: 
                        	   493: ass_value_not_indirect:
00:9AEF A593            	   494:   lda token_type
00:9AF1 C92C            	   495:   cmp #','
00:9AF3 F00D            	   496:   beq ass_indexed
00:9AF5 A901            	   497:   lda #ASS_OPERAND_ABSOLUTE
00:9AF7 856B            	   498:   sta ASS_OPERAND
                        	   499: ass_value_done:
00:9AF9 20249C          	   500:   jsr ass_check_no_more_tokens
00:9AFC 20389B          	   501:   jsr opcode_lookup
00:9AFF 4CD898          	   502:   jmp ass_finish_line
                        	   503: 
                        	   504: ;
                        	   505: ;  <expression>,X or <expression>,Y is what we are expecting here
                        	   506: ;
                        	   507: ;  OR: in the case of BBR0 ... BBR7 and BBS0 ... BBS7 : another expression
                        	   508: ;
                        	   509: 
                        	   510: ass_indexed:
                        	   511: ;
                        	   512: ;  save the value in case we find a second one
                        	   513: ;
                        	   514: ;  checking for another one may change VALUE so we do this now
                        	   515: ;
00:9B02 A500            	   516:   lda VALUE
00:9B04 8506            	   517:   sta REMAIN
00:9B06 A501            	   518:   lda VALUE+1
00:9B08 8507            	   519:   sta REMAIN+1
00:9B0A A502            	   520:   lda VALUE+2
00:9B0C 8508            	   521:   sta REMAIN+2
00:9B0E 20D19A          	   522:   jsr ass_check_we_have_x_or_y
00:9B11 9016            	   523:   bcc ass_absolute_another_value
00:9B13 C958            	   524:   cmp #'X'
00:9B15 F009            	   525:   beq ass_indexed_x
00:9B17 A904            	   526:   lda #ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
00:9B19 856B            	   527:   sta ASS_OPERAND
00:9B1B 208DC9          	   528:   jsr get_token ; skip the Y
00:9B1E 80D9            	   529:   bra ass_value_done
                        	   530: ass_indexed_x:
00:9B20 A903            	   531:   lda #ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
00:9B22 856B            	   532:   sta ASS_OPERAND
00:9B24 208DC9          	   533:   jsr get_token ; skip the X
00:9B27 80D0            	   534:   bra ass_value_done
                        	   535: 
                        	   536: ;
                        	   537: ;  this is hopefully something like BBR0 $42,foo
                        	   538: ;   so we need to evaluate foo
                        	   539: ;
                        	   540: ass_absolute_another_value:
00:9B29 A593            	   541:   lda token_type ; get token back
00:9B2B 203B9D          	   542:   jsr ass_get_value  ; should have some sort of address now in VALUE
                        	   543: ;  jsr ass_check_no_more_tokens
00:9B2E A912            	   544:   lda #ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE
00:9B30 856B            	   545:   sta ASS_OPERAND
00:9B32 20389B          	   546:   jsr opcode_lookup
00:9B35 4CD898          	   547:   jmp ass_finish_line
                        	   548: 
                        	   549: 
                        	   550: ;
                        	   551: ;  look up opcode
                        	   552: ;
                        	   553: opcode_lookup:
                        	   554:   ; the opcode we are looking up
00:9B38 A56C            	   555:   lda OPCODE
00:9B3A 8500            	   556:   sta SRCE
00:9B3C A56D            	   557:   lda OPCODE+1
00:9B3E 8501            	   558:   sta SRCE+1
00:9B40 6472            	   559:   stz ASS_COUNT   ; count of matches
                        	   560: ;
                        	   561: ;  get the address of our table of tables
                        	   562: ;
00:9B42 A982            	   563:   lda #<OPCODE_LOOKUP_TABLE
00:9B44 8570            	   564:   sta ASS_OPCODE_WORK
00:9B46 A99F            	   565:   lda #>OPCODE_LOOKUP_TABLE
00:9B48 8571            	   566:   sta ASS_OPCODE_WORK+1
                        	   567: opcode_lookup_loop:
00:9B4A A000            	   568:   ldy #OPCODE_LOOKUP_OPCODE_LENGTH
00:9B4C B170            	   569:   lda (ASS_OPCODE_WORK),Y       ; get opcode length
00:9B4E F058            	   570:   beq opcode_lookup_loop_done   ; end of table
00:9B50 C56E            	   571:   cmp OPCODE_LEN                ; right length?
00:9B52 F00F            	   572:   beq opcode_lookup_correct_length ; yes
                        	   573: ;
                        	   574: ; no, try the next table item
                        	   575: ;
                        	   576: opcode_lookup_next_table:
00:9B54 18              	   577:   clc
00:9B55 A570            	   578:   lda ASS_OPCODE_WORK
00:9B57 6906            	   579:   adc #OPCODE_LOOKUP_TABLE_SIZE  ; onto next item
00:9B59 8570            	   580:   sta ASS_OPCODE_WORK
00:9B5B A571            	   581:   lda ASS_OPCODE_WORK+1
00:9B5D 6900            	   582:   adc #0
00:9B5F 8571            	   583:   sta ASS_OPCODE_WORK+1
00:9B61 80E7            	   584:   bra opcode_lookup_loop
                        	   585: opcode_lookup_correct_length:
00:9B63 A002            	   586:   ldy #OPCODE_LOOKUP_OPCODE_TABLE
00:9B65 B170            	   587:   lda (ASS_OPCODE_WORK),Y ; get table address low-order byte
00:9B67 8503            	   588:   sta DEST
00:9B69 C8              	   589:   iny
00:9B6A B170            	   590:   lda (ASS_OPCODE_WORK),Y ; get table address high-order byte
00:9B6C 8504            	   591:   sta DEST+1
00:9B6E 20AC9E          	   592:   jsr ass_lookup_loop
00:9B71 90E1            	   593:   bcc opcode_lookup_next_table  ; not found
00:9B73 AA              	   594:   tax   ; save the machine code byte
00:9B74 E672            	   595:   inc ASS_COUNT
00:9B76 A001            	   596:   ldy #OPCODE_LOOKUP_OPERAND_TYPE
00:9B78 A56B            	   597:   lda ASS_OPERAND         ; get wanted type of operand?
00:9B7A D170            	   598:   cmp (ASS_OPCODE_WORK),Y ; compare to operand type in table
00:9B7C F013            	   599:   beq opcode_lookup_correct_operand  ; yes
00:9B7E C906            	   600:   cmp #ASS_OPERAND_ACCUMULATOR_A  ; see if in range 1 to 5
00:9B80 B0D2            	   601:   bcs opcode_lookup_next_table
                        	   602: ;
                        	   603: ;  so if we have a so-called ASS_OPERAND_ABSOLUTE (with various indexing modes)
                        	   604: ;  see if we can match on ASS_OPERAND_ZERO_PAGE by adding 10 to the operand type
                        	   605: ;  - also applies to all the absolute modes (1 to 5)
                        	   606: ;
00:9B82 18              	   607:   clc
00:9B83 690A            	   608:   adc #10
00:9B85 D170            	   609:   cmp (ASS_OPCODE_WORK),Y
00:9B87 D0CB            	   610:   bne opcode_lookup_next_table
                        	   611: ;
                        	   612: ;  plus, the operand has to be in the zero page
                        	   613: ;
00:9B89 A574            	   614:   lda ASS_VALUE+1
00:9B8B D0C7            	   615:   bne opcode_lookup_next_table
00:9B8D A575            	   616:   lda ASS_VALUE+2
00:9B8F D0C3            	   617:   bne opcode_lookup_next_table
                        	   618: opcode_lookup_correct_operand:
00:9B91 8A              	   619:   txa   ; get the byte to emit back
                        	   620: 
                        	   621: ;
                        	   622: ; we have a match! emit the opcode
                        	   623: ;
00:9B92 20D09E          	   624:   jsr ass_emit            ; emit it
00:9B95 A004            	   625:   ldy #OPCODE_LOOKUP_HANDLER  ; offset of handler
00:9B97 B170            	   626:   lda (ASS_OPCODE_WORK),Y ; get opcode handler address low-order byte
00:9B99 AA              	   627:   tax
00:9B9A C8              	   628:   iny
00:9B9B B170            	   629:   lda (ASS_OPCODE_WORK),Y ; get opcode handler address high-order byte
00:9B9D F008            	   630:   beq opcode_lookup_no_handler
00:9B9F 8571            	   631:   sta ASS_OPCODE_WORK+1
00:9BA1 8A              	   632:   txa
00:9BA2 8570            	   633:   sta ASS_OPCODE_WORK
00:9BA4 6C7000          	   634:   jmp (ASS_OPCODE_WORK)   ; do handler - it will RTS for us
                        	   635: 
                        	   636: opcode_lookup_no_handler:
                        	   637: ; put nothing here as it won't be done if there is a handler
00:9BA7 60              	   638:   rts    ; done!
                        	   639: 
                        	   640: opcode_lookup_loop_done:
                        	   641: ;
                        	   642: ;  look for assembler directives
                        	   643: ;
00:9BA8 A925            	   644:   lda #<DIRECTIVES
00:9BAA 8503            	   645:   sta DEST
00:9BAC A9A0            	   646:   lda #>DIRECTIVES
00:9BAE 8504            	   647:   sta DEST+1
00:9BB0 A56E            	   648:   lda OPCODE_LEN
                        	   649: 
                        	   650: ;  pha
                        	   651: ;   lda #'c'
                        	   652: ;   jsr ass_debug_point
                        	   653: ;   pla
                        	   654: 
00:9BB2 20748F          	   655:   jsr handlerLookup
00:9BB5 9029            	   656:   bcc opcode_lookup_ok
                        	   657: 
                        	   658: ;   lda #'d'
                        	   659: ;   jsr ass_debug_point
                        	   660: 
                        	   661: ;
                        	   662: ;  here for unknown opcode
                        	   663: ;
00:9BB7 A56C            	   664:   lda OPCODE
00:9BB9 8590            	   665:   sta token_address
00:9BBB A56D            	   666:   lda OPCODE+1
00:9BBD 8591            	   667:   sta token_address+1
00:9BBF A56E            	   668:   lda OPCODE_LEN
00:9BC1 8592            	   669:   sta token_length
                        	   670: 
                        	   671: ;
                        	   672: ;  if we NEVER found a match, this is an illegal opcode
                        	   673: ;
00:9BC3 A921            	   674:   lda #'!'
00:9BC5 201994          	   675:   jsr COUT
00:9BC8 A66E            	   676:   ldx OPCODE_LEN
00:9BCA A000            	   677:   ldy #0
                        	   678: wtf_loop:
00:9BCC B16C            	   679:    lda (OPCODE),Y
00:9BCE 201994          	   680:    jsr COUT
00:9BD1 C8              	   681:    iny
00:9BD2 CA              	   682:    dex
00:9BD3 D0F7            	   683:    bne wtf_loop
                        	   684: 
                        	   685: 
00:9BD5 A228            	   686:   ldx  #40    ; illegal opcode
00:9BD7 A572            	   687:   lda ASS_COUNT
00:9BD9 F002            	   688:   beq opcode_lookup_loop_unknown
                        	   689: ;
                        	   690: ;  if we found a match, but not for this addressing mode, they used an illegal mode
                        	   691: ;
00:9BDB A229            	   692:   ldx  #41   ; illegal addressing mode
                        	   693: opcode_lookup_loop_unknown:
00:9BDD 4C0E9F          	   694:   JMP  ass_error
                        	   695: 
                        	   696: opcode_lookup_ok:
                        	   697: 
                        	   698: ;   lda #'e'
                        	   699: ; jsr ass_debug_point
                        	   700: 
00:9BE0 60              	   701:   rts
                        	   702: 
                        	   703: ass_done:
00:9BE1 209292          	   704:   jsr  CROUT
00:9BE4 A576            	   705:   LDA  ASS_PASS
00:9BE6 D003            	   706:   bne  ass_done_second_pass
00:9BE8 4CB998          	   707:   jmp  ASSEMBLE_SECOND_PASS
                        	   708: ass_done_second_pass:
00:9BEB A906            	   709:   LDA  #<ass_done_message  ; Assemble finished: No Errors
00:9BED A29C            	   710:   LDX  #>ass_done_message
00:9BEF 202682          	   711:   JSR  print
00:9BF2 A910            	   712:   lda  #FLAG_VALID_ASSEMBLE
00:9BF4 04BE            	   713:   tsb  system_flags
00:9BF6 200F8F          	   714:   jsr  show_symbol_table_end
00:9BF9 20348F          	   715:   jsr  show_source_end
00:9BFC A582            	   716:   lda  show_symbols
00:9BFE F003            	   717:   beq  ass_done1
00:9C00 20C9A5          	   718:   jsr  list_symbols
                        	   719: ass_done1:
00:9C03 4CCD82          	   720:   JMP  main_prompt
                        	   721: 
00:9C06 417373656D626C65	   722: ass_done_message asciiz "Assemble finished: No errors\n"
00:9C0E 2066696E69736865
00:9C16 643A204E6F206572
00:9C1E 726F72730A
00:9C23 00
                        	   723: 
                        	   724: ass_check_no_more_tokens:
00:9C24 A593            	   725:   lda token_type
00:9C26 C90A            	   726:   cmp #NL           ; or end of line?
00:9C28 F005            	   727:   beq ass_check_no_more_tokens_ok
00:9C2A A213            	   728:   ldx #19    ; ERROR: incorrect symbol
00:9C2C 4C0E9F          	   729:   jmp ass_error
                        	   730: 
                        	   731: ass_check_no_more_tokens_ok:
00:9C2F 60              	   732:   rts
                        	   733: 
                        	   734: ;
                        	   735: ;  push a 3-byte value (in VALUE) onto the evaluation stack
                        	   736: ;    changes A and Y
                        	   737: ;
                        	   738: exp_push_value = *
00:9C30 A57B            	   739:   lda exp_value_stack_count
00:9C32 C9FF            	   740:   cmp #$FF
00:9C34 D005            	   741:   bne exp_push_value_ok
                        	   742: exp_push_value_memory_full:
00:9C36 A22E            	   743:   ldx #46   ; ERROR: Expression too complex
00:9C38 4C0E9F          	   744:   jmp ass_error
                        	   745: exp_push_value_ok:
00:9C3B E67B            	   746:   inc exp_value_stack_count
00:9C3D 38              	   747:   sec
00:9C3E A579            	   748:   lda exp_value_stack
00:9C40 E903            	   749:   sbc #3
00:9C42 8579            	   750:   sta exp_value_stack
00:9C44 A57A            	   751:   lda exp_value_stack+1
00:9C46 E900            	   752:   sbc #0
00:9C48 857A            	   753:   sta exp_value_stack+1
                        	   754: ;
                        	   755: ;  has our expression value fallen down into our P-codes?
                        	   756: ;
                        	   757: ;  This doesn't work if the output (PCODE) has been relocated to above
                        	   758: ;  the symbol table and I can't think of an easy solution, so let's ignore
                        	   759: ;  it and hope it doesn't happen.
                        	   760: ;
                        	   761: ;
                        	   762: ; lda  PCODE+1               ; see if P-codes full
                        	   763: ; cmp  exp_value_stack+1     ; in other words, have we hit the symbol table?
                        	   764: ; bcc  exp_push_value_not_full      ; less than
                        	   765: ; bne  exp_push_value_memory_full   ; greater than
                        	   766: ; lda  PCODE
                        	   767: ; cmp  exp_value_stack
                        	   768: ; bcs  exp_push_value_memory_full   ; BGE
                        	   769: 
                        	   770: exp_push_value_not_full:
00:9C4A A000            	   771:   ldy #0
00:9C4C A500            	   772:   lda VALUE
00:9C4E 9179            	   773:   sta (exp_value_stack),y
00:9C50 C8              	   774:   iny
00:9C51 A501            	   775:   lda VALUE+1
00:9C53 9179            	   776:   sta (exp_value_stack),y
00:9C55 C8              	   777:   iny
00:9C56 A502            	   778:   lda VALUE+2
00:9C58 9179            	   779:   sta (exp_value_stack),y
00:9C5A 60              	   780:   rts
                        	   781: 
                        	   782: ;
                        	   783: ;  pop a 3-byte value (into VALUE) from the evaluation stack
                        	   784: ;    changes A and Y
                        	   785: ;
                        	   786: exp_pop_value = *
00:9C5B A57B            	   787:   lda exp_value_stack_count
00:9C5D D005            	   788:   bne exp_pop_value_ok
00:9C5F A217            	   789:   ldx #23    ; ERROR: illegal factor
00:9C61 4C0E9F          	   790:   jmp ass_error
                        	   791: exp_pop_value_ok:
00:9C64 C67B            	   792:   dec exp_value_stack_count
00:9C66 A000            	   793:   ldy #0
00:9C68 B179            	   794:   lda (exp_value_stack),y
00:9C6A 8500            	   795:   sta VALUE
00:9C6C C8              	   796:   iny
00:9C6D B179            	   797:   lda (exp_value_stack),y
00:9C6F 8501            	   798:   sta VALUE+1
00:9C71 C8              	   799:   iny
00:9C72 B179            	   800:   lda (exp_value_stack),y
00:9C74 8502            	   801:   sta VALUE+2
00:9C76 18              	   802:   clc
00:9C77 A579            	   803:   lda exp_value_stack
00:9C79 6903            	   804:   adc #3
00:9C7B 8579            	   805:   sta exp_value_stack
00:9C7D A57A            	   806:   lda exp_value_stack+1
00:9C7F 6900            	   807:   adc #0
00:9C81 857A            	   808:   sta exp_value_stack+1
00:9C83 60              	   809:   rts
                        	   810: 
                        	   811: ;
                        	   812: ;  I needed a work area for operators, and initially used INBUF however that got
                        	   813: ;  repurposed for managing strings (in particular handling \Xnn and double quotes)
                        	   814: ;  so now I am using the memory at the current PCODE address as a work area.
                        	   815: ;  It is only needed during expression evaluation, and should hopefully be available.
                        	   816: ;
                        	   817: ;
                        	   818: ;  push an operator (A) onto the operator stack
                        	   819: ;   changes X and Y
                        	   820: ;
                        	   821: exp_push_operator:
00:9C84 A67C            	   822:   ldx exp_operator_stack_count
00:9C86 E0FA            	   823:   cpx #250  ; make sure we don't overflow our operator stack
00:9C88 9005            	   824:   bcc exp_push_operator_ok
00:9C8A A22E            	   825:   ldx #46   ; ERROR: Expression too complex
00:9C8C 4C0E9F          	   826:   jmp ass_error
                        	   827: exp_push_operator_ok:
00:9C8F E67C            	   828:   inc exp_operator_stack_count  ; add, then store
00:9C91 A47C            	   829:   ldy exp_operator_stack_count
00:9C93 9123            	   830:   sta (PCODE),Y
00:9C95 60              	   831:   rts
                        	   832: 
                        	   833: ;
                        	   834: ;  pop an operator (into A) from the operator stack
                        	   835: ;   changes X and Y
                        	   836: ;
                        	   837: exp_pop_operator:
00:9C96 A67C            	   838:   ldx exp_operator_stack_count
00:9C98 D005            	   839:   bne exp_pop_operator_ok
00:9C9A A217            	   840:   ldx #23   ; ERROR: Illegal factor
00:9C9C 4C0E9F          	   841:   jmp ass_error
                        	   842: exp_pop_operator_ok:
00:9C9F A47C            	   843:   ldy exp_operator_stack_count  ; retrieve, then decrement
00:9CA1 B123            	   844:   lda (PCODE),Y
00:9CA3 C67C            	   845:   dec exp_operator_stack_count
00:9CA5 60              	   846:   rts
                        	   847: 
                        	   848: ;
                        	   849: ;  get an operator (into A) from the operator stack (without removing it)
                        	   850: ;   changes X and Y
                        	   851: ;
                        	   852: exp_get_operator:
00:9CA6 A67C            	   853:   ldx exp_operator_stack_count
00:9CA8 D005            	   854:   bne exp_get_operator_ok
00:9CAA A217            	   855:   ldx #23   ; ERROR: Illegal factor
00:9CAC 4C0E9F          	   856:   jmp ass_error
                        	   857: exp_get_operator_ok:
00:9CAF A47C            	   858:   ldy exp_operator_stack_count
00:9CB1 B123            	   859:   lda (PCODE),Y
00:9CB3 60              	   860:   rts
                        	   861: 
                        	   862:  .macro makePrecedenceTable ; table of operators, precedence, handler
                        	   863:    dfb   \1
                        	   864:    dfb   \2
                        	   865:    word  \3
                        	   866:  .endmacro
                        	   867: 
                        	   868: ; cannot have more than 64 entries because we index into this with X
                        	   869: exp_precedence_table:
                        	   870:   makePrecedenceTable '~', 1, exp_negate
00:9CB4 7E              	     1M    dfb   '~'
00:9CB5 01              	     2M    dfb   1
00:9CB6 FBAB            	     3M    word  exp_negate
                        	   871:   makePrecedenceTable '!', 1, exp_not
00:9CB8 21              	     1M    dfb   '!'
00:9CB9 01              	     2M    dfb   1
00:9CBA 0EAC            	     3M    word  exp_not
                        	   872:   makePrecedenceTable TOKEN_UNARY_MINUS, 1, exp_unary_minus
00:9CBC 4D              	     1M    dfb   TOKEN_UNARY_MINUS
00:9CBD 01              	     2M    dfb   1
00:9CBE 1CAC            	     3M    word  exp_unary_minus
                        	   873:   makePrecedenceTable TOKEN_LOW_BYTE, 1, exp_low_byte
00:9CC0 56              	     1M    dfb   TOKEN_LOW_BYTE
00:9CC1 01              	     2M    dfb   1
00:9CC2 30AC            	     3M    word  exp_low_byte
                        	   874:   makePrecedenceTable TOKEN_HIGH_BYTE, 1, exp_high_byte
00:9CC4 57              	     1M    dfb   TOKEN_HIGH_BYTE
00:9CC5 01              	     2M    dfb   1
00:9CC6 35AC            	     3M    word  exp_high_byte
                        	   875:   makePrecedenceTable TOKEN_SHIFT_LEFT, 2, exp_shift_left
00:9CC8 4C              	     1M    dfb   TOKEN_SHIFT_LEFT
00:9CC9 02              	     2M    dfb   2
00:9CCA C9AB            	     3M    word  exp_shift_left
                        	   876:   makePrecedenceTable TOKEN_SHIFT_RIGHT, 2, exp_shift_right
00:9CCC 52              	     1M    dfb   TOKEN_SHIFT_RIGHT
00:9CCD 02              	     2M    dfb   2
00:9CCE E2AB            	     3M    word  exp_shift_right
                        	   877:   makePrecedenceTable '&', 3, exp_bitwise_and
00:9CD0 26              	     1M    dfb   '&'
00:9CD1 03              	     2M    dfb   3
00:9CD2 78AB            	     3M    word  exp_bitwise_and
                        	   878:   makePrecedenceTable '^', 4, exp_bitwise_xor
00:9CD4 5E              	     1M    dfb   '^'
00:9CD5 04              	     2M    dfb   4
00:9CD6 8DAB            	     3M    word  exp_bitwise_xor
                        	   879:   makePrecedenceTable '|', 5, exp_bitwise_or
00:9CD8 7C              	     1M    dfb   '|'
00:9CD9 05              	     2M    dfb   5
00:9CDA 63AB            	     3M    word  exp_bitwise_or
                        	   880:   makePrecedenceTable '*', 6, exp_multiply
00:9CDC 2A              	     1M    dfb   '*'
00:9CDD 06              	     2M    dfb   6
00:9CDE A3AC            	     3M    word  exp_multiply
                        	   881:   makePrecedenceTable '/', 6, exp_divide
00:9CE0 2F              	     1M    dfb   '/'
00:9CE1 06              	     2M    dfb   6
00:9CE2 DCAC            	     3M    word  exp_divide
                        	   882:   makePrecedenceTable '%', 6, exp_modulo
00:9CE4 25              	     1M    dfb   '%'
00:9CE5 06              	     2M    dfb   6
00:9CE6 3CAD            	     3M    word  exp_modulo
                        	   883:   makePrecedenceTable '+', 7, exp_add
00:9CE8 2B              	     1M    dfb   '+'
00:9CE9 07              	     2M    dfb   7
00:9CEA D5AA            	     3M    word  exp_add
                        	   884:   makePrecedenceTable '-', 7, exp_subtract
00:9CEC 2D              	     1M    dfb   '-'
00:9CED 07              	     2M    dfb   7
00:9CEE E9AA            	     3M    word  exp_subtract
                        	   885:   makePrecedenceTable '<', 8, exp_less_than
00:9CF0 3C              	     1M    dfb   '<'
00:9CF1 08              	     2M    dfb   8
00:9CF2 37AB            	     3M    word  exp_less_than
                        	   886:   makePrecedenceTable '>', 8, exp_greater_than
00:9CF4 3E              	     1M    dfb   '>'
00:9CF5 08              	     2M    dfb   8
00:9CF6 3EAB            	     3M    word  exp_greater_than
                        	   887:   makePrecedenceTable TOKEN_LEQ, 8, exp_leq
00:9CF8 80              	     1M    dfb   TOKEN_LEQ
00:9CF9 08              	     2M    dfb   8
00:9CFA 4DAB            	     3M    word  exp_leq
                        	   888:   makePrecedenceTable TOKEN_GEQ, 8, exp_geq
00:9CFC 81              	     1M    dfb   TOKEN_GEQ
00:9CFD 08              	     2M    dfb   8
00:9CFE 5CAB            	     3M    word  exp_geq
                        	   889:   makePrecedenceTable TOKEN_EQUALITY, 9, exp_eql
00:9D00 45              	     1M    dfb   TOKEN_EQUALITY
00:9D01 09              	     2M    dfb   9
00:9D02 0FAB            	     3M    word  exp_eql
                        	   890:   makePrecedenceTable TOKEN_NEQ, 9, exp_neq     ; <>
00:9D04 55              	     1M    dfb   TOKEN_NEQ
00:9D05 09              	     2M    dfb   9
00:9D06 23AB            	     3M    word  exp_neq     
                        	   891:   makePrecedenceTable TOKEN_INEQUALITY, 9, exp_neq  ; !=
00:9D08 5A              	     1M    dfb   TOKEN_INEQUALITY
00:9D09 09              	     2M    dfb   9
00:9D0A 23AB            	     3M    word  exp_neq  
                        	   892:   makePrecedenceTable TOKEN_LOGICAL_AND, 10, exp_logical_and
00:9D0C 58              	     1M    dfb   TOKEN_LOGICAL_AND
00:9D0D 0A              	     2M    dfb   10
00:9D0E B7AB            	     3M    word  exp_logical_and
                        	   893:   makePrecedenceTable TOKEN_LOGICAL_OR, 11, exp_logical_or
00:9D10 59              	     1M    dfb   TOKEN_LOGICAL_OR
00:9D11 0B              	     2M    dfb   11
00:9D12 A8AB            	     3M    word  exp_logical_or
                        	   894: 
                        	   895: exp_precedence_table_end = *
                        	   896: 
                        	   897: ;
                        	   898: ;  finds precedence of operator in A, returns it in Y (returns 0 if not found)
                        	   899: ;    changes X, A
                        	   900: ;  also stores the operator evaluation function (eg. exp_add) in exp_evaluation_function
                        	   901: ;
                        	   902: exp_get_precedence:
00:9D14 A200            	   903:   ldx #0
                        	   904: exp_get_precedence_loop:
00:9D16 DDB49C          	   905:   cmp exp_precedence_table,x
00:9D19 F00F            	   906:   beq exp_get_precedence_found
00:9D1B E8              	   907:   inx   ; skip operator
00:9D1C E8              	   908:   inx   ; skip precedence
00:9D1D E8              	   909:   inx   ; skip evaluation function
00:9D1E E8              	   910:   inx   ;  (2 bytes)
00:9D1F E060            	   911:   cpx #exp_precedence_table_end - exp_precedence_table
00:9D21 90F3            	   912:   bcc exp_get_precedence_loop
00:9D23 A000            	   913:   ldy #0
00:9D25 647F            	   914:   stz exp_evaluation_function
00:9D27 6480            	   915:   stz exp_evaluation_function+1
00:9D29 60              	   916:   rts
                        	   917: exp_get_precedence_found:
00:9D2A E8              	   918:   inx
00:9D2B BCB49C          	   919:   ldy exp_precedence_table,x
00:9D2E E8              	   920:   inx
00:9D2F BDB49C          	   921:   lda exp_precedence_table,x
00:9D32 857F            	   922:   sta exp_evaluation_function
00:9D34 E8              	   923:   inx
00:9D35 BDB49C          	   924:   lda exp_precedence_table,x
00:9D38 8580            	   925:   sta exp_evaluation_function+1
00:9D3A 60              	   926:   rts
                        	   927: 
                        	   928: ;
                        	   929: ;  Convert an expression into a value
                        	   930: ;
                        	   931: ;   Ideas from https://www.geeksforgeeks.org/expression-evaluation/
                        	   932: ;
                        	   933: ass_get_value:
                        	   934: ;
                        	   935: ;  set up expression evaluation stack
                        	   936: ;
00:9D3B 647B            	   937:   stz exp_value_stack_count
00:9D3D 647C            	   938:   stz exp_operator_stack_count
00:9D3F A531            	   939:   lda ENDSYM
00:9D41 8579            	   940:   sta exp_value_stack
00:9D43 A532            	   941:   lda ENDSYM+1
00:9D45 857A            	   942:   sta exp_value_stack+1
                        	   943: 
00:9D47 6473            	   944:   stz ASS_VALUE
00:9D49 6474            	   945:   stz ASS_VALUE+1
00:9D4B 6475            	   946:   stz ASS_VALUE+2
00:9D4D A901            	   947:   lda #1
00:9D4F 8581            	   948:   sta exp_unary_ok  ; unary operators can appear at the start of the expression
00:9D51 A593            	   949:   lda token_type
                        	   950: ;  jsr START_TRACE
                        	   951: ;
                        	   952: ;  one token lookahead
                        	   953: ;
00:9D53 8003            	   954:   bra ass_expression_loop_initial
                        	   955: 
                        	   956: ;
                        	   957: ;  1.1 Get the next token
                        	   958: ;
                        	   959: ass_expression_loop:
00:9D55 208DC9          	   960:   jsr get_token
                        	   961: ass_expression_loop_initial:
                        	   962: 
                        	   963: ;
                        	   964: ;  1.2.1 If it's a number, push onto the value stack
                        	   965: ;
00:9D58 C94E            	   966:   cmp #TOKEN_NUMBER
00:9D5A D013            	   967:   bne ass_expression_loop1a
                        	   968: ass_expression_number:
00:9D5C A594            	   969:   lda token_value
00:9D5E 8500            	   970:   sta VALUE
00:9D60 A595            	   971:   lda token_value+1
00:9D62 8501            	   972:   sta VALUE+1
00:9D64 A596            	   973:   lda token_value+2
00:9D66 8502            	   974:   sta VALUE+2
00:9D68 20309C          	   975:   jsr exp_push_value
00:9D6B 6481            	   976:   stz exp_unary_ok          ; don't have unary operators after numbers
00:9D6D 80E6            	   977:   bra ass_expression_loop
                        	   978: ;
                        	   979: ;  if it's a string and only 1 or 2 bytes, consider as a number
                        	   980: ;
                        	   981: ass_expression_loop1a:
00:9D6F C922            	   982:   cmp #TOKEN_STRING
00:9D71 D013            	   983:   bne ass_expression_loop1
00:9D73 A592            	   984:   lda token_length
00:9D75 C903            	   985:   cmp #3
00:9D77 B008            	   986:   bcs ass_expression_not_small_string  ; too long?
                        	   987: ;
                        	   988: ;  one or two character string - is this an immediate operand?
                        	   989: ;
00:9D79 A56B            	   990:   lda ASS_OPERAND
00:9D7B C907            	   991:   cmp #ASS_OPERAND_IMMEDIATE
00:9D7D D002            	   992:   bne ass_expression_not_small_string
00:9D7F 80DB            	   993:   bra ass_expression_number   ; treat as a number (its value should be in VALUE)
                        	   994: 
                        	   995: ass_expression_not_small_string:
00:9D81 A21D            	   996:   ldx #29     ; string literal too big
00:9D83 4C0E9F          	   997:   jmp ass_error
                        	   998: 
                        	   999: ;
                        	  1000: ;  1.2.2 If it's an identifier, get its value and push onto the value stack
                        	  1001: ;
                        	  1002: ass_expression_loop1:
00:9D86 C949            	  1003:   cmp #TOKEN_IDENTIFIER
00:9D88 D029            	  1004:   bne ass_expression_loop2
00:9D8A 6481            	  1005:   stz exp_unary_ok          ; don't have unary operators after identifiers
                        	  1006: 
00:9D8C 2013B9          	  1007:   jsr SEARCH    ; should be in symbol table as a constant, and the value in VALUE
00:9D8F D011            	  1008:   bne ass_expression_found_value
00:9D91 A576            	  1009:   lda ASS_PASS
00:9D93 F005            	  1010:   beq ass_label_not_found_yet
                        	  1011: 
                        	  1012: ;
                        	  1013: ; it's an error if it isn't there on the second pass
                        	  1014: ;
00:9D95 A20B            	  1015:   ldx #11  ; ERROR: Undeclared Identifier
00:9D97 4C0E9F          	  1016:   jmp ass_error
                        	  1017: 
                        	  1018: ;
                        	  1019: ;  label not found on first pass, make the value 0x6666 for now
                        	  1020: ;   - we don't want a zero-page address assumption because that
                        	  1021: ;     will throw out opcode lengths (it might assume a zero page opcode
                        	  1022: ;     which is shorter and then change it to a longer one)
                        	  1023: ;
                        	  1024: ass_label_not_found_yet:
00:9D9A A966            	  1025:   lda #$66
00:9D9C 8500            	  1026:   sta VALUE
00:9D9E 8501            	  1027:   sta VALUE+1
00:9DA0 6402            	  1028:   stz VALUE+2
                        	  1029: ass_expression_found_value:
00:9DA2 A594            	  1030:   lda token_value
00:9DA4 8500            	  1031:   sta VALUE
00:9DA6 A595            	  1032:   lda token_value+1
00:9DA8 8501            	  1033:   sta VALUE+1
00:9DAA A596            	  1034:   lda token_value+2
00:9DAC 8502            	  1035:   sta VALUE+2
00:9DAE 20309C          	  1036:   jsr exp_push_value
00:9DB1 80A2            	  1037:   bra ass_expression_loop
                        	  1038: 
                        	  1039: ;
                        	  1040: ; 1.2.3 If it's a left parenthesis: push it onto the operator stack.
                        	  1041: ;
                        	  1042: ass_expression_loop2:
00:9DB3 C928            	  1043:   cmp #'('
00:9DB5 D00B            	  1044:   bne ass_expression_loop3
00:9DB7 48              	  1045:   pha
00:9DB8 A901            	  1046:   lda  #1
00:9DBA 8581            	  1047:   sta exp_unary_ok          ; unary operators can follow left parentheses
00:9DBC 68              	  1048:   pla
                        	  1049: 
00:9DBD 20849C          	  1050:   jsr exp_push_operator
00:9DC0 8093            	  1051:   bra ass_expression_loop
                        	  1052: 
                        	  1053: ;
                        	  1054: ;  1.2.4 A right parenthesis:
                        	  1055: ;       1 While the thing on top of the operator stack is not a
                        	  1056: ;         left parenthesis,
                        	  1057: ;           1 Pop the operator from the operator stack.
                        	  1058: ;           2 Pop the value stack twice, getting two operands.
                        	  1059: ;           3 Apply the operator to the operands, in the correct order.
                        	  1060: ;           4 Push the result onto the value stack.
                        	  1061: ;        2 Pop the left parenthesis from the operator stack, and discard it.
                        	  1062: 
                        	  1063: 
                        	  1064: ass_expression_loop3:
00:9DC2 C929            	  1065:   cmp #')'
00:9DC4 D016            	  1066:   bne ass_expression_loop4
                        	  1067: ass_expression_loop3b:
                        	  1068: ;
                        	  1069: ;  a RH parenthesis with an empty operator stack is probably the end of the expression, eg. ($1234),x
                        	  1070: ;  where the ")" belongs to the indexed operand stuff and not the expression
                        	  1071: ;
00:9DC6 A57C            	  1072:   lda exp_operator_stack_count
00:9DC8 F078            	  1073:   beq exp_no_operators_left
00:9DCA 20A69C          	  1074:   jsr exp_get_operator
00:9DCD C928            	  1075:   cmp #'('
00:9DCF F005            	  1076:   beq ass_expression_loop3c
                        	  1077: ;
                        	  1078: ;  not a left parenthesis
                        	  1079: ;
                        	  1080: ass_expression_loop3a:
00:9DD1 20689E          	  1081:   jsr ass_expression_apply_operator ; pop the operator and two values, apply the operator and push the result
00:9DD4 80F0            	  1082:   bra ass_expression_loop3b          ; keep going until we don't have a left parenthesis
                        	  1083: 
                        	  1084: ass_expression_loop3c:
00:9DD6 20969C          	  1085:   jsr exp_pop_operator              ;  2 Pop the left parenthesis from the operator stack, and discard it.
                        	  1086: ass_expression_loopJ:
00:9DD9 4C559D          	  1087:   jmp ass_expression_loop
                        	  1088: 
                        	  1089: ;       1.2.5 An operator (call it thisOp):
                        	  1090: ;         1 While the operator stack is not empty, and the top thing on the
                        	  1091: ;           operator stack has the same or greater precedence as thisOp,
                        	  1092: ;           1 Pop the operator from the operator stack.
                        	  1093: ;           2 Pop the value stack twice, getting two operands.
                        	  1094: ;           3 Apply the operator to the operands, in the correct order.
                        	  1095: ;           4 Push the result onto the value stack.
                        	  1096: ;         2 Push thisOp onto the operator stack.
                        	  1097: 
                        	  1098: ass_expression_loop4:
                        	  1099: ;
                        	  1100: ;  look for unary operators
                        	  1101: ;
00:9DDC A681            	  1102:   ldx exp_unary_ok
00:9DDE F034            	  1103:   beq ass_expression_cannot_be_unary
00:9DE0 C92D            	  1104:   cmp #'-'
00:9DE2 D006            	  1105:   bne ass_not_unary_minus
00:9DE4 A94D            	  1106:   lda #TOKEN_UNARY_MINUS
00:9DE6 8593            	  1107:   sta token_type
00:9DE8 802A            	  1108:   bra ass_expression_cannot_be_unary
                        	  1109: ass_not_unary_minus:
00:9DEA C93C            	  1110:   cmp #'<'
00:9DEC D006            	  1111:   bne ass_not_unary_less_than
00:9DEE A956            	  1112:   lda #TOKEN_LOW_BYTE
00:9DF0 8593            	  1113:   sta token_type
00:9DF2 8020            	  1114:   bra ass_expression_cannot_be_unary
                        	  1115: ass_not_unary_less_than:
00:9DF4 C93E            	  1116:   cmp #'>'
00:9DF6 D006            	  1117:   bne ass_not_unary_greater_than
00:9DF8 A957            	  1118:   lda #TOKEN_HIGH_BYTE
00:9DFA 8593            	  1119:   sta token_type
00:9DFC 8000            	  1120:   bra ass_not_unary_greater_than
                        	  1121: ass_not_unary_greater_than:
00:9DFE C92A            	  1122:   cmp #'*'
00:9E00 D012            	  1123:   bne ass_expression_cannot_be_unary
                        	  1124: ;
                        	  1125: ;  A '*' where a unary expression is allowed will be the current emit address (eg. foo = *)
                        	  1126: ;
00:9E02 A523            	  1127:   lda PCODE
00:9E04 8594            	  1128:   sta token_value
00:9E06 A524            	  1129:   lda PCODE+1
00:9E08 8595            	  1130:   sta token_value+1
00:9E0A 6496            	  1131:   stz token_value+2
00:9E0C 6481            	  1132:   stz exp_unary_ok          ; don't have unary operators after numbers
00:9E0E A94E            	  1133:   lda #TOKEN_NUMBER
00:9E10 8593            	  1134:   sta token_type            ; make get_token think a sign as a token on its own
00:9E12 808E            	  1135:   bra ass_expression_found_value
                        	  1136: 
                        	  1137: ass_expression_cannot_be_unary:
00:9E14 48              	  1138:   pha
00:9E15 A901            	  1139:   lda #1
00:9E17 8581            	  1140:   sta exp_unary_ok          ; can have unary operators after operators
00:9E19 68              	  1141:   pla
                        	  1142: 
00:9E1A 20149D          	  1143:   jsr exp_get_precedence
00:9E1D 847E            	  1144:   sty exp_operator_precedence ; thisOp's precedence
00:9E1F C000            	  1145:   cpy #0
00:9E21 F01F            	  1146:   beq exp_no_operators_left
                        	  1147: 
                        	  1148: ass_expression_loop7:         ; 1 While the operator stack is not empty
00:9E23 A57C            	  1149:   lda exp_operator_stack_count
00:9E25 F013            	  1150:   beq ass_expression_loop6    ; stack empty
00:9E27 20A69C          	  1151:   jsr exp_get_operator    ; find the top thing on the operator stack
00:9E2A C928            	  1152:   cmp #'('                ; if a bracket, consider that low precedence
00:9E2C F00C            	  1153:   beq ass_expression_loop6
00:9E2E 20149D          	  1154:   jsr exp_get_precedence  ; and its precedence
00:9E31 C47E            	  1155:   cpy exp_operator_precedence
00:9E33 B005            	  1156:   bcs ass_expression_loop6  ; thing on top has less precedence (a higher value) than thisOp
00:9E35 20689E          	  1157:   jsr ass_expression_apply_operator  ; pop the operator and two values, apply the operator and push the result
00:9E38 80E9            	  1158:   bra ass_expression_loop7
                        	  1159: 
                        	  1160: ass_expression_loop6:
00:9E3A A593            	  1161:   lda token_type       ; thisOp
00:9E3C 20849C          	  1162:   jsr exp_push_operator
00:9E3F 4C559D          	  1163:   jmp ass_expression_loop
                        	  1164: 
                        	  1165: 
                        	  1166: ; 2. While the operator stack is not empty,
                        	  1167: ;     1 Pop the operator from the operator stack.
                        	  1168: ;     2 Pop the value stack twice, getting two operands.
                        	  1169: ;     3 Apply the operator to the operands, in the correct order.
                        	  1170: ;     4 Push the result onto the value stack.
                        	  1171: 
                        	  1172: 
                        	  1173: exp_no_operators_left:
00:9E42 A57C            	  1174:     lda exp_operator_stack_count
00:9E44 F005            	  1175:     beq exp_done
00:9E46 20689E          	  1176:     jsr ass_expression_apply_operator ; pop the operator and two values, apply the operator and push the result
00:9E49 80F7            	  1177:     bra exp_no_operators_left
                        	  1178: 
                        	  1179: exp_done:
00:9E4B A57B            	  1180:       lda exp_value_stack_count
00:9E4D C901            	  1181:       cmp #1
00:9E4F F005            	  1182:       beq exp_done_ok
                        	  1183: exp_done_error:
00:9E51 A217            	  1184:       ldx #23       ; ERROR: Illegal factor
00:9E53 4C0E9F          	  1185:       jmp ass_error
                        	  1186: 
                        	  1187: exp_done_ok:
00:9E56 A57C            	  1188:       lda exp_operator_stack_count
00:9E58 D0F7            	  1189:       bne exp_done_error
00:9E5A 205B9C          	  1190:       jsr exp_pop_value   ; pop the finished value
00:9E5D A500            	  1191:       lda VALUE
00:9E5F 8573            	  1192:       sta ASS_VALUE
00:9E61 A501            	  1193:       lda VALUE+1
00:9E63 8574            	  1194:       sta ASS_VALUE+1
00:9E65 6475            	  1195:       stz ASS_VALUE+2   ; make high-order byte zero just in case
00:9E67 60              	  1196:       rts
                        	  1197: 
                        	  1198: ;
                        	  1199: ;
                        	  1200: ;     1 Pop the operator from the operator stack.
                        	  1201: ;     2 Pop the value stack twice, getting two operands.
                        	  1202: ;     3 Apply the operator to the operands, in the correct order.
                        	  1203: ;     4 Push the result onto the value stack.
                        	  1204: 
                        	  1205: ;
                        	  1206: ass_expression_apply_operator:
00:9E68 205B9C          	  1207:   jsr exp_pop_value         ; 2 Pop the value stack twice, getting two operands.
00:9E6B 20A69C          	  1208:   jsr exp_get_operator
00:9E6E C97E            	  1209:   cmp #'~'
00:9E70 F01F            	  1210:   beq ass_expression_unary
00:9E72 C921            	  1211:   cmp #'!'
00:9E74 F01B            	  1212:   beq ass_expression_unary
00:9E76 C94D            	  1213:   cmp #TOKEN_UNARY_MINUS
00:9E78 F017            	  1214:   beq ass_expression_unary
00:9E7A C956            	  1215:   cmp #TOKEN_LOW_BYTE
00:9E7C F013            	  1216:   beq ass_expression_unary
00:9E7E C957            	  1217:   cmp #TOKEN_HIGH_BYTE
00:9E80 F00F            	  1218:   beq ass_expression_unary
                        	  1219: 
                        	  1220: ;
                        	  1221: ;  if a binary operator get the second value
                        	  1222: ;
00:9E82 A500            	  1223:   lda VALUE                 ; copy top value to VALUE2
00:9E84 8503            	  1224:   sta VALUE2
00:9E86 A501            	  1225:   lda VALUE+1
00:9E88 8504            	  1226:   sta VALUE2+1
00:9E8A A502            	  1227:   lda VALUE+2
00:9E8C 8505            	  1228:   sta VALUE2+2
00:9E8E 205B9C          	  1229:   jsr exp_pop_value         ; second pop
                        	  1230: ass_expression_unary:
                        	  1231: 
                        	  1232: ;
                        	  1233: ;  now we have the top two values in VALUE (and VALUE2 in the case of binary operators)
                        	  1234: ;
00:9E91 20969C          	  1235:   jsr exp_pop_operator      ; 1 Pop the operator from the operator stack.
00:9E94 857D            	  1236:   sta exp_operator
00:9E96 20149D          	  1237:   jsr exp_get_precedence    ; find the evaluation function
00:9E99 C000            	  1238:   cpy #0
00:9E9B F0CB            	  1239:   beq ass_expression_apply_operator ; should not be here if the operator isn't in the table
00:9E9D 20A99E          	  1240:   jsr ass_evaluate_operator ; do the evaluation
00:9EA0 20309C          	  1241:   jsr exp_push_value        ; 4 Push the result onto the value stack.
00:9EA3 60              	  1242:   rts
                        	  1243: 
                        	  1244: ass_expression_apply_operator_bug:
00:9EA4 A206            	  1245:   ldx #6
00:9EA6 4C0E9F          	  1246:   jmp ass_error
                        	  1247: 
                        	  1248: ass_evaluate_operator:
00:9EA9 6C7F00          	  1249:   jmp (exp_evaluation_function)
                        	  1250: 
                        	  1251: 
                        	  1252: ;
                        	  1253: ;  look up opcodes in a table
                        	  1254: ;  returns carry set if found, carry clear if not found
                        	  1255: ;
                        	  1256: ass_lookup_loop:
00:9EAC A46E            	  1257:   ldy OPCODE_LEN
00:9EAE 209792          	  1258:   jsr COMSTL
00:9EB1 F017            	  1259:   beq ass_opcode_found
                        	  1260: ;
                        	  1261: ;  add the opcode length, plus 1 to DEST
                        	  1262: ;
00:9EB3 18              	  1263:   clc
00:9EB4 A46E            	  1264:   ldy OPCODE_LEN
00:9EB6 C8              	  1265:   iny
00:9EB7 98              	  1266:   tya
00:9EB8 6503            	  1267:   adc DEST
00:9EBA 8503            	  1268:   sta DEST
00:9EBC A504            	  1269:   lda DEST+1
00:9EBE 6900            	  1270:   adc #0
00:9EC0 8504            	  1271:   sta DEST+1
                        	  1272: ;
                        	  1273: ;  end of table?
                        	  1274: ;
00:9EC2 A000            	  1275:   ldy #0
00:9EC4 B103            	  1276:   lda (DEST),Y
00:9EC6 D0E4            	  1277:   bne ass_lookup_loop   ; not yet
00:9EC8 18              	  1278:   clc
00:9EC9 60              	  1279:   rts
                        	  1280: 
                        	  1281: 
                        	  1282: ass_opcode_found:
00:9ECA A46E            	  1283:   ldy OPCODE_LEN
00:9ECC B103            	  1284:   lda (DEST),Y
00:9ECE 38              	  1285:   sec   ; indicate found
00:9ECF 60              	  1286:   rts
                        	  1287: 
                        	  1288: ass_emit:
00:9ED0 A476            	  1289:   ldy ASS_PASS
00:9ED2 F031            	  1290:   beq ass_emit3  ; only emit codes on 2nd pass
                        	  1291:   ;
                        	  1292:   ;  first time for this line of code, indent by two spaces
                        	  1293:   ;
00:9ED4 A46F            	  1294:   ldy ASS_EMIT_COUNT
00:9ED6 D00C            	  1295:   bne ass_emit2
00:9ED8 A42E            	  1296:   ldy DCODE
00:9EDA F008            	  1297:   beq ass_emit2
00:9EDC 48              	  1298:   pha
00:9EDD 201D93          	  1299:   jsr PUTSP
00:9EE0 201D93          	  1300:   jsr PUTSP
00:9EE3 68              	  1301:   pla
                        	  1302: ass_emit2:
                        	  1303: ;
                        	  1304: ;  if this is the *first* byte we emitted, then make that the start address
                        	  1305: ;  for running the code. That is, if you relocate the code, the first byte
                        	  1306: ;  actually emitted will be considered the runtime address.
                        	  1307: ;
                        	  1308: ;  this lets you relocate code (eg. to $4500) and have it run from there if
                        	  1309: ;  you happen to hit Run.
                        	  1310: ;
00:9EE4 48              	  1311:   pha
00:9EE5 A577            	  1312:   lda ass_emit_bytes
00:9EE7 0578            	  1313:   ora ass_emit_bytes+1
00:9EE9 D008            	  1314:   bne ass_already_emitted
00:9EEB A523            	  1315:   lda PCODE
00:9EED 8525            	  1316:   sta ACT_PCDA
00:9EEF A524            	  1317:   lda PCODE+1
00:9EF1 8526            	  1318:   sta ACT_PCDA+1
                        	  1319: ass_already_emitted:
00:9EF3 68              	  1320:   pla
                        	  1321: ;
                        	  1322: ;  write the byte to memory
                        	  1323: ;
00:9EF4 A000            	  1324:   ldy #0
00:9EF6 9123            	  1325:   sta (PCODE),Y
00:9EF8 E677            	  1326:   inc ass_emit_bytes
00:9EFA D002            	  1327:   bne ass_emit4
00:9EFC E678            	  1328:   inc ass_emit_bytes+1
                        	  1329: ass_emit4:
                        	  1330: 
                        	  1331: ;
                        	  1332: ;  if displaying codes, show the emitted byte
                        	  1333: ;
00:9EFE A42E            	  1334:   ldy DCODE
00:9F00 F003            	  1335:   beq ass_emit3
00:9F02 20A792          	  1336:   jsr DISHX
                        	  1337: ;
                        	  1338: ;  increment the PCODE (output) address
                        	  1339: ;
                        	  1340: ass_emit3:
00:9F05 E623            	  1341:   inc PCODE
00:9F07 D002            	  1342:   bne ass_emit1
00:9F09 E624            	  1343:   inc PCODE+1
                        	  1344: ass_emit1:
00:9F0B E66F            	  1345:   inc ASS_EMIT_COUNT
00:9F0D 60              	  1346:   rts
                        	  1347: 
                        	  1348: ass_error:
00:9F0E A56F            	  1349:   lda ASS_EMIT_COUNT
00:9F10 F003            	  1350:   beq ass_error1
00:9F12 209292          	  1351:   jsr CROUT
                        	  1352: ass_error1:
00:9F15 4CCE97          	  1353:   jmp ERROR
                        	  1354: 
                        	  1355: ass_fixup_bbr_branch:
00:9F18 A507            	  1356:   lda REMAIN+1
00:9F1A D043            	  1357:   bne ass_emit_zero_page_too_high
00:9F1C A508            	  1358:   lda REMAIN+2
00:9F1E D03F            	  1359:   bne ass_emit_zero_page_too_high
00:9F20 A506            	  1360:   lda REMAIN
00:9F22 20D09E          	  1361:   jsr ass_emit  ; output zero page address
                        	  1362: 
                        	  1363: ;
                        	  1364: ;  now fall down and emit the branch
                        	  1365: ;
                        	  1366: 
                        	  1367: ass_fixup_branch:
00:9F25 18              	  1368:   clc         ; I want to subtract one more, so I CLEAR carry <sigh>
00:9F26 A573            	  1369:   lda ASS_VALUE
00:9F28 E523            	  1370:   sbc PCODE
00:9F2A 8573            	  1371:   sta ASS_VALUE
                        	  1372: 
00:9F2C A574            	  1373:   lda ASS_VALUE+1
00:9F2E E524            	  1374:   sbc PCODE+1
00:9F30 C9FF            	  1375:   cmp #$FF  ; backwards branch
00:9F32 F00A            	  1376:   beq ass_branch_backwards
00:9F34 C900            	  1377:   cmp #0
00:9F36 D010            	  1378:   bne ass_branch_out_of_range
00:9F38 A573            	  1379:   lda ASS_VALUE ; must be 0x00 to 0x7F
00:9F3A 300C            	  1380:   bmi ass_branch_out_of_range
00:9F3C 8004            	  1381:   bra ass_branch_ok
                        	  1382: 
                        	  1383: ass_branch_backwards:
00:9F3E A573            	  1384:   lda ASS_VALUE   ; must be 0x80 to 0xFF
00:9F40 1006            	  1385:   bpl ass_branch_out_of_range
                        	  1386: 
                        	  1387: ass_branch_ok:
00:9F42 A573            	  1388:   lda ASS_VALUE
00:9F44 20D09E          	  1389:   jsr ass_emit  ; output relative address
00:9F47 60              	  1390:   rts
                        	  1391: 
                        	  1392: ass_branch_out_of_range:
00:9F48 A576            	  1393:   lda ASS_PASS
00:9F4A F0F6            	  1394:   beq ass_branch_ok   ; out of range is OK on first pass, we don't know how far the branch is
00:9F4C A22A            	  1395:   ldx #42
00:9F4E 4C0E9F          	  1396:   jmp ass_error  ; branch out of range
                        	  1397: 
                        	  1398: ass_emit_zero_page:
00:9F51 A574            	  1399:   lda ASS_VALUE+1
00:9F53 D00A            	  1400:   bne ass_emit_zero_page_too_high
00:9F55 A575            	  1401:   lda ASS_VALUE+2
00:9F57 D006            	  1402:   bne ass_emit_zero_page_too_high
00:9F59 A573            	  1403:   lda ASS_VALUE
00:9F5B 20D09E          	  1404:   jsr ass_emit  ; output zero page address
00:9F5E 60              	  1405:   rts
                        	  1406: 
                        	  1407: 
                        	  1408: ass_emit_zero_page_too_high:
00:9F5F A22B            	  1409:   ldx #43       ; Need zero page address
00:9F61 4C0E9F          	  1410:   jmp ass_error
                        	  1411: 
                        	  1412: ass_emit_immediate:
00:9F64 A574            	  1413:   lda ASS_VALUE+1
00:9F66 D00A            	  1414:   bne ass_emit_immediate_too_high
00:9F68 A575            	  1415:   lda ASS_VALUE+2
00:9F6A D006            	  1416:   bne ass_emit_immediate_too_high
00:9F6C A573            	  1417:   lda ASS_VALUE
00:9F6E 20D09E          	  1418:   jsr ass_emit  ; output immediate operand
00:9F71 60              	  1419:   rts
                        	  1420: 
                        	  1421: ass_emit_immediate_too_high:
00:9F72 A22C            	  1422:   ldx #44
00:9F74 4C0E9F          	  1423:   jmp ass_error
                        	  1424: 
                        	  1425: 
                        	  1426: ass_emit_absolute:
00:9F77 A573            	  1427:   lda ASS_VALUE
00:9F79 20D09E          	  1428:   jsr ass_emit  ; output absolute address - low-order byte
00:9F7C A574            	  1429:   lda ASS_VALUE+1
00:9F7E 20D09E          	  1430:   jsr ass_emit  ; output absolute address - high-order byte
00:9F81 60              	  1431:   rts
                        	  1432: 
                        	  1433: 
                        	  1434: ;------------------------------------
                        	  1435: ;  Opcode master table
                        	  1436: ;------------------------------------
                        	  1437: 
                        	  1438:    .macro makeOpcodeLookup ; table of opcodes, length of opcode, wanted operand type, special handler
                        	  1439:      dfb   \1
                        	  1440:      dfb   \2
                        	  1441:      word  \3
                        	  1442:      word   \4
                        	  1443:    .endmacro
                        	  1444: 
                        	  1445: ;
                        	  1446: ;  So, for an opcode to match, it has to:
                        	  1447: ;     a) be the right length (usually 3 or 4 characters)
                        	  1448: ;     b) have the right type of operand (eg. ASS_OPERAND_IMMEDIATE)
                        	  1449: ;     c) the opcode must match the name in the list
                        	  1450: ;
                        	  1451: ;   If those conditions are met we output the corresponding opcode,
                        	  1452: ;   return with the operand type in A
                        	  1453: ;
                        	  1454: ;   Otherwise, we return 0 in A
                        	  1455: ;
                        	  1456: 
                        	  1457: OPCODE_LOOKUP_OPCODE_LENGTH = 0
                        	  1458: OPCODE_LOOKUP_OPERAND_TYPE = 1
                        	  1459: OPCODE_LOOKUP_OPCODE_TABLE = 2    ; 2 bytes
                        	  1460: OPCODE_LOOKUP_HANDLER = 4         ; 2 bytes
                        	  1461: OPCODE_LOOKUP_TABLE_SIZE = 6      ; all of the above
                        	  1462: 
                        	  1463: OPCODE_LOOKUP_TABLE = *
                        	  1464: ;
                        	  1465: ;  zero-page opcodes go first as they are preferred if we are accessing a zero-page address
                        	  1466: ;
                        	  1467:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE, OPCODE_ASS_OPERAND_ZERO_PAGE, ass_emit_zero_page ; (11)
00:9F82 03              	     1M      dfb   3
00:9F83 0B              	     2M      dfb   ASS_OPERAND_ZERO_PAGE
00:9F84 0FA3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE
00:9F86 519F            	     4M      word   ass_emit_zero_page 
                        	  1468:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE, OPCODE_ASS_OPERAND_ZERO_PAGE_TOKENISED, ass_emit_zero_page ; (11)
00:9F88 01              	     1M      dfb   1
00:9F89 0B              	     2M      dfb   ASS_OPERAND_ZERO_PAGE
00:9F8A 70A3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_TOKENISED
00:9F8C 519F            	     4M      word   ass_emit_zero_page 
                        	  1469:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT, ass_em
00:9F8E 03              	     1M      dfb   3
00:9F8F 0C              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
00:9F90 73A3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
00:9F92 519F            	     4M      word   ass_emit_zero_page 
                        	  1470:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT_TOKENIS
00:9F94 01              	     1M      dfb   1
00:9F95 0C              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
00:9F96 94A3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT_TOKENISED
00:9F98 519F            	     4M      word   ass_emit_zero_page 
                        	  1471:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X, ass_emit_z
00:9F9A 03              	     1M      dfb   3
00:9F9B 0D              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
00:9F9C 97A3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
00:9F9E 519F            	     4M      word   ass_emit_zero_page 
                        	  1472:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X_TOKENISED, 
00:9FA0 01              	     1M      dfb   1
00:9FA1 0D              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
00:9FA2 E0A3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X_TOKENISED
00:9FA4 519F            	     4M      word   ass_emit_zero_page 
                        	  1473:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y, ass_emit_z
00:9FA6 03              	     1M      dfb   3
00:9FA7 0E              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
00:9FA8 E3A3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
00:9FAA 519F            	     4M      word   ass_emit_zero_page 
                        	  1474:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDIRECT, OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT, ass_emit_zero_page ; (
00:9FAC 03              	     1M      dfb   3
00:9FAD 0F              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDIRECT
00:9FAE ECA3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT
00:9FB0 519F            	     4M      word   ass_emit_zero_page 
                        	  1475:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE_INDIRECT, OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_TOKENISED, ass_emit_zer
00:9FB2 01              	     1M      dfb   1
00:9FB3 0F              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDIRECT
00:9FB4 0DA4            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_TOKENISED
00:9FB6 519F            	     4M      word   ass_emit_zero_page 
                        	  1476:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_
00:9FB8 03              	     1M      dfb   3
00:9FB9 10              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
00:9FBA 10A4            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
00:9FBC 519F            	     4M      word   ass_emit_zero_page 
                        	  1477:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_
00:9FBE 01              	     1M      dfb   1
00:9FBF 10              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
00:9FC0 31A4            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y_TOKENISED
00:9FC2 519F            	     4M      word   ass_emit_zero_page 
                        	  1478: 
                        	  1479: ;
                        	  1480: ;  non zero-page opcodes
                        	  1481: ;
                        	  1482:     makeOpcodeLookup  4,  ASS_OPERAND_ABSOLUTE, OPCODE_4_CHAR_ZERO_PAGE,  ass_emit_zero_page  ; (11)
00:9FC4 04              	     1M      dfb   4
00:9FC5 01              	     2M      dfb   ASS_OPERAND_ABSOLUTE
00:9FC6 8BA1            	     3M      word  OPCODE_4_CHAR_ZERO_PAGE
00:9FC8 519F            	     4M      word   ass_emit_zero_page  
                        	  1483:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE, OPCODE_ASS_OPERAND_ABSOLUTE,  ass_emit_absolute  ; (1)
00:9FCA 03              	     1M      dfb   3
00:9FCB 01              	     2M      dfb   ASS_OPERAND_ABSOLUTE
00:9FCC DCA1            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE
00:9FCE 779F            	     4M      word   ass_emit_absolute  
                        	  1484:     makeOpcodeLookup  1,  ASS_OPERAND_ABSOLUTE, OPCODE_ASS_OPERAND_ABSOLUTE_TOKENISED,  ass_emit_absolute  ; (1)
00:9FD0 01              	     1M      dfb   1
00:9FD1 01              	     2M      dfb   ASS_OPERAND_ABSOLUTE
00:9FD2 45A2            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_TOKENISED
00:9FD4 779F            	     4M      word   ass_emit_absolute  
                        	  1485: 
                        	  1486:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT, ass_emit
00:9FD6 03              	     1M      dfb   3
00:9FD7 02              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
00:9FD8 48A2            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
00:9FDA 779F            	     4M      word   ass_emit_absolute 
                        	  1487:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X, ass_emit_abs
00:9FDC 03              	     1M      dfb   3
00:9FDD 03              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
00:9FDE 4DA2            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
00:9FE0 779F            	     4M      word   ass_emit_absolute 
                        	  1488:     makeOpcodeLookup  1,  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X_TOKENISED, as
00:9FE2 01              	     1M      dfb   1
00:9FE3 03              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
00:9FE4 92A2            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X_TOKENISED
00:9FE6 779F            	     4M      word   ass_emit_absolute 
                        	  1489:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y, ass_emit_abs
00:9FE8 03              	     1M      dfb   3
00:9FE9 04              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
00:9FEA 95A2            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
00:9FEC 779F            	     4M      word   ass_emit_absolute 
                        	  1490:     makeOpcodeLookup  1,  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y_TOKENISED, as
00:9FEE 01              	     1M      dfb   1
00:9FEF 04              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
00:9FF0 BAA2            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y_TOKENISED
00:9FF2 779F            	     4M      word   ass_emit_absolute 
                        	  1491:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDIRECT, OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT, ass_emit_absolute ; (5)
00:9FF4 03              	     1M      dfb   3
00:9FF5 05              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDIRECT
00:9FF6 D6A2            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT
00:9FF8 779F            	     4M      word   ass_emit_absolute 
                        	  1492:     makeOpcodeLookup  1,  ASS_OPERAND_ABSOLUTE_INDIRECT, OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED, ass_emit_absolute ; (5
00:9FFA 01              	     1M      dfb   1
00:9FFB 05              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDIRECT
00:9FFC 0CA3            	     3M      word  OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED
00:9FFE 779F            	     4M      word   ass_emit_absolute 
                        	  1493:     makeOpcodeLookup  3,  ASS_OPERAND_ACCUMULATOR_A, OPCODE_ASS_OPERAND_ACCUMULATOR_A, 0 ; (6)
00:A000 03              	     1M      dfb   3
00:A001 06              	     2M      dfb   ASS_OPERAND_ACCUMULATOR_A
00:A002 BDA2            	     3M      word  OPCODE_ASS_OPERAND_ACCUMULATOR_A
00:A004 0000            	     4M      word   0 
                        	  1494:     makeOpcodeLookup  3,  ASS_OPERAND_IMMEDIATE, OPCODE_ASS_OPERAND_IMMEDIATE, ass_emit_immediate ; (7)
00:A006 03              	     1M      dfb   3
00:A007 07              	     2M      dfb   ASS_OPERAND_IMMEDIATE
00:A008 DBA2            	     3M      word  OPCODE_ASS_OPERAND_IMMEDIATE
00:A00A 649F            	     4M      word   ass_emit_immediate 
                        	  1495:     makeOpcodeLookup  1,  ASS_OPERAND_IMMEDIATE, OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED, ass_emit_immediate ; (7)
00:A00C 01              	     1M      dfb   1
00:A00D 07              	     2M      dfb   ASS_OPERAND_IMMEDIATE
00:A00E 0CA3            	     3M      word  OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED
00:A010 649F            	     4M      word   ass_emit_immediate 
                        	  1496:     makeOpcodeLookup  3,  ASS_OPERAND_IMPLIED,  OPCODE_3_CHAR_IMPLIED,    0  ; (8) and (10)
00:A012 03              	     1M      dfb   3
00:A013 08              	     2M      dfb   ASS_OPERAND_IMPLIED
00:A014 0EA1            	     3M      word  OPCODE_3_CHAR_IMPLIED
00:A016 0000            	     4M      word   0  
                        	  1497:     makeOpcodeLookup  4,  ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE, OPCODE_4_CHAR_BRANCH,     ass_fixup_bbr_branch  ; (9)
00:A018 04              	     1M      dfb   4
00:A019 12              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE
00:A01A 98A0            	     3M      word  OPCODE_4_CHAR_BRANCH
00:A01C 189F            	     4M      word   ass_fixup_bbr_branch  
                        	  1498:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE, OPCODE_3_CHAR_BRANCH,     ass_fixup_branch  ; (9)
00:A01E 03              	     1M      dfb   3
00:A01F 01              	     2M      dfb   ASS_OPERAND_ABSOLUTE
00:A020 E9A0            	     3M      word  OPCODE_3_CHAR_BRANCH
00:A022 259F            	     4M      word   ass_fixup_branch  
00:A024 00              	  1499:     dfb 0
                        	  1500: 
                        	  1501: 
                        	  1502: ;------------------------------------
                        	  1503: ;  directives
                        	  1504: ;------------------------------------
                        	  1505: 
                        	  1506: 
                        	  1507: DIRECTIVES = *
                        	  1508:   makeHandler "ASSERT",   asm_do_assert
00:A025 415353455254    	     1M    asciiz   "ASSERT"
00:A02B 00
00:A02C 34A4            	     2M    word  asm_do_assert
                        	  1509:   makeHandler "LIST",     asm_do_list
00:A02E 4C495354        	     1M    asciiz   "LIST"
00:A032 00
00:A033 4BA4            	     2M    word  asm_do_list
                        	  1510:   makeHandler "NOLIST",   asm_do_nolist
00:A035 4E4F4C495354    	     1M    asciiz   "NOLIST"
00:A03B 00
00:A03C 5AA4            	     2M    word  asm_do_nolist
                        	  1511:   makeHandler "ASC",      asm_do_asc
00:A03E 415343          	     1M    asciiz   "ASC"
00:A041 00
00:A042 99A4            	     2M    word  asm_do_asc
                        	  1512:   makeHandler "ASCII",    asm_do_asc
00:A044 4153434949      	     1M    asciiz   "ASCII"
00:A049 00
00:A04A 99A4            	     2M    word  asm_do_asc
                        	  1513:   makeHandler "ASCIIZ",   asm_do_string
00:A04C 41534349495A    	     1M    asciiz   "ASCIIZ"
00:A052 00
00:A053 B4A4            	     2M    word  asm_do_string
                        	  1514:   makeHandler "STRING",   asm_do_string
00:A055 535452494E47    	     1M    asciiz   "STRING"
00:A05B 00
00:A05C B4A4            	     2M    word  asm_do_string
                        	  1515:   makeHandler "EQU",      asm_do_equ
00:A05E 455155          	     1M    asciiz   "EQU"
00:A061 00
00:A062 BDA4            	     2M    word  asm_do_equ
                        	  1516:   makeHandler "=",        asm_do_equ
00:A064 3D              	     1M    asciiz   "="
00:A065 00
00:A066 BDA4            	     2M    word  asm_do_equ
                        	  1517:   makeHandler "ORG",      asm_do_org
00:A068 4F5247          	     1M    asciiz   "ORG"
00:A06B 00
00:A06C DAA4            	     2M    word  asm_do_org
                        	  1518:   makeHandler "DFB",      asm_do_dfb
00:A06E 444642          	     1M    asciiz   "DFB"
00:A071 00
00:A072 EEA4            	     2M    word  asm_do_dfb
                        	  1519:   makeHandler "DFW",      asm_do_dfw
00:A074 444657          	     1M    asciiz   "DFW"
00:A077 00
00:A078 2EA5            	     2M    word  asm_do_dfw
                        	  1520:   makeHandler "WORD",     asm_do_dfw
00:A07A 574F5244        	     1M    asciiz   "WORD"
00:A07E 00
00:A07F 2EA5            	     2M    word  asm_do_dfw
                        	  1521:   makeHandler "BLK",      asm_do_blk
00:A081 424C4B          	     1M    asciiz   "BLK"
00:A084 00
00:A085 6BA5            	     2M    word  asm_do_blk
                        	  1522:   makeHandler "RESERVE",  asm_do_reserve
00:A087 52455345525645  	     1M    asciiz   "RESERVE"
00:A08E 00
00:A08F 89A5            	     2M    word  asm_do_reserve
                        	  1523:   makeHandler "SYM",      asm_do_sym
00:A091 53594D          	     1M    asciiz   "SYM"
00:A094 00
00:A095 A4A5            	     2M    word  asm_do_sym
                        	  1524: 
00:A097 00              	  1525:   dfb 0
                        	  1526: 
                        	  1527: ;------------------------------------
                        	  1528: ;  4-character branch opcodes
                        	  1529: ;------------------------------------
                        	  1530: 
                        	  1531: 
                        	  1532: OPCODE_4_CHAR_BRANCH = *
00:A098 42425230        	  1533:   asc "BBR0",$0F
00:A09C 0F
00:A09D 42425231        	  1534:   asc "BBR1",$1F
00:A0A1 1F
00:A0A2 42425232        	  1535:   asc "BBR2",$2F
00:A0A6 2F
00:A0A7 42425233        	  1536:   asc "BBR3",$3F
00:A0AB 3F
00:A0AC 42425234        	  1537:   asc "BBR4",$4F
00:A0B0 4F
00:A0B1 42425235        	  1538:   asc "BBR5",$5F
00:A0B5 5F
00:A0B6 42425236        	  1539:   asc "BBR6",$6F
00:A0BA 6F
00:A0BB 42425237        	  1540:   asc "BBR7",$7F
00:A0BF 7F
00:A0C0 42425330        	  1541:   asc "BBS0",$8F
00:A0C4 8F
00:A0C5 42425331        	  1542:   asc "BBS1",$9F
00:A0C9 9F
00:A0CA 42425332        	  1543:   asc "BBS2",$AF
00:A0CE AF
00:A0CF 42425333        	  1544:   asc "BBS3",$BF
00:A0D3 BF
00:A0D4 42425334        	  1545:   asc "BBS4",$CF
00:A0D8 CF
00:A0D9 42425335        	  1546:   asc "BBS5",$DF
00:A0DD DF
00:A0DE 42425336        	  1547:   asc "BBS6",$EF
00:A0E2 EF
00:A0E3 42425337        	  1548:   asc "BBS7",$FF
00:A0E7 FF
00:A0E8 00              	  1549:   dfb 0
                        	  1550: 
                        	  1551: ;------------------------------------
                        	  1552: ;  3-character branch opcodes
                        	  1553: ;------------------------------------
                        	  1554: 
                        	  1555: 
                        	  1556: OPCODE_3_CHAR_BRANCH = *
00:A0E9 424343          	  1557:   asc "BCC",$90
00:A0EC 90
00:A0ED 424353          	  1558:   asc "BCS",$B0
00:A0F0 B0
00:A0F1 424551          	  1559:   asc "BEQ",$F0
00:A0F4 F0
00:A0F5 424D49          	  1560:   asc "BMI",$30
00:A0F8 30
00:A0F9 424E45          	  1561:   asc "BNE",$D0
00:A0FC D0
00:A0FD 42504C          	  1562:   asc "BPL",$10
00:A100 10
00:A101 425241          	  1563:   asc "BRA",$80
00:A104 80
00:A105 425643          	  1564:   asc "BVC",$50
00:A108 50
00:A109 425653          	  1565:   asc "BVS",$70
00:A10C 70
00:A10D 00              	  1566:   dfb 0
                        	  1567: 
                        	  1568: 
                        	  1569: ;------------------------------------
                        	  1570: ;  3-character implied opcodes (no operand)
                        	  1571: ;------------------------------------
                        	  1572: 
                        	  1573: OPCODE_3_CHAR_IMPLIED = *
00:A10E 42524B          	  1574:   asc "BRK",$00
00:A111 00
00:A112 434C43          	  1575:   asc "CLC",$18
00:A115 18
00:A116 434C44          	  1576:   asc "CLD",$D8
00:A119 D8
00:A11A 434C49          	  1577:   asc "CLI",$58
00:A11D 58
00:A11E 434C56          	  1578:   asc "CLV",$B8
00:A121 B8
00:A122 444558          	  1579:   asc "DEX",$CA
00:A125 CA
00:A126 444559          	  1580:   asc "DEY",$88
00:A129 88
00:A12A 494E58          	  1581:   asc "INX",$E8
00:A12D E8
00:A12E 494E59          	  1582:   asc "INY",$C8
00:A131 C8
00:A132 4E4F50          	  1583:   asc "NOP",$EA
00:A135 EA
00:A136 504841          	  1584:   asc "PHA",$48
00:A139 48
00:A13A 504850          	  1585:   asc "PHP",$08
00:A13D 08
00:A13E 504858          	  1586:   asc "PHX",$DA
00:A141 DA
00:A142 504859          	  1587:   asc "PHY",$5A
00:A145 5A
00:A146 504C41          	  1588:   asc "PLA",$68
00:A149 68
00:A14A 504C50          	  1589:   asc "PLP",$28
00:A14D 28
00:A14E 504C58          	  1590:   asc "PLX",$FA
00:A151 FA
00:A152 504C59          	  1591:   asc "PLY",$7A
00:A155 7A
00:A156 525449          	  1592:   asc "RTI",$40
00:A159 40
00:A15A 525453          	  1593:   asc "RTS",$60
00:A15D 60
00:A15E 534543          	  1594:   asc "SEC",$38
00:A161 38
00:A162 534544          	  1595:   asc "SED",$F8
00:A165 F8
00:A166 534549          	  1596:   asc "SEI",$78
00:A169 78
00:A16A 535450          	  1597:   asc "STP",$DB
00:A16D DB
00:A16E 544158          	  1598:   asc "TAX",$AA
00:A171 AA
00:A172 544159          	  1599:   asc "TAY",$A8
00:A175 A8
00:A176 545358          	  1600:   asc "TSX",$BA
00:A179 BA
00:A17A 545841          	  1601:   asc "TXA",$8A
00:A17D 8A
00:A17E 545853          	  1602:   asc "TXS",$9A
00:A181 9A
00:A182 545941          	  1603:   asc "TYA",$98
00:A185 98
00:A186 574149          	  1604:   asc "WAI",$CB
00:A189 CB
00:A18A 00              	  1605:   dfb 0
                        	  1606: 
                        	  1607: ;------------------------------------
                        	  1608: ;  4-character zero page opcodes (operand must be zero-page address)
                        	  1609: ;------------------------------------
                        	  1610: OPCODE_4_CHAR_ZERO_PAGE = *
00:A18B 534D4230        	  1611:   asc "SMB0",$87
00:A18F 87
00:A190 534D4231        	  1612:   asc "SMB1",$97
00:A194 97
00:A195 534D4232        	  1613:   asc "SMB2",$A7
00:A199 A7
00:A19A 534D4233        	  1614:   asc "SMB3",$B7
00:A19E B7
00:A19F 534D4234        	  1615:   asc "SMB4",$C7
00:A1A3 C7
00:A1A4 534D4235        	  1616:   asc "SMB5",$D7
00:A1A8 D7
00:A1A9 534D4236        	  1617:   asc "SMB6",$E7
00:A1AD E7
00:A1AE 534D4237        	  1618:   asc "SMB7",$F7
00:A1B2 F7
00:A1B3 524D4230        	  1619:   asc "RMB0",$07
00:A1B7 07
00:A1B8 524D4231        	  1620:   asc "RMB1",$17
00:A1BC 17
00:A1BD 524D4232        	  1621:   asc "RMB2",$27
00:A1C1 27
00:A1C2 524D4233        	  1622:   asc "RMB3",$37
00:A1C6 37
00:A1C7 524D4234        	  1623:   asc "RMB4",$47
00:A1CB 47
00:A1CC 524D4235        	  1624:   asc "RMB5",$57
00:A1D0 57
00:A1D1 524D4236        	  1625:   asc "RMB6",$67
00:A1D5 67
00:A1D6 524D4237        	  1626:   asc "RMB7",$77
00:A1DA 77
00:A1DB 00              	  1627:   dfb 0
                        	  1628: 
                        	  1629: ;------------------------------------
                        	  1630: ;  ASS_OPERAND_ABSOLUTE
                        	  1631: ;------------------------------------
                        	  1632: OPCODE_ASS_OPERAND_ABSOLUTE = *
00:A1DC 414443          	  1633:   asc "ADC",$6D
00:A1DF 6D
00:A1E0 414E44          	  1634:   asc "AND",$2D
00:A1E3 2D
00:A1E4 41534C          	  1635:   asc "ASL",$0E
00:A1E7 0E
00:A1E8 424954          	  1636:   asc "BIT",$2C
00:A1EB 2C
00:A1EC 434D50          	  1637:   asc "CMP",$CD
00:A1EF CD
00:A1F0 435058          	  1638:   asc "CPX",$EC
00:A1F3 EC
00:A1F4 435059          	  1639:   asc "CPY",$CC
00:A1F7 CC
00:A1F8 444543          	  1640:   asc "DEC",$CE
00:A1FB CE
00:A1FC 454F52          	  1641:   asc "EOR",$4D
00:A1FF 4D
00:A200 494E43          	  1642:   asc "INC",$EE
00:A203 EE
00:A204 4A4D50          	  1643:   asc "JMP",$4C
00:A207 4C
00:A208 4A5352          	  1644:   asc "JSR",$20
00:A20B 20
00:A20C 4C4441          	  1645:   asc "LDA",$AD
00:A20F AD
00:A210 4C4458          	  1646:   asc "LDX",$AE
00:A213 AE
00:A214 4C4459          	  1647:   asc "LDY",$AC
00:A217 AC
00:A218 4C5352          	  1648:   asc "LSR",$4E
00:A21B 4E
00:A21C 4F5241          	  1649:   asc "ORA",$0D
00:A21F 0D
00:A220 524F4C          	  1650:   asc "ROL",$2E
00:A223 2E
00:A224 524F52          	  1651:   asc "ROR",$6E
00:A227 6E
00:A228 534243          	  1652:   asc "SBC",$ED
00:A22B ED
00:A22C 535441          	  1653:   asc "STA",$8D
00:A22F 8D
00:A230 535458          	  1654:   asc "STX",$8E
00:A233 8E
00:A234 535459          	  1655:   asc "STY",$8C
00:A237 8C
00:A238 53545A          	  1656:   asc "STZ",$9C
00:A23B 9C
00:A23C 545242          	  1657:   asc "TRB",$1C
00:A23F 1C
00:A240 545342          	  1658:   asc "TSB",$0C
00:A243 0C
00:A244 00              	  1659:   dfb 0
                        	  1660: 
                        	  1661: ;------------------------------------
                        	  1662: ;  ASS_OPERAND_ABSOLUTE - for tokenised opcodes like AND
                        	  1663: ;------------------------------------
                        	  1664: OPCODE_ASS_OPERAND_ABSOLUTE_TOKENISED = *
00:A245 8D              	  1665:   dfb TOKEN_AND,$2D
00:A246 2D
00:A247 00              	  1666:   dfb 0
                        	  1667: 
                        	  1668: 
                        	  1669: ;------------------------------------
                        	  1670: ;  ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
                        	  1671: ;------------------------------------
                        	  1672: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT = *
00:A248 4A4D50          	  1673:   asc "JMP",$7C
00:A24B 7C
00:A24C 00              	  1674:   dfb 0
                        	  1675: 
                        	  1676: ;------------------------------------
                        	  1677: ;  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
                        	  1678: ;------------------------------------
                        	  1679: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X = *
00:A24D 414443          	  1680:   asc "ADC",$7D
00:A250 7D
00:A251 414E44          	  1681:   asc "AND",$3D
00:A254 3D
00:A255 41534C          	  1682:   asc "ASL",$1E
00:A258 1E
00:A259 424954          	  1683:   asc "BIT",$3C
00:A25C 3C
00:A25D 434D50          	  1684:   asc "CMP",$DD
00:A260 DD
00:A261 444543          	  1685:   asc "DEC",$DE
00:A264 DE
00:A265 454F52          	  1686:   asc "EOR",$5D
00:A268 5D
00:A269 494E43          	  1687:   asc "INC",$FE
00:A26C FE
00:A26D 4C4441          	  1688:   asc "LDA",$BD
00:A270 BD
00:A271 4C4459          	  1689:   asc "LDY",$BC
00:A274 BC
00:A275 4C5352          	  1690:   asc "LSR",$5E
00:A278 5E
00:A279 4F5241          	  1691:   asc "ORA",$1D
00:A27C 1D
00:A27D 524F4C          	  1692:   asc "ROL",$3E
00:A280 3E
00:A281 524F52          	  1693:   asc "ROR",$7E
00:A284 7E
00:A285 534243          	  1694:   asc "SBC",$FD
00:A288 FD
00:A289 535441          	  1695:   asc "STA",$9D
00:A28C 9D
00:A28D 53545A          	  1696:   asc "STZ",$9E
00:A290 9E
00:A291 00              	  1697:   dfb 0
                        	  1698: 
                        	  1699: ;------------------------------------
                        	  1700: ;  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X - for tokenised opcodes like AND
                        	  1701: ;------------------------------------
                        	  1702: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X_TOKENISED = *
00:A292 8D              	  1703:   dfb TOKEN_AND,$3D
00:A293 3D
00:A294 00              	  1704:   dfb 0
                        	  1705: 
                        	  1706: ;------------------------------------
                        	  1707: ;  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
                        	  1708: ;------------------------------------
                        	  1709: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y = *
00:A295 414443          	  1710:   asc "ADC",$79
00:A298 79
00:A299 414E44          	  1711:   asc "AND",$39
00:A29C 39
00:A29D 434D50          	  1712:   asc "CMP",$D9
00:A2A0 D9
00:A2A1 454F52          	  1713:   asc "EOR",$59
00:A2A4 59
00:A2A5 4C4441          	  1714:   asc "LDA",$B9
00:A2A8 B9
00:A2A9 4C4458          	  1715:   asc "LDX",$BE
00:A2AC BE
00:A2AD 4F5241          	  1716:   asc "ORA",$19
00:A2B0 19
00:A2B1 534243          	  1717:   asc "SBC",$F9
00:A2B4 F9
00:A2B5 535441          	  1718:   asc "STA",$99
00:A2B8 99
00:A2B9 00              	  1719:   dfb 0
                        	  1720: 
                        	  1721: ;------------------------------------
                        	  1722: ;  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y - for tokenised opcodes like AND
                        	  1723: ;------------------------------------
                        	  1724: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y_TOKENISED = *
00:A2BA 8D              	  1725:   dfb TOKEN_AND,$39
00:A2BB 39
00:A2BC 00              	  1726:   dfb 0
                        	  1727: 
                        	  1728: ;------------------------------------
                        	  1729: ;  ASS_OPERAND_ACCUMULATOR_A
                        	  1730: ;------------------------------------
                        	  1731: OPCODE_ASS_OPERAND_ACCUMULATOR_A = *
00:A2BD 41534C          	  1732:   asc "ASL",$0A
00:A2C0 0A
00:A2C1 444543          	  1733:   asc "DEC",$3A
00:A2C4 3A
00:A2C5 494E43          	  1734:   asc "INC",$1A
00:A2C8 1A
00:A2C9 4C5352          	  1735:   asc "LSR",$4A
00:A2CC 4A
00:A2CD 524F4C          	  1736:   asc "ROL",$2A
00:A2D0 2A
00:A2D1 524F52          	  1737:   asc "ROR",$6A
00:A2D4 6A
00:A2D5 00              	  1738:   dfb 0
                        	  1739: 
                        	  1740: ;------------------------------------
                        	  1741: ;  ASS_OPERAND_ABSOLUTE_INDIRECT
                        	  1742: ;------------------------------------
                        	  1743: OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT = *
00:A2D6 4A4D50          	  1744:   asc "JMP",$6C
00:A2D9 6C
00:A2DA 00              	  1745:   dfb 0
                        	  1746: 
                        	  1747: ;------------------------------------
                        	  1748: ;  ASS_OPERAND_IMMEDIATE
                        	  1749: ;------------------------------------
                        	  1750: OPCODE_ASS_OPERAND_IMMEDIATE = *
00:A2DB 414443          	  1751:   asc "ADC",$69
00:A2DE 69
00:A2DF 414E44          	  1752:   asc "AND",$29
00:A2E2 29
00:A2E3 424954          	  1753:   asc "BIT",$89
00:A2E6 89
00:A2E7 434D50          	  1754:   asc "CMP",$C9
00:A2EA C9
00:A2EB 435058          	  1755:   asc "CPX",$E0
00:A2EE E0
00:A2EF 435059          	  1756:   asc "CPY",$C0
00:A2F2 C0
00:A2F3 454F52          	  1757:   asc "EOR",$49
00:A2F6 49
00:A2F7 4C4441          	  1758:   asc "LDA",$A9
00:A2FA A9
00:A2FB 4C4458          	  1759:   asc "LDX",$A2
00:A2FE A2
00:A2FF 4C4459          	  1760:   asc "LDY",$A0
00:A302 A0
00:A303 4F5241          	  1761:   asc "ORA",$09
00:A306 09
00:A307 534243          	  1762:   asc "SBC",$E9
00:A30A E9
00:A30B 00              	  1763:   dfb 0
                        	  1764: 
                        	  1765: ;------------------------------------
                        	  1766: ;  ASS_OPERAND_IMMEDIATE - for tokenised opcodes like AND
                        	  1767: ;------------------------------------
                        	  1768: OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED = *
00:A30C 8D              	  1769:   dfb TOKEN_AND,$29
00:A30D 29
00:A30E 00              	  1770:   dfb 0
                        	  1771: 
                        	  1772: ;------------------------------------
                        	  1773: ;  ASS_OPERAND_ZERO_PAGE
                        	  1774: ;------------------------------------
                        	  1775: OPCODE_ASS_OPERAND_ZERO_PAGE = *
00:A30F 414443          	  1776:   asc "ADC",$65
00:A312 65
00:A313 414E44          	  1777:   asc "AND",$25
00:A316 25
00:A317 41534C          	  1778:   asc "ASL",$06
00:A31A 06
00:A31B 424954          	  1779:   asc "BIT",$24
00:A31E 24
00:A31F 434D50          	  1780:   asc "CMP",$C5
00:A322 C5
00:A323 435058          	  1781:   asc "CPX",$E4
00:A326 E4
00:A327 435059          	  1782:   asc "CPY",$C4
00:A32A C4
00:A32B 444543          	  1783:   asc "DEC",$C6
00:A32E C6
00:A32F 454F52          	  1784:   asc "EOR",$45
00:A332 45
00:A333 494E43          	  1785:   asc "INC",$E6
00:A336 E6
00:A337 4C4441          	  1786:   asc "LDA",$A5
00:A33A A5
00:A33B 4C4458          	  1787:   asc "LDX",$A6
00:A33E A6
00:A33F 4C4459          	  1788:   asc "LDY",$A4
00:A342 A4
00:A343 4C5352          	  1789:   asc "LSR",$46
00:A346 46
00:A347 4F5241          	  1790:   asc "ORA",$05
00:A34A 05
00:A34B 524F4C          	  1791:   asc "ROL",$26
00:A34E 26
00:A34F 524F52          	  1792:   asc "ROR",$66
00:A352 66
00:A353 534243          	  1793:   asc "SBC",$E5
00:A356 E5
00:A357 535441          	  1794:   asc "STA",$85
00:A35A 85
00:A35B 535458          	  1795:   asc "STX",$86
00:A35E 86
00:A35F 535459          	  1796:   asc "STY",$84
00:A362 84
00:A363 53545A          	  1797:   asc "STZ",$64
00:A366 64
00:A367 545242          	  1798:   asc "TRB",$14
00:A36A 14
00:A36B 545342          	  1799:   asc "TSB",$04
00:A36E 04
00:A36F 00              	  1800:   dfb 0
                        	  1801: 
                        	  1802: ;------------------------------------
                        	  1803: ;  ASS_OPERAND_ZERO_PAGE  - for tokenised opcodes like AND
                        	  1804: ;------------------------------------
                        	  1805: OPCODE_ASS_OPERAND_ZERO_PAGE_TOKENISED = *
00:A370 8D              	  1806:   dfb TOKEN_AND,$25
00:A371 25
00:A372 00              	  1807:   dfb 0
                        	  1808: 
                        	  1809: 
                        	  1810: ;------------------------------------
                        	  1811: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
                        	  1812: ;------------------------------------
                        	  1813: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT = *
00:A373 414443          	  1814:   asc "ADC",$61
00:A376 61
00:A377 414E44          	  1815:   asc "AND",$21
00:A37A 21
00:A37B 434D50          	  1816:   asc "CMP",$C1
00:A37E C1
00:A37F 454F52          	  1817:   asc "EOR",$41
00:A382 41
00:A383 4C4441          	  1818:   asc "LDA",$A1
00:A386 A1
00:A387 4F5241          	  1819:   asc "ORA",$01
00:A38A 01
00:A38B 534243          	  1820:   asc "SBC",$E1
00:A38E E1
00:A38F 535441          	  1821:   asc "STA",$81
00:A392 81
00:A393 00              	  1822:   dfb 0
                        	  1823: 
                        	  1824: ;------------------------------------
                        	  1825: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT  - for tokenised opcodes like AND
                        	  1826: ;------------------------------------
                        	  1827: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT_TOKENISED  = *
00:A394 8D              	  1828:   dfb TOKEN_AND,$21
00:A395 21
00:A396 00              	  1829:   dfb 0
                        	  1830: 
                        	  1831: 
                        	  1832: ;------------------------------------
                        	  1833: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
                        	  1834: ;------------------------------------
                        	  1835: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X = *
00:A397 414443          	  1836:   asc "ADC",$75
00:A39A 75
00:A39B 414E44          	  1837:   asc "AND",$35
00:A39E 35
00:A39F 41534C          	  1838:   asc "ASL",$16
00:A3A2 16
00:A3A3 424954          	  1839:   asc "BIT",$34
00:A3A6 34
00:A3A7 434D50          	  1840:   asc "CMP",$D5
00:A3AA D5
00:A3AB 444543          	  1841:   asc "DEC",$D6
00:A3AE D6
00:A3AF 454F52          	  1842:   asc "EOR",$55
00:A3B2 55
00:A3B3 494E43          	  1843:   asc "INC",$F6
00:A3B6 F6
00:A3B7 4C4441          	  1844:   asc "LDA",$B5
00:A3BA B5
00:A3BB 4C4459          	  1845:   asc "LDY",$B4
00:A3BE B4
00:A3BF 4C5352          	  1846:   asc "LSR",$56
00:A3C2 56
00:A3C3 4F5241          	  1847:   asc "ORA",$15
00:A3C6 15
00:A3C7 524F4C          	  1848:   asc "ROL",$36
00:A3CA 36
00:A3CB 524F52          	  1849:   asc "ROR",$76
00:A3CE 76
00:A3CF 534243          	  1850:   asc "SBC",$F5
00:A3D2 F5
00:A3D3 535441          	  1851:   asc "STA",$95
00:A3D6 95
00:A3D7 535459          	  1852:   asc "STY",$94
00:A3DA 94
00:A3DB 53545A          	  1853:   asc "STZ",$74
00:A3DE 74
00:A3DF 00              	  1854:   dfb 0
                        	  1855: 
                        	  1856: ;------------------------------------
                        	  1857: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X  - for tokenised opcodes like AND
                        	  1858: ;------------------------------------
                        	  1859: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X_TOKENISED = *
00:A3E0 8D              	  1860:   dfb TOKEN_AND,$35
00:A3E1 35
00:A3E2 00              	  1861:   dfb 0
                        	  1862: 
                        	  1863: ;------------------------------------
                        	  1864: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
                        	  1865: ;------------------------------------
                        	  1866: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y = *
00:A3E3 4C4458          	  1867:   asc "LDX",$B6
00:A3E6 B6
00:A3E7 535458          	  1868:   asc "STX",$96
00:A3EA 96
00:A3EB 00              	  1869:   dfb 0
                        	  1870: 
                        	  1871: ;------------------------------------
                        	  1872: ;  ASS_OPERAND_ZERO_PAGE_INDIRECT
                        	  1873: ;------------------------------------
                        	  1874: OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT = *
00:A3EC 414443          	  1875:   asc "ADC",$72
00:A3EF 72
00:A3F0 414E44          	  1876:   asc "AND",$32
00:A3F3 32
00:A3F4 434D50          	  1877:   asc "CMP",$D2
00:A3F7 D2
00:A3F8 454F52          	  1878:   asc "EOR",$52
00:A3FB 52
00:A3FC 4C4441          	  1879:   asc "LDA",$B2
00:A3FF B2
00:A400 4F5241          	  1880:   asc "ORA",$12
00:A403 12
00:A404 534243          	  1881:   asc "SBC",$F2
00:A407 F2
00:A408 535441          	  1882:   asc "STA",$92
00:A40B 92
00:A40C 00              	  1883:   dfb 0
                        	  1884: 
                        	  1885: ;------------------------------------
                        	  1886: ;  ASS_OPERAND_ZERO_PAGE_INDIRECT  - for tokenised opcodes like AND
                        	  1887: ;------------------------------------
                        	  1888: OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_TOKENISED = *
00:A40D 8D              	  1889:   dfb TOKEN_AND,$32
00:A40E 32
00:A40F 00              	  1890:   dfb 0
                        	  1891: 
                        	  1892: ;------------------------------------
                        	  1893: ;  ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
                        	  1894: ;------------------------------------
                        	  1895: OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y = *
00:A410 414443          	  1896:   asc "ADC",$71
00:A413 71
00:A414 414E44          	  1897:   asc "AND",$31
00:A417 31
00:A418 434D50          	  1898:   asc "CMP",$D1
00:A41B D1
00:A41C 454F52          	  1899:   asc "EOR",$51
00:A41F 51
00:A420 4C4441          	  1900:   asc "LDA",$B1
00:A423 B1
00:A424 4F5241          	  1901:   asc "ORA",$11
00:A427 11
00:A428 534243          	  1902:   asc "SBC",$F1
00:A42B F1
00:A42C 535441          	  1903:   asc "STA",$91
00:A42F 91
00:A430 00              	  1904:   dfb 0
                        	  1905: 
                        	  1906: ;------------------------------------
                        	  1907: ;  ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y - for tokenised opcodes like AND
                        	  1908: ;------------------------------------
                        	  1909: OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y_TOKENISED  = *
00:A431 8D              	  1910:   dfb TOKEN_AND,$31
00:A432 31
00:A433 00              	  1911:   dfb 0
                        	  1912: 
                        	  1913: 
                        	  1914: ; ---------------------------
                        	  1915: ; Compiler directives
                        	  1916: ; ---------------------------
                        	  1917: 
                        	  1918: ;
                        	  1919: ;  ASSERT <expression>  - raises an error if <expression> is zero
                        	  1920: ;
                        	  1921: asm_do_assert:
00:A434 A56B            	  1922:   lda ASS_OPERAND
00:A436 C901            	  1923:   cmp #ASS_OPERAND_ABSOLUTE
00:A438 D00E            	  1924:   bne asm_do_constant_expectedJ
00:A43A A500            	  1925:   lda VALUE
00:A43C 0501            	  1926:   ora VALUE+1
00:A43E 0502            	  1927:   ora VALUE+2
00:A440 F001            	  1928:   beq asm_do_assert_failed
00:A442 60              	  1929:   rts
                        	  1930: 
                        	  1931: asm_do_assert_failed:
00:A443 A234            	  1932:   ldx #52
00:A445 4C0E9F          	  1933:   jmp ass_error
                        	  1934: 
00:A448 4CE0A4          	  1935: asm_do_constant_expectedJ jmp asm_do_constant_expected
                        	  1936: 
                        	  1937: ;
                        	  1938: ; LIST (0= none, 1=source, 2=opcodes, 4=symbols, can OR these together)
                        	  1939: ; LIST  is the same as LIST 3
                        	  1940: 
                        	  1941: asm_do_list = *
                        	  1942: 
                        	  1943: ;   lda #'f'
                        	  1944: ;   jsr ass_debug_point
                        	  1945: 
00:A44B A56B            	  1946:   lda ASS_OPERAND
00:A44D C908            	  1947:   cmp #ASS_OPERAND_IMPLIED      ; implied (ie. no operand) will resolve to be the same as LIST 3
00:A44F F01A            	  1948:   beq asm_do_list_no_operand
00:A451 C901            	  1949:   cmp #ASS_OPERAND_ABSOLUTE
00:A453 F01A            	  1950:   beq asm_do_list_ok
00:A455 A202            	  1951:   ldx #2    ; ERROR: constant expected
00:A457 4C0E9F          	  1952:   jmp ass_error
                        	  1953: 
                        	  1954: ;
                        	  1955: ;  NOLIST is the same as LIST 0
                        	  1956: ;
                        	  1957: asm_do_nolist:
00:A45A A56B            	  1958:   lda ASS_OPERAND
00:A45C C908            	  1959:   cmp #ASS_OPERAND_IMPLIED
00:A45E F005            	  1960:   beq asm_do_nolist_ok              ; should have no operand
00:A460 A217            	  1961:   ldx #23   ; ERROR: Illegal factor
00:A462 4C0E9F          	  1962:   jmp ass_error
                        	  1963: asm_do_nolist_ok:
00:A465 A900            	  1964:   lda #0
00:A467 8500            	  1965:   sta VALUE
00:A469 8004            	  1966:   bra asm_do_list_ok
                        	  1967: 
                        	  1968: asm_do_list_no_operand:
00:A46B A903            	  1969:   lda #3
00:A46D 8573            	  1970:   sta ASS_VALUE
                        	  1971: asm_do_list_ok:
00:A46F A576            	  1972:   lda ASS_PASS
00:A471 F025            	  1973:   beq asm_do_list_first_pass  ; ignore on first pass
                        	  1974: 
                        	  1975: ;  lda ASS_VALUE
                        	  1976: ;  clc
                        	  1977: ;  adc #'0'
                        	  1978: ;  jsr ass_debug_point
                        	  1979: 
00:A473 A573            	  1980:   lda ASS_VALUE
00:A475 2901            	  1981:   and #$01
00:A477 F00C            	  1982:   beq asm_do_list_not    ; no listing wanted
00:A479 A904            	  1983:   lda #FLAG_LIST_SOURCE ; already listing?
00:A47B 25BE            	  1984:   and system_flags
00:A47D D00A            	  1985:   bne  asm_do_list1   ; yep
00:A47F A904            	  1986:   lda #FLAG_LIST_SOURCE
00:A481 04BE            	  1987:   tsb system_flags
                        	  1988: ;  jsr token_line        ; list the current line  TODO: don't know, I think it bumps the line number wrongly
00:A483 8004            	  1989:   bra asm_do_list1
                        	  1990: 
                        	  1991: ;
                        	  1992: ;  turn off list flag
                        	  1993: ;
                        	  1994: asm_do_list_not:
00:A485 A904            	  1995:   lda #FLAG_LIST_SOURCE
00:A487 14BE            	  1996:   trb system_flags
                        	  1997: 
                        	  1998: asm_do_list1:
                        	  1999: 
                        	  2000: 
00:A489 A573            	  2001:   lda ASS_VALUE
00:A48B 2902            	  2002:   and #$02
00:A48D 852E            	  2003:   sta DCODE
                        	  2004: 
                        	  2005: 
00:A48F A573            	  2006:   lda ASS_VALUE
00:A491 2904            	  2007:   and #$04
00:A493 8582            	  2008:   sta show_symbols
                        	  2009: ;
                        	  2010: ;  output a newline, to get past the asterisks
                        	  2011: ;
00:A495 209292          	  2012:   jsr CROUT
                        	  2013: asm_do_list_first_pass:
00:A498 60              	  2014:   rts
                        	  2015: 
                        	  2016: ;
                        	  2017: ;  ASC "String"
                        	  2018: ;
                        	  2019: asm_do_asc = *
00:A499 A56B            	  2020:   lda ASS_OPERAND
00:A49B C911            	  2021:   cmp #ASS_OPERAND_STRING
00:A49D F005            	  2022:   beq asm_do_asc_ok
00:A49F A208            	  2023:   ldx #8    ; ERROR: incorrect string
00:A4A1 4C0E9F          	  2024:   jmp ass_error
                        	  2025: ;
                        	  2026: ;  now emit the string
                        	  2027: ;
                        	  2028: asm_do_asc_ok:
00:A4A4 A000            	  2029:   ldy  #0
                        	  2030: asm_do_asc_loop:
00:A4A6 B90002          	  2031:   lda  INBUF,Y
00:A4A9 C8              	  2032:   iny         ; onto next character in the string
00:A4AA 5A              	  2033:   phy
00:A4AB 20D09E          	  2034:   jsr ass_emit
00:A4AE 7A              	  2035:   ply
                        	  2036: 
                        	  2037: asm_do_asc_next:
00:A4AF C692            	  2038:   dec token_length
00:A4B1 D0F3            	  2039:   bne asm_do_asc_loop
00:A4B3 60              	  2040:   rts
                        	  2041: 
                        	  2042: 
                        	  2043: ;
                        	  2044: ;  ASCIIZ / STRING - output a string with a null terminator
                        	  2045: ;
                        	  2046: 
                        	  2047: asm_do_string:
00:A4B4 2099A4          	  2048:   jsr asm_do_asc    ; do the string
00:A4B7 A900            	  2049:   lda #0            ; and the terminator
00:A4B9 20D09E          	  2050:   jsr ass_emit
00:A4BC 60              	  2051:   rts
                        	  2052: 
                        	  2053: 
                        	  2054: ;
                        	  2055: ;  EQU
                        	  2056: ;
                        	  2057: ;  The label, which must be present, takes on the value of the expression
                        	  2058: ;
                        	  2059: 
                        	  2060: asm_do_equ:
00:A4BD A56B            	  2061:   lda ASS_OPERAND
00:A4BF C901            	  2062:   cmp #ASS_OPERAND_ABSOLUTE
00:A4C1 D01D            	  2063:   bne asm_do_constant_expected
00:A4C3 A583            	  2064:   lda ass_current_label
00:A4C5 0584            	  2065:   ora ass_current_label+1
00:A4C7 D005            	  2066:   bne asm_do_equ_have_label
00:A4C9 A230            	  2067:   ldx #48    ; ERROR: label required
00:A4CB 4C0E9F          	  2068:   jmp ass_error
                        	  2069: 
                        	  2070: asm_do_equ_have_label:
00:A4CE A004            	  2071:   ldy #SYMDSP
00:A4D0 A573            	  2072:   lda ASS_VALUE
00:A4D2 9183            	  2073:   sta (ass_current_label),y
00:A4D4 C8              	  2074:   iny
00:A4D5 A574            	  2075:   lda ASS_VALUE+1
00:A4D7 9183            	  2076:   sta (ass_current_label),y
00:A4D9 60              	  2077:   rts
                        	  2078: 
                        	  2079: ;
                        	  2080: ;  ORG
                        	  2081: ;
                        	  2082: ;  The program counter becomes the value of the expression
                        	  2083: ;
                        	  2084: 
                        	  2085: asm_do_org:
00:A4DA A56B            	  2086:   lda ASS_OPERAND
00:A4DC C901            	  2087:   cmp #ASS_OPERAND_ABSOLUTE
00:A4DE F005            	  2088:   beq asm_do_org_ok
                        	  2089: asm_do_constant_expected:
00:A4E0 A202            	  2090:   ldx #2    ; ERROR: constant expected
00:A4E2 4C0E9F          	  2091:   jmp ass_error
                        	  2092: 
                        	  2093: asm_do_org_ok:
00:A4E5 A573            	  2094:   lda ASS_VALUE
00:A4E7 8523            	  2095:   sta PCODE
00:A4E9 A574            	  2096:   lda ASS_VALUE+1
00:A4EB 8524            	  2097:   sta PCODE+1
00:A4ED 60              	  2098:   rts
                        	  2099: 
                        	  2100: ;
                        	  2101: ;  DFB - define one byte (value being the expression)
                        	  2102: ;
                        	  2103: 
                        	  2104: asm_do_dfb:
00:A4EE A56B            	  2105:   lda ASS_OPERAND
00:A4F0 C912            	  2106:   cmp #ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE  ; multiple values?
00:A4F2 F008            	  2107:   beq asm_do_dfb_multiple
00:A4F4 C901            	  2108:   cmp #ASS_OPERAND_ABSOLUTE
00:A4F6 D0E8            	  2109:   bne asm_do_constant_expected
00:A4F8 2020A5          	  2110:   jsr asm_emit_one_byte
00:A4FB 60              	  2111:   rts
                        	  2112: 
                        	  2113: ;
                        	  2114: ;  so if we got here we thought we had two values (like a BBR0 $12,foo)
                        	  2115: ;  - the first is in REMAIN and the other in VALUE
                        	  2116: ;
                        	  2117: ;  let's emit REMAIN, then VALUE, then look for other values
                        	  2118: ;
                        	  2119: asm_do_dfb_multiple:
00:A4FC A507            	  2120:   lda REMAIN+1
00:A4FE D01B            	  2121:   bne asm_do_dfb_too_big
00:A500 A508            	  2122:   lda REMAIN+2
00:A502 D017            	  2123:   bne asm_do_dfb_too_big
00:A504 A506            	  2124:   lda REMAIN
00:A506 20D09E          	  2125:   jsr ass_emit  ; emit REMAIN
                        	  2126: asm_do_dfb_multiple_loop:
00:A509 2020A5          	  2127:   jsr asm_emit_one_byte  ; emit VALUE
00:A50C A593            	  2128:   lda token_type
00:A50E C92C            	  2129:   cmp #','      ; another?
00:A510 D008            	  2130:   bne asm_do_dfb_multiple_done
00:A512 208DC9          	  2131:   jsr get_token
00:A515 203B9D          	  2132:   jsr ass_get_value  ; should have some sort of address now in VALUE
00:A518 80EF            	  2133:   bra asm_do_dfb_multiple_loop
                        	  2134: 
                        	  2135: asm_do_dfb_multiple_done:
00:A51A 60              	  2136:   rts
                        	  2137: 
                        	  2138: 
                        	  2139: asm_do_dfb_too_big:
00:A51B A22C            	  2140:   ldx #44
00:A51D 4C0E9F          	  2141:   jmp ass_error
                        	  2142: 
                        	  2143: asm_emit_one_byte:
00:A520 A574            	  2144:   lda ASS_VALUE+1
00:A522 D0F7            	  2145:   bne asm_do_dfb_too_big
00:A524 A575            	  2146:   lda ASS_VALUE+2
00:A526 D0F3            	  2147:   bne asm_do_dfb_too_big
00:A528 A573            	  2148:   lda ASS_VALUE
00:A52A 20D09E          	  2149:   jsr ass_emit
00:A52D 60              	  2150:   rts
                        	  2151: 
                        	  2152: 
                        	  2153: ;
                        	  2154: ;  DFW - define two bytes (value being the expression)
                        	  2155: ;
                        	  2156: 
                        	  2157: asm_do_dfw:
00:A52E A56B            	  2158:   lda ASS_OPERAND
00:A530 C912            	  2159:   cmp #ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE  ; multiple values?
00:A532 F008            	  2160:   beq asm_do_dfw_multiple
00:A534 C901            	  2161:   cmp #ASS_OPERAND_ABSOLUTE
00:A536 D0A8            	  2162:   bne asm_do_constant_expected
00:A538 205CA5          	  2163:   jsr asm_emit_two_bytes
00:A53B 60              	  2164:   rts
                        	  2165: 
                        	  2166: ;
                        	  2167: ;  so if we got here we thought we had two values (like a BBR0 $12,foo)
                        	  2168: ;  - the first is in REMAIN and the other in VALUE
                        	  2169: ;
                        	  2170: ;  let's emit REMAIN, then VALUE, then look for other values
                        	  2171: ;
                        	  2172: asm_do_dfw_multiple:
00:A53C A508            	  2173:   lda REMAIN+2
00:A53E D0DB            	  2174:   bne asm_do_dfb_too_big
00:A540 A506            	  2175:   lda REMAIN
00:A542 20D09E          	  2176:   jsr ass_emit  ; emit REMAIN
00:A545 A507            	  2177:   lda REMAIN+1
00:A547 20D09E          	  2178:   jsr ass_emit  ; emit REMAIN+1
                        	  2179: asm_do_dfw_multiple_loop:
00:A54A 205CA5          	  2180:   jsr asm_emit_two_bytes  ; emit VALUE
00:A54D A593            	  2181:   lda token_type
00:A54F C92C            	  2182:   cmp #','      ; another?
00:A551 D008            	  2183:   bne asm_do_dfw_multiple_done
00:A553 208DC9          	  2184:   jsr get_token
00:A556 203B9D          	  2185:   jsr ass_get_value  ; should have some sort of address now in VALUE
00:A559 80EF            	  2186:   bra asm_do_dfw_multiple_loop
                        	  2187: 
                        	  2188: asm_do_dfw_multiple_done:
00:A55B 60              	  2189:   rts
                        	  2190: 
                        	  2191: 
                        	  2192: asm_emit_two_bytes:
00:A55C A575            	  2193:   lda ASS_VALUE+2
00:A55E D0BB            	  2194:   bne asm_do_dfb_too_big
00:A560 A573            	  2195:   lda ASS_VALUE
00:A562 20D09E          	  2196:   jsr ass_emit
00:A565 A574            	  2197:   lda ASS_VALUE+1
00:A567 20D09E          	  2198:   jsr ass_emit
00:A56A 60              	  2199:   rts
                        	  2200: 
                        	  2201: 
                        	  2202: 
                        	  2203: ;
                        	  2204: ;  BLK - zero fill <expression> bytes (eg. BLK 5 output 5 zeroes)
                        	  2205: ;
                        	  2206: 
                        	  2207: asm_do_blk:
00:A56B A56B            	  2208:   lda ASS_OPERAND
00:A56D C901            	  2209:   cmp #ASS_OPERAND_ABSOLUTE
00:A56F D030            	  2210:   bne asm_do_constant_expectedJ2
00:A571 A575            	  2211:   lda ASS_VALUE+2
00:A573 D0A6            	  2212:   bne asm_do_dfb_too_big
                        	  2213: ;
                        	  2214: ; handle (obscure) case of them defining zero bytes
                        	  2215: ;
00:A575 A573            	  2216:   lda ASS_VALUE
00:A577 0574            	  2217:   ora ASS_VALUE+1
00:A579 F00D            	  2218:   beq asm_do_blk_done
                        	  2219: asm_do_blk_loop:
                        	  2220: ;
                        	  2221: ;  emit one zero
                        	  2222: ;
00:A57B A900            	  2223:   lda #0
00:A57D 20D09E          	  2224:   jsr ass_emit
00:A580 C673            	  2225:   dec ASS_VALUE
00:A582 D0F7            	  2226:   bne asm_do_blk_loop
00:A584 C674            	  2227:   dec ASS_VALUE+1
00:A586 10F3            	  2228:   bpl asm_do_blk_loop
                        	  2229: asm_do_blk_done:
00:A588 60              	  2230:   rts
                        	  2231: 
                        	  2232: ;
                        	  2233: ;  RESERVE - reserve <expression> bytes without writing to them
                        	  2234: ;   useful for leaving a gap (eg. for zero-page variables)
                        	  2235: ;
                        	  2236: 
                        	  2237: asm_do_reserve:
00:A589 A56B            	  2238:   lda ASS_OPERAND
00:A58B C901            	  2239:   cmp #ASS_OPERAND_ABSOLUTE
00:A58D D012            	  2240:   bne asm_do_constant_expectedJ2
00:A58F A575            	  2241:   lda ASS_VALUE+2
00:A591 D088            	  2242:   bne asm_do_dfb_too_big
00:A593 18              	  2243:   clc
00:A594 A523            	  2244:   lda PCODE
00:A596 6573            	  2245:   adc ASS_VALUE
00:A598 8523            	  2246:   sta PCODE
00:A59A A524            	  2247:   lda PCODE+1
00:A59C 6574            	  2248:   adc ASS_VALUE+1
00:A59E 8524            	  2249:   sta PCODE+1
00:A5A0 60              	  2250:   rts
                        	  2251: 
00:A5A1 4CE0A4          	  2252: asm_do_constant_expectedJ2 jmp asm_do_constant_expected
                        	  2253: 
                        	  2254: ;
                        	  2255: ;  SYM <address> symbol table relocation
                        	  2256: ;
                        	  2257: asm_do_sym:
00:A5A4 A56B            	  2258:   lda ASS_OPERAND
00:A5A6 C901            	  2259:   cmp #ASS_OPERAND_ABSOLUTE
00:A5A8 D0F7            	  2260:   bne asm_do_constant_expectedJ2
                        	  2261: ;
                        	  2262: ;  only relocate symbol table on the first pass
                        	  2263: ;
00:A5AA A576            	  2264:   lda ASS_PASS
00:A5AC D00F            	  2265:   bne asm_do_sym_done
                        	  2266: 
00:A5AE A573            	  2267:   lda  ASS_VALUE
00:A5B0 8531            	  2268:   sta  ENDSYM
00:A5B2 852F            	  2269:   sta  STARTSYM
00:A5B4 A574            	  2270:   lda  ASS_VALUE+1
00:A5B6 8532            	  2271:   sta  ENDSYM+1        ; store symbol table address
00:A5B8 8530            	  2272:   sta  STARTSYM+1
                        	  2273: ;
                        	  2274: ;  put our library functions back into the symbol table
                        	  2275: ;
00:A5BA 208AAA          	  2276:   jsr  add_assembler_library_functions  ; add our inbuilt functions to the symbol table
                        	  2277: 
                        	  2278: asm_do_sym_done:
00:A5BD 60              	  2279:   rts
                        	  2280: ;
                        	  2281: 
                        	  2282: 
00:A5BE 41646472204E616D	  2283: info_message asciiz "Addr Name\n"
00:A5C6 650A
00:A5C8 00
                        	  2284: 
                        	  2285: list_symbols  = *
00:A5C9 A9BE            	  2286:          lda #<info_message
00:A5CB A2A5            	  2287:          ldx #>info_message
00:A5CD 202682          	  2288:          jsr print
                        	  2289: 
00:A5D0 A532            	  2290:          lda  ENDSYM+1    ; get the end of the symbol table
00:A5D2 8541            	  2291:          sta  SYMITM+1    ; make it the current symbol
00:A5D4 A531            	  2292:          lda  ENDSYM
00:A5D6 800B            	  2293:          bra  list_symbols_check
                        	  2294: 
                        	  2295: list_symbols_next =  *
00:A5D8 A000            	  2296:          ldy  #SYMPRV
00:A5DA B140            	  2297:          lda  (SYMITM),Y
00:A5DC AA              	  2298:          tax
00:A5DD C8              	  2299:          iny
00:A5DE B140            	  2300:          lda  (SYMITM),Y
00:A5E0 8541            	  2301:          sta  SYMITM+1   ; previous link
00:A5E2 8A              	  2302:          txa
                        	  2303: ;
                        	  2304: ;  go to the previous symbol table item
                        	  2305: ;
                        	  2306: list_symbols_check     =  *
00:A5E3 8540            	  2307:          sta  SYMITM
00:A5E5 C52F            	  2308:          cmp  STARTSYM
00:A5E7 D009            	  2309:          bne  list_symbols_line
00:A5E9 A541            	  2310:          lda  SYMITM+1
00:A5EB C530            	  2311:          cmp  STARTSYM+1
00:A5ED D003            	  2312:          bne  list_symbols_line       ; more to go
00:A5EF 4C1DA6          	  2313:          jmp  list_symbols_done       ; finished if symitm and symitm+1 are both zero
                        	  2314: 
                        	  2315: list_symbols_line = *
00:A5F2 A004            	  2316:          ldy  #SYMDSP
00:A5F4 C8              	  2317:          iny
00:A5F5 B140            	  2318:          lda  (SYMITM),Y  ; displacement
00:A5F7 200793          	  2319:          jsr  PRBYTE
00:A5FA 88              	  2320:          dey
00:A5FB B140            	  2321:          lda  (SYMITM),Y  ; displacement
00:A5FD 200793          	  2322:          jsr  PRBYTE
00:A600 A920            	  2323:          lda  #' '
00:A602 20EF92          	  2324:          jsr  PRCHAR
00:A605 A009            	  2325:          ldy  #SYMLEN
00:A607 B140            	  2326:          lda  (SYMITM),Y  ; length
00:A609 AA              	  2327:          tax
00:A60A A00A            	  2328:          ldy  #SYMNAM
                        	  2329: list_symbols_name = *
00:A60C B140            	  2330:          lda  (SYMITM),Y  ; name
00:A60E 5A              	  2331:          phy
00:A60F 20EF92          	  2332:          jsr  PRCHAR
00:A612 7A              	  2333:          ply
00:A613 C8              	  2334:          iny
00:A614 CA              	  2335:          dex
00:A615 D0F5            	  2336:          bne list_symbols_name
00:A617 209292          	  2337:          jsr CROUT
00:A61A 4CD8A5          	  2338:          jmp list_symbols_next
                        	  2339: 
                        	  2340: list_symbols_done = *
00:A61D 60              	  2341:          rts
                        	  2342: 
                        	  2343: assembler_library_functions_table:
                        	  2344: ;
                        	  2345: ;  put them in reverse alphabetic order so they come out in alphabetic
                        	  2346: ;  order if you request a symbols list
                        	  2347: ;
                        	  2348:   makeAsmLibraryFunction "write_to_serial",      write_to_serial
00:A61E 77726974655F746F	     1M      asciiz   "write_to_serial"
00:A626 5F73657269616C
00:A62D 00
00:A62E F9C8            	     2M      word     write_to_serial
                        	  2349:   makeAsmLibraryFunction "write_to_lcd",         write_to_lcd
00:A630 77726974655F746F	     1M      asciiz   "write_to_lcd"
00:A638 5F6C6364
00:A63C 00
00:A63D 04C9            	     2M      word     write_to_lcd
                        	  2350:   makeAsmLibraryFunction "write_function",       write_function
00:A63F 77726974655F6675	     1M      asciiz   "write_function"
00:A647 6E6374696F6E
00:A64D 00
00:A64E 1700            	     2M      word     write_function
                        	  2351:   makeAsmLibraryFunction "write_char",           write_char
00:A650 77726974655F6368	     1M      asciiz   "write_char"
00:A658 6172
00:A65A 00
00:A65B 57C9            	     2M      word     write_char
                        	  2352:   makeAsmLibraryFunction "value",                VALUE
00:A65D 76616C7565      	     1M      asciiz   "value"
00:A662 00
00:A663 0000            	     2M      word     VALUE
                        	  2353:   makeAsmLibraryFunction "value2",               VALUE2
00:A665 76616C756532    	     1M      asciiz   "value2"
00:A66B 00
00:A66C 0300            	     2M      word     VALUE2
                        	  2354:   makeAsmLibraryFunction "typing_latency",       typing_latency
00:A66E 747970696E675F6C	     1M      asciiz   "typing_latency"
00:A676 6174656E6379
00:A67C 00
00:A67D 0D00            	     2M      word     typing_latency
                        	  2355:   makeAsmLibraryFunction "tknjmp",               TKNJMP
00:A67F 746B6E6A6D70    	     1M      asciiz   "tknjmp"
00:A685 00
00:A686 FC8F            	     2M      word     TKNJMP
                        	  2356:   makeAsmLibraryFunction "reset",                START
00:A688 7265736574      	     1M      asciiz   "reset"
00:A68D 00
00:A68E 29D1            	     2M      word     START
                        	  2357:   makeAsmLibraryFunction "srce",                 SRCE
00:A690 73726365        	     1M      asciiz   "srce"
00:A694 00
00:A695 0000            	     2M      word     SRCE
                        	  2358:   makeAsmLibraryFunction "serial_print_message", serial_print_message
00:A697 73657269616C5F70	     1M      asciiz   "serial_print_message"
00:A69F 72696E745F6D6573
00:A6A7 73616765
00:A6AB 00
00:A6AC 7CC9            	     2M      word     serial_print_message
                        	  2359:   makeAsmLibraryFunction "serial_available",     serial_available
00:A6AE 73657269616C5F61	     1M      asciiz   "serial_available"
00:A6B6 7661696C61626C65
00:A6BE 00
00:A6BF 20C9            	     2M      word     serial_available
                        	  2360:   makeAsmLibraryFunction "nmi",                  RESTART
00:A6C1 6E6D69          	     1M      asciiz   "nmi"
00:A6C4 00
00:A6C5 45D1            	     2M      word     RESTART
                        	  2361:   makeAsmLibraryFunction "remain",               REMAIN
00:A6C7 72656D61696E    	     1M      asciiz   "remain"
00:A6CD 00
00:A6CE 0600            	     2M      word     REMAIN
                        	  2362:   makeAsmLibraryFunction "random",               random
00:A6D0 72616E646F6D    	     1M      asciiz   "random"
00:A6D6 00
00:A6D7 0900            	     2M      word     random
                        	  2363:   makeAsmLibraryFunction "putsp",                PUTSP
00:A6D9 7075747370      	     1M      asciiz   "putsp"
00:A6DE 00
00:A6DF 1D93            	     2M      word     PUTSP
                        	  2364:   makeAsmLibraryFunction "print",                print
00:A6E1 7072696E74      	     1M      asciiz   "print"
00:A6E6 00
00:A6E7 2682            	     2M      word     print
                        	  2365:   makeAsmLibraryFunction "prchar",               PRCHAR
00:A6E9 707263686172    	     1M      asciiz   "prchar"
00:A6EF 00
00:A6F0 EF92            	     2M      word     PRCHAR
                        	  2366:   makeAsmLibraryFunction "prbyte",               PRBYTE
00:A6F2 707262797465    	     1M      asciiz   "prbyte"
00:A6F8 00
00:A6F9 0793            	     2M      word     PRBYTE
                        	  2367:   makeAsmLibraryFunction "pinmode",              pinmode
00:A6FB 70696E6D6F6465  	     1M      asciiz   "pinmode"
00:A702 00
00:A703 7EC8            	     2M      word     pinmode
                        	  2368:   makeAsmLibraryFunction "lcd_wait",             lcd_wait
00:A705 6C63645F77616974	     1M      asciiz   "lcd_wait"
00:A70D 00
00:A70E 58B8            	     2M      word     lcd_wait
                        	  2369:   makeAsmLibraryFunction "lcd_second_line",      lcd_second_line
00:A710 6C63645F7365636F	     1M      asciiz   "lcd_second_line"
00:A718 6E645F6C696E65
00:A71F 00
00:A720 EFB8            	     2M      word     lcd_second_line
                        	  2370:   makeAsmLibraryFunction "lcd_print_message",    lcd_print_message
00:A722 6C63645F7072696E	     1M      asciiz   "lcd_print_message"
00:A72A 745F6D6573736167
00:A732 65
00:A733 00
00:A734 FFB8            	     2M      word     lcd_print_message
                        	  2371:   makeAsmLibraryFunction "lcd_print_char",       lcd_print_char
00:A736 6C63645F7072696E	     1M      asciiz   "lcd_print_char"
00:A73E 745F63686172
00:A744 00
00:A745 B5B8            	     2M      word     lcd_print_char
                        	  2372:   makeAsmLibraryFunction "lcd_instruction",      lcd_instruction
00:A747 6C63645F696E7374	     1M      asciiz   "lcd_instruction"
00:A74F 72756374696F6E
00:A756 00
00:A757 93B8            	     2M      word     lcd_instruction
                        	  2373:   makeAsmLibraryFunction "lcd_home",             lcd_home
00:A759 6C63645F686F6D65	     1M      asciiz   "lcd_home"
00:A761 00
00:A762 F7B8            	     2M      word     lcd_home
                        	  2374:   makeAsmLibraryFunction "lcd_get_address",      lcd_get_address
00:A764 6C63645F6765745F	     1M      asciiz   "lcd_get_address"
00:A76C 61646472657373
00:A773 00
00:A774 73B8            	     2M      word     lcd_get_address
                        	  2375:   makeAsmLibraryFunction "lcd_clear_display",    lcd_clear_display
00:A776 6C63645F636C6561	     1M      asciiz   "lcd_clear_display"
00:A77E 725F646973706C61
00:A786 79
00:A787 00
00:A788 E7B8            	     2M      word     lcd_clear_display
                        	  2376:   makeAsmLibraryFunction "isxdigit",             isxdigit
00:A78A 6973786469676974	     1M      asciiz   "isxdigit"
00:A792 00
00:A793 3E81            	     2M      word     isxdigit
                        	  2377:   makeAsmLibraryFunction "isupper",              isupper
00:A795 69737570706572  	     1M      asciiz   "isupper"
00:A79C 00
00:A79D 0E81            	     2M      word     isupper
                        	  2378:   makeAsmLibraryFunction "isspace",              isspace
00:A79F 69737370616365  	     1M      asciiz   "isspace"
00:A7A6 00
00:A7A7 4A81            	     2M      word     isspace
                        	  2379:   makeAsmLibraryFunction "islower",              islower
00:A7A9 69736C6F776572  	     1M      asciiz   "islower"
00:A7B0 00
00:A7B1 1A81            	     2M      word     islower
                        	  2380:   makeAsmLibraryFunction "isdigit",              isdigit
00:A7B3 69736469676974  	     1M      asciiz   "isdigit"
00:A7BA 00
00:A7BB 3281            	     2M      word     isdigit
                        	  2381:   makeAsmLibraryFunction "iscntrl",              iscntrl
00:A7BD 6973636E74726C  	     1M      asciiz   "iscntrl"
00:A7C4 00
00:A7C5 5681            	     2M      word     iscntrl
                        	  2382:   makeAsmLibraryFunction "isalpha",              isalpha
00:A7C7 6973616C706861  	     1M      asciiz   "isalpha"
00:A7CE 00
00:A7CF 2681            	     2M      word     isalpha
                        	  2383:   makeAsmLibraryFunction "isalnum",              isalnum
00:A7D1 6973616C6E756D  	     1M      asciiz   "isalnum"
00:A7D8 00
00:A7D9 6281            	     2M      word     isalnum
                        	  2384:   makeAsmLibraryFunction "inbuf",                INBUF
00:A7DB 696E627566      	     1M      asciiz   "inbuf"
00:A7E0 00
00:A7E1 0002            	     2M      word     INBUF
                        	  2385:   makeAsmLibraryFunction "i2c_send_message",     i2c_send_message
00:A7E3 6932635F73656E64	     1M      asciiz   "i2c_send_message"
00:A7EB 5F6D657373616765
00:A7F3 00
00:A7F4 B4D0            	     2M      word     i2c_send_message
                        	  2386:   makeAsmLibraryFunction "i2c_receive_message",  i2c_receive_message
00:A7F6 6932635F72656365	     1M      asciiz   "i2c_receive_message"
00:A7FE 6976655F6D657373
00:A806 616765
00:A809 00
00:A80A DDD0            	     2M      word     i2c_receive_message
                        	  2387:   makeAsmLibraryFunction "i2c_init",             i2c_init
00:A80C 6932635F696E6974	     1M      asciiz   "i2c_init"
00:A814 00
00:A815 AECF            	     2M      word     i2c_init
                        	  2388:   makeAsmLibraryFunction "hardware_init",        hardware_init
00:A817 6861726477617265	     1M      asciiz   "hardware_init"
00:A81F 5F696E6974
00:A824 00
00:A825 26C9            	     2M      word     hardware_init
                        	  2389:   makeAsmLibraryFunction "getin",                GETIN
00:A827 676574696E      	     1M      asciiz   "getin"
00:A82C 00
00:A82D 0FC9            	     2M      word     GETIN
                        	  2390:   makeAsmLibraryFunction "gen_random",           gen_random
00:A82F 67656E5F72616E64	     1M      asciiz   "gen_random"
00:A837 6F6D
00:A839 00
00:A83A 4490            	     2M      word     gen_random
                        	  2391:   makeAsmLibraryFunction "exp_unary_minus",      exp_unary_minus
00:A83C 6578705F756E6172	     1M      asciiz   "exp_unary_minus"
00:A844 795F6D696E7573
00:A84B 00
00:A84C 1CAC            	     2M      word     exp_unary_minus
                        	  2392:   makeAsmLibraryFunction "exp_true",             exp_true
00:A84E 6578705F74727565	     1M      asciiz   "exp_true"
00:A856 00
00:A857 FFAA            	     2M      word     exp_true
                        	  2393:   makeAsmLibraryFunction "exp_subtract",         exp_subtract
00:A859 6578705F73756274	     1M      asciiz   "exp_subtract"
00:A861 72616374
00:A865 00
00:A866 E9AA            	     2M      word     exp_subtract
                        	  2394:   makeAsmLibraryFunction "exp_shift_right",      exp_shift_right
00:A868 6578705F73686966	     1M      asciiz   "exp_shift_right"
00:A870 745F7269676874
00:A877 00
00:A878 E2AB            	     2M      word     exp_shift_right
                        	  2395:   makeAsmLibraryFunction "exp_shift_left",       exp_shift_left
00:A87A 6578705F73686966	     1M      asciiz   "exp_shift_left"
00:A882 745F6C656674
00:A888 00
00:A889 C9AB            	     2M      word     exp_shift_left
                        	  2396:   makeAsmLibraryFunction "exp_not",              exp_not
00:A88B 6578705F6E6F74  	     1M      asciiz   "exp_not"
00:A892 00
00:A893 0EAC            	     2M      word     exp_not
                        	  2397:   makeAsmLibraryFunction "exp_neq",              exp_neq
00:A895 6578705F6E6571  	     1M      asciiz   "exp_neq"
00:A89C 00
00:A89D 23AB            	     2M      word     exp_neq
                        	  2398:   makeAsmLibraryFunction "exp_negate",           exp_negate
00:A89F 6578705F6E656761	     1M      asciiz   "exp_negate"
00:A8A7 7465
00:A8A9 00
00:A8AA FBAB            	     2M      word     exp_negate
                        	  2399:   makeAsmLibraryFunction "exp_multiply",         exp_multiply
00:A8AC 6578705F6D756C74	     1M      asciiz   "exp_multiply"
00:A8B4 69706C79
00:A8B8 00
00:A8B9 A3AC            	     2M      word     exp_multiply
                        	  2400:   makeAsmLibraryFunction "exp_modulo",           exp_modulo
00:A8BB 6578705F6D6F6475	     1M      asciiz   "exp_modulo"
00:A8C3 6C6F
00:A8C5 00
00:A8C6 3CAD            	     2M      word     exp_modulo
                        	  2401:   makeAsmLibraryFunction "exp_low_byte",         exp_low_byte
00:A8C8 6578705F6C6F775F	     1M      asciiz   "exp_low_byte"
00:A8D0 62797465
00:A8D4 00
00:A8D5 30AC            	     2M      word     exp_low_byte
                        	  2402:   makeAsmLibraryFunction "exp_logical_or",       exp_logical_or
00:A8D7 6578705F6C6F6769	     1M      asciiz   "exp_logical_or"
00:A8DF 63616C5F6F72
00:A8E5 00
00:A8E6 A8AB            	     2M      word     exp_logical_or
                        	  2403:   makeAsmLibraryFunction "exp_logical_and",      exp_logical_and
00:A8E8 6578705F6C6F6769	     1M      asciiz   "exp_logical_and"
00:A8F0 63616C5F616E64
00:A8F7 00
00:A8F8 B7AB            	     2M      word     exp_logical_and
                        	  2404:   makeAsmLibraryFunction "exp_less_than",        exp_less_than
00:A8FA 6578705F6C657373	     1M      asciiz   "exp_less_than"
00:A902 5F7468616E
00:A907 00
00:A908 37AB            	     2M      word     exp_less_than
                        	  2405:   makeAsmLibraryFunction "exp_leq",              exp_leq
00:A90A 6578705F6C6571  	     1M      asciiz   "exp_leq"
00:A911 00
00:A912 4DAB            	     2M      word     exp_leq
                        	  2406:   makeAsmLibraryFunction "exp_high_byte",        exp_high_byte
00:A914 6578705F68696768	     1M      asciiz   "exp_high_byte"
00:A91C 5F62797465
00:A921 00
00:A922 35AC            	     2M      word     exp_high_byte
                        	  2407:   makeAsmLibraryFunction "exp_greater_than",     exp_greater_than
00:A924 6578705F67726561	     1M      asciiz   "exp_greater_than"
00:A92C 7465725F7468616E
00:A934 00
00:A935 3EAB            	     2M      word     exp_greater_than
                        	  2408:   makeAsmLibraryFunction "exp_geq",              exp_geq
00:A937 6578705F676571  	     1M      asciiz   "exp_geq"
00:A93E 00
00:A93F 5CAB            	     2M      word     exp_geq
                        	  2409:   makeAsmLibraryFunction "exp_false",            exp_false
00:A941 6578705F66616C73	     1M      asciiz   "exp_false"
00:A949 65
00:A94A 00
00:A94B 08AB            	     2M      word     exp_false
                        	  2410:   makeAsmLibraryFunction "exp_eql",              exp_eql
00:A94D 6578705F65716C  	     1M      asciiz   "exp_eql"
00:A954 00
00:A955 0FAB            	     2M      word     exp_eql
                        	  2411:   makeAsmLibraryFunction "exp_divide",           exp_divide
00:A957 6578705F64697669	     1M      asciiz   "exp_divide"
00:A95F 6465
00:A961 00
00:A962 DCAC            	     2M      word     exp_divide
                        	  2412:   makeAsmLibraryFunction "exp_bitwise_xor",      exp_bitwise_xor
00:A964 6578705F62697477	     1M      asciiz   "exp_bitwise_xor"
00:A96C 6973655F786F72
00:A973 00
00:A974 8DAB            	     2M      word     exp_bitwise_xor
                        	  2413:   makeAsmLibraryFunction "exp_bitwise_or",       exp_bitwise_or
00:A976 6578705F62697477	     1M      asciiz   "exp_bitwise_or"
00:A97E 6973655F6F72
00:A984 00
00:A985 63AB            	     2M      word     exp_bitwise_or
                        	  2414:   makeAsmLibraryFunction "exp_bitwise_and",      exp_bitwise_and
00:A987 6578705F62697477	     1M      asciiz   "exp_bitwise_and"
00:A98F 6973655F616E64
00:A996 00
00:A997 78AB            	     2M      word     exp_bitwise_and
                        	  2415:   makeAsmLibraryFunction "exp_add",              exp_add
00:A999 6578705F616464  	     1M      asciiz   "exp_add"
00:A9A0 00
00:A9A1 D5AA            	     2M      word     exp_add
                        	  2416:   makeAsmLibraryFunction "exp_abs_val",          exp_abs_val
00:A9A3 6578705F6162735F	     1M      asciiz   "exp_abs_val"
00:A9AB 76616C
00:A9AE 00
00:A9AF 3EAC            	     2M      word     exp_abs_val
                        	  2417:   makeAsmLibraryFunction "display_in_decimal",   display_in_decimal
00:A9B1 646973706C61795F	     1M      asciiz   "display_in_decimal"
00:A9B9 696E5F646563696D
00:A9C1 616C
00:A9C3 00
00:A9C4 BC91            	     2M      word     display_in_decimal
                        	  2418:   makeAsmLibraryFunction "digitalwrite",         digitalwrite
00:A9C6 6469676974616C77	     1M      asciiz   "digitalwrite"
00:A9CE 72697465
00:A9D2 00
00:A9D3 ADC8            	     2M      word     digitalwrite
                        	  2419:   makeAsmLibraryFunction "digitalread",          digitalread
00:A9D5 6469676974616C72	     1M      asciiz   "digitalread"
00:A9DD 656164
00:A9E0 00
00:A9E1 DCC8            	     2M      word     digitalread
                        	  2420:   makeAsmLibraryFunction "dest",                 DEST
00:A9E3 64657374        	     1M      asciiz   "dest"
00:A9E7 00
00:A9E8 0300            	     2M      word     DEST
                        	  2421:   makeAsmLibraryFunction "delay",                delay
00:A9EA 64656C6179      	     1M      asciiz   "delay"
00:A9EF 00
00:A9F0 3F91            	     2M      word     delay
                        	  2422:   makeAsmLibraryFunction "delay_1ms",            delay_1ms
00:A9F2 64656C61795F316D	     1M      asciiz   "delay_1ms"
00:A9FA 73
00:A9FB 00
00:A9FC 3591            	     2M      word     delay_1ms
                        	  2423:   makeAsmLibraryFunction "crout",                CROUT
00:A9FE 63726F7574      	     1M      asciiz   "crout"
00:AA03 00
00:AA04 9292            	     2M      word     CROUT
                        	  2424:   makeAsmLibraryFunction "crc_val",              crc_val
00:AA06 6372635F76616C  	     1M      asciiz   "crc_val"
00:AA0D 00
00:AA0E 0600            	     2M      word     crc_val
                        	  2425:   makeAsmLibraryFunction "crc_num",              crc_num
00:AA10 6372635F6E756D  	     1M      asciiz   "crc_num"
00:AA17 00
00:AA18 0300            	     2M      word     crc_num
                        	  2426:   makeAsmLibraryFunction "crc_byte",             crc_byte
00:AA1A 6372635F62797465	     1M      asciiz   "crc_byte"
00:AA22 00
00:AA23 8F90            	     2M      word     crc_byte
                        	  2427:   makeAsmLibraryFunction "crc_addr",             crc_addr
00:AA25 6372635F61646472	     1M      asciiz   "crc_addr"
00:AA2D 00
00:AA2E 0000            	     2M      word     crc_addr
                        	  2428:   makeAsmLibraryFunction "crc16",                crc16
00:AA30 6372633136      	     1M      asciiz   "crc16"
00:AA35 00
00:AA36 6790            	     2M      word     crc16
                        	  2429:   makeAsmLibraryFunction "cout",                 COUT
00:AA38 636F7574        	     1M      asciiz   "cout"
00:AA3C 00
00:AA3D 1994            	     2M      word     COUT
                        	  2430:   makeAsmLibraryFunction "comstl",               COMSTL
00:AA3F 636F6D73746C    	     1M      asciiz   "comstl"
00:AA45 00
00:AA46 9792            	     2M      word     COMSTL
                        	  2431:   makeAsmLibraryFunction "call_y",               call_y
00:AA48 63616C6C5F79    	     1M      asciiz   "call_y"
00:AA4E 00
00:AA4F 1200            	     2M      word     call_y
                        	  2432:   makeAsmLibraryFunction "call_x",               call_x
00:AA51 63616C6C5F78    	     1M      asciiz   "call_x"
00:AA57 00
00:AA58 1100            	     2M      word     call_x
                        	  2433:   makeAsmLibraryFunction "call_s",               call_s
00:AA5A 63616C6C5F73    	     1M      asciiz   "call_s"
00:AA60 00
00:AA61 1400            	     2M      word     call_s
                        	  2434:   makeAsmLibraryFunction "call_p",               call_p
00:AA63 63616C6C5F70    	     1M      asciiz   "call_p"
00:AA69 00
00:AA6A 1300            	     2M      word     call_p
                        	  2435:   makeAsmLibraryFunction "call_a",               call_a
00:AA6C 63616C6C5F61    	     1M      asciiz   "call_a"
00:AA72 00
00:AA73 1000            	     2M      word     call_a
                        	  2436:   makeAsmLibraryFunction "binary_to_decimal",    binary_to_decimal
00:AA75 62696E6172795F74	     1M      asciiz   "binary_to_decimal"
00:AA7D 6F5F646563696D61
00:AA85 6C
00:AA86 00
00:AA87 E591            	     2M      word     binary_to_decimal
                        	  2437: 
00:AA89 00              	  2438:   dfb 0   ; end of table
                        	  2439: 
                        	  2440: 
                        	  2441: add_assembler_library_functions:
00:AA8A A91E            	  2442:   lda #<assembler_library_functions_table
00:AA8C 8500            	  2443:   sta REG
00:AA8E A9A6            	  2444:   lda #>assembler_library_functions_table
00:AA90 8501            	  2445:   sta REG+1
                        	  2446: add_assembler_library_functions_loop:
00:AA92 A000            	  2447:   ldy #0
00:AA94 B100            	  2448:   lda (REG),Y
00:AA96 F03C            	  2449:   beq add_assembler_library_functions_done
00:AA98 A500            	  2450:   lda REG
00:AA9A 8590            	  2451:   sta token_address
00:AA9C A501            	  2452:   lda REG+1
00:AA9E 8591            	  2453:   sta token_address+1
00:AAA0 6492            	  2454:   stz token_length
                        	  2455: ;
                        	  2456: ;  find name length
                        	  2457: ;
                        	  2458: add_assembler_library_functions_name_loop
00:AAA2 C8              	  2459:   iny
00:AAA3 E692            	  2460:   inc token_length
00:AAA5 B100            	  2461:   lda (REG),Y
00:AAA7 D0F9            	  2462:   bne add_assembler_library_functions_name_loop
00:AAA9 5A              	  2463:   phy
00:AAAA 2036BA          	  2464:   jsr CHKDUP
00:AAAD A943            	  2465:   lda #SYMBOL_CONSTANT  ; add the symbol as a constant for now
00:AAAF 208FB9          	  2466:   jsr ADDSYM
00:AAB2 7A              	  2467:   ply
                        	  2468: 
00:AAB3 C8              	  2469:   iny             ; get next byte
00:AAB4 B100            	  2470:   lda (REG),Y     ; get function address low-byte
00:AAB6 5A              	  2471:   phy
00:AAB7 A004            	  2472:   ldy #SYMDSP
00:AAB9 9140            	  2473:   sta (SYMITM),Y  ; save function address low-byte
00:AABB 7A              	  2474:   ply
                        	  2475: 
00:AABC C8              	  2476:   iny             ; get next byte
00:AABD B100            	  2477:   lda (REG),Y     ; get function address high-byte
00:AABF 5A              	  2478:   phy
00:AAC0 A005            	  2479:   ldy #SYMDSP+1
00:AAC2 9140            	  2480:   sta (SYMITM),Y  ; save function address high-byte
00:AAC4 7A              	  2481:   ply
                        	  2482: 
00:AAC5 C8              	  2483:   iny         ; get past that last byte
00:AAC6 98              	  2484:   tya         ; move REG onto next entry
00:AAC7 18              	  2485:   clc
00:AAC8 6500            	  2486:   adc REG
00:AACA 8500            	  2487:   sta REG
00:AACC A900            	  2488:   lda #0
00:AACE 6501            	  2489:   adc REG+1
00:AAD0 8501            	  2490:   sta REG+1
00:AAD2 80BE            	  2491:   bra add_assembler_library_functions_loop
                        	  2492: 
                        	  2493: add_assembler_library_functions_done:
00:AAD4 60              	  2494:   rts
                        	  2495: 

Source: "gpascal.asm"
                        	   179:   .include "math.inc"

Source: "math.inc"
                        	     1: ;--------------------------------------------------
                        	     2: ; Maths routines. 3-byte operations on VALUE and VALUE2
                        	     3: ;
                        	     4: ;--------------------------------------------------
                        	     5: exp_add:
00:AAD5 18              	     6:   clc
00:AAD6 A500            	     7:   lda VALUE
00:AAD8 6503            	     8:   adc VALUE2
00:AADA 8500            	     9:   sta VALUE
00:AADC A501            	    10:   lda VALUE+1
00:AADE 6504            	    11:   adc VALUE2+1
00:AAE0 8501            	    12:   sta VALUE+1
00:AAE2 A502            	    13:   lda VALUE+2
00:AAE4 6505            	    14:   adc VALUE2+2
00:AAE6 8502            	    15:   sta VALUE+2
00:AAE8 60              	    16:   rts
                        	    17: 
                        	    18: ;
                        	    19: ;  subtract VALUE2 from VALUE, store in VALUE, also set the sign bit
                        	    20: ;   and put the low order two bytes in X and Y
                        	    21: ;
                        	    22: exp_subtract:
00:AAE9 38              	    23:   sec
00:AAEA A500            	    24:   lda VALUE
00:AAEC E503            	    25:   sbc VALUE2
00:AAEE 8500            	    26:   sta VALUE
00:AAF0 A8              	    27:   tay
00:AAF1 A501            	    28:   lda VALUE+1
00:AAF3 E504            	    29:   sbc VALUE2+1
00:AAF5 AA              	    30:   tax
00:AAF6 8501            	    31:   sta VALUE+1
00:AAF8 A502            	    32:   lda VALUE+2
00:AAFA E505            	    33:   sbc VALUE2+2
00:AAFC 8502            	    34:   sta VALUE+2
00:AAFE 60              	    35:   rts
                        	    36: 
                        	    37: exp_true:
00:AAFF A901            	    38:   lda #1
00:AB01 8500            	    39:   sta VALUE
00:AB03 6401            	    40:   stz VALUE+1
00:AB05 6402            	    41:   stz VALUE+2
00:AB07 60              	    42:   rts
                        	    43: 
                        	    44: exp_false:
00:AB08 6400            	    45:   stz VALUE
00:AB0A 6401            	    46:   stz VALUE+1
00:AB0C 6402            	    47:   stz VALUE+2
00:AB0E 60              	    48:   rts
                        	    49: 
                        	    50: exp_eql:
00:AB0F A500            	    51:   lda VALUE
00:AB11 C503            	    52:   cmp VALUE2
00:AB13 D0F3            	    53:   bne exp_false
00:AB15 A501            	    54:   lda VALUE+1
00:AB17 C504            	    55:   cmp VALUE2+1
00:AB19 D0ED            	    56:   bne exp_false
00:AB1B A502            	    57:   lda VALUE+2
00:AB1D C505            	    58:   cmp VALUE2+2
00:AB1F D0E7            	    59:   bne exp_false
00:AB21 80DC            	    60:   bra exp_true
                        	    61: 
                        	    62: exp_neq:
00:AB23 A500            	    63:   lda VALUE
00:AB25 C503            	    64:   cmp VALUE2
00:AB27 D0D6            	    65:   bne exp_true
00:AB29 A501            	    66:   lda VALUE+1
00:AB2B C504            	    67:   cmp VALUE2+1
00:AB2D D0D0            	    68:   bne exp_true
00:AB2F A502            	    69:   lda VALUE+2
00:AB31 C505            	    70:   cmp VALUE2+2
00:AB33 D0CA            	    71:   bne exp_true
00:AB35 80D1            	    72:   bra exp_false
                        	    73: 
                        	    74: exp_less_than:
00:AB37 20E9AA          	    75:   jsr exp_subtract
00:AB3A 30C3            	    76:   bmi exp_true
00:AB3C 10CA            	    77:   bpl exp_false
                        	    78: 
                        	    79: exp_greater_than:
00:AB3E 20E9AA          	    80:   jsr exp_subtract
00:AB41 30C5            	    81:   bmi exp_false
00:AB43 D0BA            	    82:   bne exp_true
00:AB45 98              	    83:   tya
00:AB46 D0B7            	    84:   bne exp_true
00:AB48 8A              	    85:   txa
00:AB49 D0B4            	    86:   bne exp_true
00:AB4B 10BB            	    87:   bpl exp_false
                        	    88: 
                        	    89: exp_leq:
00:AB4D 20E9AA          	    90:   jsr exp_subtract
00:AB50 30AD            	    91:   bmi exp_true
00:AB52 D0B4            	    92:   bne exp_false
00:AB54 98              	    93:   tya
00:AB55 D0B1            	    94:   bne exp_false
00:AB57 8A              	    95:   txa
00:AB58 D0AE            	    96:   bne exp_false
00:AB5A 10A3            	    97:   bpl exp_true
                        	    98: 
                        	    99: exp_geq:
00:AB5C 20E9AA          	   100:   jsr exp_subtract
00:AB5F 30A7            	   101:   bmi exp_false
00:AB61 109C            	   102:   bpl exp_true
                        	   103: 
                        	   104: exp_bitwise_or:
00:AB63 A500            	   105:   lda VALUE
00:AB65 0503            	   106:   ora VALUE2
00:AB67 8500            	   107:   sta VALUE
00:AB69 A8              	   108:   tay
00:AB6A A501            	   109:   lda VALUE+1
00:AB6C 0504            	   110:   ora VALUE2+1
00:AB6E 8501            	   111:   sta VALUE+1
00:AB70 AA              	   112:   tax
00:AB71 A502            	   113:   lda VALUE+2
00:AB73 0505            	   114:   ora VALUE2+2
00:AB75 8502            	   115:   sta VALUE+2
00:AB77 60              	   116:   rts
                        	   117: 
                        	   118: exp_bitwise_and:
00:AB78 A500            	   119:   lda VALUE
00:AB7A 2503            	   120:   and VALUE2
00:AB7C 8500            	   121:   sta VALUE
00:AB7E A8              	   122:   tay
00:AB7F A501            	   123:   lda VALUE+1
00:AB81 2504            	   124:   and VALUE2+1
00:AB83 8501            	   125:   sta VALUE+1
00:AB85 AA              	   126:   tax
00:AB86 A502            	   127:   lda VALUE+2
00:AB88 2505            	   128:   and VALUE2+2
00:AB8A 8502            	   129:   sta VALUE+2
00:AB8C 60              	   130:   rts
                        	   131: 
                        	   132: exp_bitwise_xor:
00:AB8D A500            	   133:   lda VALUE
00:AB8F 4503            	   134:   eor VALUE2
00:AB91 8500            	   135:   sta VALUE
00:AB93 A8              	   136:   tay
00:AB94 A501            	   137:   lda VALUE+1
00:AB96 4504            	   138:   eor VALUE2+1
00:AB98 8501            	   139:   sta VALUE+1
00:AB9A AA              	   140:   tax
00:AB9B A502            	   141:   lda VALUE+2
00:AB9D 4505            	   142:   eor VALUE2+2
00:AB9F 8502            	   143:   sta VALUE+2
00:ABA1 60              	   144:   rts
                        	   145: 
                        	   146: 
00:ABA2 4CFFAA          	   147: exp_trueJ jmp exp_true
00:ABA5 4C08AB          	   148: exp_falseJ jmp exp_false
                        	   149: 
                        	   150: exp_logical_or:
00:ABA8 2063AB          	   151:   jsr exp_bitwise_or
00:ABAB D0F5            	   152:   bne exp_trueJ
00:ABAD E000            	   153:   cpx #0
00:ABAF D0F1            	   154:   bne exp_trueJ
00:ABB1 C000            	   155:   cpy #0
00:ABB3 D0ED            	   156:   bne exp_trueJ
00:ABB5 80EE            	   157:   bra exp_falseJ
                        	   158: 
                        	   159: exp_logical_and:
00:ABB7 A500            	   160:   lda VALUE
00:ABB9 0501            	   161:   ora VALUE+1
00:ABBB 0502            	   162:   ora VALUE+2
00:ABBD F0E6            	   163:   beq exp_falseJ  ; if VALUE has all bits zero the logical "and" must be false
                        	   164: ;
                        	   165: ;  VALUE is non-zero, how about VALUE2?
                        	   166: ;
00:ABBF A503            	   167:   lda VALUE2
00:ABC1 0504            	   168:   ora VALUE2+1
00:ABC3 0505            	   169:   ora VALUE2+2
00:ABC5 F0DE            	   170:   beq exp_falseJ  ; if VALUE2 has all bits zero the logical "and" must be false
00:ABC7 80D9            	   171:   bra exp_trueJ   ; both are non-zero, therefore the result is true
                        	   172: 
                        	   173: exp_shift_left:
00:ABC9 A504            	   174:   lda VALUE2+1
00:ABCB 0505            	   175:   ora VALUE2+2
00:ABCD D0D6            	   176:   bne exp_falseJ  ; big shifts will return zero
00:ABCF A503            	   177:   lda VALUE2
00:ABD1 F00E            	   178:   beq exp_shift_left_done ; shift by zero? we are done then
00:ABD3 AA              	   179:   tax
00:ABD4 29E0            	   180:   and #$E0        ; maximum of 32 shifts
00:ABD6 D0CD            	   181:   bne exp_falseJ
                        	   182: exp_shift_left_loop:
00:ABD8 0600            	   183:   asl VALUE
00:ABDA 2601            	   184:   rol VALUE+1
00:ABDC 2602            	   185:   rol VALUE+2
00:ABDE CA              	   186:   dex
00:ABDF D0F7            	   187:   bne exp_shift_left_loop
                        	   188: exp_shift_left_done:
00:ABE1 60              	   189:   rts
                        	   190: 
                        	   191: exp_shift_right:
00:ABE2 A504            	   192:   lda VALUE2+1
00:ABE4 0505            	   193:   ora VALUE2+2
00:ABE6 D0BD            	   194:   bne exp_falseJ  ; big shifts will return zero
00:ABE8 A503            	   195:   lda VALUE2
00:ABEA F00E            	   196:   beq exp_shift_right_done ; shift by zero? we are done then
00:ABEC AA              	   197:   tax
00:ABED 29E0            	   198:   and #$E0        ; maximum of 32 shifts
00:ABEF D0B4            	   199:   bne exp_falseJ
                        	   200: exp_shift_right_loop:
00:ABF1 4602            	   201:   lsr VALUE+2
00:ABF3 6601            	   202:   ror VALUE+1
00:ABF5 6600            	   203:   ror VALUE
00:ABF7 CA              	   204:   dex
00:ABF8 D0F7            	   205:   bne exp_shift_right_loop
                        	   206: exp_shift_right_done:
00:ABFA 60              	   207:   rts
                        	   208: 
                        	   209: exp_negate:
00:ABFB A500            	   210:   lda VALUE
00:ABFD 49FF            	   211:   eor #$FF
00:ABFF 8500            	   212:   sta VALUE
00:AC01 A501            	   213:   lda VALUE+1
00:AC03 49FF            	   214:   eor #$FF
00:AC05 8501            	   215:   sta VALUE+1
00:AC07 A502            	   216:   lda VALUE+2
00:AC09 49FF            	   217:   eor #$FF
00:AC0B 8502            	   218:   sta VALUE+2
00:AC0D 60              	   219:   rts
                        	   220: 
                        	   221: exp_not:
00:AC0E A500            	   222:   lda VALUE
00:AC10 D093            	   223:   bne exp_falseJ
00:AC12 A501            	   224:   lda VALUE+1
00:AC14 D08F            	   225:   bne exp_falseJ
00:AC16 A502            	   226:   lda VALUE+2
00:AC18 D08B            	   227:   bne exp_falseJ
00:AC1A 8086            	   228:   bra exp_trueJ
                        	   229: 
                        	   230: exp_unary_minus:
00:AC1C 38              	   231:   sec
00:AC1D A900            	   232:   lda #0
00:AC1F E500            	   233:   sbc VALUE
00:AC21 8500            	   234:   sta VALUE
00:AC23 A900            	   235:   lda #0
00:AC25 E501            	   236:   sbc VALUE+1
00:AC27 8501            	   237:   sta VALUE+1
00:AC29 A900            	   238:   lda #0
00:AC2B E502            	   239:   sbc VALUE+2
00:AC2D 8502            	   240:   sta VALUE+2
00:AC2F 60              	   241:   rts
                        	   242: 
                        	   243: 
                        	   244: exp_low_byte:
00:AC30 6401            	   245:   stz VALUE+1
00:AC32 6402            	   246:   stz VALUE+2
00:AC34 60              	   247:   rts
                        	   248: 
                        	   249: exp_high_byte:
00:AC35 A501            	   250:   lda VALUE+1
00:AC37 8500            	   251:   sta VALUE
00:AC39 6401            	   252:   stz VALUE+1
00:AC3B 6402            	   253:   stz VALUE+2
00:AC3D 60              	   254:   rts
                        	   255: 
                        	   256: ;
                        	   257: ;  make VALUE positive
                        	   258: ;
                        	   259: exp_abs_val:
00:AC3E A502            	   260:   lda  VALUE+2  ; check high-order byte, see if negative
00:AC40 1013            	   261:   bpl  exp_abs_val_done
                        	   262: exp_negate_val:
00:AC42 38              	   263:   sec
00:AC43 A900            	   264:   lda  #0
00:AC45 E500            	   265:   sbc  VALUE
00:AC47 8500            	   266:   sta  VALUE
00:AC49 A900            	   267:   lda  #0
00:AC4B E501            	   268:   sbc  VALUE+1
00:AC4D 8501            	   269:   sta  VALUE+1
00:AC4F A900            	   270:   lda  #0
00:AC51 E502            	   271:   sbc  VALUE+2
00:AC53 8502            	   272:   sta  VALUE+2
                        	   273: exp_abs_val_done:
00:AC55 60              	   274:   rts
                        	   275: 
                        	   276: ;
                        	   277: ;  make VALUE2 positive
                        	   278: ;
                        	   279: exp_abs_val2:
00:AC56 A505            	   280:   lda  VALUE2+2  ; check high-order byte, see if negative
00:AC58 1013            	   281:   bpl  exp_abs_val2_done
                        	   282: exp_negate_val2:
00:AC5A 38              	   283:   sec
00:AC5B A900            	   284:   lda  #0
00:AC5D E503            	   285:   sbc  VALUE2
00:AC5F 8503            	   286:   sta  VALUE2
00:AC61 A900            	   287:   lda  #0
00:AC63 E504            	   288:   sbc  VALUE2+1
00:AC65 8504            	   289:   sta  VALUE2+1
00:AC67 A900            	   290:   lda  #0
00:AC69 E505            	   291:   sbc  VALUE2+2
00:AC6B 8505            	   292:   sta  VALUE2+2
                        	   293: exp_abs_val2_done:
00:AC6D 60              	   294:   rts
                        	   295: 
                        	   296: 
                        	   297: ZERRES:
00:AC6E A900            	   298:   lda  #0
00:AC70 8552            	   299:   sta  RES
00:AC72 8553            	   300:   sta  RES+1
00:AC74 8554            	   301:   sta  RES+2
00:AC76 60              	   302:   rts
                        	   303: 
                        	   304: exp_find_sign:
00:AC77 206EAC          	   305:    jsr  ZERRES     ; zero result
00:AC7A A502            	   306:    lda  VALUE+2
00:AC7C 2980            	   307:    and  #$80
00:AC7E 855B            	   308:    sta  RMNDR
00:AC80 A505            	   309:    lda  VALUE2+2
00:AC82 2980            	   310:    and  #$80
00:AC84 455B            	   311:    eor  RMNDR
00:AC86 855B            	   312:    sta  RMNDR     ; RMNDR is 0x80 if the result needs to be negative
00:AC88 203EAC          	   313:    jsr  exp_abs_val
00:AC8B 2056AC          	   314:    jsr  exp_abs_val2
00:AC8E 60              	   315:    rts
                        	   316: ;
                        	   317: 
                        	   318: exp_fix_sign:
00:AC8F A55B            	   319:   lda  RMNDR
00:AC91 100F            	   320:   bpl  exp_fix_sign_done      ; nothing needs to be changed
00:AC93 38              	   321:   sec                         ; subtract result from zero
00:AC94 A900            	   322:   lda  #0
00:AC96 E552            	   323:   sbc  RES
00:AC98 AA              	   324:   tax
00:AC99 A900            	   325:   lda  #0
00:AC9B E553            	   326:   sbc  RES+1
00:AC9D A8              	   327:   tay
00:AC9E A900            	   328:   lda  #0
00:ACA0 E554            	   329:   sbc  RES+2
                        	   330: exp_fix_sign_done:
00:ACA2 60              	   331:   rts
                        	   332: 
                        	   333: 
                        	   334: ;
                        	   335: ;  multiply VALUE1 by VALUE2 and store in VALUE
                        	   336: ;
                        	   337: ;  see: https://llx.com/Neil/a2/mult.html for a discussion
                        	   338: ;
                        	   339: 
                        	   340: exp_multiply:
00:ACA3 2077AC          	   341:   jsr exp_find_sign
00:ACA6 A218            	   342:   ldx  #24       ; for all 24 bits
                        	   343: exp_multiply_loop:
00:ACA8 0652            	   344:   asl  RES
00:ACAA 2653            	   345:   rol  RES+1
00:ACAC 2654            	   346:   rol  RES+2                    ; shift RES left one bit
00:ACAE 0600            	   347:   asl  VALUE
00:ACB0 2601            	   348:   rol  VALUE+1
00:ACB2 2602            	   349:   rol  VALUE+2                  ; shift one argument left one bit and get the low-order bit into carry
00:ACB4 9013            	   350:   bcc  exp_multiply_no_add      ; if no low-order bit, don't add anything
00:ACB6 18              	   351:   clc                           ; add the other argument to the result
00:ACB7 A503            	   352:   lda  VALUE2
00:ACB9 6552            	   353:   adc  RES
00:ACBB 8552            	   354:   sta  RES
00:ACBD A504            	   355:   lda  VALUE2+1
00:ACBF 6553            	   356:   adc  RES+1
00:ACC1 8553            	   357:   sta  RES+1
00:ACC3 A505            	   358:   lda  VALUE2+2
00:ACC5 6554            	   359:   adc  RES+2
00:ACC7 8554            	   360:   sta  RES+2
                        	   361: exp_multiply_no_add:
00:ACC9 CA              	   362:   dex                      ; count bits
00:ACCA D0DC            	   363:   bne  exp_multiply_loop   ; go back if more to go
00:ACCC 208FAC          	   364:   jsr  exp_fix_sign
00:ACCF A552            	   365:   lda  RES
00:ACD1 8500            	   366:   sta  VALUE
00:ACD3 A553            	   367:   lda  RES+1
00:ACD5 8501            	   368:   sta  VALUE+1
00:ACD7 A554            	   369:   lda  RES+2
00:ACD9 8502            	   370:   sta  VALUE+2
00:ACDB 60              	   371:   rts
                        	   372: 
                        	   373: ;
                        	   374: ;  divide VALUE by VALUE2, store result in VALUE
                        	   375: ;
                        	   376: exp_divide:
00:ACDC 2077AC          	   377:   jsr exp_find_sign
                        	   378: 
00:ACDF A503            	   379:   lda  VALUE2
00:ACE1 0504            	   380:   ora  VALUE2+1
00:ACE3 0505            	   381:   ora  VALUE2+2
00:ACE5 D005            	   382:   bne  exp_divide_not_zero  ; check not dividing by zero
00:ACE7 A22F            	   383:   ldx  #47                  ; ERROR: divide by zero
00:ACE9 4C0E9F          	   384:   jmp  ass_error
                        	   385:   ;
                        	   386: exp_divide_not_zero:
00:ACEC 206EAC          	   387:   jsr  ZERRES     ; zero result (RES) - leaves zero in A register
00:ACEF 8506            	   388:   sta  REMAIN
00:ACF1 8507            	   389:   sta  REMAIN+1
00:ACF3 8508            	   390:   sta  REMAIN+2
00:ACF5 A918            	   391:   lda  #24       ; for all 24 bits of the operands ...
00:ACF7 858D            	   392:   sta  maths_work
                        	   393: exp_divide_loop:
00:ACF9 0600            	   394:   asl  VALUE
00:ACFB 2601            	   395:   rol  VALUE+1
00:ACFD 2602            	   396:   rol  VALUE+2    ; shift the dividend left one bit
00:ACFF 2606            	   397:   rol  REMAIN    ; the low-order bit of the dividend is shifted into the remainder
00:AD01 2607            	   398:   rol  REMAIN+1
00:AD03 2608            	   399:   rol  REMAIN+2
00:AD05 38              	   400:   sec
00:AD06 A506            	   401:   lda  REMAIN    ; do a trial subtraction of: remainder - divisor
00:AD08 E503            	   402:   sbc  VALUE2
00:AD0A AA              	   403:   tax
00:AD0B A507            	   404:   lda  REMAIN+1
00:AD0D E504            	   405:   sbc  VALUE2+1
00:AD0F A8              	   406:   tay
00:AD10 A508            	   407:   lda  REMAIN+2
00:AD12 E505            	   408:   sbc  VALUE2+2
00:AD14 300B            	   409:   bmi  exp_divide_subtraction_negative      ; if the subtraction fails (is negative) then discard the result
00:AD16 8508            	   410:   sta  REMAIN+2  ; if it succeeds then the result of the subtraction is our new remainder
00:AD18 98              	   411:   tya
00:AD19 8507            	   412:   sta  REMAIN+1
00:AD1B 8A              	   413:   txa
00:AD1C 8506            	   414:   sta  REMAIN
00:AD1E 38              	   415:   sec            ; shift a one-bit into the quotient
00:AD1F B001            	   416:   bcs  exp_divide_subtraction_positive
                        	   417: exp_divide_subtraction_negative:
00:AD21 18              	   418:   clc            ; here if subtraction failed, quotient (RES) gets a 0-bit shifted in
                        	   419: exp_divide_subtraction_positive:
00:AD22 2652            	   420:   rol  RES       ; the carry bit (from above) is shifted into the quotient
00:AD24 2653            	   421:   rol  RES+1
00:AD26 2654            	   422:   rol  RES+2
00:AD28 C68D            	   423:   dec  maths_work      ; one less bit to go
00:AD2A D0CD            	   424:   bne  exp_divide_loop      ; repeat until 24 bits done
00:AD2C 208FAC          	   425:   jsr  exp_fix_sign
00:AD2F A552            	   426:   lda  RES
00:AD31 8500            	   427:   sta  VALUE
00:AD33 A553            	   428:   lda  RES+1
00:AD35 8501            	   429:   sta  VALUE+1
00:AD37 A554            	   430:   lda  RES+2
00:AD39 8502            	   431:   sta  VALUE+2
00:AD3B 60              	   432:   rts
                        	   433: 
                        	   434: exp_modulo:
00:AD3C 20DCAC          	   435:   jsr exp_divide
00:AD3F A506            	   436:   lda REMAIN
00:AD41 8500            	   437:   sta VALUE
00:AD43 A507            	   438:   lda REMAIN+1
00:AD45 8501            	   439:   sta VALUE+1
00:AD47 A508            	   440:   lda REMAIN+2
00:AD49 8502            	   441:   sta VALUE+2
00:AD4B 60              	   442:   rts
                        	   443: 

Source: "gpascal.asm"
                        	   180:   .include "interpreter.inc"

Source: "interpreter.inc"
                        	     1: ;--------------------------------------------------
                        	     2: ; Runtime P-code interpreter
                        	     3: ;
                        	     4: ;--------------------------------------------------
                        	     5: 
                        	     6: 
                        	     7: ;--------------------------------
                        	     8: ; P-codes - these are generated in the compilation phase and looked up
                        	     9: ;           in execution_address_table at runtime
                        	    10: ;
                        	    11: ; Note: some P-codes must appear in sequence, eg. PCODE_STO and PCODE_STOC
                        	    12: ;       That is because one refers to integers (STO) and one refers to characters (STOC)
                        	    13: ;       The code in various places is virtually identical except it adds 1 to the P-code
                        	    14: ;       for characters. These generally are the Load/Store operations.
                        	    15: ;--------------------------------
                        	    16: 
                        	    17: ; Not implemented yet: $05, $13, $15, $39
                        	    18: 
                        	    19: ;                 Code            Description                         Arguments
                        	    20: ;                 ----            -----------------------------       -----------------------
                        	    21: PCODE_LIT     =   $00 ; Dec:  0 - Load constant                     - 3-byte literal (number)
                        	    22: PCODE_STACK   =   $01 ; Dec:  1 - Alter runtime stack to address    - 2-byte stack address
                        	    23: PCODE_NEG     =   $02 ; Dec:  2 - Unary minus 0 - (sp)              - none
                        	    24: PCODE_LIB_CALL =  $03 ; Dec:  3 - Call library function/procedure   - absolute address
                        	    25: PCODE_ADD     =   $04 ; Dec:  4 - Add (sp) to (sp - 1)              - none
                        	    26: PCODE_SUB     =   $06 ; Dec:  6 - Subtract (sp) from (sp - 1)       - none
                        	    27: PCODE_MUL     =   $08 ; Dec:  8 - Multiply (sp) * (sp - 1)          - none
                        	    28: PCODE_DIV     =   $0A ; Dec: 10 - Divide (sp - 1) / (sp)            - none
                        	    29: PCODE_MOD     =   $0B ; Dec: 11 - Modulus (sp - 1) MOD (sp)         - none
                        	    30: PCODE_ADRNN   =   $0C ; Dec: 12 - Address of integer                - level, displ
                        	    31: PCODE_ADRNC   =   $0D ; Dec: 13 - Address of character              - level, displ
                        	    32: PCODE_ADRAN   =   $0E ; Dec: 14 - Address of integer array          - level, displ
                        	    33: PCODE_ADRAC   =   $0F ; Dec: 15 - Address of character array        - level, displ
                        	    34: PCODE_EQL     =   $10 ; Dec: 16 - Test (sp - 1) == (sp)             - none
                        	    35: PCODE_FINISHD =   $11 ; Dec: 17 - Stop run (end program)            - none
                        	    36: PCODE_NEQ     =   $12 ; Dec: 18 - Test (sp - 1) != (sp)             - none
                        	    37: PCODE_LSS     =   $14 ; Dec: 20 - Test (sp - 1) < (sp)              - none
                        	    38: PCODE_GEQ     =   $16 ; Dec: 22 - Test (sp - 1) >= (sp)             - none
                        	    39: PCODE_GTR     =   $18 ; Dec: 24 - Test (sp - 1) > (sp)              - none
                        	    40: PCODE_LEQ     =   $19 ; Dec: 25 - Test (sp - 1) <= (sp)             - none
                        	    41: PCODE_ORR     =   $1A ; Dec: 26 - OR  (sp - 1) | (sp)               - none
                        	    42: PCODE_AND     =   $1B ; Dec: 27 - AND (sp - 1) & (sp)               - none
                        	    43: PCODE_INP     =   $1C ; Dec: 28 - Input number                      - none
                        	    44: PCODE_INPC    =   $1D ; Dec: 29 - Input character                   - none
                        	    45: PCODE_OUT     =   $1E ; Dec: 30 - Output number                     - none
                        	    46: PCODE_OUTC    =   $1F ; Dec: 31 - Output character                  - none
                        	    47: PCODE_EOR     =   $20 ; Dec: 32 - Not (sp) (logical negate)         - none
                        	    48: PCODE_OUH     =   $21 ; Dec: 33 - Output hex number                 - none
                        	    49: PCODE_SHL     =   $22 ; Dec: 34 - Shift left (sp) bits              - none
                        	    50: PCODE_OUS     =   $23 ; Dec: 35 - Output string                     - length, string
                        	    51: PCODE_SHR     =   $24 ; Dec: 36 - Shift right (sp) bits             - none
                        	    52: PCODE_INS     =   $25 ; Dec: 37 - Input string into array           - max, level, displ
                        	    53: PCODE_INC     =   $26 ; Dec: 38 - Increment (sp) by 1               - none
                        	    54: PCODE_CLL     =   $27 ; Dec: 39 - Relative procedure/function call  - level, relative address
                        	    55: PCODE_DEC     =   $28 ; Dec: 40 - Decrement (sp) by 1               - none
                        	    56: PCODE_RTN     =   $29 ; Dec: 41 - Procedure/function return         - none
                        	    57: PCODE_MOV     =   $2A ; Dec: 42 - Copy (sp) to (sp + 1)             - none
                        	    58: PCODE_CLA     =   $2B ; Dec: 43 - Call absolute address             - none
                        	    59: PCODE_LOD     =   $2C ; Dec: 44 - Load integer onto stack           - level, displ
                        	    60: PCODE_LODC    =   $2D ; Dec: 45 - Load character onto stack         - level, displ
                        	    61: PCODE_LDA     =   $2E ; Dec: 46 - Load absolute address integer     - none
                        	    62: PCODE_LDAC    =   $2F ; Dec: 47 - Load absolute address character   - none
                        	    63: PCODE_LDI     =   $30 ; Dec: 48 - Load integer indexed              - level, displ
                        	    64: PCODE_LDIC    =   $31 ; Dec: 49 - Load character indexed            - level, displ
                        	    65: PCODE_STO     =   $32 ; Dec: 50 - Store integer                     - level, displ
                        	    66: PCODE_STOC    =   $33 ; Dec: 51 - Store character                   - level, displ
                        	    67: PCODE_STA     =   $34 ; Dec: 52 - Store integer absolute address    - none
                        	    68: PCODE_STAC    =   $35 ; Dec: 53 - Store character absolute address  - none
                        	    69: PCODE_STI     =   $36 ; Dec: 54 - Store integer indexed             - level, displ
                        	    70: PCODE_STIC    =   $37 ; Dec: 55 - Store character indexed           - level, displ
                        	    71: PCODE_ABSCLL  =   $38 ; Dec: 56 - Absolute procedure/function call  - level, absolute address
                        	    72: PCODE_XOR     =   $3A ; Dec: 58 - XOR (sp - 1) ^ (sp)               - none
                        	    73: PCODE_INT     =   $3B ; Dec: 59 - Increment stack pointer           - increment
                        	    74: PCODE_JMP     =   $3C ; Dec: 60 - Jump unconditionally              - relative address
                        	    75: PCODE_JMZ     =   $3D ; Dec: 61 - Jump if (sp) zero                 - relative address
                        	    76: PCODE_JM1     =   $3E ; Dec: 62 - Jump if (sp) not zero             - relative address
                        	    77: PCODE_OUTCR   =   $40 ; Dec: 64 - Output a carriage-return          - none
                        	    78: PCODE_LCD_WRITE_NUM = $42 ; Dec: 66 - Write number to LCD           - none
                        	    79: PCODE_LCD_WRITE_STR = $43 ; Dec: 67 - Write string to LCD           - none
                        	    80: PCODE_LCD_WRITE_HEX = $44 ; Dec: 68 - Write hex number to LCD       - none
                        	    81: PCODE_LCD_WRITE_CHR = $45 ; Dec: 69 - Write character to LCD        - none
                        	    82: 
                        	    83: PCODE_LAST    =   PCODE_LCD_WRITE_CHR  ; PUT THIS LAST! (error check)                  -
                        	    84: 
                        	    85: ; 0x80 to 0xFF - Load low literal (onto stack), where literal is P-code with 8-bit clear (ie. P-code & 0x7F)
                        	    86: 
                        	    87: 
                        	    88: ;
                        	    89: ;  P-code execution routine lookup.
                        	    90: ;  For symbolic version see list above
                        	    91: ;
                        	    92: ;  Y is zero when starting to execute these routines
                        	    93: ;
                        	    94: execution_address_table  =  *
00:AD4C 7DB0            	    95:   word  EX_LIT             ; $00 = LIT      Load constant
00:AD4E 71B4            	    96:   word  EX_NEW_STACK       ; $01 =          Change stack to addr
00:AD50 8FB0            	    97:   word  EX_NEG             ; $02 = NEG      Unary minus: 0 - (sp)
00:AD52 FDB5            	    98:   word  EX_LIB_CALL        ; $03 = LIB_CALL Library function call
00:AD54 98B0            	    99:   word  EX_ADD             ; $04 = ADD      Add (sp) to (sp - 1)
00:AD56 ABAF            	   100:   word  EX_INVINS          ; $05 =          NOT IMPLEMENTED
00:AD58 A1B0            	   101:   word  EX_SUB             ; $06 = SUB      Subtract (sp) from (sp - 1)
00:AD5A ABAF            	   102:   word  EX_INVINS          ; $07 =          NOT IMPLEMENTED
00:AD5C ADB0            	   103:   word  EX_MUL             ; $08 = MUL      Multiply (sp) * (sp - 1)
00:AD5E ABAF            	   104:   word  EX_INVINS          ; $09 =          NOT IMPLEMENTED
00:AD60 E8B0            	   105:   word  EX_DIV             ; $0A = DIV      Divide (sp - 1) / (sp)
00:AD62 BDB0            	   106:   word  EX_MOD             ; $0B = MOD      Modulus (sp - 1) MOD (sp)
00:AD64 5CB5            	   107:   word  EX_ADRNN           ; $0C = ADRNN    Address of integer
00:AD66 4CB5            	   108:   word  EX_ADRNC           ; $0D = ADRNC    Address of character
00:AD68 6AB5            	   109:   word  EX_ADRAN           ; $0E = ADRAN    Address of integer array
00:AD6A 70B5            	   110:   word  EX_ADRAC           ; $0F = ADRAC    Address of character array
00:AD6C 05B1            	   111:   word  EX_EQL             ; $10 = EQL      Test (sp - 1) == (sp)
00:AD6E F8AE            	   112:   word  EX_FINISHD         ; $11 = FINISHD  Stop run (end program)
00:AD70 1FB1            	   113:   word  EX_NEQ             ; $12 = NEQ      Test (sp - 1) != (sp)
00:AD72 ABAF            	   114:   word  EX_INVINS          ; $13 =          NOT IMPLEMENTED
00:AD74 28B1            	   115:   word  EX_LSS             ; $14 = LSS      Test (sp - 1) < (sp)
00:AD76 ABAF            	   116:   word  EX_INVINS          ; $15 =          NOT IMPLEMENTED
00:AD78 40B1            	   117:   word  EX_GEQ             ; $16 = GEQ      Test (sp - 1) >= (sp)
00:AD7A ABAF            	   118:   word  EX_INVINS          ; $17 =          NOT IMPLEMENTED
00:AD7C 34B1            	   119:   word  EX_GTR             ; $18 = GTR      Test (sp - 1) > (sp)
00:AD7E 4CB1            	   120:   word  EX_LEQ             ; $19 = LEQ      Test (sp - 1) <= (sp)
00:AD80 61B1            	   121:   word  EX_ORR             ; $1A = ORR      OR  (sp - 1) | (sp)
00:AD82 6AB1            	   122:   word  EX_AND             ; $1B = AND      AND (sp - 1) & (sp)
00:AD84 EAB2            	   123:   word  EX_INP             ; $1C = INP      Input number
00:AD86 B2B4            	   124:   word  EX_INPC            ; $1D = INPC     Input character
00:AD88 2AB3            	   125:   word  EX_OUT             ; $1E = OUT      Output number
00:AD8A CCB4            	   126:   word  EX_OUTC            ; $1F = OUTC     Output character
00:AD8C 73B1            	   127:   word  EX_EOR             ; $20 = EOR      Not (sp) (logical negate)
00:AD8E 3EB3            	   128:   word  EX_OUH             ; $21 = OUH      Output hex number
00:AD90 7CB1            	   129:   word  EX_SHL             ; $22 = SHL      Shift left (sp) bits
00:AD92 5EB3            	   130:   word  EX_OUS             ; $23 = OUS      Output string
00:AD94 88B1            	   131:   word  EX_SHR             ; $24 = SHR      Shift right (sp) bits
00:AD96 EEB4            	   132:   word  EX_INS             ; $25 = INS      Input string into array
00:AD98 94B1            	   133:   word  EX_INC             ; $26 = INC      Increment (sp) by 1
00:AD9A 98B3            	   134:   word  EX_CLL             ; $27 = CLL      Relative procedure/function call
00:AD9C ACB1            	   135:   word  EX_DEC             ; $28 = DEC      Decrement (sp) by 1
00:AD9E B1B2            	   136:   word  EX_RTN             ; $29 = RTN      Procedure/function return
00:ADA0 C4B1            	   137:   word  EX_MOV             ; $2A = MOV      Copy (sp) to (sp + 1)
00:ADA2 27B4            	   138:   word  EX_CLA             ; $2B = CLA      Call absolute address
00:ADA4 E7B1            	   139:   word  EX_LOD             ; $2C = LOD      Load integer onto stack
00:ADA6 D5B1            	   140:   word  EX_LODC            ; $2D = LODC     Load character onto stack
00:ADA8 08B2            	   141:   word  EX_LDA             ; $2E = LDA      Load absolute address integer
00:ADAA FDB1            	   142:   word  EX_LDAC            ; $2F = LDAC     Load absolute address character
00:ADAC 43B2            	   143:   word  EX_LDI             ; $30 = LDI      Load integer indexed
00:ADAE 3DB2            	   144:   word  EX_LDIC            ; $31 = LDIC     Load character indexed
00:ADB0 56B2            	   145:   word  EX_STO             ; $32 = STO      Store integer
00:ADB2 49B2            	   146:   word  EX_STOC            ; $33 = STOC     Store character
00:ADB4 69B2            	   147:   word  EX_STA             ; $34 = STA      Store integer absolute address
00:ADB6 7FB2            	   148:   word  EX_STAC            ; $35 = STAC     Store character absolute address
00:ADB8 96B2            	   149:   word  EX_STI             ; $36 = STI      Store integer indexed
00:ADBA 88B2            	   150:   word  EX_STIC            ; $37 = STIC     Store character indexed
00:ADBC 91B3            	   151:   word  EX_ABSCLL          ; $38 = ABSCLL   Absolute procedure/function call
00:ADBE ABAF            	   152:   word  EX_INVINS          ; $39 =          NOT IMPLEMENTED
00:ADC0 58B1            	   153:   word  EX_XOR             ; $3A = XOR      XOR (sp - 1) ^ (sp)
00:ADC2 47B4            	   154:   word  EX_INT             ; $3B = INT      Increment stack pointer
00:ADC4 83B4            	   155:   word  EX_JMP             ; $3C = JMP      Jump unconditionally
00:ADC6 96B4            	   156:   word  EX_JMZ             ; $3D = JMZ      Jump if (sp) zero
00:ADC8 A7B4            	   157:   word  EX_JM1             ; $3E = JM1      Jump if (sp) not zero
00:ADCA ABAF            	   158:   word  EX_INVINS          ; $3F =          NOT IMPLEMENTED
00:ADCC 58AF            	   159:   word  EX_OUTCR           ; $40 = OUTCR    Output a carriage-return
00:ADCE ABAF            	   160:   word  EX_INVINS          ; $41 =          NOT IMPLEMENTED
00:ADD0 2FB3            	   161:   word  EX_LCD_WRITE_NUM   ; $42 = LCD_WRITE_NUM  Write number to LCD
00:ADD2 63B3            	   162:   word  EX_LCD_WRITE_STR   ; $43 = LCD_WRITE_STR  Write string to LCD
00:ADD4 43B3            	   163:   word  EX_LCD_WRITE_HEX   ; $44 = LCD_WRITE_HEX  Write hex to LCD
00:ADD6 D1B4            	   164:   word  EX_LCD_WRITE_CHR   ; $45 = LCD_WRITE_CHR  Write character to LCD
                        	   165: 
                        	   166: ;--------------------------------------------------------------------------
                        	   167: ;
                        	   168: ;  STACK FRAMES
                        	   169: ;
                        	   170: ;  The compiler can't know where variables are actually going to be stored because
                        	   171: ;  they will be relative to the (interpreter) stack (not the processor stack) which
                        	   172: ;  is an unknown address because procedures/functions can be called directly or from
                        	   173: ;  other procedures/functions.
                        	   174: ;
                        	   175: ;  Hence variables are referenced to BASE which is the base of the current stack frame,
                        	   176: ;  thus a variable will be a certain offset from that. However in the case of nested
                        	   177: ;  calls we need to go back to a previous stack frame. That is what the 6-byte "stack
                        	   178: ;  frame linkage data" is about.
                        	   179: ;
                        	   180: ;  Variables are referred to by a "level difference" and a displacement. For the current
                        	   181: ;  procedure the level difference will be zero, and thus the variable will be BASE +
                        	   182: ;  the offset for this particular variable.
                        	   183: ;
                        	   184: ;  For variables in earlier procedures/functions (ones which called this one) there will
                        	   185: ;  be a level difference, being the depth (lexically) between the called function and the
                        	   186: ;  one with the variable. For example, if foo calls bar, and bar recurses five times, foo
                        	   187: ;  and bar are still only one level apart, from the point of view of accessing foo's
                        	   188: ;  variables.
                        	   189: ;
                        	   190: ;  Thus, to find an address we need to "walk" back through the STATIC stack frame links
                        	   191: ;  (bytes 5 and 6 of the stack frame data) to find the appropriate stack frame, and then
                        	   192: ;  take the offset from that.
                        	   193: ;
                        	   194: ;  However for recursive calls, once a recursed call ends, we need to get back the stack
                        	   195: ;  frame of the caller, which will be different from the static frame. So, to restore the
                        	   196: ;  stack frame after a procedure/function ends, we must take the DYNAMIC stack frame address
                        	   197: ;  (bytes 3 and 4 of the stack frame data) to get back the previous stack frame. In fact,
                        	   198: ;  all procedures/functions do this, it's just that the static and dynamic stack frames will
                        	   199: ;  be the same if the procedure/function does not recurse.
                        	   200: ;
                        	   201: ;  Finally, the return address (in the P-codes) for the procedure/function call is also
                        	   202: ;  stored in the stack frame data (bytes 1 and 2 of the stack frame data) so that, after
                        	   203: ;  doing a return, we can restore the P-code address to the PCODE variable after the call.
                        	   204: ;
                        	   205: ;  When a procedure/function is called these 6 bytes are pushed onto the stack. Then, for
                        	   206: ;  some reason, the code moves the stack pointer back 6 (adds to it). Then as part of the
                        	   207: ;  procedure/function initialisation the stack pointer has 6 or 9 added to it, to allow
                        	   208: ;  for not overwriting this stack frame data, and in the case of functions, the extra 3
                        	   209: ;  bytes are for the returned value.
                        	   210: ;
                        	   211: ;  Note that the stack grows downwards, as it starts at "high memory" (whatever that is
                        	   212: ;  defined as, and grows downwards, taking the gap between the end of the P-codes and the
                        	   213: ;  end of memory.
                        	   214: ;
                        	   215: ;  Then the function will add additional spaces to the stack (ie. by subtracting from the
                        	   216: ;  stack pointer) to make room for variables declared in that procedure/function. Now we
                        	   217: ;  are ready to push data onto the stack as part of normal expression evalution. It follows
                        	   218: ;  from this that variables initially have undefined values, as they will contain whatever
                        	   219: ;  happened to be in the stack when this space was allocated.
                        	   220: ;
                        	   221: ;  The function GETADR resolves these addresses by starting with BASE, the stack frame base
                        	   222: ;  for the current procedure/function, and then using the static stack frame link to load a
                        	   223: ;  (temporary) new base, and repeating that until the level difference is zero. Then it adds
                        	   224: ;  the offset of the wanted variable to the stack base to derive the actual variable address.
                        	   225: ;
                        	   226: ;--------------------------------------------------------------------------
                        	   227: 
                        	   228: 
                        	   229: ;
00:ADD8 20537461636B3A20	   230: DM1               asciiz  ' Stack: '
00:ADE0 00
00:ADE1 20426173653A2020	   231: DM2               asciiz  ' Base:  '
00:ADE9 00
00:ADEA 52756E6E696E670A	   232: running_message   asciiz  'Running\n'
00:ADF2 00
                        	   233: 
                        	   234: ;
                        	   235: DEBUG    =  *
00:ADF3 20AD92          	   236: DB11     jsr  DISPAD    ; display P-code address
00:ADF6 A523            	   237:          lda  PCODE
00:ADF8 8537            	   238:          sta  WORK
00:ADFA A524            	   239:          lda  PCODE+1
00:ADFC 8538            	   240:          sta  WORK+1
00:ADFE A204            	   241:          ldx  #4
00:AE00 20BCAE          	   242:          jsr  display_x_characters      ; display 4 bytes from WORK (ie. the P-codes)
00:AE03 209292          	   243:          jsr  CROUT
00:AE06 A649            	   244:          ldx  DBGFLG
00:AE08 3051            	   245:          bmi  DEBUG_DONE        ; trace only
00:AE0A A9D8            	   246:          lda  #<DM1             ; ' Stack: '
00:AE0C A2AD            	   247:          ldx  #>DM1
00:AE0E 202682          	   248:          jsr  print
00:AE11 A532            	   249:          lda  T+1
00:AE13 200793          	   250:          jsr  PRBYTE        ; display the stack pointer address
00:AE16 A531            	   251:          lda  T
00:AE18 20A792          	   252:          jsr  DISHX         ; display hex and a space after
00:AE1B A93D            	   253:          lda  #'='
00:AE1D 201994          	   254:          jsr  COUT
00:AE20 A531            	   255:          lda  T
00:AE22 8537            	   256:          sta  WORK
00:AE24 A532            	   257:          lda  T+1
00:AE26 8538            	   258:          sta  WORK+1
00:AE28 A209            	   259:          ldx  #9         ; show 9 bytes on stack, namely 3 variables
00:AE2A 20BCAE          	   260:          jsr  display_x_characters
00:AE2D 209292          	   261:          jsr  CROUT
00:AE30 A9E1            	   262:          lda  #<DM2       ; ' Base:  '
00:AE32 A2AD            	   263:          ldx  #>DM2
00:AE34 202682          	   264:          jsr  print
00:AE37 A53C            	   265:          lda  BASE+1
00:AE39 200793          	   266:          jsr  PRBYTE      ; display the base pointer address
00:AE3C A53B            	   267:          lda  BASE
00:AE3E 20A792          	   268:          jsr  DISHX
00:AE41 A93D            	   269:          lda  #'='
00:AE43 201994          	   270:          jsr  COUT
00:AE46 A53B            	   271:          lda  BASE
00:AE48 38              	   272:          sec
00:AE49 E906            	   273:          sbc  #6    ; the linkage data is 6 bytes below the base
00:AE4B 8537            	   274:          sta  WORK
00:AE4D A53C            	   275:          lda  BASE+1
00:AE4F E900            	   276:          sbc  #0
00:AE51 8538            	   277:          sta  WORK+1
00:AE53 A206            	   278:          ldx  #6    ; show 6 bytes of base linkage data (return, dynamic link, static link)
00:AE55 20BCAE          	   279:          jsr  display_x_characters
00:AE58 4C9292          	   280:          jmp  CROUT
                        	   281: 
00:AE5B 60              	   282: DEBUG_DONE rts
                        	   283: 
                        	   284: 
                        	   285: ;***********************************************
                        	   286: ; Interpreter initialization
                        	   287: ;***********************************************
                        	   288: 
                        	   289: INTERP   =  *
00:AE5C 08              	   290:   php
00:AE5D 68              	   291:   pla
00:AE5E 8513            	   292:   sta  call_p   ; make sure call_p has some reasonable value in it
                        	   293: ;
                        	   294: ;  Move the start of where the P-codes start into PCODE (our first P-code)
                        	   295: ;
00:AE60 A525            	   296:   lda  ACT_PCDA
00:AE62 8523            	   297:   sta  PCODE
00:AE64 A526            	   298:   lda  ACT_PCDA+1
00:AE66 8524            	   299:   sta  PCODE+1
                        	   300: ;
                        	   301: ;  Running message
                        	   302: ;
00:AE68 A9EA            	   303:   lda  #<running_message   ; Running
00:AE6A A2AD            	   304:   ldx  #>running_message
00:AE6C 202682          	   305:   jsr  print
                        	   306: ;
                        	   307: ;  Running flag
                        	   308: ;
00:AE6F A00C            	   309:   ldy  #$0C
00:AE71 843F            	   310:   sty  RUNNING
                        	   311: ;
                        	   312: ;  Set up the runtime stack pointer which is also our first stack frame base
                        	   313: ;
00:AE73 A9FF            	   314:   lda  #<HIGHEST_RAM
00:AE75 8531            	   315:   sta  T
00:AE77 853B            	   316:   sta  BASE
00:AE79 A93F            	   317:   lda  #>HIGHEST_RAM
00:AE7B 8532            	   318:   sta  T+1
00:AE7D 853C            	   319:   sta  BASE+1
                        	   320: 
00:AE7F 4C6DAF          	   321:   jmp  MAIN ; start interpreting
                        	   322: ;
                        	   323: ;
                        	   324: ;
                        	   325: 
                        	   326: 
                        	   327: ;***********************************************
                        	   328: ;  INTERPRETER
                        	   329: ;***********************************************
                        	   330: 
                        	   331: ;
                        	   332: ;
00:AE82 496C6C6567616C20	   333: DM5      asciiz  "Illegal instruction\n"
00:AE8A 696E737472756374
00:AE92 696F6E0A
00:AE96 00
00:AE97 427265616B202E2E	   334: DM6      asciiz  'Break ...\n'
00:AE9F 2E0A
00:AEA1 00
00:AEA2 4572726F72206F63	   335: DM7      asciiz  "Error occurred at P-code "
00:AEAA 6375727265642061
00:AEB2 7420502D636F6465
00:AEBA 20
00:AEBB 00
                        	   336: 
                        	   337: ;
                        	   338: ; DISPLAY (X) CHARACTERS FROM (WORK)
                        	   339: ;
                        	   340: display_x_characters:
00:AEBC 8A              	   341:          txa
00:AEBD 48              	   342:          pha
00:AEBE 201D93          	   343:          jsr  PUTSP
00:AEC1 68              	   344:          pla
00:AEC2 AA              	   345:          tax
00:AEC3 A000            	   346: DIS5     ldy  #0
00:AEC5 B137            	   347:          lda  (WORK),Y
00:AEC7 E637            	   348:          inc  WORK
00:AEC9 D002            	   349:          bne  DIS5_A
00:AECB E638            	   350:          inc  WORK+1
                        	   351: DIS5_A   =  *
00:AECD A8              	   352:          tay
00:AECE 8A              	   353:          txa
00:AECF 48              	   354:          pha
00:AED0 98              	   355:          tya
00:AED1 20A792          	   356:          jsr  DISHX
00:AED4 68              	   357:          pla
00:AED5 AA              	   358:          tax
00:AED6 CA              	   359:          dex
00:AED7 D0EA            	   360:          bne  DIS5
00:AED9 60              	   361:          rts
                        	   362: 
                        	   363: ;
                        	   364: ; Ding a bell - however we don't have it on this board
                        	   365: ;
                        	   366: BELL1    =  *
00:AEDA 48              	   367:          pha
00:AEDB A900            	   368:          lda  #0
00:AEDD 853F            	   369:          sta  RUNNING
00:AEDF 209292          	   370:          jsr  CROUT
00:AEE2 68              	   371:          pla
00:AEE3 60              	   372:          rts
                        	   373: ;
                        	   374: ;
00:AEE4 20DAAE          	   375: RUNERR   jsr  BELL1
00:AEE7 A9A2            	   376:          lda  #<DM7  ; Error occurred at P-code
00:AEE9 A2AE            	   377:          ldx  #>DM7
00:AEEB 202682          	   378:          jsr  print
00:AEEE A54E            	   379:          lda  LASTP+1
00:AEF0 200793          	   380:          jsr  PRBYTE
00:AEF3 A54D            	   381:          lda  LASTP
00:AEF5 20A792          	   382:          jsr  DISHX
                        	   383: EX_FINISHD  =  *
00:AEF8 A900            	   384:          lda  #0
00:AEFA 209292          	   385:          jsr  CROUT
00:AEFD A90F            	   386:          lda  #<FIN_MSG
00:AEFF A2AF            	   387:          ldx  #>FIN_MSG
00:AF01 202682          	   388:          jsr  print
00:AF04 648B            	   389:          stz  serial_in_byte_received  ; get rid of read-ahead
00:AF06 200FC9          	   390:          jsr  GETIN      ; wait till message seen
00:AF09 209292          	   391:          jsr  CROUT      ; output a newline in case they press space or something
00:AF0C 4C45D1          	   392:          jmp  RESTART
                        	   393: ;
00:AF0F 52756E2066696E69	   394: FIN_MSG  asciiz  'Run finished - press a key ...'
00:AF17 73686564202D2070
00:AF1F 726573732061206B
00:AF27 6579202E2E2E
00:AF2D 00
                        	   395: ;
                        	   396: ;
                        	   397: CHK_KBD  =  *
00:AF2E C90E            	   398:          cmp  #KEY_STOP_TRACE       ; Ctrl+N - stop tracing
00:AF30 D008            	   399:          bne  CHK_NOTN
00:AF32 648B            	   400:          stz  serial_in_byte_received
00:AF34 A900            	   401:          lda  #0
00:AF36 8549            	   402:          sta  DBGFLG
00:AF38 38              	   403:          sec
00:AF39 60              	   404:          rts
00:AF3A C914            	   405: CHK_NOTN cmp  #KEY_TRACE      ; Ctrl+T - start tracing
00:AF3C D00A            	   406:          bne  CHK_NOTT
00:AF3E 648B            	   407:          stz  serial_in_byte_received
00:AF40 A980            	   408:          lda  #$80
00:AF42 8549            	   409:          sta  DBGFLG
00:AF44 852E            	   410:          sta  DCODE
00:AF46 38              	   411:          sec
00:AF47 60              	   412:          rts
00:AF48 C904            	   413: CHK_NOTT cmp  #KEY_DEBUG      ; Ctrl+D - start debugging
00:AF4A D00A            	   414:          bne  CHK_NOTD
00:AF4C 648B            	   415:          stz  serial_in_byte_received
00:AF4E A901            	   416:          lda  #1
00:AF50 8549            	   417:          sta  DBGFLG
00:AF52 852E            	   418:          sta  DCODE
00:AF54 38              	   419:          sec
00:AF55 60              	   420:          rts
00:AF56 18              	   421: CHK_NOTD clc
00:AF57 60              	   422:          rts
                        	   423: ;
                        	   424: EX_OUTCR    =  *
00:AF58 209292          	   425:   jsr  CROUT      ; OUTPUT C/R
00:AF5B 4C6DAF          	   426:   jmp  MAIN
                        	   427: ;
                        	   428: ;  Here for a "low literal" - a P-code with the 0x80 bit set. Clear that bit and push
                        	   429: ;   the resulting number onto the stack
                        	   430: ;
                        	   431: LOWLIT:
00:AF5E E623            	   432:   inc  PCODE     ; increment P-code past the low literal
00:AF60 D002            	   433:   bne  LOWLIT1
00:AF62 E624            	   434:   inc  PCODE+1
                        	   435: LOWLIT1:
00:AF64 8401            	   436:   sty  REG+1     ; Y and REGB were cleared below
00:AF66 297F            	   437:   and  #$7F
00:AF68 8500            	   438:   sta  REG
                        	   439: ;
                        	   440: ;  fall down to push this value
                        	   441: ;
                        	   442: 
                        	   443: 
                        	   444: ;
                        	   445: ; Push previous result (REG) and then drop down to do the next instruction
                        	   446: ;
                        	   447: MAINP:
00:AF6A 204AB0          	   448:  jsr  PSHTOP    ; push REG onto stack and go back to MAIN
                        	   449: 
                        	   450: ;
                        	   451: ;  Main interpreter loop - each instruction jumps back here (or to MAINP above if it
                        	   452: ;              needs to push a previous calculation result)
                        	   453: ;
                        	   454: MAIN:
00:AF6D A549            	   455:   lda  DBGFLG   ; debugging?
00:AF6F F003            	   456:   beq  MAIN_2   ; no
00:AF71 20F3AD          	   457:   jsr  DEBUG    ; yes - show debug info
                        	   458: MAIN_2   =  *
                        	   459: ; check if key pressed here, to abort, or turn on/off tracing or debugging
00:AF74 A58B            	   460:   lda  serial_in_byte_received
00:AF76 F00A            	   461:   beq  MAIN_OK
00:AF78 C903            	   462:   cmp  #KEY_ABORT
00:AF7A D003            	   463:   bne  MAIN_NOT_ABORT
00:AF7C 4CF8AE          	   464:   jmp  EX_FINISHD
                        	   465: MAIN_NOT_ABORT = *
00:AF7F 202EAF          	   466:   jsr  CHK_KBD          ; check for turning on trace, debug, etc.
                        	   467: MAIN_OK  =  *
00:AF82 A523            	   468:   lda  PCODE             ; save P-code address as LASTP (for errors I presume)
00:AF84 854D            	   469:   sta  LASTP
00:AF86 A524            	   470:   lda  PCODE+1
00:AF88 854E            	   471:   sta  LASTP+1
                        	   472: ;
                        	   473: ;  now grab the P-code
                        	   474: ;
00:AF8A A000            	   475:   ldy  #0
00:AF8C 8402            	   476:   sty  REGB
00:AF8E B123            	   477:   lda  (PCODE),Y         ; get the P-code from the P-codes
00:AF90 30CC            	   478:   bmi  LOWLIT            ; low literal - just handle it
00:AF92 C946            	   479:   cmp  #PCODE_LAST+1
00:AF94 B015            	   480:   bcs  EX_INVINS         ; error if off end of table
                        	   481: ;
                        	   482: ;  increment past this P-code
                        	   483: ;
                        	   484: MAIN_5   =  *
00:AF96 E623            	   485:   inc  PCODE
00:AF98 D002            	   486:   bne  MAIN_1
00:AF9A E624            	   487:   inc  PCODE+1
                        	   488: ;
                        	   489: ;  grab the execution handler from the execution_address_table
                        	   490: ;
                        	   491: MAIN_1   =  *
00:AF9C 0A              	   492:   asl  A             ; double the P-code because each address takes 2 bytes
00:AF9D AA              	   493:   tax
00:AF9E BD4CAD          	   494:   lda  execution_address_table,X      ; otherwise get the execution address
00:AFA1 8537            	   495:   sta  WORK
00:AFA3 BD4DAD          	   496:   lda  execution_address_table+1,X    ; and the high-order byte
00:AFA6 8538            	   497:   sta  WORK+1
00:AFA8 6C3700          	   498:   jmp  (WORK)        ; execute the appropriate P-code implementation routine
                        	   499: 
                        	   500: ;
                        	   501: NOTIMP   =  *
                        	   502: EX_INVINS   =  *
00:AFAB A982            	   503:          LDA  #<DM5   ; Illegal Instruction
00:AFAD A2AE            	   504:          LDX  #>DM5
                        	   505: NOTIM1   =  *
00:AFAF 202682          	   506:          JSR  print
00:AFB2 4CE4AE          	   507:          JMP  RUNERR
                        	   508: ;
                        	   509: BREAK    =  *
00:AFB5 A997            	   510:          LDA  #<DM6  ; Break ...
00:AFB7 A2AE            	   511:          LDX  #>DM6
00:AFB9 4CAFAF          	   512:          JMP  NOTIM1
                        	   513: 
                        	   514: 
00:AFBC A000            	   515: GETADR   LDY  #0
00:AFBE B123            	   516:          LDA  (PCODE),Y     ; level
00:AFC0 854B            	   517:          STA  COUNT1        ; count of levels to work through
00:AFC2 A53C            	   518:          LDA  BASE+1        ; start with our stack base address
00:AFC4 A63B            	   519:          LDX  BASE
                        	   520: GET2     =  *
00:AFC6 853E            	   521:          STA  DATA+1        ; our data is relative to the stack base
00:AFC8 863D            	   522:          STX  DATA
00:AFCA A8              	   523:          TAY
00:AFCB A54B            	   524:          LDA  COUNT1        ; any levels left?
00:AFCD F018            	   525:          BEQ  GETADR1       ; no, we can continue
00:AFCF 38              	   526:          SEC                ; yes
00:AFD0 8A              	   527:          TXA                ; subtract 2 from the base to get the static link
00:AFD1 E902            	   528:          SBC  #2
00:AFD3 8537            	   529:          STA  WORK
00:AFD5 98              	   530:          TYA
00:AFD6 E900            	   531:          SBC  #0
00:AFD8 8538            	   532:          STA  WORK+1        ; BASE - 2 -> WORK
00:AFDA A000            	   533:          LDY  #0
00:AFDC B137            	   534:          LDA  (WORK),Y      ; grab contents of BASE-2
00:AFDE C8              	   535:          INY
00:AFDF AA              	   536:          TAX
00:AFE0 B137            	   537:          LDA  (WORK),Y
00:AFE2 C64B            	   538:          DEC  COUNT1        ; one less level
00:AFE4 4CC6AF          	   539:          JMP  GET2          ; keep going until we used all levels
                        	   540: 
                        	   541: GETADR1     =  *
00:AFE7 A001            	   542:          LDY  #1            ; now get the offset
00:AFE9 18              	   543:          CLC
00:AFEA B123            	   544:          LDA  (PCODE),Y     ; offset low-order byte
00:AFEC 653D            	   545:          ADC  DATA          ; add base
00:AFEE 853D            	   546:          STA  DATA
00:AFF0 C8              	   547:          INY
00:AFF1 B123            	   548:          LDA  (PCODE),Y     ; offset high-order byte
00:AFF3 653E            	   549:          ADC  DATA+1        ; add base
00:AFF5 853E            	   550:          STA  DATA+1        ; DATA now holds the data address
00:AFF7 A523            	   551:          LDA  PCODE         ; add 3 to PCODE to skip level and offset
00:AFF9 18              	   552:          CLC
00:AFFA 6903            	   553:          ADC  #3
00:AFFC 8523            	   554:          STA  PCODE
00:AFFE 9002            	   555:          BCC  GET1_A
00:B000 E624            	   556:          INC  PCODE+1
                        	   557: GET1_A   =  *
00:B002 60              	   558:          RTS                ; done - we can use DATA to access whatever-it-is
                        	   559: 
                        	   560: ;
                        	   561: ;  Pull the top item on the runtime stack into REG (aka VALUE)
                        	   562: ;
                        	   563: PULTOP   =  *
00:B003 A000            	   564:          LDY  #0
00:B005 B131            	   565:          LDA  (T),Y
00:B007 8500            	   566:          STA  REG
00:B009 C8              	   567:          INY
00:B00A B131            	   568:          LDA  (T),Y
00:B00C 8501            	   569:          STA  REG+1
00:B00E C8              	   570:          INY
00:B00F B131            	   571:          LDA  (T),Y
00:B011 8502            	   572:          STA  REGB
00:B013 A531            	   573:          LDA  T
00:B015 18              	   574:          CLC      ; add 3 to the stack because we removed one integer from it
00:B016 6903            	   575:          ADC  #3
00:B018 8531            	   576:          STA  T
00:B01A 9002            	   577:          BCC  PUL_END
00:B01C E632            	   578:          INC  T+1
                        	   579: PUL_END  =  *
00:B01E A500            	   580:          LDA  REG
00:B020 A601            	   581:          LDX  REG+1
00:B022 A402            	   582:          LDY  REGB
00:B024 60              	   583:          RTS
                        	   584: 
00:B025 2003B0          	   585: PULBOTH  JSR  PULTOP     ; Pulls both of them - do one and then fall through to do the other
                        	   586: 
                        	   587: ;
                        	   588: ;  Pull the top item on the runtime stack into REG2 (aka VALUE2)
                        	   589: ;
                        	   590: PULTOP2  =  *
00:B028 A000            	   591:          LDY  #0
00:B02A B131            	   592:          LDA  (T),Y
00:B02C 8503            	   593:          STA  REG2
00:B02E C8              	   594:          INY
00:B02F B131            	   595:          LDA  (T),Y
00:B031 8504            	   596:          STA  REG2+1
00:B033 C8              	   597:          INY
00:B034 B131            	   598:          LDA  (T),Y
00:B036 8505            	   599:          STA  REG2B
00:B038 A531            	   600:          LDA  T
00:B03A 18              	   601:          CLC         ; add 3 to the stack because we removed one integer from it
00:B03B 6903            	   602:          ADC  #3
00:B03D 8531            	   603:          STA  T
00:B03F 9002            	   604:          BCC  PUL2_END
00:B041 E632            	   605:          INC  T+1
                        	   606: PUL2_END =  *
00:B043 A503            	   607:          LDA  REG2
00:B045 A604            	   608:          LDX  REG2+1
00:B047 A405            	   609:          LDY  REG2B
00:B049 60              	   610:          RTS
                        	   611: 
                        	   612: ;
                        	   613: ;  Push REG (aka VALUE) onto the runtime stack
                        	   614: ;
                        	   615: PSHTOP   =  *
00:B04A 38              	   616:          SEC        ;  subtract 3 from the stack because we are about to add one integer to it
00:B04B A531            	   617:          LDA  T
00:B04D E903            	   618:          SBC  #3
00:B04F 8531            	   619:          STA  T
00:B051 B002            	   620:          BCS  PSH1
00:B053 C632            	   621:          DEC  T+1
                        	   622: PSH1     =  *
00:B055 A000            	   623:          LDY  #0
00:B057 A500            	   624:          LDA  REG
00:B059 9131            	   625:          STA  (T),Y
00:B05B C8              	   626:          INY
00:B05C A501            	   627:          LDA  REG+1
00:B05E 9131            	   628:          STA  (T),Y
00:B060 C8              	   629:          INY
00:B061 A502            	   630:          LDA  REGB
00:B063 9131            	   631:          STA  (T),Y
00:B065 60              	   632:          RTS
                        	   633: ;
                        	   634: ;  get a literal (2 bytes) from the P-codes and put it into REG
                        	   635: ;
                        	   636: GETLIT   =  *
00:B066 A000            	   637:   ldy  #0
00:B068 B123            	   638:   lda  (PCODE),Y
00:B06A 8500            	   639:   sta  REG
00:B06C C8              	   640:   iny
00:B06D B123            	   641:   lda  (PCODE),Y
00:B06F 8501            	   642:   sta  REG+1
00:B071 A523            	   643:   lda  PCODE
00:B073 18              	   644:   clc         ; P-code address goes up by 2
00:B074 6902            	   645:   adc  #2
00:B076 8523            	   646:   sta  PCODE
00:B078 9002            	   647:   bcc  GET_END
00:B07A E624            	   648:   inc  PCODE+1
                        	   649: GET_END:
00:B07C 60              	   650:   rts
                        	   651: ;
                        	   652: ; load literal onto the stack (the literal is the next 3 bytes after the P-code)
                        	   653: ;
                        	   654: EX_LIT:
00:B07D 2066B0          	   655:   jsr  GETLIT   ; get the first 2 bytes
00:B080 A000            	   656:   ldy  #0
00:B082 B123            	   657:   lda  (PCODE),Y    ; now the third byte
00:B084 8502            	   658:   sta  REGB
00:B086 E623            	   659:   inc  PCODE
00:B088 D002            	   660:   bne  LIT1
00:B08A E624            	   661:   inc  PCODE+1
                        	   662: LIT1:
00:B08C 4C6AAF          	   663:   jmp  MAINP    ; now we can push it
                        	   664: ;
                        	   665: ;  Negate (0 - (sp) )
                        	   666: ;
                        	   667: EX_NEG:
00:B08F 2003B0          	   668:   jsr PULTOP
00:B092 201CAC          	   669:   jsr exp_unary_minus
00:B095 4C6AAF          	   670:   jmp MAINP
                        	   671: ;
                        	   672: ;  Add (sp) to (sp -1)
                        	   673: ;
                        	   674: EX_ADD:
00:B098 2025B0          	   675:   JSR  PULBOTH
00:B09B 20D5AA          	   676:   jsr  exp_add
00:B09E 4C6AAF          	   677:   JMP  MAINP
                        	   678: ;
                        	   679: ;
                        	   680: ;  Add (sp) from (sp - 1)
                        	   681: ;
                        	   682: EX_SUB:
00:B0A1 2028B0          	   683:   JSR  PULTOP2
00:B0A4 2003B0          	   684:   jsr  PULTOP
00:B0A7 20E9AA          	   685:   jsr  exp_subtract
00:B0AA 4C6AAF          	   686:   JMP  MAINP
                        	   687: ;
                        	   688: ;  Multiply (sp) by (sp - 1)
                        	   689: ;
                        	   690: EX_MUL:
00:B0AD 2025B0          	   691:   jsr PULBOTH
00:B0B0 20A3AC          	   692:   jsr exp_multiply
00:B0B3 4C6AAF          	   693:   jmp MAINP
                        	   694: 
                        	   695: ;
                        	   696: ;  we will take the current key (and return to the user)
                        	   697: ;  and zero it out anyway, so that consumes the key
                        	   698: ;
                        	   699: EX_GETKEY   =  *
00:B0B6 A58B            	   700:   lda  serial_in_byte_received
00:B0B8 648B            	   701:   stz  serial_in_byte_received
00:B0BA 4C10B1          	   702:   jmp  TRUE2
                        	   703: ;
                        	   704: ;  Modulus (remainder)
                        	   705: ;
                        	   706: EX_MOD:
00:B0BD 2028B0          	   707:   jsr PULTOP2
                        	   708: ;
                        	   709: ;  check for divide by zero because I want a run-time error message
                        	   710: ;
00:B0C0 A503            	   711:   lda VALUE2
00:B0C2 0504            	   712:   ora VALUE2+1
00:B0C4 0505            	   713:   ora VALUE2+2
00:B0C6 F009            	   714:   beq EX_DIVIDE_BY_ZERO
00:B0C8 2003B0          	   715:   jsr PULTOP
00:B0CB 203CAD          	   716:   jsr exp_modulo
00:B0CE 4C6AAF          	   717:   jmp MAINP
                        	   718: ;
                        	   719: 
                        	   720: EX_DIVIDE_BY_ZERO:
00:B0D1 A9D8            	   721:   lda  #<DIVBY0
00:B0D3 A2B0            	   722:   ldx  #>DIVBY0
00:B0D5 4CAFAF          	   723:   jmp  NOTIM1
                        	   724: 
00:B0D8 4469766964652062	   725: DIVBY0   asciiz  'Divide by zero\n'
00:B0E0 79207A65726F0A
00:B0E7 00
                        	   726: ;
                        	   727: ;  Divide (sp - 1) by (sp)
                        	   728: ;
                        	   729: EX_DIV:
00:B0E8 2028B0          	   730:   jsr PULTOP2
00:B0EB A503            	   731:   lda VALUE2
00:B0ED 0504            	   732:   ora VALUE2+1
00:B0EF 0505            	   733:   ora VALUE2+2
00:B0F1 F0DE            	   734:   beq EX_DIVIDE_BY_ZERO
00:B0F3 2003B0          	   735:   jsr PULTOP
00:B0F6 20DCAC          	   736:   jsr exp_divide
00:B0F9 4C6AAF          	   737:   jmp MAINP
                        	   738: 
                        	   739: ;
                        	   740: ;  Absolute value of (sp)
                        	   741: ;
                        	   742: EX_ABS:
00:B0FC 2003B0          	   743:   jsr  PULTOP
00:B0FF 203EAC          	   744:   jsr exp_abs_val
00:B102 4C6AAF          	   745:   jmp  MAINP
                        	   746: 
                        	   747: ; Equal
                        	   748: ;
                        	   749: EX_EQL:
00:B105 2025B0          	   750:   jsr PULBOTH
00:B108 200FAB          	   751:   jsr exp_eql
00:B10B 4C6AAF          	   752:   jmp MAINP
                        	   753: 
                        	   754: ;
                        	   755: ;  Push 1
                        	   756: ;
                        	   757: TRUE:
00:B10E A901            	   758:   lda  #1
                        	   759: ;
                        	   760: ;  Push A into low-order byte, zero other two bytes
                        	   761: ;
                        	   762: TRUE2:
00:B110 8500            	   763:   sta  REG
00:B112 A900            	   764:   lda  #0
00:B114 8501            	   765:   sta  REG+1
00:B116 8502            	   766:   sta  REGB
00:B118 4C6AAF          	   767:   jmp  MAINP
                        	   768: 
                        	   769: ;
                        	   770: ;  Push 0
                        	   771: ;
                        	   772: FALSE:
00:B11B A900            	   773:   lda  #0
00:B11D 80F1            	   774:   bra TRUE2
                        	   775: ;
                        	   776: ;  Not equal
                        	   777: ;
                        	   778: EX_NEQ:
00:B11F 2025B0          	   779:     jsr PULBOTH
00:B122 2023AB          	   780:     jsr exp_neq
00:B125 4C6AAF          	   781:     jmp MAINP
                        	   782: 
                        	   783: ;
                        	   784: ;  Less than
                        	   785: ;
                        	   786: EX_LSS:
00:B128 2028B0          	   787:   jsr PULTOP2
00:B12B 2003B0          	   788:   jsr PULTOP
00:B12E 2037AB          	   789:   jsr exp_less_than
00:B131 4C6AAF          	   790:   jmp MAINP
                        	   791: 
                        	   792: ;
                        	   793: ;  Greater than
                        	   794: ;
                        	   795: EX_GTR:
00:B134 2028B0          	   796:   jsr PULTOP2
00:B137 2003B0          	   797:   jsr PULTOP
00:B13A 203EAB          	   798:   jsr exp_greater_than
00:B13D 4C6AAF          	   799:   jmp MAINP
                        	   800: 
                        	   801: ;
                        	   802: ;  Greater than or equal
                        	   803: ;
                        	   804: EX_GEQ:
00:B140 2028B0          	   805:   jsr PULTOP2
00:B143 2003B0          	   806:   jsr PULTOP
00:B146 205CAB          	   807:   jsr exp_geq
00:B149 4C6AAF          	   808:   jmp MAINP
                        	   809: 
                        	   810: ;
                        	   811: ;  Less than or equal
                        	   812: ;
                        	   813: EX_LEQ:
00:B14C 2028B0          	   814:   jsr PULTOP2
00:B14F 2003B0          	   815:   jsr PULTOP
00:B152 204DAB          	   816:   jsr exp_leq
00:B155 4C6AAF          	   817:   jmp MAINP
                        	   818: 
                        	   819: ;
                        	   820: ;  Exclusive OR
                        	   821: ;
                        	   822: EX_XOR:
00:B158 2025B0          	   823:   jsr PULBOTH
00:B15B 208DAB          	   824:   jsr exp_bitwise_xor
00:B15E 4C6AAF          	   825:   jmp MAINP
                        	   826: ;
                        	   827: ;  Or
                        	   828: ;
                        	   829: EX_ORR:
00:B161 2025B0          	   830:   jsr PULBOTH
00:B164 2063AB          	   831:   jsr exp_bitwise_or
00:B167 4C6AAF          	   832:   jmp MAINP
                        	   833: 
                        	   834: ;
                        	   835: ;  And
                        	   836: ;
                        	   837: EX_AND:
00:B16A 2025B0          	   838:   jsr  PULBOTH
00:B16D 2078AB          	   839:   jsr exp_bitwise_and
00:B170 4C6AAF          	   840:   jmp MAINP
                        	   841: 
                        	   842: ;
                        	   843: ;  Not
                        	   844: ;
                        	   845: EX_EOR:
00:B173 2003B0          	   846:   jsr PULTOP
00:B176 200EAC          	   847:   jsr exp_not
00:B179 4C6AAF          	   848:   jmp MAINP
                        	   849: ;
                        	   850: ; Shift left
                        	   851: ;
                        	   852: EX_SHL:
00:B17C 2028B0          	   853:   jsr PULTOP2
00:B17F 2003B0          	   854:   jsr PULTOP
00:B182 20C9AB          	   855:   jsr exp_shift_left
00:B185 4C6AAF          	   856:   jmp MAINP
                        	   857: 
                        	   858: ;
                        	   859: ;  Shift right
                        	   860: ;
                        	   861: EX_SHR:
00:B188 2028B0          	   862:   jsr PULTOP2
00:B18B 2003B0          	   863:   jsr PULTOP
00:B18E 20E2AB          	   864:   jsr exp_shift_right
00:B191 4C6AAF          	   865:   jmp MAINP
                        	   866: 
                        	   867: ;
                        	   868: ;  increment number on top of stack by one
                        	   869: ;
                        	   870: EX_INC:
00:B194 18              	   871:   clc
00:B195 B131            	   872:   lda  (T),Y
00:B197 6901            	   873:   adc  #1
00:B199 9131            	   874:   sta  (T),Y
00:B19B C8              	   875:   iny
00:B19C B131            	   876:   lda  (T),Y
00:B19E 6900            	   877:   adc  #0
00:B1A0 9131            	   878:   sta  (T),Y
00:B1A2 C8              	   879:   iny
00:B1A3 B131            	   880:   lda  (T),Y
00:B1A5 6900            	   881:   adc  #0
00:B1A7 9131            	   882:   sta  (T),Y
00:B1A9 4C6DAF          	   883:   jmp  MAIN
                        	   884: ;
                        	   885: ;  decrement number on top of stack by one
                        	   886: ;
                        	   887: 
                        	   888: EX_DEC:
00:B1AC 38              	   889:   sec
00:B1AD B131            	   890:   lda  (T),Y
00:B1AF E901            	   891:   sbc  #1
00:B1B1 9131            	   892:   sta  (T),Y
00:B1B3 C8              	   893:   iny
00:B1B4 B131            	   894:   lda  (T),Y
00:B1B6 E900            	   895:   sbc  #0
00:B1B8 9131            	   896:   sta  (T),Y
00:B1BA C8              	   897:   iny
00:B1BB B131            	   898:   lda  (T),Y
00:B1BD E900            	   899:   sbc  #0
00:B1BF 9131            	   900:   sta  (T),Y
00:B1C1 4C6DAF          	   901:   jmp  MAIN
                        	   902: 
                        	   903: ;
                        	   904: ;  Copy (sp) to (sp + 1)
                        	   905: ;
                        	   906: EX_MOV:
00:B1C4 B131            	   907:   lda  (T),Y  ; get item at top of stack
00:B1C6 8500            	   908:   sta REG
00:B1C8 C8              	   909:   iny
00:B1C9 B131            	   910:   lda  (T),Y
00:B1CB 8501            	   911:   sta REG+1
00:B1CD C8              	   912:   iny
00:B1CE B131            	   913:   lda  (T),Y
00:B1D0 8502            	   914:   sta REGB
00:B1D2 4C6AAF          	   915:   jmp MAINP   ; push it
                        	   916: 
                        	   917: ;
                        	   918: ;  Load a single-character value (variable) onto the stack
                        	   919: ;
                        	   920: 
                        	   921: EX_LODC:
00:B1D5 20BCAF          	   922:   jsr  GETADR
                        	   923: EX_LOD3:
00:B1D8 A002            	   924:   ldy  #2
                        	   925: EX_LOD3_A:
00:B1DA A900            	   926:   lda  #0      ; since this is a character zero out the high-order bytes
00:B1DC 8501            	   927:   sta  REG+1
00:B1DE 8502            	   928:   sta  REGB
00:B1E0 B13D            	   929:   lda  (DATA),Y  ; (DATA) contains the lower-order byte
00:B1E2 8500            	   930:   sta  REG       ; REG will be pushed
00:B1E4 4C6AAF          	   931:   jmp  MAINP     ; push REG and go to MAIN
                        	   932: ;
                        	   933: ;  Load a 3-byte value (variable) onto the stack
                        	   934: ;
                        	   935: EX_LOD:
00:B1E7 20BCAF          	   936:   jsr  GETADR
                        	   937: EX_LOD2:
00:B1EA A000            	   938:   ldy  #0
00:B1EC B13D            	   939:   lda  (DATA),Y    ; (DATA) contains the variable value
00:B1EE 8500            	   940:   sta  REG
00:B1F0 C8              	   941:   iny
00:B1F1 B13D            	   942:   lda  (DATA),Y
00:B1F3 8501            	   943:   sta  REG+1
00:B1F5 C8              	   944:   iny
00:B1F6 B13D            	   945:   lda  (DATA),Y
00:B1F8 8502            	   946:   sta REGB
00:B1FA 4C6AAF          	   947:   jmp MAINP   ; push it
                        	   948: 
                        	   949: ;
                        	   950: ;  Load absolute address character
                        	   951: ;
                        	   952: EX_LDAC:
00:B1FD 2003B0          	   953:   jsr  PULTOP
00:B200 853D            	   954:   sta  DATA
00:B202 863E            	   955:   stx  DATA+1
00:B204 A000            	   956:   ldy  #0
00:B206 F0D2            	   957:   beq  EX_LOD3_A
                        	   958: ;
                        	   959: ;  Load absolute address integer
                        	   960: ;
                        	   961: EX_LDA:
00:B208 2003B0          	   962:   jsr  PULTOP
00:B20B 853D            	   963:   sta  DATA
00:B20D 863E            	   964:   stx  DATA+1
00:B20F 4CEAB1          	   965:   jmp  EX_LOD2
                        	   966: ;
                        	   967: ;  Get address of indexed character
                        	   968: ;
                        	   969: GETIDC:
00:B212 2028B0          	   970:   jsr  PULTOP2    ; pull index into REG2
00:B215 20BCAF          	   971:   jsr  GETADR
00:B218 4C2FB2          	   972:   jmp  GETID2
                        	   973: ;
                        	   974: ;  Get address of indexed integer
                        	   975: ;
                        	   976: GETIDX   =  *
00:B21B 2028B0          	   977:   jsr  PULTOP2  ; pull index into REG2
00:B21E 0603            	   978:   asl  REG2     ; now multiply by 3
00:B220 2604            	   979:   rol  REG2+1
00:B222 18              	   980:   clc
00:B223 6503            	   981:   adc  REG2
00:B225 8503            	   982:   sta  REG2
00:B227 8A              	   983:   txa
00:B228 6504            	   984:   adc  REG2+1
00:B22A 8504            	   985:   sta  REG2+1     ; TIMES 3
00:B22C 20BCAF          	   986:   jsr  GETADR
                        	   987: ;
                        	   988: ;  Get address of indexed integer/character
                        	   989: ;
                        	   990: ;  It looks like arrays expand downwards
                        	   991: ;
                        	   992: GETID2:
00:B22F A53D            	   993:   lda  DATA     ; initial address
00:B231 38              	   994:   sec           ; subtract subscript
00:B232 E503            	   995:   sbc  REG2
00:B234 853D            	   996:   sta  DATA
00:B236 A53E            	   997:   lda  DATA+1
00:B238 E504            	   998:   sbc  REG2+1
00:B23A 853E            	   999:   sta  DATA+1
00:B23C 60              	  1000:   rts
                        	  1001: ;
                        	  1002: ;  Load indexed character
                        	  1003: ;
                        	  1004: EX_LDIC:
00:B23D 2012B2          	  1005:   jsr  GETIDC
00:B240 4CD8B1          	  1006:   jmp  EX_LOD3
                        	  1007: ;
                        	  1008: ;  Load indexed integer
                        	  1009: ;
                        	  1010: EX_LDI:
00:B243 201BB2          	  1011:   jsr  GETIDX
00:B246 4CEAB1          	  1012:   jmp  EX_LOD2
                        	  1013: ;
                        	  1014: ;  Store character
                        	  1015: ;
                        	  1016: EX_STOC:
00:B249 20BCAF          	  1017:   jsr  GETADR
00:B24C 2003B0          	  1018:   jsr  PULTOP
00:B24F A002            	  1019:   ldy  #2   ; why?
                        	  1020: EX_STO5:
00:B251 913D            	  1021:   sta  (DATA),Y
00:B253 4C6DAF          	  1022:   jmp  MAIN
                        	  1023: ;
                        	  1024: ;  Store integer
                        	  1025: ;
                        	  1026: EX_STO:
00:B256 20BCAF          	  1027:   jsr  GETADR   ; get its address
00:B259 2003B0          	  1028:   jsr  PULTOP   ; get the value to store
                        	  1029: EX_STO2:
00:B25C A000            	  1030:   ldy  #0
00:B25E 913D            	  1031:   sta  (DATA),Y
00:B260 C8              	  1032:   iny
00:B261 8A              	  1033:   txa
00:B262 913D            	  1034:   sta  (DATA),Y
00:B264 A502            	  1035:   lda  REGB
00:B266 C8              	  1036:   iny
00:B267 D0E8            	  1037:   bne  EX_STO5
                        	  1038: ;
                        	  1039: ;  Store integer at absolute address
                        	  1040: ;
                        	  1041: EX_STA:
00:B269 2025B0          	  1042:   jsr  PULBOTH  ; get address into REG2 and value into REG
00:B26C A000            	  1043:   ldy  #0
00:B26E A500            	  1044:   lda  REG
00:B270 9103            	  1045:   sta  (REG2),Y
00:B272 C8              	  1046:   iny
00:B273 A501            	  1047:   lda  REG+1
00:B275 9103            	  1048:   sta  (REG2),Y
00:B277 C8              	  1049:   iny
00:B278 A502            	  1050:   lda  REGB
                        	  1051: EX_STA5:
00:B27A 9103            	  1052:   sta  (REG2),Y
00:B27C 4C6DAF          	  1053:   jmp  MAIN
                        	  1054: ;
                        	  1055: ;  Store character at absolute address
                        	  1056: ;
                        	  1057: EX_STAC:
00:B27F 2025B0          	  1058:   jsr  PULBOTH  ; get address into REG2 and value into REG
00:B282 A500            	  1059:   lda  REG
00:B284 A000            	  1060:   ldy  #0
00:B286 F0F2            	  1061:   beq  EX_STA5
                        	  1062: ;
                        	  1063: ;     Store character indexed
                        	  1064: ;
                        	  1065: EX_STIC:
00:B288 2003B0          	  1066:   jsr  PULTOP
00:B28B 8545            	  1067:   sta  TEMP
00:B28D 2012B2          	  1068:   jsr  GETIDC
00:B290 A545            	  1069:   lda  TEMP
00:B292 A002            	  1070:   ldy  #2
00:B294 D0BB            	  1071:   bne  EX_STO5
                        	  1072: ;
                        	  1073: ;     Store integer indexed
                        	  1074: ;
                        	  1075: EX_STI :
00:B296 2003B0          	  1076:   jsr  PULTOP
00:B299 8545            	  1077:   sta  TEMP
00:B29B 8646            	  1078:   stx  TEMP+1
00:B29D 98              	  1079:   tya
00:B29E 48              	  1080:   pha
00:B29F 201BB2          	  1081:   jsr  GETIDX
00:B2A2 A000            	  1082:   ldy  #0
00:B2A4 A545            	  1083:   lda  TEMP
00:B2A6 913D            	  1084:   sta  (DATA),Y
00:B2A8 A546            	  1085:   lda  TEMP+1
00:B2AA C8              	  1086:   iny
00:B2AB 913D            	  1087:   sta  (DATA),Y
00:B2AD 68              	  1088:   pla
00:B2AE C8              	  1089:   iny
00:B2AF D0A0            	  1090:   bne  EX_STO5
                        	  1091: ;
                        	  1092: ;  Procedure/function return
                        	  1093: ;
                        	  1094: ;  Stack frame linkage data:
                        	  1095: ;
                        	  1096: ;    (from low to high address)
                        	  1097: ;
                        	  1098: ;    Return address <-- P-code to return to when function/procedure exits
                        	  1099: ;    Dynamic link   <-- The previous stack frame from the earlier function call
                        	  1100: ;    Static link    <-- The stack frame of the previous static function
                        	  1101: ;
                        	  1102: ;  Static and dynamic links will be the same except for recursive calls.
                        	  1103: ;
                        	  1104: ;  To unwind the stack we have to go back to the previous dynamic link (on a return)
                        	  1105: ;
                        	  1106: ;  However to find variables in previous lexical declarations we have to use the static link.
                        	  1107: ;
                        	  1108: ;
                        	  1109: EX_RTN:
                        	  1110: ;
                        	  1111: ;  Subtract 6 from the base address, put result into WORK
                        	  1112: ;
00:B2B1 38              	  1113:   sec
00:B2B2 A53B            	  1114:   lda  BASE
00:B2B4 E906            	  1115:   sbc  #6
00:B2B6 8537            	  1116:   sta  WORK
00:B2B8 A53C            	  1117:   lda  BASE+1
00:B2BA E900            	  1118:   sbc  #0
00:B2BC 8538            	  1119:   sta  WORK+1
                        	  1120: ;
                        	  1121: ;  The return address was at the bottom of BASE, so put that into PCODE
                        	  1122: ;
00:B2BE A000            	  1123:   ldy  #0
00:B2C0 B137            	  1124:   lda  (WORK),Y
00:B2C2 8523            	  1125:   sta  PCODE
00:B2C4 C8              	  1126:   iny
00:B2C5 B137            	  1127:   lda  (WORK),Y
00:B2C7 8524            	  1128:   sta  PCODE+1
                        	  1129: 
                        	  1130: ;
                        	  1131: ;  The base address becomes our new top of runtime stack
                        	  1132: ;
00:B2C9 A53C            	  1133:   lda  BASE+1
00:B2CB 8532            	  1134:   sta  T+1
00:B2CD A53B            	  1135:   lda  BASE
00:B2CF 8531            	  1136:   sta  T
                        	  1137: ;
                        	  1138: ;  The dynamic stack frame address is 4 bytes down from the BASE - put that into WORK
                        	  1139: ;
00:B2D1 38              	  1140:   sec
00:B2D2 E904            	  1141:   sbc  #4
00:B2D4 8537            	  1142:   sta  WORK
00:B2D6 A53C            	  1143:   lda  BASE+1
00:B2D8 E900            	  1144:   sbc  #0
00:B2DA 8538            	  1145:   sta  WORK+1
                        	  1146: ;
                        	  1147: ;  Get the previous dynamic stack frame address and put it into BASE (in case of
                        	  1148: ;   recursive function calls)
                        	  1149: ;
00:B2DC A000            	  1150:   ldy  #0
00:B2DE B137            	  1151:   lda  (WORK),Y
00:B2E0 853B            	  1152:   sta  BASE
00:B2E2 C8              	  1153:   iny
00:B2E3 B137            	  1154:   lda  (WORK),Y
00:B2E5 853C            	  1155:   sta  BASE+1
                        	  1156: ;
                        	  1157: ;  Stack, base and Pcode all changed, ready for next instruction
                        	  1158: ;
00:B2E7 4C6DAF          	  1159:   jmp  MAIN
                        	  1160: 
                        	  1161: ;
                        	  1162: ; Input a number into a variable
                        	  1163: ;
                        	  1164: EX_INP      =  *
00:B2EA A980            	  1165:   lda #$80
00:B2EC 853F            	  1166:   sta  RUNNING
00:B2EE 20F193          	  1167:   JSR  GET_LINE
00:B2F1 AD0002          	  1168:   lda  INBUF
00:B2F4 C903            	  1169:   cmp  #KEY_ABORT   ; check for aborting with Ctrl+C
00:B2F6 D003            	  1170:   bne  EX_INP_OK
00:B2F8 4C45B5          	  1171:   jmp  ex_input_aborted
                        	  1172: 
                        	  1173: EX_INP_OK:
00:B2FB A900            	  1174:   lda #<INBUF
00:B2FD 858E            	  1175:   sta token_start
00:B2FF A902            	  1176:   lda #>INBUF
00:B301 858F            	  1177:   sta token_start+1
00:B303 6493            	  1178:   stz token_type
00:B305 208DC9          	  1179:   jsr get_token
00:B308 C94E            	  1180:   cmp #TOKEN_NUMBER
00:B30A D016            	  1181:   bne BAD_INP
00:B30C A694            	  1182:   LDX  token_value
00:B30E A495            	  1183:   LDY  token_value+1
00:B310 A596            	  1184:   LDA  token_value+2
                        	  1185: INP3:
00:B312 8401            	  1186:   sty  REG+1
00:B314 8600            	  1187:   stx  REG
00:B316 8502            	  1188:   sta  REGB
00:B318 204AB0          	  1189:   jsr  PSHTOP
00:B31B A20C            	  1190:   ldx  #12
00:B31D 863F            	  1191:   stx  RUNNING
00:B31F 4C6DAF          	  1192:   jmp  MAIN
                        	  1193: ;
                        	  1194: ;  bad number: set it to $800000
                        	  1195: ;
                        	  1196: BAD_INP:
00:B322 A980            	  1197:   lda #$80
00:B324 A200            	  1198:   ldx #0
00:B326 A000            	  1199:   ldy #0
00:B328 F0E8            	  1200:   beq INP3
                        	  1201: ;
                        	  1202: ; write a number to output
                        	  1203: ;
                        	  1204: EX_OUT:
00:B32A 20F9C8          	  1205:   jsr write_to_serial
00:B32D 8003            	  1206:   bra OUT_COMMON
                        	  1207: 
                        	  1208: EX_LCD_WRITE_NUM:
00:B32F 2004C9          	  1209:   jsr write_to_lcd
                        	  1210: 
                        	  1211: OUT_COMMON:
00:B332 2003B0          	  1212:   jsr  PULTOP
00:B335 20BC91          	  1213:   jsr  display_in_decimal
00:B338 20F9C8          	  1214:   jsr  write_to_serial
00:B33B 4C6DAF          	  1215:   jmp  MAIN
                        	  1216: ;
                        	  1217: ;
                        	  1218: ; Output 6 hex characters (3 bytes)
                        	  1219: ;
                        	  1220: EX_OUH:
00:B33E 20F9C8          	  1221:   jsr write_to_serial
00:B341 8003            	  1222:   bra EX_OUH_COMMON
                        	  1223: 
                        	  1224: EX_LCD_WRITE_HEX:
00:B343 2004C9          	  1225:   jsr write_to_lcd
                        	  1226: 
                        	  1227: EX_OUH_COMMON:
00:B346 2003B0          	  1228:   jsr  PULTOP
00:B349 A502            	  1229:   lda  REGB
00:B34B 200793          	  1230:   jsr  PRBYTE
00:B34E A501            	  1231:   lda  REG+1
00:B350 200793          	  1232:   jsr  PRBYTE
00:B353 A500            	  1233:   lda  REG
00:B355 200793          	  1234:   jsr  PRBYTE
00:B358 20F9C8          	  1235:   jsr  write_to_serial
00:B35B 4C6DAF          	  1236:   jmp  MAIN
                        	  1237: ;
                        	  1238: ;  write a string to output
                        	  1239: ;
                        	  1240: EX_OUS      =  *
00:B35E 20F9C8          	  1241:   jsr write_to_serial
00:B361 8003            	  1242:   bra EX_OUS_COMMON
                        	  1243: 
                        	  1244: EX_LCD_WRITE_STR:
00:B363 2004C9          	  1245:   jsr write_to_lcd
                        	  1246: 
                        	  1247: EX_OUS_COMMON:
00:B366 A523            	  1248:   lda  PCODE
00:B368 18              	  1249:   clc
00:B369 6901            	  1250:   adc  #1
00:B36B 8537            	  1251:   sta  WORK
00:B36D A524            	  1252:   lda  PCODE+1
00:B36F 6900            	  1253:   adc  #0
00:B371 8538            	  1254:   sta  WORK+1
00:B373 B123            	  1255:   lda  (PCODE),Y
00:B375 854B            	  1256:   sta  COUNT1     ; NO. OF CHARS
00:B377 18              	  1257:   clc
00:B378 6901            	  1258:   adc  #1
00:B37A 6523            	  1259:   adc  PCODE
00:B37C 8523            	  1260:   sta  PCODE
00:B37E 9002            	  1261:   bcc  EX_OUS1
00:B380 E624            	  1262:   inc  PCODE+1
                        	  1263: EX_OUS1:
00:B382 A537            	  1264:   lda  WORK
00:B384 A638            	  1265:   ldx  WORK+1
00:B386 A44B            	  1266:   ldy  COUNT1
00:B388 202193          	  1267:   jsr  PT
00:B38B 20F9C8          	  1268:   jsr write_to_serial
00:B38E 4C6DAF          	  1269:   jmp  MAIN
                        	  1270: 
                        	  1271: 
                        	  1272: 
                        	  1273: ;
                        	  1274: ;  Stack frame linkage data:
                        	  1275: ;
                        	  1276: ;    (from low to high address)
                        	  1277: ;
                        	  1278: ;    Return address <-- P-code to return to when function/procedure exits
                        	  1279: ;    Dynamic link   <-- The previous stack frame from the earlier function call
                        	  1280: ;    Static link    <-- The stack frame of the previous static function
                        	  1281: ;
                        	  1282: ;  Static and dynamic links will be the same except for recursive calls.
                        	  1283: ;
                        	  1284: ;  To unwind the stack we have to go back to the previous dynamic link (on a return)
                        	  1285: ;
                        	  1286: ;  However to find variables in previous lexical declarations we have to use the static link.
                        	  1287: ;
                        	  1288: ;
                        	  1289: ; Call absolute procedure - I don't think this is used in this version TBH
                        	  1290: ;
                        	  1291: ; Note: Y is zero when entering
                        	  1292: ;
                        	  1293: EX_ABSCLL   =  *
00:B391 8447            	  1294:   sty  CALL      ; zero out address to be called
00:B393 8448            	  1295:   sty  CALL+1    ; (offset therefore becomes absolute address)
00:B395 4CA0B3          	  1296:   jmp  EX_CLL_A
                        	  1297: ;
                        	  1298: ; Call relative procedure
                        	  1299: ;
                        	  1300: ; Note: Y is zero when entering
                        	  1301: ;
                        	  1302: EX_CLL      =  *
00:B398 A54D            	  1303:   lda  LASTP
00:B39A 8547            	  1304:   sta  CALL
00:B39C A54E            	  1305:   lda  LASTP+1
00:B39E 8548            	  1306:   sta  CALL+1
                        	  1307: EX_CLL_A    =  *
00:B3A0 B123            	  1308:   lda  (PCODE),Y     ; level
00:B3A2 854B            	  1309:   sta  COUNT1
00:B3A4 C8              	  1310:   iny
00:B3A5 18              	  1311:   clc
00:B3A6 B123            	  1312:   lda  (PCODE),Y     ; relative address
00:B3A8 6547            	  1313:   adc  CALL          ; add to current P-code address
00:B3AA 8547            	  1314:   sta  CALL
00:B3AC C8              	  1315:   iny
00:B3AD B123            	  1316:   lda  (PCODE),Y
00:B3AF 6548            	  1317:   adc  CALL+1
00:B3B1 8548            	  1318:   sta  CALL+1
00:B3B3 A523            	  1319:   lda  PCODE         ; add 3 to P-code to bypass level / address
00:B3B5 18              	  1320:   clc                ; this will become our return address
00:B3B6 6903            	  1321:   adc  #3
00:B3B8 8523            	  1322:   sta  PCODE
00:B3BA 9002            	  1323:   bcc  EX_CLL4
00:B3BC E624            	  1324:   inc  PCODE+1
                        	  1325: EX_CLL4     =  *
00:B3BE A53C            	  1326:   lda  BASE+1
00:B3C0 A63B            	  1327:   ldx  BASE
                        	  1328: EX_CLL2     =  *
00:B3C2 853E            	  1329:   sta  DATA+1      ; this was BASE
00:B3C4 863D            	  1330:   stx  DATA
00:B3C6 A8              	  1331:   tay
00:B3C7 A54B            	  1332:   lda  COUNT1      ; this was the level
00:B3C9 F018            	  1333:   beq  EX_CLL3
00:B3CB 38              	  1334:   sec
00:B3CC 8A              	  1335:   txa
00:B3CD E902            	  1336:   sbc  #2          ; subtract 2 from BASE, store in WORK
00:B3CF 8537            	  1337:   sta  WORK
00:B3D1 98              	  1338:   tya
00:B3D2 E900            	  1339:   sbc  #0
00:B3D4 8538            	  1340:   sta  WORK+1
00:B3D6 A000            	  1341:   ldy  #0
00:B3D8 B137            	  1342:   lda  (WORK),Y
00:B3DA C8              	  1343:   iny
00:B3DB AA              	  1344:   tax
00:B3DC B137            	  1345:   lda  (WORK),Y
00:B3DE C64B            	  1346:   dec  COUNT1
00:B3E0 4CC2B3          	  1347:   jmp  EX_CLL2
                        	  1348: EX_CLL3     =  *
00:B3E3 A531            	  1349:   lda  T         ; our stack pointer
00:B3E5 8545            	  1350:   sta  TEMP      ; save it
00:B3E7 A532            	  1351:   lda  T+1
00:B3E9 8546            	  1352:   sta  TEMP+1
                        	  1353: ;
                        	  1354: ; this is as confusing as all-get-out but it looks like we
                        	  1355: ; are pushing onto the stack: DATA / BASE / PCODE (return address)
                        	  1356: ;  (which is why we saved T into TEMP so it didn't change during the pushes)
                        	  1357: ;
                        	  1358: 
00:B3EB A53D            	  1359:   lda  DATA      ; put DATA into REG
00:B3ED 8501            	  1360:   sta  REG+1
00:B3EF A53E            	  1361:   lda  DATA+1
00:B3F1 8502            	  1362:   sta  REGB
00:B3F3 A53C            	  1363:   lda  BASE+1
00:B3F5 8500            	  1364:   sta  REG
00:B3F7 204AB0          	  1365:   jsr  PSHTOP      ; push REG (DATA + BASE[1])
00:B3FA A53B            	  1366:   lda  BASE
00:B3FC 8502            	  1367:   sta  REGB
00:B3FE A545            	  1368:   lda  TEMP        ; old stack pointer
00:B400 853B            	  1369:   sta  BASE        ; becomes BASE
00:B402 A546            	  1370:   lda  TEMP+1      ; ditto for other byte
00:B404 853C            	  1371:   sta  BASE+1
00:B406 A523            	  1372:   lda  PCODE       ; get ready to push current P-Code
00:B408 8500            	  1373:   sta  REG
00:B40A A524            	  1374:   lda  PCODE+1
00:B40C 8501            	  1375:   sta  REG+1
00:B40E 204AB0          	  1376:   jsr  PSHTOP     ; push REG (BASE[0] + PCODE)
00:B411 A547            	  1377:   lda  CALL       ; now get the address of the place we want to call
00:B413 8523            	  1378:   sta  PCODE      ; and put it into PCODE
00:B415 A548            	  1379:   lda  CALL+1
00:B417 8524            	  1380:   sta  PCODE+1
00:B419 18              	  1381:   clc             ; add 6 to the stack pointer because we later emit the code to INT 6 (leave room for base stuff)
00:B41A A531            	  1382:   lda  T
00:B41C 6906            	  1383:   adc  #6
00:B41E 8531            	  1384:   sta  T
00:B420 9002            	  1385:   bcc  EX_CLL5
00:B422 E632            	  1386:   inc  T+1
                        	  1387: EX_CLL5     =  *
00:B424 4C6DAF          	  1388:   jmp  MAIN        ; we are done, MAIN will now go to the called subroutine
                        	  1389: ;
                        	  1390: ;  Here for calling machine code from Pascal
                        	  1391: ;
                        	  1392: EX_CLA:
00:B427 2003B0          	  1393:   jsr  PULTOP      ; pull the address to be called from the stack
00:B42A A513            	  1394:   lda  call_p      ; status register
00:B42C 48              	  1395:   pha
00:B42D A510            	  1396:   lda  call_a      ; A register
00:B42F A611            	  1397:   ldx  call_x      ; X register
00:B431 A412            	  1398:   ldy  call_y      ; Y register
00:B433 28              	  1399:   plp              ; get status register back
00:B434 2044B4          	  1400:   jsr  EX_CLL_JMP  ; call the subroutine
00:B437 08              	  1401:   php              ; save the status register
00:B438 8510            	  1402:   sta  call_a      ; store the A/X/Y register
00:B43A 8611            	  1403:   stx  call_x
00:B43C 8412            	  1404:   sty  call_y
00:B43E 68              	  1405:   pla              ; get status register back
00:B43F 8513            	  1406:   sta  call_p      ; save it
00:B441 4C6DAF          	  1407:   jmp  MAIN        ; done!
                        	  1408: 
00:B444 6C0000          	  1409: EX_CLL_JMP  jmp  (REG)
                        	  1410: ;
                        	  1411: ;
                        	  1412: ; increment stack pointer (that is, subtract the literal from it, as it grows downwards)
                        	  1413: ;
                        	  1414: EX_INT:
00:B447 2066B0          	  1415:   jsr  GETLIT
00:B44A 38              	  1416:   sec
00:B44B A531            	  1417:   lda  T
00:B44D E500            	  1418:   sbc  REG
00:B44F 8531            	  1419:   sta  T
00:B451 A532            	  1420:   lda  T+1
00:B453 E501            	  1421:   sbc  REG+1
00:B455 8532            	  1422:   sta  T+1
00:B457 C544            	  1423:   cmp  END_PCD+1
00:B459 9003            	  1424:   bcc  INT_ERR
00:B45B 4C6DAF          	  1425:   jmp  MAIN
                        	  1426: ;
                        	  1427: INT_ERR  =  *
00:B45E A965            	  1428:   lda  #<INT_ERRM    ; stack full
00:B460 A2B4            	  1429:   ldx  #>INT_ERRM
00:B462 4CAFAF          	  1430:   jmp  NOTIM1
                        	  1431: ;
00:B465 537461636B206675	  1432: INT_ERRM asciiz "Stack full\n"    ; stack full
00:B46D 6C6C0A
00:B470 00
                        	  1433: ;
                        	  1434: 
                        	  1435: ;
                        	  1436: ;  Change the runtime stack to the address given (assuming stack is empty)
                        	  1437: ;   Done by the {%S nnnn} compiler directive.
                        	  1438: ;
                        	  1439: EX_NEW_STACK:
00:B471 2066B0          	  1440:   jsr GETLIT
00:B474 A500            	  1441:   lda REG
00:B476 8531            	  1442:   sta T
00:B478 853B            	  1443:   sta BASE
00:B47A A501            	  1444:   lda REG+1
00:B47C 8532            	  1445:   sta T+1
00:B47E 853C            	  1446:   sta BASE+1
00:B480 4C6DAF          	  1447:   jmp MAIN
                        	  1448: 
                        	  1449: ;
                        	  1450: ;  Jump to the address following the P-code
                        	  1451: ;
                        	  1452: EX_JMP:
00:B483 2066B0          	  1453:   jsr  GETLIT   ; get the address
00:B486 18              	  1454:   clc
00:B487 A500            	  1455:   lda  REG
00:B489 654D            	  1456:   adc  LASTP
00:B48B 8523            	  1457:   sta  PCODE
00:B48D A501            	  1458:   lda  REG+1
00:B48F 654E            	  1459:   adc  LASTP+1
00:B491 8524            	  1460:   sta  PCODE+1
00:B493 4C6DAF          	  1461:   jmp  MAIN
                        	  1462: ;
                        	  1463: ;  Jump if the top of the stack is zero
                        	  1464: ;
                        	  1465: EX_JMZ:
00:B496 2003B0          	  1466:   jsr  PULTOP   ; puts REG into A
00:B499 0501            	  1467:   ora  REG+1
00:B49B 0502            	  1468:   ora  REGB
00:B49D D002            	  1469:   bne  EX_NOJUMP
00:B49F F0E2            	  1470:   beq  EX_JMP
                        	  1471: ;
                        	  1472: ;  Don't jump, just move past the address (TODO: just add 2?)
                        	  1473: ;
                        	  1474: EX_NOJUMP:
00:B4A1 2066B0          	  1475:   jsr  GETLIT
00:B4A4 4C6DAF          	  1476:   jmp  MAIN
                        	  1477: ;
                        	  1478: ;  Jump if the top of the stack is non-zero
                        	  1479: ;
                        	  1480: EX_JM1:
00:B4A7 2003B0          	  1481:   jsr  PULTOP    ; puts REG into A
00:B4AA 0501            	  1482:   ora  REG+1
00:B4AC 0502            	  1483:   ora  REGB
00:B4AE D0D3            	  1484:   bne  EX_JMP
00:B4B0 F0EF            	  1485:   beq  EX_NOJUMP
                        	  1486: ;
                        	  1487: ;
                        	  1488: EX_INPC:
00:B4B2 200FC9          	  1489:   jsr GETIN
00:B4B5 C903            	  1490:   cmp  #KEY_ABORT   ; check for aborting with Ctrl+C
00:B4B7 D003            	  1491:   bne  EX_INPC_OK
00:B4B9 4C45B5          	  1492:   jmp  ex_input_aborted
                        	  1493: 
                        	  1494: EX_INPC_OK:
00:B4BC 202EAF          	  1495:   jsr CHK_KBD
00:B4BF B0F1            	  1496:   bcs EX_INPC
00:B4C1 8500            	  1497:   sta REG
00:B4C3 A900            	  1498:   lda #0
00:B4C5 8501            	  1499:   sta REG+1
00:B4C7 8502            	  1500:   sta REGB
00:B4C9 4C6AAF          	  1501:   jmp  MAINP
                        	  1502: ;
                        	  1503: EX_OUTC:
00:B4CC 20F9C8          	  1504:   jsr write_to_serial
00:B4CF 8003            	  1505:   bra EX_OUTC_COMMON
                        	  1506: 
                        	  1507: EX_LCD_WRITE_CHR:
00:B4D1 2004C9          	  1508:   jsr write_to_lcd
                        	  1509: 
                        	  1510: EX_OUTC_COMMON:
00:B4D4 2003B0          	  1511:   jsr  PULTOP
00:B4D7 A500            	  1512:   lda  REG
00:B4D9 201994          	  1513:   jsr  COUT
00:B4DC 20F9C8          	  1514:   jsr write_to_serial
00:B4DF 4C6DAF          	  1515:   jmp  MAIN
                        	  1516:   ;
                        	  1517: 
                        	  1518: EX_LCDHOME:
00:B4E2 20F7B8          	  1519:   jsr lcd_home
00:B4E5 4C6DAF          	  1520:   JMP MAIN
                        	  1521: 
                        	  1522: 
                        	  1523: EX_LCDCLEAR:
00:B4E8 20E7B8          	  1524:   jsr lcd_clear_display
00:B4EB 4C6DAF          	  1525:   JMP MAIN
                        	  1526: 
                        	  1527: EX_INS      =  *
00:B4EE B123            	  1528:   lda  (PCODE),Y   ; wanted length
00:B4F0 8545            	  1529:   sta  TEMP
00:B4F2 E623            	  1530:   inc  PCODE
00:B4F4 D002            	  1531:   bne  EX_INS3
00:B4F6 E624            	  1532:   inc  PCODE+1
                        	  1533: EX_INS3     =  *
00:B4F8 20F193          	  1534:   jsr  GET_LINE
00:B4FB AD0002          	  1535:   lda  INBUF
00:B4FE C903            	  1536:   cmp  #KEY_ABORT     ; check for them aborting the run on input
00:B500 F043            	  1537:   beq  ex_input_aborted
00:B502 202EAF          	  1538:   jsr  CHK_KBD
00:B505 B0F1            	  1539:   bcs  EX_INS3      ; we turned on/off tracing etc, ignore this line
00:B507 98              	  1540:   tya               ; length of line
00:B508 18              	  1541:   clc
00:B509 6901            	  1542:   adc  #1        ; why?
00:B50B C545            	  1543:   cmp  TEMP
00:B50D 9002            	  1544:   bcc  EX_INS1
00:B50F A545            	  1545:   lda  TEMP      ; use max allowed length rather than received length
                        	  1546: EX_INS1     =  *
00:B511 8546            	  1547:   sta  TEMP+1    ; this is the length we are copying
00:B513 20BCAF          	  1548:   jsr  GETADR    ; get address to put the line
00:B516 A003            	  1549:   ldy  #3        ; why?
00:B518 A200            	  1550:   ldx  #0
                        	  1551: ;
                        	  1552: ;  copying loop - arrays are stored downwards, so we subtract from DATA each time
                        	  1553: ;
                        	  1554: EX_INS2     =  *
00:B51A C63D            	  1555:   dec  DATA
00:B51C A53D            	  1556:   lda  DATA
00:B51E C9FF            	  1557:   cmp  #$FF
00:B520 D002            	  1558:   bne  EX_INS4
00:B522 C63E            	  1559:   dec  DATA+1
                        	  1560: EX_INS4     =  *
00:B524 BD0002          	  1561:   lda  INBUF,X
00:B527 913D            	  1562:   sta  (DATA),Y
00:B529 E8              	  1563:   inx
00:B52A C646            	  1564:   dec  TEMP+1      ; count of bytes to copy
00:B52C D0EC            	  1565:   bne  EX_INS2
00:B52E 4C6DAF          	  1566:   jmp  MAIN        ; stop now
                        	  1567:   ;
                        	  1568: 
00:B531 0A45786563757469	  1569: execution_aborted_message asciiz "\nExecution aborted\n"
00:B539 6F6E2061626F7274
00:B541 65640A
00:B544 00
                        	  1570: 
                        	  1571: ex_input_aborted:
00:B545 A931            	  1572:   lda #<execution_aborted_message
00:B547 A2B5            	  1573:   ldx #>execution_aborted_message
00:B549 4CAFAF          	  1574:   jmp NOTIM1
                        	  1575: ;
                        	  1576: ;
                        	  1577: EX_ADRNC    =  *
00:B54C 20BCAF          	  1578:   jsr  GETADR
                        	  1579: EX_ADRNC2   =  *
00:B54F A53D            	  1580:   lda  DATA
00:B551 18              	  1581:   clc
00:B552 6902            	  1582:   adc  #2
00:B554 853D            	  1583:   sta  DATA
00:B556 9007            	  1584:   bcc  EX_ADRN2
00:B558 E63E            	  1585:   inc  DATA+1
00:B55A B003            	  1586:   bcs  EX_ADRN2
                        	  1587: EX_ADRNN    =  *
00:B55C 20BCAF          	  1588:   jsr  GETADR
                        	  1589: EX_ADRN2    =  *
00:B55F A53D            	  1590:   lda  DATA
00:B561 8500            	  1591:   sta  REG
00:B563 A53E            	  1592:   lda  DATA+1
00:B565 8501            	  1593:   sta  REG+1
00:B567 4C6AAF          	  1594:   jmp  MAINP
                        	  1595: ;
                        	  1596: EX_ADRAN    =  *
00:B56A 201BB2          	  1597:   jsr  GETIDX
00:B56D 4C5FB5          	  1598:   jmp  EX_ADRN2
                        	  1599: ;
                        	  1600: EX_ADRAC    =  *
00:B570 2012B2          	  1601:    jsr  GETIDC
00:B573 4C4FB5          	  1602:    jmp  EX_ADRNC2
                        	  1603: ;
                        	  1604: ;
                        	  1605: ;
                        	  1606: 
                        	  1607: 
                        	  1608: ;
                        	  1609: ;  DIGITALREAD (pin) pin:0 to 15; pushes 0 or 1
                        	  1610: ;
                        	  1611: EX_DIGITALREAD = *
00:B576 2003B0          	  1612:   jsr PULTOP  ; which pin
00:B579 20DCC8          	  1613:   jsr digitalread
00:B57C D003            	  1614:   bne EX_DIGITALREAD_ONE
00:B57E 4C1BB1          	  1615:   jmp FALSE
                        	  1616: EX_DIGITALREAD_ONE:
00:B581 4C0EB1          	  1617:   jmp TRUE    ; done
                        	  1618: 
                        	  1619: ;
                        	  1620: ;  LCDPOS (line, column)
                        	  1621: ;
                        	  1622: 
                        	  1623: EX_LCDPOS = *
00:B584 2003B0          	  1624:   jsr PULTOP   ; x
00:B587 290F            	  1625:   and #$0F     ; max 15
00:B589 858C            	  1626:   sta hardware_work  ; save it
00:B58B 2003B0          	  1627:   jsr PULTOP   ; y
00:B58E 2901            	  1628:   and #1       ; can be 0 or 1
00:B590 F002            	  1629:   beq EX_LCDPOS_1
00:B592 A940            	  1630:   lda #$40
                        	  1631: EX_LCDPOS_1:
00:B594 058C            	  1632:   ora hardware_work  ; or in the column
00:B596 0980            	  1633:   ora #$80     ; command to set the address
00:B598 2093B8          	  1634:   jsr lcd_instruction
00:B59B 4C6DAF          	  1635:   jmp MAIN
                        	  1636: 
                        	  1637: ;
                        	  1638: ;  RANDOM
                        	  1639: ;
                        	  1640: EX_RANDOM:
00:B59E 204490          	  1641:   jsr gen_random
00:B5A1 A509            	  1642:   lda random
00:B5A3 8500            	  1643:   sta REG
00:B5A5 A50A            	  1644:   lda random+1
00:B5A7 8501            	  1645:   sta REG+1
00:B5A9 A50B            	  1646:   lda random+2
00:B5AB 8502            	  1647:   sta REGB
00:B5AD 4C6AAF          	  1648:   jmp MAINP
                        	  1649: 
                        	  1650: 
                        	  1651: ;
                        	  1652: ;  LATENCY
                        	  1653: ;
                        	  1654: EX_LATENCY:
00:B5B0 A50D            	  1655:   lda typing_latency
00:B5B2 8500            	  1656:   sta REG
00:B5B4 A50E            	  1657:   lda typing_latency+1
00:B5B6 8501            	  1658:   sta REG+1
00:B5B8 A50F            	  1659:   lda typing_latency+2
00:B5BA 8502            	  1660:   sta REGB
00:B5BC 4C6AAF          	  1661:   jmp MAINP
                        	  1662: 
                        	  1663: ; PULTOP puts stuff here thus:
                        	  1664: ;
                        	  1665: ;        LDA  REG
                        	  1666: ;        LDX  REG+1
                        	  1667: ;        LDY  REGB
                        	  1668: 
                        	  1669: EX_DELAY = *
00:B5BF 2003B0          	  1670:   JSR  PULTOP  ; get the time interval in ms
                        	  1671:   ; (Y = high-order byte, X = lo-order byte)
00:B5C2 A600            	  1672:   ldx REG
00:B5C4 A501            	  1673:   lda REG+1
00:B5C6 297F            	  1674:   and #$7F
00:B5C8 A8              	  1675:   tay
00:B5C9 203F91          	  1676:   jsr delay
00:B5CC 4C6DAF          	  1677:   jmp MAIN
                        	  1678: 
                        	  1679: ;
                        	  1680: ;  RANDOMSEED
                        	  1681: ;
                        	  1682: EX_RANDOMSEED = *
00:B5CF 2003B0          	  1683:   JSR  PULTOP  ; get the seed
00:B5D2 850A            	  1684:   sta random+1
00:B5D4 860B            	  1685:   stx random+2
00:B5D6 840C            	  1686:   sty random+3
00:B5D8 A9FF            	  1687:   lda #$FF     ; ensure seed has some 1 bits
00:B5DA 8509            	  1688:   sta random
00:B5DC 4C6DAF          	  1689:   jmp MAIN
                        	  1690: 
                        	  1691: ;
                        	  1692: ;  PINMODE (pin, mode) pin:0 to 15; mode: 0=read, 1=write
                        	  1693: ;
                        	  1694: EX_PINMODE = *
00:B5DF 2003B0          	  1695:   jsr PULTOP  ; the mode
00:B5E2 AA              	  1696:   tax         ; input or output?
00:B5E3 DA              	  1697:   phx         ; save the mode
00:B5E4 2003B0          	  1698:   jsr PULTOP  ; which pin
00:B5E7 FA              	  1699:   plx         ; get mode back
00:B5E8 207EC8          	  1700:   jsr pinmode ; pin in A, mode in X
00:B5EB 4C6DAF          	  1701:   jmp MAIN    ; done
                        	  1702: 
                        	  1703: ;
                        	  1704: ;  DIGITALWRITE (pin, value) pin:0 to 15; value: 0 or 1
                        	  1705: ;
                        	  1706: EX_DIGITALWRITE = *
00:B5EE 2003B0          	  1707:   jsr PULTOP  ; the value
00:B5F1 AA              	  1708:   tax         ;
00:B5F2 DA              	  1709:   phx         ; save the value
00:B5F3 2003B0          	  1710:   jsr PULTOP  ; which pin
00:B5F6 FA              	  1711:   plx         ; get mode back
00:B5F7 20ADC8          	  1712:   jsr digitalwrite ; pin in A, value in X
00:B5FA 4C6DAF          	  1713:   jmp MAIN    ; done
                        	  1714: 
                        	  1715: EX_LIB_CALL:
00:B5FD 2066B0          	  1716:   JSR  GETLIT
00:B600 6C0000          	  1717:   jmp  (REG)
                        	  1718: 
                        	  1719: ;
                        	  1720: ;  Assert (expression)
                        	  1721: ;
                        	  1722: 
                        	  1723: EX_ASSERT:
00:B603 2003B0          	  1724:   jsr PULTOP  ; the value
00:B606 A500            	  1725:   lda REG
00:B608 0501            	  1726:   ora REG+1
00:B60A 0502            	  1727:   ora REGB
00:B60C D00A            	  1728:   bne EX_ASSERT_OK
00:B60E A988            	  1729:   lda #<assertion_failed_message  ; "Assertion failed"
00:B610 A297            	  1730:   ldx #>assertion_failed_message
00:B612 202682          	  1731:   jsr print
00:B615 4CE4AE          	  1732:   jmp RUNERR
                        	  1733: 
                        	  1734: EX_ASSERT_OK:
00:B618 4C6DAF          	  1735:   jmp MAIN
                        	  1736: 

Source: "gpascal.asm"
                        	   181:   .include "interrupts.inc"

Source: "interrupts.inc"
                        	     1: 
00:B61B 0A42524B20657865	     2: break_message     asciiz "\nBRK executed at address $"
00:B623 6375746564206174
00:B62B 2061646472657373
00:B633 2024
00:B635 00
00:B636 2C2041203D2024  	     3: a_equals_message  asciiz ", A = $"
00:B63D 00
00:B63E 2C2058203D2024  	     4: x_equals_message  asciiz ", X = $"
00:B645 00
00:B646 2C2059203D2024  	     5: y_equals_message  asciiz ", Y = $"
00:B64D 00
00:B64E 2C2050203D2024  	     6: p_equals_message  asciiz ", P = $"
00:B655 00
00:B656 2C2053203D2024  	     7: s_equals_message  asciiz ", S = $"
00:B65D 00
00:B65E 2C206964203D2024	     8: id_equals_message asciiz ", id = $"
00:B666 00
                        	     9: 
                        	    10: ;--------------------------------------------------
                        	    11: ;  IRQ - here on BRK interrupt
                        	    12: ;--------------------------------------------------
                        	    13: brk_executed:
00:B667 8412            	    14:   sty call_y    ; save Y - we didn't touch that
00:B669 8614            	    15:   stx call_s    ; X still has the stack pointer in it
00:B66B FA              	    16:   plx           ; get X back
00:B66C 8611            	    17:   stx call_x
00:B66E 68              	    18:   pla           ; get A back
00:B66F 8510            	    19:   sta call_a    ; save A
00:B671 68              	    20:   pla           ; get the processor flags from the stack
00:B672 8513            	    21:   sta call_p
00:B674 68              	    22:   pla           ; low-order address of BRK
00:B675 8515            	    23:   sta brk_address
00:B677 68              	    24:   pla           ; high order address of BRK
00:B678 8516            	    25:   sta brk_address+1
00:B67A 58              	    26:   cli           ; allow interrupts now so we can print
                        	    27: 
                        	    28: ;
                        	    29: ;  display BRK info for the user
                        	    30: ;
                        	    31:   ;
                        	    32:   ;  subtract 2 from brk_address to get where it actually was
                        	    33:   ;
00:B67B 38              	    34:   sec
00:B67C A515            	    35:   lda brk_address
00:B67E E902            	    36:   sbc #2
00:B680 8515            	    37:   sta brk_address
00:B682 A516            	    38:   lda brk_address+1
00:B684 E900            	    39:   sbc #0
00:B686 8516            	    40:   sta brk_address+1
00:B688 A91B            	    41:   lda #<break_message
00:B68A A2B6            	    42:   ldx #>break_message
00:B68C 202682          	    43:   jsr print
00:B68F A516            	    44:   lda brk_address+1
00:B691 200793          	    45:   jsr PRBYTE
00:B694 A515            	    46:   lda brk_address
00:B696 200793          	    47:   jsr PRBYTE
                        	    48: ;
                        	    49: ;  show A, X, Y, P, S
                        	    50: ;
00:B699 A936            	    51:   lda #<a_equals_message
00:B69B A2B6            	    52:   ldx #>a_equals_message
00:B69D 202682          	    53:   jsr print
00:B6A0 A510            	    54:   lda call_a
00:B6A2 200793          	    55:   jsr PRBYTE
00:B6A5 A93E            	    56:   lda #<x_equals_message
00:B6A7 A2B6            	    57:   ldx #>x_equals_message
00:B6A9 202682          	    58:   jsr print
00:B6AC A511            	    59:   lda call_x
00:B6AE 200793          	    60:   jsr PRBYTE
00:B6B1 A946            	    61:   lda #<y_equals_message
00:B6B3 A2B6            	    62:   ldx #>y_equals_message
00:B6B5 202682          	    63:   jsr print
00:B6B8 A512            	    64:   lda call_y
00:B6BA 200793          	    65:   jsr PRBYTE
00:B6BD A94E            	    66:   lda #<p_equals_message
00:B6BF A2B6            	    67:   ldx #>p_equals_message
00:B6C1 202682          	    68:   jsr print
00:B6C4 A513            	    69:   lda call_p
00:B6C6 200793          	    70:   jsr PRBYTE
00:B6C9 A956            	    71:   lda #<s_equals_message
00:B6CB A2B6            	    72:   ldx #>s_equals_message
00:B6CD 202682          	    73:   jsr print
00:B6D0 A514            	    74:   lda call_s
00:B6D2 200793          	    75:   jsr PRBYTE
00:B6D5 A95E            	    76:   lda #<id_equals_message
00:B6D7 A2B6            	    77:   ldx #>id_equals_message
00:B6D9 202682          	    78:   jsr print
                        	    79: ;
                        	    80: ;  advance one byte to get the break ID (byte after the BRK)
                        	    81: ;
00:B6DC E615            	    82:   inc brk_address
00:B6DE D002            	    83:   bne brk_executed1
00:B6E0 E616            	    84:   inc brk_address+1
                        	    85: brk_executed1:
00:B6E2 A000            	    86:   ldy #0
00:B6E4 B115            	    87:   lda (brk_address),Y
00:B6E6 200793          	    88:   jsr PRBYTE
                        	    89: ;
                        	    90: ;  put brk_address back to where we should resume from
                        	    91: ;
00:B6E9 E615            	    92:   inc brk_address
00:B6EB D002            	    93:   bne brk_executed2
00:B6ED E616            	    94:   inc brk_address+1
                        	    95: brk_executed2:
                        	    96: 
00:B6EF 209292          	    97:   jsr CROUT
                        	    98: ;
                        	    99: ;  display stack
                        	   100: ;
00:B6F2 A913            	   101:   lda #<stack_message
00:B6F4 A2B7            	   102:   ldx #>stack_message
00:B6F6 202682          	   103:   jsr print
00:B6F9 A514            	   104:   lda call_s
00:B6FB 18              	   105:   clc
00:B6FC 6906            	   106:   adc #6  ; the interrupt pushed 3 we pushed 2, plus the stack points to the first UNUSED spot
00:B6FE AA              	   107:   tax
                        	   108: brk_executed3:
00:B6FF BD0001          	   109:   lda $100,x
00:B702 DA              	   110:   phx
00:B703 200793          	   111:   jsr PRBYTE
00:B706 201D93          	   112:   jsr PUTSP
00:B709 FA              	   113:   plx
00:B70A E8              	   114:   inx
00:B70B D0F2            	   115:   bne brk_executed3
                        	   116: 
                        	   117: ;
                        	   118: ;  we are done now
                        	   119: ;
00:B70D 209292          	   120:   jsr CROUT
00:B710 4CCD82          	   121:   jmp main_prompt
                        	   122: 
00:B713 537461636B3A20  	   123: stack_message asciiz "Stack: "
00:B71A 00
                        	   124: 
00:B71B 4C67B6          	   125: brk_executedJ jmp brk_executed
                        	   126: 
                        	   127: ;--------------------------------------------------
                        	   128: ;  IRQ - here on maskable interrupt
                        	   129: ;--------------------------------------------------
                        	   130: 
                        	   131: irq:
00:B71E 48              	   132:   pha       ; save A and X
00:B71F DA              	   133:   phx
00:B720 BA              	   134:   tsx       ; get stack pointer
00:B721 E0FB            	   135:   cpx #$FB  ; should be lesss than $FB (since the interrupt pushed 3 and we pushed 2)
00:B723 9006            	   136:   bcc irq1
00:B725 A21B            	   137:   ldx #27   ; ERROR: stack full
00:B727 58              	   138:   cli       ; allow interrupts or error won't print
00:B728 4CCE97          	   139:   jmp ERROR
                        	   140: 
                        	   141: irq1:
00:B72B BD0301          	   142:   lda $103,X    ; this will be the processor flags on the stack (3 up from where we are now)
00:B72E 2910            	   143:   and #$10      ; check BRK flag
00:B730 D0E9            	   144:   bne brk_executedJ
                        	   145: ;
                        	   146: ;  here for a hardware IRQ
                        	   147: ;
00:B732 ADFD7F          	   148:   lda VIA_IFR
00:B735 2908            	   149:   and #VIA_FLAG_CB2        ; CB2 active edge
00:B737 D00A            	   150:   bne cb2_interrupt
                        	   151: 
00:B739 ADFD7F          	   152:   lda VIA_IFR
00:B73C 2940            	   153:   and #VIA_FLAG_TIMER1     ; Time out of T1
00:B73E D034            	   154:   bne timer1_interrupt
                        	   155: 
                        	   156: 
                        	   157: ;
                        	   158: ;  we shouldn't get here, and if we do we will probably just loop servicing the interrupt
                        	   159: ;
                        	   160:   .if SERIAL_DEBUGGING
                        	   161: 
                        	   162:     lda #SERIAL_SPARE2_MASK
                        	   163:     tsb VIA_PORTA
                        	   164:     trb VIA_PORTA
                        	   165: 
                        	   166:   .endif  ; SERIAL_DEBUGGING
                        	   167: 
00:B740 4CA3B7          	   168:   jmp irq_done
                        	   169: 
                        	   170: ;
                        	   171: ;  here for incoming start bit
                        	   172: ;
                        	   173: cb2_interrupt:
                        	   174: 
00:B743 8DFE7F          	   175:   sta VIA_IER           ; turn off that interrupt
00:B746 8DFD7F          	   176:   sta VIA_IFR           ; indicate we noticed it
                        	   177: 
00:B749 DA              	   178:   phx
00:B74A 5A              	   179:   phy
                        	   180: 
00:B74B A208            	   181:   ldx #8              ; count of bits
00:B74D A030            	   182:   ldy #SERIAL_DELAY1  ; delay interval for first bit (allow for code above) TODO - probably needs to be less now
                        	   183: serial_in_loop:
                        	   184: ;
                        	   185: ; wait for bit time to be up
                        	   186: ;
00:B74F 88              	   187:   dey
00:B750 D0FD            	   188:   bne serial_in_loop
                        	   189: 
                        	   190:   .if SERIAL_DEBUGGING
                        	   191:     lda #SERIAL_DEBUG1_MASK     ; toggle debug flag (2 cycles)
                        	   192:     tsb VIA_PORTA               ; (6 cycles)
                        	   193:     trb VIA_PORTA               ; (6 cycles)
                        	   194:   .else
00:B752 EA              	   195:     NOP    ; take the same time so the timing isn't thrown out
00:B753 EA              	   196:     NOP    ; 2 cycles each
00:B754 EA              	   197:     NOP
00:B755 EA              	   198:     NOP
00:B756 EA              	   199:     NOP
00:B757 EA              	   200:     NOP
00:B758 EA              	   201:     NOP    ; total of 14 cycles
                        	   202:   .endif  ; SERIAL_DEBUGGING
                        	   203: 
00:B759 ADF17F          	   204:   lda VIA_PORTA
00:B75C 6A              	   205:   ror A                 ; put incoming bit into carry
00:B75D 668A            	   206:   ror serial_in_byte    ; shift one bit in
00:B75F A023            	   207:   ldy #SERIAL_DELAY2    ; delay interval for remaining bits
00:B761 CA              	   208:   dex
00:B762 D0EB            	   209:   bne serial_in_loop
                        	   210: 
00:B764 7A              	   211:   ply
00:B765 FA              	   212:   plx
                        	   213: ;
                        	   214: ;  re-enable interrupts on the falling edge
                        	   215: ;
00:B766 A988            	   216:   lda #VIA_FLAG_ENABLE | VIA_FLAG_CB2
00:B768 8DFE7F          	   217:   sta VIA_IER
00:B76B 8DFD7F          	   218:   sta VIA_IFR   ; indicate we know about previous falling edges
                        	   219: 
                        	   220: ;
                        	   221: ;  move to place that we know it will be noticed
                        	   222: ;
00:B76E A58A            	   223:   lda serial_in_byte
00:B770 858B            	   224:   sta serial_in_byte_received
                        	   225: 
00:B772 802F            	   226:   bra irq_done
                        	   227: 
                        	   228: ;
                        	   229: ;  here for time to send another outgoing bit
                        	   230: ;
                        	   231: timer1_interrupt :
                        	   232: 
00:B774 8DFD7F          	   233:   sta VIA_IFR           ; indicate we noticed it
00:B777 A589            	   234:   lda serial_out_bit    ; are we in fact sending a byte?
00:B779 F028            	   235:   beq irq_done          ; no, just exit
                        	   236: 
                        	   237:   .if SERIAL_DEBUGGING
                        	   238: 
                        	   239:   lda #SERIAL_DEBUG2_MASK     ; toggle debug flag (2 cycles)
                        	   240:   tsb VIA_PORTA               ; wash on   (6 cycles)
                        	   241:   trb VIA_PORTA               ; wash off  (6 cycles)
                        	   242:                               ; now, sand the floor
                        	   243:  .else
00:B77B EA              	   244:      NOP    ; take the same time so the timing isn't thrown out
00:B77C EA              	   245:      NOP    ; 2 cycles each
00:B77D EA              	   246:      NOP
00:B77E EA              	   247:      NOP
00:B77F EA              	   248:      NOP
00:B780 EA              	   249:      NOP
00:B781 EA              	   250:      NOP    ; total of 14 cycles
                        	   251:   .endif  ; SERIAL_DEBUGGING
                        	   252: 
00:B782 6688            	   253:   ror serial_out_byte+1  ; we don't care about the high-order bit
00:B784 6687            	   254:   ror serial_out_byte    ; get the low-order bit into Carry
00:B786 9007            	   255:   bcc write_zero
00:B788 A902            	   256:   lda #SERIAL_OUT_MASK   ; (send a 1 bit)
00:B78A 0DF17F          	   257:   ora VIA_PORTA
00:B78D 8005            	   258:   bra serial_send_count_bits
                        	   259: 
                        	   260: write_zero:
00:B78F A9FD            	   261:   lda #~SERIAL_OUT_MASK  ; (send a 0 bit)
00:B791 2DF17F          	   262:   and VIA_PORTA
                        	   263: 
                        	   264: serial_send_count_bits:
00:B794 8DF17F          	   265:   sta VIA_PORTA          ; output this bit
00:B797 C689            	   266:   dec serial_out_bit     ; remember bit count for later
00:B799 D008            	   267:   bne irq_done
                        	   268: 
                        	   269: ; here when all bits have been sent
                        	   270: ; disable the timer as we don't need it any more
                        	   271: ; and this will be a flag that we can send another byte
                        	   272: 
00:B79B A940            	   273:   lda #VIA_FLAG_DISABLE | VIA_FLAG_TIMER1  ; cancel interrupt on T1 timeout
00:B79D 8DFE7F          	   274:   sta VIA_IER
00:B7A0 ADF47F          	   275:   lda VIA_T1C_L     ; clear interrupt flag
                        	   276: 
                        	   277: irq_done:
00:B7A3 FA              	   278:   plx   ; restore X
00:B7A4 68              	   279:   pla   ; restore A
00:B7A5 40              	   280:   rti
                        	   281: 

Source: "gpascal.asm"
                        	   182:   .include "lcd.inc"

Source: "lcd.inc"
                        	     1:   .if !EMULATOR
                        	     2:   .if LCD_SUPPORT
                        	     3: 
                        	     4: ;
                        	     5: ;  LCD stuff
                        	     6: ;
                        	     7: 
                        	     8: lcd_initialise:
                        	     9: ;
                        	    10: ;  LCD initialise
                        	    11: ;
                        	    12: 
00:B7A6 ADF37F          	    13:   lda VIA_DDRA
00:B7A9 09E0            	    14:   ora #(LCD_RW|LCD_RS|LCD_E)    ; set appropriate pins on Port A to output
00:B7AB 8DF37F          	    15:   sta VIA_DDRA
                        	    16: 
                        	    17:   ; see HD44780U documentation: "Initializing by Instruction" (page 46)
00:B7AE 2027B8          	    18:   jsr lcd_prepare_to_write_instruction
00:B7B1 A930            	    19:   lda #$30
00:B7B3 2087B8          	    20:   jsr lcd_write_instruction_nibble
                        	    21:   ; wait > 4.1 ms
00:B7B6 A214            	    22:   ldx #20
00:B7B8 A000            	    23:   ldy #0
00:B7BA 203F91          	    24:   jsr delay      ; 20 ms delay (in case of faster board clock speeds)
00:B7BD 2087B8          	    25:   jsr lcd_write_instruction_nibble
00:B7C0 203591          	    26:   jsr delay_1ms  ; do it 4 times in case of faster board clock speeds
00:B7C3 203591          	    27:   jsr delay_1ms
00:B7C6 203591          	    28:   jsr delay_1ms
00:B7C9 203591          	    29:   jsr delay_1ms
00:B7CC 2087B8          	    30:   jsr lcd_write_instruction_nibble
00:B7CF 203591          	    31:   jsr delay_1ms  ; do it 4 times in case of faster board clock speeds
00:B7D2 203591          	    32:   jsr delay_1ms
00:B7D5 203591          	    33:   jsr delay_1ms
00:B7D8 203591          	    34:   jsr delay_1ms
00:B7DB A920            	    35:   lda #$20    ; switch to 4-bit mode
00:B7DD 2087B8          	    36:   jsr lcd_write_instruction_nibble
00:B7E0 203591          	    37:   jsr delay_1ms  ; do it 4 times in case of faster board clock speeds
00:B7E3 203591          	    38:   jsr delay_1ms
00:B7E6 203591          	    39:   jsr delay_1ms
00:B7E9 203591          	    40:   jsr delay_1ms
                        	    41: ;
                        	    42: ;  now we can switch to sending 8-bits in two nibbles
                        	    43: ;
00:B7EC A928            	    44:   lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
00:B7EE 2093B8          	    45:   jsr lcd_instruction
00:B7F1 A90C            	    46:   lda #%00001100 ; DCB: Display on; cursor off; blink off
00:B7F3 2093B8          	    47:   jsr lcd_instruction
00:B7F6 A906            	    48:   lda #%00000110 ; Increment and shift cursor; don't shift display
00:B7F8 2093B8          	    49:   jsr lcd_instruction
00:B7FB 20E7B8          	    50:   jsr lcd_clear_display
00:B7FE 60              	    51:   rts
                        	    52: 
                        	    53: lcd_prepare_to_read_register:
00:B7FF ADF17F          	    54:   lda VIA_PORTA
00:B802 0940            	    55:   ora #LCD_RW             ; set RW bit  (ie. enable reading)
00:B804 295F            	    56:   and #<(~(LCD_RS|LCD_E)) ; Clear RS/E bits
00:B806 8DF17F          	    57:   sta VIA_PORTA
00:B809 ADF27F          	    58:   lda VIA_DDRB
00:B80C 290F            	    59:   and #$0F
00:B80E 8DF27F          	    60:   sta VIA_DDRB            ; we are reading from DDRB
00:B811 60              	    61:   rts
                        	    62: 
                        	    63: lcd_prepare_to_write_data:
00:B812 48              	    64:   pha
00:B813 ADF17F          	    65:   lda VIA_PORTA
00:B816 293F            	    66:   and #<(~(LCD_RW|LCD_E))  ; clear RW and E (enable writing)
00:B818 0920            	    67:   ora #LCD_RS              ; setting this means we write a character
00:B81A 8DF17F          	    68:   sta VIA_PORTA
00:B81D ADF27F          	    69:   lda VIA_DDRB
00:B820 09F0            	    70:   ora #$F0      ; Set high-order pins on port B to output
00:B822 8DF27F          	    71:   sta VIA_DDRB
00:B825 68              	    72:   pla
00:B826 60              	    73:   rts
                        	    74: 
                        	    75: lcd_prepare_to_write_instruction:
00:B827 48              	    76:   pha
00:B828 ADF17F          	    77:   lda VIA_PORTA
00:B82B 291F            	    78:   and #<(~(LCD_RW|LCD_RS|LCD_E))  ; clear RW, RS and E (enable writing)
00:B82D 8DF17F          	    79:   sta VIA_PORTA
00:B830 ADF27F          	    80:   lda VIA_DDRB
00:B833 09F0            	    81:   ora #$F0      ; Set high-order pins on port B to output
00:B835 8DF27F          	    82:   sta VIA_DDRB
00:B838 68              	    83:   pla
00:B839 60              	    84:   rts
                        	    85: 
                        	    86: lcd_set_enable:
00:B83A ADF17F          	    87:   lda VIA_PORTA
00:B83D 0980            	    88:   ora #LCD_E
00:B83F 8DF17F          	    89:   sta VIA_PORTA   ; Set enable (E)
00:B842 60              	    90:   rts
                        	    91: 
                        	    92: lcd_clear_enable:
00:B843 ADF17F          	    93:   lda VIA_PORTA
00:B846 297F            	    94:   and #<(~LCD_E)  ; Clear enable (E)
00:B848 8DF17F          	    95:   sta VIA_PORTA
00:B84B 60              	    96:   rts
                        	    97: 
                        	    98: lcd_read_instruction_nibble:
00:B84C 203AB8          	    99:   jsr lcd_set_enable
00:B84F ADF07F          	   100:   lda VIA_PORTB   ; read the data on port B
00:B852 48              	   101:   pha             ; save the data
00:B853 2043B8          	   102:   jsr lcd_clear_enable
00:B856 68              	   103:   pla             ; get the data back
00:B857 60              	   104:   rts
                        	   105: 
                        	   106: ;
                        	   107: ; wait until LCD is not busy
                        	   108: ;
                        	   109: lcd_wait:
00:B858 DA              	   110:   phx
00:B859 5A              	   111:   phy
00:B85A 48              	   112:   pha
00:B85B 20FFB7          	   113:   jsr lcd_prepare_to_read_register
00:B85E A200            	   114:   ldx #0
                        	   115: lcdbusy:
                        	   116: ;
                        	   117: ;  timeout after 256 iterations of this loop so we don't hang
                        	   118: ;  if there is no LCD or it doesn't respond
                        	   119: ;
00:B860 CA              	   120:   dex
00:B861 F00C            	   121:   beq lcd_wait_timeout
00:B863 204CB8          	   122:   jsr lcd_read_instruction_nibble
00:B866 2980            	   123:   and #$80        ; get busy flag
00:B868 A8              	   124:   tay             ; save busy status
00:B869 204CB8          	   125:   jsr lcd_read_instruction_nibble   ; do second nibble
00:B86C 98              	   126:   tya             ; get busy status back
00:B86D D0F1            	   127:   bne lcdbusy     ; if busy go back
                        	   128: ;
                        	   129: ;  here when not busy any more
                        	   130: ;
                        	   131: lcd_wait_timeout:
00:B86F 68              	   132:   pla
00:B870 7A              	   133:   ply
00:B871 FA              	   134:   plx
00:B872 60              	   135:   rts
                        	   136: 
                        	   137: ;
                        	   138: ;  Find the current LCD (cursor) address - useful for knowing
                        	   139: ;  if we exceed the limit of line 1
                        	   140: ;
                        	   141: lcd_get_address:
00:B873 20FFB7          	   142:   jsr lcd_prepare_to_read_register
00:B876 204CB8          	   143:   jsr lcd_read_instruction_nibble
00:B879 2970            	   144:   and #$70        ; ignore busy bit, mask out other junk
00:B87B 8586            	   145:   sta lcd_work
00:B87D 204CB8          	   146:   jsr lcd_read_instruction_nibble
00:B880 4A              	   147:   lsr A   ; shift this lot into low-order bits
00:B881 4A              	   148:   lsr A
00:B882 4A              	   149:   lsr A
00:B883 4A              	   150:   lsr A
00:B884 0586            	   151:   ora lcd_work    ; get the high-order bits back
00:B886 60              	   152:   rts
                        	   153: 
                        	   154: lcd_write_instruction_nibble:
00:B887 48              	   155:   pha
00:B888 8DF07F          	   156:   sta VIA_PORTB         ; set up the data
00:B88B 203AB8          	   157:   jsr lcd_set_enable    ; toggle enable
00:B88E 2043B8          	   158:   jsr lcd_clear_enable
00:B891 68              	   159:   pla
00:B892 60              	   160:   rts
                        	   161: 
                        	   162: ;
                        	   163: ;  send an instruction to the LCD
                        	   164: ;
                        	   165: lcd_instruction:
00:B893 2058B8          	   166:   jsr lcd_wait
00:B896 2027B8          	   167:   jsr lcd_prepare_to_write_instruction
00:B899 2087B8          	   168:   jsr lcd_write_instruction_nibble
00:B89C 48              	   169:   pha
00:B89D 0A              	   170:   asl a   ; move the low-order bits into the high-order bits
00:B89E 0A              	   171:   asl a   ; because the high-order 4 bits are the active ones
00:B89F 0A              	   172:   asl a
00:B8A0 0A              	   173:   asl a
00:B8A1 2087B8          	   174:   jsr lcd_write_instruction_nibble
00:B8A4 68              	   175:   pla
00:B8A5 60              	   176:   rts
                        	   177: 
                        	   178: lcd_data_nibble:
00:B8A6 48              	   179:   pha
00:B8A7 2012B8          	   180:   jsr lcd_prepare_to_write_data
00:B8AA 8DF07F          	   181:   sta VIA_PORTB
00:B8AD 203AB8          	   182:   jsr lcd_set_enable
00:B8B0 2043B8          	   183:   jsr lcd_clear_enable
00:B8B3 68              	   184:   pla
00:B8B4 60              	   185:   rts
                        	   186: 
                        	   187: ;
                        	   188: ;  print a character to the LCD
                        	   189: ;
                        	   190: lcd_print_char:
00:B8B5 2058B8          	   191:   jsr lcd_wait  ; wait for previous write to finish
00:B8B8 C90A            	   192:   cmp #NL
00:B8BA D004            	   193:   bne lcd_print_not_newline ; newline jumps to 2nd line
00:B8BC 20EFB8          	   194:   jsr lcd_second_line       ; go to second line
00:B8BF 60              	   195:   rts                       ; and don't print the newline :)
                        	   196: 
                        	   197: lcd_print_not_newline:
00:B8C0 48              	   198:   pha                   ; save the character we want to print
00:B8C1 2073B8          	   199:   jsr lcd_get_address
00:B8C4 C910            	   200:   cmp #16         ; 16 characters on the first line
00:B8C6 900E            	   201:   bcc lcd_print_char_ok ; not there yet
00:B8C8 D005            	   202:   bne lcd_print_char_on_2nd_line  ; not < 16 and not == 16, must be > 16
                        	   203:   ; we have exactly 16, so drop down to address 64
00:B8CA 20EFB8          	   204:   jsr lcd_second_line  ; at char 16 go to 2nd line (address 64)
00:B8CD 8007            	   205:   bra lcd_print_char_ok
                        	   206: 
                        	   207: lcd_print_char_on_2nd_line:
00:B8CF C950            	   208:   cmp #80                  ; more than 16 characters on in 2nd line? (64 + 16)
00:B8D1 9003            	   209:   bcc lcd_print_char_ok    ; nah
00:B8D3 20E7B8          	   210:   jsr lcd_clear_display    ; yes, clear display then and start again
                        	   211: lcd_print_char_ok:
                        	   212: lcd_print_char_newline:
00:B8D6 2012B8          	   213:   jsr lcd_prepare_to_write_data
00:B8D9 68              	   214:   pla                      ; get the character back
00:B8DA 20A6B8          	   215:   jsr lcd_data_nibble
00:B8DD 48              	   216:   pha
00:B8DE 0A              	   217:   asl a     ; now send the low-order bits
00:B8DF 0A              	   218:   asl a
00:B8E0 0A              	   219:   asl a
00:B8E1 0A              	   220:   asl a
00:B8E2 20A6B8          	   221:   jsr lcd_data_nibble
00:B8E5 68              	   222:   pla
00:B8E6 60              	   223:   rts
                        	   224: 
                        	   225: lcd_clear_display:
00:B8E7 48              	   226:   pha
00:B8E8 A901            	   227:   lda #%00000001 ; Clear display
00:B8EA 2093B8          	   228:   jsr lcd_instruction
00:B8ED 68              	   229:   pla
00:B8EE 60              	   230:   rts
                        	   231: 
                        	   232: lcd_second_line:
00:B8EF 48              	   233:   pha
00:B8F0 A9C0            	   234:   lda #$C0 ; set output address to 0x40 (set DDRAM address)
00:B8F2 2093B8          	   235:   jsr lcd_instruction
00:B8F5 68              	   236:   pla
00:B8F6 60              	   237:   rts
                        	   238: 
                        	   239: lcd_home:
00:B8F7 48              	   240:   pha
00:B8F8 A980            	   241:   lda #$80 ; set output address to 0 (set DDRAM address)
00:B8FA 2093B8          	   242:   jsr lcd_instruction
00:B8FD 68              	   243:   pla
00:B8FE 60              	   244:   rts
                        	   245: 
                        	   246: 
                        	   247: ;
                        	   248: ;  print null-terminated message on LCD, message in A (lo) and X (hi)
                        	   249: ;  returns the length of the message in Y
                        	   250: ;
                        	   251: lcd_print_message:
00:B8FF 8503            	   252:   sta REG2
00:B901 8604            	   253:   stx REG2+1
00:B903 A000            	   254:   ldy #0
00:B905 20E7B8          	   255:   jsr lcd_clear_display
                        	   256: lcd_print:
00:B908 B103            	   257:   lda (REG2),y
00:B90A F006            	   258:   beq lcd_print_done
00:B90C 20B5B8          	   259:   jsr lcd_print_char
00:B90F C8              	   260:   iny
00:B910 80F6            	   261:   bra lcd_print
                        	   262: 
00:B912 60              	   263: lcd_print_done rts
                        	   264: 
                        	   265:   .else ; LCD_SUPPORT
                        	   266: 
                        	   267: lcd_print_char :
                        	   268: lcd_clear_display :
                        	   269: lcd_second_line:
                        	   270: lcd_print_message:
                        	   271: lcd_instruction:
                        	   272: lcd_get_address:
                        	   273: lcd_home:
                        	   274: lcd_wait:
                        	   275:     ldx #50     ; No LCD
                        	   276:     jmp ERROR
                        	   277: 
                        	   278: 
                        	   279:   .endif  ; (no) LCD_SUPPORT
                        	   280: 
                        	   281:   .endif  ; not emulator
                        	   282: 

Source: "gpascal.asm"
                        	   183:   .include "symbols.inc"

Source: "symbols.inc"
                        	     1: ;***********************************************
                        	     2: ; SYMBOL TABLE STUFF: Offsets from the start of a particular symbol
                        	     3: ; Stored as a linked list, where you search backwards so the more local one is found first
                        	     4: ;***********************************************
                        	     5: 
                        	     6: SYMPRV   =  0         ; address of previous symbol (for working backwards through symbols)
                        	     7: SYMLVL   =  2         ; nested level (eg. entering a procedure/function increments the level,
                        	     8:                       ;                   and leaving it decrements the level)
                        	     9:                       ; - used to detect duplicate symbols at the same level
                        	    10: SYMTYP   =  3         ; Symbol type: C = constant, V = variable, Y = function return value
                        	    11:                       ;              P = procedure, F = function, A = array
                        	    12:                       ;              p = library procedure, f = library function
                        	    13:                       ;  See defines below.
                        	    14: SYMDSP   =  4         ; if the symbol is a constant, what the value is (3 bytes)
                        	    15:                       ; if the symbol is a variable, array or function return then this is the offset (2 bytes)
                        	    16: SYMARG   =  6         ; if the symbol is a procedure/function, count of arguments (can be zero)
                        	    17: SYMSUB   =  6         ; MAX SUBSCRIPT+1 - for arrays, so this is the actual array length
                        	    18: SYMDAT   =  8         ; data type: 0 = integer, 1 = char
                        	    19: SYMLEN   =  9         ; length of the name, der
                        	    20: SYMNAM   =  10        ; name of symbol for SYMLEN characters, stored in upper-case
                        	    21: 
                        	    22: ;
                        	    23: ; Symbol types
                        	    24: ;
                        	    25: 
                        	    26: SYMBOL_CONSTANT          = 'C'
                        	    27: SYMBOL_VARIABLE          = 'V'
                        	    28: SYMBOL_FUNCTION_RETURN   = 'Y'
                        	    29: SYMBOL_PROCEDURE         = 'P'
                        	    30: SYMBOL_FUNCTION          = 'F'
                        	    31: SYMBOL_LIBRARY_PROCEDURE = 'Q'  ; library procedures and functions are implemented in assembler
                        	    32: SYMBOL_LIBRARY_FUNCTION  = 'R'
                        	    33: SYMBOL_ARRAY             = 'A'
                        	    34: 
                        	    35: 
                        	    36: 
                        	    37: ;
                        	    38: ;***********************************************
                        	    39: ;SEARCH SYMBOL TABLE - returns Z if not found (BEQ <not found>)
                        	    40: ;***********************************************
                        	    41: SEARCH   =  *
00:B913 A532            	    42:          lda  ENDSYM+1    ; get the end of the symbol table
00:B915 8541            	    43:          sta  SYMITM+1    ; make it the current symbol
00:B917 A531            	    44:          lda  ENDSYM
00:B919 800B            	    45:          bra  SEA1
                        	    46: 
                        	    47: SEA_NEXT =  *
00:B91B A000            	    48:          ldy  #SYMPRV
00:B91D B140            	    49:          lda  (SYMITM),Y
00:B91F AA              	    50:          tax
00:B920 C8              	    51:          iny
00:B921 B140            	    52:          lda  (SYMITM),Y
00:B923 8541            	    53:          sta  SYMITM+1   ; previous link
00:B925 8A              	    54:          txa
                        	    55: ;
                        	    56: ;  go to the previous symbol table item
                        	    57: ;
                        	    58: SEA1     =  *
00:B926 8540            	    59:          sta  SYMITM
00:B928 C52F            	    60:          cmp  STARTSYM
00:B92A D007            	    61:          bne  SEA2
00:B92C A541            	    62:          lda  SYMITM+1
00:B92E C530            	    63:          cmp  STARTSYM+1
00:B930 D001            	    64:          bne  SEA2       ; more to go
00:B932 60              	    65:          rts             ; finished if we are back at the start of the symbol table
                        	    66: 
                        	    67: SEA2     =  *
00:B933 A009            	    68:          ldy  #SYMLEN
00:B935 B140            	    69:          lda  (SYMITM),Y  ; get this item's length
00:B937 C592            	    70:          cmp  token_length      ; compare to the token legnth we got
00:B939 D0E0            	    71:          bne  SEA_NEXT    ; wrong length - try another
00:B93B A540            	    72:          lda  SYMITM      ; back to this symbol's start address
00:B93D 18              	    73:          clc
00:B93E 690A            	    74:          adc  #SYMNAM     ; add the offset of the name to it
00:B940 8503            	    75:          sta  DEST
00:B942 A541            	    76:          lda  SYMITM+1
00:B944 6900            	    77:          adc  #0
00:B946 8504            	    78:          sta  DEST+1      ; the memory location of the symbol name is in DEST
00:B948 A590            	    79:          lda  token_address      ; now put the token's address into SRCE
00:B94A 8500            	    80:          sta  SRCE
00:B94C A591            	    81:          lda  token_address+1
00:B94E 8501            	    82:          sta  SRCE+1
00:B950 A492            	    83:          ldy  token_length
00:B952 209792          	    84:          jsr  COMSTL      ; compare SRCE to DEST
00:B955 D0C4            	    85:          bne  SEA_NEXT    ; not that one - try another
00:B957 20CFBA          	    86:          jsr  GET_DAT     ; get the symbol's data type into DATTYP
00:B95A A002            	    87:          ldy  #SYMLVL     ; and level - why isn't this a function, huh?
00:B95C B140            	    88:          lda  (SYMITM),Y
00:B95E AA              	    89:          tax              ; level into X
00:B95F A003            	    90:          ldy  #SYMTYP
00:B961 B140            	    91:          lda  (SYMITM),Y  ; get type of symbol
00:B963 8536            	    92:          sta  BSAVE       ; symbol type -> BSAVE
00:B965 C943            	    93:          cmp  #SYMBOL_CONSTANT       ; constant?
00:B967 D013            	    94:          bne  SEA4        ; nah
                        	    95: ;
                        	    96: ;  symbol is a constant
                        	    97: ;
00:B969 A004            	    98:          ldy  #SYMDSP     ; if a constant, this is the value
00:B96B B140            	    99:          lda  (SYMITM),Y
00:B96D 8594            	   100:          sta  token_value
00:B96F C8              	   101:          iny
00:B970 B140            	   102:          lda  (SYMITM),Y
00:B972 8595            	   103:          sta  token_value+1
00:B974 C8              	   104:          iny
00:B975 B140            	   105:          lda  (SYMITM),Y
00:B977 8596            	   106:          sta  token_value+2     ; token_value (3 bytes) now has the value in it
00:B979 4C87B9          	   107:          jmp  SEA3
                        	   108: ;
                        	   109: ;  symbol is not a constant
                        	   110: ;
                        	   111: SEA4     =  *                           ; not constant
00:B97C C956            	   112:          cmp  #SYMBOL_VARIABLE          ; variable?
00:B97E F004            	   113:          beq  SEA5                      ; yes
00:B980 C959            	   114:          cmp  #SYMBOL_FUNCTION_RETURN   ; argument?
00:B982 D003            	   115:          bne  SEA3                      ; no - must be SYMBOL_ARRAY, SYMBOL_PROCEDURE or SYMBOL_FUNCTION
                        	   116: ;
                        	   117: ;  here for variables and function return values
                        	   118: ;
                        	   119: SEA5     =  *
00:B984 202ABB          	   120:          jsr  GET_OFF    ; get the variable's offset
                        	   121: SEA3     =  *
00:B987 A536            	   122:          lda  BSAVE      ; A now has the symbol type in it
                        	   123: 
                        	   124: ; Types are: SYMBOL_CONSTANT, SYMBOL_VARIABLE, SYMBOL_FUNCTION_RETURN,
                        	   125: ;            SYMBOL_PROCEDURE, SYMBOL_FUNCTION, SYMBOL_ARRAY
                        	   126: 
00:B989 60              	   127:          rts             ; SHOULD SET 'NEQ' FLAG
                        	   128: 
                        	   129: 
00:B98A A225            	   130: SYM_FULL ldx  #37     ; ERROR: Symbol table full
00:B98C 4CCE97          	   131:          jmp  ERROR
                        	   132: 
                        	   133: ;***********************************************
                        	   134: ; ADD SYMBOL TO SYMBOL TABLE - going downwards until we hit the P-codes
                        	   135: ;  A = the symbol type
                        	   136: ;***********************************************
                        	   137: ADDSYM   =  *
00:B98F 48              	   138:          pha            ; save the symbol type
                        	   139: 
00:B990 A631            	   140:          ldx  ENDSYM    ; get the end of the symbol table
00:B992 8640            	   141:          stx  SYMITM    ; make it the current symbol
00:B994 A632            	   142:          ldx  ENDSYM+1
00:B996 8641            	   143:          stx  SYMITM+1
                        	   144: ;
                        	   145: ;  since we are going downwards, we need to subtract the fixed size of a symbol table item,
                        	   146: ;  plus the symbol length, from SYMITM
                        	   147: ;
00:B998 38              	   148:          sec            ; first subtract the token length
00:B999 A540            	   149:          lda  SYMITM
00:B99B E592            	   150:          sbc  token_length
00:B99D 8540            	   151:          sta  SYMITM
00:B99F 8503            	   152:          sta  DEST      ; put this spot into DEST for copying the name
00:B9A1 A541            	   153:          lda  SYMITM+1
00:B9A3 E900            	   154:          sbc  #0
00:B9A5 8541            	   155:          sta  SYMITM+1
00:B9A7 8504            	   156:          sta  DEST+1
00:B9A9 38              	   157:          sec            ; and now the fixed size
00:B9AA A540            	   158:          lda  SYMITM
00:B9AC E90A            	   159:          sbc  #SYMNAM
00:B9AE 8540            	   160:          sta  SYMITM
00:B9B0 A541            	   161:          lda  SYMITM+1
00:B9B2 E900            	   162:          sbc  #0
00:B9B4 8541            	   163:          sta  SYMITM+1
                        	   164: ;
                        	   165: ;  check we haven't hit the P-codes
                        	   166: ;
00:B9B6 A902            	   167:          lda  #FLAG_ASSEMBLING
00:B9B8 25BE            	   168:          and  system_flags
00:B9BA D008            	   169:          bne  ADDSYM_NOT_FULL
00:B9BC A524            	   170:          lda  PCODE+1
00:B9BE C541            	   171:          cmp  SYMITM+1
00:B9C0 9002            	   172:          bcc  ADDSYM_NOT_FULL   ; less than - ok
00:B9C2 80C6            	   173:          bra  SYM_FULL          ; greater than or equal (high-order byte) - uh oh
                        	   174: ;
                        	   175: ;  ah, for assembling it is a pain to know whether the symbol table has overflowed, so I'm going
                        	   176: ;  to ignore that as a problem for now. Checking against PCODE will not work if the assembler output
                        	   177: ;  has been relocated to above the symbol table, and the only other thing we can compare against is
                        	   178: ;  the end of the source which we don't necessarily know.
                        	   179: ;
                        	   180: ;
                        	   181: ;  now put the previous start in as the link for the previous one for this item
                        	   182: ;
                        	   183: ADDSYM_NOT_FULL:
00:B9C4 A000            	   184:          ldy  #SYMPRV
00:B9C6 A531            	   185:          lda  ENDSYM
00:B9C8 9140            	   186:          sta  (SYMITM),Y
00:B9CA A532            	   187:          lda  ENDSYM+1
00:B9CC C8              	   188:          iny
00:B9CD 9140            	   189:          sta  (SYMITM),Y
                        	   190: ;
                        	   191: ;  SYMITM now becomes the start of the symbol table
                        	   192: ;
00:B9CF A540            	   193:          lda  SYMITM
00:B9D1 8531            	   194:          sta  ENDSYM
00:B9D3 A541            	   195:          lda  SYMITM+1
00:B9D5 8532            	   196:          sta  ENDSYM+1
                        	   197: ;
                        	   198: ;  OK, we should be done linking it in.
                        	   199: ;  SYMITM now points to this (as yet unfilled-in) item and the first two bytes now point to
                        	   200: ;   where the symbols previously ended
                        	   201: ;
00:B9D7 68              	   202:          pla                ; get symbol type back
00:B9D8 A003            	   203:          ldy  #SYMTYP
00:B9DA 9140            	   204:          sta  (SYMITM),Y    ; store the type which was in A
00:B9DC A002            	   205:          ldy  #SYMLVL
00:B9DE 48              	   206:          pha                ; save symbol type again
00:B9DF A522            	   207:          lda  LEVEL
00:B9E1 9140            	   208:          sta  (SYMITM),Y    ; store the level
00:B9E3 A009            	   209:          ldy  #SYMLEN
00:B9E5 A592            	   210:          lda  token_length
00:B9E7 9140            	   211:          sta  (SYMITM),Y    ; store the token length
00:B9E9 A8              	   212:          tay
00:B9EA 88              	   213:          dey                ; make zero-relative
                        	   214: ADD1     =  *               ; copy the name across, in upper case
00:B9EB B190            	   215:          lda  (token_address),Y
00:B9ED 202E90          	   216:          jsr  MAKE_UPPER
00:B9F0 9103            	   217:          sta  (DEST),Y
00:B9F2 88              	   218:          dey
00:B9F3 10F6            	   219:          bpl  ADD1      ; keep copying
                        	   220: 
                        	   221: ;
                        	   222: ;  we have added name to the table, now do the rest
                        	   223: ;
00:B9F5 68              	   224:          pla                     ; get symbol type back again
00:B9F6 AA              	   225:          tax                     ; symbol type
00:B9F7 C943            	   226:          cmp  #SYMBOL_CONSTANT   ; CONSTANT??
00:B9F9 D013            	   227:          bne  ADD4
                        	   228: ;
                        	   229: ;  constant
                        	   230: ;
00:B9FB A004            	   231:          ldy  #SYMDSP            ; put this token's value into SYMDSP offset from SYMITM (for 3 bytes)
00:B9FD A594            	   232:          lda  token_value
00:B9FF 9140            	   233:          sta  (SYMITM),Y
00:BA01 C8              	   234:          iny
00:BA02 A595            	   235:          lda  token_value+1
00:BA04 9140            	   236:          sta  (SYMITM),Y
00:BA06 C8              	   237:          iny
00:BA07 A596            	   238:          lda  token_value+2
00:BA09 9140            	   239:          sta  (SYMITM),Y
00:BA0B 4C2ABA          	   240:          jmp  ADD9
                        	   241: ;
                        	   242: ;  not a constant
                        	   243: ;
                        	   244: ADD4     =  *
00:BA0E A008            	   245:          ldy  #SYMDAT
00:BA10 A901            	   246:          lda  #1            ; char type (?)
00:BA12 9140            	   247:          sta  (SYMITM),Y
00:BA14 8A              	   248:          txa                ; get symbol type back
00:BA15 C956            	   249:          cmp  #SYMBOL_VARIABLE
00:BA17 D011            	   250:          bne  ADD9
                        	   251: ;
                        	   252: ;  variable type
                        	   253: ;
00:BA19 A005            	   254:          ldy  #SYMDSP+1
00:BA1B A521            	   255:          lda  FRAME+1       ; save frame
00:BA1D 9140            	   256:          sta  (SYMITM),Y
00:BA1F 88              	   257:          dey
00:BA20 A520            	   258:          lda  FRAME
00:BA22 9140            	   259:          sta  (SYMITM),Y
00:BA24 E620            	   260:          inc  FRAME         ; add 1 to frame number
00:BA26 D002            	   261:          bne  ADD9
00:BA28 E621            	   262:          inc  FRAME+1
                        	   263: ADD9     =  *
00:BA2A 60              	   264:          rts
                        	   265: ;
                        	   266: 
                        	   267: ;
                        	   268: LOOKUP   =  *
00:BA2B 2013B9          	   269:          JSR  SEARCH
00:BA2E D005            	   270:          BNE  LOOK1
00:BA30 A20B            	   271:          LDX  #11     ; ERROR: Undeclared Identifier
00:BA32 4CCE97          	   272:          jmp  ERROR
00:BA35 60              	   273: LOOK1    RTS
                        	   274: ;
00:BA36 2013B9          	   275: CHKDUP   JSR  SEARCH
00:BA39 F00A            	   276:          BEQ  DUP9
00:BA3B 8A              	   277:          TXA
00:BA3C C522            	   278:          CMP  LEVEL
00:BA3E D005            	   279:          BNE  DUP9
00:BA40 A226            	   280:          LDX  #38   ; ERROR: Duplicate Identifier
00:BA42 4CCE97          	   281:          jmp  ERROR
00:BA45 60              	   282: DUP9     RTS
                        	   283: 

Source: "gpascal.asm"
                        	   184:   .include "compiler.inc"

Source: "compiler.inc"
                        	     1: 
                        	     2: ;***********************************************
                        	     3: ; COMPILER
                        	     4: ;***********************************************
                        	     5: 
                        	     6: 
                        	     7: ;
                        	     8: ;
                        	     9: ;  Compiler directives:
                        	    10: ;
                        	    11: ;    {%L} - list during compile (source code and current P-code address)
                        	    12: ;    {%P} - show generated P-codes during compile - only works during compile (not syntax check)
                        	    13: ;    {%N} - stop listing during compile (cancels %L and %P)
                        	    14: ;    {%S <address>} - relocate symbol table to <address> - must be done before defining symbols
                        	    15: ;                     also generates an opcode to relocate the runtime stack
                        	    16: ;
                        	    17: ;   The % must directly follow the start of the comment.
                        	    18: ;
                        	    19: ;
                        	    20: ;  Comments:  (* some comment *) or { some comment }
                        	    21: ;             "(*" / "{", and "*)" / "}" are treated interchangeably so (* some comment } would work
                        	    22: ;  Comments cannot be nested.
                        	    23: ;
                        	    24: ;  Tips:
                        	    25: ;
                        	    26: ;   Procedures and functions must be declared at the START of a block, not in the middle.
                        	    27: ;   The order is important. CONST first, then VAR, then procedure/function declarations, then BEGIN
                        	    28: 
                        	    29: ;    eg.
                        	    30: ;
                        	    31: ;    const limit = 10;   { <-- this is the start of a block: CONST before VAR }
                        	    32: ;    var k: integer;     { we declare variables and constants here - BEFORE "begin" }
                        	    33: ;    line : array [100] of char;  { array }
                        	    34: ;    function foo;       { and functions and procedures - this is the start of another block}
                        	    35: ;    begin
                        	    36: ;      foo := 42         { assign to function return value }
                        	    37: ;    end;                { end of the function block - note semicolon }
                        	    38: ;    begin               { end of declarations - now we have the block statements }
                        	    39: ;     for k := 1 to limit do
                        	    40: ;       writeln ("square of ", k, " is ", k * k);
                        	    41: ;     write (foo)        { call function }
                        	    42: ;    end.
                        	    43: ;
                        	    44: ;    ARGUMENTS: If the procedure or function does not take arguments OMIT THE BRACKETS.
                        	    45: ;               Likewise, omit the brackets if you call the procedure or function (unlike C)
                        	    46: ;
                        	    47: ;    Semicolons SEPARATE statements, they don't terminate them.
                        	    48: ;
                        	    49: ; Warnings: * Functions which do not assign to the function return value give undefined results.
                        	    50: ;           * Multiplication discards high-order bits if result is too large.
                        	    51: ;           * Divide remainder is always positive (ie. MOD always gives a positive result, regardless of operand signs)
                        	    52: ;           * Function arguments are always integers and always return an integer.
                        	    53: ;           * One to three-byte strings can be used as integer constants
                        	    54: ;               eg. a := "abc"; write (a);   --> Result: 6513249 (ie. 0x636261 or "abc")
                        	    55: ;               The first character is the low-order byte in the number, explaining the above results.
                        	    56: ;           * Strings can start with single or double quotes, whatever starts the string must terminate it.
                        	    57: ;           * String literals can have the same character that started the string embedded, to do that put it twice.
                        	    58: ;             eg. 'Nick''s cat'
                        	    59: ;           * Array access it not range-checked.
                        	    60: ;           * Arrays start at zero. The array size declared is the maximum index (unlike C) so foo: array [10] of integ
                        	    61: ;               would declare an array of 11 elements, numbered from foo [0] to foo [10]
                        	    62: ;           * Maximum arguments to a procedure/function is 85 (255 / 3) due to internal coding
                        	    63: ;
                        	    64: 
                        	    65: 
                        	    66: ;
00:BA46 A2FF            	    67: COMPIL   LDX  #NEW_STK
00:BA48 9A              	    68:   txs    ; set stack back to 0xFF
                        	    69: 
00:BA49 204492          	    70:   jsr  INIT
00:BA4C A901            	    71:   lda  #FLAG_COMPILING
00:BA4E 04BE            	    72:   tsb  system_flags
00:BA50 20B7C6          	    73:   jsr  add_pascal_library_functions
00:BA53 203BCF          	    74:   jsr  pas_get_token
00:BA56 203AC3          	    75:   jsr  BLOCK
00:BA59 A92E            	    76:   lda  #'.'
00:BA5B A209            	    77:   ldx  #9        ; ERROR: . expected
00:BA5D 209FCF          	    78:   jsr  CHKTKN
00:BA60 A900            	    79:   lda  #0
00:BA62 A213            	    80:   ldx  #19       ; ERROR: Incorrect Symbol
00:BA64 208FCF          	    81:   jsr  GETCHK
00:BA67 209292          	    82:   jsr  CROUT
00:BA6A A949            	    83:   lda  #<pcodes_ended_message  ; P-codes ended at
00:BA6C A293            	    84:   ldx  #>pcodes_ended_message
00:BA6E 202682          	    85:   jsr  print
00:BA71 A524            	    86:   lda  PCODE+1
00:BA73 8544            	    87:   sta  END_PCD+1
00:BA75 200793          	    88:   jsr  PRBYTE
00:BA78 A523            	    89:   lda  PCODE
00:BA7A 8543            	    90:   sta  END_PCD
00:BA7C 20BC93          	    91:   jsr  PRBYTECR
00:BA7F 200F8F          	    92:   jsr  show_symbol_table_end
00:BA82 20348F          	    93:   jsr  show_source_end
                        	    94: 
00:BA85 A95C            	    95:   lda  #<compile_finished_message  ; <C>ompile finished: No Errors
00:BA87 A293            	    96:   ldx  #>compile_finished_message
00:BA89 202682          	    97:   jsr  print
00:BA8C A642            	    98:   ldx  SYNTAX
00:BA8E D004            	    99:   bne  END_CMP
00:BA90 A908            	   100:   lda  #FLAG_VALID_COMPILE
00:BA92 04BE            	   101:   tsb  system_flags
                        	   102: END_CMP  =  *
00:BA94 4CCD82          	   103:   jmp  main_prompt
                        	   104: ;
                        	   105: 
                        	   106: ;
                        	   107: CHKLHP   =  *
00:BA97 A928            	   108:          LDA  #'('
00:BA99 A21F            	   109:          LDX  #31     ; ERROR: ( expected
00:BA9B 4C8FCF          	   110:          JMP  GETCHK
                        	   111: ;
                        	   112: CHKRHP   =  *
00:BA9E A929            	   113:          LDA  #')'
00:BAA0 A216            	   114:          LDX  #22     ; ERROR: ) expected
00:BAA2 209FCF          	   115:          JSR  CHKTKN
00:BAA5 4C3BCF          	   116:          JMP  pas_get_token
                        	   117: ;
                        	   118: GETSUB   =  *
00:BAA8 20B1BA          	   119:          JSR  CHKLHB
00:BAAB 20C2BD          	   120:          JSR  EXPRES
00:BAAE 4CBBBA          	   121:          JMP  CHKRHB
                        	   122: ;
                        	   123: CHKLHB   =  *
00:BAB1 A95B            	   124:          LDA  #'['
00:BAB3 A221            	   125:          LDX  #33     ; ERROR: [ expected
00:BAB5 208FCF          	   126:          JSR  GETCHK
00:BAB8 4C3BCF          	   127:          JMP  pas_get_token
                        	   128: ;
                        	   129: CHKRHB   =  *
00:BABB A95D            	   130:          LDA  #']'
00:BABD A222            	   131:          LDX  #34     ; ERROR: ] expected
00:BABF 209FCF          	   132:          JSR  CHKTKN
00:BAC2 4C3BCF          	   133:          JMP  pas_get_token
                        	   134: ;
                        	   135: GET_LEV  =  *
00:BAC5 A522            	   136:          LDA  LEVEL
00:BAC7 A002            	   137:          LDY  #SYMLVL
00:BAC9 38              	   138:          SEC
00:BACA F140            	   139:          SBC  (SYMITM),Y
00:BACC 8527            	   140:          STA  DISPL
00:BACE 60              	   141:          RTS
                        	   142: ;
                        	   143: GET_DAT  =  *
00:BACF A008            	   144:          LDY  #SYMDAT
00:BAD1 B140            	   145:          LDA  (SYMITM),Y
00:BAD3 854A            	   146:          STA  DATTYP
00:BAD5 60              	   147:          RTS
                        	   148: ;
                        	   149: 
                        	   150: 
                        	   151: 
                        	   152: ; CONSTANT DEC
                        	   153: ;
                        	   154: CONDEC   =  *
00:BAD6 A949            	   155:          LDA  #TOKEN_IDENTIFIER
00:BAD8 A204            	   156:          LDX  #4        ; ERROR: Identifier expected
00:BADA 209FCF          	   157:          JSR  CHKTKN
00:BADD 203393          	   158:          JSR  TKNWRK
00:BAE0 A592            	   159:          LDA  token_length
00:BAE2 48              	   160:          PHA
00:BAE3 A93D            	   161:          LDA  #'='
00:BAE5 A203            	   162:          LDX  #3        ; ERROR: = expected
00:BAE7 208FCF          	   163:          JSR  GETCHK
00:BAEA 203BCF          	   164:          JSR  pas_get_token
00:BAED 20C9BB          	   165:          JSR  CONST
00:BAF0 203E93          	   166:          JSR  WRKTKN
00:BAF3 68              	   167:          PLA
00:BAF4 8592            	   168:          STA  token_length
00:BAF6 2036BA          	   169:          JSR  CHKDUP
00:BAF9 A943            	   170:          LDA  #SYMBOL_CONSTANT
00:BAFB 208FB9          	   171:          JSR  ADDSYM
00:BAFE 4C3BCF          	   172:          JMP  pas_get_token
                        	   173: ;
                        	   174: ;
                        	   175: ;--- SYMITM --> WORK
                        	   176: ;
                        	   177: SYMWRK   =  *
00:BB01 48              	   178:          PHA
00:BB02 A540            	   179:          LDA  SYMITM
00:BB04 8537            	   180:          STA  WORK
00:BB06 A541            	   181:          LDA  SYMITM+1
00:BB08 8538            	   182:          STA  WORK+1
00:BB0A 68              	   183:          PLA
00:BB0B 60              	   184:          RTS
                        	   185: ;
                        	   186: ;--- WORK --> SYMITM
                        	   187: ;
                        	   188: WRKSYM   =  *
00:BB0C 48              	   189:          PHA
00:BB0D A537            	   190:          LDA  WORK
00:BB0F 8540            	   191:          STA  SYMITM
00:BB11 A538            	   192:          LDA  WORK+1
00:BB13 8541            	   193:          STA  SYMITM+1
00:BB15 68              	   194:          PLA
00:BB16 60              	   195:          RTS
                        	   196: ;
                        	   197: ; PUSH PCODE ONTO STACK
                        	   198: ;
                        	   199: PSHPCODE =  *
00:BB17 8536            	   200:          STA  BSAVE
00:BB19 68              	   201:          PLA
00:BB1A AA              	   202:          TAX
00:BB1B 68              	   203:          PLA
00:BB1C A8              	   204:          TAY
00:BB1D A524            	   205:          LDA  PCODE+1
00:BB1F 48              	   206:          PHA
00:BB20 A523            	   207:          LDA  PCODE
00:BB22 48              	   208:          PHA
00:BB23 98              	   209:          TYA
00:BB24 48              	   210:          PHA
00:BB25 8A              	   211:          TXA
00:BB26 48              	   212:          PHA
00:BB27 A536            	   213:          LDA  BSAVE
00:BB29 60              	   214:          RTS
                        	   215: ;
                        	   216: ;  Get the offset of this current symbol into OFFSET
                        	   217: ;
                        	   218: GET_OFF  =  *
00:BB2A 48              	   219:          PHA
00:BB2B A004            	   220:          LDY  #SYMDSP
00:BB2D B140            	   221:          LDA  (SYMITM),Y
00:BB2F 8529            	   222:          STA  OFFSET
00:BB31 C8              	   223:          INY
00:BB32 B140            	   224:          LDA  (SYMITM),Y
00:BB34 852A            	   225:          STA  OFFSET+1
00:BB36 A003            	   226:          LDY  #SYMTYP
00:BB38 B140            	   227:          LDA  (SYMITM),Y
00:BB3A C956            	   228:          CMP  #SYMBOL_VARIABLE
00:BB3C F008            	   229:          BEQ  GETO_1
00:BB3E C941            	   230:          CMP  #SYMBOL_ARRAY
00:BB40 F004            	   231:          BEQ  GETO_1
00:BB42 C959            	   232:          CMP  #SYMBOL_FUNCTION_RETURN
00:BB44 D00D            	   233:          BNE  GETO_2
                        	   234: ;
                        	   235: ;  here if the symbol is a variable, array or function return value
                        	   236: ;   subtract the offset from -3
                        	   237: ;
                        	   238: GETO_1   =  *
00:BB46 38              	   239:          SEC
00:BB47 A9FD            	   240:          LDA  #$FD
00:BB49 E529            	   241:          SBC  OFFSET
00:BB4B 8529            	   242:          STA  OFFSET
00:BB4D A9FF            	   243:          LDA  #$FF
00:BB4F E52A            	   244:          SBC  OFFSET+1
00:BB51 852A            	   245:          STA  OFFSET+1
                        	   246: GETO_2   =  *
00:BB53 68              	   247:          PLA
00:BB54 60              	   248:          RTS
                        	   249: ;
                        	   250: GETEXPR  =  *
00:BB55 203BCF          	   251:          JSR  pas_get_token
00:BB58 4CC2BD          	   252:          JMP  EXPRES
                        	   253: ;
                        	   254: ;
                        	   255: PCD_WRKD =  *
00:BB5B 48              	   256:          PHA
00:BB5C A523            	   257:          LDA  PCODE
00:BB5E 8533            	   258:          STA  WORKD
00:BB60 A524            	   259:          LDA  PCODE+1
00:BB62 8534            	   260:          STA  WORKD+1
00:BB64 68              	   261:          PLA
00:BB65 60              	   262:          RTS
                        	   263: ;
                        	   264: WRK_OPND =  *
00:BB66 48              	   265:          PHA
00:BB67 A537            	   266:          LDA  WORK
00:BB69 852B            	   267:          STA  OPND
00:BB6B A538            	   268:          LDA  WORK+1
00:BB6D 852C            	   269:          STA  OPND+1
00:BB6F 68              	   270:          PLA
00:BB70 60              	   271:          RTS
                        	   272: ;
                        	   273: WRKD_WRK =  *
00:BB71 48              	   274:          PHA
00:BB72 A533            	   275:          LDA  WORKD
00:BB74 8537            	   276:          STA  WORK
00:BB76 A534            	   277:          LDA  WORKD+1
00:BB78 8538            	   278:          STA  WORK+1
00:BB7A 68              	   279:          PLA
00:BB7B 60              	   280:          RTS
                        	   281: ;
                        	   282: WRK_WRKD =  *
00:BB7C 48              	   283:          PHA
00:BB7D A537            	   284:          LDA  WORK
00:BB7F 8533            	   285:          STA  WORKD
00:BB81 A538            	   286:          LDA  WORK+1
00:BB83 8534            	   287:          STA  WORKD+1
00:BB85 68              	   288:          PLA
00:BB86 60              	   289:          RTS
                        	   290: ;
                        	   291: GET_COMM =  *
00:BB87 A92C            	   292:          LDA  #','
00:BB89 A220            	   293:          LDX  #32     ; ERROR: , expected
00:BB8B 4C9FCF          	   294:          JMP  CHKTKN
                        	   295: ;
                        	   296: GET_ITEM =  *
00:BB8E 2087BB          	   297:          JSR  GET_COMM   ; check for comma
00:BB91 4C55BB          	   298:          JMP  GETEXPR
                        	   299: ;
                        	   300: ;  Load (push) a constant (ie. a literal number)
                        	   301: ;
                        	   302: ;  Numbers in the range 0 to 0x7F are turned into a "low literal" which is a P-code
                        	   303: ;  with the 0x80 bit set. These then become a single-byte P-code which simply pushes
                        	   304: ;  that number onto the stack, thus saving having to have a 4-byte P-code being PCODE_LIT
                        	   305: ;  followed by a 3-byte number, 2 bytes of which would be zero.
                        	   306: ;
                        	   307: VAL_MOVE =  *
00:BB94 48              	   308:          PHA
00:BB95 18              	   309:          CLC
00:BB96 A594            	   310:          LDA  token_value
00:BB98 8527            	   311:          STA  DISPL   ; why?
00:BB9A 1001            	   312:          BPL  VAL_1   ; is it 0x00 to 0x7F?
00:BB9C 38              	   313:          SEC          ; no, set carry bit
                        	   314: VAL_1    =  *
00:BB9D A595            	   315:          LDA  token_value+1
00:BB9F F001            	   316:          BEQ  VAL_2   ; is second byte 0x00?
00:BBA1 38              	   317:          SEC          ; no, set carry bit
                        	   318: VAL_2    =  *
00:BBA2 8529            	   319:          STA  OFFSET
00:BBA4 A596            	   320:          LDA  token_value+2
00:BBA6 852A            	   321:          STA  OFFSET+1
00:BBA8 F001            	   322:          BEQ  VAL_3   ; is third byte 0x00?
00:BBAA 38              	   323:          SEC          ; no, set carry bit
                        	   324: VAL_3    =  *
00:BBAB 9007            	   325:          BCC  VAL_5   ; did we ever set the carry bit?
00:BBAD A900            	   326:          LDA  #PCODE_LIT  ; yes, so just generate a "load literal"
00:BBAF 207AC7          	   327:          JSR  GENADR
00:BBB2 68              	   328:          PLA
00:BBB3 60              	   329:          RTS
                        	   330: VAL_5    =  *
00:BBB4 A594            	   331:          LDA  token_value   ; get the low-order byte back
00:BBB6 0980            	   332:          ORA  #$80    ; set the 0x80 bit as a flag
00:BBB8 2061C7          	   333:          JSR  GENNOP  ; output one P-code
00:BBBB 68              	   334:          PLA
00:BBBC 60              	   335:          RTS
                        	   336: ;
                        	   337: ;
                        	   338: CHK_STAK =  *
00:BBBD BA              	   339:          TSX
00:BBBE 8A              	   340:          TXA
00:BBBF C920            	   341:          CMP  #MAX_STK
00:BBC1 9001            	   342:          BCC  STK_FULL
00:BBC3 60              	   343:          RTS
                        	   344: STK_FULL =  *
00:BBC4 A21B            	   345: STK_ERR  LDX  #27     ; ERROR: Stack full
00:BBC6 4CCE97          	   346:          jmp  ERROR      ; FULL
                        	   347: ;
                        	   348: ;
                        	   349: ; CONST get the value into token_value
                        	   350: ;
                        	   351: CONST    =  *
00:BBC9 A593            	   352:          LDA  token_type
00:BBCB C94E            	   353:          CMP  #TOKEN_NUMBER
00:BBCD F01F            	   354:          BEQ  CONST9
00:BBCF C949            	   355:          CMP  #TOKEN_IDENTIFIER
00:BBD1 F00D            	   356:          BEQ  CONST1
00:BBD3 C922            	   357:          CMP  #TOKEN_STRING
00:BBD5 D00E            	   358:          BNE  CONST3
00:BBD7 A692            	   359:          LDX  token_length
00:BBD9 E004            	   360:          CPX  #4
00:BBDB 9011            	   361:          BCC  CONST9
00:BBDD 4C71BD          	   362:          JMP  FACERR1    ; STRING TOO BIG
00:BBE0 2013B9          	   363: CONST1   JSR  SEARCH
00:BBE3 D005            	   364:          BNE  CONST2
                        	   365: CONST3   =  *
00:BBE5 A202            	   366:          LDX  #2        ; ERROR: Constant expected
00:BBE7 4CCE97          	   367:          jmp  ERROR
00:BBEA C943            	   368: CONST2   CMP  #SYMBOL_CONSTANT
00:BBEC D0F7            	   369:          BNE  CONST3
00:BBEE 60              	   370: CONST9   RTS
                        	   371: ;
                        	   372: ; VARIABLE DEC
                        	   373: ;
00:BBEF A949            	   374: VARDEC   LDA  #TOKEN_IDENTIFIER
00:BBF1 A204            	   375:          LDX  #4      ; ERROR: Identifier expected
00:BBF3 209FCF          	   376:          JSR  CHKTKN
00:BBF6 2036BA          	   377:          JSR  CHKDUP
00:BBF9 A956            	   378:          LDA  #SYMBOL_VARIABLE
00:BBFB 208FB9          	   379:          JSR  ADDSYM
00:BBFE 4C3BCF          	   380:          JMP  pas_get_token
                        	   381: ;
                        	   382: ; SIMPLE EXPRESSION
                        	   383: ;
                        	   384: SIMEXP   =  *
00:BC01 A593            	   385:          LDA  token_type
00:BC03 C92B            	   386:          CMP  #'+'
00:BC05 F004            	   387:          BEQ  SIM1
00:BC07 C92D            	   388:          CMP  #'-'
00:BC09 D048            	   389:          BNE  SIM2
00:BC0B 48              	   390: SIM1     PHA
00:BC0C 203BCF          	   391:          JSR  pas_get_token
00:BC0F 2073BC          	   392:          JSR  TERM
00:BC12 68              	   393:          PLA
00:BC13 C92D            	   394:          CMP  #'-'
00:BC15 D005            	   395:          BNE  SIM3
00:BC17 A902            	   396:          LDA  #PCODE_NEG      ; NEG       Negate (sp)
00:BC19 2061C7          	   397:          JSR  GENNOP     ; NEGATE
00:BC1C A593            	   398: SIM3     LDA  token_type
00:BC1E C92B            	   399:          CMP  #'+'
00:BC20 F00D            	   400:          BEQ  SIM4
00:BC22 C92D            	   401:          CMP  #'-'
00:BC24 F009            	   402:          BEQ  SIM4
00:BC26 C98A            	   403:          CMP  #TOKEN_OR       ; OR
00:BC28 F005            	   404:          BEQ  SIM4
00:BC2A C9A4            	   405:          CMP  #TOKEN_XOR      ; XOR
00:BC2C F001            	   406:          BEQ  SIM4
00:BC2E 60              	   407:          RTS
00:BC2F 48              	   408: SIM4     PHA
00:BC30 203BCF          	   409:          JSR  pas_get_token
00:BC33 2073BC          	   410:          JSR  TERM
00:BC36 68              	   411:          PLA
00:BC37 C92D            	   412:          CMP  #'-'
00:BC39 F010            	   413:          BEQ  SIM5
00:BC3B C92B            	   414:          CMP  #'+'
00:BC3D F010            	   415:          BEQ  SIM6
00:BC3F C9A4            	   416:          CMP  #TOKEN_XOR          ; XOR
00:BC41 F016            	   417:          BEQ  SIM8
00:BC43 A91A            	   418:          LDA  #PCODE_ORR          ; ORR       OR  (sp - 1) | (sp)
00:BC45 2061C7          	   419: SIM7     JSR  GENNOP
00:BC48 4C1CBC          	   420:          JMP  SIM3
00:BC4B A906            	   421: SIM5     LDA  #PCODE_SUB          ; MINUS
00:BC4D D0F6            	   422:          BNE  SIM7
00:BC4F A904            	   423: SIM6     LDA  #PCODE_ADD          ; PLUS
00:BC51 D0F2            	   424:          BNE  SIM7
00:BC53 2073BC          	   425: SIM2     JSR  TERM
00:BC56 4C1CBC          	   426:          JMP  SIM3
00:BC59 A93A            	   427: SIM8     LDA  #PCODE_XOR         ; XOR
00:BC5B D0E8            	   428:          BNE  SIM7
                        	   429: ;
                        	   430: ; TERM
                        	   431: ;
00:BC5D 2A              	   432: TERMT1   ASC    '*'
00:BC5E 80BC            	   433:          word   TERM1
00:BC60 8B              	   434:          DFB    TOKEN_DIV    ; div
00:BC61 80BC            	   435:          word   TERM1
00:BC63 2F              	   436:          ASC    '/'
00:BC64 80BC            	   437:          word   TERM1
00:BC66 8D              	   438:          DFB    TOKEN_AND    ; and
00:BC67 80BC            	   439:          word   TERM1
00:BC69 8C              	   440:          DFB    TOKEN_MOD    ; mod
00:BC6A 80BC            	   441:          word   TERM1
00:BC6C 8E              	   442:          DFB    TOKEN_SHL    ; shl
00:BC6D 80BC            	   443:          word   TERM1
00:BC6F 8F              	   444:          DFB    TOKEN_SHR    ; shr
00:BC70 80BC            	   445:          word   TERM1
00:BC72 00              	   446:          DFB    0
                        	   447: ;
00:BC73 20C1BC          	   448: TERM     JSR  FACTOR
00:BC76 A25D            	   449: TERM2    LDX  #<TERMT1
00:BC78 A0BC            	   450:          LDY  #>TERMT1
00:BC7A A593            	   451:          LDA  token_type
00:BC7C 20FC8F          	   452:          JSR  TKNJMP
00:BC7F 60              	   453:          RTS
                        	   454: ;
00:BC80 48              	   455: TERM1    PHA
00:BC81 203BCF          	   456:          JSR  pas_get_token
00:BC84 20C1BC          	   457:          JSR  FACTOR
00:BC87 68              	   458:          PLA
00:BC88 A2AB            	   459:          LDX  #<TERMT3
00:BC8A A0BC            	   460:          LDY  #>TERMT3
00:BC8C 20FC8F          	   461:          JSR  TKNJMP
                        	   462: ;
00:BC8F A90A            	   463: TERM4    LDA  #PCODE_DIV       ; Divide (sp - 1) / (sp)
00:BC91 2061C7          	   464: TERM3    JSR  GENNOP
00:BC94 4C76BC          	   465:          JMP  TERM2
00:BC97 A91B            	   466: TERM5    LDA  #PCODE_AND        ; AND
00:BC99 D0F6            	   467:          BNE  TERM3
00:BC9B A90B            	   468: TERM6    LDA  #PCODE_MOD        ; MOD
00:BC9D D0F2            	   469:          BNE  TERM3
00:BC9F A922            	   470: TERM7    LDA  #PCODE_SHL       ; Shift left (sp) bits
00:BCA1 D0EE            	   471:          BNE  TERM3
00:BCA3 A924            	   472: TERM8    LDA  #PCODE_SHR       ; Shift right (sp) bits
00:BCA5 D0EA            	   473:          BNE  TERM3
00:BCA7 A908            	   474: TERM9    LDA  #PCODE_MUL        ; Multiply (sp) * (sp - 1)
00:BCA9 D0E6            	   475:          BNE  TERM3
                        	   476: ;
00:BCAB 8B              	   477: TERMT3   DFB    TOKEN_DIV     ; div
00:BCAC 8FBC            	   478:          word   TERM4
00:BCAE 2F              	   479:          ASC    '/'
00:BCAF 8FBC            	   480:          word   TERM4
00:BCB1 8D              	   481:          DFB    TOKEN_AND     ; and
00:BCB2 97BC            	   482:          word   TERM5
00:BCB4 8C              	   483:          DFB    TOKEN_MOD     ; mod
00:BCB5 9BBC            	   484:          word   TERM6
00:BCB7 8E              	   485:          DFB    TOKEN_SHL     ; shl
00:BCB8 9FBC            	   486:          word   TERM7
00:BCBA 8F              	   487:          DFB    TOKEN_SHR     ; shr
00:BCBB A3BC            	   488:          word   TERM8
00:BCBD 2A              	   489:          ASC    '*'
00:BCBE A7BC            	   490:          word   TERM9
00:BCC0 00              	   491:          DFB  0
                        	   492: ;
                        	   493: ; FACTOR
                        	   494: ;
00:BCC1 20BDBB          	   495: FACTOR   JSR  CHK_STAK
00:BCC4 A593            	   496:          LDA  token_type
00:BCC6 A2A9            	   497:          LDX  #<FACTB1
00:BCC8 A0BD            	   498:          LDY  #>FACTB1
00:BCCA 20FC8F          	   499:          JSR  TKNJMP
00:BCCD A217            	   500:          LDX  #23     ; ERROR: Illegal factor
00:BCCF 4CCE97          	   501:          jmp  ERROR
                        	   502: ;
00:BCD2 202BBA          	   503: IDENT    JSR  LOOKUP
00:BCD5 C950            	   504: IDENT1   CMP  #SYMBOL_PROCEDURE
00:BCD7 F004            	   505:          beq  IDENT1A
00:BCD9 C951            	   506:          CMP  #SYMBOL_LIBRARY_PROCEDURE
00:BCDB D005            	   507:          BNE  IDENT2
                        	   508: IDENT1A:
00:BCDD A215            	   509:          LDX  #21     ; ERROR: Use of procedure Identifier in expression
00:BCDF 4CCE97          	   510:          jmp  ERROR
00:BCE2 C959            	   511: IDENT2   CMP  #SYMBOL_FUNCTION_RETURN
00:BCE4 D015            	   512:          BNE  IDENT2A
00:BCE6 A000            	   513:          LDY  #SYMPRV      ; this symbol is actually the function return value symbol
00:BCE8 B140            	   514:          LDA  (SYMITM),Y   ; so go to the previous symbol which will be the function
00:BCEA AA              	   515:          TAX               ; declaration symbol with the address of the function to be called
00:BCEB C8              	   516:          INY
00:BCEC B140            	   517:          LDA  (SYMITM),Y
00:BCEE 8541            	   518:          STA  SYMITM+1
00:BCF0 8A              	   519:          TXA
00:BCF1 8540            	   520:          STA  SYMITM
00:BCF3 A980            	   521:          lda  #$80       ; push 0 onto the stack which will be the default function return value
00:BCF5 2061C7          	   522:          jsr  GENNOP     ; when the function returns this will be left on the top of the stack
00:BCF8 4C42C0          	   523:          JMP  FNCPRC     ; with the function's assigned value in it (or zero if nothing assigned);
                        	   524: 
00:BCFB C952            	   525: IDENT2A  CMP #SYMBOL_LIBRARY_FUNCTION
00:BCFD D003            	   526:          bne IDENT3
00:BCFF 4C11C7          	   527:          jmp  library_function_call
                        	   528: 
00:BD02 C941            	   529: IDENT3   CMP  #SYMBOL_ARRAY
00:BD04 F030            	   530:          BEQ  IDENT4
00:BD06 C943            	   531:          CMP  #SYMBOL_CONSTANT
00:BD08 D00E            	   532:          BNE  IDENT5
00:BD0A 2094BB          	   533:          JSR  VAL_MOVE
00:BD0D 4C2BBD          	   534:          JMP  IDENT7
                        	   535: ;
                        	   536: ;   Here for address of integer variable
                        	   537: ;
00:BD10 A90C            	   538: FACAD1   LDA  #PCODE_ADRNN
00:BD12 201ABD          	   539:          JSR  IDENT5_A
00:BD15 4C9EBA          	   540:          JMP  CHKRHP
                        	   541: ;
00:BD18 A92C            	   542: IDENT5   LDA  #PCODE_LOD   ; load integer onto stack
00:BD1A 48              	   543: IDENT5_A PHA
                        	   544: ;
00:BD1B 8636            	   545:          STX  BSAVE
00:BD1D A522            	   546:          LDA  LEVEL
00:BD1F 38              	   547:          SEC
00:BD20 E536            	   548:          SBC  BSAVE
00:BD22 8527            	   549:          STA  DISPL
00:BD24 68              	   550:          PLA
00:BD25 18              	   551: IDENT6   CLC
00:BD26 654A            	   552:          ADC  DATTYP
00:BD28 207AC7          	   553:          JSR  GENADR
00:BD2B 4C3BCF          	   554: IDENT7   JMP  pas_get_token
                        	   555: ;
00:BD2E A90E            	   556: FACAD2   LDA  #PCODE_ADRAN  ; address of integer array
00:BD30 2038BD          	   557:          JSR  IDENT4_A
00:BD33 4C9EBA          	   558:          JMP  CHKRHP
                        	   559: ;
                        	   560: ;    Here for load indexed integer
                        	   561: ;
00:BD36 A930            	   562: IDENT4   LDA  #PCODE_LDI         ; Load integer indexed
00:BD38 48              	   563: IDENT4_A PHA
                        	   564: ;
00:BD39 2001BB          	   565:          JSR  SYMWRK
00:BD3C 20C992          	   566:          JSR  PSHWRK
00:BD3F 20A8BA          	   567:          JSR  GETSUB
00:BD42 20DC92          	   568:          JSR  PULWRK
00:BD45 200CBB          	   569:          JSR  WRKSYM
00:BD48 20CFBA          	   570:          JSR  GET_DAT
00:BD4B 20C5BA          	   571:          JSR  GET_LEV
00:BD4E 202ABB          	   572:          JSR  GET_OFF
00:BD51 68              	   573:          PLA
00:BD52 18              	   574:          CLC
00:BD53 654A            	   575:          ADC  DATTYP
00:BD55 4C7AC7          	   576:          JMP  GENADR
                        	   577: ;
                        	   578: ; ADDRESS (IDENTIFIER)
                        	   579: ;
                        	   580: ;
                        	   581: FACADR   =  *
00:BD58 2097BA          	   582:          JSR  CHKLHP
00:BD5B 20A4CF          	   583:          JSR  GET_LOOK
00:BD5E C956            	   584:          CMP  #SYMBOL_VARIABLE
00:BD60 F0AE            	   585:          BEQ  FACAD1
00:BD62 C941            	   586:          CMP  #SYMBOL_ARRAY
00:BD64 F0C8            	   587:          BEQ  FACAD2
00:BD66 A217            	   588:          LDX  #23     ; ERROR: Illegal factor
00:BD68 4CCE97          	   589:          jmp  ERROR
                        	   590: ;
                        	   591: ;
00:BD6B A592            	   592: FACSTR   LDA  token_length
00:BD6D C904            	   593:          CMP  #4
00:BD6F 9005            	   594:          BCC  FACNUM    ; BLT
00:BD71 A21D            	   595: FACERR1  LDX  #29        ; ERROR: string literal too big
00:BD73 4CCE97          	   596:          jmp  ERROR
                        	   597: FACNUM   =  *
00:BD76 2094BB          	   598:          JSR  VAL_MOVE
00:BD79 4C2BBD          	   599:          JMP  IDENT7
                        	   600: ;
00:BD7C 2055BB          	   601: PAREN    JSR  GETEXPR
00:BD7F 4C9EBA          	   602:          JMP  CHKRHP
                        	   603: ;
00:BD82 A900            	   604: FACMEM   LDA  #0          ; add zero below to get PCODE_LDA
00:BD84 854A            	   605:          STA  DATTYP
00:BD86 F004            	   606:          BEQ  FACM2
00:BD88 A901            	   607: FACMMC   LDA  #1          ; add one below to get PCODE_LDAC
00:BD8A 854A            	   608:          STA  DATTYP
00:BD8C A54A            	   609: FACM2    LDA  DATTYP
00:BD8E 48              	   610:          PHA
00:BD8F 20A8BA          	   611:          JSR  GETSUB
00:BD92 68              	   612:          PLA
00:BD93 18              	   613:          CLC
00:BD94 692E            	   614:          ADC  #PCODE_LDA    ; Load absolute address integer or PCODE_LDAC if we added 1
00:BD96 D008            	   615:          BNE  GENNOP1
                        	   616: ;
00:BD98 203BCF          	   617: FACNOT   JSR  pas_get_token
00:BD9B 20C1BC          	   618:          JSR  FACTOR
00:BD9E A920            	   619:          LDA  #PCODE_EOR     ; Not (sp) (logical negate)
00:BDA0 4C61C7          	   620: GENNOP1  JMP  GENNOP
                        	   621: ;
00:BDA3 2061C7          	   622: FACRND1  JSR  GENNOP
00:BDA6 4C3BCF          	   623:          JMP  pas_get_token
                        	   624: ;
                        	   625: ;
                        	   626: ;
00:BDA9 49              	   627: FACTB1   DFB    TOKEN_IDENTIFIER
00:BDAA D2BC            	   628:          word   IDENT
00:BDAC 4E              	   629:          ASC    TOKEN_NUMBER
00:BDAD 76BD            	   630:          word   FACNUM
00:BDAF 22              	   631: FACTQT1  DFB    TOKEN_STRING        ; QUOTE SYMBOL
00:BDB0 6BBD            	   632:          word   FACSTR
00:BDB2 28              	   633:          ASC    '('
00:BDB3 7CBD            	   634:          word   PAREN
00:BDB5 91              	   635:          DFB    TOKEN_MEM
00:BDB6 82BD            	   636:          word   FACMEM     ; MEM
00:BDB8 90              	   637:          DFB    TOKEN_NOT
00:BDB9 98BD            	   638:          word   FACNOT
00:BDBB A2              	   639:          DFB    TOKEN_MEMC
00:BDBC 88BD            	   640:          word   FACMMC     ; MEMC
00:BDBE A9              	   641:          DFB    TOKEN_ADDRESS
00:BDBF 58BD            	   642:          word   FACADR
00:BDC1 00              	   643:          DFB  0
                        	   644: ;
                        	   645: ; EXPRESSION
                        	   646: ;
00:BDC2 20BDBB          	   647: EXPRES   JSR  CHK_STAK
00:BDC5 2001BC          	   648:          JSR  SIMEXP
00:BDC8 A593            	   649:          LDA  token_type
00:BDCA A2D2            	   650:          LDX  #<EXPTB1
00:BDCC A0BD            	   651:          LDY  #>EXPTB1
00:BDCE 20FC8F          	   652:          JSR  TKNJMP
00:BDD1 60              	   653:          RTS
                        	   654: ;
00:BDD2 3D              	   655: EXPTB1   ASC    '='
00:BDD3 E5BD            	   656:          word   EXPR1
00:BDD5 55              	   657:          DFB    TOKEN_NEQ
00:BDD6 E5BD            	   658:          word   EXPR1
00:BDD8 3C              	   659:          ASC    '<'
00:BDD9 E5BD            	   660:          word   EXPR1
00:BDDB 80              	   661:          DFB    TOKEN_LEQ
00:BDDC E5BD            	   662:          word   EXPR1
00:BDDE 81              	   663:          DFB    TOKEN_GEQ
00:BDDF E5BD            	   664:          word   EXPR1
00:BDE1 3E              	   665:          ASC    '>'
00:BDE2 E5BD            	   666:          word   EXPR1
00:BDE4 00              	   667:          DFB  0
                        	   668: ;
00:BDE5 48              	   669: EXPR1    PHA
00:BDE6 203BCF          	   670:          JSR  pas_get_token
00:BDE9 2001BC          	   671:          JSR  SIMEXP
00:BDEC 68              	   672:          PLA
00:BDED A2F4            	   673:          LDX  #<EXPTB3
00:BDEF A0BD            	   674:          LDY  #>EXPTB3
00:BDF1 20FC8F          	   675:          JSR  TKNJMP
                        	   676: ;
00:BDF4 3D              	   677: EXPTB3   ASC    '='
00:BDF5 07BE            	   678:          word   EXPR2
00:BDF7 55              	   679:          ASC    TOKEN_NEQ
00:BDF8 0DBE            	   680:          word   EXPR3
00:BDFA 3C              	   681:          ASC    '<'
00:BDFB 11BE            	   682:          word   EXPR4
00:BDFD 81              	   683:          DFB    TOKEN_GEQ
00:BDFE 15BE            	   684:          word   EXPR5
00:BE00 3E              	   685:          ASC    '>'
00:BE01 19BE            	   686:          word   EXPR6
00:BE03 80              	   687:          DFB    TOKEN_LEQ
00:BE04 1DBE            	   688:          word   EXPR7
00:BE06 00              	   689:          DFB  0
                        	   690: ;
00:BE07 A910            	   691: EXPR2    LDA  #PCODE_EQL       ; EQL      Test (sp - 1) == (sp)
00:BE09 2061C7          	   692: EXPR8    JSR  GENNOP
00:BE0C 60              	   693:          RTS
00:BE0D A912            	   694: EXPR3    LDA  #PCODE_NEQ       ; NEQ      Test (sp - 1) != (sp)
00:BE0F D0F8            	   695:          BNE  EXPR8
00:BE11 A914            	   696: EXPR4    LDA  #PCODE_LSS       ; LSS      Test (sp - 1) < (sp)
00:BE13 D0F4            	   697:          BNE  EXPR8
00:BE15 A916            	   698: EXPR5    LDA  #PCODE_GEQ       ; GEQ      Test (sp - 1) >= (sp)
00:BE17 D0F0            	   699:          BNE  EXPR8
00:BE19 A918            	   700: EXPR6    LDA  #PCODE_GTR       ; GTR      Test (sp - 1) > (sp)
00:BE1B D0EC            	   701:          BNE  EXPR8
00:BE1D A919            	   702: EXPR7    LDA  #PCODE_LEQ       ; LEQ      Test (sp - 1) <= (sp)
00:BE1F D0E8            	   703:          BNE  EXPR8
                        	   704: ;
                        	   705: ; STATEMENT
                        	   706: ;
00:BE21 20BDBB          	   707: STMNT    JSR  CHK_STAK
00:BE24 A593            	   708:          LDA  token_type
00:BE26 A22E            	   709:          LDX  #<STMNT1
00:BE28 A0BE            	   710:          LDY  #>STMNT1
00:BE2A 20FC8F          	   711:          JSR  TKNJMP
00:BE2D 60              	   712:          RTS
                        	   713: ;
00:BE2E 49              	   714: STMNT1   DFB    TOKEN_IDENTIFIER
00:BE2F 59BE            	   715:          word   ASSIGN
00:BE31 92              	   716:          DFB    TOKEN_IF
00:BE32 C9C0            	   717:          word   IF
00:BE34 9A              	   718:          DFB    TOKEN_FOR
00:BE35 30C2            	   719:          word   FOR
00:BE37 96              	   720:          DFB    TOKEN_WHILE
00:BE38 43C1            	   721:          word   WHILE
00:BE3A 95              	   722:          DFB    TOKEN_CASE
00:BE3B 75C1            	   723:          word   CASE
00:BE3D 98              	   724:          DFB    TOKEN_REPEAT
00:BE3E 1FC1            	   725:          word   REPEAT
00:BE40 88              	   726:          DFB    TOKEN_BEGIN
00:BE41 09C1            	   727:          word   BEG
00:BE43 9E              	   728:          DFB    TOKEN_READ
00:BE44 71BF            	   729:          word   READ
00:BE46 9D              	   730:          DFB    TOKEN_WRITE
00:BE47 CFBE            	   731:          word   WRITE
00:BE49 91              	   732:          DFB    TOKEN_MEM
00:BE4A 1AC0            	   733:          word   MEM
00:BE4C 9F              	   734:          DFB    TOKEN_CALL
00:BE4D 35C0            	   735:          word   CALLSB
00:BE4F A2              	   736:          DFB    TOKEN_MEMC
00:BE50 1FC0            	   737:          word   MEMC
00:BE52 FF              	   738:          DFB    TOKEN_WRITELN
00:BE53 C0BE            	   739:          word   WRITELN
00:BE55 F1              	   740:          DB     TOKEN_LCDWRITE
00:BE56 20BF            	   741:          word   STMNT_WRITE_LCD
00:BE58 00              	   742:          DFB  0
                        	   743: ;
                        	   744: ; ASSIGNMENT - this is where we store an integer/char into a variable or array index
                        	   745: ;
00:BE59 202BBA          	   746: ASSIGN   JSR  LOOKUP
00:BE5C A268            	   747: ASS1     LDX  #<ASSTB1
00:BE5E A0BE            	   748:          LDY  #>ASSTB1
00:BE60 20FC8F          	   749:          JSR  TKNJMP
00:BE63 A218            	   750:          LDX  #24     ; ERROR: Type mismatch
00:BE65 4CCE97          	   751:          jmp  ERROR
                        	   752: ;
00:BE68 41              	   753: ASSTB1   DFB   SYMBOL_ARRAY
00:BE69 83BE            	   754:          word  ASSARR
00:BE6B 56              	   755:          DFB   SYMBOL_VARIABLE
00:BE6C 95BE            	   756:          word  ASSVAR
00:BE6E 59              	   757:          DFB   SYMBOL_FUNCTION_RETURN
00:BE6F 95BE            	   758:          word  ASSVAR
00:BE71 50              	   759:          DFB   SYMBOL_PROCEDURE
00:BE72 42C0            	   760:          word  FNCPRC
00:BE74 51              	   761:          DFB   SYMBOL_LIBRARY_PROCEDURE
00:BE75 11C7            	   762:          word  library_function_call
00:BE77 46              	   763:          DFB   SYMBOL_FUNCTION
00:BE78 7EBE            	   764:          word  assign_bad_identifier
00:BE7A 52              	   765:          DFB   SYMBOL_LIBRARY_FUNCTION
00:BE7B 7EBE            	   766:          word  assign_bad_identifier
00:BE7D 00              	   767:          DFB  0
                        	   768: 
                        	   769: assign_bad_identifier:
00:BE7E A235            	   770:           ldx #53   ; ERROR: Use of function identifier in statement
00:BE80 4CCE97          	   771:           jmp ERROR
                        	   772: ;
00:BE83 2001BB          	   773: ASSARR   JSR  SYMWRK
00:BE86 20C992          	   774:          JSR  PSHWRK
00:BE89 A936            	   775:          LDA  #PCODE_STI    ; Store integer indexed
00:BE8B 18              	   776:          CLC
00:BE8C 654A            	   777:          ADC  DATTYP        ; A becomes PCODE_STIC (Store character indexed) if DATTYP == 1
00:BE8E 48              	   778:          PHA
00:BE8F 20A8BA          	   779:          JSR  GETSUB
00:BE92 4CA4BE          	   780:          JMP  ASS2
                        	   781: ;
00:BE95 2001BB          	   782: ASSVAR   JSR  SYMWRK
00:BE98 20C992          	   783:          JSR  PSHWRK
00:BE9B A932            	   784:          LDA  #PCODE_STO    ;  Store integer
00:BE9D 18              	   785:          CLC
00:BE9E 654A            	   786:          ADC  DATTYP        ; A becomes PCODE_STOC (Store character indexed) if DATTYP == 1
00:BEA0 48              	   787:          PHA
00:BEA1 203BCF          	   788:          JSR  pas_get_token
00:BEA4 A941            	   789: ASS2     LDA  #TOKEN_ASSIGN
00:BEA6 A20D            	   790:          LDX  #13       ; ERROR: := expected
00:BEA8 209FCF          	   791:          JSR  CHKTKN
00:BEAB 2055BB          	   792:          JSR  GETEXPR
00:BEAE 68              	   793:          PLA
00:BEAF 20DC92          	   794:          JSR  PULWRK
00:BEB2 200CBB          	   795:          JSR  WRKSYM
00:BEB5 48              	   796:          PHA
00:BEB6 20C5BA          	   797:          JSR  GET_LEV
00:BEB9 202ABB          	   798:          JSR  GET_OFF
00:BEBC 68              	   799:          PLA
00:BEBD 4C7AC7          	   800:          JMP  GENADR
                        	   801: ;
                        	   802: 
                        	   803: ;
                        	   804: ;
                        	   805: ; WRITELN
                        	   806: ;
00:BEC0 203BCF          	   807: WRITELN  JSR  pas_get_token     ; SEE IF ( PRESENT
00:BEC3 C928            	   808:          CMP  #'('
00:BEC5 D003            	   809:          BNE  WRITELN9   ; NOPE
00:BEC7 20D2BE          	   810:          JSR  WRIT9
                        	   811: WRITELN9 =  *
00:BECA A940            	   812:          LDA  #PCODE_OUTCR   ; OUTPUT C/R
00:BECC 4C61C7          	   813:          JMP  GENNOP
                        	   814: ;
                        	   815: ;
                        	   816: ; WRITE
                        	   817: ;
00:BECF 2097BA          	   818: WRITE    JSR  CHKLHP
00:BED2 203BCF          	   819: WRIT9    JSR  pas_get_token
00:BED5 C922            	   820:          CMP  #TOKEN_STRING
00:BED7 D022            	   821:          BNE  WRIT1
00:BED9 A923            	   822:          LDA  #PCODE_OUS    ; Output string
00:BEDB 20E1BE          	   823:          JSR  W_STRING
00:BEDE 4C0BBF          	   824:          JMP  WRIT5
                        	   825: ;
                        	   826: W_STRING =  *
00:BEE1 2061C7          	   827:          JSR  GENNOP
00:BEE4 A592            	   828:          LDA  token_length
00:BEE6 2061C7          	   829:          JSR  GENNOP
00:BEE9 A000            	   830:          LDY  #0
00:BEEB B90002          	   831: WRIT2    LDA  INBUF,Y
00:BEEE C8              	   832: WRIT10   INY
00:BEEF 5A              	   833:          phy
00:BEF0 2061C7          	   834:          JSR  GENNOP
00:BEF3 7A              	   835:          ply
00:BEF4 C692            	   836:          DEC  token_length
00:BEF6 D0F3            	   837:          BNE  WRIT2
00:BEF8 4C3BCF          	   838:          JMP  pas_get_token
                        	   839: ;
                        	   840: WRIT1    =  *          ; here if not string
00:BEFB C9AB            	   841:          CMP  #TOKEN_CHR       ; CHR?
00:BEFD F015            	   842:          BEQ  W_CHR      ; yes
00:BEFF C9AC            	   843:          CMP  #TOKEN_HEX       ; HEX?
00:BF01 F019            	   844:          BEQ  W_HEX      ; yes
00:BF03 20C2BD          	   845:          JSR  EXPRES     ; just ordinary number - get it
00:BF06 A91E            	   846:          LDA  #PCODE_OUT        ; OUT       Output number
00:BF08 2061C7          	   847:          JSR  GENNOP
00:BF0B A593            	   848: WRIT5    LDA  token_type
00:BF0D C92C            	   849:          CMP  #','
00:BF0F F0C1            	   850:          BEQ  WRIT9
00:BF11 4C9EBA          	   851:          JMP  CHKRHP
                        	   852: ;
                        	   853: ; here for write (chr(x))
                        	   854: ;
                        	   855: W_CHR    =  *
00:BF14 A91F            	   856:          LDA  #PCODE_OUTC   ; OUTC      Output character
                        	   857: W_CHR1   =  *
00:BF16 2010C0          	   858:          JSR  WAIT_1     ; process expression in parentheses
00:BF19 4C0BBF          	   859:          JMP  WRIT5      ; back for next item
                        	   860: ;
                        	   861: ; here for write (hex(x))
                        	   862: ;
                        	   863: W_HEX    =  *
00:BF1C A921            	   864:          LDA  #PCODE_OUH        ; OUH       Output hex number
00:BF1E D0F6            	   865:          BNE  W_CHR1
                        	   866: 
                        	   867: ;
                        	   868: ;
                        	   869: ; WRITELCD: can write number, string, hex or chr
                        	   870: ;
00:BF20 2097BA          	   871: STMNT_WRITE_LCD    JSR  CHKLHP
00:BF23 203BCF          	   872: WRITE_LCD9    JSR  pas_get_token
00:BF26 C922            	   873:          CMP  #TOKEN_STRING
00:BF28 D022            	   874:          BNE  WRITE_LCD1
00:BF2A A943            	   875:          LDA  #PCODE_LCD_WRITE_STR    ; Output string
00:BF2C 2032BF          	   876:          JSR  WRITE_LCD_STRING
00:BF2F 4C5CBF          	   877:          JMP  WRITE_LCD5
                        	   878: ;
                        	   879: WRITE_LCD_STRING =  *
00:BF32 2061C7          	   880:          JSR  GENNOP
00:BF35 A592            	   881:          LDA  token_length
00:BF37 2061C7          	   882:          JSR  GENNOP
00:BF3A A000            	   883:          LDY  #0
00:BF3C B90002          	   884: WRITE_LCD2    LDA  INBUF,Y    ; strings are placed in INBUF during parsing
00:BF3F C8              	   885:          INY
00:BF40 5A              	   886:          phy
00:BF41 2061C7          	   887:          JSR  GENNOP
00:BF44 7A              	   888:          ply
00:BF45 C692            	   889:          DEC  token_length
00:BF47 D0F3            	   890:          BNE  WRITE_LCD2
00:BF49 4C3BCF          	   891:          JMP  pas_get_token
                        	   892: ;
                        	   893: WRITE_LCD1    =  *            ; here if not string
00:BF4C C9AB            	   894:          CMP  #TOKEN_CHR      ; CHR?
00:BF4E F015            	   895:          BEQ  WRITE_LDC_CHR   ; yes
00:BF50 C9AC            	   896:          CMP  #TOKEN_HEX      ; HEX?
00:BF52 F019            	   897:          BEQ  WRITE_LDC_HEX   ; yes
00:BF54 20C2BD          	   898:          JSR  EXPRES          ; just ordinary number - get it
00:BF57 A942            	   899:          LDA  #PCODE_LCD_WRITE_NUM        ; OUT       Output number
00:BF59 2061C7          	   900:          JSR  GENNOP
00:BF5C A593            	   901: WRITE_LCD5    LDA  token_type
00:BF5E C92C            	   902:          CMP  #','
00:BF60 F0C1            	   903:          BEQ  WRITE_LCD9
00:BF62 4C9EBA          	   904:          JMP  CHKRHP
                        	   905: ;
                        	   906: ; here for lcdwrite (chr(x))
                        	   907: ;
                        	   908: WRITE_LDC_CHR    =  *
00:BF65 A945            	   909:          LDA  #PCODE_LCD_WRITE_CHR   ; OUTC     Output character
                        	   910: WRITE_LDC_CHR1   =  *
00:BF67 2010C0          	   911:          JSR  WAIT_1          ; process expression in parentheses
00:BF6A 4C5CBF          	   912:          JMP  WRITE_LCD5      ; back for next item
                        	   913: ;
                        	   914: ; here for lcdwrite (hex(x))
                        	   915: ;
                        	   916: WRITE_LDC_HEX    =  *
00:BF6D A944            	   917:          LDA  #PCODE_LCD_WRITE_HEX        ; OUH       Output hex number
00:BF6F D0F6            	   918:          BNE  WRITE_LDC_CHR1
                        	   919: 
                        	   920: ;
                        	   921: ;
                        	   922: ; READ
                        	   923: ;
00:BF71 2097BA          	   924: READ     jsr  CHKLHP    ; check for "("
00:BF74 20A4CF          	   925: READ8    jsr  GET_LOOK
00:BF77 2001BB          	   926: READ2    jsr  SYMWRK      ; SYMITM --> WORK
00:BF7A 20C992          	   927:          jsr  PSHWRK
00:BF7D A200            	   928:          ldx  #0
00:BF7F 864B            	   929:          stx  COUNT1      ; this will have 1 in it if we are reading into an array element
00:BF81 C941            	   930:          cmp  #SYMBOL_ARRAY
00:BF83 F03B            	   931:          beq  READ3
00:BF85 C956            	   932:          cmp  #SYMBOL_VARIABLE
00:BF87 F005            	   933:          beq  READ9
00:BF89 A20C            	   934:          ldx  #12     ; ERROR: Illegal Identifier
00:BF8B 4CCE97          	   935:          jmp  ERROR
                        	   936: 
00:BF8E 208DC9          	   937: READ9    jsr get_token
00:BF91 A91C            	   938: READ11   lda  #PCODE_INP  ; Input number
00:BF93 18              	   939:          clc
00:BF94 654A            	   940:          adc  DATTYP      ; becomes PCODE_INPC (input character) if DATTYP == 1
00:BF96 2061C7          	   941:          jsr  GENNOP
00:BF99 20DC92          	   942:          jsr  PULWRK
00:BF9C 200CBB          	   943:          jsr  WRKSYM      ; WORK --> SYMITM
00:BF9F 20CFBA          	   944:          jsr  GET_DAT
00:BFA2 20C5BA          	   945:          jsr  GET_LEV
00:BFA5 202ABB          	   946:          jsr  GET_OFF
00:BFA8 A932            	   947:          lda  #PCODE_STO    ; Store integer
00:BFAA A64B            	   948:          ldx  COUNT1
00:BFAC F002            	   949:          beq  READ7
00:BFAE A936            	   950:          lda  #PCODE_STI    ; Store integer indexed
00:BFB0 18              	   951: READ7    clc
00:BFB1 654A            	   952:          adc  DATTYP        ; add 1 if a char to become PCODE_STOC / PCODE_STIC
00:BFB3 207AC7          	   953:          jsr  GENADR
00:BFB6 A593            	   954: READ7_A  lda  token_type
00:BFB8 C92C            	   955:          cmp  #','
00:BFBA F0B8            	   956:          beq  READ8         ; get another variable to read into
                        	   957: ;
                        	   958: ;  done with READ statement
                        	   959: ;
00:BFBC 209EBA          	   960:          jsr  CHKRHP        ; check for ")"
00:BFBF 60              	   961:          rts
                        	   962: ;
                        	   963: ;  here for reading into an array
                        	   964: ;
00:BFC0 A54A            	   965: READ3    lda  DATTYP
00:BFC2 48              	   966:          pha              ; push data type of array
00:BFC3 203BCF          	   967:          jsr  pas_get_token
00:BFC6 C95B            	   968:          cmp  #'['
00:BFC8 F025            	   969:          beq  READ3_A
00:BFCA 68              	   970:          pla            ; get back data type of array
00:BFCB 854A            	   971:          sta  DATTYP    ; 0 = integer, 1 = char
00:BFCD D005            	   972:          bne  READ3_B
00:BFCF A218            	   973:          ldx  #24       ; ERROR: Type mismatch (cannot read into array of integer)
00:BFD1 4CCE97          	   974:          jmp  ERROR
00:BFD4 20DC92          	   975: READ3_B  jsr  PULWRK
00:BFD7 200CBB          	   976:          jsr  WRKSYM     ; WORK --> SYMITM
00:BFDA A925            	   977:          lda  #PCODE_INS        ; READ STRING - Input string into array
00:BFDC 2061C7          	   978:          jsr  GENNOP
00:BFDF 20C5BA          	   979:          jsr  GET_LEV
00:BFE2 202ABB          	   980:          jsr  GET_OFF
00:BFE5 A006            	   981:          ldy  #SYMSUB
00:BFE7 B140            	   982:          lda  (SYMITM),Y  ; maximum array size
00:BFE9 207AC7          	   983:          jsr  GENADR     ; A = length, not the P-code which we just output above
00:BFEC 4CB6BF          	   984:          jmp  READ7_A
                        	   985: ;
                        	   986: ;  read into subscripted item
                        	   987: ;
00:BFEF 2055BB          	   988: READ3_A  jsr  GETEXPR   ; subscript
00:BFF2 20BBBA          	   989:          jsr  CHKRHB    ; check for "]"
00:BFF5 E64B            	   990:          inc  COUNT1    ; flag for reading into array element
00:BFF7 68              	   991:          pla            ; get back data type of array
00:BFF8 854A            	   992:          sta  DATTYP    ; save
00:BFFA 4C91BF          	   993:          jmp  READ11
                        	   994: ;
                        	   995: 
                        	   996: ;
                        	   997: ;
00:BFFD 2097BA          	   998: TWO_OP   JSR  CHKLHP
00:C000 2055BB          	   999:          JSR  GETEXPR
00:C003 208EBB          	  1000: ONE_OP2  JSR  GET_ITEM
00:C006 209EBA          	  1001: ONE_OP   JSR  CHKRHP
00:C009 68              	  1002:          PLA
00:C00A 4C61C7          	  1003:          JMP  GENNOP
                        	  1004: 
                        	  1005: 
                        	  1006: 
00:C00D 4C61C7          	  1007: GENNOP2  JMP  GENNOP
                        	  1008: ;
                        	  1009: 
00:C010 48              	  1010: WAIT_1   PHA
00:C011 2097BA          	  1011:          JSR  CHKLHP
00:C014 2055BB          	  1012:          JSR  GETEXPR
00:C017 4C06C0          	  1013:          JMP  ONE_OP
                        	  1014: ;
                        	  1015: ; MEM
                        	  1016: ;
00:C01A A900            	  1017: MEM      LDA  #0        ; integer
00:C01C 48              	  1018:          PHA
00:C01D F003            	  1019:          BEQ  MEM2
00:C01F A901            	  1020: MEMC     LDA  #1        ; character
00:C021 48              	  1021:          PHA
00:C022 20A8BA          	  1022: MEM2     JSR  GETSUB
00:C025 A941            	  1023:          LDA  #TOKEN_ASSIGN
00:C027 A20D            	  1024:          LDX  #13     ; ERROR: := expected
00:C029 209FCF          	  1025:          JSR  CHKTKN
00:C02C 2055BB          	  1026:          JSR  GETEXPR
00:C02F 68              	  1027:          PLA
00:C030 18              	  1028:          CLC
00:C031 6934            	  1029:          ADC  #PCODE_STA     ; Store integer absolute address (or PCODE_STAC if A == 1)
00:C033 D0D8            	  1030:          BNE  GENNOP2
                        	  1031: ;
                        	  1032: ; CALL ABSOLUTE ADDRESS
                        	  1033: ;
00:C035 2097BA          	  1034: CALLSB   JSR  CHKLHP
00:C038 2055BB          	  1035:          JSR  GETEXPR
00:C03B 209EBA          	  1036:          JSR  CHKRHP
00:C03E A92B            	  1037:          LDA  #PCODE_CLA    ; Call absolute address
00:C040 D0CB            	  1038:          BNE  GENNOP2
                        	  1039: ;
                        	  1040: ; FUNCTION OR PROCEDURE CALL
                        	  1041: ;
00:C042 A900            	  1042: FNCPRC   LDA  #0
00:C044 854B            	  1043:          STA  COUNT1      ; number of arguments
00:C046 A006            	  1044:          LDY  #SYMARG
00:C048 B140            	  1045:          LDA  (SYMITM),Y
00:C04A F033            	  1046:          BEQ  FNC1
00:C04C 2097BA          	  1047:          JSR  CHKLHP
00:C04F A54B            	  1048: FNC2     LDA  COUNT1    ; save on stack in case the expression calls functions
00:C051 48              	  1049:          PHA
00:C052 2001BB          	  1050:          JSR  SYMWRK
00:C055 20C992          	  1051:          JSR  PSHWRK
00:C058 2055BB          	  1052:          JSR  GETEXPR
00:C05B 20DC92          	  1053:          JSR  PULWRK
00:C05E 200CBB          	  1054:          JSR  WRKSYM
00:C061 68              	  1055:          PLA            ; get number of arguments back
00:C062 854B            	  1056:          STA  COUNT1
00:C064 E64B            	  1057:          INC  COUNT1    ; add 1 for the one we just processed
00:C066 A593            	  1058:          LDA  token_type
00:C068 C92C            	  1059:          CMP  #','
00:C06A F0E3            	  1060:          BEQ  FNC2
00:C06C A54B            	  1061:          LDA  COUNT1
00:C06E A006            	  1062:          LDY  #SYMARG
00:C070 D140            	  1063:          CMP  (SYMITM),Y   ; check we got the right number of arguments
00:C072 F005            	  1064:          BEQ  FNC3
00:C074 A223            	  1065:          LDX  #35     ; ERROR: Parameters mismatched
00:C076 4CCE97          	  1066:          jmp  ERROR
00:C079 209EBA          	  1067: FNC3     JSR  CHKRHP
00:C07C 4C82C0          	  1068:          JMP  FNC5
00:C07F 203BCF          	  1069: FNC1     JSR  pas_get_token
00:C082 20C5BA          	  1070: FNC5     JSR  GET_LEV
00:C085 202ABB          	  1071:          JSR  GET_OFF
00:C088 A008            	  1072:          LDY  #SYMDAT
00:C08A B140            	  1073:          LDA  (SYMITM),Y
00:C08C D011            	  1074:          BNE  FNC5A
00:C08E A529            	  1075:          LDA  OFFSET
00:C090 38              	  1076:          SEC
00:C091 E523            	  1077:          SBC  PCODE         ; calculate relative procedure address
00:C093 8529            	  1078:          STA  OFFSET
00:C095 A52A            	  1079:          LDA  OFFSET+1
00:C097 E524            	  1080:          SBC  PCODE+1
00:C099 852A            	  1081:          STA  OFFSET+1
00:C09B A927            	  1082:          LDA  #PCODE_CLL         ; Relative procedure/function call
00:C09D D002            	  1083:          BNE  FNC5B
00:C09F A938            	  1084: FNC5A    LDA  #PCODE_ABSCLL      ; Absolute procedure/function call
00:C0A1 207AC7          	  1085: FNC5B    JSR  GENADR
00:C0A4 A54B            	  1086:          LDA  COUNT1    ; number of arguments
00:C0A6 F01B            	  1087:          BEQ  FNC4
00:C0A8 A54B            	  1088:          LDA  COUNT1     ; TIMES 3
00:C0AA 0A              	  1089:          ASL             ; multiply by two then add one more COUNT1
00:C0AB B017            	  1090:          BCS  FNC6
00:C0AD 654B            	  1091:          ADC  COUNT1
00:C0AF 854B            	  1092:          STA  COUNT1
00:C0B1 B011            	  1093:          BCS  FNC6
00:C0B3 A900            	  1094:          LDA  #0
00:C0B5 38              	  1095:          SEC
00:C0B6 E54B            	  1096:          SBC  COUNT1
00:C0B8 852B            	  1097:          STA  OPND
00:C0BA A9FF            	  1098:          LDA  #$FF
00:C0BC 852C            	  1099:          STA  OPND+1      ;  calculate: 0 - (number_of_arguments * 3)
00:C0BE A93B            	  1100:          LDA  #PCODE_INT     ; Increment stack pointer (allow for arguments)
00:C0C0 20EAC7          	  1101:          JSR  GENJMP
00:C0C3 60              	  1102: FNC4     RTS
00:C0C4 A20F            	  1103: FNC6     LDX  #15       ; ERROR: compiler limits exceeded
00:C0C6 4CCE97          	  1104:          jmp  ERROR
                        	  1105: ;
                        	  1106: ;
                        	  1107: ; IF
                        	  1108: ;
00:C0C9 2055BB          	  1109: IF       JSR  GETEXPR
00:C0CC A993            	  1110:          LDA  #TOKEN_THEN
00:C0CE A210            	  1111:          LDX  #16     ; ERROR: THEN expected
00:C0D0 209FCF          	  1112:          JSR  CHKTKN
00:C0D3 203BCF          	  1113:          JSR  pas_get_token
00:C0D6 2017BB          	  1114:          JSR  PSHPCODE
00:C0D9 A93D            	  1115:          LDA  #PCODE_JMZ     ; JMZ      Jump if (sp) zero
00:C0DB 20E4C7          	  1116:          JSR  GENNJM
00:C0DE 2021BE          	  1117:          JSR  STMNT
00:C0E1 A593            	  1118:          LDA  token_type
00:C0E3 C994            	  1119:          CMP  #TOKEN_ELSE       ; ELSE
00:C0E5 F007            	  1120:          BEQ  IF1
00:C0E7 20DC92          	  1121: IF2      JSR  PULWRK
00:C0EA 2018C8          	  1122:          JSR  FIXAD
00:C0ED 60              	  1123:          RTS
00:C0EE 20DC92          	  1124: IF1      JSR  PULWRK     ; HERE FOR ELSE
00:C0F1 207CBB          	  1125:          JSR  WRK_WRKD
00:C0F4 2017BB          	  1126:          JSR  PSHPCODE
00:C0F7 20E2C7          	  1127:          JSR  GENNJP
00:C0FA 2071BB          	  1128:          JSR  WRKD_WRK
00:C0FD 2018C8          	  1129:          JSR  FIXAD
00:C100 203BCF          	  1130:          JSR  pas_get_token
00:C103 2021BE          	  1131:          JSR  STMNT
00:C106 4CE7C0          	  1132:          JMP  IF2
                        	  1133: ;
                        	  1134: ; BEGIN
                        	  1135: ;
00:C109 203BCF          	  1136: BEG      JSR  pas_get_token
00:C10C 2021BE          	  1137:          JSR  STMNT
00:C10F A593            	  1138:          LDA  token_type
00:C111 C93B            	  1139:          CMP  #';'
00:C113 F0F4            	  1140:          BEQ  BEG
00:C115 A989            	  1141:          LDA  #TOKEN_END       ; END
00:C117 A211            	  1142:          LDX  #17         ; ERROR: ; or END expected
00:C119 209FCF          	  1143:          JSR  CHKTKN
00:C11C 4C3BCF          	  1144:          JMP  pas_get_token
                        	  1145: ;
                        	  1146: ; REPEAT
                        	  1147: ;
00:C11F 2017BB          	  1148: REPEAT   JSR  PSHPCODE
00:C122 203BCF          	  1149: REP1     JSR  pas_get_token
00:C125 2021BE          	  1150:          JSR  STMNT
00:C128 A593            	  1151:          LDA  token_type
00:C12A C93B            	  1152:          CMP  #';'
00:C12C F0F4            	  1153:          BEQ  REP1
00:C12E A999            	  1154:          LDA  #TOKEN_UNTIL
00:C130 A20A            	  1155:          LDX  #10           ; ERROR: ; expected
00:C132 209FCF          	  1156:          JSR  CHKTKN
00:C135 2055BB          	  1157:          JSR  GETEXPR
00:C138 20DC92          	  1158:          JSR  PULWRK
00:C13B 2066BB          	  1159:          JSR  WRK_OPND
00:C13E A93D            	  1160:          LDA  #PCODE_JMZ         ; JMZ      Jump if (sp) zero
00:C140 4CD0C7          	  1161:          JMP  GENRJMP
                        	  1162: ;
                        	  1163: ; WHILE
                        	  1164: ;
00:C143 2017BB          	  1165: WHILE    JSR  PSHPCODE
00:C146 2055BB          	  1166:          JSR  GETEXPR
00:C149 2017BB          	  1167:          JSR  PSHPCODE
00:C14C A93D            	  1168:          LDA  #PCODE_JMZ       ; JMZ      Jump if (sp) zero
00:C14E 20E4C7          	  1169:          JSR  GENNJM
00:C151 A997            	  1170:          LDA  #TOKEN_DO
00:C153 A212            	  1171:          LDX  #18             ; ERROR: DO expected
00:C155 209FCF          	  1172:          JSR  CHKTKN
00:C158 203BCF          	  1173:          JSR  pas_get_token
00:C15B 2021BE          	  1174:          JSR  STMNT
00:C15E 20DC92          	  1175:          JSR  PULWRK
00:C161 207CBB          	  1176:          JSR  WRK_WRKD
00:C164 20DC92          	  1177:          JSR  PULWRK
00:C167 2066BB          	  1178:          JSR  WRK_OPND
00:C16A A93C            	  1179:          LDA  #PCODE_JMP     ; JMP      Jump unconditionally
00:C16C 20D0C7          	  1180:          JSR  GENRJMP
00:C16F 2071BB          	  1181:          JSR  WRKD_WRK
00:C172 4C18C8          	  1182:          JMP  FIXAD
                        	  1183: ;
                        	  1184: ; CASE
                        	  1185: ;
00:C175 2055BB          	  1186: CASE     JSR  GETEXPR
00:C178 A985            	  1187:          LDA  #TOKEN_OF       ; OF
00:C17A A21A            	  1188:          LDX  #26         ; ERROR: "of " expected
00:C17C 209FCF          	  1189:          JSR  CHKTKN
00:C17F A901            	  1190:          LDA  #1
00:C181 854B            	  1191:          STA  COUNT1
00:C183 A900            	  1192: CASE7    LDA  #0
00:C185 854C            	  1193:          STA  COUNT2
                        	  1194: CASE2    =  *
00:C187 A92A            	  1195:          LDA  #PCODE_MOV  ; make copy of selector:  MOV       Copy (sp) to (sp + 1)
00:C189 2061C7          	  1196:          JSR  GENNOP
00:C18C 2055BB          	  1197:          JSR  GETEXPR    ; next expression to compare
00:C18F A910            	  1198:          LDA  #PCODE_EQL       ;  EQL       Test (sp - 1) == (sp)
00:C191 2061C7          	  1199:          JSR  GENNOP
00:C194 A593            	  1200:          LDA  token_type
00:C196 C93A            	  1201:          CMP  #':'
00:C198 F014            	  1202:          BEQ  CASE1
00:C19A A92C            	  1203:          LDA  #','
00:C19C A205            	  1204:          LDX  #5      ; ERROR: , or : expected
00:C19E 209FCF          	  1205:          JSR  CHKTKN
00:C1A1 2017BB          	  1206:          JSR  PSHPCODE
00:C1A4 A93E            	  1207:          LDA  #PCODE_JM1     ; JM1      Jump if (sp) not zero
00:C1A6 20E4C7          	  1208:          JSR  GENNJM
00:C1A9 E64C            	  1209:          INC  COUNT2
00:C1AB 4C87C1          	  1210:          JMP  CASE2
00:C1AE 205BBB          	  1211: CASE1    JSR  PCD_WRKD
00:C1B1 A93D            	  1212:          LDA  #PCODE_JMZ     ; JMZ      Jump if (sp) zero
00:C1B3 20E4C7          	  1213:          JSR  GENNJM
00:C1B6 A54C            	  1214:          LDA  COUNT2
00:C1B8 F00A            	  1215:          BEQ  CASE3
00:C1BA 20DC92          	  1216: CASE4    JSR  PULWRK
00:C1BD 2018C8          	  1217:          JSR  FIXAD
00:C1C0 C64C            	  1218:          DEC  COUNT2
00:C1C2 D0F6            	  1219:          BNE  CASE4
00:C1C4 2071BB          	  1220: CASE3    JSR  WRKD_WRK
00:C1C7 20C992          	  1221:          JSR  PSHWRK
00:C1CA 203BCF          	  1222:          JSR  pas_get_token
00:C1CD A54B            	  1223:          LDA  COUNT1
00:C1CF 48              	  1224:          PHA
00:C1D0 2021BE          	  1225:          JSR  STMNT
00:C1D3 68              	  1226:          PLA
00:C1D4 854B            	  1227:          STA  COUNT1
00:C1D6 A593            	  1228:          LDA  token_type
00:C1D8 C994            	  1229:          CMP  #TOKEN_ELSE       ; ELSE
00:C1DA F01B            	  1230:          BEQ  CASE5
00:C1DC C93B            	  1231:          CMP  #';'
00:C1DE D035            	  1232:          BNE  CASE6
00:C1E0 205BBB          	  1233:          JSR  PCD_WRKD
00:C1E3 20E2C7          	  1234:          JSR  GENNJP
00:C1E6 20DC92          	  1235:          JSR  PULWRK
00:C1E9 2018C8          	  1236:          JSR  FIXAD
00:C1EC 2071BB          	  1237:          JSR  WRKD_WRK
00:C1EF 20C992          	  1238:          JSR  PSHWRK
00:C1F2 E64B            	  1239:          INC  COUNT1
00:C1F4 4C83C1          	  1240:          JMP  CASE7
00:C1F7 205BBB          	  1241: CASE5    JSR  PCD_WRKD
00:C1FA 20E2C7          	  1242:          JSR  GENNJP
00:C1FD 20DC92          	  1243:          JSR  PULWRK
00:C200 2018C8          	  1244:          JSR  FIXAD
00:C203 2071BB          	  1245:          JSR  WRKD_WRK
00:C206 20C992          	  1246:          JSR  PSHWRK
00:C209 203BCF          	  1247:          JSR  pas_get_token
00:C20C A54B            	  1248:          LDA  COUNT1
00:C20E 48              	  1249:          PHA
00:C20F 2021BE          	  1250:          JSR  STMNT
00:C212 68              	  1251:          PLA
00:C213 854B            	  1252:          STA  COUNT1
00:C215 A989            	  1253: CASE6    LDA  #TOKEN_END       ; END
00:C217 A211            	  1254:          LDX  #17         ; ERROR: ; or END expected
00:C219 209FCF          	  1255:          JSR  CHKTKN
00:C21C A54B            	  1256:          LDA  COUNT1
00:C21E F00A            	  1257:          BEQ  CASE8
00:C220 20DC92          	  1258: CASE9    JSR  PULWRK
00:C223 2018C8          	  1259:          JSR  FIXAD
00:C226 C64B            	  1260:          DEC  COUNT1
00:C228 D0F6            	  1261:          BNE  CASE9
00:C22A 20F6C2          	  1262: CASE8    JSR  FOR6
00:C22D 4C3BCF          	  1263:          JMP  pas_get_token
                        	  1264: ;
                        	  1265: ; FOR
                        	  1266: ;
00:C230 A949            	  1267: FOR      LDA  #TOKEN_IDENTIFIER
00:C232 A204            	  1268:          LDX  #4      ; ERROR:  Identifier expected
00:C234 208FCF          	  1269:          JSR  GETCHK
00:C237 202BBA          	  1270:          JSR  LOOKUP
00:C23A C956            	  1271: FOR1     CMP  #SYMBOL_VARIABLE
00:C23C F009            	  1272:          BEQ  FOR2
00:C23E C959            	  1273:          CMP  #SYMBOL_FUNCTION_RETURN
00:C240 F005            	  1274:          BEQ  FOR2
00:C242 A20C            	  1275:          LDX  #12   ; ERROR: Illegal Identifier
00:C244 4CCE97          	  1276:          jmp  ERROR
00:C247 2095BE          	  1277: FOR2     JSR  ASSVAR
00:C24A 2001BB          	  1278:          JSR  SYMWRK
00:C24D A900            	  1279:          LDA  #0
00:C24F 854B            	  1280:          STA  COUNT1
00:C251 A593            	  1281:          LDA  token_type
00:C253 C99B            	  1282:          CMP  #TOKEN_TO       ; TO
00:C255 F009            	  1283:          BEQ  FOR3
00:C257 A99C            	  1284:          LDA  #TOKEN_DOWNTO       ; DOWNTO
00:C259 A21C            	  1285:          LDX  #28       ; ERROR: TO or DOWNTO expected
00:C25B 209FCF          	  1286:          JSR  CHKTKN
00:C25E C64B            	  1287:          DEC  COUNT1
00:C260 A54B            	  1288: FOR3     LDA  COUNT1
00:C262 48              	  1289:          PHA
00:C263 20C992          	  1290:          JSR  PSHWRK
00:C266 2055BB          	  1291:          JSR  GETEXPR
00:C269 20DC92          	  1292:          JSR  PULWRK
00:C26C 200CBB          	  1293:          JSR  WRKSYM
00:C26F 68              	  1294:          PLA
00:C270 854B            	  1295:          STA  COUNT1
00:C272 2017BB          	  1296:          JSR  PSHPCODE
00:C275 A92A            	  1297:          LDA  #PCODE_MOV     ; MOV      Copy (sp) to (sp + 1)
00:C277 2061C7          	  1298:          JSR  GENNOP
00:C27A 20C5BA          	  1299:          JSR  GET_LEV
00:C27D 202ABB          	  1300:          JSR  GET_OFF
00:C280 20CFBA          	  1301:          JSR  GET_DAT
00:C283 18              	  1302:          CLC
00:C284 692C            	  1303:          ADC  #PCODE_LOD  ; Load integer onto stack or PCODE_LODC if a char
00:C286 207AC7          	  1304:          JSR  GENADR
00:C289 A916            	  1305:          LDA  #PCODE_GEQ        ; UP (GEQ): GEQ       Test (sp - 1) >= (sp)
00:C28B A64B            	  1306:          LDX  COUNT1
00:C28D F002            	  1307:          BEQ  FOR4
00:C28F A919            	  1308:          LDA  #PCODE_LEQ        ; DOWN (LEQ): LEQ       Test (sp - 1) <= (sp)
00:C291 2061C7          	  1309: FOR4     JSR  GENNOP
00:C294 2017BB          	  1310:          JSR  PSHPCODE
00:C297 A93D            	  1311:          LDA  #PCODE_JMZ       ;  JMZ       Jump if (sp) zero
00:C299 20E4C7          	  1312:          JSR  GENNJM
00:C29C A54B            	  1313:          LDA  COUNT1
00:C29E 48              	  1314:          PHA
00:C29F 2001BB          	  1315:          JSR  SYMWRK
00:C2A2 20C992          	  1316:          JSR  PSHWRK
00:C2A5 A997            	  1317:          LDA  #TOKEN_DO
00:C2A7 A212            	  1318:          LDX  #18       ; ERROR: DO expected
00:C2A9 209FCF          	  1319:          JSR  CHKTKN
00:C2AC 203BCF          	  1320:          JSR  pas_get_token
00:C2AF 2021BE          	  1321:          JSR  STMNT
00:C2B2 20DC92          	  1322:          JSR  PULWRK
00:C2B5 200CBB          	  1323:          JSR  WRKSYM
00:C2B8 20C5BA          	  1324:          JSR  GET_LEV
00:C2BB 20CFBA          	  1325:          JSR  GET_DAT
00:C2BE 202ABB          	  1326:          JSR  GET_OFF
00:C2C1 A54A            	  1327:          LDA  DATTYP
00:C2C3 18              	  1328:          CLC
00:C2C4 692C            	  1329:          ADC  #PCODE_LOD       ; LOD      Load integer onto stack
00:C2C6 207AC7          	  1330:          JSR  GENADR
00:C2C9 68              	  1331:          PLA
00:C2CA 854B            	  1332:          STA  COUNT1
00:C2CC A926            	  1333:          LDA  #PCODE_INC     ; INC      Increment (sp) by 1
00:C2CE A64B            	  1334:          LDX  COUNT1
00:C2D0 F002            	  1335:          BEQ  FOR5
00:C2D2 A928            	  1336:          LDA  #PCODE_DEC        ; DEC       Decrement (sp) by 1
00:C2D4 2061C7          	  1337: FOR5     JSR  GENNOP
00:C2D7 A932            	  1338:          LDA  #PCODE_STO       ; STO      Store integer
00:C2D9 18              	  1339:          CLC
00:C2DA 654A            	  1340:          ADC  DATTYP          ; may become PCODE_STOC if a char
00:C2DC 207AC7          	  1341:          JSR  GENADR
00:C2DF 20DC92          	  1342:          JSR  PULWRK
00:C2E2 207CBB          	  1343:          JSR  WRK_WRKD
00:C2E5 20DC92          	  1344:          JSR  PULWRK
00:C2E8 2066BB          	  1345:          JSR  WRK_OPND
00:C2EB A93C            	  1346:          LDA  #PCODE_JMP       ; JMP      Jump unconditionally
00:C2ED 20D0C7          	  1347:          JSR  GENRJMP
00:C2F0 2071BB          	  1348:          JSR  WRKD_WRK
00:C2F3 2018C8          	  1349:          JSR  FIXAD
00:C2F6 A9FF            	  1350: FOR6     LDA  #$FF
00:C2F8 852C            	  1351:          STA  OPND+1
00:C2FA A9FD            	  1352:          LDA  #$FD
00:C2FC 852B            	  1353:          STA  OPND
00:C2FE A93B            	  1354:          LDA  #PCODE_INT       ;  INT       Increment stack pointer
00:C300 4CEAC7          	  1355:          JMP  GENJMP
                        	  1356: 
                        	  1357: 
                        	  1358: ;***********************************************
                        	  1359: ; MORE OF THE COMPILER (PROCESSING A 'BLOCK')
                        	  1360: ;***********************************************
                        	  1361: 
                        	  1362: CHKGET   =  *
00:C303 209FCF          	  1363:          JSR  CHKTKN
00:C306 4C3BCF          	  1364:          JMP  pas_get_token
                        	  1365: ;
                        	  1366: ;  copy WORK to token_value
                        	  1367: ;
                        	  1368: WRK_VAL  =  *
00:C309 48              	  1369:          PHA
00:C30A A537            	  1370:          LDA  WORK
00:C30C 8594            	  1371:          STA  token_value
00:C30E A538            	  1372:          LDA  WORK+1
00:C310 8595            	  1373:          STA  token_value+1
00:C312 68              	  1374:          PLA
00:C313 60              	  1375:          RTS
                        	  1376: ;
                        	  1377: ;  copy VALUE to WORK
                        	  1378: ;
                        	  1379: VAL_WRK  =  *
00:C314 48              	  1380:          PHA
00:C315 A594            	  1381:          LDA  token_value
00:C317 8537            	  1382:          STA  WORK
00:C319 A595            	  1383:          LDA  token_value+1
00:C31B 8538            	  1384:          STA  WORK+1
00:C31D 68              	  1385:          PLA
00:C31E 60              	  1386:          RTS
                        	  1387: ;
                        	  1388: ;  copy ENDSYM to WORK
                        	  1389: ;
                        	  1390: END_WRK  =  *
00:C31F 48              	  1391:          PHA
00:C320 A531            	  1392:          LDA  ENDSYM
00:C322 8537            	  1393:          STA  WORK
00:C324 A532            	  1394:          LDA  ENDSYM+1
00:C326 8538            	  1395:          STA  WORK+1
00:C328 68              	  1396:          PLA
00:C329 60              	  1397:          RTS
                        	  1398: ;
                        	  1399: ;***********************************************
                        	  1400: ;
                        	  1401: ;
                        	  1402: ; BLOCK
                        	  1403: ;
00:C32A 82              	  1404: BLCKT1   DFB  TOKEN_CONST
00:C32B 81C3            	  1405:          word BLKCNS
00:C32D 83              	  1406: BLCKT2   DFB  TOKEN_VAR
00:C32E 98C3            	  1407:          word BLKVAR
00:C330 86              	  1408: BLCKT3   DFB  TOKEN_PROCEDURE
00:C331 D5C4            	  1409:          word BLKPRC
00:C333 87              	  1410:          DFB  TOKEN_FUNCTION
00:C334 F5C4            	  1411:          word BLKFNC
00:C336 88              	  1412:          DFB  TOKEN_BEGIN
00:C337 BDC5            	  1413:          word BLKBEG
00:C339 00              	  1414:          DFB  0
                        	  1415: ;
                        	  1416: ;
00:C33A 20BDBB          	  1417: BLOCK    JSR  CHK_STAK
00:C33D A900            	  1418:          LDA  #0
00:C33F 8521            	  1419:          STA  FRAME+1
00:C341 A906            	  1420:          LDA  #6
00:C343 8520            	  1421:          STA  FRAME
00:C345 A539            	  1422:          LDA  PRCITM
00:C347 8537            	  1423:          STA  WORK
00:C349 A63A            	  1424:          LDX  PRCITM+1
00:C34B 8638            	  1425:          STX  WORK+1
00:C34D 053A            	  1426:          ORA  PRCITM+1
00:C34F F014            	  1427:          BEQ  BLK1
                        	  1428: 
                        	  1429: ;
00:C351 A004            	  1430: BLK1A    LDY  #SYMDSP
00:C353 A523            	  1431:          LDA  PCODE
00:C355 9137            	  1432:          STA  (WORK),Y
00:C357 C8              	  1433:          INY
00:C358 A524            	  1434:          LDA  PCODE+1
00:C35A 9137            	  1435:          STA  (WORK),Y
00:C35C A900            	  1436:          LDA  #0
00:C35E A008            	  1437:          LDY  #SYMDAT
00:C360 9137            	  1438:          STA  (WORK),Y   ; FLAG RELATIVE PROCEDURE
00:C362 4C6DC3          	  1439:          JMP  BLK2
00:C365 A523            	  1440: BLK1     LDA  PCODE
00:C367 8537            	  1441:          STA  WORK
00:C369 A524            	  1442:          LDA  PCODE+1
00:C36B 8538            	  1443:          STA  WORK+1
00:C36D 20C992          	  1444: BLK2     JSR  PSHWRK
00:C370 20E2C7          	  1445:          JSR  GENNJP
00:C373 A22A            	  1446:          LDX  #<BLCKT1
00:C375 A0C3            	  1447:          LDY  #>BLCKT1
00:C377 A593            	  1448: BLK4     LDA  token_type
00:C379 20FC8F          	  1449:          JSR  TKNJMP
00:C37C A219            	  1450:          LDX  #25       ; ERROR: BEGIN expected
00:C37E 4CCE97          	  1451:          jmp  ERROR
                        	  1452: ;
                        	  1453: ;
                        	  1454: ; CONSTANT
                        	  1455: ;
00:C381 203BCF          	  1456: BLKCNS   JSR  pas_get_token
00:C384 20D6BA          	  1457: BLKCN1   JSR  CONDEC
00:C387 A93B            	  1458:          LDA  #';'
00:C389 A20A            	  1459:          LDX  #10       ; ERROR: ; expected
00:C38B 2003C3          	  1460:          JSR  CHKGET
00:C38E A22D            	  1461:          LDX  #<BLCKT2
00:C390 A0C3            	  1462:          LDY  #>BLCKT2
00:C392 20FC8F          	  1463:          JSR  TKNJMP
00:C395 4C84C3          	  1464:          JMP  BLKCN1
                        	  1465: ;
                        	  1466: ; VARIABLE
                        	  1467: ;
00:C398 A900            	  1468: BLKVAR   LDA  #0
00:C39A 854B            	  1469:          STA  COUNT1
00:C39C 203BCF          	  1470: BLKVR1   JSR  pas_get_token
00:C39F 20EFBB          	  1471: BLKVR6   JSR  VARDEC    ; check we have an identifier, add it to the symbol table, get another token
00:C3A2 E64B            	  1472:          INC  COUNT1    ; how many variables in this declaration
00:C3A4 1003            	  1473:          BPL  BLKVR7
00:C3A6 4C16C4          	  1474:          JMP  BLKV13     ; ERROR  - compiler limits exceeded (more than 127 variables?)
00:C3A9 A593            	  1475: BLKVR7   LDA  token_type
00:C3AB C92C            	  1476:          CMP  #','
00:C3AD F0ED            	  1477:          BEQ  BLKVR1    ; back for another
00:C3AF A93A            	  1478:          LDA  #':'
00:C3B1 A205            	  1479:          LDX  #5        ; ERROR: , or : expected
00:C3B3 2003C3          	  1480:          JSR  CHKGET
00:C3B6 C984            	  1481:          CMP  #TOKEN_ARRAY   ; ARRAY
00:C3B8 F043            	  1482:          BEQ  BLKVR2
00:C3BA C9FE            	  1483:          CMP  #TOKEN_INTEGER ; INTEGER
00:C3BC F00A            	  1484:          BEQ  BLKVR8
00:C3BE A9A1            	  1485:          LDA  #TOKEN_CHAR    ; CHAR
00:C3C0 A224            	  1486:          LDX  #36            ; ERROR: Data Type not recognised
00:C3C2 209FCF          	  1487:          JSR  CHKTKN
00:C3C5 4CBDC4          	  1488:          JMP  BLKVR3
                        	  1489: 
                        	  1490: ;
                        	  1491: ;  integer variable
                        	  1492: ;
00:C3C8 2062C4          	  1493: BLKVR8   JSR  BLKVR9  ; subtract COUNT1 from FRAME, put WORK into VALUE, put ENDSYM into WORK
                        	  1494: BLKV10   = *
00:C3CB A008            	  1495:          LDY  #SYMDAT
00:C3CD A900            	  1496:          LDA  #0         ; INTEGER TYPE
00:C3CF 9137            	  1497:          STA  (WORK),Y
00:C3D1 A520            	  1498:          LDA  FRAME
00:C3D3 A004            	  1499:          LDY  #SYMDSP
00:C3D5 9137            	  1500:          STA  (WORK),Y
00:C3D7 C8              	  1501:          INY
00:C3D8 A521            	  1502:          LDA  FRAME+1
00:C3DA 9137            	  1503:          STA  (WORK),Y
00:C3DC 18              	  1504:          CLC
00:C3DD A520            	  1505:          LDA  FRAME
00:C3DF 6903            	  1506:          ADC  #3
00:C3E1 8520            	  1507:          STA  FRAME
00:C3E3 9002            	  1508:          BCC  BLKV10_A
00:C3E5 E621            	  1509:          INC  FRAME+1
                        	  1510: BLKV10_A =  *
00:C3E7 C64B            	  1511:          DEC  COUNT1
00:C3E9 D003            	  1512:          BNE  BLKV10_B
00:C3EB 4CBDC4          	  1513:          JMP  BLKVR3
                        	  1514: 
                        	  1515: BLKV10_B = *
                        	  1516: ;
                        	  1517: ;  more in the list, go to the previous symbol
                        	  1518: ;
00:C3EE A000            	  1519:          LDY  #SYMPRV
00:C3F0 B137            	  1520:          LDA  (WORK),Y
00:C3F2 AA              	  1521:          TAX
00:C3F3 C8              	  1522:          INY
00:C3F4 B137            	  1523:          LDA  (WORK),Y
00:C3F6 8538            	  1524:          STA  WORK+1
00:C3F8 8A              	  1525:          TXA
00:C3F9 8537            	  1526:          STA  WORK       ; PREVIOUS ITEM
00:C3FB 80CE            	  1527:          BRA  BLKV10
                        	  1528: 
                        	  1529: ;
                        	  1530: ; ARRAY [ N ] OF ...
                        	  1531: ;
00:C3FD 20B1BA          	  1532: BLKVR2   JSR  CHKLHB
00:C400 20C9BB          	  1533:          JSR  CONST     ; get how many are in the array
00:C403 A596            	  1534:          LDA  token_value+2   ; can't be more than 65536
00:C405 D00F            	  1535:          BNE  BLKV13
00:C407 A594            	  1536:          LDA  token_value     ; add 1 to the count since array [3] of char means 4 elements
00:C409 18              	  1537:          CLC
00:C40A 6901            	  1538:          ADC  #1
00:C40C 8594            	  1539:          STA  token_value
00:C40E A595            	  1540:          LDA  token_value+1
00:C410 3004            	  1541:          BMI  BLKV13
00:C412 6900            	  1542:          ADC  #0
00:C414 1005            	  1543:          BPL  BLKVR4
00:C416 A20F            	  1544: BLKV13   LDX  #15       ; ERROR: compiler limits exceeded
00:C418 4CCE97          	  1545:          jmp  ERROR
00:C41B 8595            	  1546: BLKVR4   STA  token_value+1
00:C41D 2014C3          	  1547:          JSR  VAL_WRK   ; put the value (array count) in WORK
00:C420 203BCF          	  1548:          JSR  pas_get_token
00:C423 20BBBA          	  1549:          JSR  CHKRHB
00:C426 A901            	  1550:          LDA  #1        ; char
00:C428 854A            	  1551:          STA  DATTYP
00:C42A A985            	  1552:          LDA  #TOKEN_OF  ; OF
00:C42C A21A            	  1553:          LDX  #26        ; ERROR: "of " expected
00:C42E 2003C3          	  1554:          JSR  CHKGET
00:C431 C9FE            	  1555:          CMP  #TOKEN_INTEGER  ; INTEGER
00:C433 D020            	  1556:          BNE  BLKV11
00:C435 C64A            	  1557:          DEC  DATTYP    ; DATTYP of 0 is integer, and 1 is char
00:C437 2009C3          	  1558:          JSR  WRK_VAL   ; get the array count back into token_value
                        	  1559: ;
                        	  1560: ; MULTIPLY token_value BY 3
                        	  1561: ;
00:C43A A594            	  1562:          LDA  token_value
00:C43C A695            	  1563:          LDX  token_value+1
00:C43E 0694            	  1564:          ASL  token_value
00:C440 2695            	  1565:          ROL  token_value+1
00:C442 B0D2            	  1566:          BCS  BLKV13
00:C444 6594            	  1567:          ADC  token_value
00:C446 8594            	  1568:          STA  token_value
00:C448 8A              	  1569:          TXA
00:C449 6595            	  1570:          ADC  token_value+1
00:C44B B0C9            	  1571:          BCS  BLKV13
00:C44D 8595            	  1572:          STA  token_value+1
00:C44F 2014C3          	  1573:          JSR  VAL_WRK     ; put the array count (times 3) back into WORK
00:C452 4C5CC4          	  1574:          JMP  BLKV12
                        	  1575:  ;
                        	  1576:  ;  here for array of char
                        	  1577:  ;
00:C455 A9A1            	  1578: BLKV11   LDA  #TOKEN_CHAR       ; CHAR
00:C457 A224            	  1579:          LDX  #36           ; ERROR: Data Type not recognised
00:C459 209FCF          	  1580:          JSR  CHKTKN
00:C45C 2062C4          	  1581: BLKV12   JSR  BLKVR9        ; we are COUNT1 frames back
00:C45F 4C7BC4          	  1582:          JMP  BLKVR5
                        	  1583: 
                        	  1584: BLKVR9   =  *
00:C462 A520            	  1585:          LDA  FRAME         ; subtract COUNT1 (the variable position) from the frame number
00:C464 38              	  1586:          SEC
00:C465 E54B            	  1587:          SBC  COUNT1
00:C467 8520            	  1588:          STA  FRAME
00:C469 A521            	  1589:          LDA  FRAME+1
00:C46B E900            	  1590:          SBC  #0
00:C46D 8521            	  1591:          STA  FRAME+1
00:C46F 2009C3          	  1592:          JSR  WRK_VAL     ; copy WORK to VALUE (array count, possibly multiplied by 3)
00:C472 A531            	  1593:          LDA  ENDSYM      ; end of symbol table into WORK
00:C474 8537            	  1594:          STA  WORK
00:C476 A532            	  1595:          LDA  ENDSYM+1
00:C478 8538            	  1596:          STA  WORK+1
00:C47A 60              	  1597:          RTS
                        	  1598: 
                        	  1599: ;
                        	  1600: ;  we should be here with ENDSYM in WORK (for walking back through the symbol table for all the variables we just decla
                        	  1601: ;  COUNT1 will be the number of symbols we have to fix up
                        	  1602: ;
                        	  1603: BLKVR5   = *
00:C47B A003            	  1604:          ldy  #SYMTYP
00:C47D A941            	  1605:          lda  #SYMBOL_ARRAY
00:C47F 9137            	  1606:          sta  (WORK),Y    ; make symbol type array
00:C481 A004            	  1607:          ldy  #SYMDSP
00:C483 A520            	  1608:          lda  FRAME       ; FRAME is the displacement
00:C485 9137            	  1609:          sta  (WORK),Y
00:C487 C8              	  1610:          iny
00:C488 A521            	  1611:          lda  FRAME+1
00:C48A 9137            	  1612:          sta  (WORK),Y
00:C48C A594            	  1613:          lda  token_value       ; array count (multiplied by 3 in the case of integers)
00:C48E 18              	  1614:          clc
00:C48F 6520            	  1615:          adc  FRAME       ; add to the stack frame address
00:C491 8520            	  1616:          sta  FRAME
00:C493 A595            	  1617:          lda  token_value+1
00:C495 6521            	  1618:          adc  FRAME+1
00:C497 8521            	  1619:          sta  FRAME+1
00:C499 A008            	  1620:          ldy  #SYMDAT
00:C49B A54A            	  1621:          lda  DATTYP       ; save the data type in the symbol
00:C49D 9137            	  1622:          sta  (WORK),Y
00:C49F A006            	  1623:          ldy  #SYMSUB
00:C4A1 A594            	  1624:          lda  token_value        ; max subscript + 1
00:C4A3 9137            	  1625:          sta  (WORK),Y
00:C4A5 A595            	  1626:          lda  token_value+1
00:C4A7 C8              	  1627:          iny
00:C4A8 9137            	  1628:          sta  (WORK),Y
00:C4AA C64B            	  1629:          dec  COUNT1
00:C4AC F00F            	  1630:          beq  BLKVR3
                        	  1631: ;
                        	  1632: ;  onto the previous symbol
                        	  1633: ;
00:C4AE A000            	  1634:          ldy  #SYMPRV
00:C4B0 B137            	  1635:          lda  (WORK),Y
00:C4B2 AA              	  1636:          tax
00:C4B3 C8              	  1637:          iny
00:C4B4 B137            	  1638:          lda  (WORK),Y
00:C4B6 8538            	  1639:          sta  WORK+1
00:C4B8 8A              	  1640:          txa
00:C4B9 8537            	  1641:          sta  WORK       ; PREVIOUS ITEM
00:C4BB 80BE            	  1642:          bra  BLKVR5
                        	  1643: ;
                        	  1644: ;  here at end of variable declaration (after INTEGER / CHAR)
                        	  1645: ;
00:C4BD A93B            	  1646: BLKVR3   LDA  #';'
00:C4BF A20A            	  1647:          LDX  #10       ; ERROR: ; expected
00:C4C1 208FCF          	  1648:          JSR  GETCHK
00:C4C4 203BCF          	  1649:          JSR  pas_get_token
00:C4C7 A230            	  1650:          LDX  #<BLCKT3  ; now look for procedure / function / begin
00:C4C9 A0C3            	  1651:          LDY  #>BLCKT3
00:C4CB 20FC8F          	  1652:          JSR  TKNJMP    ; if not there, look for another variable declaration
00:C4CE A900            	  1653:          LDA  #0        ; zero variables in this list so far
00:C4D0 854B            	  1654:          STA  COUNT1
00:C4D2 4C9FC3          	  1655:          JMP  BLKVR6
                        	  1656: ;
                        	  1657: ; PROCEDURE DECLARATION
                        	  1658: ;
00:C4D5 A949            	  1659: BLKPRC   LDA  #'I'
00:C4D7 A204            	  1660:          LDX  #4         ; ERROR: Identifier expected
00:C4D9 208FCF          	  1661:          JSR  GETCHK
00:C4DC A900            	  1662:          LDA  #0
00:C4DE 854B            	  1663:          STA  COUNT1    ; no function return value
00:C4E0 2036BA          	  1664:          JSR  CHKDUP
00:C4E3 A950            	  1665:          LDA  #SYMBOL_PROCEDURE
00:C4E5 208FB9          	  1666:          JSR  ADDSYM
00:C4E8 E622            	  1667:          INC  LEVEL
00:C4EA A540            	  1668:          LDA  SYMITM
00:C4EC 8539            	  1669:          STA  PRCITM    ; PRCITM is the symbol of the procedure/function
00:C4EE A541            	  1670:          LDA  SYMITM+1
00:C4F0 853A            	  1671:          STA  PRCITM+1
00:C4F2 4C17C5          	  1672:          JMP  BLKPR1
                        	  1673: ;
                        	  1674: ; FUNCTION DECLARATION
                        	  1675: ;
00:C4F5 A949            	  1676: BLKFNC   LDA  #TOKEN_IDENTIFIER
00:C4F7 A204            	  1677:          LDX  #4      ; ERROR: Identifier expected
00:C4F9 208FCF          	  1678:          JSR  GETCHK
00:C4FC 2036BA          	  1679:          JSR  CHKDUP
00:C4FF A946            	  1680:          LDA  #SYMBOL_FUNCTION
00:C501 208FB9          	  1681:          JSR  ADDSYM
00:C504 E622            	  1682:          INC  LEVEL
00:C506 A901            	  1683:          LDA  #1
00:C508 854B            	  1684:          STA  COUNT1    ; we have the function return as a symbol
00:C50A A540            	  1685:          LDA  SYMITM
00:C50C 8539            	  1686:          STA  PRCITM   ; PRCITM is the symbol of the procedure/function
00:C50E A541            	  1687:          LDA  SYMITM+1
00:C510 853A            	  1688:          STA  PRCITM+1
00:C512 A959            	  1689:          LDA  #SYMBOL_FUNCTION_RETURN ; for assigning the results to
00:C514 208FB9          	  1690:          JSR  ADDSYM
                        	  1691: ;
                        	  1692: ; PROCEDURE AND FUNCTION COMMON CODE
                        	  1693: ;
00:C517 A54B            	  1694: BLKPR1   LDA  COUNT1
00:C519 854C            	  1695:          STA  COUNT2    ; remember if we had 0 or 1 extra symbols (function return)
00:C51B 201FC3          	  1696:          JSR  END_WRK
00:C51E 20C992          	  1697:          JSR  PSHWRK
00:C521 A520            	  1698:          LDA  FRAME
00:C523 8537            	  1699:          STA  WORK
00:C525 A521            	  1700:          LDA  FRAME+1
00:C527 8538            	  1701:          STA  WORK+1
00:C529 20C992          	  1702:          JSR  PSHWRK
00:C52C 203BCF          	  1703:          JSR  pas_get_token
00:C52F C928            	  1704:          CMP  #'('      ; opening bracket after procedure/function name?
00:C531 D016            	  1705:          BNE  BLKPR2
00:C533 203BCF          	  1706: BLKPR3   JSR  pas_get_token
00:C536 20EFBB          	  1707:          JSR  VARDEC
00:C539 E64B            	  1708:          INC  COUNT1    ; count arguments
00:C53B 1003            	  1709:          BPL  BLKPR6
00:C53D 4C16C4          	  1710:          JMP  BLKV13
00:C540 A593            	  1711: BLKPR6   LDA  token_type
00:C542 C92C            	  1712:          CMP  #','
00:C544 F0ED            	  1713:          BEQ  BLKPR3
00:C546 209EBA          	  1714:          JSR  CHKRHP
00:C549 A539            	  1715: BLKPR2   LDA  PRCITM      ; here after argument list, if any
00:C54B 8537            	  1716:          STA  WORK
00:C54D A53A            	  1717:          LDA  PRCITM+1
00:C54F 8538            	  1718:          STA  WORK+1
00:C551 A006            	  1719:          LDY  #SYMARG
00:C553 A54B            	  1720:          LDA  COUNT1
00:C555 38              	  1721:          SEC
00:C556 E54C            	  1722:          SBC  COUNT2      ; subtract 0 or 1 depending on if this is a function or not
00:C558 9137            	  1723:          STA  (WORK),Y    ; store the number of arguments to this procedure/function
00:C55A A93B            	  1724:          LDA  #';'
00:C55C A20A            	  1725:          LDX  #10         ; ERROR: ; expected
00:C55E 209FCF          	  1726:          JSR  CHKTKN
00:C561 A54B            	  1727:          LDA  COUNT1
00:C563 F02C            	  1728:          BEQ  BLKPR4
00:C565 201FC3          	  1729:          JSR  END_WRK     ; ENDSYM -> WORK
00:C568 A2FD            	  1730:          LDX  #$FD        ; X = -3
                        	  1731: ; WORK starts off pointing to the procedure/function symbol
                        	  1732: BLKPR5   = *
00:C56A A008            	  1733:          LDY  #SYMDAT
00:C56C A900            	  1734:          LDA  #0
00:C56E 9137            	  1735:          STA  (WORK),Y    ; data type = integer
00:C570 A004            	  1736:          LDY  #SYMDSP
00:C572 8A              	  1737:          TXA
00:C573 9137            	  1738:          STA  (WORK),Y
00:C575 38              	  1739:          SEC
00:C576 E903            	  1740:          SBC  #3
00:C578 AA              	  1741:          TAX
00:C579 A9FF            	  1742:          LDA  #$FF
00:C57B C8              	  1743:          INY
00:C57C 9137            	  1744:          STA  (WORK),Y
00:C57E C64B            	  1745:          DEC  COUNT1
00:C580 F00F            	  1746:          beq  BLKPR4
                        	  1747: ;
                        	  1748: ;  back to previous symbol
                        	  1749: ;
00:C582 A000            	  1750:          LDY  #SYMPRV
00:C584 B137            	  1751:          LDA  (WORK),Y
00:C586 48              	  1752:          PHA
00:C587 C8              	  1753:          INY
00:C588 B137            	  1754:          LDA  (WORK),Y
00:C58A 8538            	  1755:          STA  WORK+1
00:C58C 68              	  1756:          PLA
00:C58D 8537            	  1757:          STA  WORK
00:C58F 80D9            	  1758:          bra  BLKPR5
00:C591 203BCF          	  1759: BLKPR4   JSR  pas_get_token
00:C594 203AC3          	  1760:          JSR  BLOCK
00:C597 C622            	  1761:          DEC  LEVEL
00:C599 20DC92          	  1762:          JSR  PULWRK
00:C59C A537            	  1763:          LDA  WORK
00:C59E 8520            	  1764:          STA  FRAME
00:C5A0 A538            	  1765:          LDA  WORK+1
00:C5A2 8521            	  1766:          STA  FRAME+1
00:C5A4 20DC92          	  1767:          JSR  PULWRK
00:C5A7 A537            	  1768:          LDA  WORK
00:C5A9 8531            	  1769:          STA  ENDSYM
00:C5AB A538            	  1770:          LDA  WORK+1
00:C5AD 8532            	  1771:          STA  ENDSYM+1
00:C5AF A93B            	  1772:          LDA  #';'
00:C5B1 A20A            	  1773:          LDX  #10       ; ERROR: ; expected
00:C5B3 2003C3          	  1774:          JSR  CHKGET
00:C5B6 A230            	  1775:          LDX  #<BLCKT3
00:C5B8 A0C3            	  1776:          LDY  #>BLCKT3
00:C5BA 4C77C3          	  1777:          JMP  BLK4
                        	  1778: ;
                        	  1779: ; BEGIN (COMPOUND STATEMENT)
                        	  1780: ;
00:C5BD 203BCF          	  1781: BLKBEG   JSR  pas_get_token
00:C5C0 20DC92          	  1782:          JSR  PULWRK
00:C5C3 A522            	  1783:          LDA  LEVEL
00:C5C5 D006            	  1784:          BNE  BLKB1
00:C5C7 2018C8          	  1785: BLKB3    JSR  FIXAD
00:C5CA 4CE9C5          	  1786:          JMP  BLKB2
00:C5CD 200CBB          	  1787: BLKB1    JSR  WRKSYM
00:C5D0 A004            	  1788:          LDY  #SYMDSP
00:C5D2 B140            	  1789:          LDA  (SYMITM),Y
00:C5D4 8537            	  1790:          STA  WORK
00:C5D6 C8              	  1791:          INY
00:C5D7 B140            	  1792:          LDA  (SYMITM),Y
00:C5D9 8538            	  1793:          STA  WORK+1
00:C5DB A004            	  1794:          LDY  #SYMDSP
00:C5DD A523            	  1795:          LDA  PCODE
00:C5DF 9140            	  1796:          STA  (SYMITM),Y
00:C5E1 A524            	  1797:          LDA  PCODE+1
00:C5E3 C8              	  1798:          INY
00:C5E4 9140            	  1799:          STA  (SYMITM),Y
00:C5E6 4CC7C5          	  1800:          JMP  BLKB3
00:C5E9 A520            	  1801: BLKB2    LDA  FRAME
00:C5EB 852B            	  1802:          STA  OPND
00:C5ED A521            	  1803:          LDA  FRAME+1
00:C5EF 852C            	  1804:          STA  OPND+1
00:C5F1 A93B            	  1805:          LDA  #PCODE_INT         ; INT      Increment stack pointer
00:C5F3 20EAC7          	  1806:          JSR  GENJMP
00:C5F6 2021BE          	  1807: BLKB5    JSR  STMNT
00:C5F9 A593            	  1808:          LDA  token_type
00:C5FB C93B            	  1809:          CMP  #';'
00:C5FD D006            	  1810:          BNE  BLKB4
00:C5FF 203BCF          	  1811:          JSR  pas_get_token
00:C602 4CF6C5          	  1812:          JMP  BLKB5
00:C605 A989            	  1813: BLKB4    LDA  #TOKEN_END       ; END
00:C607 A211            	  1814:          LDX  #17         ; ERROR: ; or END expected
00:C609 2003C3          	  1815:          JSR  CHKGET
00:C60C A929            	  1816:          LDA  #PCODE_RTN  ; OK - we are at the end of a block - this is a procedure/function return
00:C60E A622            	  1817:          LDX  LEVEL       ; OR - if we are at level 0, then that is the end of the program
00:C610 D002            	  1818:          BNE  BLKB6
00:C612 A911            	  1819:          LDA  #PCODE_FINISHD        ; Opcode: FINISHED  Stop run (end program)
                        	  1820: TEST1    =  *
00:C614 4C61C7          	  1821: BLKB6    JMP  GENNOP
                        	  1822: ;
                        	  1823: 
                        	  1824: 
                        	  1825: ;
                        	  1826: ;  Writing library functions is quite easy:
                        	  1827: ;
                        	  1828: ;   1. For each of the n arguments that they have (could be zero) do a PULTOP to get
                        	  1829: ;      that value from the runtime stack into REG. Or, PULTOP2 to get the value into REG2.
                        	  1830: ;      For two arguments you can do PULBOTH to get them into REG and REG2.
                        	  1831: ;   2. Do whatever the function/procedure is supposed to do with those arguments
                        	  1832: ;   3. If a procedure, you are finished: JMP MAIN
                        	  1833: ;      For a function, put the result into REG, and then JMP MAINP
                        	  1834: ;      - or - (equivalently): JSR PSHTOP, JMP MAIN
                        	  1835: ;
                        	  1836: ;  Note: PULTOP puts the value into REG and also: A, X and Y registers where A is the low-order
                        	  1837: ;        byte, X the middle byte, and Y the high-order byte.
                        	  1838: ;
                        	  1839: 
                        	  1840: ;                         Name           function or procedure   Args Execution address
                        	  1841: pascal_library_functions_table:
                        	  1842: ;
                        	  1843: ;    functions
                        	  1844: ;
                        	  1845:   makePasLibraryFunction "ABS",          SYMBOL_LIBRARY_FUNCTION,  1, EX_ABS
00:C617 414253          	     1M      asciiz   "ABS"
00:C61A 00
00:C61B 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:C61C 01              	     3M      dfb      1
00:C61D FCB0            	     4M      word     EX_ABS
                        	  1846:   makePasLibraryFunction "DIGITALREAD",  SYMBOL_LIBRARY_FUNCTION,  1, EX_DIGITALREAD
00:C61F 4449474954414C52	     1M      asciiz   "DIGITALREAD"
00:C627 454144
00:C62A 00
00:C62B 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:C62C 01              	     3M      dfb      1
00:C62D 76B5            	     4M      word     EX_DIGITALREAD
                        	  1847:   makePasLibraryFunction "GETKEY",       SYMBOL_LIBRARY_FUNCTION,  0, EX_GETKEY
00:C62F 4745544B4559    	     1M      asciiz   "GETKEY"
00:C635 00
00:C636 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:C637 00              	     3M      dfb      0
00:C638 B6B0            	     4M      word     EX_GETKEY
                        	  1848:   makePasLibraryFunction "RANDOM",       SYMBOL_LIBRARY_FUNCTION,  0, EX_RANDOM
00:C63A 52414E444F4D    	     1M      asciiz   "RANDOM"
00:C640 00
00:C641 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:C642 00              	     3M      dfb      0
00:C643 9EB5            	     4M      word     EX_RANDOM
                        	  1849:   makePasLibraryFunction "LATENCY",      SYMBOL_LIBRARY_FUNCTION,  0, EX_LATENCY
00:C645 4C4154454E4359  	     1M      asciiz   "LATENCY"
00:C64C 00
00:C64D 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:C64E 00              	     3M      dfb      0
00:C64F B0B5            	     4M      word     EX_LATENCY
                        	  1850: ;
                        	  1851: ;      procedures
                        	  1852: ;
                        	  1853:   makePasLibraryFunction "ASSERT",       SYMBOL_LIBRARY_PROCEDURE, 1, EX_ASSERT
00:C651 415353455254    	     1M      asciiz   "ASSERT"
00:C657 00
00:C658 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C659 01              	     3M      dfb      1
00:C65A 03B6            	     4M      word     EX_ASSERT
                        	  1854:   makePasLibraryFunction "DELAY",        SYMBOL_LIBRARY_PROCEDURE, 1, EX_DELAY
00:C65C 44454C4159      	     1M      asciiz   "DELAY"
00:C661 00
00:C662 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C663 01              	     3M      dfb      1
00:C664 BFB5            	     4M      word     EX_DELAY
                        	  1855:   makePasLibraryFunction "DIGITALWRITE", SYMBOL_LIBRARY_PROCEDURE, 2, EX_DIGITALWRITE
00:C666 4449474954414C57	     1M      asciiz   "DIGITALWRITE"
00:C66E 52495445
00:C672 00
00:C673 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C674 02              	     3M      dfb      2
00:C675 EEB5            	     4M      word     EX_DIGITALWRITE
                        	  1856:   makePasLibraryFunction "LCDCLEAR",     SYMBOL_LIBRARY_PROCEDURE, 0, EX_LCDCLEAR
00:C677 4C4344434C454152	     1M      asciiz   "LCDCLEAR"
00:C67F 00
00:C680 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C681 00              	     3M      dfb      0
00:C682 E8B4            	     4M      word     EX_LCDCLEAR
                        	  1857:   makePasLibraryFunction "LCDHOME",      SYMBOL_LIBRARY_PROCEDURE, 0, EX_LCDHOME
00:C684 4C4344484F4D45  	     1M      asciiz   "LCDHOME"
00:C68B 00
00:C68C 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C68D 00              	     3M      dfb      0
00:C68E E2B4            	     4M      word     EX_LCDHOME
                        	  1858:   makePasLibraryFunction "LCDPOS",       SYMBOL_LIBRARY_PROCEDURE, 2, EX_LCDPOS
00:C690 4C4344504F53    	     1M      asciiz   "LCDPOS"
00:C696 00
00:C697 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C698 02              	     3M      dfb      2
00:C699 84B5            	     4M      word     EX_LCDPOS
                        	  1859:   makePasLibraryFunction "PINMODE",      SYMBOL_LIBRARY_PROCEDURE, 2, EX_PINMODE
00:C69B 50494E4D4F4445  	     1M      asciiz   "PINMODE"
00:C6A2 00
00:C6A3 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C6A4 02              	     3M      dfb      2
00:C6A5 DFB5            	     4M      word     EX_PINMODE
                        	  1860:   makePasLibraryFunction "RANDOMSEED",   SYMBOL_LIBRARY_PROCEDURE, 1, EX_RANDOMSEED
00:C6A7 52414E444F4D5345	     1M      asciiz   "RANDOMSEED"
00:C6AF 4544
00:C6B1 00
00:C6B2 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C6B3 01              	     3M      dfb      1
00:C6B4 CFB5            	     4M      word     EX_RANDOMSEED
00:C6B6 00              	  1861:   dfb 0   ; end of table
                        	  1862: 
                        	  1863: add_pascal_library_functions:
00:C6B7 A917            	  1864:   lda #<pascal_library_functions_table
00:C6B9 8500            	  1865:   sta REG
00:C6BB A9C6            	  1866:   lda #>pascal_library_functions_table
00:C6BD 8501            	  1867:   sta REG+1
                        	  1868: add_pascal_library_functions_loop:
00:C6BF A000            	  1869:   ldy #0
00:C6C1 B100            	  1870:   lda (REG),Y
00:C6C3 F04B            	  1871:   beq add_pascal_library_functions_done
00:C6C5 A500            	  1872:   lda REG
00:C6C7 8590            	  1873:   sta token_address
00:C6C9 A501            	  1874:   lda REG+1
00:C6CB 8591            	  1875:   sta token_address+1
00:C6CD 6492            	  1876:   stz token_length
                        	  1877: ;
                        	  1878: ;  find name length
                        	  1879: ;
                        	  1880: add_pascal_library_functions_name_loop
00:C6CF C8              	  1881:   iny
00:C6D0 E692            	  1882:   inc token_length
00:C6D2 B100            	  1883:   lda (REG),Y
00:C6D4 D0F9            	  1884:   bne add_pascal_library_functions_name_loop
00:C6D6 5A              	  1885:   phy
00:C6D7 A943            	  1886:   lda #SYMBOL_CONSTANT  ; add the symbol as a constant for now
00:C6D9 208FB9          	  1887:   jsr ADDSYM
00:C6DC 7A              	  1888:   ply
                        	  1889: 
00:C6DD C8              	  1890:   iny             ; get past the 0x00
00:C6DE B100            	  1891:   lda (REG),Y     ; get symbol type
00:C6E0 5A              	  1892:   phy
00:C6E1 A003            	  1893:   ldy #SYMTYP
00:C6E3 9140            	  1894:   sta (SYMITM),Y  ; change symbol type to be correct
00:C6E5 7A              	  1895:   ply
                        	  1896: 
00:C6E6 C8              	  1897:   iny             ; get next byte
00:C6E7 B100            	  1898:   lda (REG),Y     ; get number of arguments
00:C6E9 5A              	  1899:   phy
00:C6EA A006            	  1900:   ldy #SYMARG
00:C6EC 9140            	  1901:   sta (SYMITM),Y  ; save number of arguments
00:C6EE 7A              	  1902:   ply
                        	  1903: 
00:C6EF C8              	  1904:   iny             ; get next byte
00:C6F0 B100            	  1905:   lda (REG),Y     ; get function address low-byte
00:C6F2 5A              	  1906:   phy
00:C6F3 A004            	  1907:   ldy #SYMDSP
00:C6F5 9140            	  1908:   sta (SYMITM),Y  ; save function address low-byte
00:C6F7 7A              	  1909:   ply
                        	  1910: 
00:C6F8 C8              	  1911:   iny             ; get next byte
00:C6F9 B100            	  1912:   lda (REG),Y     ; get function address high-byte
00:C6FB 5A              	  1913:   phy
00:C6FC A005            	  1914:   ldy #SYMDSP+1
00:C6FE 9140            	  1915:   sta (SYMITM),Y  ; save function address high-byte
00:C700 7A              	  1916:   ply
                        	  1917: 
00:C701 C8              	  1918:   iny         ; get past that last byte
00:C702 98              	  1919:   tya         ; move REG onto next entry
00:C703 18              	  1920:   clc
00:C704 6500            	  1921:   adc REG
00:C706 8500            	  1922:   sta REG
00:C708 A900            	  1923:   lda #0
00:C70A 6501            	  1924:   adc REG+1
00:C70C 8501            	  1925:   sta REG+1
00:C70E 80AF            	  1926:   bra add_pascal_library_functions_loop
                        	  1927: 
                        	  1928: add_pascal_library_functions_done:
00:C710 60              	  1929:   rts
                        	  1930: 
                        	  1931: 
                        	  1932: library_function_call:
                        	  1933: 
00:C711 A900            	  1934:   lda  #0
00:C713 854B            	  1935:   sta  COUNT1      ; number of arguments
00:C715 A006            	  1936:   ldy  #SYMARG
00:C717 B140            	  1937:   lda  (SYMITM),Y
00:C719 F032            	  1938:   beq  library_function_call_1
                        	  1939: 
                        	  1940: ;
                        	  1941: ;  here if it has arguments - push them on the stack
                        	  1942: ;
                        	  1943: 
00:C71B 2097BA          	  1944:   jsr  CHKLHP
                        	  1945: library_function_call_2
00:C71E A54B            	  1946:   lda  COUNT1    ; save on stack in case the expression calls functions
00:C720 48              	  1947:   pha
00:C721 2001BB          	  1948:   jsr  SYMWRK
00:C724 20C992          	  1949:   jsr  PSHWRK
00:C727 2055BB          	  1950:   jsr  GETEXPR
00:C72A 20DC92          	  1951:   jsr  PULWRK
00:C72D 200CBB          	  1952:   jsr  WRKSYM
00:C730 68              	  1953:   pla            ; get number of arguments back
00:C731 854B            	  1954:   sta  COUNT1
00:C733 E64B            	  1955:   inc  COUNT1    ; add 1 for the one we just processed
00:C735 A593            	  1956:   lda  token_type
00:C737 C92C            	  1957:   cmp  #','
00:C739 F0E3            	  1958:   beq  library_function_call_2
                        	  1959: 
00:C73B A54B            	  1960:   lda  COUNT1
00:C73D A006            	  1961:   ldy  #SYMARG
00:C73F D140            	  1962:   cmp  (SYMITM),Y   ; check we got the right number of arguments
00:C741 F005            	  1963:   beq  library_function_call_3
                        	  1964: 
00:C743 A223            	  1965:   ldx  #35     ; ERROR: Parameters mismatched
00:C745 4CCE97          	  1966:   jmp  ERROR
                        	  1967: library_function_call_3:
00:C748 209EBA          	  1968:   jsr  CHKRHP
00:C74B 8003            	  1969:   bra  library_function_call_5
                        	  1970: 
                        	  1971: ;
                        	  1972: ;  here for no arguments
                        	  1973: ;
                        	  1974: 
                        	  1975: library_function_call_1:
00:C74D 203BCF          	  1976:   jsr  pas_get_token      ; one token look-ahead
                        	  1977: 
                        	  1978: library_function_call_5:
00:C750 A004            	  1979:   ldy  #SYMDSP
00:C752 B140            	  1980:   lda  (SYMITM),Y
00:C754 852B            	  1981:   sta  OPND
00:C756 C8              	  1982:   iny
00:C757 B140            	  1983:   lda  (SYMITM),Y
00:C759 852C            	  1984:   sta  OPND+1
00:C75B A903            	  1985:   lda  #PCODE_LIB_CALL
00:C75D 20EAC7          	  1986:   jsr  GENJMP
00:C760 60              	  1987:   rts
                        	  1988: 
                        	  1989: 
                        	  1990: ;***********************************************
                        	  1991: ; GENERATE P-CODES - NO OPERANDS
                        	  1992: ;***********************************************
                        	  1993: GENNOP   =  *
00:C761 A442            	  1994:          LDY  SYNTAX
00:C763 D011            	  1995:          BNE  GEN1      ; no storing/displaying if syntax-only compile
00:C765 9123            	  1996:          STA  (PCODE),Y
00:C767 48              	  1997:          PHA
00:C768 20AD92          	  1998:          JSR  DISPAD
00:C76B 68              	  1999:          PLA
00:C76C A62E            	  2000:          LDX  DCODE
00:C76E F006            	  2001:          BEQ  GEN1
00:C770 20A792          	  2002:          JSR  DISHX
00:C773 209292          	  2003:          JSR  CROUT
                        	  2004: GEN1     =  *
00:C776 A901            	  2005:          LDA  #1      ; 1-byte P-code
00:C778 D035            	  2006:          BNE  GEN2_B
                        	  2007: ;***********************************************
                        	  2008: ; GENERATE P-CODES - WITH ADDRESS (3-bytes stored in DISPL (1)/OFFSET(2))
                        	  2009: ;***********************************************
                        	  2010: GENADR   =  *
00:C77A A442            	  2011:          LDY  SYNTAX
00:C77C D02F            	  2012:          BNE  GEN2    ; no storing/displaying if syntax-only compile
00:C77E 9123            	  2013:          STA  (PCODE),Y
00:C780 48              	  2014:          PHA
00:C781 A527            	  2015:          LDA  DISPL
00:C783 C8              	  2016:          INY
00:C784 9123            	  2017:          STA  (PCODE),Y
00:C786 A529            	  2018:          LDA  OFFSET
00:C788 C8              	  2019:          INY
00:C789 9123            	  2020:          STA  (PCODE),Y
00:C78B A52A            	  2021:          LDA  OFFSET+1
00:C78D C8              	  2022:          INY
00:C78E 9123            	  2023:          STA  (PCODE),Y
00:C790 20AD92          	  2024:          JSR  DISPAD
00:C793 68              	  2025:          PLA
00:C794 A62E            	  2026:          LDX  DCODE
00:C796 F015            	  2027:          BEQ  GEN2
00:C798 20A792          	  2028:          JSR  DISHX
00:C79B A527            	  2029:          LDA  DISPL
00:C79D 20A792          	  2030:          JSR  DISHX
00:C7A0 A529            	  2031:          LDA  OFFSET
00:C7A2 20A792          	  2032:          JSR  DISHX
00:C7A5 A52A            	  2033:          LDA  OFFSET+1
00:C7A7 20A792          	  2034:          JSR  DISHX
00:C7AA 209292          	  2035:          JSR  CROUT
                        	  2036: GEN2     =  *
00:C7AD A904            	  2037:          LDA  #4      ; 4-byte P-code
                        	  2038: GEN2_B   =  *
00:C7AF 18              	  2039:          CLC
00:C7B0 6523            	  2040:          ADC  PCODE
00:C7B2 8523            	  2041:          STA  PCODE
00:C7B4 9002            	  2042:          BCC  GEN2_A
00:C7B6 E624            	  2043:          INC  PCODE+1
                        	  2044: GEN2_A   =  *
00:C7B8 A542            	  2045:          LDA  SYNTAX
00:C7BA D013            	  2046:          BNE  GEN2_C      ; no storing/displaying if syntax-only compile
00:C7BC A524            	  2047:          LDA  PCODE+1     ; see if P-codes full
00:C7BE C532            	  2048:          CMP  ENDSYM+1   ; in other words, have we hit the symbol table?
00:C7C0 900D            	  2049:          BCC  GEN2_C      ; less than
00:C7C2 D006            	  2050:          BNE  GEN_FULL
00:C7C4 A523            	  2051:          LDA  PCODE
00:C7C6 C531            	  2052:          CMP  ENDSYM   ; TODO - what?
00:C7C8 9005            	  2053:          BCC  GEN2_C
00:C7CA A201            	  2054: GEN_FULL LDX  #1         ; MEM FULL
00:C7CC 4CCE97          	  2055:          jmp  ERROR
                        	  2056: GEN2_C   =  *
00:C7CF 60              	  2057: DISP9    RTS
                        	  2058: ;***********************************************
                        	  2059: ; GENERATE P-CODES - JUMP ADDRESS (relative to current P-code address in OPND)
                        	  2060: ;***********************************************
                        	  2061: GENRJMP  =  *
00:C7D0 48              	  2062:          PHA
00:C7D1 A52B            	  2063:          LDA  OPND
00:C7D3 38              	  2064:          SEC
00:C7D4 E523            	  2065:          SBC  PCODE
00:C7D6 852B            	  2066:          STA  OPND      ; subtract P-code address to find difference
00:C7D8 A52C            	  2067:          LDA  OPND+1
00:C7DA E524            	  2068:          SBC  PCODE+1
00:C7DC 852C            	  2069:          STA  OPND+1
00:C7DE 68              	  2070:          PLA
00:C7DF 4CEAC7          	  2071:          JMP  GENJMP
                        	  2072: ;
                        	  2073: GENNJP   =  *
00:C7E2 A93C            	  2074:          LDA  #PCODE_JMP       ; JMP
                        	  2075: 
                        	  2076: ; Generate jump, P-code is in "A" register (eg. PCODE_JMZ, PCODE_JM1)
                        	  2077: ;
                        	  2078: ;  Note: the destination here is 0000, however FIXAD will be called later to fix up
                        	  2079: ;        the jump, once we know what the destination will be (ie. further down the code)
                        	  2080: ;
00:C7E4 A200            	  2081: GENNJM   LDX  #0
00:C7E6 862B            	  2082:          STX  OPND
00:C7E8 862C            	  2083:          STX  OPND+1
                        	  2084: ;
                        	  2085: ;***********************************************
                        	  2086: ; GENERATE P-CODES - JUMP ADDRESS (absolute address in OPND)
                        	  2087: ;   also used in other places, like increment stack address
                        	  2088: ;***********************************************
                        	  2089: GENJMP   =  *
00:C7EA A442            	  2090:          LDY  SYNTAX
00:C7EC D025            	  2091:          BNE  GEN3     ; no storing/displaying if syntax-only compile
00:C7EE 9123            	  2092:          STA  (PCODE),Y
00:C7F0 48              	  2093:          PHA
00:C7F1 A52B            	  2094:          LDA  OPND
00:C7F3 C8              	  2095:          INY
00:C7F4 9123            	  2096:          STA  (PCODE),Y
00:C7F6 A52C            	  2097:          LDA  OPND+1
00:C7F8 C8              	  2098:          INY
00:C7F9 9123            	  2099:          STA  (PCODE),Y
00:C7FB 20AD92          	  2100:          JSR  DISPAD
00:C7FE 68              	  2101:          PLA
00:C7FF A62E            	  2102:          LDX  DCODE
00:C801 F010            	  2103:          BEQ  GEN3
00:C803 20A792          	  2104:          JSR  DISHX
00:C806 A52B            	  2105:          LDA  OPND
00:C808 20A792          	  2106:          JSR  DISHX
00:C80B A52C            	  2107:          LDA  OPND+1
00:C80D 20A792          	  2108:          JSR  DISHX
00:C810 209292          	  2109:          JSR  CROUT
                        	  2110: GEN3     =  *
00:C813 A903            	  2111:          LDA  #3        ; 3-byte P-code
00:C815 4CAFC7          	  2112:          JMP  GEN2_B
                        	  2113: 
                        	  2114: ;***********************************************
                        	  2115: ; FIXUP ADDRESSES
                        	  2116: ;***********************************************
                        	  2117: FIXAD    =  *
00:C818 A442            	  2118:          LDY  SYNTAX
00:C81A D039            	  2119:          BNE  FIXAD1
00:C81C A001            	  2120:          LDY  #1
00:C81E A523            	  2121:          LDA  PCODE
00:C820 38              	  2122:          SEC
00:C821 E537            	  2123:          SBC  WORK
00:C823 9137            	  2124:          STA  (WORK),Y
00:C825 C8              	  2125:          INY
00:C826 A524            	  2126:          LDA  PCODE+1
00:C828 E538            	  2127:          SBC  WORK+1
00:C82A 9137            	  2128:          STA  (WORK),Y
00:C82C A52E            	  2129:          LDA  DCODE
00:C82E F025            	  2130:          BEQ  FIXAD1
00:C830 A956            	  2131:          LDA  #<FIXM1
00:C832 A2C8            	  2132:          LDX  #>FIXM1
00:C834 202682          	  2133:          JSR  print
00:C837 A538            	  2134:          LDA  WORK+1
00:C839 200793          	  2135:          JSR  PRBYTE
00:C83C A537            	  2136:          LDA  WORK
00:C83E 20A792          	  2137:          JSR  DISHX
00:C841 A95F            	  2138:          LDA  #<FIXM2
00:C843 A2C8            	  2139:          LDX  #>FIXM2
00:C845 202682          	  2140:          JSR  print
00:C848 A524            	  2141:          LDA  PCODE+1
00:C84A 200793          	  2142:          JSR  PRBYTE
00:C84D A523            	  2143:          LDA  PCODE
00:C84F 20A792          	  2144:          JSR  DISHX
00:C852 4C9292          	  2145:          JMP  CROUT
00:C855 60              	  2146: FIXAD1    rts
                        	  2147: 
00:C856 4A756D7020617420	  2148: FIXM1    asciiz  'Jump at '
00:C85E 00
00:C85F 6368616E67656420	  2149: FIXM2    asciiz  'changed to '   ; changed to
00:C867 746F20
00:C86A 00
                        	  2150: 
                        	  2151: 

Source: "gpascal.asm"
                        	   185:   .include "hardware.inc"

Source: "hardware.inc"
                        	     1: 
                        	     2: ; VIA - Versatile Interface Adapter (W65C22) hardware
                        	     3: 
                        	     4: VIA_PORTB   = $7FF0   ; input/output register "B"
                        	     5: VIA_PORTA   = $7FF1   ; input/output register "A"
                        	     6: VIA_DDRB    = $7FF2   ; data direction register "B"
                        	     7: VIA_DDRA    = $7FF3   ; data direction register "A"
                        	     8: VIA_T1C_L   = $7FF4   ; T1 write: latch (L), read: counter (L)
                        	     9: VIA_T1C_H   = $7FF5   ; T1 high_order counter
                        	    10: VIA_T1L_L   = $7FF6   ; T1 low_order latches
                        	    11: VIA_T1L_H   = $7FF7   ; T1 high_order latches
                        	    12: VIA_T2C_L   = $7FF8   ; T2 write: latch (L), read: counter (L)
                        	    13: VIA_T2C_H   = $7FF9   ; T2 high_order counter
                        	    14: VIA_SR      = $7FFA   ; shift register
                        	    15: VIA_ACR     = $7FFB   ; auxilliary control register
                        	    16: VIA_PCR     = $7FFC   ; peripheral control register
                        	    17: VIA_IFR     = $7FFD   ; interrupt flag register
                        	    18: VIA_IER     = $7FFE   ; interrupt enable register
                        	    19: 
                        	    20: VIA_FLAG_ENABLE   = %10000000 ; high-order bit set enables the flag
                        	    21: VIA_FLAG_DISABLE  = %00000000 ; high-order bit clear disables the flag
                        	    22: VIA_FLAG_TIMER1   = %01000000
                        	    23: VIA_FLAG_TIMER2   = %00100000
                        	    24: VIA_FLAG_CB1      = %00010000
                        	    25: VIA_FLAG_CB2      = %00001000
                        	    26: VIA_FLAG_SHIFT    = %00000100
                        	    27: VIA_FLAG_CA1      = %00000010
                        	    28: VIA_FLAG_CA2      = %00000001
                        	    29: 
                        	    30: ;
                        	    31: ; VIA Port A pin masks
                        	    32: ;
                        	    33: 
                        	    34: SERIAL_IN_MASK     = %00000001   ; serial in on PA0 (also connect to CB2) (to FTDI TxD pin - pin 4)
                        	    35: SERIAL_OUT_MASK    = %00000010   ; serial out on PA1 (to FTDI RxD pin - pin 5)
                        	    36: SERIAL_DEBUG1_MASK = %00000100   ; serial debugging on PA2
                        	    37: SERIAL_DEBUG2_MASK = %00001000   ; serial debugging on PA3
                        	    38: SERIAL_SPARE2_MASK = %00010000   ; spare VIA pins (PA4)
                        	    39: 
                        	    40: 
                        	    41: ;***********************************************
                        	    42: ;  Functions added for Ben's Board
                        	    43: ;***********************************************
                        	    44: 
                        	    45: ;
                        	    46: ;  Converts a pin number in the range 0 to 15 to a mask
                        	    47: ;  eg. 00000001, 00000010, 00000100 and so on
                        	    48: ;
                        	    49: ;  Returns mask in Y
                        	    50: ;
                        	    51: ;  Returns with Z set if the range was 0 to 7 an
                        	    52: ;  and Z clear if the range was 8 to 15
                        	    53: ;
                        	    54: pin_number_to_mask = *
00:C86B 48              	    55:   pha         ; save for a moment
00:C86C 2907            	    56:   and #$7     ; make in range 0 to 7
00:C86E A8              	    57:   tay
00:C86F A901            	    58:   lda #1      ; initial mask
                        	    59: pin_number_to_mask_loop:
00:C871 C000            	    60:   cpy #0
00:C873 F004            	    61:   beq pin_number_to_mask_done
00:C875 0A              	    62:   asl A
00:C876 88              	    63:   dey
00:C877 80F8            	    64:   bra pin_number_to_mask_loop
                        	    65: pin_number_to_mask_done:
00:C879 A8              	    66:   tay         ; save mask in Y
00:C87A 68              	    67:   pla
00:C87B 2908            	    68:   and #$8     ; DDRA or DDRB ?
00:C87D 60              	    69:   rts
                        	    70: 
                        	    71: ;
                        	    72: ;  pin in A, mode in X
                        	    73: ;
                        	    74: pinmode:
00:C87E 868C            	    75:   stx hardware_work ; input or output
00:C880 206BC8          	    76:   jsr pin_number_to_mask  ; convert to appropriate mask bit
00:C883 D00A            	    77:   bne pinmode_B        ; Z is clear if it is DDRB
00:C885 A9F3            	    78:   lda #<VIA_DDRA
00:C887 8500            	    79:   sta REG
00:C889 A97F            	    80:   lda #>VIA_DDRA
00:C88B 8501            	    81:   sta REG+1
00:C88D 8008            	    82:   bra pinmode_C
                        	    83: pinmode_B:
00:C88F A9F2            	    84:   lda #<VIA_DDRB
00:C891 8500            	    85:   sta REG
00:C893 A97F            	    86:   lda #>VIA_DDRB
00:C895 8501            	    87:   sta REG+1
                        	    88: ;
                        	    89: ;  The DDR register is now in REG
                        	    90: ;
                        	    91: pinmode_C:
00:C897 A58C            	    92:   lda hardware_work     ; input or output?
00:C899 D00A            	    93:   bne pinmode_OUTPUT
                        	    94: ;
                        	    95: ;  here to set input mode
                        	    96: ;
00:C89B 98              	    97:   tya       ; get the mask back
00:C89C A000            	    98:   ldy #0
00:C89E 49FF            	    99:   eor #$FF  ; negate the mask
00:C8A0 3100            	   100:   and (REG),y
00:C8A2 9100            	   101:   sta (REG),y
00:C8A4 60              	   102:   rts       ; done
                        	   103: ;
                        	   104: ;  here to set output mode
                        	   105: ;
                        	   106: pinmode_OUTPUT:
00:C8A5 98              	   107:   tya          ; get the mask back
00:C8A6 A000            	   108:   ldy #0
00:C8A8 1100            	   109:   ora (REG),y  ; or in with the existing DDR register
00:C8AA 9100            	   110:   sta (REG),y  ; and write it back
00:C8AC 60              	   111:   rts          ; done
                        	   112: 
                        	   113: 
                        	   114: ;
                        	   115: ;  DIGITALWRITE (pin, value) pin:0 to 15; value: 0 or 1 : pin in A, mode in X
                        	   116: ;
                        	   117: digitalwrite = *
00:C8AD 868C            	   118:   stx hardware_work ; save what to write (0 or 1)
00:C8AF 206BC8          	   119:   jsr pin_number_to_mask  ; convert to appropriate mask bit
00:C8B2 D00A            	   120:   bne digitalwrite_B        ; Z is clear if it is PORTB
00:C8B4 A9F1            	   121:   lda #<VIA_PORTA
00:C8B6 8500            	   122:   sta REG
00:C8B8 A97F            	   123:   lda #>VIA_PORTA
00:C8BA 8501            	   124:   sta REG+1
00:C8BC 8008            	   125:   bra digitalwrite_C
                        	   126: digitalwrite_B:
00:C8BE A9F0            	   127:   lda #<VIA_PORTB
00:C8C0 8500            	   128:   sta REG
00:C8C2 A97F            	   129:   lda #>VIA_PORTB
00:C8C4 8501            	   130:   sta REG+1
                        	   131: ;
                        	   132: ;  The PORT register is now in REG
                        	   133: ;
                        	   134: digitalwrite_C:
00:C8C6 A58C            	   135:   lda hardware_work
00:C8C8 D00A            	   136:   bne digitalwrite_ONE  ; any non-zero value is writing a 1
                        	   137: ;
                        	   138: ;  here to write a zero
                        	   139: ;
00:C8CA 98              	   140:   tya
00:C8CB A000            	   141:   ldy #0
00:C8CD 49FF            	   142:   eor #$FF  ; negate the mask
00:C8CF 3100            	   143:   and (REG),y
00:C8D1 9100            	   144:   sta (REG),y
00:C8D3 60              	   145:   rts       ; done
                        	   146: 
                        	   147: ;
                        	   148: ;  here to write a one
                        	   149: ;
                        	   150: digitalwrite_ONE:
00:C8D4 98              	   151:   tya          ; get the mask back
00:C8D5 A000            	   152:   ldy #0
00:C8D7 1100            	   153:   ora (REG),y  ; or in with the existing DDR register
00:C8D9 9100            	   154:   sta (REG),y  ; and write it back
00:C8DB 60              	   155:   rts          ; done
                        	   156: 
                        	   157: 
                        	   158: ;
                        	   159: ;  DIGITALREAD (pin) pin:0 to 15; Pin to read is in in A. returns or non-zero in A.
                        	   160: ;
                        	   161: digitalread = *
00:C8DC 206BC8          	   162:   jsr pin_number_to_mask  ; convert to appropriate mask bit
00:C8DF D00A            	   163:   bne digitalread_B        ; Z is clear if it is PORTB
00:C8E1 A9F1            	   164:   lda #<VIA_PORTA
00:C8E3 8500            	   165:   sta REG
00:C8E5 A97F            	   166:   lda #>VIA_PORTA
00:C8E7 8501            	   167:   sta REG+1
00:C8E9 8008            	   168:   bra digitalread_C
                        	   169: digitalread_B:
00:C8EB A9F0            	   170:   lda #<VIA_PORTB
00:C8ED 8500            	   171:   sta REG
00:C8EF A97F            	   172:   lda #>VIA_PORTB
00:C8F1 8501            	   173:   sta REG+1
                        	   174: ;
                        	   175: ;  The PORT register is now in REG
                        	   176: ;
                        	   177: digitalread_C:
00:C8F3 98              	   178:   tya         ; get the mask back
00:C8F4 A000            	   179:   ldy #0
00:C8F6 3100            	   180:   and (REG),y ; get that bit
00:C8F8 60              	   181:   rts
                        	   182: 
                        	   183: 
                        	   184: 
                        	   185: ;
                        	   186: ;  Functions to change where writing is done
                        	   187: ;
                        	   188: write_to_serial:
00:C8F9 48              	   189:   pha
00:C8FA A957            	   190:   lda  #<write_char
00:C8FC 8517            	   191:   sta  write_function
00:C8FE A9C9            	   192:   lda  #>write_char
00:C900 8518            	   193:   sta  write_function+1
00:C902 68              	   194:   pla
00:C903 60              	   195:   rts
                        	   196: 
                        	   197: write_to_lcd:
00:C904 48              	   198:   pha
00:C905 A9B5            	   199:   lda  #<lcd_print_char
00:C907 8517            	   200:   sta  write_function
00:C909 A9B8            	   201:   lda  #>lcd_print_char
00:C90B 8518            	   202:   sta  write_function+1
00:C90D 68              	   203:   pla
00:C90E 60              	   204:   rts
                        	   205: 
                        	   206: 
                        	   207: 
                        	   208: ; ---------------------------
                        	   209: ; Simulate kernel interfaces
                        	   210: ; ---------------------------
                        	   211: ; We interface by reading/writing to special
                        	   212: ; RAM that is implemented in the emulator
                        	   213: 
                        	   214: 
                        	   215: 
                        	   216:     .if EMULATOR
                        	   217: 
                        	   218: ;
                        	   219: ;  Emulator testing
                        	   220: ;
                        	   221: CHRIN    =  *
                        	   222:          lda  $7F22
                        	   223:          rts
                        	   224: 
                        	   225: write_char   =  *
                        	   226:          sta  $7F23
                        	   227:          rts
                        	   228: 
                        	   229: 
                        	   230: GETIN    =  *
                        	   231:          lda  $7F29
                        	   232:          rts
                        	   233: 
                        	   234: hardware_init rts
                        	   235: 
                        	   236: ;
                        	   237: ;  put debug number in A
                        	   238: ;
                        	   239: EMULATOR_DEBUG = *
                        	   240:          sta $7F46
                        	   241:          rts
                        	   242: 
                        	   243: START_TRACE = *
                        	   244:          sta $7F47
                        	   245:          rts
                        	   246: 
                        	   247: STOP_TRACE = *
                        	   248:          sta $7F48
                        	   249:          rts
                        	   250: ;
                        	   251: ;  not applicable in emulator
                        	   252: ;
                        	   253: lcd_print_message   rts
                        	   254: lcd_clear_display   rts
                        	   255: lcd_print_char      rts
                        	   256: lcd_second_line     rts
                        	   257: lcd_instruction     rts
                        	   258: lcd_get_address     rts
                        	   259: lcd_wait            rts
                        	   260: lcd_home            rts
                        	   261: lcd_initialise      rts
                        	   262: serial_available    rts
                        	   263: serial_print_message rts
                        	   264: 
                        	   265:   .else
                        	   266: 
                        	   267: ;
                        	   268: ;  Ben's Board
                        	   269: ;
                        	   270: 
                        	   271: ;
                        	   272: ;  typing_latency could be used as a seed for the random number generator
                        	   273: ;    - the exact time between keypresses would be somewhat unpredictable
                        	   274: ;
                        	   275: CHRIN  = *
                        	   276: GETIN    =  *
00:C90F E60D            	   277:          inc typing_latency
00:C911 D006            	   278:          bne GETIN1
00:C913 E60E            	   279:          inc typing_latency+1
00:C915 D002            	   280:          bne GETIN1
00:C917 E60F            	   281:          inc typing_latency+2
                        	   282: GETIN1:
00:C919 A58B            	   283:          lda serial_in_byte_received
00:C91B F0F2            	   284:          beq GETIN    ; nothing yet
00:C91D 648B            	   285:          stz serial_in_byte_received
00:C91F 60              	   286:          rts
                        	   287: 
                        	   288: serial_available = *
00:C920 A58B            	   289:          lda serial_in_byte_received
00:C922 60              	   290:          rts
                        	   291: 
                        	   292: 
00:C923 60              	   293: EMULATOR_DEBUG rts
00:C924 60              	   294: START_TRACE rts
00:C925 60              	   295: STOP_TRACE rts
                        	   296: 
                        	   297: 
                        	   298: ;
                        	   299: ;  set up serial hardware
                        	   300: ;
                        	   301: 
                        	   302: hardware_init:
                        	   303: 
00:C926 A902            	   304:   lda #SERIAL_OUT_MASK  ; set 1 bit (idle serial comms), and others to zero
00:C928 8DF17F          	   305:   sta VIA_PORTA
                        	   306: 
                        	   307:   ; set output enable bits
00:C92B A91E            	   308:   lda #(SERIAL_OUT_MASK | SERIAL_DEBUG1_MASK | SERIAL_DEBUG2_MASK | SERIAL_SPARE2_MASK)
00:C92D 8DF37F          	   309:   sta VIA_DDRA
                        	   310: 
00:C930 A940            	   311:   lda #%01000000      ; continuous interrupts on T1
00:C932 8DFB7F          	   312:   sta VIA_ACR
                        	   313: 
00:C935 A900            	   314:   lda #0              ; Input-negative active edge
00:C937 8DFC7F          	   315:   sta VIA_PCR
                        	   316: 
00:C93A A9D0            	   317:   lda #<BIT_INTERVAL  ; ie. baud rate interval
00:C93C 8DF47F          	   318:   sta VIA_T1C_L       ; for sending bits
00:C93F A900            	   319:   lda #>BIT_INTERVAL
00:C941 8DF57F          	   320:   sta VIA_T1C_H       ; this starts the counter
                        	   321: 
                        	   322:   ; set up for serial input
                        	   323: 
00:C944 A988            	   324:   lda #VIA_FLAG_ENABLE | VIA_FLAG_CB2  ; interrupt on CB2 falling edge
00:C946 8DFE7F          	   325:   sta VIA_IER
                        	   326: 
00:C949 A9FF            	   327:   lda #$FF         ; clear all interrupt flags
00:C94B 8DFD7F          	   328:   sta VIA_IFR
                        	   329: 
                        	   330:   .if LCD_SUPPORT
00:C94E 20A6B7          	   331:   jsr lcd_initialise
                        	   332:   .endif
                        	   333: 
00:C951 648A            	   334:   stz serial_in_byte    ; non-zero means an interrupt put in incoming byte there
00:C953 6489            	   335:   stz serial_out_bit
                        	   336: 
00:C955 58              	   337:   cli         ; enable interrupts
00:C956 60              	   338:   rts
                        	   339: 
                        	   340: 
                        	   341: ;
                        	   342: ;  Write a character (in A) to the serial port.
                        	   343: ;   Interrupts MUST be enabled for this to work!
                        	   344: ;
                        	   345: write_char:
00:C957 48              	   346:   pha                   ; save original character
00:C958 0A              	   347:   asl a                 ; shift in a zero which will be the start bit
00:C959 8587            	   348:   sta serial_out_byte
00:C95B A9FF            	   349:   lda #0xff             ; will become the stop bit(s)
00:C95D 2A              	   350:   rol a                 ; rotate in the high-order bit from the data byte
00:C95E 8588            	   351:   sta serial_out_byte+1
00:C960 A90B            	   352:   lda #11               ; 8 data bits, one start bit, two stop bits
00:C962 8589            	   353:   sta serial_out_bit    ; number of bits to shift out
00:C964 A9D0            	   354:   lda #<BIT_INTERVAL    ; ie. baud rate interval
00:C966 8DF47F          	   355:   sta VIA_T1C_L         ; for sending bits
00:C969 A900            	   356:   lda #>BIT_INTERVAL
00:C96B 8DF57F          	   357:   sta VIA_T1C_H         ; this starts the counter
00:C96E A9C0            	   358:   lda #VIA_FLAG_ENABLE | VIA_FLAG_TIMER1  ; interrupt on T1 timeout
00:C970 8DFE7F          	   359:   sta VIA_IER
                        	   360: 
                        	   361: ;
                        	   362: ; wait for this byte to finish - otherwise it might interfere with many things
                        	   363: ;
                        	   364: 
                        	   365: write_char_loop:
00:C973 ADFE7F          	   366:   lda VIA_IER
00:C976 2940            	   367:   and #VIA_FLAG_TIMER1  ; are T1 interrupts enabled?
00:C978 D0F9            	   368:   bne write_char_loop   ; loop until this character sent
00:C97A 68              	   369:   pla                   ; get character back
00:C97B 60              	   370:   rts
                        	   371: 
                        	   372: 
                        	   373: ;
                        	   374: ;  sends null-terminated message to serial port, message in A (lo) and X (hi)
                        	   375: ;  returns the length of the message in Y
                        	   376: ;
                        	   377: serial_print_message:
00:C97C 8503            	   378:   sta REG2
00:C97E 8604            	   379:   stx REG2+1
00:C980 A000            	   380:   ldy #0
                        	   381: serial_print:
00:C982 B103            	   382:   lda (REG2),y
00:C984 F006            	   383:   beq serial_print_done
00:C986 2057C9          	   384:   jsr write_char
00:C989 C8              	   385:   iny
00:C98A 80F6            	   386:   bra serial_print
                        	   387: 
00:C98C 60              	   388: serial_print_done rts
                        	   389: 
                        	   390:   .endif  ; not EMULATOR
                        	   391: 
                        	   392: 

Source: "gpascal.asm"
                        	   186:   .include "gtoken.inc"

Source: "gtoken.inc"
                        	     1: ;
                        	     2: ;  get_token
                        	     3: ;
                        	     4: ;  Gets a lexical token from the specified address.
                        	     5: ;
                        	     6: ;  - Start parsing at token_start (this should be the first character of the token)
                        	     7: ;  - The first found character (after spaces, comments, newlines) is in token_address
                        	     8: ;      - this is mainly used for knowing what the identifier is so we can put it in the symbol table
                        	     9: ;      - strings are put into INBUF after processing, so token_address is not as useful in that case
                        	    10: ;  - The length is in token_length (in the case of strings, this is the processed length)
                        	    11: ;  - The type is in token_type - zero would mean end of file
                        	    12: ;
                        	    13: ;  The types are one of the token codes below
                        	    14: ;
                        	    15: ;  Tokens which start with a letter and are possibly followed by letters, numbers, and
                        	    16: ;    the underscore character become TOKEN_IDENTIFIER.
                        	    17: ;
                        	    18: ;  Tokens starting with a number (TOKEN_NUMBER) are parsed for the value which is placed into token_value.
                        	    19: ;
                        	    20: ;  Tokens starting with a single or double quote are parsed for the internal string (TOKEN_STRING)
                        	    21: ;  which is placed in INBUF. The internal string has internal double-quotes turned
                        	    22: ;  into single quotes, and sequences like \n or \x42 turned into their appropriate characters.
                        	    23: ;
                        	    24: ;  String tokens which are up to 3 bytes long also have the 3 bytes placed into token_value.
                        	    25: ;
                        	    26: ;  Hex and binary tokens are parsed for their value which is placed into token_value.
                        	    27: ;
                        	    28: ;  Various 2-character tokens are given their own code (eg. <> == != := << >> and so on).
                        	    29: ;
                        	    30: ;  Spaces and comments are skipped, however Pascal directives inside comments are processed
                        	    31: ;
                        	    32: ;  Newlines are skipped in Pascal but returned as a token in assembler (ASSEMBLING == true)
                        	    33: ;  If newlines are skipped then token_line is called to handle listing the line (the line
                        	    34: ;   we are about to process, not the previous line)
                        	    35: ;
                        	    36: ; Rewritten in February 2022 to be easier to read and have well-defined work variables (zero-page variables)
                        	    37: 
                        	    38: ; multi-byte token codes (single byte tokens are themselves)
                        	    39: 
                        	    40: TOKEN_ASSIGN     = 'A'   ; :=
                        	    41: TOKEN_IDENTIFIER = 'I'   ; alpha-numeric identifiers
                        	    42: TOKEN_NUMBER     = 'N'   ; numbers
                        	    43: TOKEN_STRING     = '"'   ; string literal
                        	    44: TOKEN_LEQ        = $80   ; <=
                        	    45: TOKEN_GEQ        = $81   ; >=
                        	    46: TOKEN_NEQ        = 'U'   ; <>
                        	    47: 
                        	    48: ;
                        	    49: ;  the ones below are used in the assembler
                        	    50: ;
                        	    51: TOKEN_EQUALITY    = 'E'     ; ==
                        	    52: TOKEN_SHIFT_LEFT  = 'L'     ; <<
                        	    53: TOKEN_SHIFT_RIGHT = 'R'     ; >>
                        	    54: TOKEN_UNARY_MINUS = 'M'     ; -
                        	    55: TOKEN_LOW_BYTE    = 'V'     ; eg. lda #<foo
                        	    56: TOKEN_HIGH_BYTE   = 'W'     ; eg. lda #>foo
                        	    57: TOKEN_LOGICAL_AND = 'X'     ; &&
                        	    58: TOKEN_LOGICAL_OR  = 'Y'     ; ||
                        	    59: TOKEN_INEQUALITY  = 'Z'     ; !=
                        	    60: 
                        	    61: 
                        	    62: get_token:
00:C98D A593            	    63:   lda token_type      ; remember previous token for checking if + or - stand on their own
00:C98F 8598            	    64:   sta token_work
                        	    65: get_token_loop:
00:C991 A000            	    66:   ldy #0              ; offset into the token address
00:C993 8497            	    67:   sty token_sign      ; Y is zero at this point
00:C995 8494            	    68:   sty token_value     ; no value yet
00:C997 8495            	    69:   sty token_value+1
00:C999 8496            	    70:   sty token_value+2
                        	    71: 
                        	    72: gc_skip_spaces:
00:C99B B18E            	    73:   lda (token_start),y
00:C99D F034            	    74:   beq gc_done         ; 0x00 means end, so return it WITHOUT incrementing the pointer
00:C99F C90A            	    75:   cmp #NL             ; newline need special handling
00:C9A1 F00D            	    76:   beq gc_newline
00:C9A3 204A81          	    77:   jsr isspace
00:C9A6 9043            	    78:   bcc gc_not_space
00:C9A8 E68E            	    79:   inc token_start     ; increment pointer because spaces can be any length
00:C9AA D0EF            	    80:   bne gc_skip_spaces
00:C9AC E68F            	    81:   inc token_start+1
00:C9AE 80EB            	    82:   bra gc_skip_spaces
                        	    83: 
                        	    84: ;
                        	    85: ;  got a newline - if assembling, return that so we know where lines end
                        	    86: ;  otherwise just call token_line to display the next line and press on looking
                        	    87: ;  for tokens.
                        	    88: ;
                        	    89: gc_newline:
00:C9B0 A902            	    90:   lda #FLAG_ASSEMBLING
00:C9B2 25BE            	    91:   and system_flags
00:C9B4 D014            	    92:   bne gc_newline_assembling    ; return the newline as a token
00:C9B6 C8              	    93:   iny              ; length in Y (ie. one)
00:C9B7 E68E            	    94:   inc token_start
00:C9B9 D002            	    95:   bne gc_newline1
00:C9BB E68F            	    96:   inc token_start+1
                        	    97: gc_newline1:
00:C9BD A58E            	    98:   lda token_start
00:C9BF 859C            	    99:   sta token_line_start
00:C9C1 A58F            	   100:   lda token_start+1
00:C9C3 859D            	   101:   sta token_line_start+1
00:C9C5 202DCA          	   102:   jsr token_line        ; list the next line
00:C9C8 80C7            	   103:   bra get_token_loop    ; look for another token
                        	   104: 
                        	   105: gc_newline_assembling:
00:C9CA A90A            	   106:   lda #NL       ; get the newline back
00:C9CC 4CD1C9          	   107:   jmp gc_single_byte_token
                        	   108: 
                        	   109: ;
                        	   110: ;  wrap up getting a token:
                        	   111: ;
                        	   112: ;   - save the type
                        	   113: ;   - save the current address as token_address
                        	   114: ;   - add the length to token_start ready for next time
                        	   115: ;
                        	   116: gc_single_byte_already_known:
00:C9CF A593            	   117:   lda token_type        ; get back saved token type
                        	   118: gc_single_byte_token:
00:C9D1 A001            	   119:   ldy #1
                        	   120: gc_done:
00:C9D3 8492            	   121:   sty token_length      ; Y has our length
00:C9D5 8593            	   122:   sta token_type        ; A has our type
00:C9D7 18              	   123:   clc
00:C9D8 A58E            	   124:   lda token_start
00:C9DA 8590            	   125:   sta token_address     ; save the starting address of the token
00:C9DC 6592            	   126:   adc token_length      ; now add its length
00:C9DE 858E            	   127:   sta token_start       ; that gives the ending address
                        	   128: 
00:C9E0 A58F            	   129:   lda token_start+1     ; repeat for high-order byte
00:C9E2 8591            	   130:   sta token_address+1
00:C9E4 6900            	   131:   adc #0
00:C9E6 858F            	   132:   sta token_start+1
                        	   133: 
00:C9E8 A593            	   134:   lda token_type        ; get token type back into A
00:C9EA 60              	   135:   rts
                        	   136: 
                        	   137: ;
                        	   138: ;  not a space (or newline) so this must be the actual start of it
                        	   139: ;
                        	   140: 
                        	   141: gc_not_space:
                        	   142: 
                        	   143: ;
                        	   144: ;  first look for classes of characters (ie. alpha, numeric)
                        	   145: ;
00:C9EB 202681          	   146:   jsr isalpha
00:C9EE 9026            	   147:   bcc gc_not_alpha
                        	   148: 
                        	   149: ;
                        	   150: ;  find end of identifier
                        	   151: ;
                        	   152: gc_alpha_loop:
00:C9F0 C8              	   153:   iny
00:C9F1 D005            	   154:   bne gc_alpha_ok   ; if it becomes zero now, we have 256+ long identifier
00:C9F3 A20C            	   155:   ldx #12       ; ERROR: Illegal Identifier (too long)
00:C9F5 4CCE97          	   156:   jmp ERROR
                        	   157: 
                        	   158: gc_alpha_ok:
00:C9F8 A940            	   159:   lda #FLAG_ONLY_ALPHA
00:C9FA 24BE            	   160:   bit system_flags
00:C9FC D00F            	   161:   bne gc_alpha_alpha_only
00:C9FE B18E            	   162:   lda (token_start),y
00:CA00 206281          	   163:   jsr isalnum
00:CA03 B0EB            	   164:   bcs gc_alpha_loop
00:CA05 C95F            	   165:   cmp #'_'
00:CA07 F0E7            	   166:   beq gc_alpha_loop
                        	   167: 
                        	   168: ;
                        	   169: ; end of identifier
                        	   170: ;
                        	   171: gc_alpha_done:
00:CA09 A949            	   172:   lda #TOKEN_IDENTIFIER
00:CA0B 80C6            	   173:   bra gc_done
                        	   174: 
                        	   175: 
                        	   176: gc_alpha_alpha_only:
00:CA0D B18E            	   177:   lda (token_start),y
00:CA0F 202681          	   178:   jsr isalpha
00:CA12 B0DC            	   179:   bcs gc_alpha_loop
00:CA14 80F3            	   180:   bra gc_alpha_done
                        	   181: 
                        	   182: ;
                        	   183: ; now see if it is a digit
                        	   184: ;
                        	   185: gc_not_alpha:
00:CA16 203281          	   186:   jsr isdigit
00:CA19 9007            	   187:   bcc gc_not_digit
                        	   188: 
00:CA1B 207CCA          	   189:   jsr atoi
00:CA1E A94E            	   190:   lda  #TOKEN_NUMBER
00:CA20 80B1            	   191:   bra  gc_done
                        	   192: 
                        	   193: ;
                        	   194: ;  not alpha and not digit - so let's consider:
                        	   195: ;   * prefixes: $ for hex and % for binary
                        	   196: ;   *  + or - in front of numbers or on their own
                        	   197: ;   * single character tokens, eg. =, (, ) and so on
                        	   198: ;   * double-character tokens, eg. ==, >= << and so on
                        	   199: ;   * strings, eg. "foo"
                        	   200: ;
                        	   201: ;  we'll do a jump on the first character
                        	   202: ;
                        	   203: gc_not_digit:
00:CA22 8593            	   204:   sta token_type            ; remember it in case of possible two-byte sequences
00:CA24 A20A            	   205:   ldx #<gtoken_table
00:CA26 A0CB            	   206:   ldy #>gtoken_table
00:CA28 20FC8F          	   207:   jsr TKNJMP
00:CA2B 80A2            	   208:   bra gc_single_byte_already_known  ; it is what it is
                        	   209: 
                        	   210: ;
                        	   211: ;  here when get_token discovers a newline - print the next line if wanted
                        	   212: ;
                        	   213: 
                        	   214: token_line:
                        	   215: ;
                        	   216: ;  count lines
                        	   217: ;
00:CA2D E6A2            	   218:   inc current_line
00:CA2F D002            	   219:   bne token_line1
00:CA31 E6A3            	   220:   inc current_line+1
                        	   221: token_line1:
                        	   222: ;
                        	   223: ;  compiling or assembling?
                        	   224: ;
00:CA33 A901            	   225:   lda #FLAG_COMPILING
00:CA35 0902            	   226:   ora #FLAG_ASSEMBLING
00:CA37 25BE            	   227:   and system_flags
00:CA39 F040            	   228:   beq token_line_done ; no - no listing
                        	   229: ;
                        	   230: ;  listing wanted?
                        	   231: ;
00:CA3B A904            	   232:   lda #FLAG_LIST_SOURCE
00:CA3D 25BE            	   233:   and system_flags
00:CA3F D00D            	   234:   bne token_line_listing ; yes
                        	   235: 
                        	   236: ;
                        	   237: ;  no listing - show an asterisk every 15 lines
                        	   238: ;
00:CA41 A5A2            	   239:   lda current_line
00:CA43 290F            	   240:   and #$0F
00:CA45 D034            	   241:   bne token_line_done
00:CA47 A92A            	   242:   lda #'*'
00:CA49 201994          	   243:   jsr COUT
00:CA4C 802D            	   244:   bra token_line_done
                        	   245: 
                        	   246: token_line_listing:
00:CA4E A52E            	   247:   lda DCODE
00:CA50 48              	   248:   pha
00:CA51 A901            	   249:   lda #1
00:CA53 852E            	   250:   sta DCODE
00:CA55 20AD92          	   251:   jsr DISPAD
00:CA58 68              	   252:   pla
00:CA59 852E            	   253:   sta DCODE
00:CA5B 20608C          	   254:   jsr show_current_line_number
                        	   255: 
00:CA5E A59C            	   256:   lda token_line_start
00:CA60 8598            	   257:   sta token_work
00:CA62 A59D            	   258:   lda token_line_start+1
00:CA64 8599            	   259:   sta token_work+1
                        	   260: 
                        	   261: token_line_loop:
00:CA66 A000            	   262:   ldy #0
00:CA68 B198            	   263:   lda (token_work),Y
00:CA6A F00F            	   264:   beq token_line_done
00:CA6C 48              	   265:   pha
00:CA6D 201994          	   266:   jsr COUT
00:CA70 E698            	   267:   inc token_work
00:CA72 D002            	   268:   bne token_line_loop1
00:CA74 E699            	   269:   inc token_work+1
                        	   270: token_line_loop1:
00:CA76 68              	   271:   pla
00:CA77 C90A            	   272:   cmp #NL
00:CA79 D0EB            	   273:   bne token_line_loop
                        	   274: 
                        	   275: token_line_done:
00:CA7B 60              	   276:   rts
                        	   277: 
                        	   278: 
                        	   279: ;
                        	   280: ;  atoi
                        	   281: ;
                        	   282: ; get a decimal number - returns carry flag set if bad number and running
                        	   283: ;   (if compiling and a bad number gives an error)
                        	   284: ;
                        	   285: ;  token_start : the start address of the number
                        	   286: ;  Y : offset into token_start
                        	   287: ;  token_sign : non-zero if negative
                        	   288: ;
                        	   289: ;  returns: token_value  and carry clear (if no error)
                        	   290: ;           carry set if error (for use at runtime)
                        	   291: ;           Y at offset of first non-numeric character
                        	   292: 
                        	   293: atoi:
00:CA7C 38              	   294:   sec
00:CA7D E930            	   295:   sbc  #'0'   ;  ; subtract out ASCII stuff, save first digit
00:CA7F 8594            	   296:   sta  token_value
00:CA81 6495            	   297:   stz  token_value+1
00:CA83 6496            	   298:   stz  token_value+2
                        	   299: atoi_loop    =  *
00:CA85 C8              	   300:   iny
00:CA86 B18E            	   301:   lda  (token_start),y
00:CA88 203281          	   302:   jsr  isdigit
00:CA8B B009            	   303:   bcs  atoi_more      ; more digits
                        	   304: ;
                        	   305: ; end of number - make negative if we got a sign earlier
                        	   306: ;
00:CA8D A597            	   307:   lda  token_sign
00:CA8F F003            	   308:   beq  atoi_positive    ; not signed
                        	   309: ;
                        	   310: ;  make negative
                        	   311: ;
00:CA91 20F6CA          	   312:   jsr negate_token_value
                        	   313: ;
                        	   314: ;  done! clear carry and return
                        	   315: ;
                        	   316: atoi_positive:
00:CA94 18              	   317:   clc                   ; indicate no error for numeric conversion
00:CA95 60              	   318:   rts
                        	   319: ;
                        	   320: ;  Multiply previous value by 10, add in new digit
                        	   321: ;
                        	   322: atoi_more    =  *
00:CA96 38              	   323:   sec
00:CA97 E930            	   324:   sbc  #'0'
00:CA99 859B            	   325:   sta  token_digit
00:CA9B 0694            	   326:   asl  token_value         ; multiply token_value by 2
00:CA9D 2695            	   327:   rol  token_value+1
00:CA9F 2696            	   328:   rol  token_value+2
00:CAA1 3048            	   329:   bmi  atoi_error
                        	   330: 
00:CAA3 A594            	   331:   lda  token_value         ; save token_value*2 in token_work
00:CAA5 8598            	   332:   sta  token_work
00:CAA7 A595            	   333:   lda  token_value+1
00:CAA9 8599            	   334:   sta  token_work+1
00:CAAB A596            	   335:   lda  token_value+2
00:CAAD 859A            	   336:   sta  token_work+2
                        	   337: 
00:CAAF 0694            	   338:   asl  token_value         ; now token_value is multiplied by 4
00:CAB1 2695            	   339:   rol  token_value+1
00:CAB3 2696            	   340:   rol  token_value+2
00:CAB5 3034            	   341:   bmi  atoi_error
                        	   342: 
00:CAB7 0694            	   343:   asl  token_value         ; now token_value is multiplied by 8
00:CAB9 2695            	   344:   rol  token_value+1
00:CABB 2696            	   345:   rol  token_value+2
00:CABD 302C            	   346:   bmi  atoi_error
                        	   347: 
00:CABF A598            	   348:   lda  token_work          ; now add back in token_value*2 (giving token_value*10)
00:CAC1 6594            	   349:   adc  token_value
00:CAC3 8594            	   350:   sta  token_value
00:CAC5 A599            	   351:   lda  token_work+1
00:CAC7 6595            	   352:   adc  token_value+1
00:CAC9 8595            	   353:   sta  token_value+1
00:CACB A59A            	   354:   lda  token_work+2
00:CACD 6596            	   355:   adc  token_value+2
00:CACF 8596            	   356:   sta  token_value+2
00:CAD1 3018            	   357:   bmi  atoi_error      ; if negative, the number was too big
00:CAD3 18              	   358:   clc
00:CAD4 A594            	   359:   lda  token_value     ; now take the value and add in our new digit
00:CAD6 659B            	   360:   adc  token_digit
00:CAD8 8594            	   361:   sta  token_value
00:CADA A900            	   362:   lda #0
00:CADC 6595            	   363:   adc  token_value+1   ; increment next byte if necessary
00:CADE 8595            	   364:   sta  token_value+1
00:CAE0 A900            	   365:   lda #0
00:CAE2 6596            	   366:   adc  token_value+2
00:CAE4 8596            	   367:   sta  token_value+2
00:CAE6 3003            	   368:   bmi  atoi_error
00:CAE8 4C85CA          	   369:   jmp  atoi_loop     ; onwards for next digit
                        	   370: 
                        	   371: atoi_error    =  *
00:CAEB A53F            	   372:   lda  RUNNING
00:CAED 1002            	   373:   bpl  atoi_not_running
00:CAEF 38              	   374:   sec             ; otherwise set carry and return
00:CAF0 60              	   375:   rts
                        	   376: atoi_not_running  =  *
00:CAF1 A21E            	   377:   ldx  #30       ; ERROR: Number out of Range
00:CAF3 4CCE97          	   378:   jmp  ERROR
                        	   379: 
                        	   380: ;
                        	   381: ;  for negative numbers, subtract token_value from zero
                        	   382: ;
                        	   383: negate_token_value:
00:CAF6 38              	   384:   sec
00:CAF7 A900            	   385:   lda  #0
00:CAF9 E594            	   386:   sbc  token_value
00:CAFB 8594            	   387:   sta  token_value
00:CAFD A900            	   388:   lda  #0
00:CAFF E595            	   389:   sbc  token_value+1
00:CB01 8595            	   390:   sta  token_value+1
00:CB03 A900            	   391:   lda  #0
00:CB05 E596            	   392:   sbc  token_value+2
00:CB07 8596            	   393:   sta  token_value+2
00:CB09 60              	   394:   rts
                        	   395: 
                        	   396: 
                        	   397: gtoken_table:
                        	   398:   tknjmpItem '(',gc_lh_paren
00:CB0A 28              	     1M    dfb   '('
00:CB0B 52CB            	     2M    word  gc_lh_paren
                        	   399:   tknjmpItem '{',gc_lh_brace
00:CB0D 7B              	     1M    dfb   '{'
00:CB0E 4ECB            	     2M    word  gc_lh_brace
                        	   400:   tknjmpItem '"',gc_quote
00:CB10 22              	     1M    dfb   '"'
00:CB11 41CC            	     2M    word  gc_quote
                        	   401:   tknjmpItem SINGLE_QUOTE,gc_quote
00:CB13 27              	     1M    dfb   SINGLE_QUOTE
00:CB14 41CC            	     2M    word  gc_quote
                        	   402:   tknjmpItem '$',gc_dollar
00:CB16 24              	     1M    dfb   '$'
00:CB17 0FCD            	     2M    word  gc_dollar
                        	   403:   tknjmpItem '%',gc_percent
00:CB19 25              	     1M    dfb   '%'
00:CB1A 69CD            	     2M    word  gc_percent
                        	   404:   tknjmpItem ':',gc_colon
00:CB1C 3A              	     1M    dfb   ':'
00:CB1D 93CD            	     2M    word  gc_colon
                        	   405:   tknjmpItem '<',gc_less_than
00:CB1F 3C              	     1M    dfb   '<'
00:CB20 A4CD            	     2M    word  gc_less_than
                        	   406:   tknjmpItem '>',gc_greater_than
00:CB22 3E              	     1M    dfb   '>'
00:CB23 C7CD            	     2M    word  gc_greater_than
                        	   407:   tknjmpItem '-',gc_minus
00:CB25 2D              	     1M    dfb   '-'
00:CB26 E1CD            	     2M    word  gc_minus
                        	   408:   tknjmpItem '+',gc_plus
00:CB28 2B              	     1M    dfb   '+'
00:CB29 E3CD            	     2M    word  gc_plus
                        	   409:   tknjmpItem '&',gc_ampersand
00:CB2B 26              	     1M    dfb   '&'
00:CB2C 02CE            	     2M    word  gc_ampersand
                        	   410:   tknjmpItem '|',gc_bar
00:CB2E 7C              	     1M    dfb   '|'
00:CB2F 13CE            	     2M    word  gc_bar
                        	   411:   tknjmpItem '=',gc_equals
00:CB31 3D              	     1M    dfb   '='
00:CB32 24CE            	     2M    word  gc_equals
                        	   412:   tknjmpItem '!',gc_bang
00:CB34 21              	     1M    dfb   '!'
00:CB35 35CE            	     2M    word  gc_bang
                        	   413:   tknjmpItem ';',gc_semicolon
00:CB37 3B              	     1M    dfb   ';'
00:CB38 08CC            	     2M    word  gc_semicolon
00:CB3A 00              	   414:   dfb        0   ; end of table
                        	   415: 
                        	   416: gtoken_directive_table:
                        	   417:   tknjmpItem 'S',gc_directive_symbols
00:CB3B 53              	     1M    dfb   'S'
00:CB3C BACB            	     2M    word  gc_directive_symbols
                        	   418:   tknjmpItem 'L',gc_directive_list
00:CB3E 4C              	     1M    dfb   'L'
00:CB3F F2CB            	     2M    word  gc_directive_list
                        	   419:   tknjmpItem 'P',gc_directive_pcodes
00:CB41 50              	     1M    dfb   'P'
00:CB42 F9CB            	     2M    word  gc_directive_pcodes
                        	   420:   tknjmpItem 'N',gc_directive_nolist
00:CB44 4E              	     1M    dfb   'N'
00:CB45 FFCB            	     2M    word  gc_directive_nolist
00:CB47 00              	   421:   dfb        0
                        	   422: 
                        	   423: ; single byte token, in A
00:CB48 4CD1C9          	   424: gc_single_byte_tokenJ jmp gc_single_byte_token
                        	   425: ; single byte token in token_type
00:CB4B 4CCFC9          	   426: gc_single_byte_already_knownJ jmp gc_single_byte_already_known
                        	   427: 
                        	   428: gc_lh_brace:
00:CB4E A000            	   429:   ldy #0
00:CB50 800E            	   430:   bra gc_pascal_comment
                        	   431: gc_lh_paren:
00:CB52 A902            	   432:   lda #FLAG_ASSEMBLING
00:CB54 25BE            	   433:   and system_flags
00:CB56 D0F3            	   434:   bne gc_single_byte_already_knownJ
00:CB58 A001            	   435:   ldy #1
00:CB5A B18E            	   436:   lda (token_start),Y
00:CB5C C92A            	   437:   cmp #'*'      ; was it: (* ?
00:CB5E D0EB            	   438:   bne gc_single_byte_already_knownJ  ; nope
                        	   439: 
                        	   440: ;
                        	   441: ;  Y will be 0 or 1 depending on the sort of starting comment
                        	   442: ;  first look for % which indicates a compiler directive
                        	   443: ;
                        	   444: gc_pascal_comment:
00:CB60 C8              	   445:   iny
00:CB61 B18E            	   446:   lda (token_start),Y
00:CB63 C925            	   447:   cmp #'%'   ; directive?
00:CB65 D018            	   448:   bne gc_pascal_comment_find_end
00:CB67 C8              	   449:   iny
00:CB68 B18E            	   450:   lda (token_start),Y ; get the directive: S, L, P or N
00:CB6A 48              	   451:   pha   ; save the directive for now
00:CB6B 98              	   452:   tya
                        	   453: ;
                        	   454: ;  make token_start point to where we are up to, so we can skip the comment, even if it is long
                        	   455: ;
00:CB6C 38              	   456:   sec               ; I actually want to be one past where the directive letter is
00:CB6D 658E            	   457:   adc token_start
00:CB6F 858E            	   458:   sta token_start
00:CB71 A900            	   459:   lda #0
00:CB73 658F            	   460:   adc token_start+1
00:CB75 858F            	   461:   sta token_start+1
00:CB77 68              	   462:   pla   ; get the directive back
00:CB78 A23B            	   463:   ldx #<gtoken_directive_table
00:CB7A A0CB            	   464:   ldy #>gtoken_directive_table
00:CB7C 20FC8F          	   465:   jsr TKNJMP  ; do the directive handler
                        	   466: ;
                        	   467: ;  fall through if not found and just find the end of the comment
                        	   468: ;
                        	   469: 
                        	   470: gc_pascal_comment_find_end:
00:CB7F A000            	   471:   ldy #0    ; we normalised token_start to be where we want to start
00:CB81 B18E            	   472:   lda (token_start),Y
00:CB83 D005            	   473:   bne gc_comment_not_eof
00:CB85 A207            	   474:   ldx  #7           ; NO } FOUND
00:CB87 4CCE97          	   475:   jmp  ERROR
                        	   476: gc_comment_not_eof:
00:CB8A C90A            	   477:   cmp #NL
00:CB8C D005            	   478:   bne gc_comment_not_newline
00:CB8E 202DCA          	   479:   jsr token_line    ; handle the newline (we can't be assembling or we wouldn't be here)
00:CB91 800F            	   480:   bra gc_comment_keep_looking
                        	   481: gc_comment_not_newline:
00:CB93 C97D            	   482:   cmp #'}'
00:CB95 F013            	   483:   beq gc_comment_found_end
00:CB97 C92A            	   484:   cmp #'*'
00:CB99 D007            	   485:   bne gc_comment_keep_looking
00:CB9B C8              	   486:   iny
00:CB9C B18E            	   487:   lda (token_start),Y
00:CB9E C929            	   488:   cmp #')'
00:CBA0 F008            	   489:   beq gc_comment_found_end
                        	   490: 
                        	   491: ;
                        	   492: ;  skip this byte and keep looking for the end of comment
                        	   493: ;
                        	   494: gc_comment_keep_looking:
00:CBA2 E68E            	   495:   inc token_start
00:CBA4 D0D9            	   496:   bne gc_pascal_comment_find_end
00:CBA6 E68F            	   497:   inc token_start+1
00:CBA8 80D5            	   498:   bra gc_pascal_comment_find_end
                        	   499: 
                        	   500: ;
                        	   501: ;  found end of comment, so move token_start to this character
                        	   502: ;   (the one past the end of the comment) and try again for a token
                        	   503: ;
                        	   504: gc_comment_found_end:
00:CBAA C8              	   505:   iny   ; get past end of comment
00:CBAB 98              	   506:   tya
00:CBAC 18              	   507:   clc
00:CBAD 658E            	   508:   adc token_start
00:CBAF 858E            	   509:   sta token_start
00:CBB1 A900            	   510:   lda #0
00:CBB3 658F            	   511:   adc token_start+1
00:CBB5 858F            	   512:   sta token_start+1
00:CBB7 4C91C9          	   513:   jmp get_token_loop
                        	   514: 
                        	   515: ;
                        	   516: ;  {%S $nnnn}
                        	   517: ;  symbol table relocation
                        	   518: ;
                        	   519: gc_directive_symbols:
00:CBBA 2091C9          	   520:    jsr  get_token_loop     ; re-call get_token to find the address
00:CBBD C94E            	   521:    cmp  #TOKEN_NUMBER ; number?
00:CBBF F005            	   522:    beq  gc_directive_symbols_ok      ; yes
00:CBC1 A202            	   523:    ldx  #2
00:CBC3 4CCE97          	   524:    jmp  ERROR      ; 'Constant expected'
                        	   525: 
                        	   526: gc_directive_symbols_ok:
                        	   527:   ;
                        	   528:   ;  check we haven't generated any code
                        	   529:   ;
00:CBC6 A523            	   530:   lda PCODE
00:CBC8 C525            	   531:   cmp ACT_PCDA
00:CBCA D021            	   532:   bne gc_directive_symbols_too_late
00:CBCC A524            	   533:   lda PCODE+1
00:CBCE C526            	   534:   cmp ACT_PCDA+1
00:CBD0 D01B            	   535:   bne gc_directive_symbols_too_late
                        	   536: 
00:CBD2 A594            	   537:   lda  token_value
00:CBD4 8531            	   538:   sta  ENDSYM
00:CBD6 852F            	   539:   sta  STARTSYM
00:CBD8 852B            	   540:   sta  OPND
00:CBDA A595            	   541:   lda  token_value+1
00:CBDC 8532            	   542:   sta  ENDSYM+1        ; store symbol table address
00:CBDE 8530            	   543:   sta  STARTSYM+1
00:CBE0 852C            	   544:   sta  OPND+1
00:CBE2 A901            	   545:   lda  #PCODE_STACK    ; change runtime stack
00:CBE4 20EAC7          	   546:   jsr  GENJMP
                        	   547: ;
                        	   548: ;  put the library functions back
                        	   549: ;
00:CBE7 20B7C6          	   550:   jsr  add_pascal_library_functions
                        	   551: 
00:CBEA 4C7FCB          	   552:   jmp  gc_pascal_comment_find_end     ; go back and find the end of the comment
                        	   553: ;
                        	   554: 
                        	   555: gc_directive_symbols_too_late:
00:CBED A233            	   556:   ldx #51        ; code already generated
00:CBEF 4CCE97          	   557:   JMP  ERROR
                        	   558: 
                        	   559: 
                        	   560: ;
                        	   561: ;  {%L} - list source
                        	   562: ;
                        	   563: gc_directive_list:
00:CBF2 A904            	   564:   lda #FLAG_LIST_SOURCE
00:CBF4 04BE            	   565:   tsb system_flags
00:CBF6 4C7FCB          	   566:   jmp gc_pascal_comment_find_end
                        	   567: 
                        	   568: ;
                        	   569: ;  {%P} - list source and P-codes
                        	   570: ;
                        	   571: gc_directive_pcodes:
00:CBF9 A901            	   572:   lda #1
00:CBFB 852E            	   573:   sta DCODE
00:CBFD 80F3            	   574:   bra gc_directive_list   ; also list source
                        	   575: ;
                        	   576: ;  {%N} - do not list source or P-codes
                        	   577: ;
                        	   578: gc_directive_nolist:
00:CBFF A904            	   579:   lda #FLAG_LIST_SOURCE
00:CC01 14BE            	   580:   trb system_flags    ; clear both of the above flags
00:CC03 642E            	   581:   stz DCODE
00:CC05 4C7FCB          	   582:   jmp gc_pascal_comment_find_end
                        	   583: 
                        	   584: ;
                        	   585: ;  semicolons start comments in the assembler
                        	   586: ;
                        	   587: gc_semicolon:
00:CC08 A902            	   588:   lda #FLAG_ASSEMBLING
00:CC0A 25BE            	   589:   and system_flags
00:CC0C D003            	   590:   bne gc_assembler_comment_find_end
00:CC0E 4CCFC9          	   591:   jmp gc_single_byte_already_known
                        	   592: 
                        	   593: gc_assembler_comment_find_end:
00:CC11 A000            	   594:   ldy #0
00:CC13 B18E            	   595:   lda (token_start),Y
00:CC15 D005            	   596:   bne gc_assembler_comment_not_eof
00:CC17 A90A            	   597:   lda #NL
00:CC19 8593            	   598:   sta token_type
00:CC1B 60              	   599:   rts     ; exit without incrementing token_start
                        	   600: 
                        	   601: gc_assembler_comment_not_eof:
00:CC1C C90A            	   602:   cmp #NL
00:CC1E D003            	   603:   bne gc_assembler_comment_keep_looking
00:CC20 4CD1C9          	   604:   jmp gc_single_byte_token
                        	   605: ;
                        	   606: ;  skip this byte and keep looking for the newline at the end of comment
                        	   607: ;
                        	   608: gc_assembler_comment_keep_looking:
00:CC23 E68E            	   609:   inc token_start
00:CC25 D0EA            	   610:   bne gc_assembler_comment_find_end
00:CC27 E68F            	   611:   inc token_start+1
00:CC29 80E6            	   612:   bra gc_assembler_comment_find_end
                        	   613: 
                        	   614: 
                        	   615: gc_backslash_tokens:
00:CC2B 41              	   616:          DFB  'A',$07  ; bell ($07)
00:CC2C 07
00:CC2D 42              	   617:          DFB  'B',$08  ; backspace ($08)
00:CC2E 08
00:CC2F 45              	   618:          DFB  'E',$1B  ; escape  (0x1B)
00:CC30 1B
00:CC31 46              	   619:          DFB  'F',$0C  ; formfeed ($0C)
00:CC32 0C
00:CC33 4E              	   620:          DFB  'N',$0A  ; newline  (0x0A)
00:CC34 0A
00:CC35 52              	   621:          DFB  'R',$0D  ; carriage return (0x0D)
00:CC36 0D
00:CC37 54              	   622:          DFB  'T',$09  ; horizontal tab (0x09)
00:CC38 09
00:CC39 56              	   623:          DFB  'V',$0B  ; vertical tab (0x0B)
00:CC3A 0B
00:CC3B 5C              	   624:          DFB  $5C,$5C  ; backslash
00:CC3C 5C
00:CC3D 22              	   625:          DFB  '"','"'  ; double quote
00:CC3E 22
00:CC3F 27              	   626:          DFB  SINGLE_QUOTE,SINGLE_QUOTE  ; single quote
00:CC40 27
                        	   627: gc_backslash_tokens_end = *
                        	   628: gc_backslash_tokens_length = gc_backslash_tokens_end - gc_backslash_tokens
                        	   629: 
                        	   630: ;
                        	   631: ;  quoted string
                        	   632: ;
                        	   633: ;  resolve double quotes and backslash sequences and store it in INBUF
                        	   634: ;
                        	   635: ;
                        	   636: gc_quote:
00:CC41 8598            	   637:   sta token_work    ; remember which sort
00:CC43 A000            	   638:   ldy #0            ; back to the start
00:CC45 6492            	   639:   stz token_length  ; zero-length string so far
00:CC47 A58E            	   640:   lda token_start
00:CC49 8590            	   641:   sta token_address   ; save the starting address of the token (not that it matters too much)
00:CC4B A58F            	   642:   lda token_start+1   ; repeat for high-order byte
00:CC4D 8591            	   643:   sta token_address+1
                        	   644: 
                        	   645: gc_quote_loop:
00:CC4F C8              	   646:   iny                 ; onto next character
00:CC50 B18E            	   647:   lda (token_start),Y ; get the next character in the string
00:CC52 F004            	   648:   beq gc_quote_bad
00:CC54 C90A            	   649:   cmp  #NL
00:CC56 D005            	   650:   bne  gc_quote_loop_not_end_of_line
                        	   651: 
                        	   652: gc_quote_bad:
00:CC58 A208            	   653:   ldx  #8         ; MISSING QUOTE: Incorrect string
00:CC5A 4CCE97          	   654:   jmp  ERROR
                        	   655: 
                        	   656: gc_quote_loop_not_end_of_line:
00:CC5D C598            	   657:   cmp  token_work  ; same as start quote?
00:CC5F D037            	   658:   bne  gc_quote_not_finished       ; no
00:CC61 C8              	   659:   iny
00:CC62 B18E            	   660:   lda (token_start),Y ; see if another quote follows
00:CC64 C598            	   661:   cmp  token_work
00:CC66 F05A            	   662:   beq  gc_quote_not_backslash      ; embedded quote (ie. two quotes in a row)? Store a single quote symbol
                        	   663:   ;
                        	   664:   ;  here at end of quoted string
                        	   665:   ;
00:CC68 8498            	   666:   sty  token_work  ; remember how far through our input we are
00:CC6A A003            	   667:   ldy  #3          ; OK, we have the final quote, so is the string <= 3 characters long?
00:CC6C C492            	   668:   cpy  token_length
00:CC6E 9002            	   669:   bcc  gc_quote_long_string   ; BLT - no
00:CC70 A492            	   670:   ldy  token_length           ; yes - load its actual length into Y (ie. 0, 1, 2, 3)
                        	   671: gc_quote_long_string:
00:CC72 88              	   672:   dey      ; zero-relative
00:CC73 3008            	   673:   bmi  gc_quote_copied_value   ; keep going into the length done
00:CC75 B90002          	   674:   lda  INBUF,Y   ; store the (up to) 3 bytes into VALUE as the token value
00:CC78 999400          	   675:   sta  token_value,Y
00:CC7B D0F5            	   676:   bne  gc_quote_long_string   ; keep going until we hit the 0x00 at the end
                        	   677: 
                        	   678: gc_quote_copied_value:
00:CC7D A592            	   679:   lda  token_length    ; now see how long it is?
00:CC7F D005            	   680:   bne  gc_quote_done     ; don't allow zero length strings
00:CC81 A20E            	   681:   ldx  #14        ; BAD STRING: literal string of zero length
00:CC83 4CCE97          	   682:   jmp  ERROR
                        	   683: 
                        	   684: gc_quote_done:
00:CC86 18              	   685:   clc
00:CC87 A58E            	   686:   lda token_start       ; bump up our token_start address to past the quoted string
00:CC89 6598            	   687:   adc token_work        ; now add its (actual) length, not the length afer mucking around
00:CC8B 858E            	   688:   sta token_start       ; that gives the ending address
00:CC8D A58F            	   689:   lda token_start+1   ; repeat for high-order byte
00:CC8F 6900            	   690:   adc #0
00:CC91 858F            	   691:   sta token_start+1
00:CC93 A922            	   692:   lda  #TOKEN_STRING   ; it's a string token
00:CC95 8593            	   693:   sta  token_type
00:CC97 60              	   694:   rts
                        	   695: 
                        	   696: 
                        	   697: gc_quote_not_finished:
00:CC98 C95C            	   698:   cmp #$5C    ; backslash?
00:CC9A D026            	   699:   bne  gc_quote_not_backslash
                        	   700: ;
                        	   701: ;  backslash - see what follows
                        	   702: ;
00:CC9C C8              	   703:   iny
00:CC9D B18E            	   704:   lda (token_start),Y ; the character after the backslash
00:CC9F F0B7            	   705:   beq gc_quote_bad    ; nothing? bad
00:CCA1 202E90          	   706:   jsr MAKE_UPPER
00:CCA4 C958            	   707:   cmp #'X'
00:CCA6 F038            	   708:   beq gc_quote_hex_character
00:CCA8 A200            	   709:   ldx #0
                        	   710: gc_quote_backslash_loop:
00:CCAA DD2BCC          	   711:   cmp gc_backslash_tokens,X
00:CCAD F00F            	   712:   beq gc_quote_found_backslash_character   ; good match
00:CCAF E8              	   713:   inx
00:CCB0 E8              	   714:   inx
00:CCB1 E016            	   715:   cpx #gc_backslash_tokens_length
00:CCB3 90F5            	   716:   bcc gc_quote_backslash_loop
                        	   717: gc_quote_bad_string:
00:CCB5 A208            	   718:   ldx #8
00:CCB7 4CCE97          	   719:   jmp ERROR   ; ERROR: Incorrect string
                        	   720: 
                        	   721: gc_quote_hex_character_done:
00:CCBA A594            	   722:   lda token_value
00:CCBC 8004            	   723:   bra gc_quote_not_backslash
                        	   724: 
                        	   725: gc_quote_found_backslash_character:
00:CCBE E8              	   726:   inx
00:CCBF BD2BCC          	   727:   lda gc_backslash_tokens,X  ; get its replacement
                        	   728: 
                        	   729: gc_quote_not_backslash:
00:CCC2 A692            	   730:   ldx  token_length
00:CCC4 9D0002          	   731:   sta  INBUF,x           ; store it in INBUF
00:CCC7 E692            	   732:   inc  token_length
00:CCC9 F003            	   733:   beq  gc_quote_too_long
00:CCCB 4C4FCC          	   734:   jmp  gc_quote_loop     ; keep adding to string
                        	   735: 
                        	   736: 
                        	   737: gc_quote_too_long:
                        	   738:   ;            string over 255 characters long - error!
00:CCCE A21D            	   739:   ldx   #29  ; ERROR: string literal too big
00:CCD0 4CCE97          	   740:   jmp  ERROR
                        	   741: 
                        	   742: ;
                        	   743: ;  "fix" a hex digit by making it upper-case, then subtracting 7 if it is A-F
                        	   744: ;   then subtracting '0' so we get a number in the range 0x00 to 0x0F in A
                        	   745: ;
                        	   746: gc_fix_hex:
00:CCD3 202E90          	   747:   jsr  MAKE_UPPER
00:CCD6 C941            	   748:   cmp  #'A'
00:CCD8 9002            	   749:   bcc  gc_fix_hex_not_a_to_f
00:CCDA E907            	   750:   sbc  #7
                        	   751: gc_fix_hex_not_a_to_f:
00:CCDC 38              	   752:   sec
00:CCDD E930            	   753:   sbc  #'0'
00:CCDF 60              	   754:   rts
                        	   755: 
                        	   756: gc_quote_hex_character:
00:CCE0 C8              	   757:   iny
00:CCE1 F0EB            	   758:   beq  gc_quote_too_long
00:CCE3 B18E            	   759:   lda  (token_start),Y ; the character after the backslash
00:CCE5 203E81          	   760:   jsr  isxdigit
00:CCE8 90CB            	   761:   bcc  gc_quote_bad_string  ; what? should be hex
00:CCEA 20D3CC          	   762:   jsr  gc_fix_hex
00:CCED 8594            	   763:   sta  token_value  ; first nibble
00:CCEF C8              	   764:   iny
00:CCF0 F0DC            	   765:   beq  gc_quote_too_long
00:CCF2 B18E            	   766:   lda  (token_start),Y ; a second hex character?
00:CCF4 F0BF            	   767:   beq  gc_quote_bad_string
00:CCF6 203E81          	   768:   jsr  isxdigit
00:CCF9 9011            	   769:   bcc  gc_quote_hex_character_one_only
00:CCFB 20D3CC          	   770:   jsr  gc_fix_hex
00:CCFE 0694            	   771:   asl  token_value    ; shift existing value 4 bits left
00:CD00 0694            	   772:   asl  token_value
00:CD02 0694            	   773:   asl  token_value
00:CD04 0694            	   774:   asl  token_value
00:CD06 0594            	   775:   ora  token_value
00:CD08 8594            	   776:   sta  token_value
00:CD0A 80AE            	   777:   bra  gc_quote_hex_character_done
                        	   778: 
                        	   779: gc_quote_hex_character_one_only:
00:CD0C 88              	   780:   dey         ; undo add since we didn't find another hex character
00:CD0D 80AB            	   781:   bra gc_quote_hex_character_done
                        	   782: 
                        	   783: ;
                        	   784: ;  $nnnnnn where nnnnnn is one or more hex digits
                        	   785: ;    if no hex digits, then it is the token '$'
                        	   786: ;
                        	   787: gc_dollar:
00:CD0F A001            	   788:   ldy  #1    ; start with the character after the dollar
00:CD11 B18E            	   789:   lda  (token_start),Y ; followed by a hex character?
00:CD13 203E81          	   790:   jsr  isxdigit
00:CD16 B003            	   791:   bcs  gc_hex_literal
00:CD18 4CCFC9          	   792:   jmp  gc_single_byte_already_known
                        	   793: 
                        	   794: gc_hex_literal:
00:CD1B 20D3CC          	   795:   jsr gc_fix_hex
00:CD1E 8594            	   796:   sta token_value       ; store the first digit
00:CD20 6495            	   797:   stz token_value+1
00:CD22 6496            	   798:   stz token_value+2
                        	   799: gc_hex_loop:
00:CD24 C8              	   800:   iny
00:CD25 B18E            	   801:   lda (token_start),Y ; followed by another hex character?
00:CD27 203E81          	   802:   jsr isxdigit
00:CD2A 9033            	   803:   bcc gc_hex_done
00:CD2C 20D3CC          	   804:   jsr gc_fix_hex
                        	   805: ;
                        	   806: ;  shift the existing value left 4 bits to make room for the new nibble
                        	   807: ;
00:CD2F 0694            	   808:   asl  token_value        ; token_value shifted left 1 bit
00:CD31 2695            	   809:   rol  token_value+1
00:CD33 2696            	   810:   rol  token_value+2
00:CD35 B02D            	   811:   bcs  gc_hex_too_big
00:CD37 0694            	   812:   asl  token_value        ; token_value shifted left 2 bits
00:CD39 2695            	   813:   rol  token_value+1
00:CD3B 2696            	   814:   rol  token_value+2
00:CD3D B025            	   815:   bcs  gc_hex_too_big
00:CD3F 0694            	   816:   asl  token_value        ; token_value shifted left 3 bits
00:CD41 2695            	   817:   rol  token_value+1
00:CD43 2696            	   818:   rol  token_value+2
00:CD45 B01D            	   819:   bcs  gc_hex_too_big
00:CD47 0694            	   820:   asl  token_value        ; token_value shifted left 4 bits
00:CD49 2695            	   821:   rol  token_value+1
00:CD4B 2696            	   822:   rol  token_value+2
00:CD4D B015            	   823:   bcs  gc_hex_too_big
00:CD4F 6594            	   824:   adc  token_value        ; now add in this last digit (carry will be clear)
00:CD51 8594            	   825:   sta  token_value        ; store the new result
00:CD53 90CF            	   826:   bcc  gc_hex_loop
00:CD55 E695            	   827:   inc  token_value+1
00:CD57 90CB            	   828:   bcc  gc_hex_loop
00:CD59 E695            	   829:   inc  token_value+1
00:CD5B B007            	   830:   bcs  gc_hex_too_big
00:CD5D 80C5            	   831:   bra  gc_hex_loop
                        	   832: 
                        	   833: gc_hex_done:
00:CD5F A94E            	   834:   lda #TOKEN_NUMBER
00:CD61 4CD3C9          	   835:   jmp gc_done
                        	   836: 
                        	   837: gc_hex_too_big:
00:CD64 A21E            	   838:   ldx  #30       ; ERROR: Number out of Range
00:CD66 4CCE97          	   839:   jmp  ERROR
                        	   840: 
                        	   841: ;
                        	   842: ;  %nnnnnn where nnnnnn is one or more binary digits
                        	   843: ;    if no binary digits, then it is the token '%'
                        	   844: ;
                        	   845: 
                        	   846: gc_percent:
00:CD69 A001            	   847:   ldy  #1    ; start with the character after the %
00:CD6B B18E            	   848:   lda  (token_start),Y ; followed by a binary character?
00:CD6D 206E81          	   849:   jsr  isbinary
00:CD70 B003            	   850:   bcs  gc_binary_literal
00:CD72 4CCFC9          	   851:   jmp  gc_single_byte_already_known
                        	   852: 
                        	   853: gc_binary_literal:
00:CD75 E930            	   854:   sbc #'0'              ; we know carry is set
00:CD77 8594            	   855:   sta token_value       ; store the first digit
00:CD79 6495            	   856:   stz token_value+1
00:CD7B 6496            	   857:   stz token_value+2
                        	   858: gc_binary_loop:
00:CD7D C8              	   859:   iny
00:CD7E B18E            	   860:   lda (token_start),Y ; followed by another binary character?
00:CD80 206E81          	   861:   jsr isbinary
00:CD83 90DA            	   862:   bcc gc_hex_done
00:CD85 E930            	   863:   sbc #'0'              ; we know carry is set
                        	   864: 
00:CD87 6A              	   865:   ror A   ; get the new bit into Carry
00:CD88 2694            	   866:   rol token_value
00:CD8A 2695            	   867:   rol token_value+1
00:CD8C 2696            	   868:   rol token_value+2
00:CD8E 90ED            	   869:   bcc gc_binary_loop
00:CD90 4C64CD          	   870:   jmp gc_hex_too_big   ; number too large
                        	   871: 
                        	   872: ;
                        	   873: ;  token : might be :=
                        	   874: ;
                        	   875: gc_colon:
00:CD93 A001            	   876:   ldy  #1               ; get the next character
00:CD95 B18E            	   877:   lda  (token_start),Y  ; followed by = ?
00:CD97 C93D            	   878:   cmp  #'='
00:CD99 F003            	   879:   beq  gc_assign
00:CD9B 4CCFC9          	   880:   jmp  gc_single_byte_already_known
                        	   881: 
                        	   882: gc_assign:
00:CD9E A941            	   883:   lda #TOKEN_ASSIGN
00:CDA0 C8              	   884:   iny
00:CDA1 4CD3C9          	   885:   jmp gc_done
                        	   886: 
                        	   887: ;
                        	   888: ;  token: < might be <=, <>, <<
                        	   889: ;
                        	   890: gc_less_than:
00:CDA4 A001            	   891:   ldy  #1               ; get the next character
00:CDA6 B18E            	   892:   lda  (token_start),Y  ; followed by = ?
00:CDA8 C8              	   893:   iny                   ; make it a 2-byte token
00:CDA9 C93D            	   894:   cmp  #'='
00:CDAB F00B            	   895:   beq  gc_leq
00:CDAD C93E            	   896:   cmp  #'>'
00:CDAF F00C            	   897:   beq  gc_neq
00:CDB1 C93C            	   898:   cmp  #'<'
00:CDB3 F00D            	   899:   beq  gc_shift_left
00:CDB5 4CCFC9          	   900:   jmp  gc_single_byte_already_known
                        	   901: 
                        	   902: gc_leq:
00:CDB8 A980            	   903:   lda #TOKEN_LEQ
00:CDBA 4CD3C9          	   904:   jmp gc_done
                        	   905: 
                        	   906: gc_neq:
00:CDBD A955            	   907:   lda #TOKEN_NEQ
00:CDBF 4CD3C9          	   908:   jmp gc_done
                        	   909: 
                        	   910: gc_shift_left:
00:CDC2 A94C            	   911:   lda #TOKEN_SHIFT_LEFT
00:CDC4 4CD3C9          	   912:   jmp gc_done
                        	   913: 
                        	   914: ;
                        	   915: ;  token: > might be <>=, >>
                        	   916: ;
                        	   917: gc_greater_than:
00:CDC7 A001            	   918:   ldy  #1               ; get the next character
00:CDC9 B18E            	   919:   lda  (token_start),Y  ; followed by = ?
00:CDCB C8              	   920:   iny                   ; make it a 2-byte token
00:CDCC C93D            	   921:   cmp  #'='
00:CDCE F007            	   922:   beq  gc_geq
00:CDD0 C93E            	   923:   cmp  #'>'
00:CDD2 F008            	   924:   beq  gc_shift_right
                        	   925: 
                        	   926: gc_single_byte_already_knownJ2:
00:CDD4 4CCFC9          	   927:   jmp  gc_single_byte_already_known
                        	   928: 
                        	   929: gc_geq:
00:CDD7 A981            	   930:   lda #TOKEN_GEQ
00:CDD9 4CD3C9          	   931:   jmp gc_done
                        	   932: 
                        	   933: gc_shift_right:
00:CDDC A952            	   934:   lda #TOKEN_SHIFT_RIGHT
00:CDDE 4CD3C9          	   935:   jmp gc_done
                        	   936: 
                        	   937: 
                        	   938: ;
                        	   939: ;  minus and plus sign
                        	   940: ;
                        	   941: 
                        	   942: gc_minus:
00:CDE1 8597            	   943:   sta token_sign
                        	   944: gc_plus:
                        	   945: 
                        	   946: ;
                        	   947: ;  new stuff - treat a sign as a token on its own if the previous token was one of:
                        	   948: ;    a) a number
                        	   949: ;    b) an identifier
                        	   950: ;    c) a RH bracket
                        	   951: ;
                        	   952: ;  So, for example: 2+3 is three tokens, but 2+-5 is also three, as the -5 becomes one token
                        	   953: ;
00:CDE3 A598            	   954:   lda  token_work            ; saved previous token on entry to get_token
00:CDE5 C94E            	   955:   cmp  #TOKEN_NUMBER
00:CDE7 F0EB            	   956:   beq  gc_single_byte_already_knownJ2
00:CDE9 C949            	   957:   cmp  #TOKEN_IDENTIFIER
00:CDEB F0E7            	   958:   beq  gc_single_byte_already_knownJ2
00:CDED C929            	   959:   cmp  #')'
00:CDEF F0E3            	   960:   beq  gc_single_byte_already_knownJ2
                        	   961: ;
                        	   962: ;  if not, see if this is a signed number (ie. it is directly followed by a digit)
                        	   963: ;
00:CDF1 A001            	   964:   ldy  #1               ; get the next character
00:CDF3 B18E            	   965:   lda  (token_start),Y  ; followed by a digit?
00:CDF5 203281          	   966:   jsr  isdigit
00:CDF8 90DA            	   967:   bcc  gc_single_byte_already_knownJ2
00:CDFA 207CCA          	   968:   jsr atoi
00:CDFD A94E            	   969:   lda  #TOKEN_NUMBER
00:CDFF 4CD3C9          	   970:   jmp  gc_done
                        	   971: 
                        	   972: 
                        	   973: ;
                        	   974: ;  token: & might be &&
                        	   975: ;
                        	   976: gc_ampersand:
00:CE02 A001            	   977:   ldy  #1               ; get the next character
00:CE04 B18E            	   978:   lda  (token_start),Y  ; followed by & ?
00:CE06 C926            	   979:   cmp  #'&'
00:CE08 F003            	   980:   beq  gc_logical_and
00:CE0A 4CCFC9          	   981:   jmp  gc_single_byte_already_known
                        	   982: 
                        	   983: gc_logical_and:
00:CE0D A958            	   984:   lda #TOKEN_LOGICAL_AND
00:CE0F C8              	   985:   iny
00:CE10 4CD3C9          	   986:   jmp gc_done
                        	   987: 
                        	   988: ;
                        	   989: ;  token: | might be ||
                        	   990: ;
                        	   991: gc_bar:
00:CE13 A001            	   992:   ldy  #1               ; get the next character
00:CE15 B18E            	   993:   lda  (token_start),Y  ; followed by | ?
00:CE17 C97C            	   994:   cmp  #'|'
00:CE19 F003            	   995:   beq  gc_logical_or
00:CE1B 4CCFC9          	   996:   jmp  gc_single_byte_already_known
                        	   997: 
                        	   998: gc_logical_or:
00:CE1E A959            	   999:   lda #TOKEN_LOGICAL_OR
00:CE20 C8              	  1000:   iny
00:CE21 4CD3C9          	  1001:   jmp gc_done
                        	  1002: 
                        	  1003: ;
                        	  1004: ;  token: = might be ==
                        	  1005: ;
                        	  1006: gc_equals:
00:CE24 A001            	  1007:   ldy  #1               ; get the next character
00:CE26 B18E            	  1008:   lda  (token_start),Y  ; followed by = ?
00:CE28 C93D            	  1009:   cmp  #'='
00:CE2A F003            	  1010:   beq  gc_equality
00:CE2C 4CCFC9          	  1011:   jmp  gc_single_byte_already_known
                        	  1012: 
                        	  1013: gc_equality:
00:CE2F A945            	  1014:   lda #TOKEN_EQUALITY
00:CE31 C8              	  1015:   iny
00:CE32 4CD3C9          	  1016:   jmp gc_done
                        	  1017: 
                        	  1018: ;
                        	  1019: ;  token: ! might be !=
                        	  1020: ;
                        	  1021: gc_bang:
00:CE35 A001            	  1022:   ldy  #1               ; get the next character
00:CE37 B18E            	  1023:   lda  (token_start),Y  ; followed by = ?
00:CE39 C93D            	  1024:   cmp  #'='
00:CE3B F003            	  1025:   beq  gc_inequality
00:CE3D 4CCFC9          	  1026:   jmp  gc_single_byte_already_known
                        	  1027: 
                        	  1028: gc_inequality:
00:CE40 A95A            	  1029:   lda #TOKEN_INEQUALITY
00:CE42 C8              	  1030:   iny
00:CE43 4CD3C9          	  1031:   jmp gc_done
                        	  1032: 
                        	  1033: 
                        	  1034: 
                        	  1035: ; Pascal tokens
                        	  1036: 
                        	  1037: TOKEN_CONST     = $82
                        	  1038: TOKEN_VAR       = $83
                        	  1039: TOKEN_ARRAY     = $84
                        	  1040: TOKEN_OF        = $85
                        	  1041: TOKEN_PROCEDURE = $86
                        	  1042: TOKEN_FUNCTION  = $87
                        	  1043: TOKEN_BEGIN     = $88
                        	  1044: TOKEN_END       = $89
                        	  1045: TOKEN_OR        = $8A
                        	  1046: TOKEN_DIV       = $8B
                        	  1047: TOKEN_MOD       = $8C
                        	  1048: TOKEN_AND       = $8D
                        	  1049: TOKEN_SHL       = $8E
                        	  1050: TOKEN_SHR       = $8F
                        	  1051: TOKEN_NOT       = $90
                        	  1052: TOKEN_MEM       = $91
                        	  1053: TOKEN_IF        = $92
                        	  1054: TOKEN_THEN      = $93
                        	  1055: TOKEN_ELSE      = $94
                        	  1056: TOKEN_CASE      = $95
                        	  1057: TOKEN_WHILE     = $96
                        	  1058: TOKEN_DO        = $97
                        	  1059: TOKEN_REPEAT    = $98
                        	  1060: TOKEN_UNTIL     = $99
                        	  1061: TOKEN_FOR       = $9A
                        	  1062: TOKEN_TO        = $9B
                        	  1063: TOKEN_DOWNTO    = $9C
                        	  1064: TOKEN_WRITE     = $9D
                        	  1065: TOKEN_READ      = $9E
                        	  1066: TOKEN_CALL      = $9F
                        	  1067: TOKEN_CHAR      = $A1
                        	  1068: TOKEN_MEMC      = $A2
                        	  1069: TOKEN_XOR       = $A4
                        	  1070: TOKEN_ADDRESS   = $A9
                        	  1071: TOKEN_CHR       = $AB
                        	  1072: TOKEN_HEX       = $AC
                        	  1073: ; $B0 to $DE used by message tokens
                        	  1074: TOKEN_LCDWRITE  = $F1
                        	  1075: TOKEN_INTEGER   = $FE
                        	  1076: TOKEN_WRITELN   = $FF
                        	  1077: 
                        	  1078: 
                        	  1079: 
                        	  1080: ; RESERVED WORD TABLE
                        	  1081: ;
                        	  1082: ;***********************************************
                        	  1083:          .macro makeToken  ; MACRO DEFINITION FOR TOKENS: Length, token number, token name
                        	  1084:          DFB  \1
                        	  1085:          DFB  \2
                        	  1086:          text  \3
                        	  1087:          .endmacro           ; END OF MACRO
                        	  1088: 
                        	  1089: ;
                        	  1090: ; Reserved words are identified internally by their code (eg. $86 for PROCEDURE)
                        	  1091: ;
                        	  1092: ;  They are also stored "tokenised" and expanded out when you list the source
                        	  1093: ;
                        	  1094: ; Other tokens are:
                        	  1095: ;  * Punctuation (eg. "<", ">", "=", ".", "(", ")", "$", "+", "-"
                        	  1096: ;  * Identifiers: "I"        (eg. MY_VARIABLE)
                        	  1097: ;  * Constant numbers: "N"   (eg. -1234 and $1234)
                        	  1098: ;  * Literal strings:  '"' (quote symbol)  (eg. "Nick")
                        	  1099: ;  * Double-character punctuation:
                        	  1100: ;       <= : $80
                        	  1101: ;       >= : $81
                        	  1102: ;       Unequal (<>) : "U"
                        	  1103: ;       Assignment (:=) : "A"
                        	  1104: ;
                        	  1105: ; Comments are skipped: (* some comment *)
                        	  1106: ;
                        	  1107: ;
                        	  1108: ; However comments can have compiler directives embedded, eg. (*%A $4000) - put P-codes at $4000
                        	  1109: ;    (*%L*) - list during compile
                        	  1110: ;    (*%N*) - stop listing during compile (cancels %L and %P)
                        	  1111: ;    (*%P*) - show P-codes during compile
                        	  1112: ;    (*%A  $nnnn *) - put P-codes at address $nnnn - must be at START of program
                        	  1113: ;
                        	  1114: ;
                        	  1115: 
                        	  1116: ;              Length   Code             Name
                        	  1117: ;                  --   --------------- ---------------
                        	  1118: RSVWRD   =  *
                        	  1119:    makeToken   5, TOKEN_CONST     ,"CONST"
00:CE46 05              	     1M          DFB  5
00:CE47 82              	     2M          DFB  TOKEN_CONST     
00:CE48 434F4E5354      	     3M          text  "CONST"
                        	  1120:    makeToken   3, TOKEN_VAR       ,"VAR"
00:CE4D 03              	     1M          DFB  3
00:CE4E 83              	     2M          DFB  TOKEN_VAR       
00:CE4F 564152          	     3M          text  "VAR"
                        	  1121:    makeToken   5, TOKEN_ARRAY     ,"ARRAY"
00:CE52 05              	     1M          DFB  5
00:CE53 84              	     2M          DFB  TOKEN_ARRAY     
00:CE54 4152524159      	     3M          text  "ARRAY"
                        	  1122:    makeToken   2, TOKEN_OF        ,"OF"
00:CE59 02              	     1M          DFB  2
00:CE5A 85              	     2M          DFB  TOKEN_OF        
00:CE5B 4F46            	     3M          text  "OF"
                        	  1123:    makeToken   9, TOKEN_PROCEDURE ,"PROCEDURE"
00:CE5D 09              	     1M          DFB  9
00:CE5E 86              	     2M          DFB  TOKEN_PROCEDURE 
00:CE5F 50524F4345445552	     3M          text  "PROCEDURE"
00:CE67 45
                        	  1124:    makeToken   8, TOKEN_FUNCTION  ,"FUNCTION"
00:CE68 08              	     1M          DFB  8
00:CE69 87              	     2M          DFB  TOKEN_FUNCTION  
00:CE6A 46554E4354494F4E	     3M          text  "FUNCTION"
                        	  1125:    makeToken   5, TOKEN_BEGIN     ,"BEGIN"
00:CE72 05              	     1M          DFB  5
00:CE73 88              	     2M          DFB  TOKEN_BEGIN     
00:CE74 424547494E      	     3M          text  "BEGIN"
                        	  1126:    makeToken   3, TOKEN_END       ,"END"
00:CE79 03              	     1M          DFB  3
00:CE7A 89              	     2M          DFB  TOKEN_END       
00:CE7B 454E44          	     3M          text  "END"
                        	  1127:    makeToken   2, TOKEN_OR        ,"OR"
00:CE7E 02              	     1M          DFB  2
00:CE7F 8A              	     2M          DFB  TOKEN_OR        
00:CE80 4F52            	     3M          text  "OR"
                        	  1128:    makeToken   3, TOKEN_DIV       ,"DIV"
00:CE82 03              	     1M          DFB  3
00:CE83 8B              	     2M          DFB  TOKEN_DIV       
00:CE84 444956          	     3M          text  "DIV"
                        	  1129:    makeToken   3, TOKEN_MOD       ,"MOD"
00:CE87 03              	     1M          DFB  3
00:CE88 8C              	     2M          DFB  TOKEN_MOD       
00:CE89 4D4F44          	     3M          text  "MOD"
                        	  1130:    makeToken   3, TOKEN_AND       ,"AND"
00:CE8C 03              	     1M          DFB  3
00:CE8D 8D              	     2M          DFB  TOKEN_AND       
00:CE8E 414E44          	     3M          text  "AND"
                        	  1131:    makeToken   3, TOKEN_SHL       ,"SHL"
00:CE91 03              	     1M          DFB  3
00:CE92 8E              	     2M          DFB  TOKEN_SHL       
00:CE93 53484C          	     3M          text  "SHL"
                        	  1132:    makeToken   3, TOKEN_SHR       ,"SHR"
00:CE96 03              	     1M          DFB  3
00:CE97 8F              	     2M          DFB  TOKEN_SHR       
00:CE98 534852          	     3M          text  "SHR"
                        	  1133:    makeToken   3, TOKEN_NOT       ,"NOT"
00:CE9B 03              	     1M          DFB  3
00:CE9C 90              	     2M          DFB  TOKEN_NOT       
00:CE9D 4E4F54          	     3M          text  "NOT"
                        	  1134:    makeToken   3, TOKEN_MEM       ,"MEM"
00:CEA0 03              	     1M          DFB  3
00:CEA1 91              	     2M          DFB  TOKEN_MEM       
00:CEA2 4D454D          	     3M          text  "MEM"
                        	  1135:    makeToken   2, TOKEN_IF        ,"IF"
00:CEA5 02              	     1M          DFB  2
00:CEA6 92              	     2M          DFB  TOKEN_IF        
00:CEA7 4946            	     3M          text  "IF"
                        	  1136:    makeToken   4, TOKEN_THEN      ,"THEN"
00:CEA9 04              	     1M          DFB  4
00:CEAA 93              	     2M          DFB  TOKEN_THEN      
00:CEAB 5448454E        	     3M          text  "THEN"
                        	  1137:    makeToken   4, TOKEN_ELSE      ,"ELSE"
00:CEAF 04              	     1M          DFB  4
00:CEB0 94              	     2M          DFB  TOKEN_ELSE      
00:CEB1 454C5345        	     3M          text  "ELSE"
                        	  1138:    makeToken   4, TOKEN_CASE      ,"CASE"
00:CEB5 04              	     1M          DFB  4
00:CEB6 95              	     2M          DFB  TOKEN_CASE      
00:CEB7 43415345        	     3M          text  "CASE"
                        	  1139:    makeToken   5, TOKEN_WHILE     ,"WHILE"
00:CEBB 05              	     1M          DFB  5
00:CEBC 96              	     2M          DFB  TOKEN_WHILE     
00:CEBD 5748494C45      	     3M          text  "WHILE"
                        	  1140:    makeToken   2, TOKEN_DO        ,"DO"
00:CEC2 02              	     1M          DFB  2
00:CEC3 97              	     2M          DFB  TOKEN_DO        
00:CEC4 444F            	     3M          text  "DO"
                        	  1141:    makeToken   6, TOKEN_REPEAT    ,"REPEAT"
00:CEC6 06              	     1M          DFB  6
00:CEC7 98              	     2M          DFB  TOKEN_REPEAT    
00:CEC8 524550454154    	     3M          text  "REPEAT"
                        	  1142:    makeToken   5, TOKEN_UNTIL     ,"UNTIL"
00:CECE 05              	     1M          DFB  5
00:CECF 99              	     2M          DFB  TOKEN_UNTIL     
00:CED0 554E54494C      	     3M          text  "UNTIL"
                        	  1143:    makeToken   3, TOKEN_FOR       ,"FOR"
00:CED5 03              	     1M          DFB  3
00:CED6 9A              	     2M          DFB  TOKEN_FOR       
00:CED7 464F52          	     3M          text  "FOR"
                        	  1144:    makeToken   2, TOKEN_TO        ,"TO"
00:CEDA 02              	     1M          DFB  2
00:CEDB 9B              	     2M          DFB  TOKEN_TO        
00:CEDC 544F            	     3M          text  "TO"
                        	  1145:    makeToken   6, TOKEN_DOWNTO    ,"DOWNTO"
00:CEDE 06              	     1M          DFB  6
00:CEDF 9C              	     2M          DFB  TOKEN_DOWNTO    
00:CEE0 444F574E544F    	     3M          text  "DOWNTO"
                        	  1146:    makeToken   5, TOKEN_WRITE     ,"WRITE"
00:CEE6 05              	     1M          DFB  5
00:CEE7 9D              	     2M          DFB  TOKEN_WRITE     
00:CEE8 5752495445      	     3M          text  "WRITE"
                        	  1147:    makeToken   4, TOKEN_READ      ,"READ"
00:CEED 04              	     1M          DFB  4
00:CEEE 9E              	     2M          DFB  TOKEN_READ      
00:CEEF 52454144        	     3M          text  "READ"
                        	  1148:    makeToken   4, TOKEN_CALL      ,"CALL"
00:CEF3 04              	     1M          DFB  4
00:CEF4 9F              	     2M          DFB  TOKEN_CALL      
00:CEF5 43414C4C        	     3M          text  "CALL"
                        	  1149:    makeToken   4, TOKEN_CHAR      ,"CHAR"
00:CEF9 04              	     1M          DFB  4
00:CEFA A1              	     2M          DFB  TOKEN_CHAR      
00:CEFB 43484152        	     3M          text  "CHAR"
                        	  1150:    makeToken   4, TOKEN_MEMC      ,"MEMC"
00:CEFF 04              	     1M          DFB  4
00:CF00 A2              	     2M          DFB  TOKEN_MEMC      
00:CF01 4D454D43        	     3M          text  "MEMC"
                        	  1151:    makeToken   3, TOKEN_XOR       ,"XOR"
00:CF05 03              	     1M          DFB  3
00:CF06 A4              	     2M          DFB  TOKEN_XOR       
00:CF07 584F52          	     3M          text  "XOR"
                        	  1152:    makeToken   7, TOKEN_ADDRESS   ,"ADDRESS"
00:CF0A 07              	     1M          DFB  7
00:CF0B A9              	     2M          DFB  TOKEN_ADDRESS   
00:CF0C 41444452455353  	     3M          text  "ADDRESS"
                        	  1153:    makeToken   3, TOKEN_CHR       ,"CHR"
00:CF13 03              	     1M          DFB  3
00:CF14 AB              	     2M          DFB  TOKEN_CHR       
00:CF15 434852          	     3M          text  "CHR"
                        	  1154:    makeToken   3, TOKEN_HEX       ,"HEX"
00:CF18 03              	     1M          DFB  3
00:CF19 AC              	     2M          DFB  TOKEN_HEX       
00:CF1A 484558          	     3M          text  "HEX"
                        	  1155:    makeToken   7, TOKEN_INTEGER   ,"INTEGER"
00:CF1D 07              	     1M          DFB  7
00:CF1E FE              	     2M          DFB  TOKEN_INTEGER   
00:CF1F 494E5445474552  	     3M          text  "INTEGER"
                        	  1156:    makeToken   7, TOKEN_WRITELN   ,"WRITELN"
00:CF26 07              	     1M          DFB  7
00:CF27 FF              	     2M          DFB  TOKEN_WRITELN   
00:CF28 57524954454C4E  	     3M          text  "WRITELN"
                        	  1157:    makeToken   8, TOKEN_LCDWRITE  ,"LCDWRITE"
00:CF2F 08              	     1M          DFB  8
00:CF30 F1              	     2M          DFB  TOKEN_LCDWRITE  
00:CF31 4C43445752495445	     3M          text  "LCDWRITE"
                        	  1158: 
                        	  1159: 
00:CF39 00              	  1160: RSVEND   DFB  0,0        ; END OF TABLE
00:CF3A 00
                        	  1161: ;
                        	  1162: 
                        	  1163: ;
                        	  1164: ;  Pascal get_token
                        	  1165: ;
                        	  1166: ;  Used in the Pascal section. Does a get_token, and then if an identifier is found tries to look
                        	  1167: ;  it up.
                        	  1168: ;
                        	  1169: pas_get_token:
00:CF3B 208DC9          	  1170:   jsr get_token
00:CF3E F004            	  1171:   beq pas_get_token_eof   ; branch to make sure Z flag stays set
00:CF40 C949            	  1172:   cmp #TOKEN_IDENTIFIER
00:CF42 F001            	  1173:   beq pas_gc_identifier
                        	  1174: pas_get_token_eof:
00:CF44 60              	  1175:   rts
                        	  1176: ;
                        	  1177: ;  here if get_token got an identifier
                        	  1178: ;
                        	  1179: pas_gc_identifier:
00:CF45 A946            	  1180:   lda  #<RSVWRD
00:CF47 8598            	  1181:   sta  token_work
00:CF49 A9CE            	  1182:   lda  #>RSVWRD
00:CF4B 8599            	  1183:   sta  token_work+1
                        	  1184: pas_gc_loop:
00:CF4D A000            	  1185:   ldy  #0
00:CF4F B198            	  1186:   lda  (token_work),Y
00:CF51 D003            	  1187:   bne  pas_gc_more        ; MORE TO GO
00:CF53 A949            	  1188:   lda  #TOKEN_IDENTIFIER
00:CF55 60              	  1189:   rts
                        	  1190: ;
                        	  1191: ; SEARCH for RESERVED WORD
                        	  1192: ;
                        	  1193: pas_gc_more:
00:CF56 B198            	  1194:   lda  (token_work),Y     ; length of word in table
00:CF58 C592            	  1195:   cmp  token_length       ; same?
00:CF5A D022            	  1196:   bne  pas_gc_no_match    ; no - can't be it then
00:CF5C A8              	  1197:   tay                     ; length
00:CF5D A590            	  1198:   lda  token_address      ; put token start address into SRCE
00:CF5F 8500            	  1199:   sta  SRCE
00:CF61 A591            	  1200:   lda  token_address+1
00:CF63 8501            	  1201:   sta  SRCE+1
00:CF65 A598            	  1202:   lda  token_work         ; put current token_work+2 into DEST
00:CF67 18              	  1203:   clc
00:CF68 6902            	  1204:   adc  #2
00:CF6A 8503            	  1205:   sta  DEST
00:CF6C A599            	  1206:   lda  token_work+1
00:CF6E 6900            	  1207:   adc  #0
00:CF70 8504            	  1208:   sta  DEST+1
00:CF72 200182          	  1209:   jsr  str_ic_compare
00:CF75 D007            	  1210:   bne  pas_gc_no_match      ; NOT FOUND
00:CF77 A001            	  1211:   ldy  #1
00:CF79 B198            	  1212:   lda  (token_work),Y
00:CF7B 8593            	  1213:   sta  token_type
00:CF7D 60              	  1214:   rts
                        	  1215: pas_gc_no_match    =  *
00:CF7E A000            	  1216:   ldy  #0
00:CF80 B198            	  1217:   lda  (token_work),Y     ; token_work points to reserved word entry
00:CF82 18              	  1218:   clc
00:CF83 6902            	  1219:   adc  #2         ; add 2 to bypass length and code
00:CF85 6598            	  1220:   adc  token_work
00:CF87 8598            	  1221:   sta  token_work         ; put it back
00:CF89 90C2            	  1222:   bcc  pas_gc_loop
00:CF8B E699            	  1223:   inc  token_work+1       ; handle overflow
00:CF8D 80BE            	  1224:   bra  pas_gc_loop     ; try for another
                        	  1225: 
                        	  1226: 
                        	  1227: 
                        	  1228: ;***********************************************
                        	  1229: ; GET A TOKEN - CHECK THAT IT
                        	  1230: ; IS THE SAME AS IN "A", IF NOT
                        	  1231: ; CALL ERROR "X"
                        	  1232: ;***********************************************
                        	  1233: GETCHK:
00:CF8F DA              	  1234:   phx   ; save error number
00:CF90 48              	  1235:   pha   ; save wanted token type
00:CF91 203BCF          	  1236:   jsr pas_get_token
00:CF94 68              	  1237:   pla   ; get it back
00:CF95 C593            	  1238:   cmp token_type
00:CF97 F004            	  1239:   beq CHKOK
00:CF99 FA              	  1240:   plx   ; get error number back
                        	  1241: CHKNOK   =  *
00:CF9A 4CCE97          	  1242:   jmp ERROR
                        	  1243: CHKOK    =  *
00:CF9D FA              	  1244:   plx   ; get error number back
00:CF9E 60              	  1245:   rts
                        	  1246: 
                        	  1247: ;***********************************************
                        	  1248: ; CHECK TOKEN AGREES WITH "A",
                        	  1249: ; IF NOT, GIVE ERROR "X"
                        	  1250: ;***********************************************
                        	  1251: CHKTKN:
00:CF9F C593            	  1252:   cmp  token_type
00:CFA1 D0F7            	  1253:   bne  CHKNOK
00:CFA3 60              	  1254:   rts
                        	  1255: 
                        	  1256: ;***********************************************
                        	  1257: ;
                        	  1258: ; GET NEXT TOKEN - MUST BE IDENTIFIER
                        	  1259: ; THEN LOOK IT UP IN SYMBOL TABLE
                        	  1260: ;***********************************************
                        	  1261: 
                        	  1262: GET_LOOK:
00:CFA4 A949            	  1263:   lda  #TOKEN_IDENTIFIER
00:CFA6 A204            	  1264:   ldx  #4      ; ERROR: Identifier expected
00:CFA8 208FCF          	  1265:   jsr  GETCHK
00:CFAB 4C2BBA          	  1266:   jmp  LOOKUP
                        	  1267: 

Source: "gpascal.asm"
                        	   187:   .include "i2c.inc"

Source: "i2c.inc"
                        	     1: ;
                        	     2: ;  I2C interface routines
                        	     3: ;
                        	     4: ; Author: Nick Gammon
                        	     5: ; Date: 2 March 2022
                        	     6: 
                        	     7: ; PROTOCOL
                        	     8: ;
                        	     9: ;  BUS NOT BUSY: Both data and clock lines remain HIGH.
                        	    10: ;
                        	    11: ;  START DATA TRANSFER: A change in the state of the data line, from HIGH to LOW, while the clock is
                        	    12: ;  HIGH, defines a START condition.
                        	    13: ;
                        	    14: ;  STOP DATA TRANSFER: A change in the state of the data line, from LOW to HIGH, while the clock line
                        	    15: ;  is HIGH, defines the STOP condition.
                        	    16: ;
                        	    17: ;  DATA VALID: The state of the data line represents valid data when, after a START condition, the data
                        	    18: ;  line is stable for the duration of the HIGH period of the clock signal. The data on the line must be
                        	    19: ;  changed during the LOW period of the clock signal. There is one clock pulse per bit of data.
                        	    20: ;  Each data transfer is initiated with a START co ndition and terminated with a STOP condition. The
                        	    21: ;  number of data bytes transferred between START and STOP conditions is not limited, and is
                        	    22: ;  determined by the master device. The information is transferred byte-wise and each receiver
                        	    23: ;  acknowledges with a ninth bit.
                        	    24: ;
                        	    25: ;  CLOCK STRETCHING
                        	    26: ;
                        	    27: ;  If a slave wants us to wait, or another master is attempting to take over the bus, SCL will not go
                        	    28: ;  high immediately after we set it to input (high impedance) so we therefore wait until SCL is in
                        	    29: ;  fact high before proceeding.
                        	    30: ;
                        	    31: ;  ARBITRATION
                        	    32: ;
                        	    33: ;  If two masters are attempting to write to the bus we can detect that as soon as one of them writes
                        	    34: ;  a one, but reads back a zero. This indicates that another master wrote the zero. The master that
                        	    35: ;  read back the one then abandons its attempt to write (to try again later).
                        	    36: ;
                        	    37: ;  Since, up to this point, both have read back what they wrote, the bus is not corrupted.
                        	    38: ;
                        	    39: 
                        	    40: 
                        	    41: ; Configuration of which VIA ports are used by SCL and SDA
                        	    42: 
                        	    43: I2C_SCL     = %00000100   ; SCL (serial clock) - PA2
                        	    44: I2C_SDA     = %00001000   ; SDA (serial data)  - PA3
                        	    45: 
                        	    46: I2C_PORT    = VIA_PORTA   ; PORT A
                        	    47: I2C_DDR     = VIA_DDRA    ; DDR  A
                        	    48: 
                        	    49: ;
                        	    50: ;  Initialise hardware for I2C comms.
                        	    51: ;
                        	    52: ;  Set SCL and SDA to high, however make the ports input for now
                        	    53: ;
                        	    54: i2c_init:
                        	    55: 
                        	    56: ;
                        	    57: ;  Set ports to low
                        	    58: ;
00:CFAE A90C            	    59:   lda #I2C_SCL | I2C_SDA
00:CFB0 1CF17F          	    60:   trb I2C_PORT
                        	    61: 
                        	    62: ;
                        	    63: ;  Set ports to input
                        	    64: ;
                        	    65: 
00:CFB3 A90C            	    66:   lda #I2C_SCL | I2C_SDA
00:CFB5 1CF37F          	    67:   trb I2C_DDR
                        	    68: 
                        	    69: 
00:CFB8 60              	    70:   rts
                        	    71: 
                        	    72: ;---------------------------------------------
                        	    73: ;  delay between clock bits - could make shorter if using a 1 MHz clock
                        	    74: ;---------------------------------------------
                        	    75: i2c_delay:
00:CFB9 EA              	    76:     nop
00:CFBA EA              	    77:     nop
00:CFBB EA              	    78:     nop
00:CFBC 60              	    79:     rts
                        	    80: 
                        	    81: ;---------------------------------------------
                        	    82: ;  toggle the SCL line from low to high and back again
                        	    83: ;---------------------------------------------
                        	    84: i2c_toggle_clock:
00:CFBD A904            	    85:   lda #I2C_SCL
00:CFBF 1CF37F          	    86:   trb I2C_DDR      ; SCL high
00:CFC2 20B9CF          	    87:   jsr i2c_delay
                        	    88: ;
                        	    89: ;  check if the slave wants us to wait by pulling the clock low
                        	    90: ;
                        	    91: i2c_toggle_clock_wait:
00:CFC5 ADF17F          	    92:   lda I2C_PORT
00:CFC8 2904            	    93:   and #I2C_SCL
00:CFCA F0F9            	    94:   beq i2c_toggle_clock_wait   ; should be high, but is low
                        	    95: ;
                        	    96: ;  we let the clock go high, and it actually IS high, so we can proceed
                        	    97: ;
00:CFCC 0CF37F          	    98:   tsb I2C_DDR       ; SCL low
00:CFCF A908            	    99:   lda #I2C_SDA      ; immediately set SDA to low
00:CFD1 1CF37F          	   100:   trb I2C_DDR
00:CFD4 20B9CF          	   101:   jsr i2c_delay
00:CFD7 60              	   102:   rts
                        	   103: 
                        	   104: ;---------------------------------------------
                        	   105: ;
                        	   106: ;  Begin transmission: send a start condition
                        	   107: ;
                        	   108: ;  Slave address in A, read/write bit in low-order bit
                        	   109: ;    0 = write, 1 = read
                        	   110: ;
                        	   111: ;  Sets carry if OK
                        	   112: ;
                        	   113: ;  START CONDITION:
                        	   114: ;
                        	   115: ;  A change in the state of the data line, from HIGH to LOW, while the clock is HIGH
                        	   116: ;---------------------------------------------
                        	   117: 
                        	   118: i2c_begin_transmission:
                        	   119: 
00:CFD8 48              	   120:   pha             ; save address
                        	   121: 
00:CFD9 20AECF          	   122:   jsr i2c_init    ; set ports to low, and ports to input
                        	   123: 
                        	   124: ;
                        	   125: ;  Check if SDA or SCL are in use (low) - if so, wait until they are not
                        	   126: ;
                        	   127: i2c_begin_transmission_loop:
00:CFDC A908            	   128:   lda #I2C_SDA
00:CFDE 2DF17F          	   129:   and I2C_PORT
00:CFE1 F0F9            	   130:   beq i2c_begin_transmission_loop
00:CFE3 A904            	   131:   lda #I2C_SCL
00:CFE5 2DF17F          	   132:   and I2C_PORT
00:CFE8 F0F2            	   133:   beq i2c_begin_transmission_loop
                        	   134: 
                        	   135: ;
                        	   136: ;  The start condition pulls SDA low but SCL stays high
                        	   137: ;
                        	   138: 
00:CFEA A908            	   139:   lda #I2C_SDA
00:CFEC 0CF37F          	   140:   tsb I2C_DDR
00:CFEF 20B9CF          	   141:   jsr i2c_delay
                        	   142: 
                        	   143: ;
                        	   144: ;  But now we pull SCL low ready for clocking out bits
                        	   145: ;
                        	   146: 
00:CFF2 A904            	   147:   lda #I2C_SCL
00:CFF4 0CF37F          	   148:   tsb I2C_DDR
00:CFF7 20B9CF          	   149:   jsr i2c_delay
                        	   150: 
00:CFFA 68              	   151:   pla   ; get address back
                        	   152: 
00:CFFB 20FFCF          	   153:   jsr i2c_write
                        	   154: 
00:CFFE 60              	   155:   rts
                        	   156: 
                        	   157: ;---------------------------------------------
                        	   158: ;
                        	   159: ;  I2C write: send 8 data bits, wait for acknowledge
                        	   160: ;
                        	   161: ;---------------------------------------------
                        	   162: 
                        	   163: i2c_write:
00:CFFF A208            	   164:   ldx #8  ; count of bits
00:D001 A8              	   165:   tay
                        	   166: 
                        	   167: i2c_write_loop:
00:D002 98              	   168:   tya
00:D003 2A              	   169:   rol a   ; get bit to write into carry
00:D004 A8              	   170:   tay
                        	   171: 
00:D005 B007            	   172:   bcs i2c_write_one
                        	   173: ;
                        	   174: ;  write a zero by setting SDA to output
                        	   175: ;
00:D007 A908            	   176:   lda #I2C_SDA
00:D009 0CF37F          	   177:   tsb I2C_DDR
00:D00C 800B            	   178:   bra i2c_write_clock
                        	   179: ;
                        	   180: ;  write a one by setting SDA to input
                        	   181: ;
                        	   182: i2c_write_one:
00:D00E A908            	   183:   lda #I2C_SDA
00:D010 1CF37F          	   184:   trb I2C_DDR
                        	   185: ;
                        	   186: ;  if SDA is not high, another master has taken control of the bus, abandon this write
                        	   187: ;
00:D013 EA              	   188:   nop
00:D014 2DF17F          	   189:   and I2C_PORT
00:D017 F028            	   190:   beq i2c_write_lost_arbitration   ; error return, give up
                        	   191: 
                        	   192: ;---------------------------------------------
                        	   193: ;
                        	   194: ;  toggle clock
                        	   195: ;
                        	   196: ;---------------------------------------------
                        	   197: i2c_write_clock:
00:D019 20BDCF          	   198:   jsr i2c_toggle_clock
                        	   199: ;
                        	   200: ;  back for another bit?
                        	   201: ;
00:D01C CA              	   202:   dex
00:D01D D0E3            	   203:   bne i2c_write_loop
                        	   204: 
                        	   205:   ;---------------------------------------------
                        	   206:   ;  wait for acknowledge bit
                        	   207:   ;---------------------------------------------
                        	   208: 
                        	   209:   ;
                        	   210:   ;  make SDA input and see if it is pulled low
                        	   211:   ;
                        	   212: 
00:D01F A908            	   213:   lda #I2C_SDA
00:D021 1CF37F          	   214:   trb I2C_DDR         ; SDA to input
                        	   215: 
00:D024 A904            	   216:   lda #I2C_SCL        ; clock high
00:D026 1CF37F          	   217:   trb I2C_DDR
                        	   218: 
                        	   219: ;
                        	   220: ;  check if the slave wants us to wait by pulling the clock low
                        	   221: ;
                        	   222: i2c_write_clock_wait:
00:D029 ADF17F          	   223:   lda I2C_PORT
00:D02C 2904            	   224:   and #I2C_SCL
00:D02E F0F9            	   225:   beq i2c_write_clock_wait   ; should be high, but is low
                        	   226: 
00:D030 20B9CF          	   227:   jsr i2c_delay       ; give it time to respond
                        	   228: 
00:D033 A908            	   229:   lda #I2C_SDA
00:D035 2DF17F          	   230:   and I2C_PORT        ; read SDA
                        	   231: 
00:D038 AA              	   232:   tax                 ; save result for a moment
00:D039 A904            	   233:   lda #I2C_SCL        ; clock low
00:D03B 0CF37F          	   234:   tsb I2C_DDR
                        	   235: 
00:D03E 8A              	   236:   txa             ; get ack/nak bit back
                        	   237: 
00:D03F F002            	   238:   beq i2c_write_got_ack
                        	   239: 
                        	   240: i2c_write_lost_arbitration:
00:D041 18              	   241:   clc   ; error return
00:D042 60              	   242:   rts
                        	   243: 
                        	   244: i2c_write_got_ack:
00:D043 38              	   245:   sec   ; carry means OK
00:D044 60              	   246:   rts
                        	   247: 
                        	   248: 
                        	   249: ;---------------------------------------------
                        	   250: ;
                        	   251: ;  I2C read: receive 8 data bits, then acknowledge unless hardware_work is zero
                        	   252: ;    hardware_work will be the count of outstanding bytes to be sent
                        	   253: ;    on the last bit we NAK it to tell the sender not to send any more
                        	   254: ;
                        	   255: ;---------------------------------------------
                        	   256: 
                        	   257: i2c_read:
00:D045 A208            	   258:   ldx #8  ; count of bits
00:D047 A000            	   259:   ldy #0  ; current result
                        	   260: 
00:D049 A908            	   261:   lda #I2C_SDA
00:D04B 1CF37F          	   262:   trb I2C_DDR         ; SDA to input
                        	   263: 
                        	   264: i2c_read_loop:
                        	   265: 
00:D04E A904            	   266:   lda #I2C_SCL        ; clock high
00:D050 1CF37F          	   267:   trb I2C_DDR
00:D053 20B9CF          	   268:   jsr i2c_delay       ; give it time to respond
                        	   269: 
00:D056 A908            	   270:   lda #I2C_SDA
00:D058 2DF17F          	   271:   and I2C_PORT        ; read SDA
00:D05B F006            	   272:   beq i2c_read_zero
                        	   273: ;
                        	   274: ;  read a 1
                        	   275: ;
00:D05D 98              	   276:   tya       ; get previous result
00:D05E 38              	   277:   sec
00:D05F 2A              	   278:   rol a     ; rotate in a one-bit
00:D060 A8              	   279:   tay       ; keep for later
00:D061 8004            	   280:   bra i2c_read_next
                        	   281: 
                        	   282: ;
                        	   283: ;  read a 0
                        	   284: ;
                        	   285: i2c_read_zero:
00:D063 98              	   286:   tya       ; get previous result
00:D064 18              	   287:   clc
00:D065 2A              	   288:   rol a     ; rotate in a zero-bit
00:D066 A8              	   289:   tay       ; keep for later
                        	   290: 
                        	   291: i2c_read_next:
                        	   292: 
00:D067 A904            	   293:   lda #I2C_SCL        ; clock low
00:D069 0CF37F          	   294:   tsb I2C_DDR
00:D06C 20B9CF          	   295:   jsr i2c_delay       ; give it time to respond
                        	   296: 
                        	   297: ;
                        	   298: ;  back for another bit?
                        	   299: ;
00:D06F CA              	   300:   dex
00:D070 D0DC            	   301:   bne i2c_read_loop
                        	   302: 
00:D072 A58C            	   303:   lda hardware_work   ; NAK on last read so they stop sending
00:D074 F007            	   304:   beq i2c_read_nak
                        	   305: 
00:D076 A908            	   306:   lda #I2C_SDA
00:D078 0CF37F          	   307:   tsb I2C_DDR         ; pull SDA low to ACK the byte
00:D07B 8005            	   308:   bra i2c_read_ack_or_nak
                        	   309: 
                        	   310: i2c_read_nak:
00:D07D A908            	   311:   lda #I2C_SDA
00:D07F 1CF37F          	   312:   trb I2C_DDR         ; pull SDA high to NAK the final byte
                        	   313: 
                        	   314: i2c_read_ack_or_nak:
                        	   315: 
00:D082 A904            	   316:   lda #I2C_SCL        ; clock high
00:D084 1CF37F          	   317:   trb I2C_DDR
                        	   318: 
                        	   319: ;
                        	   320: ;  check if the slave wants us to wait by pulling the clock low
                        	   321: ;   (clock stretching)
                        	   322: ;
                        	   323: 
                        	   324: i2c_read_ack_or_nak_wait:
00:D087 ADF17F          	   325:   lda I2C_PORT
00:D08A 2904            	   326:   and #I2C_SCL
00:D08C F0F9            	   327:   beq i2c_read_ack_or_nak_wait   ; should be high, but is low
                        	   328: 
00:D08E 20B9CF          	   329:   jsr i2c_delay       ; give it time to respond
                        	   330: 
00:D091 A904            	   331:   lda #I2C_SCL        ; clock low
00:D093 0CF37F          	   332:   tsb I2C_DDR
00:D096 20B9CF          	   333:   jsr i2c_delay
                        	   334: 
                        	   335: i2c_read_done:
                        	   336: 
00:D099 98              	   337:   tya                 ; result in A
00:D09A 60              	   338:   rts
                        	   339: 
                        	   340: 
                        	   341: ;---------------------------------------------
                        	   342: ;  end transmission - send stop condition
                        	   343: ;
                        	   344: ;  STOP CONDITION:
                        	   345: ;
                        	   346: ;  A change in the state of the data line, from LOW to HIGH, while the clock is HIGH
                        	   347: ;---------------------------------------------
                        	   348: 
                        	   349: i2c_end_transmission:
                        	   350: 
                        	   351: ;
                        	   352: ;  make sure SDA is low, otherwise it can't transition low to high
                        	   353: ;
00:D09B A908            	   354:   lda #I2C_SDA
00:D09D 0CF37F          	   355:   tsb I2C_DDR
                        	   356: 
00:D0A0 20B9CF          	   357:   jsr i2c_delay
                        	   358: 
                        	   359: ;
                        	   360: ;  Set SCL to input so it floats high
                        	   361: ;
00:D0A3 A904            	   362:   lda #I2C_SCL
00:D0A5 1CF37F          	   363:   trb I2C_DDR
                        	   364: 
00:D0A8 20B9CF          	   365:   jsr i2c_delay
                        	   366: 
                        	   367: ;
                        	   368: ;  Now with SCL high, set SDA to input so it also floats high
                        	   369: ;
00:D0AB A908            	   370:   lda #I2C_SDA
00:D0AD 1CF37F          	   371:   trb I2C_DDR
                        	   372: 
00:D0B0 20B9CF          	   373:   jsr i2c_delay
                        	   374: 
                        	   375: ;
                        	   376: ;  Both SDA and SCL are now high (by the pull-up resistors) so we are done
                        	   377: ;
00:D0B3 60              	   378:   rts
                        	   379: 
                        	   380: ;---------------------------------------------
                        	   381: ;
                        	   382: ;  Send a message, address in A (excluding write bit)
                        	   383: ;  Message in (VALUE)
                        	   384: ;  Length in Y
                        	   385: ;  Returns carry set on success, carry clear on failure
                        	   386: ;
                        	   387: ;---------------------------------------------
                        	   388: i2c_send_message:
00:D0B4 848C            	   389:   sty hardware_work
00:D0B6 0A              	   390:   asl A     ; move zero into write bit
00:D0B7 20D8CF          	   391:   jsr i2c_begin_transmission
00:D0BA 901C            	   392:   bcc i2c_send_message_fail
                        	   393: 
                        	   394: ;
                        	   395: ;  send each byte
                        	   396: ;
                        	   397: i2c_send_message_loop:
00:D0BC A58C            	   398:   lda hardware_work           ; number of bytes to go
00:D0BE F013            	   399:   beq i2c_send_message_done
00:D0C0 C68C            	   400:   dec hardware_work
00:D0C2 A000            	   401:   ldy #0
00:D0C4 B100            	   402:   lda (VALUE),Y
00:D0C6 20FFCF          	   403:   jsr i2c_write
00:D0C9 900D            	   404:   bcc i2c_send_message_fail
00:D0CB E600            	   405:   inc VALUE
00:D0CD D0ED            	   406:   bne i2c_send_message_loop
00:D0CF E601            	   407:   inc VALUE+1
00:D0D1 80E9            	   408:   bra i2c_send_message_loop
                        	   409: ;
                        	   410: ;  sending done
                        	   411: ;
                        	   412: i2c_send_message_done:
00:D0D3 209BD0          	   413:   jsr i2c_end_transmission
00:D0D6 38              	   414:   sec
00:D0D7 60              	   415:   rts
                        	   416: ;
                        	   417: ;  sending failure
                        	   418: ;
                        	   419: i2c_send_message_fail:
00:D0D8 209BD0          	   420:   jsr i2c_end_transmission
00:D0DB 18              	   421:   clc
00:D0DC 60              	   422:   rts
                        	   423: 
                        	   424: ;---------------------------------------------
                        	   425: ;
                        	   426: ;  Receive messave, slave address in A (excluding write bit)
                        	   427: ;  Message in (VALUE)
                        	   428: ;  Length in Y
                        	   429: ;---------------------------------------------
                        	   430: 
                        	   431: i2c_receive_message:
00:D0DD 848C            	   432:   sty hardware_work
00:D0DF 38              	   433:   sec
00:D0E0 2A              	   434:   rol A   ; move one into write bit (so it is read mode)
00:D0E1 20D8CF          	   435:   jsr i2c_begin_transmission
00:D0E4 901F            	   436:   bcc i2c_receive_message_fail
                        	   437: 
                        	   438: ;
                        	   439: ;  put serial data (SDA) into input mode so we can read from it
                        	   440: ;
00:D0E6 A908            	   441:   lda #I2C_SDA
00:D0E8 1CF37F          	   442:   trb I2C_DDR
                        	   443: 
                        	   444: ;
                        	   445: ;  receive each byte
                        	   446: ;
                        	   447: i2c_receive_message_loop:
00:D0EB A58C            	   448:   lda hardware_work           ; number of bytes to go
00:D0ED F011            	   449:   beq i2c_receive_message_done
00:D0EF C68C            	   450:   dec hardware_work
00:D0F1 2045D0          	   451:   jsr i2c_read
00:D0F4 A000            	   452:   ldy #0
00:D0F6 9100            	   453:   sta (VALUE),Y
00:D0F8 E600            	   454:   inc VALUE
00:D0FA D0EF            	   455:   bne i2c_receive_message_loop
00:D0FC E601            	   456:   inc VALUE+1
00:D0FE 80EB            	   457:   bra i2c_receive_message_loop
                        	   458: ;
                        	   459: ;  receiving done
                        	   460: ;
                        	   461: i2c_receive_message_done:
00:D100 209BD0          	   462:   jsr i2c_end_transmission
00:D103 38              	   463:   sec
00:D104 60              	   464:   rts
                        	   465: ;
                        	   466: ;  receiving failure
                        	   467: ;
                        	   468: i2c_receive_message_fail:
00:D105 209BD0          	   469:   jsr i2c_end_transmission
00:D108 18              	   470:   clc
00:D109 60              	   471:   rts
                        	   472: 
                        	   473: 

Source: "gpascal.asm"
                        	   188: 
                        	   189: 
                        	   190:   .if LCD_SUPPORT
00:D10A 4E69636B27732047	   191: LCD_welcome asciiz "Nick's G-Pascal\nCompiler v4.01"
00:D112 2D50617363616C0A
00:D11A 436F6D70696C6572
00:D122 2076342E3031
00:D128 00
                        	   192:   .endif
                        	   193: 
                        	   194: ;
                        	   195: ; here for cold start - clear text file to null etc. etc.
                        	   196: ;
                        	   197: START    =  *
00:D129 D8              	   198:   cld             ; cancel decimal mode
00:D12A 78              	   199:   sei             ; no interrupts yet
00:D12B A9FF            	   200:   lda #$FF
00:D12D 8509            	   201:   sta random      ; initialise random numbers
00:D12F 850A            	   202:   sta random+1
00:D131 850B            	   203:   sta random+2
00:D133 850C            	   204:   sta random+3
                        	   205: ;
                        	   206: ;  Put 0x00 at start of source
                        	   207: ;
00:D135 A900            	   208:   lda  #<TEXT_START
00:D137 8500            	   209:   sta  REG
00:D139 A903            	   210:   lda  #>TEXT_START
00:D13B 8501            	   211:   sta  REG+1
00:D13D A900            	   212:   lda  #0
00:D13F A8              	   213:   tay
00:D140 9100            	   214:   sta  (REG),Y     ; null edit file
00:D142 84BE            	   215:   sty  system_flags
00:D144 AA              	   216:   tax
                        	   217: ;
                        	   218: ;  now do rest of initialization
                        	   219: ;
                        	   220: RESTART  =  *
00:D145 A2FF            	   221:   ldx  #NEW_STK
00:D147 9A              	   222:   txs             ; reset stack
00:D148 58              	   223:   cli             ; allow interrupts after a NMI
00:D149 D8              	   224:   cld             ; cancel decimal mode
00:D14A 2026C9          	   225:   jsr hardware_init
                        	   226: 
                        	   227: ;
                        	   228: REST1    =  *
                        	   229:   .if LCD_SUPPORT
                        	   230:     ;
                        	   231:     ;  put message on the LCD screen to prove it is working
                        	   232:     ;
00:D14D A90A            	   233:     lda  #<LCD_welcome  ; G-pascal compiler
00:D14F A2D1            	   234:     ldx  #>LCD_welcome
00:D151 20FFB8          	   235:     jsr lcd_print_message
                        	   236:   .endif
                        	   237: 
                        	   238: ;
                        	   239: ;  now direct output to the serial port
                        	   240: ;
00:D154 20F9C8          	   241:   jsr  write_to_serial   ; set up outputting function
00:D157 A900            	   242:   lda  #0
00:D159 853F            	   243:   sta  RUNNING
00:D15B 4CC682          	   244:   jmp  main_start    ; go to "shell"
                        	   245: 
                        	   246: 
                        	   247: ;
                        	   248: ;  processor hardware vectors
                        	   249: ;
                        	   250:   .org $FFFA
01:FFFA 45D1            	   251:   .word RESTART   ; non-maskable interrupt (NMI)
01:FFFC 29D1            	   252:   .word START     ; reset vector
01:FFFE 1EB7            	   253:   .word irq       ; maskable interrupt (IRQ)
                        	   254: 


Symbols by name:
ACT_PCDA                         S:0025
ADD1                             E:B9EB
ADD4                             E:BA0E
ADD9                             E:BA2A
ADDSYM                           E:B98F
ADDSYM_NOT_FULL                  A:B9C4
ASS1                             A:BE5C
ASS2                             A:BEA4
ASSARR                           A:BE83
ASSEMBLE                         A:98AC
ASSEMBLE_PASS                    A:98BE
ASSEMBLE_SECOND_PASS             A:98B9
ASSIGN                           A:BE59
ASSTB1                           A:BE68
ASSVAR                           A:BE95
ASS_COUNT                        S:0072
ASS_EMIT_COUNT                   S:006F
ASS_OPCODE_WORK                  S:0070
ASS_OPERAND                      S:006B
ASS_OPERAND_ABSOLUTE             E:0001
ASS_OPERAND_ABSOLUTE_INDEXED_IN  E:0002
ASS_OPERAND_ABSOLUTE_INDEXED_WI  E:0003
ASS_OPERAND_ABSOLUTE_INDEXED_WI  E:0004
ASS_OPERAND_ABSOLUTE_INDIRECT    E:0005
ASS_OPERAND_ACCUMULATOR_A        E:0006
ASS_OPERAND_IMMEDIATE            E:0007
ASS_OPERAND_IMPLIED              E:0008
ASS_OPERAND_STRING               E:0011
ASS_OPERAND_ZERO_PAGE            E:000B
ASS_OPERAND_ZERO_PAGE_AND_ABSOL  E:0012
ASS_OPERAND_ZERO_PAGE_INDEXED_I  E:000C
ASS_OPERAND_ZERO_PAGE_INDEXED_W  E:000D
ASS_OPERAND_ZERO_PAGE_INDEXED_W  E:000E
ASS_OPERAND_ZERO_PAGE_INDIRECT   E:000F
ASS_OPERAND_ZERO_PAGE_INDIRECT_  E:0010
ASS_PASS                         S:0076
ASS_VALUE                        S:0073
BACKSPACE                        E:0008
BAD_INP                          A:B322
BASE                             S:003B
BAUD_RATE                        E:12C0
BEG                              A:C109
BELL1                            E:AEDA
BIT_INTERVAL                     E:00D0
BLCKT1                           A:C32A
BLCKT2                           A:C32D
BLCKT3                           A:C330
BLK1                             A:C365
BLK1A                            A:C351
BLK2                             A:C36D
BLK4                             A:C377
BLKB1                            A:C5CD
BLKB2                            A:C5E9
BLKB3                            A:C5C7
BLKB4                            A:C605
BLKB5                            A:C5F6
BLKB6                            A:C614
BLKBEG                           A:C5BD
BLKCN1                           A:C384
BLKCNS                           A:C381
BLKFNC                           A:C4F5
BLKPR1                           A:C517
BLKPR2                           A:C549
BLKPR3                           A:C533
BLKPR4                           A:C591
BLKPR5                           E:C56A
BLKPR6                           A:C540
BLKPRC                           A:C4D5
BLKV10                           E:C3CB
BLKV10_A                         E:C3E7
BLKV10_B                         E:C3EE
BLKV11                           A:C455
BLKV12                           A:C45C
BLKV13                           A:C416
BLKVAR                           A:C398
BLKVR1                           A:C39C
BLKVR2                           A:C3FD
BLKVR3                           A:C4BD
BLKVR4                           A:C41B
BLKVR5                           E:C47B
BLKVR6                           A:C39F
BLKVR7                           A:C3A9
BLKVR8                           A:C3C8
BLKVR9                           E:C462
BLOCK                            A:C33A
BSAVE                            S:0036
CALL                             S:0047
CALLSB                           A:C035
CASE                             A:C175
CASE1                            A:C1AE
CASE2                            E:C187
CASE3                            A:C1C4
CASE4                            A:C1BA
CASE5                            A:C1F7
CASE6                            A:C215
CASE7                            A:C183
CASE8                            A:C22A
CASE9                            A:C220
CHKDUP                           A:BA36
CHKGET                           E:C303
CHKLHB                           E:BAB1
CHKLHP                           E:BA97
CHKNOK                           E:CF9A
CHKOK                            E:CF9D
CHKRHB                           E:BABB
CHKRHP                           E:BA9E
CHKTKN                           A:CF9F
CHK_KBD                          E:AF2E
CHK_NOTD                         A:AF56
CHK_NOTN                         A:AF3A
CHK_NOTT                         A:AF48
CHK_RUN                          A:93D5
CHK_STAK                         E:BBBD
CHK_VAL                          E:93C2
CHK_VAL9                         E:93D4
CHRIN                            E:C90F
CLOCK_RATE                       E:4240
COMPIL                           A:BA46
COMS8                            A:92A4
COMS9                            A:92A3
COMSTL                           E:9297
CONDEC                           E:BAD6
CONST                            E:BBC9
CONST1                           A:BBE0
CONST2                           A:BBEA
CONST3                           E:BBE5
CONST9                           A:BBEE
COUNT1                           S:004B
COUNT2                           S:004C
COUT                             A:9419
COUT_CALL                        A:9423
CR                               E:000D
CROUT                            E:9292
DATA                             S:003D
DATTYP                           S:004A
DB11                             A:ADF3
DBGFLG                           S:0049
DCODE                            S:002E
DEBUG                            E:ADF3
DEBUG_DONE                       A:AE5B
DEST                             E:0003
DIRECTIVES                       E:A025
DIS5                             A:AEC3
DIS5_A                           E:AECD
DISHX                            A:92A7
DISP9                            A:C7CF
DISPAD                           E:92AD
DISPAD2                          A:92C8
DISPL                            S:0027
DIVBY0                           A:B0D8
DM1                              A:ADD8
DM2                              A:ADE1
DM5                              A:AE82
DM6                              A:AE97
DM7                              A:AEA2
DUP9                             A:BA45
EFLAG_ALLOW_ZERO_FROM            E:0002
EFLAG_FIND                       E:0010
EFLAG_LOAD                       E:0004
EFLAG_NO_LINE_NUMBERS            E:0080
EFLAG_REPLACE                    E:0020
EFLAG_SAVE                       E:0008
EFLAG_SHOW_LINE                  E:0001
EFLAG_SUPPRESS_NEWLINE           E:0040
EMULATOR                         E:0000
EMULATOR_DEBUG                   A:C923
ENDSYM                           S:0031
END_CMP                          E:BA94
END_EDITOR_INPUT                 E:001B
END_PCD                          S:0043
END_WRK                          E:C31F
ERR1                             E:97E1
ERR3                             E:97F5
ERR5                             E:9805
ERR6                             E:980B
ERR7                             E:97D7
ERRLIT                           A:97C2
ERRNO                            S:0035
ERROR                            A:97CE
EXPR1                            A:BDE5
EXPR2                            A:BE07
EXPR3                            A:BE0D
EXPR4                            A:BE11
EXPR5                            A:BE15
EXPR6                            A:BE19
EXPR7                            A:BE1D
EXPR8                            A:BE09
EXPRES                           A:BDC2
EXPTB1                           A:BDD2
EXPTB3                           A:BDF4
EX_ABS                           A:B0FC
EX_ABSCLL                        E:B391
EX_ADD                           A:B098
EX_ADRAC                         E:B570
EX_ADRAN                         E:B56A
EX_ADRN2                         E:B55F
EX_ADRNC                         E:B54C
EX_ADRNC2                        E:B54F
EX_ADRNN                         E:B55C
EX_AND                           A:B16A
EX_ASSERT                        A:B603
EX_ASSERT_OK                     A:B618
EX_CLA                           A:B427
EX_CLL                           E:B398
EX_CLL2                          E:B3C2
EX_CLL3                          E:B3E3
EX_CLL4                          E:B3BE
EX_CLL5                          E:B424
EX_CLL_A                         E:B3A0
EX_CLL_JMP                       A:B444
EX_DEC                           A:B1AC
EX_DELAY                         E:B5BF
EX_DIGITALREAD                   E:B576
EX_DIGITALREAD_ONE               A:B581
EX_DIGITALWRITE                  E:B5EE
EX_DIV                           A:B0E8
EX_DIVIDE_BY_ZERO                A:B0D1
EX_EOR                           A:B173
EX_EQL                           A:B105
EX_FINISHD                       E:AEF8
EX_GEQ                           A:B140
EX_GETKEY                        E:B0B6
EX_GTR                           A:B134
EX_INC                           A:B194
EX_INP                           E:B2EA
EX_INPC                          A:B4B2
EX_INPC_OK                       A:B4BC
EX_INP_OK                        A:B2FB
EX_INS                           E:B4EE
EX_INS1                          E:B511
EX_INS2                          E:B51A
EX_INS3                          E:B4F8
EX_INS4                          E:B524
EX_INT                           A:B447
EX_INVINS                        E:AFAB
EX_JM1                           A:B4A7
EX_JMP                           A:B483
EX_JMZ                           A:B496
EX_LATENCY                       A:B5B0
EX_LCDCLEAR                      A:B4E8
EX_LCDHOME                       A:B4E2
EX_LCDPOS                        E:B584
EX_LCDPOS_1                      A:B594
EX_LCD_WRITE_CHR                 A:B4D1
EX_LCD_WRITE_HEX                 A:B343
EX_LCD_WRITE_NUM                 A:B32F
EX_LCD_WRITE_STR                 A:B363
EX_LDA                           A:B208
EX_LDAC                          A:B1FD
EX_LDI                           A:B243
EX_LDIC                          A:B23D
EX_LEQ                           A:B14C
EX_LIB_CALL                      A:B5FD
EX_LIT                           A:B07D
EX_LOD                           A:B1E7
EX_LOD2                          A:B1EA
EX_LOD3                          A:B1D8
EX_LOD3_A                        A:B1DA
EX_LODC                          A:B1D5
EX_LSS                           A:B128
EX_MOD                           A:B0BD
EX_MOV                           A:B1C4
EX_MUL                           A:B0AD
EX_NEG                           A:B08F
EX_NEQ                           A:B11F
EX_NEW_STACK                     A:B471
EX_NOJUMP                        A:B4A1
EX_ORR                           A:B161
EX_OUH                           A:B33E
EX_OUH_COMMON                    A:B346
EX_OUS                           E:B35E
EX_OUS1                          A:B382
EX_OUS_COMMON                    A:B366
EX_OUT                           A:B32A
EX_OUTC                          A:B4CC
EX_OUTCR                         E:AF58
EX_OUTC_COMMON                   A:B4D4
EX_PINMODE                       E:B5DF
EX_RANDOM                        A:B59E
EX_RANDOMSEED                    E:B5CF
EX_RTN                           A:B2B1
EX_SHL                           A:B17C
EX_SHR                           A:B188
EX_STA                           A:B269
EX_STA5                          A:B27A
EX_STAC                          A:B27F
EX_STI                           A:B296
EX_STIC                          A:B288
EX_STO                           A:B256
EX_STO2                          A:B25C
EX_STO5                          A:B251
EX_STOC                          A:B249
EX_SUB                           A:B0A1
EX_XOR                           A:B158
FACAD1                           A:BD10
FACAD2                           A:BD2E
FACADR                           E:BD58
FACERR1                          A:BD71
FACM2                            A:BD8C
FACMEM                           A:BD82
FACMMC                           A:BD88
FACNOT                           A:BD98
FACNUM                           E:BD76
FACRND1                          A:BDA3
FACSTR                           A:BD6B
FACTB1                           A:BDA9
FACTOR                           A:BCC1
FACTQT1                          A:BDAF
FALSE                            A:B11B
FFLAG_GLOBAL                     E:0002
FFLAG_IGNORE_CASE                E:0001
FFLAG_QUIET                      E:0004
FIN_MSG                          A:AF0F
FIXAD                            E:C818
FIXAD1                           A:C855
FIXM1                            A:C856
FIXM2                            A:C85F
FLAG_ABORTED                     E:0080
FLAG_ASSEMBLING                  E:0002
FLAG_COMPILING                   E:0001
FLAG_LIST_SOURCE                 E:0004
FLAG_ONLY_ALPHA                  E:0040
FLAG_VALID_ASSEMBLE              E:0010
FLAG_VALID_COMPILE               E:0008
FNC1                             A:C07F
FNC2                             A:C04F
FNC3                             A:C079
FNC4                             A:C0C3
FNC5                             A:C082
FNC5A                            A:C09F
FNC5B                            A:C0A1
FNC6                             A:C0C4
FNCPRC                           A:C042
FOR                              A:C230
FOR1                             A:C23A
FOR2                             A:C247
FOR3                             A:C260
FOR4                             A:C291
FOR5                             A:C2D4
FOR6                             A:C2F6
FRAME                            S:0020
FROM                             E:0040
GEN1                             E:C776
GEN2                             E:C7AD
GEN2_A                           E:C7B8
GEN2_B                           E:C7AF
GEN2_C                           E:C7CF
GEN3                             E:C813
GENADR                           E:C77A
GENJMP                           E:C7EA
GENNJM                           A:C7E4
GENNJP                           E:C7E2
GENNOP                           E:C761
GENNOP1                          A:BDA0
GENNOP2                          A:C00D
GENRJMP                          E:C7D0
GEN_FULL                         A:C7CA
GET1                             A:93F3
GET1_A                           E:B002
GET2                             E:AFC6
GET3                             A:9410
GETADR                           A:AFBC
GETADR1                          E:AFE7
GETCHK                           A:CF8F
GETEXPR                          E:BB55
GETID2                           A:B22F
GETIDC                           A:B212
GETIDX                           E:B21B
GETIN                            E:C90F
GETIN1                           A:C919
GETLIT                           E:B066
GETLN1                           E:93F1
GETLN_OVERFLOW                   A:9416
GETO_1                           E:BB46
GETO_2                           E:BB53
GETSUB                           E:BAA8
GET_COMM                         E:BB87
GET_DAT                          E:BACF
GET_END                          A:B07C
GET_ITEM                         E:BB8E
GET_LEV                          E:BAC5
GET_LINE                         E:93F1
GET_LOOK                         A:CFA4
GET_OFF                          E:BB2A
HIGHEST_RAM                      E:3FFF
I2C_DDR                          E:7FF3
I2C_PORT                         E:7FF1
I2C_SCL                          E:0004
I2C_SDA                          E:0008
IDENT                            A:BCD2
IDENT1                           A:BCD5
IDENT1A                          A:BCDD
IDENT2                           A:BCE2
IDENT2A                          A:BCFB
IDENT3                           A:BD02
IDENT4                           A:BD36
IDENT4_A                         A:BD38
IDENT5                           A:BD18
IDENT5_A                         A:BD1A
IDENT6                           A:BD25
IDENT7                           A:BD2B
IF                               A:C0C9
IF1                              A:C0EE
IF2                              A:C0E7
INBUF                            S:0200
INBUF_SIZE                       E:0100
INIT                             E:9244
INIT9                            A:9291
INIT_SECOND_PASS                 A:9250
INP3                             A:B312
INTERP                           E:AE5C
INT_ERR                          E:B45E
INT_ERRM                         A:B465
JMP1                             E:9004
JMP2                             E:900C
JMP3                             E:9021
KEY_ABORT                        E:0003
KEY_DEBUG                        E:0004
KEY_STOP_TRACE                   E:000E
KEY_TRACE                        E:0014
LASTP                            S:004D
LCD_E                            E:0080
LCD_RS                           E:0020
LCD_RW                           E:0040
LCD_SUPPORT                      E:0001
LCD_welcome                      A:D10A
LEVEL                            S:0022
LINE_CNT                         S:0019
LIST                             S:001D
LIT1                             A:B08C
LOOK1                            A:BA35
LOOKUP                           E:BA2B
LOWLIT                           A:AF5E
LOWLIT1                          A:AF64
MAIN                             A:AF6D
MAINP                            A:AF6A
MAIN_1                           E:AF9C
MAIN_2                           E:AF74
MAIN_NOT_ABORT                   E:AF7F
MAIN_OK                          E:AF82
MAKE_LOWER_DONE                  E:9043
MAKE_UPPER                       E:902E
MAKE_UPPER_DONE                  E:9038
MAX_STK                          E:0020
MCAND                            S:0055
MEM                              A:C01A
MEM2                             A:C022
MEMC                             A:C01F
NEW_STK                          E:00FF
NL                               E:000A
NOSCE                            A:9233
NOTIM1                           E:AFAF
OFFSET                           S:0029
ONE_OP                           A:C006
ONE_OP2                          A:C003
OPCODE                           S:006C
OPCODE_3_CHAR_BRANCH             E:A0E9
OPCODE_3_CHAR_IMPLIED            E:A10E
OPCODE_4_CHAR_BRANCH             E:A098
OPCODE_4_CHAR_ZERO_PAGE          E:A18B
OPCODE_ASS_OPERAND_ABSOLUTE      E:A1DC
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A248
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A24D
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A292
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A295
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A2BA
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A2D6
OPCODE_ASS_OPERAND_ABSOLUTE_TOK  E:A245
OPCODE_ASS_OPERAND_ACCUMULATOR_  E:A2BD
OPCODE_ASS_OPERAND_IMMEDIATE     E:A2DB
OPCODE_ASS_OPERAND_IMMEDIATE_TO  E:A30C
OPCODE_ASS_OPERAND_ZERO_PAGE     E:A30F
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A373
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A394
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A397
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A3E0
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A3E3
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A3EC
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A410
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A431
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A40D
OPCODE_ASS_OPERAND_ZERO_PAGE_TO  E:A370
OPCODE_LEN                       S:006E
OPCODE_LOOKUP_HANDLER            E:0004
OPCODE_LOOKUP_OPCODE_LENGTH      E:0000
OPCODE_LOOKUP_OPCODE_TABLE       E:0002
OPCODE_LOOKUP_OPERAND_TYPE       E:0001
OPCODE_LOOKUP_TABLE              E:9F82
OPCODE_LOOKUP_TABLE_SIZE         E:0006
OPND                             S:002B
OUT_COMMON                       A:B332
PAREN                            A:BD7C
PCD_WRKD                         E:BB5B
PCODE                            S:0023
PCODE_ABSCLL                     E:0038
PCODE_ADD                        E:0004
PCODE_ADRAN                      E:000E
PCODE_ADRNN                      E:000C
PCODE_AND                        E:001B
PCODE_CLA                        E:002B
PCODE_CLL                        E:0027
PCODE_DEC                        E:0028
PCODE_DIV                        E:000A
PCODE_EOR                        E:0020
PCODE_EQL                        E:0010
PCODE_FINISHD                    E:0011
PCODE_GEQ                        E:0016
PCODE_GTR                        E:0018
PCODE_INC                        E:0026
PCODE_INP                        E:001C
PCODE_INS                        E:0025
PCODE_INT                        E:003B
PCODE_JM1                        E:003E
PCODE_JMP                        E:003C
PCODE_JMZ                        E:003D
PCODE_LAST                       E:0045
PCODE_LCD_WRITE_CHR              E:0045
PCODE_LCD_WRITE_HEX              E:0044
PCODE_LCD_WRITE_NUM              E:0042
PCODE_LCD_WRITE_STR              E:0043
PCODE_LDA                        E:002E
PCODE_LDI                        E:0030
PCODE_LEQ                        E:0019
PCODE_LIB_CALL                   E:0003
PCODE_LIT                        E:0000
PCODE_LOD                        E:002C
PCODE_LSS                        E:0014
PCODE_MOD                        E:000B
PCODE_MOV                        E:002A
PCODE_MUL                        E:0008
PCODE_NEG                        E:0002
PCODE_NEQ                        E:0012
PCODE_ORR                        E:001A
PCODE_OUH                        E:0021
PCODE_OUS                        E:0023
PCODE_OUT                        E:001E
PCODE_OUTC                       E:001F
PCODE_OUTCR                      E:0040
PCODE_RTN                        E:0029
PCODE_SHL                        E:0022
PCODE_SHR                        E:0024
PCODE_STA                        E:0034
PCODE_STACK                      E:0001
PCODE_STI                        E:0036
PCODE_STO                        E:0032
PCODE_SUB                        E:0006
PCODE_XOR                        E:003A
PRBYTE                           A:9307
PRBYTECR                         E:93BC
PRCHAR                           E:92EF
PRCITM                           S:0039
PRHEX                            A:9310
PRHEX1                           A:931A
PRHEXZ                           A:9312
PSH1                             E:B055
PSH9                             A:92DB
PSHPCODE                         E:BB17
PSHTOP                           E:B04A
PSHWRK                           E:92C9
PT                               A:9321
PT6                              A:9329
PUL2_END                         E:B043
PULBOTH                          A:B025
PULTOP                           E:B003
PULTOP2                          E:B028
PULWRK                           E:92DC
PUL_END                          E:B01E
PUTSP                            E:931D
READ                             A:BF71
READ11                           A:BF91
READ2                            A:BF77
READ3                            A:BFC0
READ3_A                          A:BFEF
READ3_B                          A:BFD4
READ7                            A:BFB0
READ7_A                          A:BFB6
READ8                            A:BF74
READ9                            A:BF8E
REG                              E:0000
REG2                             E:0003
REG2B                            E:0005
REGB                             E:0002
REMAIN                           S:0006
REP1                             A:C122
REPEAT                           A:C11F
RES                              S:0052
RESTART                          E:D145
RMNDR                            S:005B
RSVEND                           A:CF39
RSVWRD                           E:CE46
RUNERR                           A:AEE4
RUNNING                          S:003F
SEA1                             E:B926
SEA2                             E:B933
SEA3                             E:B987
SEA4                             E:B97C
SEA5                             E:B984
SEARCH                           E:B913
SEA_NEXT                         E:B91B
SERIAL_DEBUG1_MASK               E:0004
SERIAL_DEBUG2_MASK               E:0008
SERIAL_DEBUGGING                 E:0000
SERIAL_DELAY1                    E:0030
SERIAL_DELAY2                    E:0023
SERIAL_OUT_MASK                  E:0002
SERIAL_SPARE2_MASK               E:0010
SIM1                             A:BC0B
SIM2                             A:BC53
SIM3                             A:BC1C
SIM4                             A:BC2F
SIM5                             A:BC4B
SIM6                             A:BC4F
SIM7                             A:BC45
SIM8                             A:BC59
SIMEXP                           E:BC01
SINGLE_QUOTE                     E:0027
SRCE                             E:0000
START                            E:D129
STARTSYM                         S:002F
START_OF_ROM                     E:8000
START_TRACE                      A:C924
STK_ERR                          A:BBC4
STK_FULL                         E:BBC4
STMNT                            A:BE21
STMNT1                           A:BE2E
STMNT_WRITE_LCD                  A:BF20
STOP_TRACE                       A:C925
ST_SYMTBL_LIST_CHECK             E:8DF5
ST_SYMTBL_LIST_DONE              E:8E8A
ST_SYMTBL_LIST_LINE              E:8E04
ST_SYMTBL_LIST_NAME              E:8E79
ST_SYMTBL_LIST_NEXT              E:8DEA
SYMARG                           E:0006
SYMBOL_ARRAY                     E:0041
SYMBOL_CONSTANT                  E:0043
SYMBOL_FUNCTION                  E:0046
SYMBOL_FUNCTION_RETURN           E:0059
SYMBOL_LIBRARY_FUNCTION          E:0052
SYMBOL_LIBRARY_PROCEDURE         E:0051
SYMBOL_PROCEDURE                 E:0050
SYMBOL_TABLE_START               E:3FFF
SYMBOL_VARIABLE                  E:0056
SYMDAT                           E:0008
SYMDSP                           E:0004
SYMITM                           S:0040
SYMLEN                           E:0009
SYMLVL                           E:0002
SYMNAM                           E:000A
SYMPRV                           E:0000
SYMSUB                           E:0006
SYMTYP                           E:0003
SYMWRK                           E:BB01
SYM_FULL                         A:B98A
SYNTAX                           S:0042
T                                E:0031
TEMP                             S:0045
TERM                             A:BC73
TERM1                            A:BC80
TERM2                            A:BC76
TERM3                            A:BC91
TERM4                            A:BC8F
TERM5                            A:BC97
TERM6                            A:BC9B
TERM7                            A:BC9F
TERM8                            A:BCA3
TERM9                            A:BCA7
TERMT1                           A:BC5D
TERMT3                           A:BCAB
TEXT_START                       E:0300
TKNJMP                           E:8FFC
TKNWRK                           E:9333
TOKEN_ADDRESS                    E:00A9
TOKEN_AND                        E:008D
TOKEN_ARRAY                      E:0084
TOKEN_ASSIGN                     E:0041
TOKEN_BEGIN                      E:0088
TOKEN_CALL                       E:009F
TOKEN_CASE                       E:0095
TOKEN_CHAR                       E:00A1
TOKEN_CHR                        E:00AB
TOKEN_CONST                      E:0082
TOKEN_DIV                        E:008B
TOKEN_DO                         E:0097
TOKEN_DOWNTO                     E:009C
TOKEN_ELSE                       E:0094
TOKEN_END                        E:0089
TOKEN_EQUALITY                   E:0045
TOKEN_FOR                        E:009A
TOKEN_FUNCTION                   E:0087
TOKEN_GEQ                        E:0081
TOKEN_HEX                        E:00AC
TOKEN_HIGH_BYTE                  E:0057
TOKEN_IDENTIFIER                 E:0049
TOKEN_IF                         E:0092
TOKEN_INEQUALITY                 E:005A
TOKEN_INTEGER                    E:00FE
TOKEN_LCDWRITE                   E:00F1
TOKEN_LEQ                        E:0080
TOKEN_LOGICAL_AND                E:0058
TOKEN_LOGICAL_OR                 E:0059
TOKEN_LOW_BYTE                   E:0056
TOKEN_MEM                        E:0091
TOKEN_MEMC                       E:00A2
TOKEN_MOD                        E:008C
TOKEN_NEQ                        E:0055
TOKEN_NOT                        E:0090
TOKEN_NUMBER                     E:004E
TOKEN_OF                         E:0085
TOKEN_OR                         E:008A
TOKEN_PROCEDURE                  E:0086
TOKEN_READ                       E:009E
TOKEN_REPEAT                     E:0098
TOKEN_SHIFT_LEFT                 E:004C
TOKEN_SHIFT_RIGHT                E:0052
TOKEN_SHL                        E:008E
TOKEN_SHR                        E:008F
TOKEN_STRING                     E:0022
TOKEN_THEN                       E:0093
TOKEN_TO                         E:009B
TOKEN_UNARY_MINUS                E:004D
TOKEN_UNTIL                      E:0099
TOKEN_VAR                        E:0083
TOKEN_WHILE                      E:0096
TOKEN_WRITE                      E:009D
TOKEN_WRITELN                    E:00FF
TOKEN_XOR                        E:00A4
TRUE                             A:B10E
TRUE2                            A:B110
TWO_OP                           A:BFFD
VALUE                            S:0000
VALUE2                           S:0003
VAL_1                            E:BB9D
VAL_2                            E:BBA2
VAL_3                            E:BBAB
VAL_5                            E:BBB4
VAL_MOVE                         E:BB94
VAL_WRK                          E:C314
VARDEC                           A:BBEF
VIA_ACR                          E:7FFB
VIA_DDRA                         E:7FF3
VIA_DDRB                         E:7FF2
VIA_FLAG_CB2                     E:0008
VIA_FLAG_DISABLE                 E:0000
VIA_FLAG_ENABLE                  E:0080
VIA_FLAG_TIMER1                  E:0040
VIA_IER                          E:7FFE
VIA_IFR                          E:7FFD
VIA_PCR                          E:7FFC
VIA_PORTA                        E:7FF1
VIA_PORTB                        E:7FF0
VIA_T1C_H                        E:7FF5
VIA_T1C_L                        E:7FF4
WAIT_1                           A:C010
WHILE                            A:C143
WORK                             S:0037
WORKD                            S:0033
WRIT1                            E:BEFB
WRIT10                           A:BEEE
WRIT2                            A:BEEB
WRIT5                            A:BF0B
WRIT9                            A:BED2
WRITE                            A:BECF
WRITELN                          A:BEC0
WRITELN9                         E:BECA
WRITE_LCD1                       E:BF4C
WRITE_LCD2                       A:BF3C
WRITE_LCD5                       A:BF5C
WRITE_LCD9                       A:BF23
WRITE_LCD_STRING                 E:BF32
WRITE_LDC_CHR                    E:BF65
WRITE_LDC_CHR1                   E:BF67
WRITE_LDC_HEX                    E:BF6D
WRKD_WRK                         E:BB71
WRKSYM                           E:BB0C
WRKTKN                           E:933E
WRK_OPND                         E:BB66
WRK_VAL                          E:C309
WRK_WRKD                         E:BB7C
W_CHR                            E:BF14
W_CHR1                           E:BF16
W_HEX                            E:BF1C
W_STRING                         E:BEE1
ZERRES                           A:AC6E
a_equals_message                 A:B636
add_assembler_library_functions  A:AA8A
add_assembler_library_functions  A:AAD4
add_assembler_library_functions  A:AA92
add_assembler_library_functions  A:AAA2
add_pascal_library_functions     A:C6B7
add_pascal_library_functions_do  A:C710
add_pascal_library_functions_lo  A:C6BF
add_pascal_library_functions_na  A:C6CF
asm_do_asc                       E:A499
asm_do_asc_loop                  A:A4A6
asm_do_asc_next                  A:A4AF
asm_do_asc_ok                    A:A4A4
asm_do_assert                    A:A434
asm_do_assert_failed             A:A443
asm_do_blk                       A:A56B
asm_do_blk_done                  A:A588
asm_do_blk_loop                  A:A57B
asm_do_constant_expected         A:A4E0
asm_do_constant_expectedJ        A:A448
asm_do_constant_expectedJ2       A:A5A1
asm_do_dfb                       A:A4EE
asm_do_dfb_multiple              A:A4FC
asm_do_dfb_multiple_done         A:A51A
asm_do_dfb_multiple_loop         A:A509
asm_do_dfb_too_big               A:A51B
asm_do_dfw                       A:A52E
asm_do_dfw_multiple              A:A53C
asm_do_dfw_multiple_done         A:A55B
asm_do_dfw_multiple_loop         A:A54A
asm_do_equ                       A:A4BD
asm_do_equ_have_label            A:A4CE
asm_do_list                      E:A44B
asm_do_list1                     A:A489
asm_do_list_first_pass           A:A498
asm_do_list_no_operand           A:A46B
asm_do_list_not                  A:A485
asm_do_list_ok                   A:A46F
asm_do_nolist                    A:A45A
asm_do_nolist_ok                 A:A465
asm_do_org                       A:A4DA
asm_do_org_ok                    A:A4E5
asm_do_reserve                   A:A589
asm_do_string                    A:A4B4
asm_do_sym                       A:A5A4
asm_do_sym_done                  A:A5BD
asm_emit_one_byte                A:A520
asm_emit_two_bytes               A:A55C
ass_absolute_another_value       A:9B29
ass_added_symbol                 A:9966
ass_already_emitted              A:9EF3
ass_bad_identifier               A:9921
ass_bad_indirect                 A:9A90
ass_bad_zp_indirect_indexed      A:9ACA
ass_branch_backwards             A:9F3E
ass_branch_ok                    A:9F42
ass_branch_out_of_range          A:9F48
ass_check_label_changed          A:99D0
ass_check_no_more_tokens         A:9C24
ass_check_no_more_tokens_ok      A:9C2F
ass_check_we_have_x_or_y         A:9AD1
ass_check_we_have_x_or_y_ok      A:9AED
ass_current_label                S:0083
ass_done                         A:9BE1
ass_done1                        A:9C03
ass_done_jump                    A:98E3
ass_done_message                 A:9C06
ass_done_second_pass             A:9BEB
ass_emit                         A:9ED0
ass_emit1                        A:9F0B
ass_emit2                        A:9EE4
ass_emit3                        A:9F05
ass_emit4                        A:9EFE
ass_emit_absolute                A:9F77
ass_emit_bytes                   S:0077
ass_emit_immediate               A:9F64
ass_emit_immediate_too_high      A:9F72
ass_emit_zero_page               A:9F51
ass_emit_zero_page_too_high      A:9F5F
ass_error                        A:9F0E
ass_error1                       A:9F15
ass_evaluate_operator            A:9EA9
ass_expression_apply_operator    A:9E68
ass_expression_apply_operator_b  A:9EA4
ass_expression_cannot_be_unary   A:9E14
ass_expression_found_value       A:9DA2
ass_expression_loop              A:9D55
ass_expression_loop1             A:9D86
ass_expression_loop1a            A:9D6F
ass_expression_loop2             A:9DB3
ass_expression_loop3             A:9DC2
ass_expression_loop3a            A:9DD1
ass_expression_loop3b            A:9DC6
ass_expression_loop3c            A:9DD6
ass_expression_loop4             A:9DDC
ass_expression_loop6             A:9E3A
ass_expression_loop7             A:9E23
ass_expression_loopJ             A:9DD9
ass_expression_loop_initial      A:9D58
ass_expression_not_small_string  A:9D81
ass_expression_number            A:9D5C
ass_expression_unary             A:9E91
ass_finish_line                  A:98D8
ass_finish_lineJ                 A:99F6
ass_fixup_bbr_branch             A:9F18
ass_fixup_branch                 A:9F25
ass_get_value                    A:9D3B
ass_identifier                   A:9926
ass_identifier_operand           A:9A34
ass_illegal_opcode               A:9987
ass_immediate                    A:9A18
ass_indexed                      A:9B02
ass_indexed_x                    A:9B20
ass_indirect                     A:9A2B
ass_indirect_with_bracket        A:9A95
ass_label_not_found_yet          A:9D9A
ass_line                         A:98E6
ass_line1                        A:98F5
ass_lookup_existing_label        A:9950
ass_lookup_loop                  A:9EAC
ass_lookup_save_address          A:995A
ass_not_colon                    A:9978
ass_not_colon2                   A:997F
ass_not_unary_greater_than       A:9DFE
ass_not_unary_less_than          A:9DF4
ass_not_unary_minus              A:9DEA
ass_not_x_or_y                   A:9ACF
ass_opcode                       A:998F
ass_opcode2                      A:99E5
ass_opcode_found                 A:9ECA
ass_operand                      A:99F9
ass_operand_value                A:9A55
ass_string                       A:9A0B
ass_symbol_address_changed       A:99E0
ass_value_done                   A:9AF9
ass_value_not_indirect           A:9AEF
ass_value_not_indirectJ          A:9A8D
ass_zp_indirect_indexed          A:9AA9
assembler_library_functions_tab  A:A61E
assertion_failed_message         A:9788
assign_bad_identifier            A:BE7E
atoi                             A:CA7C
atoi_error                       E:CAEB
atoi_loop                        E:CA85
atoi_more                        E:CA96
atoi_not_running                 E:CAF1
atoi_positive                    A:CA94
bad_command                      A:82A3
bad_delimiter_message            A:86DC
bad_flag_message                 A:8846
bcd_output_digit                 A:91DA
bcd_positive                     A:91C8
bcd_result                       S:0060
bcd_skip_zeroes                  A:91CF
bcd_table                        E:915C
bcd_unpack                       A:9149
bcd_work                         S:005C
binary_to_decimal                A:91E5
binary_to_decimal_loop           A:91F0
binary_to_decimal_next           A:9215
break_message                    A:B61B
brk_address                      S:0015
brk_executed                     A:B667
brk_executed1                    A:B6E2
brk_executed2                    A:B6EF
brk_executed3                    A:B6FF
brk_executedJ                    A:B71B
brk_resumed                      A:8CEF
bytes_message                    A:90E5
call_a                           S:0010
call_assembler                   A:93E7
call_handler                     A:8FB4
call_p                           S:0013
call_s                           S:0014
call_x                           S:0011
call_y                           S:0012
cb2_interrupt                    A:B743
character_types_table            E:8006
compile_finished_message         A:935C
crc16                            E:9067
crc16_loop                       E:9073
crc16_next                       A:9080
crc16_skip                       A:9086
crc_addr                         E:0000
crc_byte                         E:908F
crc_done                         A:908E
crc_helper1                      A:90BF
crc_message                      A:90C2
crc_num                          E:0003
crc_source                       E:90ED
crc_val                          E:0006
current_line                     S:00A2
delay                            E:913F
delay_1ms                        E:9135
delay_1ms_loop                   A:9138
digitalread                      E:C8DC
digitalread_B                    A:C8EB
digitalread_C                    A:C8F3
digitalwrite                     E:C8AD
digitalwrite_B                   A:C8BE
digitalwrite_C                   A:C8C6
digitalwrite_ONE                 A:C8D4
display_in_decimal               E:91BC
display_x_characters             A:AEBC
editor_argument_check            A:8BA0
editor_argument_check_failed     A:8BB2
editor_argument_check_got_argum  A:8BBC
editor_argument_check_loop       A:8BA2
editor_assemble                  A:8F6E
editor_bad_delimiter             A:86EB
editor_bad_number                A:8571
editor_bad_range                 A:862C
editor_bad_rangeJ                A:86C5
editor_check_no_more             A:8659
editor_check_no_more_failed      A:866B
editor_check_no_more_loop        A:865B
editor_check_no_more_ok          A:8675
editor_compile                   A:8EEF
editor_debug                     A:8EC8
editor_default_range             A:8553
editor_delete                    A:8BBD
editor_delete_line_count_done    A:8C2B
editor_delete_line_count_loop    A:8C0B
editor_delete_line_count_not_do  A:8C17
editor_delete_line_count_not_ne  A:8C23
editor_do_replace                A:89BB
editor_do_replace_copy_done      A:8A00
editor_do_replace_smaller        A:89FD
editor_do_the_replace            A:8921
editor_easy_replace              A:892E
editor_easy_replace_done         A:893F
editor_easy_replace_loop         A:8932
editor_find                      A:8770
editor_find_bug                  A:87AE
editor_find_case_sensitive       A:88DF
editor_find_found_it             A:8903
editor_find_found_it1            A:8909
editor_find_get_flags            A:8808
editor_find_inner_loop           A:88C8
editor_find_loop                 A:88C4
editor_find_no_match             A:88ED
editor_find_or_replacing         A:88C0
editor_find_problem              A:86EF
editor_find_second_delimiter_lo  A:87BB
editor_find_skip_this            A:88E9
editor_find_test_character       A:88E0
editor_find_third_delimiter_loo  A:87E2
editor_flags                     S:00BC
editor_flags1                    A:8828
editor_flags2                    A:8832
editor_flags3                    A:883C
editor_flags_loop                A:880A
editor_get_delimiter             A:8719
editor_get_number                A:857B
editor_get_number_done           A:85E3
editor_get_number_end            A:85E7
editor_get_number_none           A:85E5
editor_get_number_not_identifie  A:85BD
editor_get_number_ok             A:85D3
editor_get_range                 A:8676
editor_get_range_done            A:86C4
editor_get_range_hyphen          A:86AC
editor_get_range_number          A:86B1
editor_handlers                  A:8331
editor_help                      A:8534
editor_help_done                 A:8550
editor_help_info                 A:83BF
editor_help_loop                 A:853F
editor_info                      E:8EE0
editor_insert                    A:8A2F
editor_insert_at_start           A:8A49
editor_insert_backspace          A:8AE3
editor_insert_backspace_not_at_  A:8AEF
editor_insert_common             A:8A57
editor_insert_done               A:8B05
editor_insert_done_with_newline  A:8B16
editor_insert_loop               A:8A9A
editor_insert_loop1              A:8AD3
editor_insert_no_line_number     A:8AAB
editor_insert_not_newline        A:8ACA
editor_line_number_too_big       A:8613
editor_list                      A:877C
editor_list_aborted              A:88B3
editor_list_check_to_line        A:896F
editor_list_check_to_line_ok     A:897F
editor_list_completely_done      A:89B8
editor_list_doing_find           A:87A2
editor_list_done                 A:899B
editor_list_doneJ                A:8886
editor_list_fix_target_string    A:8854
editor_list_fixup_loop           A:885C
editor_list_get_on_with_it       A:886F
editor_list_got_from_point       A:87B9
editor_list_have_source          A:8880
editor_list_loop                 A:888C
editor_list_loopJ                A:8998
editor_list_no_line_number       A:895D
editor_list_no_line_numberJ      A:8889
editor_list_not_find             A:886C
editor_list_not_finding          A:8950
editor_list_not_newline          A:8987
editor_list_skip_newline         A:8992
editor_load                      A:8A2B
editor_memory                    A:8D15
editor_memory_aborted            A:8D8B
editor_memory_ascii              A:8D93
editor_memory_done               A:8D88
editor_memory_loop               A:8D2F
editor_memory_loop1              A:8D50
editor_memory_loop2              A:8D62
editor_memory_loop3              A:8D78
editor_memory_not_control        A:8D9B
editor_memory_not_high           A:8DA1
editor_memory_show_ascii         A:8D91
editor_memory_show_dot           A:8D9F
editor_newline_processing        A:8965
editor_no_closing_delimiter      A:8747
editor_no_closing_delimiterJ     A:87B6
editor_no_closing_delimiter_mes  A:8731
editor_no_find_string            A:8762
editor_no_lines                  A:8B49
editor_recover                   A:8E9F
editor_recover_not_needed        A:8EBE
editor_replace                   A:8768
editor_replacement_loop          A:88C2
editor_run                       A:8F03
editor_save                      A:8776
editor_syntax                    A:8EF9
editor_test                      A:8D03
editor_too_full                  A:8B31
editor_too_full_loop             A:8B38
editor_trace                     A:8ED4
error1                           A:9825
error_find_next                  A:981C
error_found                      A:9846
error_loop                       A:9818
error_next                       A:9817
error_not_found                  A:982E
error_not_found_message          A:9853
errors_table                     A:9426
ex_input_aborted                 A:B545
execution_aborted_message        A:B531
execution_address_table          E:AD4C
exp_abs_val                      A:AC3E
exp_abs_val2                     A:AC56
exp_abs_val2_done                A:AC6D
exp_abs_val_done                 A:AC55
exp_add                          A:AAD5
exp_bitwise_and                  A:AB78
exp_bitwise_or                   A:AB63
exp_bitwise_xor                  A:AB8D
exp_divide                       A:ACDC
exp_divide_loop                  A:ACF9
exp_divide_not_zero              A:ACEC
exp_divide_subtraction_negative  A:AD21
exp_divide_subtraction_positive  A:AD22
exp_done                         A:9E4B
exp_done_error                   A:9E51
exp_done_ok                      A:9E56
exp_eql                          A:AB0F
exp_evaluation_function          S:007F
exp_false                        A:AB08
exp_falseJ                       A:ABA5
exp_find_sign                    A:AC77
exp_fix_sign                     A:AC8F
exp_fix_sign_done                A:ACA2
exp_geq                          A:AB5C
exp_get_operator                 A:9CA6
exp_get_operator_ok              A:9CAF
exp_get_precedence               A:9D14
exp_get_precedence_found         A:9D2A
exp_get_precedence_loop          A:9D16
exp_greater_than                 A:AB3E
exp_high_byte                    A:AC35
exp_leq                          A:AB4D
exp_less_than                    A:AB37
exp_logical_and                  A:ABB7
exp_logical_or                   A:ABA8
exp_low_byte                     A:AC30
exp_modulo                       A:AD3C
exp_multiply                     A:ACA3
exp_multiply_loop                A:ACA8
exp_multiply_no_add              A:ACC9
exp_negate                       A:ABFB
exp_negate_val                   A:AC42
exp_negate_val2                  A:AC5A
exp_neq                          A:AB23
exp_no_operators_left            A:9E42
exp_not                          A:AC0E
exp_operator                     S:007D
exp_operator_precedence          S:007E
exp_operator_stack_count         S:007C
exp_pop_operator                 A:9C96
exp_pop_operator_ok              A:9C9F
exp_pop_value                    E:9C5B
exp_pop_value_ok                 A:9C64
exp_precedence_table             A:9CB4
exp_precedence_table_end         E:9D14
exp_push_operator                A:9C84
exp_push_operator_ok             A:9C8F
exp_push_value                   E:9C30
exp_push_value_memory_full       A:9C36
exp_push_value_not_full          A:9C4A
exp_push_value_ok                A:9C3B
exp_shift_left                   A:ABC9
exp_shift_left_done              A:ABE1
exp_shift_left_loop              A:ABD8
exp_shift_right                  A:ABE2
exp_shift_right_done             A:ABFA
exp_shift_right_loop             A:ABF1
exp_subtract                     A:AAE9
exp_true                         A:AAFF
exp_trueJ                        A:ABA2
exp_unary_minus                  A:AC1C
exp_unary_ok                     S:0081
exp_value_stack                  S:0079
exp_value_stack_count            S:007B
find_count                       S:00B9
find_delimiter                   S:00B4
find_flags                       S:00BD
find_from                        S:00B0
find_len                         S:00B3
find_line                        A:8C9E
find_line_eof                    A:8CD1
find_line_loop                   A:8CAC
find_line_next                   A:8CBB
find_line_same_line              A:8CC9
find_pos                         S:00B2
find_source_end                  A:8CD2
find_source_end_done             E:8CEE
find_source_end_loop             E:8CDA
find_source_end_wrap             E:8CE8
find_string_too_long             A:8713
find_string_too_longJ            A:87B3
find_string_too_long_message     A:86F5
find_to                          S:00B1
found_message                    A:86C8
found_this_line                  S:00BB
from_line                        S:009E
from_msg                         A:86D0
gc_alpha_alpha_only              A:CA0D
gc_alpha_done                    A:CA09
gc_alpha_loop                    A:C9F0
gc_alpha_ok                      A:C9F8
gc_ampersand                     A:CE02
gc_assembler_comment_find_end    A:CC11
gc_assembler_comment_keep_looki  A:CC23
gc_assembler_comment_not_eof     A:CC1C
gc_assign                        A:CD9E
gc_backslash_tokens              A:CC2B
gc_backslash_tokens_end          E:CC41
gc_backslash_tokens_length       E:0016
gc_bang                          A:CE35
gc_bar                           A:CE13
gc_binary_literal                A:CD75
gc_binary_loop                   A:CD7D
gc_colon                         A:CD93
gc_comment_found_end             A:CBAA
gc_comment_keep_looking          A:CBA2
gc_comment_not_eof               A:CB8A
gc_comment_not_newline           A:CB93
gc_directive_list                A:CBF2
gc_directive_nolist              A:CBFF
gc_directive_pcodes              A:CBF9
gc_directive_symbols             A:CBBA
gc_directive_symbols_ok          A:CBC6
gc_directive_symbols_too_late    A:CBED
gc_dollar                        A:CD0F
gc_done                          A:C9D3
gc_equality                      A:CE2F
gc_equals                        A:CE24
gc_fix_hex                       A:CCD3
gc_fix_hex_not_a_to_f            A:CCDC
gc_geq                           A:CDD7
gc_greater_than                  A:CDC7
gc_hex_done                      A:CD5F
gc_hex_literal                   A:CD1B
gc_hex_loop                      A:CD24
gc_hex_too_big                   A:CD64
gc_inequality                    A:CE40
gc_leq                           A:CDB8
gc_less_than                     A:CDA4
gc_lh_brace                      A:CB4E
gc_lh_paren                      A:CB52
gc_logical_and                   A:CE0D
gc_logical_or                    A:CE1E
gc_minus                         A:CDE1
gc_neq                           A:CDBD
gc_newline                       A:C9B0
gc_newline1                      A:C9BD
gc_newline_assembling            A:C9CA
gc_not_alpha                     A:CA16
gc_not_digit                     A:CA22
gc_not_space                     A:C9EB
gc_pascal_comment                A:CB60
gc_pascal_comment_find_end       A:CB7F
gc_percent                       A:CD69
gc_plus                          A:CDE3
gc_quote                         A:CC41
gc_quote_backslash_loop          A:CCAA
gc_quote_bad                     A:CC58
gc_quote_bad_string              A:CCB5
gc_quote_copied_value            A:CC7D
gc_quote_done                    A:CC86
gc_quote_found_backslash_charac  A:CCBE
gc_quote_hex_character           A:CCE0
gc_quote_hex_character_done      A:CCBA
gc_quote_hex_character_one_only  A:CD0C
gc_quote_long_string             A:CC72
gc_quote_loop                    A:CC4F
gc_quote_loop_not_end_of_line    A:CC5D
gc_quote_not_backslash           A:CCC2
gc_quote_not_finished            A:CC98
gc_quote_too_long                A:CCCE
gc_semicolon                     A:CC08
gc_shift_left                    A:CDC2
gc_shift_right                   A:CDDC
gc_single_byte_already_known     A:C9CF
gc_single_byte_already_knownJ    A:CB4B
gc_single_byte_already_knownJ2   A:CDD4
gc_single_byte_token             A:C9D1
gc_single_byte_tokenJ            A:CB48
gc_skip_spaces                   A:C99B
gen_random                       A:9044
gen_random1                      A:9066
get_token                        A:C98D
get_token_loop                   A:C991
gtoken_directive_table           A:CB3B
gtoken_table                     A:CB0A
handlerLookup                    A:8F74
handler_find_length              A:8F7C
handler_found_directive          A:8FA2
handler_found_length             A:8F85
handler_loop                     A:8F76
handler_next                     A:8F89
handler_same_length              A:8F99
handlers_done                    A:8FB2
hardware_init                    A:C926
hardware_work                    S:008C
i2c_begin_transmission           A:CFD8
i2c_begin_transmission_loop      A:CFDC
i2c_delay                        A:CFB9
i2c_end_transmission             A:D09B
i2c_init                         A:CFAE
i2c_read                         A:D045
i2c_read_ack_or_nak              A:D082
i2c_read_ack_or_nak_wait         A:D087
i2c_read_done                    A:D099
i2c_read_loop                    A:D04E
i2c_read_nak                     A:D07D
i2c_read_next                    A:D067
i2c_read_zero                    A:D063
i2c_receive_message              A:D0DD
i2c_receive_message_done         A:D100
i2c_receive_message_fail         A:D105
i2c_receive_message_loop         A:D0EB
i2c_send_message                 A:D0B4
i2c_send_message_done            A:D0D3
i2c_send_message_fail            A:D0D8
i2c_send_message_loop            A:D0BC
i2c_toggle_clock                 A:CFBD
i2c_toggle_clock_wait            A:CFC5
i2c_write                        A:CFFF
i2c_write_clock                  A:D019
i2c_write_clock_wait             A:D029
i2c_write_got_ack                A:D043
i2c_write_loop                   A:D002
i2c_write_lost_arbitration       A:D041
i2c_write_one                    A:D00E
id_equals_message                A:B65E
info_message                     A:A5BE
insert_limit                     S:00A4
introduction                     A:8255
irq                              A:B71E
irq1                             A:B72B
irq_done                         A:B7A3
is_xxx_fail                      A:8106
is_xxx_pass                      A:810A
isalnum                          E:8162
isalpha                          E:8126
isbin                            A:8176
isbinary                         E:816E
iscntrl                          E:8156
isdigit                          E:8132
islower                          E:811A
isspace                          E:814A
isupper                          E:810E
isxdigit                         E:813E
lcd_clear_display                A:B8E7
lcd_clear_enable                 A:B843
lcd_data_nibble                  A:B8A6
lcd_get_address                  A:B873
lcd_home                         A:B8F7
lcd_initialise                   A:B7A6
lcd_instruction                  A:B893
lcd_prepare_to_read_register     A:B7FF
lcd_prepare_to_write_data        A:B812
lcd_prepare_to_write_instructio  A:B827
lcd_print                        A:B908
lcd_print_char                   A:B8B5
lcd_print_char_newline           A:B8D6
lcd_print_char_ok                A:B8D6
lcd_print_char_on_2nd_line       A:B8CF
lcd_print_done                   A:B912
lcd_print_message                A:B8FF
lcd_print_not_newline            A:B8C0
lcd_read_instruction_nibble      A:B84C
lcd_second_line                  A:B8EF
lcd_set_enable                   A:B83A
lcd_wait                         A:B858
lcd_wait_timeout                 A:B86F
lcd_work                         S:0086
lcd_write_instruction_nibble     A:B887
lcdbusy                          A:B860
library_function_call            A:C711
library_function_call_1          A:C74D
library_function_call_2          A:C71E
library_function_call_3          A:C748
library_function_call_5          A:C750
line_number_lt_1000              A:8C79
line_number_output_spaces        A:8C88
lines_deleted_message            A:8C55
list_symbols                     E:A5C9
list_symbols_check               E:A5E3
list_symbols_done                E:A61D
list_symbols_line                E:A5F2
list_symbols_name                E:A60C
list_symbols_next                E:A5D8
load_message                     A:8A09
m_alnum                          E:0080
m_alpha                          E:0004
m_cntrl                          E:0040
m_digit                          E:0008
m_lower                          E:0002
m_space                          E:0020
m_upper                          E:0001
m_xdigit                         E:0010
main_loop                        A:82E7
main_loop_not_run                A:8313
main_prompt                      A:82CD
main_start                       A:82C6
maths_work                       S:008D
mem_move_dest                    S:00A8
mem_move_len                     S:00AA
mem_move_src                     S:00A6
memory_filled_up                 A:8B77
memory_full                      A:8B5C
movedown                         A:817A
movedown1                        A:819D
movedown2                        A:8190
movedown_done                    A:819C
movedown_loop                    A:8186
moveup                           A:81A6
moveup3                          A:81D8
moveup_done                      A:81E4
moveup_loop                      A:81CE
moveup_next                      E:81E5
negate_token_value               A:CAF6
no_find_message                  A:874D
no_valid_compile_message         A:9392
notbin                           A:8178
number_bad_range_message         A:861D
number_expected_message          A:8560
number_too_large_message         A:85F4
opcode_lookup                    A:9B38
opcode_lookup_correct_length     A:9B63
opcode_lookup_correct_operand    A:9B91
opcode_lookup_loop               A:9B4A
opcode_lookup_loop_done          A:9BA8
opcode_lookup_loop_unknown       A:9BDD
opcode_lookup_next_table         A:9B54
opcode_lookup_no_handler         A:9BA7
opcode_lookup_ok                 A:9BE0
p_equals_message                 A:B64E
partial_handler_Lookup           A:8FB7
partial_handler_done             A:8FFB
partial_handler_found_directive  A:8FE7
partial_handler_next             A:8FD0
partial_handler_next_found_item  A:8FD7
partial_handler_next_item        A:8FB9
partial_handler_next_loop        A:8FC1
partial_handler_skipped_string   A:8FEE
pas_gc_identifier                A:CF45
pas_gc_loop                      A:CF4D
pas_gc_more                      A:CF56
pas_gc_no_match                  E:CF7E
pas_get_token                    A:CF3B
pas_get_token_eof                A:CF44
pascal_library_functions_table   A:C617
pcodes_ended_message             A:9349
pin_number_to_mask               E:C86B
pin_number_to_mask_done          A:C879
pin_number_to_mask_loop          A:C871
pinmode                          A:C87E
pinmode_B                        A:C88F
pinmode_C                        A:C897
pinmode_OUTPUT                   A:C8A5
prchar_not_control               A:9302
print                            A:8226
print_done                       A:824C
print_loop                       A:8234
print_not_abort                  A:8242
prompt                           A:82A0
random                           S:0009
recover_done                     A:8E8D
recover_not_needed               A:8E93
rep_diff                         S:00B7
rep_from                         S:00B5
rep_to                           S:00B6
run_assembler                    A:93E1
running_message                  A:ADEA
s_equals_message                 A:B656
serial_available                 E:C920
serial_in_byte                   S:008A
serial_in_byte_received          S:008B
serial_in_loop                   A:B74F
serial_out_bit                   S:0089
serial_out_byte                  S:0087
serial_print                     A:C982
serial_print_done                A:C98C
serial_print_message             A:C97C
serial_send_count_bits           A:B794
show_current_line                A:9863
show_current_line_done           A:98A8
show_current_line_loop           A:9885
show_current_line_loop_print_on  A:989D
show_current_line_number         A:8C60
show_current_line_number_done    A:8C94
show_source_end                  A:8F34
show_source_start                A:8F5C
show_symbol_table_end            A:8F0F
show_symbols                     S:0082
source_ended_message             A:8F21
source_length_message            A:90D5
source_starts_message            A:8F49
stack_message                    A:B713
str_compare                      A:81F0
str_compare_done                 A:81FE
str_ic_compare                   A:8201
str_ic_compare_done              A:8223
str_ic_compare_fixed_dest        A:821E
str_ic_compare_fixed_srce        A:8210
str_work                         S:0085
symbol_table_ended_message       A:937A
symbol_table_message             A:8DB8
system_flags                     S:00BE
this_line                        S:00AC
this_line_addr                   S:00AE
timer1_interrupt                 A:B774
to_line                          S:00A0
to_msg                           A:86D7
token_address                    S:0090
token_digit                      S:009B
token_length                     S:0092
token_line                       A:CA2D
token_line1                      A:CA33
token_line_done                  A:CA7B
token_line_listing               A:CA4E
token_line_loop                  A:CA66
token_line_loop1                 A:CA76
token_line_start                 S:009C
token_sign                       S:0097
token_start                      S:008E
token_type                       S:0093
token_value                      S:0094
token_work                       S:0098
too_much_on_line                 A:8636
typing_latency                   S:000D
write_char                       A:C957
write_char_loop                  A:C973
write_function                   S:0017
write_to_lcd                     A:C904
write_to_serial                  A:C8F9
write_zero                       A:B78F
wtf_loop                         A:9BCC
x_equals_message                 A:B63E
y_equals_message                 A:B646

Symbols by value:
0000 EMULATOR
0000 OPCODE_LOOKUP_OPCODE_LENGTH
0000 PCODE_LIT
0000 REG
0000 SERIAL_DEBUGGING
0000 SRCE
0000 SYMPRV
0000 VALUE
0000 VIA_FLAG_DISABLE
0000 crc_addr
0001 ASS_OPERAND_ABSOLUTE
0001 EFLAG_SHOW_LINE
0001 FFLAG_IGNORE_CASE
0001 FLAG_COMPILING
0001 LCD_SUPPORT
0001 OPCODE_LOOKUP_OPERAND_TYPE
0001 PCODE_STACK
0001 m_upper
0002 ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
0002 EFLAG_ALLOW_ZERO_FROM
0002 FFLAG_GLOBAL
0002 FLAG_ASSEMBLING
0002 OPCODE_LOOKUP_OPCODE_TABLE
0002 PCODE_NEG
0002 REGB
0002 SERIAL_OUT_MASK
0002 SYMLVL
0002 m_lower
0003 ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
0003 DEST
0003 KEY_ABORT
0003 PCODE_LIB_CALL
0003 REG2
0003 SYMTYP
0003 VALUE2
0003 crc_num
0004 ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
0004 EFLAG_LOAD
0004 FFLAG_QUIET
0004 FLAG_LIST_SOURCE
0004 I2C_SCL
0004 KEY_DEBUG
0004 OPCODE_LOOKUP_HANDLER
0004 PCODE_ADD
0004 SERIAL_DEBUG1_MASK
0004 SYMDSP
0004 m_alpha
0005 ASS_OPERAND_ABSOLUTE_INDIRECT
0005 REG2B
0006 ASS_OPERAND_ACCUMULATOR_A
0006 OPCODE_LOOKUP_TABLE_SIZE
0006 PCODE_SUB
0006 REMAIN
0006 SYMARG
0006 SYMSUB
0006 crc_val
0007 ASS_OPERAND_IMMEDIATE
0008 ASS_OPERAND_IMPLIED
0008 BACKSPACE
0008 EFLAG_SAVE
0008 FLAG_VALID_COMPILE
0008 I2C_SDA
0008 PCODE_MUL
0008 SERIAL_DEBUG2_MASK
0008 SYMDAT
0008 VIA_FLAG_CB2
0008 m_digit
0009 SYMLEN
0009 random
000A NL
000A PCODE_DIV
000A SYMNAM
000B ASS_OPERAND_ZERO_PAGE
000B PCODE_MOD
000C ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
000C PCODE_ADRNN
000D ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
000D CR
000D typing_latency
000E ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
000E KEY_STOP_TRACE
000E PCODE_ADRAN
000F ASS_OPERAND_ZERO_PAGE_INDIRECT
0010 ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
0010 EFLAG_FIND
0010 FLAG_VALID_ASSEMBLE
0010 PCODE_EQL
0010 SERIAL_SPARE2_MASK
0010 call_a
0010 m_xdigit
0011 ASS_OPERAND_STRING
0011 PCODE_FINISHD
0011 call_x
0012 ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE
0012 PCODE_NEQ
0012 call_y
0013 call_p
0014 KEY_TRACE
0014 PCODE_LSS
0014 call_s
0015 brk_address
0016 PCODE_GEQ
0016 gc_backslash_tokens_length
0017 write_function
0018 PCODE_GTR
0019 LINE_CNT
0019 PCODE_LEQ
001A PCODE_ORR
001B END_EDITOR_INPUT
001B PCODE_AND
001C PCODE_INP
001D LIST
001E PCODE_OUT
001F PCODE_OUTC
0020 EFLAG_REPLACE
0020 FRAME
0020 LCD_RS
0020 MAX_STK
0020 PCODE_EOR
0020 m_space
0021 PCODE_OUH
0022 LEVEL
0022 PCODE_SHL
0022 TOKEN_STRING
0023 PCODE
0023 PCODE_OUS
0023 SERIAL_DELAY2
0024 PCODE_SHR
0025 ACT_PCDA
0025 PCODE_INS
0026 PCODE_INC
0027 DISPL
0027 PCODE_CLL
0027 SINGLE_QUOTE
0028 PCODE_DEC
0029 OFFSET
0029 PCODE_RTN
002A PCODE_MOV
002B OPND
002B PCODE_CLA
002C PCODE_LOD
002E DCODE
002E PCODE_LDA
002F STARTSYM
0030 PCODE_LDI
0030 SERIAL_DELAY1
0031 ENDSYM
0031 T
0032 PCODE_STO
0033 WORKD
0034 PCODE_STA
0035 ERRNO
0036 BSAVE
0036 PCODE_STI
0037 WORK
0038 PCODE_ABSCLL
0039 PRCITM
003A PCODE_XOR
003B BASE
003B PCODE_INT
003C PCODE_JMP
003D DATA
003D PCODE_JMZ
003E PCODE_JM1
003F RUNNING
0040 EFLAG_SUPPRESS_NEWLINE
0040 FLAG_ONLY_ALPHA
0040 FROM
0040 LCD_RW
0040 PCODE_OUTCR
0040 SYMITM
0040 VIA_FLAG_TIMER1
0040 m_cntrl
0041 SYMBOL_ARRAY
0041 TOKEN_ASSIGN
0042 PCODE_LCD_WRITE_NUM
0042 SYNTAX
0043 END_PCD
0043 PCODE_LCD_WRITE_STR
0043 SYMBOL_CONSTANT
0044 PCODE_LCD_WRITE_HEX
0045 PCODE_LAST
0045 PCODE_LCD_WRITE_CHR
0045 TEMP
0045 TOKEN_EQUALITY
0046 SYMBOL_FUNCTION
0047 CALL
0049 DBGFLG
0049 TOKEN_IDENTIFIER
004A DATTYP
004B COUNT1
004C COUNT2
004C TOKEN_SHIFT_LEFT
004D LASTP
004D TOKEN_UNARY_MINUS
004E TOKEN_NUMBER
0050 SYMBOL_PROCEDURE
0051 SYMBOL_LIBRARY_PROCEDURE
0052 RES
0052 SYMBOL_LIBRARY_FUNCTION
0052 TOKEN_SHIFT_RIGHT
0055 MCAND
0055 TOKEN_NEQ
0056 SYMBOL_VARIABLE
0056 TOKEN_LOW_BYTE
0057 TOKEN_HIGH_BYTE
0058 TOKEN_LOGICAL_AND
0059 SYMBOL_FUNCTION_RETURN
0059 TOKEN_LOGICAL_OR
005A TOKEN_INEQUALITY
005B RMNDR
005C bcd_work
0060 bcd_result
006B ASS_OPERAND
006C OPCODE
006E OPCODE_LEN
006F ASS_EMIT_COUNT
0070 ASS_OPCODE_WORK
0072 ASS_COUNT
0073 ASS_VALUE
0076 ASS_PASS
0077 ass_emit_bytes
0079 exp_value_stack
007B exp_value_stack_count
007C exp_operator_stack_count
007D exp_operator
007E exp_operator_precedence
007F exp_evaluation_function
0080 EFLAG_NO_LINE_NUMBERS
0080 FLAG_ABORTED
0080 LCD_E
0080 TOKEN_LEQ
0080 VIA_FLAG_ENABLE
0080 m_alnum
0081 TOKEN_GEQ
0081 exp_unary_ok
0082 TOKEN_CONST
0082 show_symbols
0083 TOKEN_VAR
0083 ass_current_label
0084 TOKEN_ARRAY
0085 TOKEN_OF
0085 str_work
0086 TOKEN_PROCEDURE
0086 lcd_work
0087 TOKEN_FUNCTION
0087 serial_out_byte
0088 TOKEN_BEGIN
0089 TOKEN_END
0089 serial_out_bit
008A TOKEN_OR
008A serial_in_byte
008B TOKEN_DIV
008B serial_in_byte_received
008C TOKEN_MOD
008C hardware_work
008D TOKEN_AND
008D maths_work
008E TOKEN_SHL
008E token_start
008F TOKEN_SHR
0090 TOKEN_NOT
0090 token_address
0091 TOKEN_MEM
0092 TOKEN_IF
0092 token_length
0093 TOKEN_THEN
0093 token_type
0094 TOKEN_ELSE
0094 token_value
0095 TOKEN_CASE
0096 TOKEN_WHILE
0097 TOKEN_DO
0097 token_sign
0098 TOKEN_REPEAT
0098 token_work
0099 TOKEN_UNTIL
009A TOKEN_FOR
009B TOKEN_TO
009B token_digit
009C TOKEN_DOWNTO
009C token_line_start
009D TOKEN_WRITE
009E TOKEN_READ
009E from_line
009F TOKEN_CALL
00A0 to_line
00A1 TOKEN_CHAR
00A2 TOKEN_MEMC
00A2 current_line
00A4 TOKEN_XOR
00A4 insert_limit
00A6 mem_move_src
00A8 mem_move_dest
00A9 TOKEN_ADDRESS
00AA mem_move_len
00AB TOKEN_CHR
00AC TOKEN_HEX
00AC this_line
00AE this_line_addr
00B0 find_from
00B1 find_to
00B2 find_pos
00B3 find_len
00B4 find_delimiter
00B5 rep_from
00B6 rep_to
00B7 rep_diff
00B9 find_count
00BB found_this_line
00BC editor_flags
00BD find_flags
00BE system_flags
00D0 BIT_INTERVAL
00F1 TOKEN_LCDWRITE
00FE TOKEN_INTEGER
00FF NEW_STK
00FF TOKEN_WRITELN
0100 INBUF_SIZE
0200 INBUF
0300 TEXT_START
12C0 BAUD_RATE
3FFF HIGHEST_RAM
3FFF SYMBOL_TABLE_START
7FF0 VIA_PORTB
7FF1 I2C_PORT
7FF1 VIA_PORTA
7FF2 VIA_DDRB
7FF3 I2C_DDR
7FF3 VIA_DDRA
7FF4 VIA_T1C_L
7FF5 VIA_T1C_H
7FFB VIA_ACR
7FFC VIA_PCR
7FFD VIA_IFR
7FFE VIA_IER
8000 START_OF_ROM
8006 character_types_table
8106 is_xxx_fail
810A is_xxx_pass
810E isupper
811A islower
8126 isalpha
8132 isdigit
813E isxdigit
814A isspace
8156 iscntrl
8162 isalnum
816E isbinary
8176 isbin
8178 notbin
817A movedown
8186 movedown_loop
8190 movedown2
819C movedown_done
819D movedown1
81A6 moveup
81CE moveup_loop
81D8 moveup3
81E4 moveup_done
81E5 moveup_next
81F0 str_compare
81FE str_compare_done
8201 str_ic_compare
8210 str_ic_compare_fixed_srce
821E str_ic_compare_fixed_dest
8223 str_ic_compare_done
8226 print
8234 print_loop
8242 print_not_abort
824C print_done
8255 introduction
82A0 prompt
82A3 bad_command
82C6 main_start
82CD main_prompt
82E7 main_loop
8313 main_loop_not_run
8331 editor_handlers
83BF editor_help_info
8534 editor_help
853F editor_help_loop
8550 editor_help_done
8553 editor_default_range
8560 number_expected_message
8571 editor_bad_number
857B editor_get_number
85BD editor_get_number_not_identifier
85D3 editor_get_number_ok
85E3 editor_get_number_done
85E5 editor_get_number_none
85E7 editor_get_number_end
85F4 number_too_large_message
8613 editor_line_number_too_big
861D number_bad_range_message
862C editor_bad_range
8636 too_much_on_line
8659 editor_check_no_more
865B editor_check_no_more_loop
866B editor_check_no_more_failed
8675 editor_check_no_more_ok
8676 editor_get_range
86AC editor_get_range_hyphen
86B1 editor_get_range_number
86C4 editor_get_range_done
86C5 editor_bad_rangeJ
86C8 found_message
86D0 from_msg
86D7 to_msg
86DC bad_delimiter_message
86EB editor_bad_delimiter
86EF editor_find_problem
86F5 find_string_too_long_message
8713 find_string_too_long
8719 editor_get_delimiter
8731 editor_no_closing_delimiter_message
8747 editor_no_closing_delimiter
874D no_find_message
8762 editor_no_find_string
8768 editor_replace
8770 editor_find
8776 editor_save
877C editor_list
87A2 editor_list_doing_find
87AE editor_find_bug
87B3 find_string_too_longJ
87B6 editor_no_closing_delimiterJ
87B9 editor_list_got_from_point
87BB editor_find_second_delimiter_loop
87E2 editor_find_third_delimiter_loop
8808 editor_find_get_flags
880A editor_flags_loop
8828 editor_flags1
8832 editor_flags2
883C editor_flags3
8846 bad_flag_message
8854 editor_list_fix_target_string
885C editor_list_fixup_loop
886C editor_list_not_find
886F editor_list_get_on_with_it
8880 editor_list_have_source
8886 editor_list_doneJ
8889 editor_list_no_line_numberJ
888C editor_list_loop
88B3 editor_list_aborted
88C0 editor_find_or_replacing
88C2 editor_replacement_loop
88C4 editor_find_loop
88C8 editor_find_inner_loop
88DF editor_find_case_sensitive
88E0 editor_find_test_character
88E9 editor_find_skip_this
88ED editor_find_no_match
8903 editor_find_found_it
8909 editor_find_found_it1
8921 editor_do_the_replace
892E editor_easy_replace
8932 editor_easy_replace_loop
893F editor_easy_replace_done
8950 editor_list_not_finding
895D editor_list_no_line_number
8965 editor_newline_processing
896F editor_list_check_to_line
897F editor_list_check_to_line_ok
8987 editor_list_not_newline
8992 editor_list_skip_newline
8998 editor_list_loopJ
899B editor_list_done
89B8 editor_list_completely_done
89BB editor_do_replace
89FD editor_do_replace_smaller
8A00 editor_do_replace_copy_done
8A09 load_message
8A2B editor_load
8A2F editor_insert
8A49 editor_insert_at_start
8A57 editor_insert_common
8A9A editor_insert_loop
8AAB editor_insert_no_line_number
8ACA editor_insert_not_newline
8AD3 editor_insert_loop1
8AE3 editor_insert_backspace
8AEF editor_insert_backspace_not_at_start
8B05 editor_insert_done
8B16 editor_insert_done_with_newline
8B31 editor_too_full
8B38 editor_too_full_loop
8B49 editor_no_lines
8B5C memory_full
8B77 memory_filled_up
8BA0 editor_argument_check
8BA2 editor_argument_check_loop
8BB2 editor_argument_check_failed
8BBC editor_argument_check_got_argument
8BBD editor_delete
8C0B editor_delete_line_count_loop
8C17 editor_delete_line_count_not_done
8C23 editor_delete_line_count_not_newline
8C2B editor_delete_line_count_done
8C55 lines_deleted_message
8C60 show_current_line_number
8C79 line_number_lt_1000
8C88 line_number_output_spaces
8C94 show_current_line_number_done
8C9E find_line
8CAC find_line_loop
8CBB find_line_next
8CC9 find_line_same_line
8CD1 find_line_eof
8CD2 find_source_end
8CDA find_source_end_loop
8CE8 find_source_end_wrap
8CEE find_source_end_done
8CEF brk_resumed
8D03 editor_test
8D15 editor_memory
8D2F editor_memory_loop
8D50 editor_memory_loop1
8D62 editor_memory_loop2
8D78 editor_memory_loop3
8D88 editor_memory_done
8D8B editor_memory_aborted
8D91 editor_memory_show_ascii
8D93 editor_memory_ascii
8D9B editor_memory_not_control
8D9F editor_memory_show_dot
8DA1 editor_memory_not_high
8DB8 symbol_table_message
8DEA ST_SYMTBL_LIST_NEXT
8DF5 ST_SYMTBL_LIST_CHECK
8E04 ST_SYMTBL_LIST_LINE
8E79 ST_SYMTBL_LIST_NAME
8E8A ST_SYMTBL_LIST_DONE
8E8D recover_done
8E93 recover_not_needed
8E9F editor_recover
8EBE editor_recover_not_needed
8EC8 editor_debug
8ED4 editor_trace
8EE0 editor_info
8EEF editor_compile
8EF9 editor_syntax
8F03 editor_run
8F0F show_symbol_table_end
8F21 source_ended_message
8F34 show_source_end
8F49 source_starts_message
8F5C show_source_start
8F6E editor_assemble
8F74 handlerLookup
8F76 handler_loop
8F7C handler_find_length
8F85 handler_found_length
8F89 handler_next
8F99 handler_same_length
8FA2 handler_found_directive
8FB2 handlers_done
8FB4 call_handler
8FB7 partial_handler_Lookup
8FB9 partial_handler_next_item
8FC1 partial_handler_next_loop
8FD0 partial_handler_next
8FD7 partial_handler_next_found_item_length
8FE7 partial_handler_found_directive
8FEE partial_handler_skipped_string
8FFB partial_handler_done
8FFC TKNJMP
9004 JMP1
900C JMP2
9021 JMP3
902E MAKE_UPPER
9038 MAKE_UPPER_DONE
9043 MAKE_LOWER_DONE
9044 gen_random
9066 gen_random1
9067 crc16
9073 crc16_loop
9080 crc16_next
9086 crc16_skip
908E crc_done
908F crc_byte
90BF crc_helper1
90C2 crc_message
90D5 source_length_message
90E5 bytes_message
90ED crc_source
9135 delay_1ms
9138 delay_1ms_loop
913F delay
9149 bcd_unpack
915C bcd_table
91BC display_in_decimal
91C8 bcd_positive
91CF bcd_skip_zeroes
91DA bcd_output_digit
91E5 binary_to_decimal
91F0 binary_to_decimal_loop
9215 binary_to_decimal_next
9233 NOSCE
9244 INIT
9250 INIT_SECOND_PASS
9291 INIT9
9292 CROUT
9297 COMSTL
92A3 COMS9
92A4 COMS8
92A7 DISHX
92AD DISPAD
92C8 DISPAD2
92C9 PSHWRK
92DB PSH9
92DC PULWRK
92EF PRCHAR
9302 prchar_not_control
9307 PRBYTE
9310 PRHEX
9312 PRHEXZ
931A PRHEX1
931D PUTSP
9321 PT
9329 PT6
9333 TKNWRK
933E WRKTKN
9349 pcodes_ended_message
935C compile_finished_message
937A symbol_table_ended_message
9392 no_valid_compile_message
93BC PRBYTECR
93C2 CHK_VAL
93D4 CHK_VAL9
93D5 CHK_RUN
93E1 run_assembler
93E7 call_assembler
93F1 GETLN1
93F1 GET_LINE
93F3 GET1
9410 GET3
9416 GETLN_OVERFLOW
9419 COUT
9423 COUT_CALL
9426 errors_table
9788 assertion_failed_message
97C2 ERRLIT
97CE ERROR
97D7 ERR7
97E1 ERR1
97F5 ERR3
9805 ERR5
980B ERR6
9817 error_next
9818 error_loop
981C error_find_next
9825 error1
982E error_not_found
9846 error_found
9853 error_not_found_message
9863 show_current_line
9885 show_current_line_loop
989D show_current_line_loop_print_one_character
98A8 show_current_line_done
98AC ASSEMBLE
98B9 ASSEMBLE_SECOND_PASS
98BE ASSEMBLE_PASS
98D8 ass_finish_line
98E3 ass_done_jump
98E6 ass_line
98F5 ass_line1
9921 ass_bad_identifier
9926 ass_identifier
9950 ass_lookup_existing_label
995A ass_lookup_save_address
9966 ass_added_symbol
9978 ass_not_colon
997F ass_not_colon2
9987 ass_illegal_opcode
998F ass_opcode
99D0 ass_check_label_changed
99E0 ass_symbol_address_changed
99E5 ass_opcode2
99F6 ass_finish_lineJ
99F9 ass_operand
9A0B ass_string
9A18 ass_immediate
9A2B ass_indirect
9A34 ass_identifier_operand
9A55 ass_operand_value
9A8D ass_value_not_indirectJ
9A90 ass_bad_indirect
9A95 ass_indirect_with_bracket
9AA9 ass_zp_indirect_indexed
9ACA ass_bad_zp_indirect_indexed
9ACF ass_not_x_or_y
9AD1 ass_check_we_have_x_or_y
9AED ass_check_we_have_x_or_y_ok
9AEF ass_value_not_indirect
9AF9 ass_value_done
9B02 ass_indexed
9B20 ass_indexed_x
9B29 ass_absolute_another_value
9B38 opcode_lookup
9B4A opcode_lookup_loop
9B54 opcode_lookup_next_table
9B63 opcode_lookup_correct_length
9B91 opcode_lookup_correct_operand
9BA7 opcode_lookup_no_handler
9BA8 opcode_lookup_loop_done
9BCC wtf_loop
9BDD opcode_lookup_loop_unknown
9BE0 opcode_lookup_ok
9BE1 ass_done
9BEB ass_done_second_pass
9C03 ass_done1
9C06 ass_done_message
9C24 ass_check_no_more_tokens
9C2F ass_check_no_more_tokens_ok
9C30 exp_push_value
9C36 exp_push_value_memory_full
9C3B exp_push_value_ok
9C4A exp_push_value_not_full
9C5B exp_pop_value
9C64 exp_pop_value_ok
9C84 exp_push_operator
9C8F exp_push_operator_ok
9C96 exp_pop_operator
9C9F exp_pop_operator_ok
9CA6 exp_get_operator
9CAF exp_get_operator_ok
9CB4 exp_precedence_table
9D14 exp_get_precedence
9D14 exp_precedence_table_end
9D16 exp_get_precedence_loop
9D2A exp_get_precedence_found
9D3B ass_get_value
9D55 ass_expression_loop
9D58 ass_expression_loop_initial
9D5C ass_expression_number
9D6F ass_expression_loop1a
9D81 ass_expression_not_small_string
9D86 ass_expression_loop1
9D9A ass_label_not_found_yet
9DA2 ass_expression_found_value
9DB3 ass_expression_loop2
9DC2 ass_expression_loop3
9DC6 ass_expression_loop3b
9DD1 ass_expression_loop3a
9DD6 ass_expression_loop3c
9DD9 ass_expression_loopJ
9DDC ass_expression_loop4
9DEA ass_not_unary_minus
9DF4 ass_not_unary_less_than
9DFE ass_not_unary_greater_than
9E14 ass_expression_cannot_be_unary
9E23 ass_expression_loop7
9E3A ass_expression_loop6
9E42 exp_no_operators_left
9E4B exp_done
9E51 exp_done_error
9E56 exp_done_ok
9E68 ass_expression_apply_operator
9E91 ass_expression_unary
9EA4 ass_expression_apply_operator_bug
9EA9 ass_evaluate_operator
9EAC ass_lookup_loop
9ECA ass_opcode_found
9ED0 ass_emit
9EE4 ass_emit2
9EF3 ass_already_emitted
9EFE ass_emit4
9F05 ass_emit3
9F0B ass_emit1
9F0E ass_error
9F15 ass_error1
9F18 ass_fixup_bbr_branch
9F25 ass_fixup_branch
9F3E ass_branch_backwards
9F42 ass_branch_ok
9F48 ass_branch_out_of_range
9F51 ass_emit_zero_page
9F5F ass_emit_zero_page_too_high
9F64 ass_emit_immediate
9F72 ass_emit_immediate_too_high
9F77 ass_emit_absolute
9F82 OPCODE_LOOKUP_TABLE
A025 DIRECTIVES
A098 OPCODE_4_CHAR_BRANCH
A0E9 OPCODE_3_CHAR_BRANCH
A10E OPCODE_3_CHAR_IMPLIED
A18B OPCODE_4_CHAR_ZERO_PAGE
A1DC OPCODE_ASS_OPERAND_ABSOLUTE
A245 OPCODE_ASS_OPERAND_ABSOLUTE_TOKENISED
A248 OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
A24D OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
A292 OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X_TOKENISED
A295 OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
A2BA OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y_TOKENISED
A2BD OPCODE_ASS_OPERAND_ACCUMULATOR_A
A2D6 OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT
A2DB OPCODE_ASS_OPERAND_IMMEDIATE
A30C OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED
A30F OPCODE_ASS_OPERAND_ZERO_PAGE
A370 OPCODE_ASS_OPERAND_ZERO_PAGE_TOKENISED
A373 OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
A394 OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT_TOKENISED
A397 OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
A3E0 OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X_TOKENISED
A3E3 OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
A3EC OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT
A40D OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_TOKENISED
A410 OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
A431 OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y_TOKENISED
A434 asm_do_assert
A443 asm_do_assert_failed
A448 asm_do_constant_expectedJ
A44B asm_do_list
A45A asm_do_nolist
A465 asm_do_nolist_ok
A46B asm_do_list_no_operand
A46F asm_do_list_ok
A485 asm_do_list_not
A489 asm_do_list1
A498 asm_do_list_first_pass
A499 asm_do_asc
A4A4 asm_do_asc_ok
A4A6 asm_do_asc_loop
A4AF asm_do_asc_next
A4B4 asm_do_string
A4BD asm_do_equ
A4CE asm_do_equ_have_label
A4DA asm_do_org
A4E0 asm_do_constant_expected
A4E5 asm_do_org_ok
A4EE asm_do_dfb
A4FC asm_do_dfb_multiple
A509 asm_do_dfb_multiple_loop
A51A asm_do_dfb_multiple_done
A51B asm_do_dfb_too_big
A520 asm_emit_one_byte
A52E asm_do_dfw
A53C asm_do_dfw_multiple
A54A asm_do_dfw_multiple_loop
A55B asm_do_dfw_multiple_done
A55C asm_emit_two_bytes
A56B asm_do_blk
A57B asm_do_blk_loop
A588 asm_do_blk_done
A589 asm_do_reserve
A5A1 asm_do_constant_expectedJ2
A5A4 asm_do_sym
A5BD asm_do_sym_done
A5BE info_message
A5C9 list_symbols
A5D8 list_symbols_next
A5E3 list_symbols_check
A5F2 list_symbols_line
A60C list_symbols_name
A61D list_symbols_done
A61E assembler_library_functions_table
AA8A add_assembler_library_functions
AA92 add_assembler_library_functions_loop
AAA2 add_assembler_library_functions_name_loop
AAD4 add_assembler_library_functions_done
AAD5 exp_add
AAE9 exp_subtract
AAFF exp_true
AB08 exp_false
AB0F exp_eql
AB23 exp_neq
AB37 exp_less_than
AB3E exp_greater_than
AB4D exp_leq
AB5C exp_geq
AB63 exp_bitwise_or
AB78 exp_bitwise_and
AB8D exp_bitwise_xor
ABA2 exp_trueJ
ABA5 exp_falseJ
ABA8 exp_logical_or
ABB7 exp_logical_and
ABC9 exp_shift_left
ABD8 exp_shift_left_loop
ABE1 exp_shift_left_done
ABE2 exp_shift_right
ABF1 exp_shift_right_loop
ABFA exp_shift_right_done
ABFB exp_negate
AC0E exp_not
AC1C exp_unary_minus
AC30 exp_low_byte
AC35 exp_high_byte
AC3E exp_abs_val
AC42 exp_negate_val
AC55 exp_abs_val_done
AC56 exp_abs_val2
AC5A exp_negate_val2
AC6D exp_abs_val2_done
AC6E ZERRES
AC77 exp_find_sign
AC8F exp_fix_sign
ACA2 exp_fix_sign_done
ACA3 exp_multiply
ACA8 exp_multiply_loop
ACC9 exp_multiply_no_add
ACDC exp_divide
ACEC exp_divide_not_zero
ACF9 exp_divide_loop
AD21 exp_divide_subtraction_negative
AD22 exp_divide_subtraction_positive
AD3C exp_modulo
AD4C execution_address_table
ADD8 DM1
ADE1 DM2
ADEA running_message
ADF3 DB11
ADF3 DEBUG
AE5B DEBUG_DONE
AE5C INTERP
AE82 DM5
AE97 DM6
AEA2 DM7
AEBC display_x_characters
AEC3 DIS5
AECD DIS5_A
AEDA BELL1
AEE4 RUNERR
AEF8 EX_FINISHD
AF0F FIN_MSG
AF2E CHK_KBD
AF3A CHK_NOTN
AF48 CHK_NOTT
AF56 CHK_NOTD
AF58 EX_OUTCR
AF5E LOWLIT
AF64 LOWLIT1
AF6A MAINP
AF6D MAIN
AF74 MAIN_2
AF7F MAIN_NOT_ABORT
AF82 MAIN_OK
AF9C MAIN_1
AFAB EX_INVINS
AFAF NOTIM1
AFBC GETADR
AFC6 GET2
AFE7 GETADR1
B002 GET1_A
B003 PULTOP
B01E PUL_END
B025 PULBOTH
B028 PULTOP2
B043 PUL2_END
B04A PSHTOP
B055 PSH1
B066 GETLIT
B07C GET_END
B07D EX_LIT
B08C LIT1
B08F EX_NEG
B098 EX_ADD
B0A1 EX_SUB
B0AD EX_MUL
B0B6 EX_GETKEY
B0BD EX_MOD
B0D1 EX_DIVIDE_BY_ZERO
B0D8 DIVBY0
B0E8 EX_DIV
B0FC EX_ABS
B105 EX_EQL
B10E TRUE
B110 TRUE2
B11B FALSE
B11F EX_NEQ
B128 EX_LSS
B134 EX_GTR
B140 EX_GEQ
B14C EX_LEQ
B158 EX_XOR
B161 EX_ORR
B16A EX_AND
B173 EX_EOR
B17C EX_SHL
B188 EX_SHR
B194 EX_INC
B1AC EX_DEC
B1C4 EX_MOV
B1D5 EX_LODC
B1D8 EX_LOD3
B1DA EX_LOD3_A
B1E7 EX_LOD
B1EA EX_LOD2
B1FD EX_LDAC
B208 EX_LDA
B212 GETIDC
B21B GETIDX
B22F GETID2
B23D EX_LDIC
B243 EX_LDI
B249 EX_STOC
B251 EX_STO5
B256 EX_STO
B25C EX_STO2
B269 EX_STA
B27A EX_STA5
B27F EX_STAC
B288 EX_STIC
B296 EX_STI
B2B1 EX_RTN
B2EA EX_INP
B2FB EX_INP_OK
B312 INP3
B322 BAD_INP
B32A EX_OUT
B32F EX_LCD_WRITE_NUM
B332 OUT_COMMON
B33E EX_OUH
B343 EX_LCD_WRITE_HEX
B346 EX_OUH_COMMON
B35E EX_OUS
B363 EX_LCD_WRITE_STR
B366 EX_OUS_COMMON
B382 EX_OUS1
B391 EX_ABSCLL
B398 EX_CLL
B3A0 EX_CLL_A
B3BE EX_CLL4
B3C2 EX_CLL2
B3E3 EX_CLL3
B424 EX_CLL5
B427 EX_CLA
B444 EX_CLL_JMP
B447 EX_INT
B45E INT_ERR
B465 INT_ERRM
B471 EX_NEW_STACK
B483 EX_JMP
B496 EX_JMZ
B4A1 EX_NOJUMP
B4A7 EX_JM1
B4B2 EX_INPC
B4BC EX_INPC_OK
B4CC EX_OUTC
B4D1 EX_LCD_WRITE_CHR
B4D4 EX_OUTC_COMMON
B4E2 EX_LCDHOME
B4E8 EX_LCDCLEAR
B4EE EX_INS
B4F8 EX_INS3
B511 EX_INS1
B51A EX_INS2
B524 EX_INS4
B531 execution_aborted_message
B545 ex_input_aborted
B54C EX_ADRNC
B54F EX_ADRNC2
B55C EX_ADRNN
B55F EX_ADRN2
B56A EX_ADRAN
B570 EX_ADRAC
B576 EX_DIGITALREAD
B581 EX_DIGITALREAD_ONE
B584 EX_LCDPOS
B594 EX_LCDPOS_1
B59E EX_RANDOM
B5B0 EX_LATENCY
B5BF EX_DELAY
B5CF EX_RANDOMSEED
B5DF EX_PINMODE
B5EE EX_DIGITALWRITE
B5FD EX_LIB_CALL
B603 EX_ASSERT
B618 EX_ASSERT_OK
B61B break_message
B636 a_equals_message
B63E x_equals_message
B646 y_equals_message
B64E p_equals_message
B656 s_equals_message
B65E id_equals_message
B667 brk_executed
B6E2 brk_executed1
B6EF brk_executed2
B6FF brk_executed3
B713 stack_message
B71B brk_executedJ
B71E irq
B72B irq1
B743 cb2_interrupt
B74F serial_in_loop
B774 timer1_interrupt
B78F write_zero
B794 serial_send_count_bits
B7A3 irq_done
B7A6 lcd_initialise
B7FF lcd_prepare_to_read_register
B812 lcd_prepare_to_write_data
B827 lcd_prepare_to_write_instruction
B83A lcd_set_enable
B843 lcd_clear_enable
B84C lcd_read_instruction_nibble
B858 lcd_wait
B860 lcdbusy
B86F lcd_wait_timeout
B873 lcd_get_address
B887 lcd_write_instruction_nibble
B893 lcd_instruction
B8A6 lcd_data_nibble
B8B5 lcd_print_char
B8C0 lcd_print_not_newline
B8CF lcd_print_char_on_2nd_line
B8D6 lcd_print_char_newline
B8D6 lcd_print_char_ok
B8E7 lcd_clear_display
B8EF lcd_second_line
B8F7 lcd_home
B8FF lcd_print_message
B908 lcd_print
B912 lcd_print_done
B913 SEARCH
B91B SEA_NEXT
B926 SEA1
B933 SEA2
B97C SEA4
B984 SEA5
B987 SEA3
B98A SYM_FULL
B98F ADDSYM
B9C4 ADDSYM_NOT_FULL
B9EB ADD1
BA0E ADD4
BA2A ADD9
BA2B LOOKUP
BA35 LOOK1
BA36 CHKDUP
BA45 DUP9
BA46 COMPIL
BA94 END_CMP
BA97 CHKLHP
BA9E CHKRHP
BAA8 GETSUB
BAB1 CHKLHB
BABB CHKRHB
BAC5 GET_LEV
BACF GET_DAT
BAD6 CONDEC
BB01 SYMWRK
BB0C WRKSYM
BB17 PSHPCODE
BB2A GET_OFF
BB46 GETO_1
BB53 GETO_2
BB55 GETEXPR
BB5B PCD_WRKD
BB66 WRK_OPND
BB71 WRKD_WRK
BB7C WRK_WRKD
BB87 GET_COMM
BB8E GET_ITEM
BB94 VAL_MOVE
BB9D VAL_1
BBA2 VAL_2
BBAB VAL_3
BBB4 VAL_5
BBBD CHK_STAK
BBC4 STK_ERR
BBC4 STK_FULL
BBC9 CONST
BBE0 CONST1
BBE5 CONST3
BBEA CONST2
BBEE CONST9
BBEF VARDEC
BC01 SIMEXP
BC0B SIM1
BC1C SIM3
BC2F SIM4
BC45 SIM7
BC4B SIM5
BC4F SIM6
BC53 SIM2
BC59 SIM8
BC5D TERMT1
BC73 TERM
BC76 TERM2
BC80 TERM1
BC8F TERM4
BC91 TERM3
BC97 TERM5
BC9B TERM6
BC9F TERM7
BCA3 TERM8
BCA7 TERM9
BCAB TERMT3
BCC1 FACTOR
BCD2 IDENT
BCD5 IDENT1
BCDD IDENT1A
BCE2 IDENT2
BCFB IDENT2A
BD02 IDENT3
BD10 FACAD1
BD18 IDENT5
BD1A IDENT5_A
BD25 IDENT6
BD2B IDENT7
BD2E FACAD2
BD36 IDENT4
BD38 IDENT4_A
BD58 FACADR
BD6B FACSTR
BD71 FACERR1
BD76 FACNUM
BD7C PAREN
BD82 FACMEM
BD88 FACMMC
BD8C FACM2
BD98 FACNOT
BDA0 GENNOP1
BDA3 FACRND1
BDA9 FACTB1
BDAF FACTQT1
BDC2 EXPRES
BDD2 EXPTB1
BDE5 EXPR1
BDF4 EXPTB3
BE07 EXPR2
BE09 EXPR8
BE0D EXPR3
BE11 EXPR4
BE15 EXPR5
BE19 EXPR6
BE1D EXPR7
BE21 STMNT
BE2E STMNT1
BE59 ASSIGN
BE5C ASS1
BE68 ASSTB1
BE7E assign_bad_identifier
BE83 ASSARR
BE95 ASSVAR
BEA4 ASS2
BEC0 WRITELN
BECA WRITELN9
BECF WRITE
BED2 WRIT9
BEE1 W_STRING
BEEB WRIT2
BEEE WRIT10
BEFB WRIT1
BF0B WRIT5
BF14 W_CHR
BF16 W_CHR1
BF1C W_HEX
BF20 STMNT_WRITE_LCD
BF23 WRITE_LCD9
BF32 WRITE_LCD_STRING
BF3C WRITE_LCD2
BF4C WRITE_LCD1
BF5C WRITE_LCD5
BF65 WRITE_LDC_CHR
BF67 WRITE_LDC_CHR1
BF6D WRITE_LDC_HEX
BF71 READ
BF74 READ8
BF77 READ2
BF8E READ9
BF91 READ11
BFB0 READ7
BFB6 READ7_A
BFC0 READ3
BFD4 READ3_B
BFEF READ3_A
BFFD TWO_OP
C003 ONE_OP2
C006 ONE_OP
C00D GENNOP2
C010 WAIT_1
C01A MEM
C01F MEMC
C022 MEM2
C035 CALLSB
C042 FNCPRC
C04F FNC2
C079 FNC3
C07F FNC1
C082 FNC5
C09F FNC5A
C0A1 FNC5B
C0C3 FNC4
C0C4 FNC6
C0C9 IF
C0E7 IF2
C0EE IF1
C109 BEG
C11F REPEAT
C122 REP1
C143 WHILE
C175 CASE
C183 CASE7
C187 CASE2
C1AE CASE1
C1BA CASE4
C1C4 CASE3
C1F7 CASE5
C215 CASE6
C220 CASE9
C22A CASE8
C230 FOR
C23A FOR1
C247 FOR2
C260 FOR3
C291 FOR4
C2D4 FOR5
C2F6 FOR6
C303 CHKGET
C309 WRK_VAL
C314 VAL_WRK
C31F END_WRK
C32A BLCKT1
C32D BLCKT2
C330 BLCKT3
C33A BLOCK
C351 BLK1A
C365 BLK1
C36D BLK2
C377 BLK4
C381 BLKCNS
C384 BLKCN1
C398 BLKVAR
C39C BLKVR1
C39F BLKVR6
C3A9 BLKVR7
C3C8 BLKVR8
C3CB BLKV10
C3E7 BLKV10_A
C3EE BLKV10_B
C3FD BLKVR2
C416 BLKV13
C41B BLKVR4
C455 BLKV11
C45C BLKV12
C462 BLKVR9
C47B BLKVR5
C4BD BLKVR3
C4D5 BLKPRC
C4F5 BLKFNC
C517 BLKPR1
C533 BLKPR3
C540 BLKPR6
C549 BLKPR2
C56A BLKPR5
C591 BLKPR4
C5BD BLKBEG
C5C7 BLKB3
C5CD BLKB1
C5E9 BLKB2
C5F6 BLKB5
C605 BLKB4
C614 BLKB6
C617 pascal_library_functions_table
C6B7 add_pascal_library_functions
C6BF add_pascal_library_functions_loop
C6CF add_pascal_library_functions_name_loop
C710 add_pascal_library_functions_done
C711 library_function_call
C71E library_function_call_2
C748 library_function_call_3
C74D library_function_call_1
C750 library_function_call_5
C761 GENNOP
C776 GEN1
C77A GENADR
C7AD GEN2
C7AF GEN2_B
C7B8 GEN2_A
C7CA GEN_FULL
C7CF DISP9
C7CF GEN2_C
C7D0 GENRJMP
C7E2 GENNJP
C7E4 GENNJM
C7EA GENJMP
C813 GEN3
C818 FIXAD
C855 FIXAD1
C856 FIXM1
C85F FIXM2
C86B pin_number_to_mask
C871 pin_number_to_mask_loop
C879 pin_number_to_mask_done
C87E pinmode
C88F pinmode_B
C897 pinmode_C
C8A5 pinmode_OUTPUT
C8AD digitalwrite
C8BE digitalwrite_B
C8C6 digitalwrite_C
C8D4 digitalwrite_ONE
C8DC digitalread
C8EB digitalread_B
C8F3 digitalread_C
C8F9 write_to_serial
C904 write_to_lcd
C90F CHRIN
C90F GETIN
C919 GETIN1
C920 serial_available
C923 EMULATOR_DEBUG
C924 START_TRACE
C925 STOP_TRACE
C926 hardware_init
C957 write_char
C973 write_char_loop
C97C serial_print_message
C982 serial_print
C98C serial_print_done
C98D get_token
C991 get_token_loop
C99B gc_skip_spaces
C9B0 gc_newline
C9BD gc_newline1
C9CA gc_newline_assembling
C9CF gc_single_byte_already_known
C9D1 gc_single_byte_token
C9D3 gc_done
C9EB gc_not_space
C9F0 gc_alpha_loop
C9F8 gc_alpha_ok
CA09 gc_alpha_done
CA0D gc_alpha_alpha_only
CA16 gc_not_alpha
CA22 gc_not_digit
CA2D token_line
CA33 token_line1
CA4E token_line_listing
CA66 token_line_loop
CA76 token_line_loop1
CA7B token_line_done
CA7C atoi
CA85 atoi_loop
CA94 atoi_positive
CA96 atoi_more
CAEB atoi_error
CAF1 atoi_not_running
CAF6 negate_token_value
CB0A gtoken_table
CB3B gtoken_directive_table
CB48 gc_single_byte_tokenJ
CB4B gc_single_byte_already_knownJ
CB4E gc_lh_brace
CB52 gc_lh_paren
CB60 gc_pascal_comment
CB7F gc_pascal_comment_find_end
CB8A gc_comment_not_eof
CB93 gc_comment_not_newline
CBA2 gc_comment_keep_looking
CBAA gc_comment_found_end
CBBA gc_directive_symbols
CBC6 gc_directive_symbols_ok
CBED gc_directive_symbols_too_late
CBF2 gc_directive_list
CBF9 gc_directive_pcodes
CBFF gc_directive_nolist
CC08 gc_semicolon
CC11 gc_assembler_comment_find_end
CC1C gc_assembler_comment_not_eof
CC23 gc_assembler_comment_keep_looking
CC2B gc_backslash_tokens
CC41 gc_backslash_tokens_end
CC41 gc_quote
CC4F gc_quote_loop
CC58 gc_quote_bad
CC5D gc_quote_loop_not_end_of_line
CC72 gc_quote_long_string
CC7D gc_quote_copied_value
CC86 gc_quote_done
CC98 gc_quote_not_finished
CCAA gc_quote_backslash_loop
CCB5 gc_quote_bad_string
CCBA gc_quote_hex_character_done
CCBE gc_quote_found_backslash_character
CCC2 gc_quote_not_backslash
CCCE gc_quote_too_long
CCD3 gc_fix_hex
CCDC gc_fix_hex_not_a_to_f
CCE0 gc_quote_hex_character
CD0C gc_quote_hex_character_one_only
CD0F gc_dollar
CD1B gc_hex_literal
CD24 gc_hex_loop
CD5F gc_hex_done
CD64 gc_hex_too_big
CD69 gc_percent
CD75 gc_binary_literal
CD7D gc_binary_loop
CD93 gc_colon
CD9E gc_assign
CDA4 gc_less_than
CDB8 gc_leq
CDBD gc_neq
CDC2 gc_shift_left
CDC7 gc_greater_than
CDD4 gc_single_byte_already_knownJ2
CDD7 gc_geq
CDDC gc_shift_right
CDE1 gc_minus
CDE3 gc_plus
CE02 gc_ampersand
CE0D gc_logical_and
CE13 gc_bar
CE1E gc_logical_or
CE24 gc_equals
CE2F gc_equality
CE35 gc_bang
CE40 gc_inequality
CE46 RSVWRD
CF39 RSVEND
CF3B pas_get_token
CF44 pas_get_token_eof
CF45 pas_gc_identifier
CF4D pas_gc_loop
CF56 pas_gc_more
CF7E pas_gc_no_match
CF8F GETCHK
CF9A CHKNOK
CF9D CHKOK
CF9F CHKTKN
CFA4 GET_LOOK
CFAE i2c_init
CFB9 i2c_delay
CFBD i2c_toggle_clock
CFC5 i2c_toggle_clock_wait
CFD8 i2c_begin_transmission
CFDC i2c_begin_transmission_loop
CFFF i2c_write
D002 i2c_write_loop
D00E i2c_write_one
D019 i2c_write_clock
D029 i2c_write_clock_wait
D041 i2c_write_lost_arbitration
D043 i2c_write_got_ack
D045 i2c_read
D04E i2c_read_loop
D063 i2c_read_zero
D067 i2c_read_next
D07D i2c_read_nak
D082 i2c_read_ack_or_nak
D087 i2c_read_ack_or_nak_wait
D099 i2c_read_done
D09B i2c_end_transmission
D0B4 i2c_send_message
D0BC i2c_send_message_loop
D0D3 i2c_send_message_done
D0D8 i2c_send_message_fail
D0DD i2c_receive_message
D0EB i2c_receive_message_loop
D100 i2c_receive_message_done
D105 i2c_receive_message_fail
D10A LCD_welcome
D129 START
D145 RESTART
4240 CLOCK_RATE
