Sections:
00: "seg8000" (8000-DC7F)
01: "segfffa" (FFFA-0)


Source: "gpascal.asm"
                        	     1: ;***********************************************
                        	     2: ; G-PASCAL COMPILER
                        	     3: ; for Ben Eater's breadboard computer
                        	     4: ;
                        	     5: ; Author: Nick Gammon
                        	     6: ; Date: 20 January 2022
                        	     7: ;
                        	     8: ; To compile:
                        	     9: ;
                        	    10: ;  vasm6502_oldstyle gpascal.asm -wdc02 -esc -Fbin -o gpascal.bin -dotdir -L gpascal.list
                        	    11: ;
                        	    12: ; To program EEPROM:
                        	    13: ;
                        	    14: ;  minipro -p AT28C256 -w gpascal.bin
                        	    15: ;
                        	    16: ;
                        	    17: ;
                        	    18: ; To communicate, I suggest: miniterm /dev/ttyUSB0 4800 -e
                        	    19: ;
                        	    20: ;   Miniterm: Ctrl+]        : to exit.
                        	    21: ;             Ctrl+T Ctrl+H : help
                        	    22: ;             Ctrl+T Ctrl+E : toggle local echo
                        	    23: ;
                        	    24: ;
                        	    25: ;  Copyright 2022 by Nick Gammon
                        	    26: ;
                        	    27: ;  Permission is hereby granted, free of charge, to any person obtaining a copy
                        	    28: ;  of this software and associated documentation files (the "Software"), to deal
                        	    29: ;  in the Software without restriction, including without limitation the rights
                        	    30: ;  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                        	    31: ;  copies of the Software, and to permit persons to whom the Software is
                        	    32: ;  furnished to do so, subject to the following conditions:
                        	    33: ;
                        	    34: ;  The above copyright notice and this permission notice shall be included in all
                        	    35: ;  copies or substantial portions of the Software.
                        	    36: ;
                        	    37: ;  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                        	    38: ;  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                        	    39: ;  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                        	    40: ;  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                        	    41: ;  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                        	    42: ;  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
                        	    43: ;  SOFTWARE.
                        	    44: ;
                        	    45: ;***********************************************
                        	    46: ;
                        	    47: 
                        	    48: ; Note: BCC == BLT and BCS == BGE
                        	    49: ;
                        	    50: 
                        	    51: ;
                        	    52: ;  CONDITIONAL COMPILES
                        	    53: 
                        	    54: EMULATOR = 0          ; for testing on a PC running an emulator
                        	    55: LCD_SUPPORT = 1       ; 1 = support LCD, 0 = not. Unset if you have removed the LCD.
                        	    56: USE_CP437_FONT = 1    ; 1 = include the symbols for the CP437 font for use with MAX7219 chip, 0 = omit them
                        	    57: USE_PASCAL = 1        ; 1 = include the G-Pascal compiler, 0 = omit it
                        	    58: USE_ASSEMBLER = 1     ; 1 = include the assembler, 0 = omit it
                        	    59: 
                        	    60: SERIAL_DEBUGGING = 0  ; if set, toggle VIA PA2 when reading a bit, and PA3 when writing a bit
                        	    61:                       ;  DO NOT USE I2C if this is on, as I2C functions use these two pins
                        	    62: 
                        	    63: 
                        	    64: ;
                        	    65: ;  CONFIGURATION
                        	    66: ;
                        	    67: CLOCK_RATE   = 1000000   ; 1 Mhz
                        	    68: START_OF_ROM = $8000     ; where the ROM chip starts
                        	    69: HIGHEST_RAM  = $3FFF      ; original board hardware
                        	    70: ;HIGHEST_RAM  = $5FFF    ; with suggested additional AND gate
                        	    71: 
                        	    72: RUNNING_STACK_TOP = $CF   ; top of stack when running assembler code
                        	    73: 
                        	    74: ;
                        	    75: ;  serial output
                        	    76: ;
                        	    77: BAUD_RATE    = 4800         ; baud
                        	    78: BIT_INTERVAL = CLOCK_RATE / BAUD_RATE ; time between bits in Âµs
                        	    79: 
                        	    80: ;
                        	    81: ;  serial input - input commences on the interrupt generated by the falling edge
                        	    82: ;    of the start bit. Bits are then clocked in with a timed loop.
                        	    83: ;  - these delays can be tweaked if you believe the serial input is not being
                        	    84: ;    sampled at the right moment, confirm by turning SERIAL_DEBUGGING on
                        	    85: ;    and checking the debugging pulses compared to the middle of the bit times
                        	    86: ;    with an oscilloscope or logic analyser
                        	    87: ;
                        	    88: SERIAL_DELAY1 = 48    ; initial delay (count) - higher because it is 1.5 bit times
                        	    89: SERIAL_DELAY2 = 35    ; subsequent delays between bits (count)
                        	    90: 
                        	    91: SYMBOL_TABLE_START = HIGHEST_RAM  ; symbol table pointer (ENDSYM) is decremented before being used
                        	    92: 
                        	    93: STACK            =  $100  ; hardware stack address
                        	    94: SPACE            =  $20   ; uh-huh
                        	    95: SINGLE_QUOTE     =  $27
                        	    96: NL               =  $0A   ; newline
                        	    97: CR               =  $0D   ; carriage-return
                        	    98: BACKSPACE        =  $08   ; backspace
                        	    99: 
                        	   100: MAX_STK          =  32
                        	   101: NEW_STK          =  $FF
                        	   102: 
                        	   103:     .if EMULATOR
                        	   104: END_EDITOR_INPUT =  '`'   ; backtick terminates input
                        	   105:     .else
                        	   106: END_EDITOR_INPUT =  $1B   ; Esc terminates editor input
                        	   107:     .endif
                        	   108: 
                        	   109: KEY_DEBUG      = 'D'-$40   ; Ctrl+D start debugging
                        	   110: KEY_TRACE      = 'T'-$40   ; Ctrl+T start tracing
                        	   111: KEY_STOP_TRACE = 'N'-$40   ; Ctrl+N stop tracing
                        	   112: KEY_ABORT      = 'C'-$40   ; Ctrl+C abort execution
                        	   113: 
                        	   114: 
                        	   115:   .if LCD_SUPPORT
                        	   116: ;
                        	   117: ;  Pins connected from the VIA to the LCD
                        	   118: ;
                        	   119: LCD_RS             = %00100000  ; PA 5 - 0 = instruction, 1 = data
                        	   120: LCD_RW             = %01000000  ; PA 6 - 0 = write, 1 = read
                        	   121: LCD_E              = %10000000  ; PA 7 - toggle (0 -> 1 -> 0) to clock out a command or data
                        	   122:   .endif
                        	   123: 
                        	   124:   .include "zp_variables.inc"

Source: "zp_variables.inc"
                        	     1: ;***********************************************
                        	     2: ;
                        	     3: ; Zero-page variables (currently 64 (decimal) bytes are free for your use).
                        	     4: ;  I suggest using the high ones and working down in case there is a change to the code.
                        	     5: ;  For example, start with 0xFF, then 0xFE and so on.
                        	     6: ;
                        	     7: ;***********************************************
                        	     8: 
                        	     9:   .dsect
                        	    10: 
                        	    11: 
                        	    12: ;
                        	    13: ;  General work-areas for arithmetic routines (eg. add, subtract, divide, multiply)
                        	    14: ;   3-byte signed numbers: -8388608 to +8388607
                        	    15: ;
00:0000 00              	    16: VALUE    reserve 3    ; the current value of the token (ie. if a number)
00:0001 *
00:0003 00              	    17: VALUE2   reserve 3    ; used by the assembler expression evaluator
00:0004 *
                        	    18: 
                        	    19: ; SRCE and DEST used in compiler and editor, particularly for string comparisons
                        	    20: ;   (re-using VALUE and VALUE2)
                        	    21: 
                        	    22: SRCE     =  VALUE
                        	    23: DEST     =  VALUE2
                        	    24: 
00:0006 00              	    25: REMAIN   reserve 3    ; division remainder
00:0007 *
                        	    26: 
                        	    27: ;
                        	    28: ;  work "register" - re-using VALUE and VALUE2 again
                        	    29: ;
                        	    30: REG   = VALUE
                        	    31: REGB  = VALUE+2
                        	    32: REG2  = VALUE2
                        	    33: REG2B = VALUE2+2
                        	    34: 
                        	    35: ;
                        	    36: ;  re-using above for CRC-16 calculations
                        	    37: ;
                        	    38: crc_addr = VALUE      ; the address to take a CRC of (2 bytes)
                        	    39: crc_num  = VALUE2     ; the number of bytes to take a CRC of (2 bytes)
                        	    40: crc_val  = REMAIN     ; the current CRC value (2 bytes)
                        	    41: 
                        	    42: ;
                        	    43: ;  current random number - change this to reseed it
                        	    44: ;
00:0009 00              	    45: random         reserve 4 ; 32-bit random number
00:000A *
00:000D 00              	    46: typing_latency reserve 3 ; incremented while waiting for input
00:000E *
                        	    47: 
                        	    48: ;
                        	    49: ;  Used for seeding registers when calling machine code from Pascal
                        	    50: ;
00:0010 00              	    51: call_a reserve 1      ; used when doing a machine code call:  A register
00:0011 00              	    52: call_x reserve 1      ;  ditto: X register
00:0012 00              	    53: call_y reserve 1      ;  ditto: Y register
00:0013 00              	    54: call_p reserve 1      ;  ditto: status register
00:0014 00              	    55: call_s reserve 1      ; stack register, used by BRK
00:0015 00              	    56: brk_address reserve 2 ; BRK address
00:0016 *
                        	    57: 
                        	    58: ;
                        	    59: ;  address of write function (2 bytes)
                        	    60: ;
                        	    61: ;  This is called by "character out" function COUT. It writes the character in "A" to
                        	    62: ;   serial port or LCD. You could conceivably put another function address here if
                        	    63: ;   you wanted to capture output (eg. from calling DISP_BIN) and putting it somewhere else
                        	    64: ;   like into a series of memory locations, or to output to SPI.
                        	    65: ;  The functions write_to_serial and write_to_lcd
                        	    66: ;   put the appropriate outputting functions into this location.
                        	    67: ;
00:0017 00              	    68: write_function reserve 2  ; address of function to write to serial or LCD
00:0018 *
                        	    69: 
                        	    70: 
00:0019 00              	    71: LINE_CNT  reserve 2   ; line counter during compile
00:001A *
                        	    72: LINE_NO  =  LINE_CNT
                        	    73: 
00:001B 00              	    74: WX       reserve 2    ; 2-byte address used during compilation (reserved word lookup)
00:001C *
00:001D 00              	    75: LIST     reserve 1    ; 0 = no listing, 1 = list source during compile
00:001E 00              	    76: DIGIT    reserve 1    ; used only in GET_NUM to process a decimal number
00:001F 00              	    77: SIGN     reserve 1    ; used in compiling and inputting a number - is there a minus sign?
                        	    78: 
00:0020 00              	    79: FRAME    reserve 2    ; stack frame number - not totally certain but it used for procedure calls at runtime
00:0021 *
00:0022 00              	    80: LEVEL    reserve 1    ; current nested procedure/function level (how far we are nested)
00:0023 00              	    81: PCODE    reserve 2    ; current P-code address (increments during compile and running)
00:0024 *
                        	    82: PNTR     =  PCODE     ; 2-byte work pointer used in editor (eg. in find/replace etc.)
00:0025 00              	    83: ACT_PCDA reserve 2    ; start of P-codes (after source) - does not increment
00:0026 *
00:0027 00              	    84: DISPL    reserve 2    ; level? ahhh ... I don't know
00:0028 *
00:0029 00              	    85: OFFSET   reserve 2    ; variable offset? maybe just a work area
00:002A *
00:002B 00              	    86: OPND     reserve 3    ; jump operand ... not sure
00:002C *
00:002E 00              	    87: DCODE    reserve 1     ; 0 = no display, 1 = display P-codes during compile
00:002F 00              	    88: STARTSYM reserve 2    ; start of symbol table
00:0030 *
00:0031 00              	    89: ENDSYM   reserve 2    ; end of symbol table - used for reverse searching symbols
00:0032 *
                        	    90: T        =  ENDSYM     ; stack pointer 2 bytes
00:0033 00              	    91: WORKD    reserve 2    ; work area for holding P-code address
00:0034 *
00:0035 00              	    92: ERRNO    reserve 1    ; current error number, if ERROR called
00:0036 00              	    93: BSAVE    reserve 1    ; seems to be used to save "A" register, lol
00:0037 00              	    94: WORK     reserve 2    ; work area, used for pushing 2-bytes onto the (processor) stack
00:0038 *
00:0039 00              	    95: PRCITM   reserve 2    ; seems to hold the current procedure/function symbol
00:003A *
00:003B 00              	    96: BASE     reserve 2    ; the base interpreter stack frame (for this procedure)
00:003C *
                        	    97: TO       =  BASE      ; Used in editor (from/to list ranges, and copying text)
00:003D 00              	    98: DATA     reserve 2    ; 2-byte address work-area for calculating the address of a variable at runtime
00:003E *
00:003F 00              	    99: RUNNING  reserve 1    ; 0x40 - in editor, 0x80 - executing - affects stuff like numeric conversion
00:0040 00              	   100: SYMITM   reserve 2    ; current symbol table item (found by searching)
00:0041 *
                        	   101: FROM     =  SYMITM    ; Used in editor (from/to list ranges, and copying text)
00:0042 00              	   102: SYNTAX   reserve 1    ; 0 = full compile, 1 = syntax-only compile (no writing to memory)
00:0043 00              	   103: END_PCD  reserve 2    ; where the P-codes ended after a compile
00:0044 *
00:0045 00              	   104: TEMP     reserve 2    ; temporary work area?
00:0046 *
00:0047 00              	   105: CALL     reserve 2    ; the procedure address we are calling
00:0048 *
00:0049 00              	   106: DBGFLG   reserve 1    ; 0 = not debugging, 1 = debugging, $80 = tracing
00:004A 00              	   107: DATTYP   reserve 1    ; 0 for integers and 1 for characters
00:004B 00              	   108: COUNT1   reserve 1    ; work counter
00:004C 00              	   109: COUNT2   reserve 1    ; and another
00:004D 00              	   110: LASTP    reserve 2    ; 2-byte last P-code address executed at runtime (start of this P-code)
00:004E *
00:004F 00              	   111: IO_A     reserve 1    ; dunno
00:0050 00              	   112: IO_Y     reserve 1    ; seems to be used to save and restore Y
00:0051 00              	   113: IO_X     reserve 1    ;  ditto for X
00:0052 00              	   114: RES      reserve 3    ; multiplication result
00:0053 *
00:0055 00              	   115: DIVISOR  reserve 3      ; divisor for division
00:0056 *
00:0058 00              	   116: DVDN     reserve 3    ; dividend
00:0059 *
00:005B 00              	   117: RMNDR    reserve 1    ; for division, 0 if positive, 0x80 if negative
00:005C 00              	   118: bcd_work    reserve 4    ; work area for converting binary to decimal (packed)
00:005D *
00:0060 00              	   119: bcd_result  reserve 8    ; work area for turning numbers into printable (unpacked)
00:0061 *
00:0068 00              	   120: spi_mode   reserve 1   ; SPI mode: 0 to 3
00:0069 00              	   121: QUOT_SYM reserve 1     ; current quote symbol
00:006A 00              	   122: QT_SIZE  reserve 1    ; number of characters in reserved words
00:006B 00              	   123: ASS_OPERAND reserve 1 ; assembler operand type = see defines below
00:006C 00              	   124: OPCODE   reserve 2    ; address of opcode in assembler
00:006D *
00:006E 00              	   125: OPCODE_LEN reserve 1  ; length of opcode
00:006F 00              	   126: ASS_EMIT_COUNT reserve 1 ; number of bytes emitted on this line
00:0070 00              	   127: ASS_OPCODE_WORK reserve 2; for opcode lookups
00:0071 *
00:0072 00              	   128: ASS_COUNT reserve 1 ; for counting opcode matches
00:0073 00              	   129: ASS_VALUE reserve 3 ; the assembler operand (address or immediate) will be here
00:0074 *
00:0076 00              	   130: ASS_PASS  reserve 1 ; which assembler pass we are up to
00:0077 00              	   131: ass_emit_bytes reserve 2 ; how many bytes the assembler emitted altogether
00:0078 *
00:0079 00              	   132: exp_value_stack reserve 2  ; address of assembler value stack
00:007A *
00:007B 00              	   133: exp_value_stack_count reserve 1 ; how far through value stack we are (0 = empty)
00:007C 00              	   134: exp_operator_stack_count reserve 1 ;  how far through operator stack we are (0 = empty)
00:007D 00              	   135: exp_operator reserve 1  ; current operator for expression evaluation
00:007E 00              	   136: exp_operator_precedence reserve 1 ; current operator precedence
00:007F 00              	   137: exp_evaluation_function reserve 2 ; function to evaluate an expression
00:0080 *
00:0081 00              	   138: exp_unary_ok reserve 1  ; true if the next token can be a unary operator (like: - < >)
00:0082 00              	   139: show_symbols reserve 1  ; 4 = list the symbol table after an assemble, 8 = include library symbols
00:0083 00              	   140: ass_current_label reserve 2 ; current symbol table address of the label on this line
00:0084 *
00:0085 00              	   141: str_work reserve 1      ; work byte for string compares
                        	   142:   .if LCD_SUPPORT
00:0086 00              	   143: lcd_work  reserve 1 ; used by the LCD routines
                        	   144:   .endif
                        	   145: 
                        	   146: ;
                        	   147: ;  serial work
                        	   148: ;
00:0087 00              	   149: serial_out_byte reserve 2 ; current byte we are sending
00:0088 *
00:0089 00              	   150: serial_out_bit  reserve 1 ; current bit count
00:008A 00              	   151: serial_in_byte  reserve 1 ; current byte we are receiving
00:008B 00              	   152: serial_in_byte_received  reserve 1 ; last received byte
                        	   153: 
                        	   154: ;
                        	   155: ; hardware
                        	   156: ;
00:008C 00              	   157: hardware_work  reserve 1  ; work for use during interpreting
                        	   158: 
                        	   159: ;
                        	   160: ; maths
                        	   161: ;
00:008D 00              	   162: maths_work  reserve 1 ; work for multiply/divide
                        	   163: ;
                        	   164: ;  for get_token
                        	   165: ;
00:008E 00              	   166: token_start      reserve 2  ; where to start looking for a token
00:008F *
00:0090 00              	   167: token_address    reserve 2  ; where the token actually started
00:0091 *
00:0092 00              	   168: token_length     reserve 1  ; length of the token
00:0093 00              	   169: token_type       reserve 1  ; what type of token it is
00:0094 00              	   170: token_value      reserve 3  ; the value of numeric tokens
00:0095 *
00:0097 00              	   171: token_sign       reserve 1  ; non-zero if negative value
00:0098 00              	   172: token_work       reserve 3  ; temporary work area - also used by handlerLookup
00:0099 *
00:009B 00              	   173: token_digit      reserve 1  ; used by get_token
00:009C 00              	   174: token_line_start reserve 2  ; where the current line starts
00:009D *
                        	   175: 
                        	   176: ;
                        	   177: ;  for editor
                        	   178: ;
00:009E 00              	   179: from_line       reserve 2     ; list, delete, modify: FROM line number
00:009F *
00:00A0 00              	   180: to_line         reserve 2     ; list, delete, modify: TO line number
00:00A1 *
00:00A2 00              	   181: current_line    reserve 2     ; current editor line number
00:00A3 *
00:00A4 00              	   182: insert_limit    reserve 2     ; maximum we can input to
00:00A5 *
00:00A6 00              	   183: mem_move_src    reserve 2     ; for copying memory - source of move
00:00A7 *
00:00A8 00              	   184: mem_move_dest   reserve 2     ; for copying memory - destination of move
00:00A9 *
00:00AA 00              	   185: mem_move_len    reserve 2     ; for copying memory - length of move
00:00AB *
00:00AC 00              	   186: this_line       reserve 2     ; which line we are searching for
00:00AD *
00:00AE 00              	   187: this_line_addr  reserve 2     ; address of the "this" line
00:00AF *
00:00B0 00              	   188: find_from       reserve 1     ; editor find: from offset in INBUF (start of target string)
00:00B1 00              	   189: find_to         reserve 1     ; editor find: to offset in INBUF (end of target string)
00:00B2 00              	   190: find_pos        reserve 1     ; which offset in the current line we are currently searching from
00:00B3 00              	   191: find_len        reserve 1     ; the length of the find text
00:00B4 00              	   192: find_delimiter  reserve 1     ; the find/replace delimiter
00:00B5 00              	   193: rep_from        reserve 1     ; editor replace: start of replacement string
00:00B6 00              	   194: rep_to          reserve 1     ; editor replace: end of replacement string
00:00B7 00              	   195: rep_diff        reserve 2     ; difference in find/replace string lengths (signed 2 bytes)
00:00B8 *
00:00B9 00              	   196: find_count      reserve 2     ; count of find/replace
00:00BA *
00:00BB 00              	   197: found_this_line reserve 1     ; did we find something on this line?
                        	   198: insert_last_char = find_from  ; the last character we inserted in INSERT/LOAD mode
                        	   199: 
00:00BC 00              	   200: editor_flags    reserve 1     ; various flags, see below
                        	   201: 
                        	   202: EFLAG_SHOW_LINE        = %00000001    ; set after receiving a newline, so we display the next line
                        	   203: EFLAG_ALLOW_ZERO_FROM  = %00000010    ; for use with MEMORY, allow them to start from $0000
                        	   204: EFLAG_LOAD             = %00000100    ; doing a LOAD, do not show line numbers when inserting
                        	   205: EFLAG_SAVE             = %00001000    ; doing a SAVE, do not show line numbers
                        	   206: EFLAG_FIND             = %00010000    ; doing a FIND
                        	   207: EFLAG_REPLACE          = %00100000    ; doing a REPLACE
                        	   208: EFLAG_SUPPRESS_NEWLINE = %01000000    ; don't show newlines
                        	   209: EFLAG_NO_LINE_NUMBERS  = %10000000    ; don't show line numbers
                        	   210: 
00:00BD 00              	   211: find_flags     reserve 1      ; find/replace flags, see below
                        	   212: 
                        	   213: FFLAG_IGNORE_CASE = %00000001
                        	   214: FFLAG_GLOBAL      = %00000010
                        	   215: FFLAG_QUIET       = %00000100
                        	   216: 
                        	   217: ;
                        	   218: ;  system flags
                        	   219: ;
                        	   220: 
00:00BE 00              	   221: system_flags    reserve 1    ; general flags
                        	   222: 
                        	   223: FLAG_COMPILING      = %00000001
                        	   224: FLAG_ASSEMBLING     = %00000010
                        	   225: FLAG_LIST_SOURCE    = %00000100
                        	   226: FLAG_VALID_COMPILE  = %00001000
                        	   227: FLAG_VALID_ASSEMBLE = %00010000
                        	   228: FLAG_RUNNING        = %00100000
                        	   229: FLAG_ONLY_ALPHA     = %01000000   ; for editor, so you can L5 to do LIST 5
                        	   230: FLAG_BRK_REACHED    = %10000000   ; Breakpoint encountered during run
                        	   231: 

Source: "gpascal.asm"
                        	   125: 
                        	   126: ;
                        	   127: ;  A general work-buffer is allocated from $200 to $2FF for use during keyboard input, and also
                        	   128: ;  for converting strings during tokenisation (eg. two quotes in a row to one quote, and handling
                        	   129: ;  string escape sequences). It is also used during assembly as a 256-byte operator stack.
                        	   130: ;
                        	   131:   .org $200
                        	   132: INBUF_SIZE = 256          ; we use this for string storage during tokenisation
01:0200 00              	   133: INBUF  reserve INBUF_SIZE ; and also for preprocessing string literals (eg. backslash expansion)
01:0201 *
                        	   134: TEXT_START = *            ; where source goes in memory (currently $300)
                        	   135:   .dend
                        	   136: 
                        	   137: 
                        	   138: 
                        	   139: ;------------------------------------------
                        	   140: ;  Macros
                        	   141: ;------------------------------------------
                        	   142: 
                        	   143:  .macro tknjmpItem ; tknjmp entry: token, handler
                        	   144:    dfb   \1
                        	   145:    word  \2
                        	   146:  .endmacro
                        	   147: 
                        	   148:  .macro makeHandler ; table of words and handlers: word, handler
                        	   149:    asciiz   \1
                        	   150:    word  \2
                        	   151:  .endmacro
                        	   152: 
                        	   153: ;
                        	   154: ; makePasLibraryFunction NAME (SYMNAM), TYPE (SYMTYP), ARG_COUNT (SYMARG), EXECUTION_ADDRESS (SYMDSP)
                        	   155: ;
                        	   156: ;   TYPE = SYMBOL_LIBRARY_PROCEDURE or SYMBOL_LIBRARY_FUNCTION
                        	   157:    .macro makePasLibraryFunction
                        	   158:      asciiz   \1
                        	   159:      dfb      \2
                        	   160:      dfb      \3
                        	   161:      word     \4
                        	   162:    .endmacro
                        	   163: 
                        	   164: ;
                        	   165: ; makeAsmLibraryFunction NAME (SYMNAM), EXECUTION_ADDRESS (SYMDSP)
                        	   166: ;
                        	   167:    .macro makeAsmLibraryFunction
                        	   168:      asciiz   \1
                        	   169:      word     \2
                        	   170:    .endmacro
                        	   171: 
                        	   172:   ORG  START_OF_ROM   ; normally $8000 in the case of Ben Eater's board
                        	   173: 
00:8000 4C49DC          	   174:   JMP  START   ; where RESET takes us - a cold start
00:8003 4C65DC          	   175:   JMP  RESTART ; where NMI takes us - a warm start
                        	   176: 
                        	   177: ;***********************************************
                        	   178: ; INCLUDES
                        	   179: ;***********************************************
                        	   180: 
                        	   181:   .include "memory.inc"

Source: "memory.inc"
                        	     1: ;---------------------------
                        	     2: ; standard library stuff
                        	     3: ;---------------------------
                        	     4: 
                        	     5: ;
                        	     6: ;  character type masks
                        	     7: ;
                        	     8: m_upper   = %00000001    ; $01
                        	     9: m_lower   = %00000010    ; $02
                        	    10: m_alpha   = %00000100    ; $04
                        	    11: m_digit   = %00001000    ; $08
                        	    12: m_xdigit  = %00010000    ; $10
                        	    13: m_space   = %00100000    ; $20
                        	    14: m_cntrl   = %01000000    ; $40
                        	    15: m_alnum   = %10000000    ; $80
                        	    16: 
                        	    17: ;
                        	    18: ;  for fast checks which corrupt registers
                        	    19: ;
                        	    20: ;    ldx THE_CHARACTER_TO_BE_TESTED
                        	    21: ;    lda character_types_table,X
                        	    22: ;    bne IS_IN_THAT_CLASS
                        	    23: ;
                        	    24: 
                        	    25: character_types_table = *
00:8006 40              	    26:   dfb $40,$40,$40,$40,$40,$40,$40,$40    ; 0x00
00:8007 40
00:8008 40
00:8009 40
00:800A 40
00:800B 40
00:800C 40
00:800D 40
00:800E 40              	    27:   dfb $40,$60,$60,$60,$60,$60,$40,$40    ; 0x08
00:800F 60
00:8010 60
00:8011 60
00:8012 60
00:8013 60
00:8014 40
00:8015 40
00:8016 40              	    28:   dfb $40,$40,$40,$40,$40,$40,$40,$40    ; 0x10
00:8017 40
00:8018 40
00:8019 40
00:801A 40
00:801B 40
00:801C 40
00:801D 40
00:801E 40              	    29:   dfb $40,$40,$40,$40,$40,$40,$40,$40    ; 0x18
00:801F 40
00:8020 40
00:8021 40
00:8022 40
00:8023 40
00:8024 40
00:8025 40
00:8026 20              	    30:   dfb $20,$00,$00,$00,$00,$00,$00,$00    ; 0x20   !"#$%&'
00:8027 00
00:8028 00
00:8029 00
00:802A 00
00:802B 00
00:802C 00
00:802D 00
00:802E 00              	    31:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x28  ()*+,-./
00:802F 00
00:8030 00
00:8031 00
00:8032 00
00:8033 00
00:8034 00
00:8035 00
00:8036 98              	    32:   dfb $98,$98,$98,$98,$98,$98,$98,$98    ; 0x30  01234567
00:8037 98
00:8038 98
00:8039 98
00:803A 98
00:803B 98
00:803C 98
00:803D 98
00:803E 98              	    33:   dfb $98,$98,$00,$00,$00,$00,$00,$00    ; 0x38  89:;<=>?
00:803F 98
00:8040 00
00:8041 00
00:8042 00
00:8043 00
00:8044 00
00:8045 00
00:8046 00              	    34:   dfb $00,$95,$95,$95,$95,$95,$95,$85    ; 0x40  @ABCDEFG
00:8047 95
00:8048 95
00:8049 95
00:804A 95
00:804B 95
00:804C 95
00:804D 85
00:804E 85              	    35:   dfb $85,$85,$85,$85,$85,$85,$85,$85    ; 0x48  HIJKLMNO
00:804F 85
00:8050 85
00:8051 85
00:8052 85
00:8053 85
00:8054 85
00:8055 85
00:8056 85              	    36:   dfb $85,$85,$85,$85,$85,$85,$85,$85    ; 0x50  PQRSTUVW
00:8057 85
00:8058 85
00:8059 85
00:805A 85
00:805B 85
00:805C 85
00:805D 85
00:805E 85              	    37:   dfb $85,$85,$85,$00,$00,$00,$00,$00    ; 0x58  XYZ[\]^_
00:805F 85
00:8060 85
00:8061 00
00:8062 00
00:8063 00
00:8064 00
00:8065 00
00:8066 00              	    38:   dfb $00,$96,$96,$96,$96,$96,$96,$86    ; 0x60  `abcdefg
00:8067 96
00:8068 96
00:8069 96
00:806A 96
00:806B 96
00:806C 96
00:806D 86
00:806E 86              	    39:   dfb $86,$86,$86,$86,$86,$86,$86,$86    ; 0x68  hijklmno
00:806F 86
00:8070 86
00:8071 86
00:8072 86
00:8073 86
00:8074 86
00:8075 86
00:8076 86              	    40:   dfb $86,$86,$86,$86,$86,$86,$86,$86    ; 0x70  pqrstuvw
00:8077 86
00:8078 86
00:8079 86
00:807A 86
00:807B 86
00:807C 86
00:807D 86
00:807E 86              	    41:   dfb $86,$86,$86,$00,$00,$00,$00,$40    ; 0x78  xyz{|}~
00:807F 86
00:8080 86
00:8081 00
00:8082 00
00:8083 00
00:8084 00
00:8085 40
00:8086 00              	    42:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x80
00:8087 00
00:8088 00
00:8089 00
00:808A 00
00:808B 00
00:808C 00
00:808D 00
00:808E 00              	    43:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x88
00:808F 00
00:8090 00
00:8091 00
00:8092 00
00:8093 00
00:8094 00
00:8095 00
00:8096 00              	    44:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x90
00:8097 00
00:8098 00
00:8099 00
00:809A 00
00:809B 00
00:809C 00
00:809D 00
00:809E 00              	    45:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x98
00:809F 00
00:80A0 00
00:80A1 00
00:80A2 00
00:80A3 00
00:80A4 00
00:80A5 00
00:80A6 00              	    46:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xA0
00:80A7 00
00:80A8 00
00:80A9 00
00:80AA 00
00:80AB 00
00:80AC 00
00:80AD 00
00:80AE 00              	    47:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xA8
00:80AF 00
00:80B0 00
00:80B1 00
00:80B2 00
00:80B3 00
00:80B4 00
00:80B5 00
00:80B6 00              	    48:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xB0
00:80B7 00
00:80B8 00
00:80B9 00
00:80BA 00
00:80BB 00
00:80BC 00
00:80BD 00
00:80BE 00              	    49:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xB8
00:80BF 00
00:80C0 00
00:80C1 00
00:80C2 00
00:80C3 00
00:80C4 00
00:80C5 00
00:80C6 00              	    50:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xC0
00:80C7 00
00:80C8 00
00:80C9 00
00:80CA 00
00:80CB 00
00:80CC 00
00:80CD 00
00:80CE 00              	    51:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xC8
00:80CF 00
00:80D0 00
00:80D1 00
00:80D2 00
00:80D3 00
00:80D4 00
00:80D5 00
00:80D6 00              	    52:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xD0
00:80D7 00
00:80D8 00
00:80D9 00
00:80DA 00
00:80DB 00
00:80DC 00
00:80DD 00
00:80DE 00              	    53:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xD8
00:80DF 00
00:80E0 00
00:80E1 00
00:80E2 00
00:80E3 00
00:80E4 00
00:80E5 00
00:80E6 00              	    54:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xE0
00:80E7 00
00:80E8 00
00:80E9 00
00:80EA 00
00:80EB 00
00:80EC 00
00:80ED 00
00:80EE 00              	    55:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xE8
00:80EF 00
00:80F0 00
00:80F1 00
00:80F2 00
00:80F3 00
00:80F4 00
00:80F5 00
00:80F6 00              	    56:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xF0
00:80F7 00
00:80F8 00
00:80F9 00
00:80FA 00
00:80FB 00
00:80FC 00
00:80FD 00
00:80FE 00              	    57:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xF8
00:80FF 00
00:8100 00
00:8101 00
00:8102 00
00:8103 00
00:8104 00
00:8105 00
                        	    58: 
                        	    59: ;
                        	    60: ;  character type tests: test character in A, Carry set if true, carry clear if false
                        	    61: ;    -no registers changed
                        	    62: ;
                        	    63: is_xxx_fail:
00:8106 FA              	    64:   plx
00:8107 68              	    65:   pla
00:8108 18              	    66:   clc
00:8109 60              	    67:   rts
                        	    68: 
                        	    69: is_xxx_pass:
00:810A FA              	    70:   plx
00:810B 68              	    71:   pla
00:810C 38              	    72:   sec
00:810D 60              	    73:   rts
                        	    74: 
                        	    75:   .macro isXXX
                        	    76: \1 = *
                        	    77:   pha
                        	    78:   phx
                        	    79:   tax
                        	    80:   lda character_types_table,x
                        	    81:   and #\2
                        	    82:   beq is_xxx_fail
                        	    83:   bra is_xxx_pass
                        	    84:   .endmacro
                        	    85: 
                        	    86: ;
                        	    87: ;  generate the various character type tests - done by fast table lookup
                        	    88: ;
                        	    89:   isXXX isupper,  m_upper
                        	     1M isupper = *
00:810E 48              	     2M   pha
00:810F DA              	     3M   phx
00:8110 AA              	     4M   tax
00:8111 BD0680          	     5M   lda character_types_table,x
00:8114 2901            	     6M   and #m_upper
00:8116 F0EE            	     7M   beq is_xxx_fail
00:8118 80F0            	     8M   bra is_xxx_pass
                        	    90:   isXXX islower,  m_lower
                        	     1M islower = *
00:811A 48              	     2M   pha
00:811B DA              	     3M   phx
00:811C AA              	     4M   tax
00:811D BD0680          	     5M   lda character_types_table,x
00:8120 2902            	     6M   and #m_lower
00:8122 F0E2            	     7M   beq is_xxx_fail
00:8124 80E4            	     8M   bra is_xxx_pass
                        	    91:   isXXX isalpha,  m_alpha
                        	     1M isalpha = *
00:8126 48              	     2M   pha
00:8127 DA              	     3M   phx
00:8128 AA              	     4M   tax
00:8129 BD0680          	     5M   lda character_types_table,x
00:812C 2904            	     6M   and #m_alpha
00:812E F0D6            	     7M   beq is_xxx_fail
00:8130 80D8            	     8M   bra is_xxx_pass
                        	    92:   isXXX isdigit,  m_digit
                        	     1M isdigit = *
00:8132 48              	     2M   pha
00:8133 DA              	     3M   phx
00:8134 AA              	     4M   tax
00:8135 BD0680          	     5M   lda character_types_table,x
00:8138 2908            	     6M   and #m_digit
00:813A F0CA            	     7M   beq is_xxx_fail
00:813C 80CC            	     8M   bra is_xxx_pass
                        	    93:   isXXX isxdigit, m_xdigit
                        	     1M isxdigit = *
00:813E 48              	     2M   pha
00:813F DA              	     3M   phx
00:8140 AA              	     4M   tax
00:8141 BD0680          	     5M   lda character_types_table,x
00:8144 2910            	     6M   and #m_xdigit
00:8146 F0BE            	     7M   beq is_xxx_fail
00:8148 80C0            	     8M   bra is_xxx_pass
                        	    94:   isXXX isspace,  m_space
                        	     1M isspace = *
00:814A 48              	     2M   pha
00:814B DA              	     3M   phx
00:814C AA              	     4M   tax
00:814D BD0680          	     5M   lda character_types_table,x
00:8150 2920            	     6M   and #m_space
00:8152 F0B2            	     7M   beq is_xxx_fail
00:8154 80B4            	     8M   bra is_xxx_pass
                        	    95:   isXXX iscntrl,  m_cntrl
                        	     1M iscntrl = *
00:8156 48              	     2M   pha
00:8157 DA              	     3M   phx
00:8158 AA              	     4M   tax
00:8159 BD0680          	     5M   lda character_types_table,x
00:815C 2940            	     6M   and #m_cntrl
00:815E F0A6            	     7M   beq is_xxx_fail
00:8160 80A8            	     8M   bra is_xxx_pass
                        	    96:   isXXX isalnum,  m_alnum
                        	     1M isalnum = *
00:8162 48              	     2M   pha
00:8163 DA              	     3M   phx
00:8164 AA              	     4M   tax
00:8165 BD0680          	     5M   lda character_types_table,x
00:8168 2980            	     6M   and #m_alnum
00:816A F09A            	     7M   beq is_xxx_fail
00:816C 809C            	     8M   bra is_xxx_pass
                        	    97: 
                        	    98: ;
                        	    99: ;  ran out of bits so implemented this one manually
                        	   100: ;
                        	   101: isbinary   =  *
00:816E C930            	   102:          cmp  #'0'
00:8170 F004            	   103:          beq  isbin
00:8172 C931            	   104:          cmp  #'1'
00:8174 D002            	   105:          bne  notbin
                        	   106: isbin:
00:8176 38              	   107:          sec
00:8177 60              	   108:          rts
                        	   109: notbin:
00:8178 18              	   110:          clc
00:8179 60              	   111:          rts
                        	   112: 
                        	   113: ;
                        	   114: ; Move memory down  (mem_move_dest is < mem_move_src)
                        	   115: ;
                        	   116: ;  Copies first byte first, working upwards
                        	   117: ;
                        	   118: ; mem_move_src = source start address
                        	   119: ; mem_move_dest = destination start address
                        	   120: ; mem_move_len = number of bytes mem_move_dest move
                        	   121: ;
                        	   122: movedown:
00:817A A5AA            	   123:   lda mem_move_len
00:817C 05AB            	   124:   ora mem_move_len+1
00:817E F01C            	   125:   beq movedown_done
00:8180 A000            	   126:   ldy #0
00:8182 8498            	   127:   sty  token_work      ; counter
00:8184 8499            	   128:   sty  token_work+1
                        	   129: ;
                        	   130: ;  copy one byte, increment counter
                        	   131: ;
                        	   132: movedown_loop:
00:8186 B1A6            	   133:   lda (mem_move_src),Y
00:8188 91A8            	   134:   sta (mem_move_dest),Y
00:818A E698            	   135:   inc token_work
00:818C D002            	   136:   bne movedown2
00:818E E699            	   137:   inc token_work+1
                        	   138: ;
                        	   139: ;  see if length reached
                        	   140: ;
                        	   141: movedown2:
                        	   142: 
00:8190 A598            	   143:   lda  token_work
00:8192 C5AA            	   144:   cmp  mem_move_len
00:8194 D007            	   145:   bne  movedown1
00:8196 A599            	   146:   lda  token_work+1
00:8198 C5AB            	   147:   cmp  mem_move_len+1
00:819A D001            	   148:   bne  movedown1
                        	   149: movedown_done:
00:819C 60              	   150:   rts
                        	   151: 
                        	   152: ;
                        	   153: ; increment Y, and increment high-order address bytes if necessary
                        	   154: ;
                        	   155: movedown1:
00:819D C8              	   156:   iny
00:819E D0E6            	   157:   bne  movedown_loop
00:81A0 E6A7            	   158:   inc  mem_move_src+1
00:81A2 E6A9            	   159:   inc  mem_move_dest+1
00:81A4 80E0            	   160:   bra  movedown_loop
                        	   161: 
                        	   162: ; Move memory up (mem_move_dest is > mem_move_src)
                        	   163: ;
                        	   164: ;   Copies last byte first, moving downwards
                        	   165: ;
                        	   166: ; mem_move_src = source start address
                        	   167: ; mem_move_dest = destination start address
                        	   168: ; mem_move_len = number of bytes mem_move_dest move
                        	   169: ;
                        	   170: moveup:
00:81A6 A5AA            	   171:   lda mem_move_len
00:81A8 05AB            	   172:   ora mem_move_len+1
00:81AA F038            	   173:   beq moveup_done
00:81AC A000            	   174:   ldy #0
00:81AE 8498            	   175:   sty  token_work      ; counter
00:81B0 8499            	   176:   sty  token_work+1
                        	   177:   ;
                        	   178:   ;  calculate final address of source
                        	   179:   ;
00:81B2 18              	   180:   clc
00:81B3 A5A6            	   181:   lda mem_move_src
00:81B5 65AA            	   182:   adc mem_move_len
00:81B7 85A6            	   183:   sta mem_move_src
00:81B9 A5A7            	   184:   lda mem_move_src+1
00:81BB 65AB            	   185:   adc mem_move_len+1
00:81BD 85A7            	   186:   sta mem_move_src+1
                        	   187:   ;
                        	   188:   ;  calculate final address of destination
                        	   189:   ;
00:81BF 18              	   190:   clc
00:81C0 A5A8            	   191:   lda mem_move_dest
00:81C2 65AA            	   192:   adc mem_move_len
00:81C4 85A8            	   193:   sta mem_move_dest
00:81C6 A5A9            	   194:   lda mem_move_dest+1
00:81C8 65AB            	   195:   adc mem_move_len+1
00:81CA 85A9            	   196:   sta mem_move_dest+1
00:81CC 8017            	   197:   bra moveup_next   ; have to decrement first
                        	   198: ;
                        	   199: ; move one byte, count moves
                        	   200: ;
                        	   201: moveup_loop:
00:81CE B1A6            	   202:   lda (mem_move_src),Y
00:81D0 91A8            	   203:   sta (mem_move_dest),Y
00:81D2 E698            	   204:   inc token_work
00:81D4 D002            	   205:   bne moveup3
00:81D6 E699            	   206:   inc token_work+1
                        	   207: moveup3:
                        	   208: ;
                        	   209: ;  see if length reached
                        	   210: ;
00:81D8 A598            	   211:   lda token_work
00:81DA C5AA            	   212:   cmp mem_move_len
00:81DC D007            	   213:   bne moveup_next
00:81DE A599            	   214:   lda token_work+1
00:81E0 C5AB            	   215:   cmp mem_move_len+1
00:81E2 D001            	   216:   bne moveup_next
                        	   217: moveup_done:
00:81E4 60              	   218:   rts
                        	   219: ;
                        	   220: ;  decrement Y, and decrement high-order address bytes if necessary
                        	   221: ;
                        	   222: moveup_next   =  *
00:81E5 88              	   223:   dey
00:81E6 C0FF            	   224:   cpy #$FF
00:81E8 D0E4            	   225:   bne moveup_loop
00:81EA C6A7            	   226:   dec mem_move_src+1
00:81EC C6A9            	   227:   dec mem_move_dest+1
00:81EE 80DE            	   228:   bra moveup_loop
                        	   229: 
                        	   230: ;
                        	   231: ;
                        	   232: ; String compare - case significant (max 128 byte strings)
                        	   233: ;
                        	   234: ; SRCE = source start address
                        	   235: ; DEST = destination start address
                        	   236: ; Y    = length of both strings (range 1 to 128)
                        	   237: ;
                        	   238: ;  returns Z set if strings are equal
                        	   239: ;
                        	   240: 
                        	   241: str_compare:
00:81F0 88              	   242:   dey             ; make zero-relative
00:81F1 300B            	   243:   bmi str_compare_done
00:81F3 B100            	   244:   lda (SRCE),y
00:81F5 8585            	   245:   sta str_work
00:81F7 B103            	   246:   lda (DEST),y
00:81F9 C585            	   247:   cmp str_work
00:81FB F0F3            	   248:   beq str_compare
00:81FD 60              	   249:   rts   ; no match, zero flag not set
                        	   250: str_compare_done:
00:81FE A900            	   251:   lda #0    ; set Z flag
00:8200 60              	   252:   rts
                        	   253: 
                        	   254: ;
                        	   255: ; String compare - case NOT significant (max 128 byte strings)
                        	   256: ;
                        	   257: ; SRCE = source start address
                        	   258: ; DEST = destination start address
                        	   259: ; Y    = length of both strings (range 1 to 128)
                        	   260: ;
                        	   261: ;  returns Z set if strings are equal
                        	   262: ;
                        	   263: 
                        	   264: str_ic_compare:
00:8201 88              	   265:   dey
00:8202 301F            	   266:   bmi str_ic_compare_done
00:8204 B100            	   267:   lda (SRCE),y
00:8206 C97B            	   268:   cmp #'z'+1
00:8208 B006            	   269:   bcs str_ic_compare_fixed_srce  ; BGE
00:820A C961            	   270:   cmp #'a'
00:820C 9002            	   271:   bcc str_ic_compare_fixed_srce  ; BLT
00:820E E920            	   272:   sbc #$20    ; make upper-case
                        	   273: str_ic_compare_fixed_srce:
00:8210 8585            	   274:   sta str_work
00:8212 B103            	   275:   lda (DEST),y
00:8214 C97B            	   276:   cmp #'z'+1
00:8216 B006            	   277:   bcs str_ic_compare_fixed_dest  ; BGE
00:8218 C961            	   278:   cmp #'a'
00:821A 9002            	   279:   bcc str_ic_compare_fixed_dest  ; BLT
00:821C E920            	   280:   sbc #$20    ; make upper-case
                        	   281: str_ic_compare_fixed_dest:
00:821E C585            	   282:   cmp str_work
00:8220 F0DF            	   283:   beq str_ic_compare
00:8222 60              	   284:   rts       ; no match, zero flag not set
                        	   285: str_ic_compare_done:
00:8223 A900            	   286:   lda #0    ; set Z flag
00:8225 60              	   287:   rts
                        	   288: 
                        	   289: 

Source: "gpascal.asm"
                        	   182:   .include "editor.inc"

Source: "editor.inc"
                        	     1: ;-------------------------------------------------
                        	     2: ;
                        	     3: ;  Shell, and text editor
                        	     4: ;
                        	     5: ;-------------------------------------------------
                        	     6: 
                        	     7: 
                        	     8: ;-------------------------------------------------
                        	     9: ;  print null-terminated message, message in A (lo) and X (hi)
                        	    10: ;  returns the length of the message in Y
                        	    11: ;-------------------------------------------------
                        	    12: print:
00:8226 A8              	    13:   tay   ; save A
00:8227 A503            	    14:   lda REG2 ; save REG2
00:8229 48              	    15:   pha
00:822A A504            	    16:   lda REG2+1  ; save REG2+1
00:822C 48              	    17:   pha
00:822D 98              	    18:   tya   ; get original A back
00:822E 8503            	    19:   sta REG2
00:8230 8604            	    20:   stx REG2+1
00:8232 A000            	    21:   ldy #0
                        	    22: print_loop:
00:8234 B103            	    23:   lda (REG2),y
00:8236 F006            	    24:   beq print_done
00:8238 20B395          	    25:   jsr COUT
00:823B C8              	    26:   iny
00:823C D0F6            	    27:   bne print_loop  ; give up if we overflow
                        	    28: print_done:
                        	    29: ;  stz serial_in_byte_received   ; TODO: Not sure about this
                        	    30: ;
                        	    31: ;  get REG2 back
                        	    32: ;
00:823E 68              	    33:   pla
00:823F 8504            	    34:   sta REG2+1
00:8241 68              	    35:   pla
00:8242 8503            	    36:   sta REG2
00:8244 60              	    37:   rts
                        	    38: 
00:8245 3A20            	    39: prompt       asciiz ": "
00:8247 00
00:8248 556E6B6E6F776E20	    40: bad_command  asciiz "Unknown command, type H for help.\n"
00:8250 636F6D6D616E642C
00:8258 2074797065204820
00:8260 666F722068656C70
00:8268 2E0A
00:826A 00
                        	    41: 
                        	    42: ;-------------------------------------------------
                        	    43: ; Start here after Reset or NMI - show introduction
                        	    44: ;-------------------------------------------------
                        	    45: 
                        	    46: main_start:
00:826B A9D6            	    47:   lda #<introduction
00:826D A2DB            	    48:   ldx #>introduction
00:826F 202682          	    49:   jsr print
                        	    50: 
                        	    51: main_prompt:
00:8272 A2FF            	    52:   ldx  #NEW_STK
00:8274 9A              	    53:   txs
00:8275 D8              	    54:   cld
                        	    55: 
00:8276 A945            	    56:   lda #<prompt
00:8278 A282            	    57:   ldx #>prompt
00:827A 202682          	    58:   jsr print
                        	    59: 
00:827D 208B95          	    60:   jsr  GET_LINE
                        	    61: 
00:8280 A900            	    62:   lda #<INBUF
00:8282 858E            	    63:   sta token_start
00:8284 A902            	    64:   lda #>INBUF
00:8286 858F            	    65:   sta token_start+1
                        	    66: 
00:8288 A901            	    67:   lda #1
00:828A 853F            	    68:   sta RUNNING
                        	    69: 
                        	    70: ;-------------------------------------------------
                        	    71: ; EDITOR (SHELL) MAIN LOOP
                        	    72: ;-------------------------------------------------
                        	    73: 
                        	    74: main_loop:
00:828C 64BC            	    75:   stz editor_flags  ; no flags yet
00:828E 64BD            	    76:   stz find_flags    ;  ditto
00:8290 A901            	    77:   lda #FLAG_COMPILING
00:8292 0902            	    78:   ora #FLAG_ASSEMBLING
00:8294 14BE            	    79:   trb system_flags  ; not compiling or assembling now
                        	    80: 
00:8296 A940            	    81:   lda #FLAG_ONLY_ALPHA
00:8298 04BE            	    82:   tsb system_flags  ; we only want alpha commands, thus we can enter L1 and be the same as List 1
                        	    83: 
00:829A 209FCB          	    84:   jsr get_token
00:829D F0D3            	    85:   beq main_prompt   ; no input
                        	    86: 
                        	    87: ;
                        	    88: ;  Shortcut: If the input is "R" or "r" followed directly by a newline, assume they want to Run
                        	    89: ;
00:829F C949            	    90:   cmp #TOKEN_IDENTIFIER
00:82A1 D015            	    91:   bne main_loop_not_run
                        	    92: 
00:82A3 A000            	    93:   ldy #0
00:82A5 B190            	    94:   lda (token_address),y
00:82A7 20C191          	    95:   jsr MAKE_UPPER
00:82AA C952            	    96:   cmp #'R'
00:82AC D00A            	    97:   bne main_loop_not_run
00:82AE C8              	    98:   iny
00:82AF B190            	    99:   lda (token_address),y
00:82B1 C90A            	   100:   cmp #NL
00:82B3 D003            	   101:   bne main_loop_not_run
00:82B5 4C428E          	   102:   jmp editor_run
                        	   103: 
                        	   104: ;
                        	   105: ;  Not a RUN shortcut, look up the command in our table
                        	   106: ;
                        	   107: main_loop_not_run:
                        	   108: ;
                        	   109: ;  set up our input line as where to find tokens
                        	   110: ;
00:82B8 A590            	   111:   lda token_address
00:82BA 8500            	   112:   sta SRCE
00:82BC A591            	   113:   lda token_address+1
00:82BE 8501            	   114:   sta SRCE+1
                        	   115: 
                        	   116: ;
                        	   117: ;  get editor handlers
                        	   118: ;
00:82C0 A9D6            	   119:   lda #<editor_handlers
00:82C2 8503            	   120:   sta DEST
00:82C4 A982            	   121:   lda #>editor_handlers
00:82C6 8504            	   122:   sta DEST+1
                        	   123: 
                        	   124: ;
                        	   125: ;  get the token length and look up the handler
                        	   126: ;
00:82C8 A592            	   127:   lda token_length
00:82CA 204A91          	   128:   jsr partial_handler_Lookup
                        	   129: 
                        	   130: ;
                        	   131: ;  if we returned, unknown command
                        	   132: ;
00:82CD A948            	   133:   lda #<bad_command
00:82CF A282            	   134:   ldx #>bad_command
00:82D1 202682          	   135:   jsr print
00:82D4 809C            	   136:   bra  main_prompt
                        	   137: 
                        	   138: 
                        	   139: editor_handlers:
                        	   140:   makeHandler "LIST",    editor_list
00:82D6 4C495354        	     1M    asciiz   "LIST"
00:82DA 00
00:82DB 6387            	     2M    word  editor_list
                        	   141:   makeHandler "INSERT",  editor_insert
00:82DD 494E53455254    	     1M    asciiz   "INSERT"
00:82E3 00
00:82E4 168A            	     2M    word  editor_insert
                        	   142:   makeHandler "LOAD",    editor_load
00:82E6 4C4F4144        	     1M    asciiz   "LOAD"
00:82EA 00
00:82EB 128A            	     2M    word  editor_load
                        	   143:   makeHandler "DELETE",  editor_delete
00:82ED 44454C455445    	     1M    asciiz   "DELETE"
00:82F3 00
00:82F4 A48B            	     2M    word  editor_delete
                        	   144:   makeHandler "HELP",    editor_help
00:82F6 48454C50        	     1M    asciiz   "HELP"
00:82FA 00
00:82FB 1B85            	     2M    word  editor_help
                        	   145: 
                        	   146:   .if USE_PASCAL
                        	   147:   makeHandler "COMPILE" ,editor_compile
00:82FD 434F4D50494C45  	     1M    asciiz   "COMPILE" 
00:8304 00
00:8305 2E8E            	     2M    word  editor_compile
                        	   148:   makeHandler "SYNTAX",  editor_syntax
00:8307 53594E544158    	     1M    asciiz   "SYNTAX"
00:830D 00
00:830E 388E            	     2M    word  editor_syntax
                        	   149:   .endif ; USE_PASCAL
                        	   150: 
                        	   151:   makeHandler "SAVE",    editor_save
00:8310 53415645        	     1M    asciiz   "SAVE"
00:8314 00
00:8315 5D87            	     2M    word  editor_save
                        	   152: ;  makeHandler "TEST",    editor_test
                        	   153:   makeHandler "MEMORY",  editor_memory
00:8317 4D454D4F5259    	     1M    asciiz   "MEMORY"
00:831D 00
00:831E EA8C            	     2M    word  editor_memory
                        	   154:  ; makeHandler "SYMTBL", editor_symbol_table_list
                        	   155:   makeHandler "INFO",    editor_info
00:8320 494E464F        	     1M    asciiz   "INFO"
00:8324 00
00:8325 1C8E            	     2M    word  editor_info
                        	   156:   makeHandler "TRACE",   editor_trace
00:8327 5452414345      	     1M    asciiz   "TRACE"
00:832C 00
00:832D 0A8E            	     2M    word  editor_trace
                        	   157:   makeHandler "DEBUG",   editor_debug
00:832F 4445425547      	     1M    asciiz   "DEBUG"
00:8334 00
00:8335 EE8D            	     2M    word  editor_debug
                        	   158: 
                        	   159:   .if USE_ASSEMBLER
                        	   160:   makeHandler "ASSEMBLE",editor_assemble
00:8337 415353454D424C45	     1M    asciiz   "ASSEMBLE"
00:833F 00
00:8340 F18E            	     2M    word  editor_assemble
                        	   161:   .endif  ; USE_ASSEMBLER
                        	   162: 
                        	   163:   makeHandler "FIND",    editor_find
00:8342 46494E44        	     1M    asciiz   "FIND"
00:8346 00
00:8347 5787            	     2M    word  editor_find
                        	   164:   makeHandler "REPLACE", editor_replace
00:8349 5245504C414345  	     1M    asciiz   "REPLACE"
00:8350 00
00:8351 4F87            	     2M    word  editor_replace
                        	   165:   makeHandler "RUN",     editor_run
00:8353 52554E          	     1M    asciiz   "RUN"
00:8356 00
00:8357 428E            	     2M    word  editor_run
                        	   166:   makeHandler "RESUME",  editor_resume
00:8359 524553554D45    	     1M    asciiz   "RESUME"
00:835F 00
00:8360 168F            	     2M    word  editor_resume
                        	   167:   makeHandler "RECOVER", editor_recover
00:8362 5245434F564552  	     1M    asciiz   "RECOVER"
00:8369 00
00:836A 9F8D            	     2M    word  editor_recover
                        	   168:   makeHandler "POKE",    editor_poke
00:836C 504F4B45        	     1M    asciiz   "POKE"
00:8370 00
00:8371 6C8F            	     2M    word  editor_poke
                        	   169:   makeHandler "JSR",     editor_jsr
00:8373 4A5352          	     1M    asciiz   "JSR"
00:8376 00
00:8377 2990            	     2M    word  editor_jsr
                        	   170:   makeHandler "JMP",     editor_jmp
00:8379 4A4D50          	     1M    asciiz   "JMP"
00:837C 00
00:837D 5A90            	     2M    word  editor_jmp
                        	   171:   .if USE_ASSEMBLER
                        	   172:   makeHandler "LIBRARY", editor_library
00:837F 4C494252415259  	     1M    asciiz   "LIBRARY"
00:8386 00
00:8387 7B90            	     2M    word  editor_library
                        	   173:   .endif  ; USE_ASSEMBLER
00:8389 00              	   174:   dfb 0
                        	   175: 
                        	   176: editor_help_info:
00:838A 417661696C61626C	   177:   asc "Available actions:\n\n"
00:8392 6520616374696F6E
00:839A 733A0A0A
00:839E 4C6973742F534176	   178:   asc "List/SAve   line_number_range\n"
00:83A6 652020206C696E65
00:83AE 5F6E756D6265725F
00:83B6 72616E67650A
00:83BC 44656C6574652020	   179:   asc "Delete      line_number_range\n"
00:83C4 202020206C696E65
00:83CC 5F6E756D6265725F
00:83D4 72616E67650A
00:83DA 496E736572742F4C	   180:   asc "Insert/LOad after_line\n"
00:83E2 4F61642061667465
00:83EA 725F6C696E650A
00:83F1 46696E6420202020	   181:   asc "Find        line_number_range /target/flags\n"
00:83F9 202020206C696E65
00:8401 5F6E756D6265725F
00:8409 72616E6765202F74
00:8411 61726765742F666C
00:8419 6167730A
00:841D 5265706C61636520	   182:   asc "Replace     line_number_range /target/replacement/flags\n"
00:8425 202020206C696E65
00:842D 5F6E756D6265725F
00:8435 72616E6765202F74
00:843D 61726765742F7265
00:8445 706C6163656D656E
00:844D 742F666C6167730A
00:8455 5245436F7665720A	   183:   asc "RECover\n"
00:845D 0A              	   184:   asc "\n"
00:845E 48656C700A      	   185:   asc "Help\n"
00:8463 494E666F0A      	   186:   asc "INfo\n"
00:8468 4D656D6F72792020	   187:   asc "Memory      first_address last_address\n"
00:8470 2020202066697273
00:8478 745F616464726573
00:8480 73206C6173745F61
00:8488 6464726573730A
                        	   188: 
                        	   189:   .if USE_ASSEMBLER
00:848F 417373656D626C65	   190:   asc "Assemble\n"
00:8497 0A
00:8498 4C4942726172790A	   191:   asc "LIBrary\n"
                        	   192:   .endif  ; USE_ASSEMBLER
                        	   193: 
                        	   194:   .if USE_PASCAL
00:84A0 436F6D70696C652F	   195:   asc "Compile/Syntax\n"
00:84A8 53796E7461780A
                        	   196:   .endif  ; USE_PASCAL
                        	   197: 
00:84AF 52556E0A        	   198:   asc "RUn\n"
00:84B3 44454275672F5472	   199:   asc "DEBug/Trace\n"
00:84BB 6163650A
00:84BF 524553756D650A  	   200:   asc "RESume\n"
00:84C6 506F6B652F4A7372	   201:   asc "Poke/Jsr/JMp\n"
00:84CE 2F4A4D700A
00:84D3 28416374696F6E73	   202:   asc "(Actions may be abbreviated)\n"
00:84DB 206D617920626520
00:84E3 6162627265766961
00:84EB 746564290A
00:84F0 28466C6167733A20	   203:   asc "(Flags: 'I'gnore case, 'G'lobal, 'Q'uiet)\n"
00:84F8 274927676E6F7265
00:8500 20636173652C2027
00:8508 47276C6F62616C2C
00:8510 2027512775696574
00:8518 290A
00:851A 00              	   204:   dfb 0
                        	   205: 
                        	   206: 
                        	   207: ;--------------------------------------------
                        	   208: ;  HELP
                        	   209: ;--------------------------------------------
                        	   210: editor_help:
00:851B 204086          	   211:   jsr editor_check_no_more
00:851E A98A            	   212:   lda #<editor_help_info
00:8520 8500            	   213:   sta REG
00:8522 A983            	   214:   lda #>editor_help_info
00:8524 8501            	   215:   sta REG+1
                        	   216: editor_help_loop:
00:8526 A000            	   217:   ldy #0
00:8528 B100            	   218:   lda (REG),Y
00:852A F00B            	   219:   beq editor_help_done
00:852C 20B395          	   220:   jsr COUT
00:852F E600            	   221:   inc REG
00:8531 D0F3            	   222:   bne editor_help_loop
00:8533 E601            	   223:   inc REG+1
00:8535 80EF            	   224:   bra editor_help_loop
                        	   225: editor_help_done:
00:8537 4C7282          	   226:   jmp main_prompt
                        	   227: 
                        	   228: ;
                        	   229: ;  Sets default range from 1 to 65535
                        	   230: ;
                        	   231: editor_default_range:
                        	   232: ;
                        	   233: ;  default to all lines
                        	   234: ;
00:853A A901            	   235:   lda #1
00:853C 859E            	   236:   sta from_line
00:853E 649F            	   237:   stz from_line+1
00:8540 A9FF            	   238:   lda #$FF
00:8542 85A0            	   239:   sta to_line
00:8544 85A1            	   240:   sta to_line+1
00:8546 60              	   241:   rts
                        	   242: 
                        	   243: number_expected_message:
00:8547 4E756D6265722065	   244:   asciiz "Number expected\n"
00:854F 787065637465640A
00:8557 00
                        	   245: 
                        	   246: editor_bad_number:
00:8558 A947            	   247:   lda #<number_expected_message
00:855A A285            	   248:   ldx #>number_expected_message
00:855C 202682          	   249:   jsr print
00:855F 4C7282          	   250:   jmp main_prompt
                        	   251: 
                        	   252: ;
                        	   253: ;  get a number for the editor: accepts eof or newline as "no number"
                        	   254: ;  otherwise must be a number and in the range 0x0001 to 0xFFFF
                        	   255: ;  returns carry set if a number (in token_value) and carry clear if
                        	   256: ;  no number. Raises an error otherwise
                        	   257: ;
                        	   258: editor_get_number:
00:8562 204DD1          	   259:   jsr pas_get_token   ; use this to find END as a token
00:8565 F065            	   260:   beq editor_get_number_none ; no token? return with carry set
00:8567 C90A            	   261:   cmp #NL
00:8569 F061            	   262:   beq editor_get_number_none ; newline counts as no token
00:856B C94E            	   263:   cmp #TOKEN_NUMBER
00:856D F04B            	   264:   beq editor_get_number_ok
00:856F C989            	   265:   cmp #TOKEN_END
00:8571 F05B            	   266:   beq editor_get_number_end
00:8573 C949            	   267:   cmp #TOKEN_IDENTIFIER
00:8575 D02D            	   268:   bne editor_get_number_not_identifier
00:8577 A592            	   269:   lda token_length
00:8579 C903            	   270:   cmp #3
00:857B D0DB            	   271:   bne editor_bad_number
00:857D A000            	   272:   ldy #0
00:857F B190            	   273:   lda (token_address),y
00:8581 20C191          	   274:   jsr MAKE_UPPER
00:8584 C941            	   275:   cmp #'A'
00:8586 D0D0            	   276:   bne editor_bad_number
00:8588 C8              	   277:   iny
00:8589 B190            	   278:   lda (token_address),y
00:858B 20C191          	   279:   jsr MAKE_UPPER
00:858E C94C            	   280:   cmp #'L'
00:8590 D0C6            	   281:   bne editor_bad_number
00:8592 C8              	   282:   iny
00:8593 B190            	   283:   lda (token_address),y
00:8595 20C191          	   284:   jsr MAKE_UPPER
00:8598 C94C            	   285:   cmp #'L'
00:859A D0BC            	   286:   bne editor_bad_number
00:859C 203A85          	   287:   jsr editor_default_range
00:859F 204086          	   288:   jsr editor_check_no_more ; can't have ALL - something
00:85A2 8028            	   289:   bra editor_get_number_none
                        	   290: ;
                        	   291: ;  find / replace can go straight to the delimiter
                        	   292: ;
                        	   293: editor_get_number_not_identifier:
00:85A4 A910            	   294:   lda #EFLAG_FIND
00:85A6 0920            	   295:   ora #EFLAG_REPLACE
00:85A8 25BC            	   296:   and editor_flags
00:85AA F0AC            	   297:   beq editor_bad_number
00:85AC A592            	   298:   lda token_length
00:85AE C901            	   299:   cmp #1
00:85B0 D0A6            	   300:   bne editor_bad_number
                        	   301: ;
                        	   302: ;  go back one character, we need get_token to find this again later
                        	   303: ;
00:85B2 C68E            	   304:   dec token_start
00:85B4 D016            	   305:   bne editor_get_number_none
00:85B6 C68F            	   306:   dec token_start+1
00:85B8 8012            	   307:   bra editor_get_number_none
                        	   308: 
                        	   309: editor_get_number_ok:
00:85BA A596            	   310:   lda token_value+2         ; must be a number
00:85BC D03C            	   311:   bne editor_line_number_too_big
00:85BE A5BC            	   312:   lda editor_flags
00:85C0 2902            	   313:   and #EFLAG_ALLOW_ZERO_FROM
00:85C2 D006            	   314:   bne editor_get_number_done
00:85C4 A594            	   315:   lda token_value
00:85C6 0595            	   316:   ora token_value+1
00:85C8 F030            	   317:   beq editor_line_number_too_big  ; too small actually
                        	   318: editor_get_number_done:
00:85CA 38              	   319:   sec
00:85CB 60              	   320:   rts
                        	   321: 
                        	   322: editor_get_number_none:
00:85CC 18              	   323:   clc
00:85CD 60              	   324:   rts
                        	   325: 
                        	   326: ;
                        	   327: ;  the word "END" will count as the highest possible line number
                        	   328: ;
                        	   329: editor_get_number_end:
00:85CE A9FF            	   330:   lda #$FF
00:85D0 8594            	   331:   sta token_value
00:85D2 8595            	   332:   sta token_value+1
00:85D4 6496            	   333:   stz token_value+2
00:85D6 204086          	   334:   jsr editor_check_no_more ; can't have END - something
00:85D9 38              	   335:   sec
00:85DA 60              	   336:   rts
                        	   337: 
                        	   338: number_too_large_message:
00:85DB 4E756D6265722074	   339:   asciiz "Number too large or too small\n"
00:85E3 6F6F206C61726765
00:85EB 206F7220746F6F20
00:85F3 736D616C6C0A
00:85F9 00
                        	   340: 
                        	   341: editor_line_number_too_big:
00:85FA A9DB            	   342:   lda #<number_too_large_message
00:85FC A285            	   343:   ldx #>number_too_large_message
00:85FE 202682          	   344:   jsr print
00:8601 4C7282          	   345:   jmp main_prompt
                        	   346: 
                        	   347: number_bad_range_message:
00:8604 52616E676520696E	   348:   asciiz "Range invalid\n"
00:860C 76616C69640A
00:8612 00
                        	   349: 
                        	   350: editor_bad_range:
00:8613 A904            	   351:   lda #<number_bad_range_message
00:8615 A286            	   352:   ldx #>number_bad_range_message
00:8617 202682          	   353:   jsr print
00:861A 4C7282          	   354:   jmp main_prompt
                        	   355: 
                        	   356: too_much_on_line:
00:861D 556E657870656374	   357:   asciiz "Unexpected trailing input on line\n"
00:8625 656420747261696C
00:862D 696E6720696E7075
00:8635 74206F6E206C696E
00:863D 650A
00:863F 00
                        	   358: 
                        	   359: ;
                        	   360: ;  check that all is left on the line is spaces
                        	   361: ;
                        	   362: editor_check_no_more:
00:8640 A000            	   363:   ldy #0
                        	   364: editor_check_no_more_loop:
00:8642 B18E            	   365:   lda (token_start),y
00:8644 F016            	   366:   beq editor_check_no_more_ok   ; end of file
00:8646 C90A            	   367:   cmp #NL
00:8648 F012            	   368:   beq editor_check_no_more_ok   ; newline is OK
00:864A 204A81          	   369:   jsr isspace
00:864D 9003            	   370:   bcc editor_check_no_more_failed ; not spaces is bad
00:864F C8              	   371:   iny
00:8650 D0F0            	   372:   bne editor_check_no_more_loop   ; skip spaces
                        	   373: 
                        	   374: editor_check_no_more_failed:
00:8652 A91D            	   375:   lda #<too_much_on_line
00:8654 A286            	   376:   ldx #>too_much_on_line
00:8656 202682          	   377:   jsr print
00:8659 4C7282          	   378:   jmp main_prompt
                        	   379: editor_check_no_more_ok:
00:865C 60              	   380:   rts
                        	   381: 
                        	   382: 
                        	   383: 
                        	   384: ;--------------------------------------------
                        	   385: ;  get a range of line numbers (eg. L 1,10; D 4; M 6,10 )
                        	   386: ;--------------------------------------------
                        	   387: 
                        	   388: editor_get_range:
                        	   389: 
                        	   390: 
                        	   391: ;
                        	   392: ;  get the first line number (if any)
                        	   393: ;
00:865D 206285          	   394:   jsr editor_get_number
00:8660 9049            	   395:   bcc editor_get_range_done ; no token? take defaults
                        	   396: ;
                        	   397: ;  store the from line
                        	   398: ;
00:8662 A594            	   399:   lda token_value
00:8664 859E            	   400:   sta from_line
00:8666 85A0            	   401:   sta to_line
00:8668 A595            	   402:   lda token_value+1
00:866A 859F            	   403:   sta from_line+1
00:866C 85A1            	   404:   sta to_line+1
                        	   405: 
                        	   406: ;
                        	   407: ;  comma or hyphen?
                        	   408: ;
00:866E 209FCB          	   409:   jsr get_token
00:8671 F038            	   410:   beq editor_get_range_done   ; line done, just the single line wanted
                        	   411: 
00:8673 C92D            	   412:   cmp #'-'
00:8675 F01C            	   413:   beq editor_get_range_hyphen
00:8677 C94E            	   414:   cmp #TOKEN_NUMBER
00:8679 F01D            	   415:   beq editor_get_range_number
00:867B C989            	   416:   cmp #TOKEN_END
00:867D F019            	   417:   beq editor_get_range_number
00:867F C92C            	   418:   cmp #','
00:8681 F010            	   419:   beq editor_get_range_hyphen
                        	   420: ;
                        	   421: ;  find and replace may have another character after the first line number
                        	   422: ;  which isn't a second line number or a hyphen/comma
                        	   423: ;
00:8683 A910            	   424:   lda #EFLAG_FIND
00:8685 0920            	   425:   ora #EFLAG_REPLACE
00:8687 25BC            	   426:   and editor_flags
00:8689 F088            	   427:   beq editor_bad_range
                        	   428: 
                        	   429: ;
                        	   430: ;  go back one character, we need get_token to find this again later
                        	   431: ;
00:868B C68E            	   432:   dec token_start
00:868D D01C            	   433:   bne editor_get_range_done
00:868F C68F            	   434:   dec token_start+1
00:8691 8018            	   435:   bra editor_get_range_done
                        	   436: 
                        	   437: editor_get_range_hyphen:
                        	   438: ;
                        	   439: ;  get the second line number
                        	   440: ;
00:8693 206285          	   441:   jsr editor_get_number
00:8696 9014            	   442:   bcc editor_bad_rangeJ
                        	   443: 
                        	   444: editor_get_range_number:
00:8698 A594            	   445:   lda token_value
00:869A 85A0            	   446:   sta to_line
00:869C A595            	   447:   lda token_value+1
00:869E 85A1            	   448:   sta to_line+1
                        	   449: 
                        	   450: ;
                        	   451: ;  make sure range ascends
                        	   452: ;
00:86A0 38              	   453:   sec
00:86A1 A5A0            	   454:   lda to_line
00:86A3 E59E            	   455:   sbc from_line
00:86A5 A5A1            	   456:   lda to_line+1
00:86A7 E59F            	   457:   sbc from_line+1
00:86A9 9001            	   458:   bcc editor_bad_rangeJ    ; <sigh> because of the way SBC works
                        	   459: 
                        	   460: editor_get_range_done:
00:86AB 60              	   461:   rts
                        	   462: 
00:86AC 4C1386          	   463: editor_bad_rangeJ jmp editor_bad_range
                        	   464: 
                        	   465: ;
                        	   466: 
00:86AF 20666F756E640A  	   467: found_message asciiz  ' found\n'
00:86B6 00
                        	   468: 
                        	   469: 
                        	   470: 
00:86B7 46726F6D3A20    	   471: from_msg: asciiz "From: "
00:86BD 00
00:86BE 20746F20        	   472: to_msg:   asciiz " to "
00:86C2 00
                        	   473: 
00:86C3 4261642064656C69	   474: bad_delimiter_message asciiz "Bad delimiter\n"
00:86CB 6D697465720A
00:86D1 00
                        	   475: 
                        	   476: editor_bad_delimiter:
00:86D2 A9C3            	   477:   lda #<bad_delimiter_message
00:86D4 A286            	   478:   ldx #>bad_delimiter_message
                        	   479: editor_find_problem:
00:86D6 202682          	   480:   jsr print
00:86D9 4C7282          	   481:   jmp main_prompt
                        	   482: 
00:86DC 46696E642F726570	   483: find_string_too_long_message asciiz "Find/replace string too long\n"
00:86E4 6C61636520737472
00:86EC 696E6720746F6F20
00:86F4 6C6F6E670A
00:86F9 00
                        	   484: 
                        	   485: find_string_too_long:
00:86FA A9DC            	   486:   lda #<find_string_too_long_message
00:86FC A286            	   487:   ldx #>find_string_too_long_message
00:86FE 80D6            	   488:   bra editor_find_problem
                        	   489: 
                        	   490: editor_get_delimiter:
00:8700 209FCB          	   491:   jsr get_token
00:8703 C949            	   492:   cmp #TOKEN_IDENTIFIER
00:8705 F0CB            	   493:   beq editor_bad_delimiter
00:8707 C94E            	   494:   cmp #TOKEN_NUMBER
00:8709 F0C7            	   495:   beq editor_bad_delimiter
00:870B C922            	   496:   cmp #TOKEN_STRING
00:870D F0C3            	   497:   beq editor_bad_delimiter
00:870F A692            	   498:   ldx token_length
00:8711 E001            	   499:   cpx #1
00:8713 D0BD            	   500:   bne editor_bad_delimiter
00:8715 85B4            	   501:   sta find_delimiter
00:8717 60              	   502:   rts
                        	   503: 
00:8718 4E6F20636C6F7369	   504: editor_no_closing_delimiter_message asciiz "No closing delimiter\n"
00:8720 6E672064656C696D
00:8728 697465720A
00:872D 00
                        	   505: 
                        	   506: editor_no_closing_delimiter:
00:872E A918            	   507:   lda #<editor_no_closing_delimiter_message
00:8730 A287            	   508:   ldx #>editor_no_closing_delimiter_message
00:8732 80A2            	   509:   bra editor_find_problem
                        	   510: 
00:8734 5461726765742073	   511: no_find_message asciiz "Target string empty\n"
00:873C 7472696E6720656D
00:8744 7074790A
00:8748 00
                        	   512: 
                        	   513: editor_no_find_string:
00:8749 A934            	   514:   lda #<no_find_message
00:874B A287            	   515:   ldx #>no_find_message
00:874D 8087            	   516:   bra editor_find_problem
                        	   517: 
                        	   518: ;--------------------------------------------
                        	   519: ;  LIST / SAVE / FIND / REPLACE / MODIFY
                        	   520: ;
                        	   521: ;  This rather complex routine lists the source between from_line and to_line
                        	   522: ;   In the process it can show or omit line numbers  (omit for SAVE)
                        	   523: ;  Also, it can find the target text, and optionally replace it with the replacement text
                        	   524: ;  In find/replace mode the lines are not shown unless they had something found (unless
                        	   525: ;   the Quiet flag is set)
                        	   526: ;
                        	   527: ;--------------------------------------------
                        	   528: 
                        	   529: editor_replace:
00:874F A920            	   530:   lda #EFLAG_REPLACE
00:8751 0910            	   531:   ora #EFLAG_FIND   ; makes things simpler later on
00:8753 85BC            	   532:   sta editor_flags
00:8755 800C            	   533:   bra editor_list
                        	   534: 
                        	   535: editor_find:
                        	   536: 
00:8757 A910            	   537:   lda #EFLAG_FIND
00:8759 85BC            	   538:   sta editor_flags
00:875B 8006            	   539:   bra editor_list
                        	   540: 
                        	   541: editor_save
                        	   542: 
00:875D A980            	   543:   lda #EFLAG_NO_LINE_NUMBERS
00:875F 0908            	   544:   ora #EFLAG_SAVE
00:8761 85BC            	   545:   sta editor_flags
                        	   546: 
                        	   547: ;
                        	   548: ;  main entry point - get the from and to lines
                        	   549: ;
                        	   550: editor_list:
00:8763 203A85          	   551:   jsr editor_default_range
00:8766 205D86          	   552:   jsr editor_get_range
                        	   553: 
                        	   554: ;
                        	   555: ;  turn the from_line into an address and put it into PCODE
                        	   556: ;
00:8769 A59E            	   557:   lda from_line
00:876B 85AC            	   558:   sta this_line
00:876D A59F            	   559:   lda from_line+1
00:876F 85AD            	   560:   sta this_line+1
00:8771 20858C          	   561:   jsr find_line    ; find the "from" line address (this_line in fact)
00:8774 A5AE            	   562:   lda this_line_addr
00:8776 8523            	   563:   sta PCODE
00:8778 A5AF            	   564:   lda this_line_addr+1
00:877A 8524            	   565:   sta PCODE+1
00:877C 64B9            	   566:   stz find_count
00:877E 64BA            	   567:   stz find_count+1
                        	   568: 
                        	   569: ;
                        	   570: ;  for FIND and REPLACE, get the first delimiter
                        	   571: ;
00:8780 A5BC            	   572:   lda editor_flags
00:8782 2910            	   573:   and #EFLAG_FIND
00:8784 D003            	   574:   bne editor_list_doing_find
00:8786 4C5388          	   575:   jmp editor_list_not_find
                        	   576: 
                        	   577: editor_list_doing_find:
00:8789 200087          	   578:   jsr editor_get_delimiter
                        	   579: ;
                        	   580: ;  token_next should now be the start of what we are searching for
                        	   581: ;
00:878C 38              	   582:   sec
00:878D A58E            	   583:   lda token_start
00:878F E900            	   584:   sbc #<INBUF
00:8791 85B0            	   585:   sta find_from
00:8793 B00B            	   586:   bcs editor_list_got_from_point ; delimiter should be a single byte
                        	   587: 
                        	   588: editor_find_bug:
00:8795 A214            	   589:   ldx #20  ; ERROR: bug
00:8797 4CE099          	   590:   jmp ERROR
                        	   591: 
00:879A 4CFA86          	   592: find_string_too_longJ         jmp find_string_too_long
00:879D 4C2E87          	   593: editor_no_closing_delimiterJ  jmp editor_no_closing_delimiter
                        	   594: 
                        	   595: editor_list_got_from_point:
                        	   596: 
                        	   597: ;
                        	   598: ;  Now find closing delimiter by a simple scan as we will pass who-knows-what on the way
                        	   599: ;
00:87A0 A6B0            	   600:   ldx find_from
                        	   601: editor_find_second_delimiter_loop:
00:87A2 E8              	   602:   inx
00:87A3 BD0002          	   603:   lda INBUF,x
00:87A6 F0F5            	   604:   beq editor_no_closing_delimiterJ
00:87A8 C90A            	   605:   cmp #NL
00:87AA F0F1            	   606:   beq editor_no_closing_delimiterJ
00:87AC C5B4            	   607:   cmp find_delimiter
00:87AE D0F2            	   608:   bne editor_find_second_delimiter_loop
                        	   609: 
                        	   610: ;
                        	   611: ;  found the closing delimiter
                        	   612: ;
00:87B0 86B1            	   613:   stx find_to
00:87B2 E4B0            	   614:   cpx find_from
00:87B4 F093            	   615:   beq editor_no_find_string
                        	   616: ;
                        	   617: ;  maximum 127 byte find string
                        	   618: ;
00:87B6 38              	   619:   sec
00:87B7 A5B1            	   620:   lda find_to
00:87B9 E5B0            	   621:   sbc find_from
00:87BB 30DD            	   622:   bmi find_string_too_longJ
00:87BD 85B3            	   623:   sta find_len    ; save for later memory move calculations
                        	   624: 
00:87BF A920            	   625:   lda #EFLAG_REPLACE
00:87C1 25BC            	   626:   and editor_flags
00:87C3 F02A            	   627:   beq editor_find_get_flags
                        	   628: 
                        	   629: ;
                        	   630: ;  doing a replace - find second delimiter
                        	   631: ;
                        	   632: 
00:87C5 86B5            	   633:   stx rep_from
00:87C7 E6B5            	   634:   inc rep_from    ; get past the delimiter
                        	   635: 
                        	   636: editor_find_third_delimiter_loop:
00:87C9 E8              	   637:   inx
00:87CA BD0002          	   638:   lda INBUF,x
00:87CD F0CE            	   639:   beq editor_no_closing_delimiterJ
00:87CF C90A            	   640:   cmp #NL
00:87D1 F0CA            	   641:   beq editor_no_closing_delimiterJ
00:87D3 C5B4            	   642:   cmp find_delimiter
00:87D5 D0F2            	   643:   bne editor_find_third_delimiter_loop
                        	   644: 
                        	   645: ;
                        	   646: ;  found the replacement closing delimiter
00:87D7 86B6            	   647:   stx rep_to
                        	   648: 
                        	   649: ;
                        	   650: ;  maximum 127 byte replacement string
                        	   651: ;
00:87D9 38              	   652:   sec
00:87DA A5B6            	   653:   lda rep_to
00:87DC E5B5            	   654:   sbc rep_from
00:87DE 30BA            	   655:   bmi find_string_too_longJ
                        	   656: 
                        	   657: ;
                        	   658: ;  now find the signed difference between the find and replace strings
                        	   659: ;  namely: (rep_to - rep_from) - find_len
                        	   660: ;
00:87E0 64B8            	   661:   stz rep_diff+1
00:87E2 38              	   662:   sec
00:87E3 A5B6            	   663:   lda rep_to
00:87E5 E5B5            	   664:   sbc rep_from
00:87E7 E5B3            	   665:   sbc find_len
00:87E9 85B7            	   666:   sta rep_diff
00:87EB 1002            	   667:   bpl editor_find_get_flags
00:87ED C6B8            	   668:   dec rep_diff+1   ; make that $ff
                        	   669: 
                        	   670: ;
                        	   671: ; get any find/replace flags
                        	   672: ;
                        	   673: editor_find_get_flags:
00:87EF 64BD            	   674:   stz find_flags
                        	   675: 
                        	   676: editor_flags_loop:
00:87F1 E8              	   677:   inx
00:87F2 BD0002          	   678:   lda INBUF,X
00:87F5 C90A            	   679:   cmp #NL
00:87F7 F042            	   680:   beq editor_list_fix_target_string
00:87F9 204A81          	   681:   jsr isspace
00:87FC B0F3            	   682:   bcs editor_flags_loop
00:87FE 20C191          	   683:   jsr MAKE_UPPER
00:8801 C951            	   684:   cmp #'Q'
00:8803 D00A            	   685:   bne editor_flags1
00:8805 A904            	   686:   lda #FFLAG_QUIET
00:8807 04BD            	   687:   tsb find_flags
00:8809 A980            	   688:   lda #EFLAG_NO_LINE_NUMBERS
00:880B 04BC            	   689:   tsb editor_flags
00:880D 80E2            	   690:   bra editor_flags_loop
                        	   691: editor_flags1:
00:880F C947            	   692:   cmp #'G'
00:8811 D006            	   693:   bne editor_flags2
00:8813 A902            	   694:   lda #FFLAG_GLOBAL
00:8815 04BD            	   695:   tsb find_flags
00:8817 80D8            	   696:   bra editor_flags_loop
                        	   697: editor_flags2:
00:8819 C949            	   698:   cmp #'I'
00:881B D006            	   699:   bne editor_flags3
00:881D A901            	   700:   lda #FFLAG_IGNORE_CASE
00:881F 04BD            	   701:   tsb find_flags
00:8821 80CE            	   702:   bra editor_flags_loop
                        	   703: editor_flags3:
00:8823 A92D            	   704:   lda #<bad_flag_message
00:8825 A288            	   705:   ldx #>bad_flag_message
00:8827 202682          	   706:   jsr print
00:882A 4C7282          	   707:   jmp main_prompt
                        	   708: 
00:882D 556E6B6E6F776E20	   709: bad_flag_message: asciiz "Unknown flag\n"
00:8835 666C61670A
00:883A 00
                        	   710: 
                        	   711: editor_list_fix_target_string:
                        	   712: 
00:883B A901            	   713:   lda #FFLAG_IGNORE_CASE
00:883D 25BD            	   714:   and find_flags
00:883F F015            	   715:   beq editor_list_get_on_with_it
                        	   716: 
                        	   717: ;
                        	   718: ;  for case insensitive compare force target to be upper case
                        	   719: ;
00:8841 A6B0            	   720:   ldx find_from
                        	   721: editor_list_fixup_loop:
00:8843 E4B1            	   722:   cpx find_to
00:8845 F00F            	   723:   beq editor_list_get_on_with_it
00:8847 BD0002          	   724:   lda INBUF,X
00:884A 20C191          	   725:   jsr MAKE_UPPER
00:884D 9D0002          	   726:   sta INBUF,X
00:8850 E8              	   727:   inx
00:8851 80F0            	   728:   bra editor_list_fixup_loop
                        	   729: 
                        	   730: 
                        	   731: editor_list_not_find:
                        	   732: ;
                        	   733: ;  we should have no more tokens now
                        	   734: ;
00:8853 204086          	   735:   jsr editor_check_no_more
                        	   736: 
                        	   737: editor_list_get_on_with_it:
                        	   738: ;
                        	   739: ;  make sure current_line is correct
                        	   740: ;
00:8856 A59E            	   741:   lda from_line
00:8858 85A2            	   742:   sta current_line
00:885A A59F            	   743:   lda from_line+1
00:885C 85A3            	   744:   sta current_line+1
                        	   745: 
                        	   746: ;
                        	   747: ;  exit immediately if no source from here on
                        	   748: ;
00:885E A000            	   749:   ldy #0
00:8860 B123            	   750:   lda (PCODE),Y
00:8862 D003            	   751:   bne editor_list_have_source
00:8864 4C8289          	   752:   jmp editor_list_done
                        	   753: 
                        	   754: editor_list_have_source:
00:8867 A901            	   755:   lda #EFLAG_SHOW_LINE
00:8869 04BC            	   756:   tsb editor_flags
00:886B 8006            	   757:   bra editor_list_loop
                        	   758: 
00:886D 4C8289          	   759: editor_list_doneJ jmp editor_list_done
00:8870 4C4489          	   760: editor_list_no_line_numberJ jmp editor_list_no_line_number
                        	   761: 
                        	   762: editor_list_loop:
00:8873 A58B            	   763:   lda serial_in_byte_received
00:8875 C903            	   764:   cmp  #KEY_ABORT
00:8877 F021            	   765:   beq  editor_list_aborted
00:8879 64BB            	   766:   stz  found_this_line
00:887B A000            	   767:   ldy #0
00:887D B123            	   768:   lda (PCODE),Y
00:887F F0EC            	   769:   beq editor_list_doneJ
00:8881 A5BC            	   770:   lda editor_flags
00:8883 2901            	   771:   and #EFLAG_SHOW_LINE
00:8885 F0E9            	   772:   beq  editor_list_no_line_numberJ
00:8887 A5BC            	   773:   lda editor_flags
00:8889 2908            	   774:   and #EFLAG_SAVE
00:888B D0E3            	   775:   bne editor_list_no_line_numberJ
                        	   776: ;
                        	   777: ;  At this exact point we know we are at the start of a line
                        	   778: ;  and we aren't doing a Save. Now, if we are doing a Find then
                        	   779: ;  we need to know if this line (from here to the next newline)
                        	   780: ;  matches our find string, and if not, to skip it
                        	   781: 
00:888D A940            	   782:   lda #EFLAG_SUPPRESS_NEWLINE
00:888F 14BC            	   783:   trb editor_flags              ; we can show newlines now
                        	   784: 
00:8891 A5BC            	   785:   lda editor_flags
00:8893 2910            	   786:   and #EFLAG_FIND
00:8895 D010            	   787:   bne editor_find_or_replacing
                        	   788: 
00:8897 4C3789          	   789:   jmp  editor_list_not_finding
                        	   790: 
                        	   791: ;
                        	   792: ;  Here when Ctrl+C pressed
                        	   793: ;
                        	   794: editor_list_aborted:
00:889A A232            	   795:   ldx #50
00:889C A000            	   796:   ldy #0
00:889E 20D292          	   797:   jsr delay   ; 50 ms delay to allow serial to settle
00:88A1 202594          	   798:   jsr CROUT
00:88A4 4C8289          	   799:   jmp editor_list_done
                        	   800: 
                        	   801: editor_find_or_replacing:
                        	   802: 
                        	   803: ;
                        	   804: ;  here if finding or replacing
                        	   805: ;
                        	   806: 
00:88A7 A900            	   807:   lda #0
                        	   808: 
                        	   809: ;
                        	   810: ;  we come back here for multiple replacements with a new starting pos
                        	   811: ;
                        	   812: editor_replacement_loop:
00:88A9 85B2            	   813:   sta find_pos    ; searching line from beginning (or not, if doing a multiple replace)
                        	   814: 
                        	   815: editor_find_loop:
00:88AB A6B0            	   816:   ldx find_from   ; out target string position in INBUF
00:88AD A4B2            	   817:   ldy find_pos    ; where we are on the line
                        	   818: editor_find_inner_loop:
00:88AF E4B1            	   819:   cpx find_to     ; reached end of target, found the string!
00:88B1 F037            	   820:   beq editor_find_found_it
00:88B3 B123            	   821:   lda (PCODE),Y
00:88B5 C90A            	   822:   cmp #NL
00:88B7 F01B            	   823:   beq editor_find_no_match ; hit end of line without matching
                        	   824: 
                        	   825: ;
                        	   826: ;  force to upper-case if required
                        	   827: ;
00:88B9 48              	   828:   pha
00:88BA A901            	   829:   lda #FFLAG_IGNORE_CASE
00:88BC 25BD            	   830:   and find_flags
00:88BE F006            	   831:   beq editor_find_case_sensitive
00:88C0 68              	   832:   pla
00:88C1 20C191          	   833:   jsr MAKE_UPPER
00:88C4 8001            	   834:   bra editor_find_test_character
                        	   835: editor_find_case_sensitive:
00:88C6 68              	   836:   pla
                        	   837: editor_find_test_character:
00:88C7 DD0002          	   838:   cmp INBUF,X     ; does source byte match target byte?
00:88CA D004            	   839:   bne editor_find_skip_this
00:88CC C8              	   840:   iny
00:88CD E8              	   841:   inx
00:88CE 80DF            	   842:   bra editor_find_inner_loop
                        	   843: 
                        	   844: editor_find_skip_this:
00:88D0 E6B2            	   845:   inc find_pos
00:88D2 D0D7            	   846:   bne editor_find_loop  ; if it wraps, give up
                        	   847: 
                        	   848: ;
                        	   849: ;  we are at the newline without a match, increment PCODE to match
                        	   850: ;  where we are and go onto newline processing
                        	   851: ;
                        	   852: editor_find_no_match:
00:88D4 A5BB            	   853:    lda found_this_line
00:88D6 D05F            	   854:    bne editor_list_not_finding
00:88D8 18              	   855:    clc
00:88D9 98              	   856:    tya
00:88DA 6523            	   857:    adc PCODE
00:88DC 8523            	   858:    sta PCODE
00:88DE A900            	   859:    lda #0
00:88E0 6524            	   860:    adc PCODE+1
00:88E2 8524            	   861:    sta PCODE+1
00:88E4 A940            	   862:    lda #EFLAG_SUPPRESS_NEWLINE
00:88E6 04BC            	   863:    tsb editor_flags
00:88E8 8062            	   864:    bra editor_newline_processing
                        	   865: 
                        	   866: ;
                        	   867: ;  here when find succeeded
                        	   868: ;
                        	   869: editor_find_found_it:
00:88EA E6B9            	   870:   inc find_count
00:88EC D002            	   871:   bne editor_find_found_it1
00:88EE E6BA            	   872:   inc find_count+1
                        	   873: editor_find_found_it1:
00:88F0 A901            	   874:   lda #1
00:88F2 85BB            	   875:   sta found_this_line
00:88F4 A920            	   876:   lda #EFLAG_REPLACE
00:88F6 25BC            	   877:   and editor_flags
00:88F8 D00E            	   878:   bne editor_do_the_replace
                        	   879: 
00:88FA A902            	   880:   lda #FFLAG_GLOBAL
00:88FC 25BD            	   881:   and find_flags
00:88FE F037            	   882:   beq editor_list_not_finding   ; one replace is enough
                        	   883: 
                        	   884: ;
                        	   885: ;  add the find length to Y (moving past what we just found)
                        	   886: ;
                        	   887: ;
00:8900 18              	   888:   clc
00:8901 A5B2            	   889:   lda find_pos
00:8903 65B3            	   890:   adc find_len
00:8905 4CA988          	   891:   jmp editor_replacement_loop
                        	   892: 
                        	   893: ;
                        	   894: ;  here when replacing
                        	   895: ;
                        	   896: editor_do_the_replace:
00:8908 A908            	   897:   lda #FLAG_VALID_COMPILE   ; compile or assemble no longer valid
00:890A 0910            	   898:   ora #FLAG_VALID_ASSEMBLE
00:890C 14BE            	   899:   trb system_flags
                        	   900: 
00:890E A5B7            	   901:   lda rep_diff ; same length?
00:8910 F003            	   902:   beq editor_easy_replace
00:8912 4CA289          	   903:   jmp editor_do_replace
                        	   904: 
                        	   905: editor_easy_replace:
00:8915 A4B2            	   906:   ldy find_pos
00:8917 A6B5            	   907:   ldx rep_from
                        	   908: editor_easy_replace_loop:
00:8919 E4B6            	   909:   cpx rep_to
00:891B F009            	   910:   beq editor_easy_replace_done
00:891D BD0002          	   911:   lda INBUF,x
00:8920 9123            	   912:   sta (PCODE),y
00:8922 C8              	   913:   iny
00:8923 E8              	   914:   inx
00:8924 D0F3            	   915:   bne editor_easy_replace_loop  ; keep replacing
                        	   916: 
                        	   917: editor_easy_replace_done:
00:8926 A902            	   918:   lda #FFLAG_GLOBAL
00:8928 25BD            	   919:   and find_flags
00:892A F00B            	   920:   beq editor_list_not_finding   ; one replace is enough
                        	   921: 
                        	   922: ;
                        	   923: ;  add the replacement length to Y (moving past what we just replaced)
                        	   924: ;   the replacement length is rep_to - rep_from
                        	   925: ;
00:892C 18              	   926:   clc
00:892D A5B2            	   927:   lda find_pos
00:892F 65B6            	   928:   adc rep_to
00:8931 38              	   929:   sec
00:8932 E5B5            	   930:   sbc rep_from
00:8934 4CA988          	   931:   jmp editor_replacement_loop
                        	   932: 
                        	   933: ;
                        	   934: ;
                        	   935: ;  display the line number
                        	   936: ;
                        	   937: editor_list_not_finding:
00:8937 A901            	   938:   lda #EFLAG_SHOW_LINE
00:8939 14BC            	   939:   trb editor_flags      ; cancel flag until next newline
00:893B A980            	   940:   lda #EFLAG_NO_LINE_NUMBERS
00:893D 25BC            	   941:   and editor_flags
00:893F D003            	   942:   bne editor_list_no_line_number
00:8941 20478C          	   943:   jsr show_current_line_number
                        	   944: 
                        	   945: editor_list_no_line_number:
00:8944 A000            	   946:   ldy  #0
00:8946 B123            	   947:   lda  (PCODE),Y
00:8948 C90A            	   948:   cmp  #NL
00:894A D022            	   949:   bne  editor_list_not_newline
                        	   950: 
                        	   951: editor_newline_processing:
00:894C A901            	   952:   lda  #EFLAG_SHOW_LINE
00:894E 04BC            	   953:   tsb  editor_flags
00:8950 E6A2            	   954:   inc  current_line
00:8952 D002            	   955:   bne  editor_list_check_to_line
00:8954 E6A3            	   956:   inc  current_line+1
                        	   957: 
                        	   958: ;
                        	   959: ;  see if we hit the wanted "to" line
                        	   960: ;
                        	   961: editor_list_check_to_line:
00:8956 A5A3            	   962:   lda  current_line+1
00:8958 C5A1            	   963:   cmp  to_line+1
00:895A 900A            	   964:   bcc  editor_list_check_to_line_ok
00:895C D024            	   965:   bne  editor_list_done
00:895E A5A2            	   966:   lda  current_line
00:8960 C5A0            	   967:   cmp  to_line
00:8962 9002            	   968:   bcc  editor_list_check_to_line_ok
00:8964 D01C            	   969:   bne  editor_list_done
                        	   970: 
                        	   971: editor_list_check_to_line_ok:
                        	   972: 
00:8966 A940            	   973:   lda #EFLAG_SUPPRESS_NEWLINE
00:8968 25BC            	   974:   and editor_flags
00:896A D00D            	   975:   bne editor_list_skip_newline
00:896C A90A            	   976:   lda #NL   ; put the newline back
                        	   977: 
                        	   978: ;
                        	   979: ;  just echo the character, and increment the memory address
                        	   980: ;
                        	   981: editor_list_not_newline:
00:896E AA              	   982:   tax
00:896F A904            	   983:   lda #FFLAG_QUIET
00:8971 25BD            	   984:   and find_flags
00:8973 D004            	   985:   bne editor_list_skip_newline
00:8975 8A              	   986:   txa
00:8976 208294          	   987:   jsr PRCHAR
                        	   988: 
                        	   989: editor_list_skip_newline:
00:8979 E623            	   990:   inc PCODE
00:897B D002            	   991:   bne editor_list_loopJ
00:897D E624            	   992:   inc PCODE+1
                        	   993: 
                        	   994: editor_list_loopJ:
00:897F 4C7388          	   995:   jmp editor_list_loop
                        	   996: 
                        	   997: editor_list_done:
00:8982 202594          	   998:   jsr CROUT
                        	   999: 
00:8985 A5B9            	  1000:   lda find_count
00:8987 05BA            	  1001:   ora find_count+1
00:8989 F014            	  1002:   beq  editor_list_completely_done
00:898B A5B9            	  1003:   lda find_count
00:898D 8500            	  1004:   sta REG
00:898F A5BA            	  1005:   lda find_count+1
00:8991 8501            	  1006:   sta REG+1
00:8993 6402            	  1007:   stz REGB
00:8995 204F93          	  1008:   jsr display_in_decimal
00:8998 A9AF            	  1009:   lda #<found_message
00:899A A286            	  1010:   ldx #>found_message
00:899C 202682          	  1011:   jsr print
                        	  1012: 
                        	  1013: editor_list_completely_done:
00:899F 4C7282          	  1014:   jmp main_prompt
                        	  1015: 
                        	  1016: ;
                        	  1017: ;  This if for replacing when the lengths differ
                        	  1018: ;
                        	  1019: editor_do_replace:
                        	  1020: ;
                        	  1021: ; add our current find_pos to PCODE to get where we are in memory
                        	  1022: ;
00:89A2 18              	  1023:   clc
00:89A3 A523            	  1024:   lda  PCODE
00:89A5 48              	  1025:   pha   ; save where we currently are
00:89A6 65B2            	  1026:   adc  find_pos
00:89A8 85A6            	  1027:   sta  mem_move_src
00:89AA A524            	  1028:   lda  PCODE+1
00:89AC 48              	  1029:   pha
00:89AD 6900            	  1030:   adc  #0
00:89AF 85A7            	  1031:   sta  mem_move_src+1
                        	  1032: 
                        	  1033: ;
                        	  1034: ;  add the source string length as we don't need to copy that
                        	  1035: ;
00:89B1 18              	  1036:   clc
00:89B2 A5A6            	  1037:   lda mem_move_src
00:89B4 65B3            	  1038:   adc find_len
00:89B6 85A6            	  1039:   sta mem_move_src
00:89B8 A5A7            	  1040:   lda mem_move_src+1
00:89BA 6900            	  1041:   adc #0
00:89BC 85A7            	  1042:   sta mem_move_src+1
                        	  1043: 
                        	  1044: ;
                        	  1045: ;  the move destination is the source plus the replacement length
                        	  1046: ;   (ie. a gap of the difference in bytes)
                        	  1047: 
00:89BE 18              	  1048:   clc
00:89BF A5A6            	  1049:   lda mem_move_src
00:89C1 65B7            	  1050:   adc rep_diff
00:89C3 85A8            	  1051:   sta mem_move_dest
00:89C5 A5A7            	  1052:   lda mem_move_src+1
00:89C7 65B8            	  1053:   adc rep_diff+1
00:89C9 85A9            	  1054:   sta mem_move_dest+1
                        	  1055: 
                        	  1056: 
00:89CB 20B98C          	  1057:   jsr find_source_end   ; goes into PCODE
                        	  1058: ;
                        	  1059: ;  the length to move will be (the end of the source) - (the start of the move)
                        	  1060: ;
00:89CE 38              	  1061:   sec
00:89CF A523            	  1062:   lda PCODE
00:89D1 E5A6            	  1063:   sbc mem_move_src
00:89D3 85AA            	  1064:   sta mem_move_len
00:89D5 A524            	  1065:   lda PCODE+1
00:89D7 E5A7            	  1066:   sbc mem_move_src+1
00:89D9 85AB            	  1067:   sta mem_move_len+1
                        	  1068: 
00:89DB A5B8            	  1069:   lda rep_diff+1
00:89DD 3005            	  1070:   bmi editor_do_replace_smaller
00:89DF 20A681          	  1071:   jsr moveup      ; replacing with larger string
00:89E2 8003            	  1072:   bra editor_do_replace_copy_done
                        	  1073: 
                        	  1074: editor_do_replace_smaller:
00:89E4 207A81          	  1075:   jsr movedown    ; replacing with smaller string
                        	  1076: 
                        	  1077: editor_do_replace_copy_done:
                        	  1078: ;
                        	  1079: ;  get the current source address back
                        	  1080: ;
00:89E7 68              	  1081:   pla
00:89E8 8524            	  1082:   sta  PCODE+1
00:89EA 68              	  1083:   pla
00:89EB 8523            	  1084:   sta  PCODE
00:89ED 4C1589          	  1085:   jmp  editor_easy_replace    ; now move in new string
                        	  1086: 
                        	  1087: 
00:89F0 456E74657220736F	  1088: load_message asciiz "Enter source, terminate with Esc\n"
00:89F8 757263652C207465
00:8A00 726D696E61746520
00:8A08 7769746820457363
00:8A10 0A
00:8A11 00
                        	  1089: 
                        	  1090: ;--------------------------------------------
                        	  1091: ;  INSERT / LOAD
                        	  1092: ;--------------------------------------------
                        	  1093: editor_load:
                        	  1094: 
00:8A12 A904            	  1095:   lda #EFLAG_LOAD
00:8A14 85BC            	  1096:   sta editor_flags
                        	  1097: 
                        	  1098: editor_insert:
00:8A16 206285          	  1099:   jsr editor_get_number
00:8A19 9015            	  1100:   bcc editor_insert_at_start
                        	  1101: 
                        	  1102:   ;
                        	  1103:   ; I really want to insert AFTER this line so I'll add 1 to whatever line number they gave
                        	  1104:   ; To insert at the start use Insert without a line number
                        	  1105:   ;
00:8A1B 18              	  1106:   clc
00:8A1C A594            	  1107:   lda token_value
00:8A1E 6901            	  1108:   adc #1
00:8A20 85AC            	  1109:   sta this_line
00:8A22 A595            	  1110:   lda token_value+1
00:8A24 6900            	  1111:   adc #0
00:8A26 85AD            	  1112:   sta this_line+1
                        	  1113: 
00:8A28 204086          	  1114:   jsr editor_check_no_more
00:8A2B 20858C          	  1115:   jsr find_line    ; find the "from" line address
00:8A2E 800E            	  1116:   bra editor_insert_common
                        	  1117: 
                        	  1118: editor_insert_at_start:
00:8A30 A900            	  1119:   lda #<TEXT_START
00:8A32 85AE            	  1120:   sta this_line_addr
00:8A34 A903            	  1121:   lda #>TEXT_START
00:8A36 85AF            	  1122:   sta this_line_addr+1
00:8A38 A901            	  1123:   lda #1
00:8A3A 85A2            	  1124:   sta current_line    ; current line number (1)
00:8A3C 64A3            	  1125:   stz current_line+1
                        	  1126: 
                        	  1127: editor_insert_common:
00:8A3E 20B98C          	  1128:   jsr find_source_end
                        	  1129: 
                        	  1130: ;
                        	  1131: ;  move existing source to end of RAM
                        	  1132: ;
00:8A41 38              	  1133:   sec
00:8A42 A523            	  1134:   lda PCODE
00:8A44 E5AE            	  1135:   sbc this_line_addr
00:8A46 85AA            	  1136:   sta mem_move_len
00:8A48 A524            	  1137:   lda PCODE+1
00:8A4A E5AF            	  1138:   sbc this_line_addr+1
00:8A4C 85AB            	  1139:   sta mem_move_len+1
                        	  1140: 
                        	  1141: ;
                        	  1142: ;  find where to move to
                        	  1143: ;
00:8A4E 38              	  1144:   sec
00:8A4F A9FF            	  1145:   lda #<HIGHEST_RAM
00:8A51 E5AA            	  1146:   sbc mem_move_len
00:8A53 85A8            	  1147:   sta mem_move_dest
00:8A55 85A4            	  1148:   sta insert_limit
00:8A57 A93F            	  1149:   lda #>HIGHEST_RAM
00:8A59 E5AB            	  1150:   sbc mem_move_len+1
00:8A5B 85A9            	  1151:   sta mem_move_dest+1
00:8A5D 85A5            	  1152:   sta insert_limit+1
                        	  1153: 
                        	  1154: ;
                        	  1155: ;  the source of the move
                        	  1156: ;
00:8A5F A5AE            	  1157:   lda this_line_addr
00:8A61 85A6            	  1158:   sta mem_move_src
00:8A63 A5AF            	  1159:   lda this_line_addr+1
00:8A65 85A7            	  1160:   sta mem_move_src+1
                        	  1161: 
00:8A67 20A681          	  1162:   jsr moveup
                        	  1163: 
                        	  1164: ;
                        	  1165: ;  put input at from_line_addr
                        	  1166: ;
                        	  1167: 
00:8A6A A5AE            	  1168:   lda this_line_addr
00:8A6C 8523            	  1169:   sta PCODE
00:8A6E A5AF            	  1170:   lda this_line_addr+1
00:8A70 8524            	  1171:   sta PCODE+1
                        	  1172: 
00:8A72 A9F0            	  1173:   lda  #<load_message
00:8A74 A289            	  1174:   ldx  #>load_message
00:8A76 202682          	  1175:   jsr  print
                        	  1176: 
                        	  1177: ;
                        	  1178: ;  show the first line number
                        	  1179: ;
                        	  1180: 
00:8A79 A901            	  1181:   lda #EFLAG_SHOW_LINE
00:8A7B 04BC            	  1182:   tsb editor_flags
00:8A7D A000            	  1183:   ldy #0    ; offset from PCODE for inserting (should always be zero)
00:8A7F A200            	  1184:   ldx #0    ; last character we inserted
                        	  1185: 
                        	  1186: editor_insert_loop:
00:8A81 A904            	  1187:   lda #EFLAG_LOAD         ; no line numbers on load
00:8A83 25BC            	  1188:   and editor_flags
00:8A85 D00B            	  1189:   bne editor_insert_no_line_number
                        	  1190: 
00:8A87 A5BC            	  1191:   lda editor_flags
00:8A89 2901            	  1192:   and #EFLAG_SHOW_LINE
00:8A8B F005            	  1193:   beq  editor_insert_no_line_number
                        	  1194: ;
                        	  1195: ;  display the line number
                        	  1196: ;
                        	  1197: 
00:8A8D 64BC            	  1198:   stz editor_flags      ; cancel flag until next newline
00:8A8F 20478C          	  1199:   jsr show_current_line_number
                        	  1200: 
                        	  1201: editor_insert_no_line_number:
00:8A92 201FCB          	  1202:   jsr  CHRIN
00:8A95 C90D            	  1203:   cmp  #CR                          ; carriage-return?
00:8A97 F0F9            	  1204:   beq  editor_insert_no_line_number ; yes, ignore
00:8A99 C91B            	  1205:   cmp  #END_EDITOR_INPUT            ; Esc?
00:8A9B F04F            	  1206:   beq  editor_insert_done
00:8A9D C908            	  1207:   cmp  #BACKSPACE
00:8A9F F029            	  1208:   beq  editor_insert_backspace
00:8AA1 C90A            	  1209:   cmp  #NL
00:8AA3 D00C            	  1210:   bne  editor_insert_not_newline
00:8AA5 A901            	  1211:   lda  #EFLAG_SHOW_LINE
00:8AA7 04BC            	  1212:   tsb  editor_flags
00:8AA9 A90A            	  1213:   lda  #NL            ; get the newline back
00:8AAB E6A2            	  1214:   inc  current_line
00:8AAD D002            	  1215:   bne  editor_insert_not_newline
00:8AAF E6A3            	  1216:   inc  current_line+1
                        	  1217: editor_insert_not_newline:
00:8AB1 9123            	  1218:   sta  (PCODE),y
00:8AB3 AA              	  1219:   tax                ; for detecting final newline
00:8AB4 E623            	  1220:   inc  PCODE
00:8AB6 D002            	  1221:   bne  editor_insert_loop1
00:8AB8 E624            	  1222:   inc  PCODE+1
                        	  1223: 
                        	  1224: editor_insert_loop1:
00:8ABA A5A5            	  1225:   lda  insert_limit+1
00:8ABC C524            	  1226:   cmp  PCODE+1
00:8ABE B0C1            	  1227:   bcs  editor_insert_loop   ; carry is SET if we didn't borrow
00:8AC0 D056            	  1228:   bne  editor_too_full
00:8AC2 A5A4            	  1229:   lda  insert_limit
00:8AC4 C523            	  1230:   cmp  PCODE
00:8AC6 F050            	  1231:   beq  editor_too_full
00:8AC8 80B7            	  1232:   bra  editor_insert_loop
                        	  1233: 
                        	  1234: ;
                        	  1235: ;  backspace reduces our pointer by one, unless we are at the start
                        	  1236: ;
                        	  1237: editor_insert_backspace:
00:8ACA A523            	  1238:   lda PCODE
00:8ACC C5AE            	  1239:   cmp this_line_addr
00:8ACE D006            	  1240:   bne editor_insert_backspace_not_at_start
00:8AD0 A524            	  1241:   lda PCODE+1
00:8AD2 C5AF            	  1242:   cmp this_line_addr+1
00:8AD4 F0AB            	  1243:   beq editor_insert_loop    ; at start, ignore backspace
                        	  1244: 
                        	  1245: editor_insert_backspace_not_at_start:
00:8AD6 38              	  1246:   sec                       ; move source pointer back one
00:8AD7 A523            	  1247:   lda PCODE
00:8AD9 E901            	  1248:   sbc #1
00:8ADB 8523            	  1249:   sta PCODE
00:8ADD A524            	  1250:   lda PCODE+1
00:8ADF E900            	  1251:   sbc #0
00:8AE1 8524            	  1252:   sta PCODE+1
00:8AE3 B123            	  1253:   lda (PCODE),y
00:8AE5 AA              	  1254:   tax                      ; this is now the last character we inserted
                        	  1255: ;
                        	  1256: ;  however we don't want them backspacing over a previous line, so if we detect a newline
                        	  1257: ;  just go back up and put it back (and increment PCODE back to where it was)
                        	  1258: ;
00:8AE6 C90A            	  1259:   cmp #NL
00:8AE8 F0C7            	  1260:   beq editor_insert_not_newline
00:8AEA 8095            	  1261:   bra editor_insert_loop
                        	  1262: 
                        	  1263: editor_insert_done:
00:8AEC 8A              	  1264:   txa
00:8AED F00E            	  1265:   beq editor_insert_done_with_newline   ; nothing got inserted at all
00:8AEF C90A            	  1266:   cmp #NL
00:8AF1 F00A            	  1267:   beq editor_insert_done_with_newline  ; skip inserting a newline if we just got a newline
                        	  1268: ;
                        	  1269: ;  They finished inserting, but without a newline ... add one
                        	  1270: ;
00:8AF3 A90A            	  1271:   lda #NL
00:8AF5 9123            	  1272:   sta (PCODE),y
00:8AF7 E623            	  1273:   inc PCODE
00:8AF9 D002            	  1274:   bne editor_insert_done_with_newline
00:8AFB E624            	  1275:   inc PCODE+1
                        	  1276: 
                        	  1277: ;
                        	  1278: ;  they are done - copy the rest back to the end of where they just inserted
                        	  1279: ;
                        	  1280: editor_insert_done_with_newline:
                        	  1281: 
00:8AFD 64BE            	  1282:   stz system_flags     ; compile is not valid any more
                        	  1283: 
00:8AFF A523            	  1284:   lda PCODE
00:8B01 85A8            	  1285:   sta mem_move_dest
00:8B03 A524            	  1286:   lda PCODE+1
00:8B05 85A9            	  1287:   sta mem_move_dest+1
                        	  1288: 
00:8B07 A5A4            	  1289:   lda insert_limit
00:8B09 85A6            	  1290:   sta mem_move_src
00:8B0B A5A5            	  1291:   lda insert_limit+1
00:8B0D 85A7            	  1292:   sta mem_move_src+1
                        	  1293: 
00:8B0F 207A81          	  1294:   jsr movedown
                        	  1295: 
00:8B12 202594          	  1296:   jsr CROUT   ; put a newline after the ESC character
00:8B15 4C7282          	  1297:   jmp main_prompt
                        	  1298: 
                        	  1299: editor_too_full:
00:8B18 A943            	  1300:   lda #<memory_full
00:8B1A A28B            	  1301:   ldx #>memory_full
00:8B1C 202682          	  1302:   jsr print
                        	  1303: ;
                        	  1304: ;  consume input so it isn't mistaken for a command
                        	  1305: ;
                        	  1306: editor_too_full_loop:
00:8B1F 201FCB          	  1307:   jsr CHRIN
00:8B22 C91B            	  1308:   cmp #END_EDITOR_INPUT
00:8B24 D0F9            	  1309:   bne editor_too_full_loop
                        	  1310: ;
                        	  1311: ;  another message, they may miss the first one during a bulk load
                        	  1312: ;
00:8B26 A95E            	  1313:   lda #<memory_filled_up
00:8B28 A28B            	  1314:   ldx #>memory_filled_up
00:8B2A 202682          	  1315:   jsr print
00:8B2D 4CEC8A          	  1316:   jmp editor_insert_done
                        	  1317: 
00:8B30 4E6F2072616E6765	  1318: editor_no_lines  asciiz "No range supplied\n"
00:8B38 20737570706C6965
00:8B40 640A
00:8B42 00
00:8B43 0A0A4D656D6F7279	  1319: memory_full      asciiz "\n\nMemory full - press Esc\n"
00:8B4B 2066756C6C202D20
00:8B53 7072657373204573
00:8B5B 630A
00:8B5D 00
00:8B5E 0A0A4E6F20726F6F	  1320: memory_filled_up asciiz "\n\nNo room for source during load/input\n\n"
00:8B66 6D20666F7220736F
00:8B6E 7572636520647572
00:8B76 696E67206C6F6164
00:8B7E 2F696E7075740A0A
00:8B86 00
                        	  1321: 
                        	  1322: ;
                        	  1323: ;  subroutine to check we got a range for certain actions
                        	  1324: ;
                        	  1325: editor_argument_check:
00:8B87 A000            	  1326:   ldy #0
                        	  1327: ;
                        	  1328: ;  skip spaces to make sure we got a range
                        	  1329: ;
                        	  1330: editor_argument_check_loop:
00:8B89 B18E            	  1331:   lda (token_start),y
00:8B8B F00C            	  1332:   beq editor_argument_check_failed
00:8B8D C90A            	  1333:   cmp #NL
00:8B8F F008            	  1334:   beq editor_argument_check_failed
00:8B91 204A81          	  1335:   jsr isspace
00:8B94 900D            	  1336:   bcc editor_argument_check_got_argument
00:8B96 C8              	  1337:   iny
00:8B97 D0F0            	  1338:   bne editor_argument_check_loop
                        	  1339: 
                        	  1340: ;
                        	  1341: ;  only found spaces, not good enough
                        	  1342: ;
                        	  1343: editor_argument_check_failed:
00:8B99 A930            	  1344:   lda #<editor_no_lines
00:8B9B A28B            	  1345:   ldx #>editor_no_lines
00:8B9D 202682          	  1346:   jsr print
00:8BA0 4C7282          	  1347:   jmp  main_prompt
                        	  1348: 
                        	  1349: editor_argument_check_got_argument:
00:8BA3 60              	  1350:   rts
                        	  1351: 
                        	  1352: 
                        	  1353: ;--------------------------------------------
                        	  1354: ;  DELETE
                        	  1355: ;--------------------------------------------
                        	  1356: editor_delete:
                        	  1357: ;
                        	  1358: ;  default to no lines
                        	  1359: ;
00:8BA4 649E            	  1360:   stz from_line
00:8BA6 649F            	  1361:   stz from_line+1
00:8BA8 64A0            	  1362:   stz to_line
00:8BAA 64A1            	  1363:   stz to_line+1
                        	  1364: 
00:8BAC 64B9            	  1365:   stz find_count      ; delete count in this case
00:8BAE 64BA            	  1366:   stz find_count+1
00:8BB0 20878B          	  1367:   jsr editor_argument_check ; cannot get away with no arguments
                        	  1368: 
00:8BB3 205D86          	  1369:   jsr editor_get_range
00:8BB6 204086          	  1370:   jsr editor_check_no_more
                        	  1371: 
00:8BB9 A59E            	  1372:   lda from_line
00:8BBB 85AC            	  1373:   sta this_line
00:8BBD A59F            	  1374:   lda from_line+1
00:8BBF 85AD            	  1375:   sta this_line+1
00:8BC1 20858C          	  1376:   jsr find_line       ; find the "from" line address
00:8BC4 A5AE            	  1377:   lda this_line_addr  ; that becomes the destination of the move
00:8BC6 85A8            	  1378:   sta mem_move_dest
00:8BC8 A5AF            	  1379:   lda this_line_addr+1
00:8BCA 85A9            	  1380:   sta mem_move_dest+1
00:8BCC 64AA            	  1381:   stz mem_move_len
00:8BCE 64AB            	  1382:   stz mem_move_len+1
                        	  1383: ;
                        	  1384: ;  now we'll work our way up until we get to the to_line, however we'll
                        	  1385: ;  add one because we want the final address to actually be the start of
                        	  1386: ;  the NEXT line
                        	  1387: ;
00:8BD0 18              	  1388:   clc
00:8BD1 A5A0            	  1389:   lda to_line
00:8BD3 6901            	  1390:   adc #1
00:8BD5 85AC            	  1391:   sta this_line
00:8BD7 A5A1            	  1392:   lda to_line+1
00:8BD9 6900            	  1393:   adc #0
00:8BDB 85AD            	  1394:   sta this_line+1
00:8BDD 20938C          	  1395:   jsr find_line_loop    ; find the "to" line address
00:8BE0 A5AE            	  1396:   lda this_line_addr  ; that becomes the destination of the move
00:8BE2 85A6            	  1397:   sta mem_move_src
00:8BE4 A5AF            	  1398:   lda this_line_addr+1
00:8BE6 85A7            	  1399:   sta mem_move_src+1
                        	  1400: 
                        	  1401: ;
                        	  1402: ;  count how many lines we delete by counting newlines from
                        	  1403: ;   mem_move_dest to mem_move_src
                        	  1404: ;
                        	  1405: 
00:8BE8 A5A8            	  1406:   lda mem_move_dest
00:8BEA 8523            	  1407:   sta PCODE
00:8BEC A5A9            	  1408:   lda mem_move_dest+1
00:8BEE 8524            	  1409:   sta PCODE+1
00:8BF0 A000            	  1410:   ldy #0
                        	  1411: 
                        	  1412: editor_delete_line_count_loop:
00:8BF2 A523            	  1413:   lda PCODE
00:8BF4 C5A6            	  1414:   cmp mem_move_src
00:8BF6 D006            	  1415:   bne editor_delete_line_count_not_done
00:8BF8 A524            	  1416:   lda PCODE+1
00:8BFA C5A7            	  1417:   cmp mem_move_src+1
00:8BFC F014            	  1418:   beq editor_delete_line_count_done
                        	  1419: 
                        	  1420: editor_delete_line_count_not_done:
00:8BFE B123            	  1421:   lda (PCODE),y
00:8C00 C90A            	  1422:   cmp #NL
00:8C02 D006            	  1423:   bne editor_delete_line_count_not_newline
00:8C04 E6B9            	  1424:   inc find_count
00:8C06 D002            	  1425:   bne editor_delete_line_count_not_newline
00:8C08 E6BA            	  1426:   inc find_count+1
                        	  1427: editor_delete_line_count_not_newline:
00:8C0A E623            	  1428:   inc PCODE
00:8C0C D0E4            	  1429:   bne editor_delete_line_count_loop
00:8C0E E624            	  1430:   inc PCODE+1
00:8C10 80E0            	  1431:   bra editor_delete_line_count_loop
                        	  1432: 
                        	  1433: ;
                        	  1434: ;  now find where the source ends
                        	  1435: ;  PCODE will now be at the first line to not be deleted
                        	  1436: ;
                        	  1437: editor_delete_line_count_done:
                        	  1438: 
00:8C12 20C18C          	  1439:   jsr find_source_end_loop
00:8C15 38              	  1440:   sec
00:8C16 A523            	  1441:   lda PCODE
00:8C18 E5AE            	  1442:   sbc this_line_addr
00:8C1A 85AA            	  1443:   sta mem_move_len
00:8C1C A524            	  1444:   lda PCODE+1
00:8C1E E5AF            	  1445:   sbc this_line_addr+1
00:8C20 85AB            	  1446:   sta mem_move_len+1
00:8C22 207A81          	  1447:   jsr movedown  ; that should do it
                        	  1448: 
00:8C25 A5B9            	  1449:   lda find_count
00:8C27 8500            	  1450:   sta REG
00:8C29 A5BA            	  1451:   lda find_count+1
00:8C2B 8501            	  1452:   sta REG+1
00:8C2D 6402            	  1453:   stz REGB
00:8C2F 204F93          	  1454:   jsr display_in_decimal
00:8C32 A93C            	  1455:   lda #<lines_deleted_message
00:8C34 A28C            	  1456:   ldx #>lines_deleted_message
00:8C36 202682          	  1457:   jsr print
00:8C39 4C7282          	  1458:   jmp main_prompt
                        	  1459: 
00:8C3C 2064656C65746564	  1460: lines_deleted_message asciiz " deleted.\n"
00:8C44 2E0A
00:8C46 00
                        	  1461: 
                        	  1462: ;--------------------------------------------
                        	  1463: ;  show current line number with leading spaces
                        	  1464: ;--------------------------------------------
                        	  1465: show_current_line_number:
00:8C47 48              	  1466:   pha
00:8C48 DA              	  1467:   phx
00:8C49 5A              	  1468:   phy
                        	  1469: ;
                        	  1470: ;  get the line number into REG ready for printing
                        	  1471: ;
00:8C4A A5A2            	  1472:   lda current_line
00:8C4C 8500            	  1473:   sta REG
00:8C4E A6A3            	  1474:   ldx current_line+1
00:8C50 8601            	  1475:   stx REG+1
00:8C52 A000            	  1476:   ldy #0        ; count of leading spaces
00:8C54 8402            	  1477:   sty REGB
00:8C56 E003            	  1478:   cpx #>1000    ; if the number is >= 1000 don't print any spaces
00:8C58 9006            	  1479:   bcc line_number_lt_1000
00:8C5A D013            	  1480:   bne line_number_output_spaces
00:8C5C C9E8            	  1481:   cmp #<1000
00:8C5E B00F            	  1482:   bcs line_number_output_spaces
                        	  1483: line_number_lt_1000:
00:8C60 C8              	  1484:   iny           ; output one space
00:8C61 E000            	  1485:   cpx  #0       ; if line number > 255 then one space is all we need
00:8C63 D00A            	  1486:   bne  line_number_output_spaces
00:8C65 C964            	  1487:   cmp  #100     ; if line number >= 100 then one space is all we need
00:8C67 B006            	  1488:   bcs  line_number_output_spaces
00:8C69 C8              	  1489:   iny           ; output two spaces
00:8C6A C90A            	  1490:   cmp  #10      ; if line number >= 10 then two spaces are all we need
00:8C6C B001            	  1491:   bcs  line_number_output_spaces
00:8C6E C8              	  1492:   iny           ; output three spaces
                        	  1493: line_number_output_spaces:
00:8C6F C000            	  1494:   cpy #0            ; leading spaces in front of line number
00:8C71 F008            	  1495:   beq  show_current_line_number_done
00:8C73 5A              	  1496:   phy
00:8C74 20B094          	  1497:   jsr  PUTSP      ; output the space
00:8C77 7A              	  1498:   ply
00:8C78 88              	  1499:   dey             ; count them
00:8C79 D0F4            	  1500:   bne  line_number_output_spaces  ; more spaces to go
                        	  1501: show_current_line_number_done:
00:8C7B 204F93          	  1502:   jsr  display_in_decimal    ; now the actual number
00:8C7E 20B094          	  1503:   jsr  PUTSP      ; and a space after it
00:8C81 7A              	  1504:   ply
00:8C82 FA              	  1505:   plx
00:8C83 68              	  1506:   pla
00:8C84 60              	  1507:   rts
                        	  1508: 
                        	  1509: ;--------------------------------------------
                        	  1510: ;  find_line
                        	  1511: ;
                        	  1512: ;  finds address of this_line in memory - returns in this_line_addr
                        	  1513: ;--------------------------------------------
                        	  1514: find_line:
00:8C85 A901            	  1515:   lda #1
00:8C87 85A2            	  1516:   sta current_line    ; current line number (1)
00:8C89 64A3            	  1517:   stz current_line+1
00:8C8B A900            	  1518:   lda #<TEXT_START   ; start at start of source
00:8C8D 85AE            	  1519:   sta this_line_addr
00:8C8F A903            	  1520:   lda #>TEXT_START
00:8C91 85AF            	  1521:   sta this_line_addr+1
                        	  1522: find_line_loop:
00:8C93 A000            	  1523:   ldy #0
00:8C95 A5A2            	  1524:   lda current_line
00:8C97 C5AC            	  1525:   cmp this_line
00:8C99 D007            	  1526:   bne find_line_next
00:8C9B A5A3            	  1527:   lda current_line+1
00:8C9D C5AD            	  1528:   cmp this_line+1
00:8C9F D001            	  1529:   bne find_line_next
00:8CA1 60              	  1530:   rts
                        	  1531: find_line_next:
00:8CA2 B1AE            	  1532:   lda (this_line_addr),Y
00:8CA4 F012            	  1533:   beq find_line_eof
00:8CA6 C90A            	  1534:   cmp #NL
00:8CA8 D006            	  1535:   bne find_line_same_line
00:8CAA E6A2            	  1536:   inc current_line       ; add 1 to our line number counter
00:8CAC D002            	  1537:   bne find_line_same_line
00:8CAE E6A3            	  1538:   inc current_line+1
                        	  1539: find_line_same_line:
00:8CB0 E6AE            	  1540:   inc this_line_addr     ; onto next address - which means that a newline
00:8CB2 D0DF            	  1541:   bne find_line_loop     ; will actually end up being the start of the new
00:8CB4 E6AF            	  1542:   inc this_line_addr+1   ; line, which is what we want
00:8CB6 80DB            	  1543:   bra find_line_loop
                        	  1544: find_line_eof:           ; we are pointing to 0x00 - make that the address
00:8CB8 60              	  1545:   rts
                        	  1546: 
                        	  1547: 
                        	  1548: 
                        	  1549: ;***********************************************
                        	  1550: ; Find text end
                        	  1551: ;***********************************************
                        	  1552: find_source_end:
00:8CB9 A900            	  1553:   lda  #<TEXT_START        ; start at start of source
00:8CBB 8523            	  1554:   sta  PCODE
00:8CBD A903            	  1555:   lda  #>TEXT_START
00:8CBF 8524            	  1556:   sta  PCODE+1
                        	  1557: find_source_end_loop =  *
00:8CC1 A000            	  1558:   ldy  #0
00:8CC3 B123            	  1559:   lda  (PCODE),Y             ; keep going until 0x00 indicates end of source
00:8CC5 F008            	  1560:   beq  find_source_end_wrap
00:8CC7 E623            	  1561:   inc  PCODE
00:8CC9 D0F6            	  1562:   bne  find_source_end_loop
00:8CCB E624            	  1563:   inc  PCODE+1
00:8CCD 80F2            	  1564:   bra  find_source_end_loop
                        	  1565: ;
                        	  1566: ;  include final 0x00
                        	  1567: ;
                        	  1568: find_source_end_wrap =  *
00:8CCF E623            	  1569:   inc  PCODE
00:8CD1 D002            	  1570:   bne  find_source_end_done
00:8CD3 E624            	  1571:   inc  PCODE+1
                        	  1572: find_source_end_done =  *
00:8CD5 60              	  1573:   rts
                        	  1574: 
                        	  1575: ;
                        	  1576: ;  testing BRK handling
                        	  1577: ;
00:8CD6 0A526573756D6564	  1578: brk_resumed asciiz "\nResumed after BRK\n"
00:8CDE 2061667465722042
00:8CE6 524B0A
00:8CE9 00
                        	  1579: 
                        	  1580: ;
                        	  1581: ;  memory dump
                        	  1582: ;
                        	  1583: editor_memory:
00:8CEA 20878B          	  1584:   jsr editor_argument_check  ; check they supplied some sort of range
00:8CED 203A85          	  1585:   jsr editor_default_range
00:8CF0 A902            	  1586:   lda #EFLAG_ALLOW_ZERO_FROM
00:8CF2 85BC            	  1587:   sta editor_flags
00:8CF4 205D86          	  1588:   jsr editor_get_range
00:8CF7 204086          	  1589:   jsr editor_check_no_more
00:8CFA 64A2            	  1590:   stz current_line      ; count of bytes shown
00:8CFC A59E            	  1591:   lda from_line
00:8CFE 85AE            	  1592:   sta this_line_addr
00:8D00 A59F            	  1593:   lda from_line+1
00:8D02 85AF            	  1594:   sta this_line_addr+1
                        	  1595: 
                        	  1596: editor_memory_loop:
00:8D04 A58B            	  1597:   lda serial_in_byte_received
00:8D06 C903            	  1598:   cmp  #KEY_ABORT
00:8D08 F053            	  1599:   beq  editor_memory_aborted
                        	  1600: 
00:8D0A A5A2            	  1601:   lda current_line
00:8D0C D017            	  1602:   bne editor_memory_loop1
                        	  1603: ;
                        	  1604: ;  show address
                        	  1605: ;
00:8D0E A924            	  1606:   lda #'$'
00:8D10 20B395          	  1607:   jsr COUT
00:8D13 A59F            	  1608:   lda from_line+1
00:8D15 209A94          	  1609:   jsr PRBYTE
00:8D18 A59E            	  1610:   lda from_line
00:8D1A 209A94          	  1611:   jsr PRBYTE
00:8D1D A93A            	  1612:   lda #':'
00:8D1F 20B395          	  1613:   jsr COUT
00:8D22 20B094          	  1614:   jsr PUTSP
                        	  1615: editor_memory_loop1:
00:8D25 A000            	  1616:   ldy #0
00:8D27 B19E            	  1617:   lda (from_line),Y
00:8D29 209A94          	  1618:   jsr PRBYTE
00:8D2C 20B094          	  1619:   jsr PUTSP
00:8D2F E6A2            	  1620:   inc current_line
00:8D31 E69E            	  1621:   inc from_line
00:8D33 D002            	  1622:   bne editor_memory_loop2
00:8D35 E69F            	  1623:   inc from_line+1
                        	  1624: editor_memory_loop2:
                        	  1625: ;
                        	  1626: ;  if we wrap around back to zero, stop
                        	  1627: ;
00:8D37 A59E            	  1628:   lda from_line
00:8D39 059F            	  1629:   ora from_line+1
00:8D3B F01D            	  1630:   beq editor_memory_done
00:8D3D A59F            	  1631:   lda from_line+1
00:8D3F C5A1            	  1632:   cmp to_line+1
00:8D41 900A            	  1633:   bcc editor_memory_loop3   ; less than
00:8D43 D015            	  1634:   bne editor_memory_done    ; greater than
00:8D45 A59E            	  1635:   lda from_line             ; equal, so try low-order byte
00:8D47 C5A0            	  1636:   cmp to_line
00:8D49 9002            	  1637:   bcc editor_memory_loop3   ; less than
00:8D4B D00D            	  1638:   bne editor_memory_done    ; greater than
                        	  1639: editor_memory_loop3:
00:8D4D A5A2            	  1640:   lda current_line
00:8D4F C910            	  1641:   cmp #16
00:8D51 90B1            	  1642:   bcc editor_memory_loop
00:8D53 20638D          	  1643:   jsr editor_memory_show_ascii
00:8D56 64A2            	  1644:   stz current_line      ; count of bytes shown
00:8D58 80AA            	  1645:   bra editor_memory_loop
                        	  1646: 
                        	  1647: editor_memory_done:
00:8D5A 20638D          	  1648:   jsr editor_memory_show_ascii
                        	  1649: editor_memory_aborted:
00:8D5D 202594          	  1650:   jsr CROUT
00:8D60 4C7282          	  1651:   jmp  main_prompt
                        	  1652: 
                        	  1653: editor_memory_show_ascii:
                        	  1654: ;
                        	  1655: ;  now the ASCII equivalents
                        	  1656: ;
00:8D63 20B094          	  1657:   jsr PUTSP
00:8D66 A000            	  1658:   ldy #0
                        	  1659: editor_memory_ascii:
00:8D68 B1AE            	  1660:   lda (this_line_addr),Y
00:8D6A C920            	  1661:   cmp #$20
00:8D6C B002            	  1662:   bcs editor_memory_not_control
00:8D6E 8004            	  1663:   bra editor_memory_show_dot
                        	  1664: editor_memory_not_control:
00:8D70 C97F            	  1665:   cmp #$7F
00:8D72 9002            	  1666:   bcc editor_memory_not_high
                        	  1667: editor_memory_show_dot
00:8D74 A92E            	  1668:   lda #'.'
                        	  1669: editor_memory_not_high:
00:8D76 20B395          	  1670:   jsr COUT
00:8D79 20B094          	  1671:   jsr PUTSP
00:8D7C C8              	  1672:   iny
00:8D7D C6A2            	  1673:   dec current_line
00:8D7F D0E7            	  1674:   bne editor_memory_ascii
                        	  1675: ;
                        	  1676: ;  adjust the ASCII printing address
                        	  1677: ;
00:8D81 A59E            	  1678:   lda from_line
00:8D83 85AE            	  1679:   sta this_line_addr
00:8D85 A59F            	  1680:   lda from_line+1
00:8D87 85AF            	  1681:   sta this_line_addr+1
                        	  1682: 
00:8D89 202594          	  1683:   jsr CROUT
00:8D8C 60              	  1684:   rts
                        	  1685: 
                        	  1686: ;
                        	  1687: ;  for testing during development, omit for now
                        	  1688: ;
                        	  1689: 
                        	  1690:   .if 0
                        	  1691: 
                        	  1692: symbol_table_message asciiz "Addr Prev L  T Dsp  Ar Da Ln Name\n"
                        	  1693: 
                        	  1694: editor_symbol_table_list  = *
                        	  1695:   lda #<symbol_table_message
                        	  1696:   ldx #>symbol_table_message
                        	  1697:   jsr print
                        	  1698: 
                        	  1699:   lda  ENDSYM+1    ; get the end of the symbol table
                        	  1700:   sta  SYMITM+1    ; make it the current symbol
                        	  1701:   lda  ENDSYM
                        	  1702:   bra  ST_SYMTBL_LIST_CHECK
                        	  1703: 
                        	  1704: ST_SYMTBL_LIST_NEXT =  *
                        	  1705:   ldy  #SYMPRV
                        	  1706:   lda  (SYMITM),Y
                        	  1707:   tax
                        	  1708:   iny
                        	  1709:   lda  (SYMITM),Y
                        	  1710:   sta  SYMITM+1   ; previous link
                        	  1711:   txa
                        	  1712: ;
                        	  1713: ;  go to the previous symbol table item
                        	  1714: ;
                        	  1715: ST_SYMTBL_LIST_CHECK     =  *
                        	  1716:   sta  SYMITM
                        	  1717:   cmp  #<SYMBOL_TABLE_START
                        	  1718:   bne  ST_SYMTBL_LIST_LINE
                        	  1719:   lda  SYMITM+1
                        	  1720:   cmp  #>SYMBOL_TABLE_START
                        	  1721:   bne  ST_SYMTBL_LIST_LINE       ; more to go
                        	  1722:   jmp  ST_SYMTBL_LIST_DONE       ; finished if symitm and symitm+1 are both zero
                        	  1723: 
                        	  1724: ST_SYMTBL_LIST_LINE = *
                        	  1725:   lda  SYMITM+1
                        	  1726:   jsr  PRBYTE
                        	  1727:   lda  SYMITM
                        	  1728:   jsr  PRBYTE
                        	  1729:   lda  #' '
                        	  1730:   jsr  PRCHAR
                        	  1731:   ldy  #SYMPRV+1
                        	  1732:   lda  (SYMITM),Y
                        	  1733:   jsr  PRBYTE
                        	  1734:   dey
                        	  1735:   lda  (SYMITM),Y
                        	  1736:   jsr  PRBYTE
                        	  1737:   lda  #' '
                        	  1738:   jsr  PRCHAR
                        	  1739:   ldy  #SYMLVL
                        	  1740:   lda  (SYMITM),Y  ; level
                        	  1741:   jsr  PRBYTE
                        	  1742:   lda  #' '
                        	  1743:   jsr  PRCHAR
                        	  1744:   ldy  #SYMTYP
                        	  1745:   lda  (SYMITM),Y  ; type
                        	  1746:   jsr  PRCHAR
                        	  1747:   lda  #' '
                        	  1748:   jsr  PRCHAR
                        	  1749:   ldy  #SYMDSP
                        	  1750:   iny
                        	  1751:   lda  (SYMITM),Y  ; displacement
                        	  1752:   jsr  PRBYTE
                        	  1753:   dey
                        	  1754:   lda  (SYMITM),Y  ; displacement
                        	  1755:   jsr  PRBYTE
                        	  1756:   lda  #' '
                        	  1757:   jsr  PRCHAR
                        	  1758:   ldy  #SYMARG
                        	  1759:   lda  (SYMITM),Y  ; argument count
                        	  1760:   jsr  PRBYTE
                        	  1761:   lda  #' '
                        	  1762:   jsr  PRCHAR
                        	  1763:   ldy  #SYMDAT
                        	  1764:   lda  (SYMITM),Y  ; data type
                        	  1765:   jsr  PRBYTE
                        	  1766:   lda  #' '
                        	  1767:   jsr  PRCHAR
                        	  1768:   ldy  #SYMLEN
                        	  1769:   lda  (SYMITM),Y  ; length
                        	  1770:   pha
                        	  1771:   jsr  PRBYTE
                        	  1772:   lda  #' '
                        	  1773:   jsr  PRCHAR
                        	  1774:   ldy  #SYMNAM
                        	  1775:   pla
                        	  1776:   tax
                        	  1777: ST_SYMTBL_LIST_NAME = *
                        	  1778:   lda  (SYMITM),Y  ; name
                        	  1779:   phy
                        	  1780:   jsr  PRCHAR
                        	  1781:   ply
                        	  1782:   iny
                        	  1783:   dex
                        	  1784:   bne ST_SYMTBL_LIST_NAME
                        	  1785:   jsr CROUT
                        	  1786:   jmp ST_SYMTBL_LIST_NEXT
                        	  1787: 
                        	  1788: ST_SYMTBL_LIST_DONE = *
                        	  1789: 
                        	  1790:   jmp main_prompt
                        	  1791: 
                        	  1792:   .endif  ; 0
                        	  1793: 
00:8D8D 446F6E650A      	  1794: recover_done asciiz "Done\n"
00:8D92 00
00:8D93 4E6F74206E656564	  1795: recover_not_needed asciiz "Not needed\n"
00:8D9B 65640A
00:8D9E 00
                        	  1796: 
                        	  1797: ;
                        	  1798: ; Recover: if the first byte of the source is 0x00, change it to a space
                        	  1799: ;
                        	  1800: editor_recover:
00:8D9F 204086          	  1801:   jsr editor_check_no_more
00:8DA2 A900            	  1802:   lda  #<TEXT_START
00:8DA4 8540            	  1803:   sta  FROM
00:8DA6 A903            	  1804:   lda  #>TEXT_START
00:8DA8 8541            	  1805:   sta  FROM+1
00:8DAA A000            	  1806:   ldy  #0
00:8DAC B140            	  1807:   lda  (FROM),Y
00:8DAE D00E            	  1808:   bne  editor_recover_not_needed
00:8DB0 A920            	  1809:   lda  #' '
00:8DB2 9140            	  1810:   sta  (FROM),Y
                        	  1811: editor_done_message:
00:8DB4 A98D            	  1812:   lda #<recover_done
00:8DB6 A28D            	  1813:   ldx #>recover_done
00:8DB8 202682          	  1814:   jsr print
00:8DBB 4C7282          	  1815:   jmp main_prompt
                        	  1816: 
                        	  1817: editor_recover_not_needed:
00:8DBE A993            	  1818:   lda #<recover_not_needed
00:8DC0 A28D            	  1819:   ldx #>recover_not_needed
00:8DC2 202682          	  1820:   jsr print
00:8DC5 4C7282          	  1821:   jmp main_prompt
                        	  1822: 
00:8DC8 43616E6E6F742074	  1823: not_assembler_message asciiz "Cannot trace or debug assembler code\n"
00:8DD0 72616365206F7220
00:8DD8 6465627567206173
00:8DE0 73656D626C657220
00:8DE8 636F64650A
00:8DED 00
                        	  1824: 
                        	  1825: editor_debug:
00:8DEE 204086          	  1826:   jsr editor_check_no_more
00:8DF1 A910            	  1827:   lda  #FLAG_VALID_ASSEMBLE
00:8DF3 25BE            	  1828:   and  system_flags
00:8DF5 F00A            	  1829:   beq editor_debug_ok
                        	  1830: 
                        	  1831: editor_not_assembler:
00:8DF7 A9C8            	  1832:   lda #<not_assembler_message
00:8DF9 A28D            	  1833:   ldx #>not_assembler_message
00:8DFB 202682          	  1834:   jsr print
00:8DFE 4C7282          	  1835:   jmp main_prompt
                        	  1836: 
                        	  1837: editor_debug_ok:
00:8E01 A901            	  1838:   lda #1
00:8E03 8549            	  1839:   sta  DBGFLG
00:8E05 852E            	  1840:   sta  DCODE
00:8E07 4C6895          	  1841:   jmp  CHK_RUN
                        	  1842: 
                        	  1843: editor_trace:
00:8E0A 204086          	  1844:   jsr editor_check_no_more
00:8E0D A910            	  1845:   lda  #FLAG_VALID_ASSEMBLE
00:8E0F 25BE            	  1846:   and  system_flags
00:8E11 D0E4            	  1847:   bne  editor_not_assembler
00:8E13 A980            	  1848:   lda  #$80
00:8E15 8549            	  1849:   sta  DBGFLG
00:8E17 852E            	  1850:   sta  DCODE
00:8E19 4C6895          	  1851:   jmp  CHK_RUN
                        	  1852: 
                        	  1853: 
                        	  1854: editor_info  = *
00:8E1C 204086          	  1855:   jsr editor_check_no_more
00:8E1F 209B8E          	  1856:   jsr show_source_start
00:8E22 20738E          	  1857:   jsr show_source_end
00:8E25 20BD8E          	  1858:   jsr show_source_lines
00:8E28 208092          	  1859:   jsr crc_source
00:8E2B 4C7282          	  1860:   jmp main_prompt
                        	  1861: 
                        	  1862:   .if USE_PASCAL
                        	  1863: editor_compile:
00:8E2E 204086          	  1864:   jsr editor_check_no_more
00:8E31 A900            	  1865:   lda  #0
00:8E33 8542            	  1866:   sta  SYNTAX
00:8E35 4CC0AF          	  1867:   jmp  COMPIL
                        	  1868: 
                        	  1869: editor_syntax:
00:8E38 204086          	  1870:   jsr editor_check_no_more
00:8E3B A901            	  1871:   lda #1
00:8E3D 8542            	  1872:   sta  SYNTAX
00:8E3F 4CC0AF          	  1873:   jmp  COMPIL
                        	  1874:   .endif    ; USE_PASCAL
                        	  1875: 
                        	  1876: editor_run:
00:8E42 204086          	  1877:   jsr editor_check_no_more
00:8E45 A900            	  1878:   lda  #0
00:8E47 8549            	  1879:   sta  DBGFLG
00:8E49 852E            	  1880:   sta  DCODE
00:8E4B 4C6895          	  1881:   jmp  CHK_RUN
                        	  1882: 
                        	  1883:   ;
                        	  1884: show_symbol_table_end:
00:8E4E A90D            	  1885:   lda  #<symbol_table_ended_message    ; Symbol table ended at
00:8E50 A295            	  1886:   ldx  #>symbol_table_ended_message
00:8E52 202682          	  1887:   jsr  print
00:8E55 A532            	  1888:   lda  ENDSYM+1
00:8E57 209A94          	  1889:   jsr  PRBYTE
00:8E5A A531            	  1890:   lda  ENDSYM
00:8E5C 204F95          	  1891:   jsr  PRBYTECR
00:8E5F 60              	  1892:   rts
                        	  1893: 
                        	  1894: 
00:8E60 536F757263652065	  1895: source_ended_message asciiz "Source ends   at $"
00:8E68 6E64732020206174
00:8E70 2024
00:8E72 00
                        	  1896: show_source_end:
00:8E73 A960            	  1897:   lda #<source_ended_message
00:8E75 A28E            	  1898:   ldx #>source_ended_message
00:8E77 202682          	  1899:   jsr print
00:8E7A 20B98C          	  1900:   jsr find_source_end
00:8E7D A524            	  1901:   lda PCODE+1
00:8E7F 209A94          	  1902:   jsr PRBYTE
00:8E82 A523            	  1903:   lda PCODE
00:8E84 204F95          	  1904:   jsr PRBYTECR
00:8E87 60              	  1905:   rts
                        	  1906: 
00:8E88 536F757263652073	  1907: source_starts_message asciiz "Source starts at $"    ; source starts at
00:8E90 7461727473206174
00:8E98 2024
00:8E9A 00
                        	  1908: show_source_start:
00:8E9B A988            	  1909:   lda #<source_starts_message
00:8E9D A28E            	  1910:   ldx #>source_starts_message
00:8E9F 202682          	  1911:   jsr print
00:8EA2 A903            	  1912:   lda #>TEXT_START
00:8EA4 209A94          	  1913:   jsr PRBYTE
00:8EA7 A900            	  1914:   lda #<TEXT_START
00:8EA9 204F95          	  1915:   jsr PRBYTECR
00:8EAC 60              	  1916:   rts
                        	  1917: 
                        	  1918: ;--------------------------------------------
                        	  1919: ;  show_source_lines - show count of number of source lines
                        	  1920: ;--------------------------------------------
00:8EAD 536F75726365206C	  1921: source_line_count asciiz "Source lines:  "    ; count of lines
00:8EB5 696E65733A2020
00:8EBC 00
                        	  1922: show_source_lines:
00:8EBD 6400            	  1923:   stz VALUE      ; line count in this case
00:8EBF 6401            	  1924:   stz VALUE+1
00:8EC1 6402            	  1925:   stz VALUE+2
                        	  1926: 
00:8EC3 A900            	  1927:   lda #<TEXT_START
00:8EC5 8523            	  1928:   sta PCODE
00:8EC7 A903            	  1929:   lda #>TEXT_START
00:8EC9 8524            	  1930:   sta PCODE+1
00:8ECB A000            	  1931:   ldy #0
                        	  1932: 
                        	  1933: editor_line_count_loop:
00:8ECD B123            	  1934:   lda (PCODE),y
00:8ECF F012            	  1935:   beq editor_line_count_done    ; 0x00 means end of source
00:8ED1 C90A            	  1936:   cmp #NL                       ; newline?
00:8ED3 D006            	  1937:   bne editor_line_count_not_newline
00:8ED5 E600            	  1938:   inc VALUE
00:8ED7 D002            	  1939:   bne editor_line_count_not_newline
00:8ED9 E601            	  1940:   inc VALUE+1
                        	  1941: ;
                        	  1942: ;  increment pointer
                        	  1943: ;
                        	  1944: editor_line_count_not_newline:
00:8EDB E623            	  1945:   inc PCODE
00:8EDD D0EE            	  1946:   bne editor_line_count_loop
00:8EDF E624            	  1947:   inc PCODE+1
00:8EE1 80EA            	  1948:   bra editor_line_count_loop
                        	  1949: 
                        	  1950: editor_line_count_done:
00:8EE3 A9AD            	  1951:   lda #<source_line_count
00:8EE5 A28E            	  1952:   ldx #>source_line_count
00:8EE7 202682          	  1953:   jsr print
00:8EEA 204F93          	  1954:   jsr display_in_decimal
00:8EED 202594          	  1955:   jsr CROUT
00:8EF0 60              	  1956:   rts
                        	  1957: 
                        	  1958:   .if USE_ASSEMBLER
                        	  1959: editor_assemble:
00:8EF1 204086          	  1960:   jsr editor_check_no_more
00:8EF4 4CBE9A          	  1961:   jmp ASSEMBLE
                        	  1962:   .endif  ; USE_ASSEMBLER
                        	  1963: 
00:8EF7 4E6F2042524B2070	  1964: no_break_message asciiz "No BRK previously encountered\n"
00:8EFF 726576696F75736C
00:8F07 7920656E636F756E
00:8F0F 74657265640A
00:8F15 00
                        	  1965: 
                        	  1966: ;--------------------------------------------
                        	  1967: ;  editor_resume - resume after a breakpoint
                        	  1968: ;--------------------------------------------
                        	  1969: editor_resume:
00:8F16 205595          	  1970:   jsr CHK_VAL     ; check we had a valid compile/assemble
00:8F19 A5BE            	  1971:   lda system_flags
00:8F1B 2980            	  1972:   and #FLAG_BRK_REACHED    ; BRK reached yet?
00:8F1D D00A            	  1973:   bne editor_resume_ok
00:8F1F A9F7            	  1974:   lda #<no_break_message
00:8F21 A28E            	  1975:   ldx #>no_break_message
00:8F23 202682          	  1976:   jsr print
00:8F26 4C7282          	  1977:   jmp main_prompt
                        	  1978: editor_resume_ok:
00:8F29 A980            	  1979:   lda #FLAG_BRK_REACHED    ; no BRK reached yet
00:8F2B 14BE            	  1980:   trb system_flags
                        	  1981: ;
                        	  1982: ;  put the stack back to what it was and push the
                        	  1983: ;   processor flags and breakpoint address
                        	  1984: ;
00:8F2D 18              	  1985:   clc
00:8F2E A514            	  1986:   lda call_s
00:8F30 6905            	  1987:   adc #5      ; undo effect of pushing X and Y, and the 3 pushes the processor did
00:8F32 AA              	  1988:   tax
00:8F33 9A              	  1989:   txs         ; switch back to what the stack pointer was
00:8F34 A516            	  1990:   lda brk_address+1   ; put stuff back ready for rti
00:8F36 48              	  1991:   pha
00:8F37 A515            	  1992:   lda brk_address
00:8F39 48              	  1993:   pha
00:8F3A A513            	  1994:   lda call_p
00:8F3C 48              	  1995:   pha         ; processor flags
00:8F3D A510            	  1996:   lda call_a  ; get registers back
00:8F3F A412            	  1997:   ldy call_y
00:8F41 A611            	  1998:   ldx call_x
00:8F43 40              	  1999:   rti
                        	  2000: 
                        	  2001: 
00:8F44 4E65656420616E20	  2002: editor_poke_message asciiz "Need an address and at least one value\n"
00:8F4C 6164647265737320
00:8F54 616E64206174206C
00:8F5C 65617374206F6E65
00:8F64 2076616C75650A
00:8F6B 00
                        	  2003: 
                        	  2004: ;--------------------------------------------
                        	  2005: ;  editor_poke - put stuff into memory
                        	  2006: ;
                        	  2007: ;  Note that as we do two passes over the input line, if they
                        	  2008: ;  choose a one-character string, get_token parses strings
                        	  2009: ;  into INBUF, so INBUF will be corrupted, however even in
                        	  2010: ;  the worst-case scenario: p8'a'
                        	  2011: ;  The corruption is only over the 'p' and re-parsing works OK. Just.
                        	  2012: ;--------------------------------------------
                        	  2013: editor_poke:
                        	  2014: ;
                        	  2015: ;  first check how many numbers are on the input line
                        	  2016: ;
00:8F6C 64B9            	  2017:   stz find_count
00:8F6E A58E            	  2018:   lda token_start
00:8F70 859E            	  2019:   sta from_line
00:8F72 A58F            	  2020:   lda token_start+1
00:8F74 859F            	  2021:   sta from_line+1
                        	  2022: 
                        	  2023: editor_poke_loop:
00:8F76 209FCB          	  2024:   jsr get_token
00:8F79 F02D            	  2025:   beq editor_poke_got_all_numbers
00:8F7B C94E            	  2026:   cmp #TOKEN_NUMBER
00:8F7D F011            	  2027:   beq editor_poke_got_number
00:8F7F C922            	  2028:   cmp #TOKEN_STRING           ; a one-byte string is OK, eg. poke $1000 'a'
00:8F81 D00A            	  2029:   bne editor_poke_bad_token
00:8F83 A5B9            	  2030:   lda find_count
00:8F85 F006            	  2031:   beq editor_poke_bad_token   ; however not for the address
00:8F87 A592            	  2032:   lda token_length
00:8F89 C901            	  2033:   cmp #1
00:8F8B F003            	  2034:   beq editor_poke_got_number
                        	  2035: ;
                        	  2036: ;  here when we got neither a number or a single-byte string
                        	  2037: ;
                        	  2038: editor_poke_bad_token:
00:8F8D 4C5885          	  2039:   jmp editor_bad_number
                        	  2040: editor_poke_got_number:
00:8F90 E6B9            	  2041:   inc find_count
00:8F92 A5B9            	  2042:   lda find_count
00:8F94 C901            	  2043:   cmp #1
00:8F96 D007            	  2044:   bne editor_poke_not_first
                        	  2045: ;
                        	  2046: ;  here for first number - must be in range 0x0000 to 0xffff
                        	  2047: ;
00:8F98 A596            	  2048:   lda token_value+2
00:8F9A F0DA            	  2049:   beq editor_poke_loop
00:8F9C 4CFA85          	  2050:   jmp editor_line_number_too_big
                        	  2051: editor_poke_not_first:
                        	  2052: ;
                        	  2053: ;  here for subsequent numbers - must be in range 0x00 to 0xff
                        	  2054: ;
00:8F9F A595            	  2055:   lda token_value+1
00:8FA1 0596            	  2056:   ora token_value+2
00:8FA3 F0D1            	  2057:   beq editor_poke_loop
00:8FA5 4CFA85          	  2058:   jmp editor_line_number_too_big
                        	  2059: 
                        	  2060: ;
                        	  2061: ;  must have at least two numbers
                        	  2062: ;
                        	  2063: editor_poke_got_all_numbers:
00:8FA8 A5B9            	  2064:   lda find_count
00:8FAA C902            	  2065:   cmp #2
00:8FAC B00A            	  2066:   bcs editor_poke_got_enough
00:8FAE A944            	  2067:   lda #<editor_poke_message
00:8FB0 A28F            	  2068:   ldx #>editor_poke_message
00:8FB2 202682          	  2069:   jsr print
00:8FB5 4C7282          	  2070:   jmp main_prompt
                        	  2071: 
                        	  2072: editor_poke_got_enough:
                        	  2073: ;
                        	  2074: ;  reset for get_token to do its stuff again
                        	  2075: ;
00:8FB8 A59E            	  2076:   lda from_line
00:8FBA 858E            	  2077:   sta token_start
00:8FBC A59F            	  2078:   lda from_line+1
00:8FBE 858F            	  2079:   sta token_start+1
                        	  2080: ;
                        	  2081: ;  get address again - we know it is valid since we checked above
                        	  2082: ;
00:8FC0 209FCB          	  2083:   jsr get_token
                        	  2084: ;
                        	  2085: ;  where to put stuff
                        	  2086: ;
00:8FC3 A594            	  2087:   lda token_value
00:8FC5 859E            	  2088:   sta from_line
00:8FC7 A595            	  2089:   lda token_value+1
00:8FC9 859F            	  2090:   sta from_line+1
                        	  2091: 
                        	  2092: editor_poking_loop:
00:8FCB 209FCB          	  2093:   jsr get_token
00:8FCE D003            	  2094:   bne editor_poke_another
00:8FD0 4CB48D          	  2095:   jmp editor_done_message
                        	  2096: 
                        	  2097: editor_poke_another:
00:8FD3 A000            	  2098:   ldy #0
00:8FD5 A594            	  2099:   lda token_value
00:8FD7 919E            	  2100:   sta (from_line),y
                        	  2101: ;
                        	  2102: ;  check change was successful - if not, probably trying to change ROM
                        	  2103: ;
00:8FD9 D19E            	  2104:   cmp (from_line),y
00:8FDB D029            	  2105:   bne editor_poke_failed
00:8FDD E69E            	  2106:   inc from_line
00:8FDF D0EA            	  2107:   bne editor_poking_loop
00:8FE1 E69F            	  2108:   inc from_line+1
00:8FE3 80E6            	  2109:   bra editor_poking_loop
                        	  2110: 
00:8FE5 4661696C65642074	  2111: editor_poke_failed_message asciiz "Failed to change address $"
00:8FED 6F206368616E6765
00:8FF5 2061646472657373
00:8FFD 2024
00:8FFF 00
00:9000 20746F2024      	  2112: editor_poke_to_message     asciiz " to $"
00:9005 00
                        	  2113: 
                        	  2114: editor_poke_failed:
00:9006 A9E5            	  2115:   lda #<editor_poke_failed_message
00:9008 A28F            	  2116:   ldx #>editor_poke_failed_message
00:900A 202682          	  2117:   jsr print
00:900D A59F            	  2118:   lda from_line+1
00:900F 209A94          	  2119:   jsr PRBYTE
00:9012 A59E            	  2120:   lda from_line
00:9014 209A94          	  2121:   jsr PRBYTE
00:9017 A900            	  2122:   lda #<editor_poke_to_message
00:9019 A290            	  2123:   ldx #>editor_poke_to_message
00:901B 202682          	  2124:   jsr print
00:901E A594            	  2125:   lda token_value
00:9020 209A94          	  2126:   jsr PRBYTE
00:9023 202594          	  2127:   jsr CROUT
00:9026 4C7282          	  2128:   jmp main_prompt
                        	  2129: 
                        	  2130: ;--------------------------------------------
                        	  2131: ;  editor_jsr - jump to subroutine
                        	  2132: ;--------------------------------------------
                        	  2133: editor_jsr:
00:9029 209FCB          	  2134:   jsr get_token
00:902C C94E            	  2135:   cmp #TOKEN_NUMBER
00:902E F003            	  2136:   beq editor_jsr_got_number
00:9030 4C5885          	  2137:   jmp editor_bad_number
                        	  2138: ;
                        	  2139: ;  check in range 0x0000 to 0xFFFF
                        	  2140: ;
                        	  2141: editor_jsr_got_number:
00:9033 A596            	  2142:   lda token_value+2
00:9035 F003            	  2143:   beq editor_jsr_number_in_range
00:9037 4CFA85          	  2144:   jmp editor_line_number_too_big
                        	  2145: 
                        	  2146: editor_jsr_number_in_range:
00:903A 204086          	  2147:   jsr editor_check_no_more
00:903D A513            	  2148:   lda  call_p      ; status register
00:903F 48              	  2149:   pha
00:9040 A510            	  2150:   lda  call_a      ; A register
00:9042 A611            	  2151:   ldx  call_x      ; X register
00:9044 A412            	  2152:   ldy  call_y      ; Y register
00:9046 28              	  2153:   plp              ; get status register back
00:9047 205790          	  2154:   jsr  editor_jsr_got_number_execute  ; call the subroutine
00:904A 08              	  2155:   php              ; save the status register
00:904B 8510            	  2156:   sta  call_a      ; store the A/X/Y register
00:904D 8611            	  2157:   stx  call_x
00:904F 8412            	  2158:   sty  call_y
00:9051 68              	  2159:   pla              ; get status register back
00:9052 8513            	  2160:   sta  call_p      ; save it
00:9054 4C7282          	  2161:   jmp main_prompt
                        	  2162: 
00:9057 6C9400          	  2163: editor_jsr_got_number_execute  jmp  (token_value)
                        	  2164: 
                        	  2165: 
                        	  2166: ;--------------------------------------------
                        	  2167: ;  editor_jmp - jump to address
                        	  2168: ;--------------------------------------------
                        	  2169: editor_jmp:
00:905A 209FCB          	  2170:   jsr get_token
00:905D C94E            	  2171:   cmp #TOKEN_NUMBER
00:905F F003            	  2172:   beq editor_jmp_got_number
00:9061 4C5885          	  2173:   jmp editor_bad_number
                        	  2174: ;
                        	  2175: ;  check in range 0x0000 to 0xFFFF
                        	  2176: ;
                        	  2177: editor_jmp_got_number:
00:9064 A596            	  2178:   lda token_value+2
00:9066 F003            	  2179:   beq editor_jmp_number_in_range
00:9068 4CFA85          	  2180:   jmp editor_line_number_too_big
                        	  2181: 
                        	  2182: editor_jmp_number_in_range:
00:906B 204086          	  2183:   jsr editor_check_no_more
00:906E A513            	  2184:   lda  call_p      ; status register
00:9070 48              	  2185:   pha
00:9071 A510            	  2186:   lda  call_a      ; A register
00:9073 A611            	  2187:   ldx  call_x      ; X register
00:9075 A412            	  2188:   ldy  call_y      ; Y register
00:9077 28              	  2189:   plp              ; get status register back
00:9078 6C9400          	  2190:   jmp  (token_value)
                        	  2191: 
                        	  2192:   .if USE_ASSEMBLER
                        	  2193: ;--------------------------------------------
                        	  2194: ;  editor_library - list library symbols
                        	  2195: ;--------------------------------------------
                        	  2196: editor_library:
00:907B 209FCB          	  2197:   jsr get_token
00:907E F01E            	  2198:   beq editor_library_no_search
00:9080 C949            	  2199:   cmp #TOKEN_IDENTIFIER
00:9082 F003            	  2200:   beq editor_library_search
00:9084 4C5286          	  2201:   jmp editor_check_no_more_failed
                        	  2202: 
                        	  2203: editor_library_search:
00:9087 204086          	  2204:   jsr editor_check_no_more
                        	  2205: ;
                        	  2206: ;  put a null after the end of the search string
                        	  2207: ;
00:908A A492            	  2208:   ldy token_length
00:908C A900            	  2209:   lda #0
00:908E 9190            	  2210:   sta (token_address),Y
                        	  2211: ;
                        	  2212: ;  force match string to lower-case
                        	  2213: ;
00:9090 A000            	  2214:   ldy #0
                        	  2215: editor_library_make_lower_loop:
00:9092 B190            	  2216:   lda (token_address),Y
00:9094 F008            	  2217:   beq editor_library_no_search
00:9096 20CC91          	  2218:   jsr MAKE_LOWER
00:9099 9190            	  2219:   sta (token_address),Y
00:909B C8              	  2220:   iny
00:909C D0F4            	  2221:   bne editor_library_make_lower_loop
                        	  2222: 
                        	  2223: editor_library_no_search:
00:909E A938            	  2224:   lda #<assembler_library_functions_table
00:90A0 8500            	  2225:   sta REG
00:90A2 A9A8            	  2226:   lda #>assembler_library_functions_table
00:90A4 8501            	  2227:   sta REG+1
                        	  2228: editor_library_loop:
00:90A6 A000            	  2229:   ldy #0
00:90A8 B100            	  2230:   lda (REG),Y
00:90AA F058            	  2231:   beq editor_library_done   ; end of names
                        	  2232: 
                        	  2233: ;
                        	  2234: ;  filter out unwanted names
                        	  2235: ;
                        	  2236: 
00:90AC A593            	  2237:   lda token_type
00:90AE C949            	  2238:   cmp #TOKEN_IDENTIFIER
00:90B0 D018            	  2239:   bne editor_library_name_loop    ; no filter
00:90B2 A000            	  2240:   ldy #0
                        	  2241: editor_library_filter_loop:
00:90B4 B190            	  2242:   lda (token_address),Y
00:90B6 F010            	  2243:   beq edit_library_continue  ; end of search string, must have matched
00:90B8 D100            	  2244:   cmp (REG),y
00:90BA D003            	  2245:   bne editor_library_filter_reject  ; doesn't match, therefore discard it
00:90BC C8              	  2246:   iny
00:90BD 80F5            	  2247:   bra editor_library_filter_loop
                        	  2248: 
                        	  2249: editor_library_filter_reject:
00:90BF A000            	  2250:   ldy #0
                        	  2251: editor_library_filter_reject_loop:
00:90C1 C8              	  2252:   iny
00:90C2 B100            	  2253:   lda (REG),Y
00:90C4 D0FB            	  2254:   bne editor_library_filter_reject_loop
00:90C6 802B            	  2255:   bra editor_library_name_onto_next
                        	  2256: 
                        	  2257: edit_library_continue:
00:90C8 A000            	  2258:   ldy #0
                        	  2259: ;
                        	  2260: ;  find name length
                        	  2261: ;
                        	  2262: editor_library_name_loop
00:90CA C8              	  2263:   iny
00:90CB E692            	  2264:   inc token_length
00:90CD B100            	  2265:   lda (REG),Y
00:90CF D0F9            	  2266:   bne editor_library_name_loop
                        	  2267: 
00:90D1 C8              	  2268:   iny             ; get next byte
00:90D2 B100            	  2269:   lda (REG),Y     ; get function address low-byte
00:90D4 48              	  2270:   pha
00:90D5 C8              	  2271:   iny             ; get next byte
00:90D6 A924            	  2272:   lda #'$'
00:90D8 20B395          	  2273:   jsr COUT
00:90DB B100            	  2274:   lda (REG),Y     ; get function address high-byte
00:90DD 209A94          	  2275:   jsr PRBYTE      ; show high-order address byte
00:90E0 68              	  2276:   pla
00:90E1 209A94          	  2277:   jsr PRBYTE      ; show high-order address byte
00:90E4 20B094          	  2278:   jsr PUTSP
00:90E7 A500            	  2279:   lda REG
00:90E9 A601            	  2280:   ldx REG+1
00:90EB 88              	  2281:   dey             ; subtract 2, leaving the length of the name in Y
00:90EC 88              	  2282:   dey
00:90ED 20B494          	  2283:   jsr PT
00:90F0 202594          	  2284:   jsr CROUT
                        	  2285: 
                        	  2286: editor_library_name_onto_next:
00:90F3 C8              	  2287:   iny         ; add 2 to get past the address
00:90F4 C8              	  2288:   iny
00:90F5 C8              	  2289:   iny         ; get past that last 0x00  byte
00:90F6 98              	  2290:   tya         ; move REG onto next entry
00:90F7 18              	  2291:   clc
00:90F8 6500            	  2292:   adc REG
00:90FA 8500            	  2293:   sta REG
00:90FC A900            	  2294:   lda #0
00:90FE 6501            	  2295:   adc REG+1
00:9100 8501            	  2296:   sta REG+1
00:9102 80A2            	  2297:   bra editor_library_loop
                        	  2298: 
                        	  2299: editor_library_done:
00:9104 4C7282          	  2300:   jmp main_prompt
                        	  2301: 
                        	  2302:   .endif  ; USE_ASSEMBLER
                        	  2303: 
                        	  2304: ;16-bit number comparison...
                        	  2305: ;
                        	  2306: ;         lda #>x               ; MSB of 1st number
                        	  2307: ;         cmp #>y               ; MSB of 2nd number
                        	  2308: ;         bcc islower           ; X < Y
                        	  2309: ;
                        	  2310: ;         bne ishigher          ; X > Y
                        	  2311: ;
                        	  2312: ;         lda #<x               ; LSB of 1st number
                        	  2313: ;         cmp #<y               ; LSB of 2nd number
                        	  2314: ;         bcc islower           ; X < Y
                        	  2315: ;
                        	  2316: ;         beq issame            ; X = Y
                        	  2317: ;
                        	  2318: ;         bne ishigher          ; X > Y
                        	  2319: ;
                        	  2320: ;
                        	  2321: 

Source: "gpascal.asm"
                        	   183:   .include "utilities.inc"

Source: "utilities.inc"
                        	     1: ;
                        	     2: ;  function to look up a handler for a word (eg. assembler directive)
                        	     3: ;
                        	     4: ;  word in SRCE
                        	     5: ;
                        	     6: ;  table of words/handlers in DEST
                        	     7: ;
                        	     8: ;  length of word in A
                        	     9: ;
                        	    10: ;  see makeHandler for making the table
                        	    11: ;
                        	    12: ;  Basically:
                        	    13: ;    asciiz "foo"
                        	    14: ;    word   foo_handler
                        	    15: ;
                        	    16: ;  In other words:
                        	    17: ;    makeHandler "foo",foo_handler
                        	    18: ;
                        	    19: ;  Returns with carry set if no match, otherwise calls the handler which should clear carry
                        	    20: ;
                        	    21: 
                        	    22: handlerLookup:
00:9107 8598            	    23:   sta token_work    ; save length
                        	    24: 
                        	    25: ;
                        	    26: ;  find the length of the word
                        	    27: ;
                        	    28: handler_loop:
00:9109 A000            	    29:   ldy #0
00:910B B103            	    30:   lda (DEST),y
00:910D F036            	    31:   beq handlers_done
                        	    32: handler_find_length:
00:910F B103            	    33:   lda (DEST),y
00:9111 F005            	    34:   beq handler_found_length
00:9113 C8              	    35:   iny
00:9114 F02F            	    36:   beq handlers_done   ; sanity clause
00:9116 80F7            	    37:   bra handler_find_length
                        	    38: handler_found_length:
                        	    39: 
                        	    40: ;  lda #'i'
                        	    41: ;  jsr ass_debug_point
                        	    42: 
00:9118 C498            	    43:   cpy token_work
00:911A F010            	    44:   beq handler_same_length
                        	    45: ;
                        	    46: ;  not the same length, or no match on the string
                        	    47: ;
                        	    48: handler_next:
00:911C 98              	    49:   tya
00:911D 18              	    50:   clc
00:911E 6903            	    51:   adc #3  ; skip the 0x00 and the execution address
00:9120 6503            	    52:   adc DEST
00:9122 8503            	    53:   sta DEST
00:9124 A504            	    54:   lda DEST+1
00:9126 6900            	    55:   adc #0
00:9128 8504            	    56:   sta DEST+1
00:912A 80DD            	    57:   bra handler_loop
                        	    58: 
                        	    59: handler_same_length:
                        	    60: 
                        	    61: ;  lda #'j'
                        	    62: ;  jsr ass_debug_point
                        	    63: 
00:912C 5A              	    64:   phy  ; save the length
00:912D 202A94          	    65:   jsr COMSTL
00:9130 F003            	    66:   beq  handler_found_directive
00:9132 7A              	    67:   ply
00:9133 80E7            	    68:   bra handler_next
                        	    69: handler_found_directive:
00:9135 7A              	    70:   ply  ; get the length back
00:9136 C8              	    71:   iny  ; skip past the 0x00 byte
00:9137 B103            	    72:   lda (DEST),y
00:9139 8599            	    73:   sta token_work+1
00:913B C8              	    74:   iny
00:913C B103            	    75:   lda (DEST),y
00:913E 859A            	    76:   sta token_work+2
00:9140 204791          	    77:   jsr call_handler
00:9143 18              	    78:   clc
00:9144 60              	    79:   rts
                        	    80: 
                        	    81: handlers_done:
                        	    82: ;  lda #'h'
                        	    83: ;  jsr ass_debug_point
00:9145 38              	    84:   sec     ; error flag
00:9146 60              	    85:   rts
                        	    86: 
                        	    87: call_handler:
                        	    88: ;  lda #'g'
                        	    89: ;  jsr ass_debug_point
                        	    90: 
00:9147 6C9900          	    91:   jmp (token_work+1)   ; do handler - it will RTS for us
                        	    92: 
                        	    93: 
                        	    94: ;
                        	    95: ;  function to look up a handler for a word on a partial match (eg. editor command)
                        	    96: ;
                        	    97: ;  word in SRCE
                        	    98: ;
                        	    99: ;  table of words/handlers in DEST - in UPPER CASE
                        	   100: ;
                        	   101: ;  length of word in A
                        	   102: ;
                        	   103: ;  see makeHandler for making the table
                        	   104: ;
                        	   105: ;  Basically:
                        	   106: ;    asciiz "FOO"
                        	   107: ;    word   foo_handler
                        	   108: ;
                        	   109: ;  In other words:
                        	   110: ;    makeHandler "FOO",foo_handler
                        	   111: ;
                        	   112: ;  Returns if no match, otherwise jumps to the handler and thus doesn't return
                        	   113: ;
                        	   114: 
                        	   115: partial_handler_Lookup:
00:914A 8598            	   116:   sta token_work    ; save length
                        	   117: ;
                        	   118: ;  here for a new table item
                        	   119: ;
                        	   120: partial_handler_next_item:
00:914C A000            	   121:   ldy #0
00:914E B103            	   122:   lda (DEST),y
00:9150 F03C            	   123:   beq partial_handler_done
00:9152 A698            	   124:   ldx token_work        ; source length
                        	   125: partial_handler_next_loop:
                        	   126: ;
                        	   127: ;  ensure the nth character matches until the source runs out
                        	   128: ;
00:9154 B100            	   129:   lda (SRCE),y
00:9156 20C191          	   130:   jsr MAKE_UPPER
00:9159 D103            	   131:   cmp (DEST),y
00:915B D006            	   132:   bne partial_handler_next
00:915D C8              	   133:   iny
00:915E CA              	   134:   dex     ; one less count
00:915F F019            	   135:   beq partial_handler_found_directive ; source has finished and we found the directive
00:9161 80F1            	   136:   bra partial_handler_next_loop       ; try matching the next one
                        	   137: ;
                        	   138: ;  no match on the string - advance Y to the end of the destination string
                        	   139: ;
                        	   140: partial_handler_next:
00:9163 B103            	   141:   lda (DEST),y
00:9165 F003            	   142:   beq partial_handler_next_found_item_length
00:9167 C8              	   143:   iny
00:9168 80F9            	   144:   bra partial_handler_next
                        	   145: partial_handler_next_found_item_length:
00:916A 98              	   146:   tya     ; length of the word in the table
00:916B 18              	   147:   clc
00:916C 6903            	   148:   adc #3  ; skip the 0x00 and the execution address
00:916E 6503            	   149:   adc DEST
00:9170 8503            	   150:   sta DEST
00:9172 A504            	   151:   lda DEST+1
00:9174 6900            	   152:   adc #0
00:9176 8504            	   153:   sta DEST+1
00:9178 80D2            	   154:   bra partial_handler_next_item
                        	   155: 
                        	   156: partial_handler_found_directive:
00:917A B103            	   157:   lda (DEST),y
00:917C F003            	   158:   beq partial_handler_skipped_string
00:917E C8              	   159:   iny
00:917F 80F9            	   160:   bra partial_handler_found_directive
                        	   161: partial_handler_skipped_string:
00:9181 C8              	   162:   iny  ; skip past the 0x00 byte
00:9182 B103            	   163:   lda (DEST),y
00:9184 8599            	   164:   sta token_work+1
00:9186 C8              	   165:   iny
00:9187 B103            	   166:   lda (DEST),y
00:9189 859A            	   167:   sta token_work+2
00:918B 6C9900          	   168:   jmp (token_work+1)   ; do partial_partial_handler_ - it will RTS for us
                        	   169: 
                        	   170: partial_handler_done:
00:918E 60              	   171:   rts
                        	   172: 
                        	   173: ;***********************************************
                        	   174: ; JUMP ON TOKEN
                        	   175: ; X/Y = START OF TABLE
                        	   176: ; END OF TABLE IS A NULL
                        	   177: ; A = TOKEN
                        	   178: ;***********************************************
                        	   179: TKNJMP   =  *
00:918F 8600            	   180:          stx  REG     ; save table address
00:9191 8401            	   181:          sty  REG+1
                        	   182: 
00:9193 20C191          	   183:          jsr MAKE_UPPER
00:9196 AA              	   184:          tax          ; save the token
                        	   185: JMP1     =  *
00:9197 A000            	   186:          ldy  #0
00:9199 B100            	   187:          lda  (REG),Y
00:919B D002            	   188:          bne  JMP2
                        	   189: ; failed to find the token
00:919D 8A              	   190:          txa          ; retore the token
00:919E 60              	   191:          rts
                        	   192: JMP2     =  *
00:919F 8A              	   193:          txa          ; get token back
00:91A0 D100            	   194:          cmp  (REG),Y
00:91A2 D010            	   195:          bne  JMP3    ; branch if not found
00:91A4 68              	   196:          pla
00:91A5 68              	   197:          pla          ; remove return address for TKNJMP call
00:91A6 C8              	   198:          iny          ; move Y on to routine address
00:91A7 B100            	   199:          lda  (REG),Y ; get low order byte of routine
00:91A9 8503            	   200:          sta  REG2
00:91AB C8              	   201:          iny          ; next byte
00:91AC B100            	   202:          lda  (REG),Y ; get high order byte
00:91AE 8504            	   203:          sta  REG2+1
00:91B0 8A              	   204:          txa          ; get token back
00:91B1 6C0300          	   205:          jmp  (REG2)  ; go to routine
                        	   206: JMP3     =  *
00:91B4 A500            	   207:          lda  REG     ; skip this token sequence
00:91B6 18              	   208:          clc
00:91B7 6903            	   209:          adc  #3
00:91B9 8500            	   210:          sta  REG
00:91BB 90DA            	   211:          bcc  JMP1
00:91BD E601            	   212:          inc  REG+1
00:91BF 80D6            	   213:          bra  JMP1    ; try again
                        	   214: 
                        	   215: ;
                        	   216: 
                        	   217: 
                        	   218: ;***********************************************
                        	   219: ;
                        	   220: ; Case conversion
                        	   221: ;
                        	   222: ;***********************************************
                        	   223: 
                        	   224: 
                        	   225: MAKE_UPPER = *
00:91C1 C97B            	   226:          CMP  #('z'+1)
00:91C3 B006            	   227:          BCS  MAKE_UPPER_DONE
00:91C5 C961            	   228:          CMP  #'a'
00:91C7 9002            	   229:          BCC  MAKE_UPPER_DONE
00:91C9 E920            	   230:          SBC  #$20  ; make upper-case - we want carry set so there is no borrow
                        	   231: MAKE_UPPER_DONE = *
00:91CB 60              	   232:          RTS
                        	   233: 
                        	   234: MAKE_LOWER = *
00:91CC C941            	   235:          CMP  #'A'
00:91CE 9006            	   236:          BCC  MAKE_LOWER_DONE
00:91D0 C95B            	   237:          CMP  #('Z'+1)
00:91D2 B002            	   238:          BCS  MAKE_LOWER_DONE
00:91D4 6920            	   239:          ADC  #$20  ; make upper-case - we want carry clear so there is no carry
                        	   240: MAKE_LOWER_DONE = *
00:91D6 60              	   241:          RTS
                        	   242: 
                        	   243: 
                        	   244: ;
                        	   245: ;  generate the next random number
                        	   246: ;
                        	   247: gen_random:
00:91D7 0609            	   248:     asl random
00:91D9 260A            	   249:     rol random+1
00:91DB 260B            	   250:     rol random+2
00:91DD 260C            	   251:     rol random+3
00:91DF 9018            	   252:     bcc gen_random1
00:91E1 A509            	   253:     lda random
00:91E3 49B7            	   254:     eor #$B7
00:91E5 8509            	   255:     sta random
00:91E7 A50A            	   256:     lda random+1
00:91E9 491D            	   257:     eor #$1D
00:91EB 850A            	   258:     sta random+1
00:91ED A50B            	   259:     lda random+2
00:91EF 49C1            	   260:     eor #$C1
00:91F1 850B            	   261:     sta random+2
00:91F3 A50C            	   262:     lda random+3
00:91F5 4904            	   263:     eor #$04
00:91F7 850C            	   264:     sta random+3
                        	   265: gen_random1:
00:91F9 60              	   266:     rts
                        	   267: 
                        	   268: 
                        	   269: 
                        	   270: ;
                        	   271: ;  From: http://www.6502.org/source/integers/crc-more.html
                        	   272: ;
                        	   273: ;   jacksum  -a crc:16,1021,FFFF,false,false,0 -X SOME_FILE
                        	   274: ;
                        	   275: ;   https://jacksum.net/en/index.html
                        	   276: ;
                        	   277: ;   With a starting CRC of $FFFF, the binary string $01 $02 $03 $04 should evaluate to $89C3.
                        	   278: ;
                        	   279: ;   Start at crc_addr, for crc_num bytes
                        	   280: ;
                        	   281: crc16 = *
                        	   282: ;
                        	   283: ;  initialise CRC
                        	   284: ;
00:91FA A9FF            	   285:   lda #$FF
00:91FC 8506            	   286:   sta crc_val
00:91FE 8507            	   287:   sta crc_val+1
00:9200 A503            	   288:   lda crc_num
00:9202 0504            	   289:   ora crc_num+1
00:9204 F01B            	   290:   beq crc_done
                        	   291: 
                        	   292: ;
                        	   293: ;  here for each byte
                        	   294: ;
                        	   295: crc16_loop  = *
00:9206 A000            	   296:   ldy #0
00:9208 B100            	   297:   lda (crc_addr),y  ; get next byte
00:920A 202292          	   298:   jsr crc_byte
                        	   299:   ;
                        	   300:   ;  onto next address
                        	   301:   ;
00:920D E600            	   302:   inc crc_addr
00:920F D002            	   303:   bne crc16_next
00:9211 E601            	   304:   inc crc_addr+1       ; Step to next byte
                        	   305: crc16_next:
                        	   306:   ;
                        	   307:   ; now do a 16-bit decrement
                        	   308:   ;
00:9213 A503            	   309:   LDA crc_num
00:9215 D002            	   310:   BNE crc16_skip    ; decrement the high-order byte if we are about to wrap
00:9217 C604            	   311:   DEC crc_num+1
                        	   312: crc16_skip:
00:9219 C603            	   313:   DEC crc_num       ; decrement the low-order byte
00:921B D0E9            	   314:   BNE crc16_loop    ; not zero, keep going
00:921D A504            	   315:   LDA crc_num+1     ; are we zero here too?
00:921F D0E5            	   316:   BNE crc16_loop    ; not yet
                        	   317: 
                        	   318: crc_done:
00:9221 60              	   319:   rts
                        	   320: 
                        	   321: ;
                        	   322: ;  do a CRC of one byte (in A) updating crc_val
                        	   323: ;
                        	   324: crc_byte = *
00:9222 4507            	   325:   eor crc_val+1     ; A contained the data
00:9224 8507            	   326:   sta crc_val+1     ; XOR it into high byte
00:9226 4A              	   327:   lsr               ; right shift A 4 bits
00:9227 4A              	   328:   lsr               ; to make top of x^12 term
00:9228 4A              	   329:   lsr               ; ($1...)
00:9229 4A              	   330:   lsr
00:922A AA              	   331:   tax               ; save it
00:922B 0A              	   332:   asl               ; then make top of x^5 term
00:922C 4506            	   333:   eor crc_val       ; and XOR that with low byte
00:922E 8506            	   334:   sta crc_val       ; and save
00:9230 8A              	   335:   txa               ; restore partial term
00:9231 4507            	   336:   eor crc_val+1     ; and update high byte
00:9233 8507            	   337:   sta crc_val+1     ; and save
00:9235 0A              	   338:   asl               ; left shift three
00:9236 0A              	   339:   asl               ; the rest of the terms
00:9237 0A              	   340:   asl               ; have feedback from x^12
00:9238 AA              	   341:   tax               ; save bottom of x^12
00:9239 0A              	   342:   asl               ; left shift two more
00:923A 0A              	   343:   asl               ; watch the carry flag
00:923B 4507            	   344:   eor crc_val+1     ; bottom of x^5 ($..2.)
00:923D A8              	   345:   tay               ; save high byte
00:923E 8A              	   346:   txa               ; fetch temp value
00:923F 2A              	   347:   rol               ; bottom of x^12, middle of x^5!
00:9240 4506            	   348:   eor crc_val       ; finally update low byte
00:9242 8507            	   349:   sta crc_val+1     ; then swap high and low bytes
00:9244 8406            	   350:   sty crc_val
00:9246 60              	   351:   rts
                        	   352: 
                        	   353: 
                        	   354: crc_helper = *
00:9247 5A              	   355:   phy
00:9248 DA              	   356:   phx
00:9249 202292          	   357:   jsr crc_byte
00:924C E603            	   358:   inc crc_num
00:924E D002            	   359:   bne crc_helper1
00:9250 E604            	   360:   inc crc_num+1
                        	   361: crc_helper1:
00:9252 FA              	   362:   plx
00:9253 7A              	   363:   ply
00:9254 60              	   364:   rts
                        	   365: 
00:9255 536F757263652043	   366: crc_message asciiz "Source CRC       $"               ; source CRC
00:925D 5243202020202020
00:9265 2024
00:9267 00
00:9268 536F75726365206C	   367: source_length_message asciiz "Source length: "    ; source length
00:9270 656E6774683A20
00:9277 00
00:9278 2062797465730A  	   368: bytes_message asciiz " bytes\n"
00:927F 00
                        	   369: 
                        	   370: crc_source = *
00:9280 20B98C          	   371:   jsr find_source_end
                        	   372: 
                        	   373: ;
                        	   374: ;  move existing source to end of RAM
                        	   375: ;
00:9283 18              	   376:   clc             ; don't count the final 0x00 byte
00:9284 A523            	   377:   lda PCODE
00:9286 E900            	   378:   sbc #<TEXT_START
00:9288 8503            	   379:   sta crc_num
00:928A A524            	   380:   lda PCODE+1
00:928C E903            	   381:   sbc #>TEXT_START
00:928E 8504            	   382:   sta crc_num+1
                        	   383: ;
                        	   384: ;  Show the length of the source
                        	   385: ;
00:9290 A968            	   386:   lda #<source_length_message
00:9292 A292            	   387:   ldx #>source_length_message
00:9294 202682          	   388:   jsr print
00:9297 A503            	   389:   lda crc_num
00:9299 8500            	   390:   sta REG
00:929B A504            	   391:   lda crc_num+1
00:929D 8501            	   392:   sta REG+1
00:929F 6402            	   393:   stz REGB
00:92A1 204F93          	   394:   jsr display_in_decimal
00:92A4 A978            	   395:   lda #<bytes_message
00:92A6 A292            	   396:   ldx #>bytes_message
00:92A8 202682          	   397:   jsr print
                        	   398: 
                        	   399: ;
                        	   400: ;  now the CRC
                        	   401: ;
00:92AB A900            	   402:   lda #<TEXT_START
00:92AD 8500            	   403:   sta crc_addr
00:92AF A903            	   404:   lda #>TEXT_START
00:92B1 8501            	   405:   sta crc_addr+1
00:92B3 20FA91          	   406:   jsr crc16
00:92B6 A955            	   407:   lda  #<crc_message            ;  source CRC
00:92B8 A292            	   408:   ldx  #>crc_message            ;
00:92BA 202682          	   409:   jsr  print
00:92BD A507            	   410:   lda crc_val+1
00:92BF 209A94          	   411:   jsr PRBYTE
00:92C2 A506            	   412:   lda crc_val
00:92C4 204F95          	   413:   jsr PRBYTECR
00:92C7 60              	   414:   rts
                        	   415: 
                        	   416: 
                        	   417: ;
                        	   418: ;  delays for roughly 1 ms - changes no registers
                        	   419: ;
                        	   420: delay_1ms = *
00:92C8 DA              	   421:          phx
00:92C9 A26C            	   422:          ldx #108
                        	   423: delay_1ms_loop:
00:92CB EA              	   424:          nop
00:92CC EA              	   425:          nop
00:92CD CA              	   426:          dex
00:92CE D0FB            	   427:          bne delay_1ms_loop
00:92D0 FA              	   428:          plx
00:92D1 60              	   429:          rts
                        	   430: 
                        	   431: ;
                        	   432: ; delay for YYXX ms (Y = high-order byte, X = lo-order byte)
                        	   433: ;  maximum delay 0x7FFF, that is 32767 ms
                        	   434: ;  Changes X and Y
                        	   435: ;
                        	   436: delay = *
00:92D2 20C892          	   437:   jsr delay_1ms
00:92D5 CA              	   438:   dex
00:92D6 D0FA            	   439:   bne delay
00:92D8 88              	   440:   dey
00:92D9 10F7            	   441:   bpl delay
00:92DB 60              	   442:   rts
                        	   443: 
                        	   444: 
                        	   445: ;--------------------------------------------------------------------------
                        	   446: ;
                        	   447: ;  BINARY TO DECIMAL CONVERSION
                        	   448: ;
                        	   449: ;  This works as follows:
                        	   450: ;
                        	   451: ;  1. First the number is checked if it is negative (sign bit set).
                        	   452: ;  2. If so, a "-" is output and the number subtracted from zero to make it positive.
                        	   453: ;  3. Our next step is to set a BCD (binary coded decimal) output area to all zeroes.
                        	   454: ;      In BCD, the number 1234 is actually stored as 0x1234.
                        	   455: ;      With BCD mode turned on in the processor, doing adds results in an early carry
                        	   456: ;      so that numbers add "the decimal way" rather than the binary way.
                        	   457: ;  4. Then we a loop of 24 iterations (one for each bit) which adds the appropriate number from bcd_table
                        	   458: ;      if that bit was set in the original value.
                        	   459: ;  5. The function bcd_unpack is then called to convert the BCD format into ASCII format. It takes each
                        	   460: ;     nibble and adds 0x30 ('0') to it, and saves that in bcd_result.
                        	   461: ;  6. At this stage bcd_result has a 8-digit ASCII number in it.
                        	   462: ;  7. We then skip leading zeroes in bcd_result.
                        	   463: ;  8. Finally the remaining digits in bcd_result are output.
                        	   464: ;
                        	   465: ;
                        	   466: ;   I'm not sure where the idea for this came from. There was no Internet when this was written in 1979
                        	   467: ;   so it is possibly (probably) my own.
                        	   468: ;   My original implementation, although similar, was more complex than this one, which I found at:
                        	   469: ;              http://www.6502.org/source/integers/hex2dec.htm
                        	   470: ;
                        	   471: ;   Other suggestions for binary to decimal conversion I found recently do not employ this method. One
                        	   472: ;   technique (as described by Ben Eater here: https://www.youtube.com/watch?v=v3-a-zqKfgA ) is to
                        	   473: ;   repeatedly divide by 10 and use the remainder as the digit. This has to be done until the result of
                        	   474: ;   the division is zero. Dividing a 3-byte number by 10 on an 8-bit machine is not particularly fast,
                        	   475: ;   as it involves an inner loop of 24 iterations (one for each bit) and this would have to be done for
                        	   476: ;   each digit, so the number of loops of 24 iterations would increase for each digit. Therefore an
                        	   477: ;   8-digit number (like 80000000) would take 144 iterations in the divide loop. Then the digits have to
                        	   478: ;   be reversed because the remainder gives you the low-order decimal digit first.
                        	   479: ;
                        	   480: ;   Another technique is the "Double dabble" routine.
                        	   481: ;
                        	   482: ;     https://en.wikipedia.org/wiki/Double_dabble
                        	   483: ;
                        	   484: ;   The method below seems fairly efficient, as the inner loop only does anything substantial if a
                        	   485: ;     1-bit is detected. Thus large numbers can be produced quite efficiently, however it would be a
                        	   486: ;     bit slower if the input number had a lot of 1-bits set.
                        	   487: ;
                        	   488: ;   Considering that this is only used when outputting to serial, itself a slow process, speed is not
                        	   489: ;   really the issue here.
                        	   490: ;
                        	   491: ;   - Nick Gammon
                        	   492: ;
                        	   493: ;
                        	   494: ;--------------------------------------------------------------------------
                        	   495: ;
                        	   496: ; Converts BCD to ASCII
                        	   497: ;
                        	   498: bcd_unpack:
00:92DC 48              	   499:   pha  ; save the number for later
                        	   500: ;
                        	   501: ;  shift right 4 bits
                        	   502: ;
00:92DD 4A              	   503:   lsr A
00:92DE 4A              	   504:   lsr A
00:92DF 4A              	   505:   lsr A
00:92E0 4A              	   506:   lsr A
00:92E1 0930            	   507:   ora #'0'          ; make printable
00:92E3 9560            	   508:   sta bcd_result,X  ; save in bcd_result
00:92E5 E8              	   509:   inx
00:92E6 68              	   510:   pla               ; get the original character back
00:92E7 290F            	   511:   and #$0F          ; take low-order bits and make printable
00:92E9 0930            	   512:   ora #'0'
00:92EB 9560            	   513:   sta bcd_result,X  ; save in bcd_result
00:92ED E8              	   514:   inx
00:92EE 60              	   515:   rts               ; done!
                        	   516: 
                        	   517: ;
                        	   518: ;
                        	   519: ; Table for adding into the BCD result.
                        	   520: ;
                        	   521: bcd_table  =  *
00:92EF 00              	   522:   dfb $00,$00,$00,$01   ; 0000001
00:92F0 00
00:92F1 00
00:92F2 01
00:92F3 00              	   523:   dfb $00,$00,$00,$02   ; 0000002
00:92F4 00
00:92F5 00
00:92F6 02
00:92F7 00              	   524:   dfb $00,$00,$00,$04   ; 0000004
00:92F8 00
00:92F9 00
00:92FA 04
00:92FB 00              	   525:   dfb $00,$00,$00,$08   ; 0000008
00:92FC 00
00:92FD 00
00:92FE 08
00:92FF 00              	   526:   dfb $00,$00,$00,$16   ; 0000016
00:9300 00
00:9301 00
00:9302 16
00:9303 00              	   527:   dfb $00,$00,$00,$32   ; 0000032
00:9304 00
00:9305 00
00:9306 32
00:9307 00              	   528:   dfb $00,$00,$00,$64   ; 0000064
00:9308 00
00:9309 00
00:930A 64
00:930B 00              	   529:   dfb $00,$00,$01,$28   ; 0000128
00:930C 00
00:930D 01
00:930E 28
00:930F 00              	   530:   dfb $00,$00,$02,$56   ; 0000256
00:9310 00
00:9311 02
00:9312 56
00:9313 00              	   531:   dfb $00,$00,$05,$12   ; 0000512
00:9314 00
00:9315 05
00:9316 12
00:9317 00              	   532:   dfb $00,$00,$10,$24   ; 0001024
00:9318 00
00:9319 10
00:931A 24
00:931B 00              	   533:   dfb $00,$00,$20,$48   ; 0002048
00:931C 00
00:931D 20
00:931E 48
00:931F 00              	   534:   dfb $00,$00,$40,$96   ; 0004096
00:9320 00
00:9321 40
00:9322 96
00:9323 00              	   535:   dfb $00,$00,$81,$92   ; 0008192
00:9324 00
00:9325 81
00:9326 92
00:9327 00              	   536:   dfb $00,$01,$63,$84   ; 0016384
00:9328 01
00:9329 63
00:932A 84
00:932B 00              	   537:   dfb $00,$03,$27,$68   ; 0032768
00:932C 03
00:932D 27
00:932E 68
00:932F 00              	   538:   dfb $00,$06,$55,$36   ; 0065536
00:9330 06
00:9331 55
00:9332 36
00:9333 00              	   539:   dfb $00,$13,$10,$72   ; 0131072
00:9334 13
00:9335 10
00:9336 72
00:9337 00              	   540:   dfb $00,$26,$21,$44   ; 0262144
00:9338 26
00:9339 21
00:933A 44
00:933B 00              	   541:   dfb $00,$52,$42,$88   ; 0524288
00:933C 52
00:933D 42
00:933E 88
00:933F 01              	   542:   dfb $01,$04,$85,$76   ; 1048576
00:9340 04
00:9341 85
00:9342 76
00:9343 02              	   543:   dfb $02,$09,$71,$52   ; 2097152
00:9344 09
00:9345 71
00:9346 52
00:9347 04              	   544:   dfb $04,$19,$43,$04   ; 4194304
00:9348 19
00:9349 43
00:934A 04
00:934B 08              	   545:   dfb $08,$38,$86,$08   ; 8388608
00:934C 38
00:934D 86
00:934E 08
                        	   546: 
                        	   547: ;--------------------------------------------------------------------------
                        	   548: ; display_in_decimal - start here - VALUE will be zero after this is executed
                        	   549: ;--------------------------------------------------------------------------
                        	   550: 
                        	   551: display_in_decimal  =  *
00:934F A502            	   552:   lda  VALUE+2
00:9351 1008            	   553:   bpl  bcd_positive
                        	   554: ;
                        	   555: ;  if the number is negative, output a minus sign and make it positive
                        	   556: ;
00:9353 A92D            	   557:   lda  #'-'
00:9355 20B395          	   558:   jsr  COUT
00:9358 2090AE          	   559:   jsr  exp_unary_minus
                        	   560: ;
                        	   561: ;  number is now positive
                        	   562: ;
                        	   563: bcd_positive:
                        	   564: 
00:935B 207893          	   565:   jsr binary_to_decimal   ; do the conversion
                        	   566: 
00:935E A207            	   567:   ldx  #7         ; zero suppress count (always keep the last zero)
00:9360 A000            	   568:   ldy  #0
                        	   569: ;
                        	   570: ;  this is skipping the leading zeroes
                        	   571: ;
                        	   572: bcd_skip_zeroes:
00:9362 B96000          	   573:   lda  bcd_result,Y
00:9365 C930            	   574:   cmp  #'0'
00:9367 D004            	   575:   bne  bcd_output_digit
00:9369 C8              	   576:   iny
00:936A CA              	   577:   dex
00:936B D0F5            	   578:   bne  bcd_skip_zeroes
                        	   579: ;
                        	   580: ;  now we have a non-zero, start outputting them
                        	   581: ;
                        	   582: ;  Y points to how far we are through bcd_result
                        	   583: ;  X is how many digits to go
                        	   584: ;
                        	   585: bcd_output_digit:
00:936D B96000          	   586:   lda  bcd_result,Y
00:9370 20B395          	   587:   jsr  COUT
00:9373 C8              	   588:   iny
00:9374 CA              	   589:   dex
00:9375 10F6            	   590:   bpl  bcd_output_digit
                        	   591: ;
                        	   592: ;  done!
                        	   593: ;
00:9377 60              	   594:   rts
                        	   595: 
                        	   596: ;--------------------------------------------------------------------------
                        	   597: ;
                        	   598: ;  Binary to decimal routine: Converts VALUE into bcd_result (8 digits)
                        	   599: ;
                        	   600: ;  See: http://www.6502.org/source/integers/hex2dec.htm
                        	   601: ;
                        	   602: ;  - VALUE will be zero after this is executed
                        	   603: ;
                        	   604: ;--------------------------------------------------------------------------
                        	   605: binary_to_decimal:
00:9378 F8              	   606:   sed                 ; decimal mode for adds below
00:9379 645C            	   607:   stz  bcd_work       ; zero our result area (4 bytes = 8 digits)
00:937B 645D            	   608:   stz  bcd_work+1
00:937D 645E            	   609:   stz  bcd_work+2
00:937F 645F            	   610:   stz  bcd_work+3
                        	   611: 
00:9381 A25C            	   612:   ldx  #(4*23)        ; X points to the start of the highest entry
                        	   613: 
                        	   614: binary_to_decimal_loop:
00:9383 0600            	   615:   asl VALUE      ;  shift out high-order bit into Carry
00:9385 2601            	   616:   rol VALUE+1
00:9387 2602            	   617:   rol VALUE+2
00:9389 901D            	   618:   bcc binary_to_decimal_next  ; if carry clear, no add needs to be done
                        	   619: ;
                        	   620: ;  that bit was set, so add the appropriate BCD number from the table (eg. 1, 2, 4, 8, 16 and so on)
                        	   621: ;
00:938B 18              	   622:   clc
00:938C A55C            	   623:   lda bcd_work
00:938E 7DF292          	   624:   adc bcd_table+3,X
00:9391 855C            	   625:   sta bcd_work
00:9393 A55D            	   626:   lda bcd_work+1
00:9395 7DF192          	   627:   adc bcd_table+2,X
00:9398 855D            	   628:   sta bcd_work+1
00:939A A55E            	   629:   lda bcd_work+2
00:939C 7DF092          	   630:   adc bcd_table+1,X
00:939F 855E            	   631:   sta bcd_work+2
00:93A1 A55F            	   632:   lda bcd_work+3
00:93A3 7DEF92          	   633:   adc bcd_table,X
00:93A6 855F            	   634:   sta bcd_work+3
                        	   635: 
                        	   636: binary_to_decimal_next:
00:93A8 CA              	   637:   dex      ; back to the previous table item
00:93A9 CA              	   638:   dex
00:93AA CA              	   639:   dex
00:93AB CA              	   640:   dex
00:93AC 10D5            	   641:   bpl binary_to_decimal_loop
00:93AE D8              	   642:   cld     ; decimal mode off
                        	   643: 
                        	   644: 
                        	   645: ;
                        	   646: ;  convert BCD to ASCII - note that UNPACK increments x by two each time
                        	   647: ;    - the results are in bcd_result - an 8-character field
                        	   648: ;
                        	   649: ;  We unpack the high-order bytes first, naturally
                        	   650: ;
00:93AF A200            	   651:   ldx  #0
00:93B1 A55F            	   652:   lda  bcd_work+3
00:93B3 20DC92          	   653:   jsr  bcd_unpack
00:93B6 A55E            	   654:   lda  bcd_work+2
00:93B8 20DC92          	   655:   jsr  bcd_unpack
00:93BB A55D            	   656:   lda  bcd_work+1
00:93BD 20DC92          	   657:   jsr  bcd_unpack
00:93C0 A55C            	   658:   lda  bcd_work
00:93C2 20DC92          	   659:   jsr  bcd_unpack
00:93C5 60              	   660:   rts
                        	   661: 
00:93C6 4E6F20736F757263	   662: NOSCE    asciiz  'No source file.\n'   ; No source file
00:93CE 652066696C652E0A
00:93D6 00
                        	   663: 
                        	   664: ;***********************************************
                        	   665: ;
                        	   666: ; Initialize a compile or assembly
                        	   667: ;
                        	   668: ;***********************************************
                        	   669: 
                        	   670: 
                        	   671: INIT     =  *
                        	   672: ;
                        	   673: ;  set up symbol table pointer
                        	   674: ;
                        	   675: 
00:93D7 A93F            	   676:   lda  #>SYMBOL_TABLE_START
00:93D9 8532            	   677:   sta  ENDSYM+1
00:93DB 8530            	   678:   sta  STARTSYM+1
00:93DD A9FF            	   679:   lda  #<SYMBOL_TABLE_START
00:93DF 8531            	   680:   sta  ENDSYM
00:93E1 852F            	   681:   sta  STARTSYM
                        	   682: 
                        	   683: INIT_SECOND_PASS:   ; for assembler
                        	   684: 
00:93E3 A900            	   685:   lda  #0
00:93E5 851D            	   686:   sta  LIST            ; not listing
00:93E7 8522            	   687:   sta  LEVEL           ; variable level zero
00:93E9 852E            	   688:   sta  DCODE
00:93EB 853F            	   689:   sta  RUNNING         ; not running
00:93ED 8539            	   690:   sta  PRCITM
00:93EF 853A            	   691:   sta  PRCITM+1
00:93F1 8502            	   692:   sta  REGB
00:93F3 8593            	   693:   sta  token_type
00:93F5 64BE            	   694:   stz  system_flags
00:93F7 A901            	   695:   lda #1
00:93F9 85A2            	   696:   sta  current_line        ; we are currently on line 1
00:93FB 64A3            	   697:   stz  current_line+1
                        	   698: 
                        	   699: ;
                        	   700: ;  set up for reading first byte of source
                        	   701: ;
00:93FD A900            	   702:   lda  #<TEXT_START
00:93FF 858E            	   703:   sta  token_start
00:9401 859C            	   704:   sta  token_line_start
00:9403 A903            	   705:   lda  #>TEXT_START
00:9405 858F            	   706:   sta  token_start+1
00:9407 859D            	   707:   sta  token_line_start+1
00:9409 20B98C          	   708:   jsr  find_source_end
00:940C A523            	   709:   lda  PCODE
00:940E 8525            	   710:   sta  ACT_PCDA
00:9410 A524            	   711:   lda  PCODE+1
00:9412 8526            	   712:   sta  ACT_PCDA+1
00:9414 A000            	   713:   ldy  #0
00:9416 B18E            	   714:   lda  (token_start),y
00:9418 D00A            	   715:   bne  INIT9
00:941A A9C6            	   716:   lda  #<NOSCE
00:941C A293            	   717:   ldx  #>NOSCE
00:941E 202682          	   718:   jsr  print                      ; No source file
00:9421 4C7282          	   719:   jmp  main_prompt
00:9424 60              	   720: INIT9    rts
                        	   721: 
                        	   722: 
                        	   723: 
                        	   724: 
                        	   725: ;
                        	   726: CROUT    =  *             ; show a newline
00:9425 A90A            	   727:   lda  #NL         ; was a carriage-return in legacy, now is newline
00:9427 4CB395          	   728:   jmp  COUT
                        	   729: ;
                        	   730: ;***********************************************
                        	   731: ; COMPARE STRING - compare SRCE to DEST, assumes DEST is upper-case
                        	   732: ;                - length in Y (therefore max 255 characters)
                        	   733: ;                - zero flag set if match (therefore do a BEQ to see if strings match)
                        	   734: ;***********************************************
                        	   735: COMSTL   =  *
00:942A 88              	   736:          dey
00:942B 300A            	   737:          bmi  COMS8
00:942D B100            	   738:          lda  (SRCE),Y
00:942F 20C191          	   739:          jsr MAKE_UPPER
00:9432 D103            	   740:          cmp  (DEST),Y
00:9434 F0F4            	   741:          beq  COMSTL
00:9436 60              	   742: COMS9    rts             ; NOT EQUAL
00:9437 A900            	   743: COMS8    lda  #0
00:9439 60              	   744:          rts             ; EQUAL
                        	   745: 
                        	   746: ;***********************************************
                        	   747: ; DISPLAY A LINE
                        	   748: ;
                        	   749: 
                        	   750: ;
                        	   751: ; DISPLAY IN HEX
                        	   752: ;
00:943A 209A94          	   753: DISHX    jsr  PRBYTE
00:943D 4CB094          	   754:          jmp  PUTSP
                        	   755: ;
                        	   756: 
                        	   757: ;***********************************************
                        	   758: ; DISPLAY PCODE ADDRESS
                        	   759: ;***********************************************
                        	   760: DISPAD   =  *
00:9440 A52E            	   761:          lda  DCODE
00:9442 F017            	   762:          beq  DISPAD2
                        	   763: DISPAD1  =  *
00:9444 A928            	   764:          lda  #'('
00:9446 20B395          	   765:          jsr  COUT
00:9449 A524            	   766:          lda  PCODE+1
00:944B 209A94          	   767:          jsr  PRBYTE
00:944E A523            	   768:          lda  PCODE
00:9450 209A94          	   769:          jsr  PRBYTE
00:9453 A929            	   770:          lda  #')'
00:9455 20B395          	   771:          jsr  COUT
00:9458 4CB094          	   772:          jmp  PUTSP
00:945B 60              	   773: DISPAD2  rts
                        	   774: ;
                        	   775: 
                        	   776: ;***********************************************
                        	   777: ; PUSH 'WORK' ONTO STACK
                        	   778: ;***********************************************
                        	   779: PSHWRK   =  *
00:945C 8536            	   780:          sta  BSAVE
00:945E 68              	   781:          pla
00:945F AA              	   782:          tax
00:9460 68              	   783:          pla
00:9461 A8              	   784:          tay
00:9462 A538            	   785:          lda  WORK+1
00:9464 48              	   786:          pha
00:9465 A537            	   787:          lda  WORK
00:9467 48              	   788:          pha
00:9468 98              	   789:          tya
00:9469 48              	   790:          pha
00:946A 8A              	   791:          txa
00:946B 48              	   792:          pha
00:946C A536            	   793:          lda  BSAVE
00:946E 60              	   794: PSH9     rts
                        	   795: ;
                        	   796: ;***********************************************
                        	   797: ; PULL 'WORK' FROM STACK
                        	   798: ;***********************************************
                        	   799: PULWRK   =  *
00:946F 8536            	   800:          sta  BSAVE
00:9471 68              	   801:          pla
00:9472 AA              	   802:          tax
00:9473 68              	   803:          pla
00:9474 A8              	   804:          tay
00:9475 68              	   805:          pla
00:9476 8537            	   806:          sta  WORK
00:9478 68              	   807:          pla
00:9479 8538            	   808:          sta  WORK+1
00:947B 98              	   809:          tya
00:947C 48              	   810:          pha
00:947D 8A              	   811:          txa
00:947E 48              	   812:          pha
00:947F A536            	   813:          lda  BSAVE
00:9481 60              	   814:          rts
                        	   815: ;
                        	   816: ;***********************************************
                        	   817: ; PRINTING SUBROUTINES
                        	   818: ; Control characters print with a ^ in front of them, eg. ^A
                        	   819: ;***********************************************
                        	   820: PRCHAR   =  *
00:9482 48              	   821:   pha
00:9483 C90A            	   822:   cmp #NL
00:9485 F00E            	   823:   beq prchar_not_control
00:9487 C920            	   824:   cmp #$20
00:9489 B00A            	   825:   bcs prchar_not_control
00:948B 48              	   826:   pha
00:948C A95E            	   827:   lda #'^'
00:948E 20B395          	   828:   jsr COUT
00:9491 68              	   829:   pla
00:9492 18              	   830:   clc
00:9493 6940            	   831:   adc #$40  ; make 0x01 print as ^A
                        	   832: prchar_not_control:
00:9495 20B395          	   833:   jsr  COUT
00:9498 68              	   834:   pla
00:9499 60              	   835:   rts
                        	   836: ;
                        	   837: ; Prints A in hex
                        	   838: ;
                        	   839: PRBYTE:
00:949A 48              	   840:   pha
00:949B 4A              	   841:   lsr
00:949C 4A              	   842:   lsr
00:949D 4A              	   843:   lsr
00:949E 4A              	   844:   lsr
00:949F 20A594          	   845:   jsr  PRHEXZ    ; first nibble
00:94A2 68              	   846:   pla            ; now do other nibble
                        	   847: PRHEX:
00:94A3 290F            	   848:   and  #$0F
                        	   849: PRHEXZ:
00:94A5 0930            	   850:   ora  #'0'
00:94A7 C93A            	   851:   cmp  #'0' + $0A
00:94A9 9002            	   852:   bcc  PRHEX1
00:94AB 6926            	   853:   adc  #$26  ; (carry is set: adding 7 to make 0x0a become 'a')
                        	   854: PRHEX1:
00:94AD 4C8294          	   855:   jmp  PRCHAR
                        	   856: ;
                        	   857: PUTSP    =  *
00:94B0 A920            	   858:   lda  #' '
00:94B2 80F9            	   859:   bra  PRHEX1
                        	   860: ;
                        	   861: ;
                        	   862: ;  PT - put text
                        	   863: ;   Low-order address in A, high-order address in X, count in Y
                        	   864: ;
                        	   865: ;
                        	   866: PT:
00:94B4 8503            	   867:   sta  REG2
00:94B6 8604            	   868:   stx  REG2+1
00:94B8 98              	   869:   tya    ; count of bytes to print
00:94B9 AA              	   870:   tax    ; put that into X
00:94BA A000            	   871:   ldy  #0
                        	   872: PT6:
00:94BC B103            	   873:   lda  (REG2),Y    ; next character
00:94BE 20B395          	   874:   jsr COUT         ; show it
00:94C1 C8              	   875:   iny
00:94C2 CA              	   876:   dex
00:94C3 D0F7            	   877:   bne  PT6
00:94C5 60              	   878:   rts
                        	   879: ;
                        	   880: ;
                        	   881: ;
                        	   882: ;---- token_address --> WORK
                        	   883: ;
                        	   884: TKNWRK   =  *
00:94C6 48              	   885:          PHA
00:94C7 A590            	   886:          LDA  token_address
00:94C9 8537            	   887:          STA  WORK
00:94CB A591            	   888:          LDA  token_address+1
00:94CD 8538            	   889:          STA  WORK+1
00:94CF 68              	   890:          PLA
00:94D0 60              	   891:          RTS
                        	   892: ;
                        	   893: ;---- WORK --> token_address
                        	   894: ;
                        	   895: WRKTKN   =  *
00:94D1 48              	   896:          PHA
00:94D2 A537            	   897:          LDA  WORK
00:94D4 8590            	   898:          STA  token_address
00:94D6 A538            	   899:          LDA  WORK+1
00:94D8 8591            	   900:          STA  token_address+1
00:94DA 68              	   901:          PLA
00:94DB 60              	   902:          RTS
                        	   903: ;
                        	   904: 
                        	   905: 
                        	   906: ;***********************************************
                        	   907: ; MENU, FILE HANDLING
                        	   908: ;***********************************************
                        	   909: ;
00:94DC 502D636F64657320	   910: pcodes_ended_message        asciiz  "P-codes ended at $"
00:94E4 656E646564206174
00:94EC 2024
00:94EE 00
00:94EF 436F6D70696C6520	   911: compile_finished_message    asciiz  "Compile finished: No errors.\n"
00:94F7 66696E6973686564
00:94FF 3A204E6F20657272
00:9507 6F72732E0A
00:950C 00
00:950D 53796D626F6C2074	   912: symbol_table_ended_message  asciiz "Symbol table ended at $"
00:9515 61626C6520656E64
00:951D 65642061742024
00:9524 00
00:9525 4E6F2076616C6964	   913: no_valid_compile_message    asciiz  'No valid compile or assemble done before\n'
00:952D 20636F6D70696C65
00:9535 206F722061737365
00:953D 6D626C6520646F6E
00:9545 65206265666F7265
00:954D 0A
00:954E 00
                        	   914: ;
                        	   915: PRBYTECR =  *
00:954F 209A94          	   916:          JSR  PRBYTE
00:9552 4C2594          	   917:          JMP  CROUT
                        	   918: ;
                        	   919: ;
                        	   920: ;
                        	   921: CHK_VAL  =  *
00:9555 A908            	   922:          lda  #FLAG_VALID_COMPILE
00:9557 0910            	   923:          ora  #FLAG_VALID_ASSEMBLE
00:9559 25BE            	   924:          and  system_flags
00:955B D00A            	   925:          bne  CHK_VAL9
00:955D A925            	   926:          lda  #<no_valid_compile_message    ; No valid Compile or Assemble done before
00:955F A295            	   927:          ldx  #>no_valid_compile_message
00:9561 202682          	   928:          jsr  print
00:9564 4C7282          	   929:          jmp  main_prompt
                        	   930: CHK_VAL9 =  *
                        	   931: BELL1X   =  *          ; no bell yet
00:9567 60              	   932:          rts
                        	   933: ;
00:9568 205595          	   934: CHK_RUN  jsr  CHK_VAL
00:956B A910            	   935:          lda  #FLAG_VALID_ASSEMBLE
00:956D 25BE            	   936:          and  system_flags
00:956F D003            	   937:          bne  run_assembler
                        	   938: ;
                        	   939: ;  If we somehow get here without Pascal included, go back to editor
                        	   940: ;
                        	   941:          .if  USE_PASCAL
00:9571 4CB0BE          	   942:          jmp  INTERP
                        	   943:          .else
                        	   944:          jmp main_prompt
                        	   945:          .endif ; USE_PASCAL
                        	   946: 
                        	   947: run_assembler:
00:9574 A2CF            	   948:          ldx #RUNNING_STACK_TOP           ; don't use all of stack
00:9576 9A              	   949:          txs
00:9577 A980            	   950:          lda #FLAG_BRK_REACHED    ; no BRK reached yet
00:9579 14BE            	   951:          trb system_flags
00:957B 208195          	   952:          jsr call_assembler
00:957E 4CF895          	   953:          jmp  EX_FINISHD
                        	   954: ;
                        	   955: ;  let's assume they put a RTS at the end of their code
                        	   956: ;
                        	   957: call_assembler:
00:9581 A940            	   958:          lda  #<running_message   ; Running
00:9583 A2DC            	   959:          ldx  #>running_message
00:9585 202682          	   960:          jsr  print
00:9588 6C2500          	   961:          jmp (ACT_PCDA)
                        	   962: 
                        	   963: ;
                        	   964: 
                        	   965: ;
                        	   966: ; Get a line, read byte by byte until we get a newline, store in INBUF
                        	   967: ;   returns length in Y - handles backspace, ignores carriage-return
                        	   968: ;
                        	   969: GET_LINE =  *
                        	   970: GETLN1   =  *
00:958B A000            	   971:   ldy  #0
                        	   972: GET1:
00:958D 201FCB          	   973:   jsr  CHRIN
00:9590 C90D            	   974:   cmp  #CR       ; carriage-return?
00:9592 F0F9            	   975:   beq  GET1       ; ignore it
00:9594 990002          	   976:   sta  INBUF,Y    ; SAVE IN BUFFER
00:9597 C8              	   977:   iny
00:9598 F016            	   978:   beq  GETLN_OVERFLOW       ; overflow
00:959A C90A            	   979:   cmp  #NL        ; END OF LINE?
00:959C F00C            	   980:   beq  GET3       ; yes
00:959E C908            	   981:   cmp  #BACKSPACE ; backspace?
00:95A0 D0EB            	   982:   bne  GET1       ; no - keep adding to buffer
                        	   983: ;
                        	   984: ;  here for backspace
                        	   985: ;
00:95A2 88              	   986:   dey  ; get rid of backspace
00:95A3 88              	   987:   dey  ; get rid of character we backspaced over
00:95A4 C0FF            	   988:   cpy  #$FF
00:95A6 F0E3            	   989:   beq  GETLN1   ; if Y underflowed, go back to zero
00:95A8 80E3            	   990:   bra GET1
                        	   991: 
                        	   992: GET3:
00:95AA A900            	   993:   lda  #0
00:95AC 990002          	   994:   sta  INBUF,Y    ; turn newline into 0x00
00:95AF 60              	   995:   rts             ; RETURN
                        	   996: ;
                        	   997: ;  here on INBUF overflow
                        	   998: ;
                        	   999: GETLN_OVERFLOW:
00:95B0 88              	  1000:   dey           ; get back to 255 (last byte)
00:95B1 80F7            	  1001:   bra  GET3     ; store a zero there
                        	  1002: 
                        	  1003: 
                        	  1004: ;
                        	  1005: ;  output a character - saves all registers
                        	  1006: ;
                        	  1007: COUT:
00:95B3 48              	  1008:   pha
00:95B4 DA              	  1009:   phx
00:95B5 5A              	  1010:   phy
00:95B6 20BD95          	  1011:   jsr COUT_CALL   ; call the current outputting routine
00:95B9 7A              	  1012:   ply
00:95BA FA              	  1013:   plx
00:95BB 68              	  1014:   pla
00:95BC 60              	  1015:   rts
                        	  1016: 
                        	  1017: 
                        	  1018: COUT_CALL:
00:95BD 6C1700          	  1019:   jmp (write_function)
                        	  1020: 
                        	  1021: 
00:95C0 4572726F72206F63	  1022: DM7      asciiz  "Error occurred at P-code "
00:95C8 6375727265642061
00:95D0 7420502D636F6465
00:95D8 20
00:95D9 00
                        	  1023: 
                        	  1024: ;
                        	  1025: ; Ding a bell - however we don't have it on this board
                        	  1026: ;
                        	  1027: BELL1    =  *
00:95DA 48              	  1028:          pha
00:95DB A900            	  1029:          lda  #0
00:95DD 853F            	  1030:          sta  RUNNING
00:95DF 202594          	  1031:          jsr  CROUT
00:95E2 68              	  1032:          pla
00:95E3 60              	  1033:          rts
                        	  1034: ;
                        	  1035: ;
00:95E4 20DA95          	  1036: RUNERR   jsr  BELL1
00:95E7 A9C0            	  1037:          lda  #<DM7  ; Error occurred at P-code
00:95E9 A295            	  1038:          ldx  #>DM7
00:95EB 202682          	  1039:          jsr  print
00:95EE A54E            	  1040:          lda  LASTP+1
00:95F0 209A94          	  1041:          jsr  PRBYTE
00:95F3 A54D            	  1042:          lda  LASTP
00:95F5 203A94          	  1043:          jsr  DISHX
                        	  1044: EX_FINISHD  =  *
00:95F8 A900            	  1045:          lda  #0
00:95FA 202594          	  1046:          jsr  CROUT
00:95FD A90F            	  1047:          lda  #<FIN_MSG
00:95FF A296            	  1048:          ldx  #>FIN_MSG
00:9601 202682          	  1049:          jsr  print
00:9604 648B            	  1050:          stz  serial_in_byte_received  ; get rid of read-ahead
00:9606 201FCB          	  1051:          jsr  GETIN      ; wait till message seen
00:9609 202594          	  1052:          jsr  CROUT      ; output a newline in case they press space or something
00:960C 4C65DC          	  1053:          jmp  RESTART
                        	  1054: ;
00:960F 52756E2066696E69	  1055: FIN_MSG  asciiz  'Run finished - press a key ...'
00:9617 73686564202D2070
00:961F 726573732061206B
00:9627 6579202E2E2E
00:962D 00
                        	  1056: 
                        	  1057: ass_error:
00:962E A56F            	  1058:   lda ASS_EMIT_COUNT
00:9630 F003            	  1059:   beq ass_error1
00:9632 202594          	  1060:   jsr CROUT
                        	  1061: ass_error1:
00:9635 4CE099          	  1062:   jmp ERROR
                        	  1063: 
                        	  1064: 

Source: "gpascal.asm"
                        	   184:   .include "errors.inc"

Source: "errors.inc"
                        	     1: 
                        	     2: errors_table:
00:9638 4D656D6F72792066	     3:   asciiz "Memory full"                               ;  1
00:9640 756C6C
00:9643 00
00:9644 436F6E7374616E74	     4:   asciiz "Constant expected"                         ;  2
00:964C 2065787065637465
00:9654 64
00:9655 00
00:9656 3D20657870656374	     5:   asciiz "= expected"                                ;  3
00:965E 6564
00:9660 00
00:9661 4964656E74696669	     6:   asciiz "Identifier expected"                       ;  4
00:9669 6572206578706563
00:9671 746564
00:9674 00
00:9675 2C206F72203A2065	     7:   asciiz ", or : expected"                           ;  5
00:967D 78706563746564
00:9684 00
00:9685 427567          	     8:   asciiz "Bug"                                       ;  6
00:9688 00
00:9689 2A29206F72207D20	     9:   asciiz "*) or } expected"                          ;  7
00:9691 6578706563746564
00:9699 00
00:969A 496E636F72726563	    10:   asciiz "Incorrect string"                          ;  8
00:96A2 7420737472696E67
00:96AA 00
00:96AB 2E20657870656374	    11:   asciiz ". expected"                                ;  9
00:96B3 6564
00:96B5 00
00:96B6 3B20657870656374	    12:   asciiz "; expected"                                ; 10
00:96BE 6564
00:96C0 00
00:96C1 556E6465636C6172	    13:   asciiz "Undeclared identifier"                     ; 11
00:96C9 6564206964656E74
00:96D1 6966696572
00:96D6 00
00:96D7 496C6C6567616C20	    14:   asciiz "Illegal identifier"                        ; 12
00:96DF 6964656E74696669
00:96E7 6572
00:96E9 00
00:96EA 3A3D206578706563	    15:   asciiz ":= expected"                               ; 13
00:96F2 746564
00:96F5 00
00:96F6 4C69746572616C20	    16:   asciiz "Literal string of zero length"             ; 14
00:96FE 737472696E67206F
00:9706 66207A65726F206C
00:970E 656E677468
00:9713 00
00:9714 436F6D70696C6572	    17:   asciiz "Compiler limits exceeded"                  ; 15
00:971C 206C696D69747320
00:9724 6578636565646564
00:972C 00
00:972D 5448454E20657870	    18:   asciiz "THEN expected"                             ; 16
00:9735 6563746564
00:973A 00
00:973B 3B206F7220454E44	    19:   asciiz "; or END expected"                         ; 17
00:9743 2065787065637465
00:974B 64
00:974C 00
00:974D 444F206578706563	    20:   asciiz "DO expected"                               ; 18
00:9755 746564
00:9758 00
00:9759 496E636F72726563	    21:   asciiz "Incorrect symbol"                          ; 19
00:9761 742073796D626F6C
00:9769 00
00:976A 427567          	    22:   asciiz "Bug"                                       ; 20
00:976D 00
00:976E 557365206F662070	    23:   asciiz "Use of procedure identifier in expression" ; 21
00:9776 726F636564757265
00:977E 206964656E746966
00:9786 69657220696E2065
00:978E 787072657373696F
00:9796 6E
00:9797 00
00:9798 2920657870656374	    24:   asciiz ") expected"                                ; 22
00:97A0 6564
00:97A2 00
00:97A3 496C6C6567616C20	    25:   asciiz "Illegal factor"                            ; 23
00:97AB 666163746F72
00:97B1 00
00:97B2 54797065206D6973	    26:   asciiz "Type mismatch"                             ; 24
00:97BA 6D61746368
00:97BF 00
00:97C0 424547494E206578	    27:   asciiz "BEGIN expected"                            ; 25
00:97C8 706563746564
00:97CE 00
00:97CF 4F46206578706563	    28:   asciiz "OF expected"                               ; 26
00:97D7 746564
00:97DA 00
00:97DB 537461636B206675	    29:   asciiz "Stack full"                                ; 27
00:97E3 6C6C
00:97E5 00
00:97E6 544F206F7220444F	    30:   asciiz "TO or DOWNTO expected"                     ; 28
00:97EE 574E544F20657870
00:97F6 6563746564
00:97FB 00
00:97FC 537472696E67206C	    31:   asciiz "String literal too big"                    ; 29
00:9804 69746572616C2074
00:980C 6F6F20626967
00:9812 00
00:9813 4E756D626572206F	    32:   asciiz "Number out of range"                       ; 30
00:981B 7574206F66207261
00:9823 6E6765
00:9826 00
00:9827 2820657870656374	    33:   asciiz "( expected"                                ; 31
00:982F 6564
00:9831 00
00:9832 2C20657870656374	    34:   asciiz ", expected"                                ; 32
00:983A 6564
00:983C 00
00:983D 5B20657870656374	    35:   asciiz "[ expected"                                ; 33
00:9845 6564
00:9847 00
00:9848 5D20657870656374	    36:   asciiz "] expected"                                ; 34
00:9850 6564
00:9852 00
00:9853 506172616D657465	    37:   asciiz "Parameters mismatched"                     ; 35
00:985B 7273206D69736D61
00:9863 7463686564
00:9868 00
00:9869 4461746120747970	    38:   asciiz "Data type not recognised"                  ; 36
00:9871 65206E6F74207265
00:9879 636F676E69736564
00:9881 00
00:9882 53796D626F6C2074	    39:   asciiz "Symbol table full"                         ; 37
00:988A 61626C652066756C
00:9892 6C
00:9893 00
00:9894 4475706C69636174	    40:   asciiz "Duplicate identifier"                      ; 38
00:989C 65206964656E7469
00:98A4 66696572
00:98A8 00
00:98A9 56616C7565206578	    41:   asciiz "Value expected"                            ; 39
00:98B1 706563746564
00:98B7 00
00:98B8 496C6C6567616C20	    42:   asciiz "Illegal opcode"                            ; 40
00:98C0 6F70636F6465
00:98C6 00
00:98C7 496C6C6567616C20	    43:   asciiz "Illegal addressing mode"                   ; 41
00:98CF 6164647265737369
00:98D7 6E67206D6F6465
00:98DE 00
00:98DF 4272616E6368206F	    44:   asciiz "Branch out of range"                       ; 42
00:98E7 7574206F66207261
00:98EF 6E6765
00:98F2 00
00:98F3 4E656564207A6572	    45:   asciiz "Need zero page address"                    ; 43
00:98FB 6F20706167652061
00:9903 646472657373
00:9909 00
00:990A 4F706572616E6420	    46:   asciiz "Operand too large"                         ; 44
00:9912 746F6F206C617267
00:991A 65
00:991B 00
00:991C 53796D626F6C2061	    47:   asciiz "Symbol address changed"                    ; 45
00:9924 6464726573732063
00:992C 68616E676564
00:9932 00
00:9933 4578707265737369	    48:   asciiz "Expression too complex"                    ; 46
00:993B 6F6E20746F6F2063
00:9943 6F6D706C6578
00:9949 00
00:994A 4469766964652062	    49:   asciiz "Divide by zero"                            ; 47
00:9952 79207A65726F
00:9958 00
00:9959 4C6162656C207265	    50:   asciiz "Label required"                            ; 48
00:9961 717569726564
00:9967 00
00:9968 53796D626F6C2074	    51:   asciiz "Symbol table in use"                       ; 49
00:9970 61626C6520696E20
00:9978 757365
00:997B 00
00:997C 4E6F204C4344    	    52:   asciiz "No LCD"                                    ; 50
00:9982 00
00:9983 436F646520616C72	    53:   asciiz "Code already generated"                    ; 51
00:998B 656164792067656E
00:9993 657261746564
00:9999 00
                        	    54: assertion_failed_message:   ; used by Pascal assert function
00:999A 417373657274696F	    55:   asciiz "Assertion failed"                          ; 52
00:99A2 6E206661696C6564
00:99AA 00
00:99AB 557365206F662066	    56:   asciiz "Use of function identifier in statement"   ; 53
00:99B3 756E6374696F6E20
00:99BB 6964656E74696669
00:99C3 657220696E207374
00:99CB 6174656D656E74
00:99D2 00
00:99D3 00              	    57:   dfb 0
                        	    58: 
                        	    59: ;***********************************************
                        	    60: ; DISPLAY ERROR - this does not return to the caller
                        	    61: ;  but to main_prompt
                        	    62: ;  Error number in X
                        	    63: ;***********************************************
00:99D4 2A2A2A204572726F	    64: ERRLIT   asciiz  '*** Error: '
00:99DC 723A20
00:99DF 00
                        	    65: 
00:99E0 8635            	    66: ERROR    stx  ERRNO
00:99E2 A53F            	    67:          lda  RUNNING
00:99E4 F003            	    68:          beq  ERR7
00:99E6 4C1D9A          	    69:          jmp  ERR6
                        	    70: ERR7     =  *
00:99E9 A51D            	    71:          lda  LIST
00:99EB D006            	    72:          bne  ERR1
00:99ED 202594          	    73:          jsr  CROUT
00:99F0 20759A          	    74:          jsr  show_current_line
                        	    75: ERR1     =  *
00:99F3 A590            	    76:          lda  token_address
00:99F5 38              	    77:          sec
00:99F6 E59C            	    78:          sbc  token_line_start  ; TODO: what about high-order byte?
00:99F8 48              	    79:          pha             ; CHARS UP TO ERROR POINT
00:99F9 A9D4            	    80:          lda  #<ERRLIT   ; *** Error
00:99FB A299            	    81:          ldx  #>ERRLIT
00:99FD 202682          	    82:          jsr  print
00:9A00 68              	    83:          pla
00:9A01 18              	    84:          clc
00:9A02 6901            	    85:          adc   #1
00:9A04 8545            	    86:          sta  TEMP       ; BYTES TO ERROR POINT
00:9A06 AA              	    87:          tax
                        	    88: ERR3     =  *
00:9A07 20B094          	    89:          jsr  PUTSP
00:9A0A CA              	    90:          dex
00:9A0B D0FA            	    91:          bne  ERR3
00:9A0D A95E            	    92:          lda  #'^'
00:9A0F 20B395          	    93:          jsr  COUT
00:9A12 202594          	    94:          jsr  CROUT
00:9A15 A209            	    95:          ldx  #9
                        	    96: ERR5     =  *
00:9A17 20B094          	    97:          jsr  PUTSP
00:9A1A CA              	    98:          dex
00:9A1B D0FA            	    99:          bne  ERR5
                        	   100: ERR6     =  *
00:9A1D A938            	   101:   lda #<errors_table
00:9A1F 8500            	   102:   sta REG
00:9A21 A996            	   103:   lda #>errors_table
00:9A23 8501            	   104:   sta REG+1
00:9A25 A200            	   105:   ldx #0
00:9A27 A000            	   106:   ldy #0
                        	   107: error_next:
00:9A29 E8              	   108:   inx
                        	   109: error_loop:
00:9A2A E435            	   110:   cpx ERRNO
00:9A2C F02A            	   111:   beq error_found
                        	   112: error_find_next:
00:9A2E B100            	   113:   lda (REG),Y
00:9A30 48              	   114:   pha
00:9A31 E600            	   115:   inc REG
00:9A33 D002            	   116:   bne error1
00:9A35 E601            	   117:   inc REG+1
                        	   118: error1:
00:9A37 68              	   119:   pla           ; get the previous byte
00:9A38 D0F4            	   120:   bne error_find_next
00:9A3A B100            	   121:   lda (REG),Y   ; a null after a null?
00:9A3C F002            	   122:   beq error_not_found
00:9A3E 80E9            	   123:   bra error_next  ; we got a null, so add 1 to our current error number (X)
                        	   124: 
                        	   125: error_not_found:
00:9A40 A965            	   126:   lda #<error_not_found_message
00:9A42 A29A            	   127:   ldx #>error_not_found_message
00:9A44 202682          	   128:   jsr print
00:9A47 A535            	   129:   lda ERRNO
00:9A49 8500            	   130:   sta REG
00:9A4B 6401            	   131:   stz REG+1
00:9A4D 6402            	   132:   stz REGB
00:9A4F 204F93          	   133:   jsr display_in_decimal
00:9A52 202594          	   134:   jsr CROUT
00:9A55 4C7282          	   135:   jmp main_prompt
                        	   136: 
                        	   137: error_found:
00:9A58 A500            	   138:   lda REG
00:9A5A A601            	   139:   ldx REG+1
00:9A5C 202682          	   140:   jsr print
00:9A5F 202594          	   141:   jsr CROUT
00:9A62 4C7282          	   142:   jmp  main_prompt
                        	   143: 
00:9A65 556E6B6E6F776E20	   144: error_not_found_message asciiz "Unknown error: "
00:9A6D 6572726F723A20
00:9A74 00
                        	   145: 
                        	   146: show_current_line:
00:9A75 A928            	   147:   lda #'('
00:9A77 20B395          	   148:   jsr COUT
00:9A7A A524            	   149:   lda PCODE+1
00:9A7C 209A94          	   150:   jsr PRBYTE
00:9A7F A523            	   151:   lda PCODE
00:9A81 209A94          	   152:   jsr PRBYTE
00:9A84 A929            	   153:   lda #')'
00:9A86 20B395          	   154:   jsr COUT
00:9A89 20B094          	   155:   jsr PUTSP
00:9A8C 20478C          	   156:   jsr show_current_line_number
00:9A8F A59C            	   157:   lda token_line_start
00:9A91 85A6            	   158:   sta mem_move_src
00:9A93 A59D            	   159:   lda token_line_start+1
00:9A95 85A7            	   160:   sta mem_move_src+1
                        	   161: 
                        	   162: show_current_line_loop:
00:9A97 A000            	   163:   ldy #0
00:9A99 B1A6            	   164:   lda (mem_move_src),Y
00:9A9B F01D            	   165:   beq show_current_line_done
00:9A9D C90A            	   166:   cmp #NL
00:9A9F F019            	   167:   beq show_current_line_done
00:9AA1 C920            	   168:   cmp #$20
00:9AA3 B00A            	   169:   bcs show_current_line_loop_print_one_character
00:9AA5 48              	   170:   pha
00:9AA6 A95E            	   171:   lda #'^'
00:9AA8 20B395          	   172:   jsr COUT
00:9AAB 68              	   173:   pla
00:9AAC 18              	   174:   clc
00:9AAD 6940            	   175:   adc #$40  ; make 0x01 print as ^A
                        	   176: show_current_line_loop_print_one_character:
00:9AAF 20B395          	   177:   jsr COUT    ; show that byte
00:9AB2 E6A6            	   178:   inc mem_move_src
00:9AB4 D0E1            	   179:   bne show_current_line_loop
00:9AB6 E6A7            	   180:   inc mem_move_src+1
00:9AB8 80DD            	   181:   bra show_current_line_loop
                        	   182: 
                        	   183: show_current_line_done:
00:9ABA 202594          	   184:   jsr CROUT
00:9ABD 60              	   185:   rts
                        	   186: 

Source: "gpascal.asm"
                        	   185:   .if USE_ASSEMBLER
                        	   186:   .include "assembler.inc"

Source: "assembler.inc"
                        	     1: ;***********************************************
                        	     2: ;
                        	     3: ; Assembler
                        	     4: ;
                        	     5: ;***********************************************
                        	     6: 
                        	     7: ;***********************************************
                        	     8: ; Assembler operand types
                        	     9: ;***********************************************
                        	    10: 
                        	    11: ASS_OPERAND_ABSOLUTE                           =  1      ; a
                        	    12: ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT          =  2      ; (a,x)
                        	    13: ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X            =  3      ; a,x
                        	    14: ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y            =  4      ; a,y
                        	    15: ASS_OPERAND_ABSOLUTE_INDIRECT                  =  5      ; (a)
                        	    16: ASS_OPERAND_ACCUMULATOR_A                      =  6      ; A
                        	    17: ASS_OPERAND_IMMEDIATE                          =  7      ; #
                        	    18: ASS_OPERAND_IMPLIED                            =  8      ; i
                        	    19: ASS_OPERAND_PROGRAM_COUNTER_RELATIVE           =  9      ; r
                        	    20: ASS_OPERAND_STACK                              = 10      ; s
                        	    21: ASS_OPERAND_ZERO_PAGE                          = 11      ; zp
                        	    22: ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT         = 12      ; (zp,x)
                        	    23: ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X           = 13      ; zp,x
                        	    24: ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y           = 14      ; zp,y
                        	    25: ASS_OPERAND_ZERO_PAGE_INDIRECT                 = 15      ; (zp)
                        	    26: ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y  = 16      ; (zp),y
                        	    27: ASS_OPERAND_STRING                             = 17      ; "But does it get goat's blood out?"
                        	    28: ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE             = 18      ; zp,r
                        	    29: 
                        	    30: ;
                        	    31: ;  Entry point for assembler
                        	    32: ;
                        	    33: ASSEMBLE:
                        	    34: 
00:9ABE A2FF            	    35:    ldx  #NEW_STK
00:9AC0 9A              	    36:    txs    ; set stack back to 0xFF
00:9AC1 6476            	    37:    stz  ASS_PASS  ; first pass
00:9AC3 20D793          	    38:    jsr  INIT       ; sets up pointers, calls LINE
00:9AC6 20F8AC          	    39:    jsr  add_assembler_library_functions  ; add our inbuilt functions to the symbol table
00:9AC9 8005            	    40:    bra  ASSEMBLE_PASS
                        	    41: 
                        	    42: ASSEMBLE_SECOND_PASS:
00:9ACB E676            	    43:    inc  ASS_PASS
00:9ACD 20E393          	    44:    jsr  INIT_SECOND_PASS    ; don't re-initialise the symbol table
                        	    45: ASSEMBLE_PASS:
00:9AD0 64A2            	    46:    stz  current_line  ; we'll got for zero, not one
                        	    47: 
00:9AD2 A902            	    48:    lda  #FLAG_ASSEMBLING
00:9AD4 04BE            	    49:    tsb  system_flags
                        	    50: 
                        	    51: ;
                        	    52: ;  no listing yet
                        	    53: ;
00:9AD6 642E            	    54:    stz  DCODE
00:9AD8 641D            	    55:    stz  LIST
00:9ADA 6442            	    56:    stz  SYNTAX
00:9ADC 6482            	    57:    stz  show_symbols
                        	    58: ;
                        	    59: ; zero line count
                        	    60: ;
00:9ADE 6419            	    61:    stz  LINE_CNT
00:9AE0 641A            	    62:    stz  LINE_CNT+1
                        	    63: 
                        	    64: ;
                        	    65: ;  and emitted bytes count
                        	    66: ;
00:9AE2 6477            	    67:    stz ass_emit_bytes
00:9AE4 6478            	    68:    stz ass_emit_bytes+1
                        	    69: 
                        	    70: ;
                        	    71: ; no previous token
                        	    72: ;
00:9AE6 6493            	    73:    stz  token_type
00:9AE8 800E            	    74:    bra ass_line
                        	    75: 
                        	    76: ass_finish_line:
00:9AEA A593            	    77:    lda token_type
00:9AEC C90A            	    78:    cmp #NL
00:9AEE F008            	    79:    beq ass_line
00:9AF0 A213            	    80:    ldx #19    ; Incorrect Symbol
00:9AF2 4C2E96          	    81:    jmp ass_error
                        	    82: 
                        	    83: ass_done_jump:
00:9AF5 4CF99D          	    84:    jmp ass_done
                        	    85: ;
                        	    86: ;  here for the start of a line
                        	    87: ;
                        	    88: ass_line:
00:9AF8 A576            	    89:   lda ASS_PASS    ; only showing codes on 2nd pass
00:9AFA F00B            	    90:   beq ass_line1
00:9AFC A56F            	    91:   lda ASS_EMIT_COUNT  ; only need a newline if we actually output a code
00:9AFE F007            	    92:   beq ass_line1
00:9B00 A52E            	    93:   lda DCODE           ; is showing codes on?
00:9B02 F003            	    94:   beq ass_line1
00:9B04 202594          	    95:   jsr CROUT
                        	    96: ass_line1:
00:9B07 A000            	    97:   ldy #0
00:9B09 B18E            	    98:   lda (token_start),y ; quick test so we don't list a non-existent line
00:9B0B F0E8            	    99:   beq ass_done_jump
                        	   100: 
00:9B0D A58E            	   101:   lda token_start
00:9B0F 859C            	   102:   sta token_line_start
00:9B11 A58F            	   103:   lda token_start+1
00:9B13 859D            	   104:   sta token_line_start+1
00:9B15 203FCC          	   105:   jsr token_line        ; list the next line
                        	   106: 
00:9B18 646B            	   107:   stz ASS_OPERAND   ; no operand yet
00:9B1A 646F            	   108:   stz ASS_EMIT_COUNT
00:9B1C 6483            	   109:   stz ass_current_label
00:9B1E 6484            	   110:   stz ass_current_label+1
                        	   111: 
00:9B20 209FCB          	   112:   jsr get_token
                        	   113: 
00:9B23 C949            	   114:   cmp #TOKEN_IDENTIFIER  ; could be a label if in column 1
00:9B25 F011            	   115:   beq ass_identifier
00:9B27 C93D            	   116:   cmp #'='               ; = directive is OK
00:9B29 F00D            	   117:   beq ass_identifier
                        	   118: 
00:9B2B C90A            	   119:   cmp #NL
00:9B2D F0C9            	   120:   beq ass_line
                        	   121: 
00:9B2F C900            	   122:   cmp #0
00:9B31 F0C2            	   123:   beq ass_done_jump
                        	   124: 
                        	   125: ass_bad_identifier:
00:9B33 A204            	   126:   ldx #4      ; Identifier expected
00:9B35 4C2E96          	   127:   JMP ass_error
                        	   128: 
                        	   129: ass_identifier:
                        	   130: 
                        	   131: ;
                        	   132: ;  if the identifier is at the start of the line, it is a label, not an opcode
                        	   133: ;
00:9B38 A590            	   134:   lda token_address
00:9B3A C59C            	   135:   cmp token_line_start
00:9B3C D069            	   136:   bne ass_opcode
00:9B3E A591            	   137:   lda token_address+1
00:9B40 C59D            	   138:   cmp token_line_start+1
00:9B42 D063            	   139:   bne ass_opcode
                        	   140: 
00:9B44 A593            	   141:   lda token_type         ; can't have = as an identifier
00:9B46 C93D            	   142:   cmp #'='               ; or "="
00:9B48 F0E9            	   143:   beq ass_bad_identifier
                        	   144: 
                        	   145: ;
                        	   146: ;  here for label - on the first pass, add it to the symbol table, on the second pass look it up
                        	   147: ;
00:9B4A A576            	   148:   lda ASS_PASS
00:9B4C D01A            	   149:   bne ass_lookup_existing_label
                        	   150: ;
                        	   151: ;  here for first pass
                        	   152: ;
00:9B4E 202FCA          	   153:   jsr CHKDUP
                        	   154: ;
                        	   155: ; not a duplicate - add it
                        	   156: ;
00:9B51 A523            	   157:   lda PCODE
00:9B53 8594            	   158:   sta token_value
00:9B55 A524            	   159:   lda PCODE+1
00:9B57 8595            	   160:   sta token_value+1
00:9B59 6496            	   161:   stz token_value+2
00:9B5B A943            	   162:   lda #SYMBOL_CONSTANT
00:9B5D 2088C9          	   163:   jsr ADDSYM
00:9B60 A002            	   164:   ldy #SYMLIB     ; the "level" of user symbols is 0
00:9B62 A900            	   165:   lda #0
00:9B64 9140            	   166:   sta (SYMITM),Y
00:9B66 8016            	   167:   bra ass_added_symbol
                        	   168: 
                        	   169: ;
                        	   170: ;  here for second pass
                        	   171: ;
                        	   172: ass_lookup_existing_label:
00:9B68 200CC9          	   173:   jsr SEARCH  ; look it up
00:9B6B D005            	   174:   bne ass_lookup_save_address  ; it should be!
00:9B6D A206            	   175:   ldx #6  ; ERROR: bug
00:9B6F 4C2E96          	   176:   jmp ass_error
                        	   177: 
                        	   178: ass_lookup_save_address:
00:9B72 A594            	   179:   lda token_value
00:9B74 8573            	   180:   sta ASS_VALUE
00:9B76 A595            	   181:   lda token_value+1
00:9B78 8574            	   182:   sta ASS_VALUE+1
00:9B7A A596            	   183:   lda token_value+2
00:9B7C 8575            	   184:   sta ASS_VALUE+2
                        	   185: 
                        	   186: ;
                        	   187: ;  the symbol has either been added, or looked up to make sure it is still there
                        	   188: ;
                        	   189: ass_added_symbol:
                        	   190: 
                        	   191: ;
                        	   192: ;  remember its address in case we have an EQU directive
                        	   193: ;
00:9B7E A540            	   194:   lda SYMITM
00:9B80 8583            	   195:   sta ass_current_label
00:9B82 A541            	   196:   lda SYMITM+1
00:9B84 8584            	   197:   sta ass_current_label+1
                        	   198: 
                        	   199: ;
                        	   200: ;  get whatever is after the label
                        	   201: ;
00:9B86 209FCB          	   202:   jsr get_token
00:9B89 C93A            	   203:   cmp #':'
00:9B8B D003            	   204:   bne ass_not_colon
00:9B8D 209FCB          	   205:   jsr get_token  ; skip the colon
                        	   206: ass_not_colon:
00:9B90 C90A            	   207:   cmp #NL     ; newline means this is just a label line
00:9B92 D003            	   208:   bne ass_not_colon2
00:9B94 4CEA9A          	   209:   jmp ass_finish_line
                        	   210: 
                        	   211: ass_not_colon2:
00:9B97 C949            	   212:   cmp #TOKEN_IDENTIFIER  ; should be an opcode now
00:9B99 F00C            	   213:   beq ass_opcode
00:9B9B C93D            	   214:   cmp #'='               ; = directive is OK
00:9B9D F008            	   215:   beq ass_opcode
                        	   216: 
                        	   217: ass_illegal_opcode:
00:9B9F 209A94          	   218:   jsr PRBYTE
00:9BA2 A228            	   219:   ldx #40      ; ERROR: illegal opcode
00:9BA4 4C2E96          	   220:   JMP ass_error
                        	   221: 
                        	   222: ass_opcode:
                        	   223: 
                        	   224: ;
                        	   225: ;  this will be our assembler mnemonic or directive so save its start point and length
                        	   226: ;
                        	   227: 
00:9BA7 A690            	   228:   ldx token_address
00:9BA9 866C            	   229:   stx OPCODE
00:9BAB A691            	   230:   ldx token_address+1
00:9BAD 866D            	   231:   stx OPCODE+1
00:9BAF A692            	   232:   ldx token_length
00:9BB1 866E            	   233:   stx OPCODE_LEN
                        	   234: 
                        	   235: ;
                        	   236: ;  if we had a label on the line, check its address hasn't changed (on the second pass)
                        	   237: ;   UNLESS it is an EQU directive in which case it probably did change
                        	   238: ;
00:9BB3 A576            	   239:   lda ASS_PASS
00:9BB5 F046            	   240:   beq ass_opcode2
00:9BB7 A583            	   241:   lda ass_current_label
00:9BB9 0584            	   242:   ora ass_current_label+1   ; was there a label?
00:9BBB F040            	   243:   beq ass_opcode2    ; nope
00:9BBD A593            	   244:   lda token_type
00:9BBF C93D            	   245:   cmp #'='
00:9BC1 F03A            	   246:   beq ass_opcode2   ; don't check on "=" directive
00:9BC3 A592            	   247:   lda token_length
00:9BC5 C903            	   248:   cmp #3
00:9BC7 D034            	   249:   bne ass_opcode2   ; can't be EQU
                        	   250: ;
                        	   251: ; this is truly crap, but I am feeling lazy
                        	   252: ;
00:9BC9 A000            	   253:   ldy #0
00:9BCB B190            	   254:   lda (token_address),y
00:9BCD 20C191          	   255:   jsr MAKE_UPPER
00:9BD0 C945            	   256:   cmp #'E'
00:9BD2 D014            	   257:   bne ass_check_label_changed
00:9BD4 C8              	   258:   iny
00:9BD5 B190            	   259:   lda (token_address),y
00:9BD7 20C191          	   260:   jsr MAKE_UPPER
00:9BDA C951            	   261:   cmp #'Q'
00:9BDC D00A            	   262:   bne ass_check_label_changed
00:9BDE C8              	   263:   iny
00:9BDF B190            	   264:   lda (token_address),y
00:9BE1 20C191          	   265:   jsr MAKE_UPPER
00:9BE4 C955            	   266:   cmp #'U'
00:9BE6 F015            	   267:   beq ass_opcode2
                        	   268: 
                        	   269: ;
                        	   270: ;  we looked up the label earlier, when it was the current token,
                        	   271: ;   and we saved its value in ASS_VALUE
                        	   272: ;
                        	   273: 
                        	   274: ass_check_label_changed:
00:9BE8 A523            	   275:   lda PCODE
00:9BEA C573            	   276:   cmp ASS_VALUE
00:9BEC D00A            	   277:   bne ass_symbol_address_changed
00:9BEE A524            	   278:   lda PCODE+1
00:9BF0 C574            	   279:   cmp ASS_VALUE+1
00:9BF2 D004            	   280:   bne ass_symbol_address_changed
00:9BF4 A575            	   281:   lda ASS_VALUE+2   ; 3rd byte should be zero
00:9BF6 F005            	   282:   beq ass_opcode2
                        	   283: 
                        	   284: ass_symbol_address_changed:
00:9BF8 A22D            	   285:   ldx #45     ; ERROR: Symbol address changed
00:9BFA 4C2E96          	   286:   jmp ass_error
                        	   287: 
                        	   288: 
                        	   289: 
                        	   290: ass_opcode2:
                        	   291: ;
                        	   292: ;  look up operand
                        	   293: ;
                        	   294: 
00:9BFD 209FCB          	   295:   jsr get_token
00:9C00 C90A            	   296:   cmp #NL           ; or end of line?
00:9C02 D00D            	   297:   bne ass_operand
                        	   298: 
                        	   299: ;
                        	   300: ;  here when the opcode is followed by (spaces) or a newline
                        	   301: ;
00:9C04 A908            	   302:   lda #ASS_OPERAND_IMPLIED
00:9C06 856B            	   303:   sta ASS_OPERAND
00:9C08 20509D          	   304:   jsr opcode_lookup
00:9C0B 203C9E          	   305:   jsr ass_check_no_more_tokens
                        	   306: ass_finish_lineJ:
00:9C0E 4CEA9A          	   307:   jmp ass_finish_line
                        	   308: 
                        	   309: ass_operand:
00:9C11 C923            	   310:   cmp #'#'  ; immediate?
00:9C13 F01B            	   311:   beq ass_immediate
00:9C15 C928            	   312:   cmp #'('  ; indirect?
00:9C17 F02A            	   313:   beq ass_indirect
00:9C19 C949            	   314:   cmp #TOKEN_IDENTIFIER
00:9C1B F02F            	   315:   beq ass_identifier_operand
00:9C1D C922            	   316:   cmp #TOKEN_STRING
00:9C1F F002            	   317:   beq ass_string
                        	   318: ;
                        	   319: ;  here for some kind of numeric address
                        	   320: ;
00:9C21 804A            	   321:   bra ass_operand_value
                        	   322: 
                        	   323: ;
                        	   324: ;  Here for a string as an operand, should be a compiler directive, eg.  ASC "Hello, world"
                        	   325: ;
                        	   326: ass_string:
00:9C23 A911            	   327:   lda #ASS_OPERAND_STRING
00:9C25 856B            	   328:   sta ASS_OPERAND
00:9C27 20509D          	   329:   jsr opcode_lookup
00:9C2A 209FCB          	   330:   jsr get_token  ; NOW get the next token
00:9C2D 4CEA9A          	   331:   jmp ass_finish_line
                        	   332: 
                        	   333: ;
                        	   334: ;  immediate, that is:  #<expression>
                        	   335: ;
                        	   336: ass_immediate:
00:9C30 A907            	   337:   lda #ASS_OPERAND_IMMEDIATE
00:9C32 856B            	   338:   sta ASS_OPERAND
00:9C34 209FCB          	   339:   jsr get_token
00:9C37 20539F          	   340:   jsr ass_get_value
00:9C3A 203C9E          	   341:   jsr ass_check_no_more_tokens
00:9C3D 20509D          	   342:   jsr opcode_lookup
00:9C40 4CEA9A          	   343:   jmp ass_finish_line
                        	   344: 
                        	   345: ;
                        	   346: ;  indirect, that is: (expression) OR (expression,X) OR (expression),Y
                        	   347: ;
                        	   348: ass_indirect:
00:9C43 A905            	   349:   lda #ASS_OPERAND_ABSOLUTE_INDIRECT  ; first guess
00:9C45 856B            	   350:   sta ASS_OPERAND
00:9C47 209FCB          	   351:   jsr get_token    ; skip the bracket
00:9C4A 8021            	   352:   bra ass_operand_value
                        	   353: 
                        	   354: ;
                        	   355: ;  some sort of identifier, possibly the start of an expression or maybe just "A"
                        	   356: ;
                        	   357: ass_identifier_operand:
                        	   358: 
                        	   359: ;
                        	   360: ;  see if the operand is just the letter "A"
                        	   361: ;
00:9C4C A592            	   362:   lda token_length
00:9C4E C901            	   363:   cmp #1
00:9C50 D01B            	   364:   bne ass_operand_value
00:9C52 A000            	   365:   ldy #0
00:9C54 B190            	   366:   lda (token_address),Y
00:9C56 20C191          	   367:   jsr MAKE_UPPER
00:9C59 C941            	   368:   cmp #'A'
00:9C5B D010            	   369:   bne ass_operand_value
00:9C5D A906            	   370:   lda #ASS_OPERAND_ACCUMULATOR_A
00:9C5F 856B            	   371:   sta ASS_OPERAND
00:9C61 209FCB          	   372:   jsr get_token  ; skip past A
00:9C64 203C9E          	   373:   jsr ass_check_no_more_tokens
00:9C67 20509D          	   374:   jsr opcode_lookup
00:9C6A 4CEA9A          	   375:   jmp ass_finish_line
                        	   376: 
                        	   377: ;
                        	   378: ;  a number or identifier - evaluate as an expression
                        	   379: ;
                        	   380: ass_operand_value:
                        	   381: 
00:9C6D A593            	   382:   lda token_type ; get token back
00:9C6F 20539F          	   383:   jsr ass_get_value  ; should have some sort of address now in VALUE
                        	   384: ;
                        	   385: ;  we come back with the first non-value token loaded in TOKEN
                        	   386: ;  now see if we originally had a bracket, so this must be one of those indirect things
                        	   387: ;
00:9C72 A56B            	   388:   lda ASS_OPERAND
00:9C74 C905            	   389:   cmp #ASS_OPERAND_ABSOLUTE_INDIRECT
00:9C76 D02D            	   390:   bne ass_value_not_indirectJ
00:9C78 A593            	   391:   lda token_type   ; now we should have a comma or a bracket
00:9C7A C929            	   392:   cmp #')'
00:9C7C F02F            	   393:   beq ass_indirect_with_bracket
                        	   394: ;
                        	   395: ;  We had an opening bracket but not a closing bracket. Must be a comma then
                        	   396: ;
                        	   397: 
00:9C7E A92C            	   398:   lda #','
00:9C80 A220            	   399:   ldx #32  ; ERROR: , expected
00:9C82 20B1D1          	   400:   jsr CHKTKN
                        	   401: ;
                        	   402: ;  now we must have X
                        	   403: ;
00:9C85 20E99C          	   404:   jsr ass_check_we_have_x_or_y
00:9C88 901E            	   405:   bcc ass_bad_indirect
00:9C8A C958            	   406:   cmp #'X'
00:9C8C D01A            	   407:   bne ass_bad_indirect
00:9C8E A902            	   408:   lda #ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
00:9C90 856B            	   409:   sta ASS_OPERAND
00:9C92 A929            	   410:   lda #')'
00:9C94 A216            	   411:   ldx #22  ; ERROR: ) expected
00:9C96 20A1D1          	   412:   jsr GETCHK
00:9C99 209FCB          	   413:   jsr get_token
00:9C9C 203C9E          	   414:   jsr ass_check_no_more_tokens
00:9C9F 20509D          	   415:   jsr opcode_lookup
00:9CA2 4CEA9A          	   416:   jmp ass_finish_line
                        	   417: 
00:9CA5 4C079D          	   418: ass_value_not_indirectJ jmp ass_value_not_indirect
                        	   419: 
                        	   420: ass_bad_indirect:
00:9CA8 A229            	   421:   ldx #41  ; ERROR: illegal addressing mode
00:9CAA 4C2E96          	   422:   jmp ass_error
                        	   423: 
                        	   424: 
                        	   425: ;
                        	   426: ;  we have some sort of indirect expression followed by a bracket, so see if there is ",Y" after it
                        	   427: ;
                        	   428: ass_indirect_with_bracket:
                        	   429: ;
                        	   430: ;  can only be (a), (zp) or (zp),y
                        	   431: ;
00:9CAD 209FCB          	   432:   jsr get_token
00:9CB0 C92C            	   433:   cmp #','
00:9CB2 F00D            	   434:   beq ass_zp_indirect_indexed
00:9CB4 203C9E          	   435:   jsr ass_check_no_more_tokens
00:9CB7 A905            	   436:   lda #ASS_OPERAND_ABSOLUTE_INDIRECT
00:9CB9 856B            	   437:   sta ASS_OPERAND
00:9CBB 20509D          	   438:   jsr opcode_lookup
00:9CBE 4CEA9A          	   439:   jmp ass_finish_line
                        	   440: 
                        	   441: 
                        	   442: ;
                        	   443: ;  For indirect followed by a comma, we must have Y and nothing else
                        	   444: ;  Also, the operand must be a zero-page address
                        	   445: ;
                        	   446: ass_zp_indirect_indexed:
00:9CC1 20E99C          	   447:   jsr ass_check_we_have_x_or_y
00:9CC4 90E2            	   448:   bcc ass_bad_indirect
00:9CC6 C959            	   449:   cmp #'Y'
00:9CC8 D0DE            	   450:   bne ass_bad_indirect
00:9CCA A574            	   451:   lda ASS_VALUE+1
00:9CCC D014            	   452:   bne ass_bad_zp_indirect_indexed
00:9CCE A575            	   453:   lda ASS_VALUE+2
00:9CD0 D010            	   454:   bne ass_bad_zp_indirect_indexed
00:9CD2 A910            	   455:   lda #ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
00:9CD4 856B            	   456:   sta ASS_OPERAND
00:9CD6 209FCB          	   457:   jsr get_token  ; skip the Y
00:9CD9 203C9E          	   458:   jsr ass_check_no_more_tokens
00:9CDC 20509D          	   459:   jsr opcode_lookup
00:9CDF 4CEA9A          	   460:   jmp ass_finish_line
                        	   461: 
                        	   462: ass_bad_zp_indirect_indexed:
00:9CE2 A22B            	   463:   ldx #43
00:9CE4 4C2E96          	   464:   jmp ass_error
                        	   465: 
                        	   466: ass_not_x_or_y:
00:9CE7 18              	   467:   clc
00:9CE8 60              	   468:   rts
                        	   469: 
                        	   470: ;
                        	   471: ;  we had (<expression>),<something> so check that <something> is X or Y
                        	   472: ;   sets carry if it is
                        	   473: ;
                        	   474: ass_check_we_have_x_or_y:
00:9CE9 209FCB          	   475:   jsr get_token
00:9CEC C949            	   476:   cmp #TOKEN_IDENTIFIER
00:9CEE D0F7            	   477:   bne ass_not_x_or_y
00:9CF0 A592            	   478:   lda token_length
00:9CF2 C901            	   479:   cmp #1
00:9CF4 D0F1            	   480:   bne ass_not_x_or_y
00:9CF6 A000            	   481:   ldy #0
00:9CF8 B190            	   482:   lda (token_address),y
00:9CFA 20C191          	   483:   jsr MAKE_UPPER
00:9CFD C959            	   484:   cmp #'Y'
00:9CFF F004            	   485:   beq ass_check_we_have_x_or_y_ok
00:9D01 C958            	   486:   cmp #'X'
00:9D03 D0E2            	   487:   bne ass_not_x_or_y
                        	   488: ass_check_we_have_x_or_y_ok:
00:9D05 38              	   489:   sec
00:9D06 60              	   490:   rts
                        	   491: 
                        	   492: ;
                        	   493: ;  we had a non-indirect expression, so was it followed by a comma?
                        	   494: ;
                        	   495: 
                        	   496: ass_value_not_indirect:
00:9D07 A593            	   497:   lda token_type
00:9D09 C92C            	   498:   cmp #','
00:9D0B F00D            	   499:   beq ass_indexed
00:9D0D A901            	   500:   lda #ASS_OPERAND_ABSOLUTE
00:9D0F 856B            	   501:   sta ASS_OPERAND
                        	   502: ass_value_done:
00:9D11 203C9E          	   503:   jsr ass_check_no_more_tokens
00:9D14 20509D          	   504:   jsr opcode_lookup
00:9D17 4CEA9A          	   505:   jmp ass_finish_line
                        	   506: 
                        	   507: ;
                        	   508: ;  <expression>,X or <expression>,Y is what we are expecting here
                        	   509: ;
                        	   510: ;  OR: in the case of BBR0 ... BBR7 and BBS0 ... BBS7 : another expression
                        	   511: ;
                        	   512: 
                        	   513: ass_indexed:
                        	   514: ;
                        	   515: ;  save the value in case we find a second one
                        	   516: ;
                        	   517: ;  checking for another one may change VALUE so we do this now
                        	   518: ;
00:9D1A A500            	   519:   lda VALUE
00:9D1C 8506            	   520:   sta REMAIN
00:9D1E A501            	   521:   lda VALUE+1
00:9D20 8507            	   522:   sta REMAIN+1
00:9D22 A502            	   523:   lda VALUE+2
00:9D24 8508            	   524:   sta REMAIN+2
00:9D26 20E99C          	   525:   jsr ass_check_we_have_x_or_y
00:9D29 9016            	   526:   bcc ass_absolute_another_value
00:9D2B C958            	   527:   cmp #'X'
00:9D2D F009            	   528:   beq ass_indexed_x
00:9D2F A904            	   529:   lda #ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
00:9D31 856B            	   530:   sta ASS_OPERAND
00:9D33 209FCB          	   531:   jsr get_token ; skip the Y
00:9D36 80D9            	   532:   bra ass_value_done
                        	   533: ass_indexed_x:
00:9D38 A903            	   534:   lda #ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
00:9D3A 856B            	   535:   sta ASS_OPERAND
00:9D3C 209FCB          	   536:   jsr get_token ; skip the X
00:9D3F 80D0            	   537:   bra ass_value_done
                        	   538: 
                        	   539: ;
                        	   540: ;  this is hopefully something like BBR0 $42,foo
                        	   541: ;   so we need to evaluate foo
                        	   542: ;
                        	   543: ass_absolute_another_value:
00:9D41 A593            	   544:   lda token_type ; get token back
00:9D43 20539F          	   545:   jsr ass_get_value  ; should have some sort of address now in VALUE
                        	   546: ;  jsr ass_check_no_more_tokens
00:9D46 A912            	   547:   lda #ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE
00:9D48 856B            	   548:   sta ASS_OPERAND
00:9D4A 20509D          	   549:   jsr opcode_lookup
00:9D4D 4CEA9A          	   550:   jmp ass_finish_line
                        	   551: 
                        	   552: 
                        	   553: ;
                        	   554: ;  look up opcode
                        	   555: ;
                        	   556: opcode_lookup:
                        	   557:   ; the opcode we are looking up
00:9D50 A56C            	   558:   lda OPCODE
00:9D52 8500            	   559:   sta SRCE
00:9D54 A56D            	   560:   lda OPCODE+1
00:9D56 8501            	   561:   sta SRCE+1
00:9D58 6472            	   562:   stz ASS_COUNT   ; count of matches
                        	   563: ;
                        	   564: ;  get the address of our table of tables
                        	   565: ;
00:9D5A A990            	   566:   lda #<OPCODE_LOOKUP_TABLE
00:9D5C 8570            	   567:   sta ASS_OPCODE_WORK
00:9D5E A9A1            	   568:   lda #>OPCODE_LOOKUP_TABLE
00:9D60 8571            	   569:   sta ASS_OPCODE_WORK+1
                        	   570: opcode_lookup_loop:
00:9D62 A000            	   571:   ldy #OPCODE_LOOKUP_OPCODE_LENGTH
00:9D64 B170            	   572:   lda (ASS_OPCODE_WORK),Y       ; get opcode length
00:9D66 F058            	   573:   beq opcode_lookup_loop_done   ; end of table
00:9D68 C56E            	   574:   cmp OPCODE_LEN                ; right length?
00:9D6A F00F            	   575:   beq opcode_lookup_correct_length ; yes
                        	   576: ;
                        	   577: ; no, try the next table item
                        	   578: ;
                        	   579: opcode_lookup_next_table:
00:9D6C 18              	   580:   clc
00:9D6D A570            	   581:   lda ASS_OPCODE_WORK
00:9D6F 6906            	   582:   adc #OPCODE_LOOKUP_TABLE_SIZE  ; onto next item
00:9D71 8570            	   583:   sta ASS_OPCODE_WORK
00:9D73 A571            	   584:   lda ASS_OPCODE_WORK+1
00:9D75 6900            	   585:   adc #0
00:9D77 8571            	   586:   sta ASS_OPCODE_WORK+1
00:9D79 80E7            	   587:   bra opcode_lookup_loop
                        	   588: opcode_lookup_correct_length:
00:9D7B A002            	   589:   ldy #OPCODE_LOOKUP_OPCODE_TABLE
00:9D7D B170            	   590:   lda (ASS_OPCODE_WORK),Y ; get table address low-order byte
00:9D7F 8503            	   591:   sta DEST
00:9D81 C8              	   592:   iny
00:9D82 B170            	   593:   lda (ASS_OPCODE_WORK),Y ; get table address high-order byte
00:9D84 8504            	   594:   sta DEST+1
00:9D86 20C4A0          	   595:   jsr ass_lookup_loop
00:9D89 90E1            	   596:   bcc opcode_lookup_next_table  ; not found
00:9D8B AA              	   597:   tax   ; save the machine code byte
00:9D8C E672            	   598:   inc ASS_COUNT
00:9D8E A001            	   599:   ldy #OPCODE_LOOKUP_OPERAND_TYPE
00:9D90 A56B            	   600:   lda ASS_OPERAND         ; get wanted type of operand?
00:9D92 D170            	   601:   cmp (ASS_OPCODE_WORK),Y ; compare to operand type in table
00:9D94 F013            	   602:   beq opcode_lookup_correct_operand  ; yes
00:9D96 C906            	   603:   cmp #ASS_OPERAND_ACCUMULATOR_A  ; see if in range 1 to 5
00:9D98 B0D2            	   604:   bcs opcode_lookup_next_table
                        	   605: ;
                        	   606: ;  so if we have a so-called ASS_OPERAND_ABSOLUTE (with various indexing modes)
                        	   607: ;  see if we can match on ASS_OPERAND_ZERO_PAGE by adding 10 to the operand type
                        	   608: ;  - also applies to all the absolute modes (1 to 5)
                        	   609: ;
00:9D9A 18              	   610:   clc
00:9D9B 690A            	   611:   adc #10
00:9D9D D170            	   612:   cmp (ASS_OPCODE_WORK),Y
00:9D9F D0CB            	   613:   bne opcode_lookup_next_table
                        	   614: ;
                        	   615: ;  plus, the operand has to be in the zero page
                        	   616: ;
00:9DA1 A574            	   617:   lda ASS_VALUE+1
00:9DA3 D0C7            	   618:   bne opcode_lookup_next_table
00:9DA5 A575            	   619:   lda ASS_VALUE+2
00:9DA7 D0C3            	   620:   bne opcode_lookup_next_table
                        	   621: opcode_lookup_correct_operand:
00:9DA9 8A              	   622:   txa   ; get the byte to emit back
                        	   623: 
                        	   624: ;
                        	   625: ; we have a match! emit the opcode
                        	   626: ;
00:9DAA 20E8A0          	   627:   jsr ass_emit            ; emit it
00:9DAD A004            	   628:   ldy #OPCODE_LOOKUP_HANDLER  ; offset of handler
00:9DAF B170            	   629:   lda (ASS_OPCODE_WORK),Y ; get opcode handler address low-order byte
00:9DB1 AA              	   630:   tax
00:9DB2 C8              	   631:   iny
00:9DB3 B170            	   632:   lda (ASS_OPCODE_WORK),Y ; get opcode handler address high-order byte
00:9DB5 F008            	   633:   beq opcode_lookup_no_handler
00:9DB7 8571            	   634:   sta ASS_OPCODE_WORK+1
00:9DB9 8A              	   635:   txa
00:9DBA 8570            	   636:   sta ASS_OPCODE_WORK
00:9DBC 6C7000          	   637:   jmp (ASS_OPCODE_WORK)   ; do handler - it will RTS for us
                        	   638: 
                        	   639: opcode_lookup_no_handler:
                        	   640: ; put nothing here as it won't be done if there is a handler
00:9DBF 60              	   641:   rts    ; done!
                        	   642: 
                        	   643: opcode_lookup_loop_done:
                        	   644: ;
                        	   645: ;  look for assembler directives
                        	   646: ;
00:9DC0 A933            	   647:   lda #<DIRECTIVES
00:9DC2 8503            	   648:   sta DEST
00:9DC4 A9A2            	   649:   lda #>DIRECTIVES
00:9DC6 8504            	   650:   sta DEST+1
00:9DC8 A56E            	   651:   lda OPCODE_LEN
                        	   652: 
                        	   653: ;  pha
                        	   654: ;   lda #'c'
                        	   655: ;   jsr ass_debug_point
                        	   656: ;   pla
                        	   657: 
00:9DCA 200791          	   658:   jsr handlerLookup
00:9DCD 9029            	   659:   bcc opcode_lookup_ok
                        	   660: 
                        	   661: ;   lda #'d'
                        	   662: ;   jsr ass_debug_point
                        	   663: 
                        	   664: ;
                        	   665: ;  here for unknown opcode
                        	   666: ;
00:9DCF A56C            	   667:   lda OPCODE
00:9DD1 8590            	   668:   sta token_address
00:9DD3 A56D            	   669:   lda OPCODE+1
00:9DD5 8591            	   670:   sta token_address+1
00:9DD7 A56E            	   671:   lda OPCODE_LEN
00:9DD9 8592            	   672:   sta token_length
                        	   673: 
                        	   674: ;
                        	   675: ;  if we NEVER found a match, this is an illegal opcode
                        	   676: ;
00:9DDB A921            	   677:   lda #'!'
00:9DDD 20B395          	   678:   jsr COUT
00:9DE0 A66E            	   679:   ldx OPCODE_LEN
00:9DE2 A000            	   680:   ldy #0
                        	   681: wtf_loop:
00:9DE4 B16C            	   682:    lda (OPCODE),Y
00:9DE6 20B395          	   683:    jsr COUT
00:9DE9 C8              	   684:    iny
00:9DEA CA              	   685:    dex
00:9DEB D0F7            	   686:    bne wtf_loop
                        	   687: 
                        	   688: 
00:9DED A228            	   689:   ldx  #40    ; illegal opcode
00:9DEF A572            	   690:   lda ASS_COUNT
00:9DF1 F002            	   691:   beq opcode_lookup_loop_unknown
                        	   692: ;
                        	   693: ;  if we found a match, but not for this addressing mode, they used an illegal mode
                        	   694: ;
00:9DF3 A229            	   695:   ldx  #41   ; illegal addressing mode
                        	   696: opcode_lookup_loop_unknown:
00:9DF5 4C2E96          	   697:   JMP  ass_error
                        	   698: 
                        	   699: opcode_lookup_ok:
                        	   700: 
                        	   701: ;   lda #'e'
                        	   702: ; jsr ass_debug_point
                        	   703: 
00:9DF8 60              	   704:   rts
                        	   705: 
                        	   706: ass_done:
00:9DF9 202594          	   707:   jsr  CROUT
00:9DFC A576            	   708:   LDA  ASS_PASS
00:9DFE D003            	   709:   bne  ass_done_second_pass
00:9E00 4CCB9A          	   710:   jmp  ASSEMBLE_SECOND_PASS
                        	   711: ass_done_second_pass:
00:9E03 A91E            	   712:   LDA  #<ass_done_message  ; Assemble finished: No Errors
00:9E05 A29E            	   713:   LDX  #>ass_done_message
00:9E07 202682          	   714:   JSR  print
00:9E0A A910            	   715:   lda  #FLAG_VALID_ASSEMBLE
00:9E0C 04BE            	   716:   tsb  system_flags
00:9E0E 204E8E          	   717:   jsr  show_symbol_table_end
00:9E11 20738E          	   718:   jsr  show_source_end
00:9E14 A582            	   719:   lda  show_symbols
00:9E16 F003            	   720:   beq  ass_done1
00:9E18 20D7A7          	   721:   jsr  list_symbols
                        	   722: ass_done1:
00:9E1B 4C7282          	   723:   JMP  main_prompt
                        	   724: 
00:9E1E 417373656D626C65	   725: ass_done_message asciiz "Assemble finished: No errors\n"
00:9E26 2066696E69736865
00:9E2E 643A204E6F206572
00:9E36 726F72730A
00:9E3B 00
                        	   726: 
                        	   727: ass_check_no_more_tokens:
00:9E3C A593            	   728:   lda token_type
00:9E3E C90A            	   729:   cmp #NL           ; or end of line?
00:9E40 F005            	   730:   beq ass_check_no_more_tokens_ok
00:9E42 A213            	   731:   ldx #19    ; ERROR: incorrect symbol
00:9E44 4C2E96          	   732:   jmp ass_error
                        	   733: 
                        	   734: ass_check_no_more_tokens_ok:
00:9E47 60              	   735:   rts
                        	   736: 
                        	   737: ;
                        	   738: ;  push a 3-byte value (in VALUE) onto the evaluation stack
                        	   739: ;    changes A and Y
                        	   740: ;
                        	   741: exp_push_value = *
00:9E48 A57B            	   742:   lda exp_value_stack_count
00:9E4A C9FF            	   743:   cmp #$FF
00:9E4C D005            	   744:   bne exp_push_value_ok
                        	   745: exp_push_value_memory_full:
00:9E4E A22E            	   746:   ldx #46   ; ERROR: Expression too complex
00:9E50 4C2E96          	   747:   jmp ass_error
                        	   748: exp_push_value_ok:
00:9E53 E67B            	   749:   inc exp_value_stack_count
00:9E55 38              	   750:   sec
00:9E56 A579            	   751:   lda exp_value_stack
00:9E58 E903            	   752:   sbc #3
00:9E5A 8579            	   753:   sta exp_value_stack
00:9E5C A57A            	   754:   lda exp_value_stack+1
00:9E5E E900            	   755:   sbc #0
00:9E60 857A            	   756:   sta exp_value_stack+1
                        	   757: ;
                        	   758: ;  has our expression value fallen down into our P-codes?
                        	   759: ;
                        	   760: ;  This doesn't work if the output (PCODE) has been relocated to above
                        	   761: ;  the symbol table and I can't think of an easy solution, so let's ignore
                        	   762: ;  it and hope it doesn't happen.
                        	   763: ;
                        	   764: ;
                        	   765: ; lda  PCODE+1               ; see if P-codes full
                        	   766: ; cmp  exp_value_stack+1     ; in other words, have we hit the symbol table?
                        	   767: ; bcc  exp_push_value_not_full      ; less than
                        	   768: ; bne  exp_push_value_memory_full   ; greater than
                        	   769: ; lda  PCODE
                        	   770: ; cmp  exp_value_stack
                        	   771: ; bcs  exp_push_value_memory_full   ; BGE
                        	   772: 
                        	   773: exp_push_value_not_full:
00:9E62 A000            	   774:   ldy #0
00:9E64 A500            	   775:   lda VALUE
00:9E66 9179            	   776:   sta (exp_value_stack),y
00:9E68 C8              	   777:   iny
00:9E69 A501            	   778:   lda VALUE+1
00:9E6B 9179            	   779:   sta (exp_value_stack),y
00:9E6D C8              	   780:   iny
00:9E6E A502            	   781:   lda VALUE+2
00:9E70 9179            	   782:   sta (exp_value_stack),y
00:9E72 60              	   783:   rts
                        	   784: 
                        	   785: ;
                        	   786: ;  pop a 3-byte value (into VALUE) from the evaluation stack
                        	   787: ;    changes A and Y
                        	   788: ;
                        	   789: exp_pop_value = *
00:9E73 A57B            	   790:   lda exp_value_stack_count
00:9E75 D005            	   791:   bne exp_pop_value_ok
00:9E77 A217            	   792:   ldx #23    ; ERROR: illegal factor
00:9E79 4C2E96          	   793:   jmp ass_error
                        	   794: exp_pop_value_ok:
00:9E7C C67B            	   795:   dec exp_value_stack_count
00:9E7E A000            	   796:   ldy #0
00:9E80 B179            	   797:   lda (exp_value_stack),y
00:9E82 8500            	   798:   sta VALUE
00:9E84 C8              	   799:   iny
00:9E85 B179            	   800:   lda (exp_value_stack),y
00:9E87 8501            	   801:   sta VALUE+1
00:9E89 C8              	   802:   iny
00:9E8A B179            	   803:   lda (exp_value_stack),y
00:9E8C 8502            	   804:   sta VALUE+2
00:9E8E 18              	   805:   clc
00:9E8F A579            	   806:   lda exp_value_stack
00:9E91 6903            	   807:   adc #3
00:9E93 8579            	   808:   sta exp_value_stack
00:9E95 A57A            	   809:   lda exp_value_stack+1
00:9E97 6900            	   810:   adc #0
00:9E99 857A            	   811:   sta exp_value_stack+1
00:9E9B 60              	   812:   rts
                        	   813: 
                        	   814: ;
                        	   815: ;  I needed a work area for operators, and initially used INBUF however that got
                        	   816: ;  repurposed for managing strings (in particular handling \Xnn and double quotes)
                        	   817: ;  so now I am using the memory at the current PCODE address as a work area.
                        	   818: ;  It is only needed during expression evaluation, and should hopefully be available.
                        	   819: ;
                        	   820: ;
                        	   821: ;  push an operator (A) onto the operator stack
                        	   822: ;   changes X and Y
                        	   823: ;
                        	   824: exp_push_operator:
00:9E9C A67C            	   825:   ldx exp_operator_stack_count
00:9E9E E0FA            	   826:   cpx #250  ; make sure we don't overflow our operator stack
00:9EA0 9005            	   827:   bcc exp_push_operator_ok
00:9EA2 A22E            	   828:   ldx #46   ; ERROR: Expression too complex
00:9EA4 4C2E96          	   829:   jmp ass_error
                        	   830: exp_push_operator_ok:
00:9EA7 E67C            	   831:   inc exp_operator_stack_count  ; add, then store
00:9EA9 A47C            	   832:   ldy exp_operator_stack_count
00:9EAB 9123            	   833:   sta (PCODE),Y
00:9EAD 60              	   834:   rts
                        	   835: 
                        	   836: ;
                        	   837: ;  pop an operator (into A) from the operator stack
                        	   838: ;   changes X and Y
                        	   839: ;
                        	   840: exp_pop_operator:
00:9EAE A67C            	   841:   ldx exp_operator_stack_count
00:9EB0 D005            	   842:   bne exp_pop_operator_ok
00:9EB2 A217            	   843:   ldx #23   ; ERROR: Illegal factor
00:9EB4 4C2E96          	   844:   jmp ass_error
                        	   845: exp_pop_operator_ok:
00:9EB7 A47C            	   846:   ldy exp_operator_stack_count  ; retrieve, then decrement
00:9EB9 B123            	   847:   lda (PCODE),Y
00:9EBB C67C            	   848:   dec exp_operator_stack_count
00:9EBD 60              	   849:   rts
                        	   850: 
                        	   851: ;
                        	   852: ;  get an operator (into A) from the operator stack (without removing it)
                        	   853: ;   changes X and Y
                        	   854: ;
                        	   855: exp_get_operator:
00:9EBE A67C            	   856:   ldx exp_operator_stack_count
00:9EC0 D005            	   857:   bne exp_get_operator_ok
00:9EC2 A217            	   858:   ldx #23   ; ERROR: Illegal factor
00:9EC4 4C2E96          	   859:   jmp ass_error
                        	   860: exp_get_operator_ok:
00:9EC7 A47C            	   861:   ldy exp_operator_stack_count
00:9EC9 B123            	   862:   lda (PCODE),Y
00:9ECB 60              	   863:   rts
                        	   864: 
                        	   865:  .macro makePrecedenceTable ; table of operators, precedence, handler
                        	   866:    dfb   \1
                        	   867:    dfb   \2
                        	   868:    word  \3
                        	   869:  .endmacro
                        	   870: 
                        	   871: ; cannot have more than 64 entries because we index into this with X
                        	   872: exp_precedence_table:
                        	   873:   makePrecedenceTable '~', 1, exp_negate
00:9ECC 7E              	     1M    dfb   '~'
00:9ECD 01              	     2M    dfb   1
00:9ECE 6FAE            	     3M    word  exp_negate
                        	   874:   makePrecedenceTable '!', 1, exp_not
00:9ED0 21              	     1M    dfb   '!'
00:9ED1 01              	     2M    dfb   1
00:9ED2 82AE            	     3M    word  exp_not
                        	   875:   makePrecedenceTable TOKEN_UNARY_MINUS, 1, exp_unary_minus
00:9ED4 4D              	     1M    dfb   TOKEN_UNARY_MINUS
00:9ED5 01              	     2M    dfb   1
00:9ED6 90AE            	     3M    word  exp_unary_minus
                        	   876:   makePrecedenceTable TOKEN_LOW_BYTE, 1, exp_low_byte
00:9ED8 56              	     1M    dfb   TOKEN_LOW_BYTE
00:9ED9 01              	     2M    dfb   1
00:9EDA A4AE            	     3M    word  exp_low_byte
                        	   877:   makePrecedenceTable TOKEN_HIGH_BYTE, 1, exp_high_byte
00:9EDC 57              	     1M    dfb   TOKEN_HIGH_BYTE
00:9EDD 01              	     2M    dfb   1
00:9EDE A9AE            	     3M    word  exp_high_byte
                        	   878:   makePrecedenceTable TOKEN_SHIFT_LEFT, 2, exp_shift_left
00:9EE0 4C              	     1M    dfb   TOKEN_SHIFT_LEFT
00:9EE1 02              	     2M    dfb   2
00:9EE2 3DAE            	     3M    word  exp_shift_left
                        	   879:   makePrecedenceTable TOKEN_SHIFT_RIGHT, 2, exp_shift_right
00:9EE4 52              	     1M    dfb   TOKEN_SHIFT_RIGHT
00:9EE5 02              	     2M    dfb   2
00:9EE6 56AE            	     3M    word  exp_shift_right
                        	   880:   makePrecedenceTable '&', 3, exp_bitwise_and
00:9EE8 26              	     1M    dfb   '&'
00:9EE9 03              	     2M    dfb   3
00:9EEA ECAD            	     3M    word  exp_bitwise_and
                        	   881:   makePrecedenceTable '^', 4, exp_bitwise_xor
00:9EEC 5E              	     1M    dfb   '^'
00:9EED 04              	     2M    dfb   4
00:9EEE 01AE            	     3M    word  exp_bitwise_xor
                        	   882:   makePrecedenceTable '|', 5, exp_bitwise_or
00:9EF0 7C              	     1M    dfb   '|'
00:9EF1 05              	     2M    dfb   5
00:9EF2 D7AD            	     3M    word  exp_bitwise_or
                        	   883:   makePrecedenceTable '*', 6, exp_multiply
00:9EF4 2A              	     1M    dfb   '*'
00:9EF5 06              	     2M    dfb   6
00:9EF6 17AF            	     3M    word  exp_multiply
                        	   884:   makePrecedenceTable '/', 6, exp_divide
00:9EF8 2F              	     1M    dfb   '/'
00:9EF9 06              	     2M    dfb   6
00:9EFA 50AF            	     3M    word  exp_divide
                        	   885:   makePrecedenceTable '%', 6, exp_modulo
00:9EFC 25              	     1M    dfb   '%'
00:9EFD 06              	     2M    dfb   6
00:9EFE B0AF            	     3M    word  exp_modulo
                        	   886:   makePrecedenceTable '+', 7, exp_add
00:9F00 2B              	     1M    dfb   '+'
00:9F01 07              	     2M    dfb   7
00:9F02 49AD            	     3M    word  exp_add
                        	   887:   makePrecedenceTable '-', 7, exp_subtract
00:9F04 2D              	     1M    dfb   '-'
00:9F05 07              	     2M    dfb   7
00:9F06 5DAD            	     3M    word  exp_subtract
                        	   888:   makePrecedenceTable '<', 8, exp_less_than
00:9F08 3C              	     1M    dfb   '<'
00:9F09 08              	     2M    dfb   8
00:9F0A ABAD            	     3M    word  exp_less_than
                        	   889:   makePrecedenceTable '>', 8, exp_greater_than
00:9F0C 3E              	     1M    dfb   '>'
00:9F0D 08              	     2M    dfb   8
00:9F0E B2AD            	     3M    word  exp_greater_than
                        	   890:   makePrecedenceTable TOKEN_LEQ, 8, exp_leq
00:9F10 80              	     1M    dfb   TOKEN_LEQ
00:9F11 08              	     2M    dfb   8
00:9F12 C1AD            	     3M    word  exp_leq
                        	   891:   makePrecedenceTable TOKEN_GEQ, 8, exp_geq
00:9F14 81              	     1M    dfb   TOKEN_GEQ
00:9F15 08              	     2M    dfb   8
00:9F16 D0AD            	     3M    word  exp_geq
                        	   892:   makePrecedenceTable TOKEN_EQUALITY, 9, exp_eql
00:9F18 45              	     1M    dfb   TOKEN_EQUALITY
00:9F19 09              	     2M    dfb   9
00:9F1A 83AD            	     3M    word  exp_eql
                        	   893:   makePrecedenceTable TOKEN_NEQ, 9, exp_neq     ; <>
00:9F1C 55              	     1M    dfb   TOKEN_NEQ
00:9F1D 09              	     2M    dfb   9
00:9F1E 97AD            	     3M    word  exp_neq     
                        	   894:   makePrecedenceTable TOKEN_INEQUALITY, 9, exp_neq  ; !=
00:9F20 5A              	     1M    dfb   TOKEN_INEQUALITY
00:9F21 09              	     2M    dfb   9
00:9F22 97AD            	     3M    word  exp_neq  
                        	   895:   makePrecedenceTable TOKEN_LOGICAL_AND, 10, exp_logical_and
00:9F24 58              	     1M    dfb   TOKEN_LOGICAL_AND
00:9F25 0A              	     2M    dfb   10
00:9F26 2BAE            	     3M    word  exp_logical_and
                        	   896:   makePrecedenceTable TOKEN_LOGICAL_OR, 11, exp_logical_or
00:9F28 59              	     1M    dfb   TOKEN_LOGICAL_OR
00:9F29 0B              	     2M    dfb   11
00:9F2A 1CAE            	     3M    word  exp_logical_or
                        	   897: 
                        	   898: exp_precedence_table_end = *
                        	   899: 
                        	   900: ;
                        	   901: ;  finds precedence of operator in A, returns it in Y (returns 0 if not found)
                        	   902: ;    changes X, A
                        	   903: ;  also stores the operator evaluation function (eg. exp_add) in exp_evaluation_function
                        	   904: ;
                        	   905: exp_get_precedence:
00:9F2C A200            	   906:   ldx #0
                        	   907: exp_get_precedence_loop:
00:9F2E DDCC9E          	   908:   cmp exp_precedence_table,x
00:9F31 F00F            	   909:   beq exp_get_precedence_found
00:9F33 E8              	   910:   inx   ; skip operator
00:9F34 E8              	   911:   inx   ; skip precedence
00:9F35 E8              	   912:   inx   ; skip evaluation function
00:9F36 E8              	   913:   inx   ;  (2 bytes)
00:9F37 E060            	   914:   cpx #exp_precedence_table_end - exp_precedence_table
00:9F39 90F3            	   915:   bcc exp_get_precedence_loop
00:9F3B A000            	   916:   ldy #0
00:9F3D 647F            	   917:   stz exp_evaluation_function
00:9F3F 6480            	   918:   stz exp_evaluation_function+1
00:9F41 60              	   919:   rts
                        	   920: exp_get_precedence_found:
00:9F42 E8              	   921:   inx
00:9F43 BCCC9E          	   922:   ldy exp_precedence_table,x
00:9F46 E8              	   923:   inx
00:9F47 BDCC9E          	   924:   lda exp_precedence_table,x
00:9F4A 857F            	   925:   sta exp_evaluation_function
00:9F4C E8              	   926:   inx
00:9F4D BDCC9E          	   927:   lda exp_precedence_table,x
00:9F50 8580            	   928:   sta exp_evaluation_function+1
00:9F52 60              	   929:   rts
                        	   930: 
                        	   931: ;
                        	   932: ;  Convert an expression into a value
                        	   933: ;
                        	   934: ;   Ideas from https://www.geeksforgeeks.org/expression-evaluation/
                        	   935: ;
                        	   936: ass_get_value:
                        	   937: ;
                        	   938: ;  set up expression evaluation stack
                        	   939: ;
00:9F53 647B            	   940:   stz exp_value_stack_count
00:9F55 647C            	   941:   stz exp_operator_stack_count
00:9F57 A531            	   942:   lda ENDSYM
00:9F59 8579            	   943:   sta exp_value_stack
00:9F5B A532            	   944:   lda ENDSYM+1
00:9F5D 857A            	   945:   sta exp_value_stack+1
                        	   946: 
00:9F5F 6473            	   947:   stz ASS_VALUE
00:9F61 6474            	   948:   stz ASS_VALUE+1
00:9F63 6475            	   949:   stz ASS_VALUE+2
00:9F65 A901            	   950:   lda #1
00:9F67 8581            	   951:   sta exp_unary_ok  ; unary operators can appear at the start of the expression
00:9F69 A593            	   952:   lda token_type
                        	   953: ;  jsr START_TRACE
                        	   954: ;
                        	   955: ;  one token lookahead
                        	   956: ;
00:9F6B 8003            	   957:   bra ass_expression_loop_initial
                        	   958: 
                        	   959: ;
                        	   960: ;  1.1 Get the next token
                        	   961: ;
                        	   962: ass_expression_loop:
00:9F6D 209FCB          	   963:   jsr get_token
                        	   964: ass_expression_loop_initial:
                        	   965: 
                        	   966: ;
                        	   967: ;  1.2.1 If it's a number, push onto the value stack
                        	   968: ;
00:9F70 C94E            	   969:   cmp #TOKEN_NUMBER
00:9F72 D013            	   970:   bne ass_expression_loop1a
                        	   971: ass_expression_number:
00:9F74 A594            	   972:   lda token_value
00:9F76 8500            	   973:   sta VALUE
00:9F78 A595            	   974:   lda token_value+1
00:9F7A 8501            	   975:   sta VALUE+1
00:9F7C A596            	   976:   lda token_value+2
00:9F7E 8502            	   977:   sta VALUE+2
00:9F80 20489E          	   978:   jsr exp_push_value
00:9F83 6481            	   979:   stz exp_unary_ok          ; don't have unary operators after numbers
00:9F85 80E6            	   980:   bra ass_expression_loop
                        	   981: ;
                        	   982: ;  if it's a string and only 1 or 2 bytes, consider as a number
                        	   983: ;
                        	   984: ass_expression_loop1a:
00:9F87 C922            	   985:   cmp #TOKEN_STRING
00:9F89 D013            	   986:   bne ass_expression_loop1
00:9F8B A592            	   987:   lda token_length
00:9F8D C903            	   988:   cmp #3
00:9F8F B008            	   989:   bcs ass_expression_not_small_string  ; too long?
                        	   990: ;
                        	   991: ;  one or two character string - is this an immediate operand?
                        	   992: ;
00:9F91 A56B            	   993:   lda ASS_OPERAND
00:9F93 C907            	   994:   cmp #ASS_OPERAND_IMMEDIATE
00:9F95 D002            	   995:   bne ass_expression_not_small_string
00:9F97 80DB            	   996:   bra ass_expression_number   ; treat as a number (its value should be in VALUE)
                        	   997: 
                        	   998: ass_expression_not_small_string:
00:9F99 A21D            	   999:   ldx #29     ; string literal too big
00:9F9B 4C2E96          	  1000:   jmp ass_error
                        	  1001: 
                        	  1002: ;
                        	  1003: ;  1.2.2 If it's an identifier, get its value and push onto the value stack
                        	  1004: ;
                        	  1005: ass_expression_loop1:
00:9F9E C949            	  1006:   cmp #TOKEN_IDENTIFIER
00:9FA0 D029            	  1007:   bne ass_expression_loop2
00:9FA2 6481            	  1008:   stz exp_unary_ok          ; don't have unary operators after identifiers
                        	  1009: 
00:9FA4 200CC9          	  1010:   jsr SEARCH    ; should be in symbol table as a constant, and the value in VALUE
00:9FA7 D011            	  1011:   bne ass_expression_found_value
00:9FA9 A576            	  1012:   lda ASS_PASS
00:9FAB F005            	  1013:   beq ass_label_not_found_yet
                        	  1014: 
                        	  1015: ;
                        	  1016: ; it's an error if it isn't there on the second pass
                        	  1017: ;
00:9FAD A20B            	  1018:   ldx #11  ; ERROR: Undeclared Identifier
00:9FAF 4C2E96          	  1019:   jmp ass_error
                        	  1020: 
                        	  1021: ;
                        	  1022: ;  label not found on first pass, make the value 0x6666 for now
                        	  1023: ;   - we don't want a zero-page address assumption because that
                        	  1024: ;     will throw out opcode lengths (it might assume a zero page opcode
                        	  1025: ;     which is shorter and then change it to a longer one)
                        	  1026: ;
                        	  1027: ass_label_not_found_yet:
00:9FB2 A966            	  1028:   lda #$66
00:9FB4 8500            	  1029:   sta VALUE
00:9FB6 8501            	  1030:   sta VALUE+1
00:9FB8 6402            	  1031:   stz VALUE+2
                        	  1032: ass_expression_found_value:
00:9FBA A594            	  1033:   lda token_value
00:9FBC 8500            	  1034:   sta VALUE
00:9FBE A595            	  1035:   lda token_value+1
00:9FC0 8501            	  1036:   sta VALUE+1
00:9FC2 A596            	  1037:   lda token_value+2
00:9FC4 8502            	  1038:   sta VALUE+2
00:9FC6 20489E          	  1039:   jsr exp_push_value
00:9FC9 80A2            	  1040:   bra ass_expression_loop
                        	  1041: 
                        	  1042: ;
                        	  1043: ; 1.2.3 If it's a left parenthesis: push it onto the operator stack.
                        	  1044: ;
                        	  1045: ass_expression_loop2:
00:9FCB C928            	  1046:   cmp #'('
00:9FCD D00B            	  1047:   bne ass_expression_loop3
00:9FCF 48              	  1048:   pha
00:9FD0 A901            	  1049:   lda  #1
00:9FD2 8581            	  1050:   sta exp_unary_ok          ; unary operators can follow left parentheses
00:9FD4 68              	  1051:   pla
                        	  1052: 
00:9FD5 209C9E          	  1053:   jsr exp_push_operator
00:9FD8 8093            	  1054:   bra ass_expression_loop
                        	  1055: 
                        	  1056: ;
                        	  1057: ;  1.2.4 A right parenthesis:
                        	  1058: ;       1 While the thing on top of the operator stack is not a
                        	  1059: ;         left parenthesis,
                        	  1060: ;           1 Pop the operator from the operator stack.
                        	  1061: ;           2 Pop the value stack twice, getting two operands.
                        	  1062: ;           3 Apply the operator to the operands, in the correct order.
                        	  1063: ;           4 Push the result onto the value stack.
                        	  1064: ;        2 Pop the left parenthesis from the operator stack, and discard it.
                        	  1065: 
                        	  1066: 
                        	  1067: ass_expression_loop3:
00:9FDA C929            	  1068:   cmp #')'
00:9FDC D016            	  1069:   bne ass_expression_loop4
                        	  1070: ass_expression_loop3b:
                        	  1071: ;
                        	  1072: ;  a RH parenthesis with an empty operator stack is probably the end of the expression, eg. ($1234),x
                        	  1073: ;  where the ")" belongs to the indexed operand stuff and not the expression
                        	  1074: ;
00:9FDE A57C            	  1075:   lda exp_operator_stack_count
00:9FE0 F078            	  1076:   beq exp_no_operators_left
00:9FE2 20BE9E          	  1077:   jsr exp_get_operator
00:9FE5 C928            	  1078:   cmp #'('
00:9FE7 F005            	  1079:   beq ass_expression_loop3c
                        	  1080: ;
                        	  1081: ;  not a left parenthesis
                        	  1082: ;
                        	  1083: ass_expression_loop3a:
00:9FE9 2080A0          	  1084:   jsr ass_expression_apply_operator ; pop the operator and two values, apply the operator and push the result
00:9FEC 80F0            	  1085:   bra ass_expression_loop3b          ; keep going until we don't have a left parenthesis
                        	  1086: 
                        	  1087: ass_expression_loop3c:
00:9FEE 20AE9E          	  1088:   jsr exp_pop_operator              ;  2 Pop the left parenthesis from the operator stack, and discard it.
                        	  1089: ass_expression_loopJ:
00:9FF1 4C6D9F          	  1090:   jmp ass_expression_loop
                        	  1091: 
                        	  1092: ;       1.2.5 An operator (call it thisOp):
                        	  1093: ;         1 While the operator stack is not empty, and the top thing on the
                        	  1094: ;           operator stack has the same or greater precedence as thisOp,
                        	  1095: ;           1 Pop the operator from the operator stack.
                        	  1096: ;           2 Pop the value stack twice, getting two operands.
                        	  1097: ;           3 Apply the operator to the operands, in the correct order.
                        	  1098: ;           4 Push the result onto the value stack.
                        	  1099: ;         2 Push thisOp onto the operator stack.
                        	  1100: 
                        	  1101: ass_expression_loop4:
                        	  1102: ;
                        	  1103: ;  look for unary operators
                        	  1104: ;
00:9FF4 A681            	  1105:   ldx exp_unary_ok
00:9FF6 F034            	  1106:   beq ass_expression_cannot_be_unary
00:9FF8 C92D            	  1107:   cmp #'-'
00:9FFA D006            	  1108:   bne ass_not_unary_minus
00:9FFC A94D            	  1109:   lda #TOKEN_UNARY_MINUS
00:9FFE 8593            	  1110:   sta token_type
00:A000 802A            	  1111:   bra ass_expression_cannot_be_unary
                        	  1112: ass_not_unary_minus:
00:A002 C93C            	  1113:   cmp #'<'
00:A004 D006            	  1114:   bne ass_not_unary_less_than
00:A006 A956            	  1115:   lda #TOKEN_LOW_BYTE
00:A008 8593            	  1116:   sta token_type
00:A00A 8020            	  1117:   bra ass_expression_cannot_be_unary
                        	  1118: ass_not_unary_less_than:
00:A00C C93E            	  1119:   cmp #'>'
00:A00E D006            	  1120:   bne ass_not_unary_greater_than
00:A010 A957            	  1121:   lda #TOKEN_HIGH_BYTE
00:A012 8593            	  1122:   sta token_type
00:A014 8000            	  1123:   bra ass_not_unary_greater_than
                        	  1124: ass_not_unary_greater_than:
00:A016 C92A            	  1125:   cmp #'*'
00:A018 D012            	  1126:   bne ass_expression_cannot_be_unary
                        	  1127: ;
                        	  1128: ;  A '*' where a unary expression is allowed will be the current emit address (eg. foo = *)
                        	  1129: ;
00:A01A A523            	  1130:   lda PCODE
00:A01C 8594            	  1131:   sta token_value
00:A01E A524            	  1132:   lda PCODE+1
00:A020 8595            	  1133:   sta token_value+1
00:A022 6496            	  1134:   stz token_value+2
00:A024 6481            	  1135:   stz exp_unary_ok          ; don't have unary operators after numbers
00:A026 A94E            	  1136:   lda #TOKEN_NUMBER
00:A028 8593            	  1137:   sta token_type            ; make get_token think a sign as a token on its own
00:A02A 808E            	  1138:   bra ass_expression_found_value
                        	  1139: 
                        	  1140: ass_expression_cannot_be_unary:
00:A02C 48              	  1141:   pha
00:A02D A901            	  1142:   lda #1
00:A02F 8581            	  1143:   sta exp_unary_ok          ; can have unary operators after operators
00:A031 68              	  1144:   pla
                        	  1145: 
00:A032 202C9F          	  1146:   jsr exp_get_precedence
00:A035 847E            	  1147:   sty exp_operator_precedence ; thisOp's precedence
00:A037 C000            	  1148:   cpy #0
00:A039 F01F            	  1149:   beq exp_no_operators_left
                        	  1150: 
                        	  1151: ass_expression_loop7:         ; 1 While the operator stack is not empty
00:A03B A57C            	  1152:   lda exp_operator_stack_count
00:A03D F013            	  1153:   beq ass_expression_loop6    ; stack empty
00:A03F 20BE9E          	  1154:   jsr exp_get_operator    ; find the top thing on the operator stack
00:A042 C928            	  1155:   cmp #'('                ; if a bracket, consider that low precedence
00:A044 F00C            	  1156:   beq ass_expression_loop6
00:A046 202C9F          	  1157:   jsr exp_get_precedence  ; and its precedence
00:A049 C47E            	  1158:   cpy exp_operator_precedence
00:A04B B005            	  1159:   bcs ass_expression_loop6  ; thing on top has less precedence (a higher value) than thisOp
00:A04D 2080A0          	  1160:   jsr ass_expression_apply_operator  ; pop the operator and two values, apply the operator and push the result
00:A050 80E9            	  1161:   bra ass_expression_loop7
                        	  1162: 
                        	  1163: ass_expression_loop6:
00:A052 A593            	  1164:   lda token_type       ; thisOp
00:A054 209C9E          	  1165:   jsr exp_push_operator
00:A057 4C6D9F          	  1166:   jmp ass_expression_loop
                        	  1167: 
                        	  1168: 
                        	  1169: ; 2. While the operator stack is not empty,
                        	  1170: ;     1 Pop the operator from the operator stack.
                        	  1171: ;     2 Pop the value stack twice, getting two operands.
                        	  1172: ;     3 Apply the operator to the operands, in the correct order.
                        	  1173: ;     4 Push the result onto the value stack.
                        	  1174: 
                        	  1175: 
                        	  1176: exp_no_operators_left:
00:A05A A57C            	  1177:     lda exp_operator_stack_count
00:A05C F005            	  1178:     beq exp_done
00:A05E 2080A0          	  1179:     jsr ass_expression_apply_operator ; pop the operator and two values, apply the operator and push the result
00:A061 80F7            	  1180:     bra exp_no_operators_left
                        	  1181: 
                        	  1182: exp_done:
00:A063 A57B            	  1183:       lda exp_value_stack_count
00:A065 C901            	  1184:       cmp #1
00:A067 F005            	  1185:       beq exp_done_ok
                        	  1186: exp_done_error:
00:A069 A217            	  1187:       ldx #23       ; ERROR: Illegal factor
00:A06B 4C2E96          	  1188:       jmp ass_error
                        	  1189: 
                        	  1190: exp_done_ok:
00:A06E A57C            	  1191:       lda exp_operator_stack_count
00:A070 D0F7            	  1192:       bne exp_done_error
00:A072 20739E          	  1193:       jsr exp_pop_value   ; pop the finished value
00:A075 A500            	  1194:       lda VALUE
00:A077 8573            	  1195:       sta ASS_VALUE
00:A079 A501            	  1196:       lda VALUE+1
00:A07B 8574            	  1197:       sta ASS_VALUE+1
00:A07D 6475            	  1198:       stz ASS_VALUE+2   ; make high-order byte zero just in case
00:A07F 60              	  1199:       rts
                        	  1200: 
                        	  1201: ;
                        	  1202: ;
                        	  1203: ;     1 Pop the operator from the operator stack.
                        	  1204: ;     2 Pop the value stack twice, getting two operands.
                        	  1205: ;     3 Apply the operator to the operands, in the correct order.
                        	  1206: ;     4 Push the result onto the value stack.
                        	  1207: 
                        	  1208: ;
                        	  1209: ass_expression_apply_operator:
00:A080 20739E          	  1210:   jsr exp_pop_value         ; 2 Pop the value stack twice, getting two operands.
00:A083 20BE9E          	  1211:   jsr exp_get_operator
00:A086 C97E            	  1212:   cmp #'~'
00:A088 F01F            	  1213:   beq ass_expression_unary
00:A08A C921            	  1214:   cmp #'!'
00:A08C F01B            	  1215:   beq ass_expression_unary
00:A08E C94D            	  1216:   cmp #TOKEN_UNARY_MINUS
00:A090 F017            	  1217:   beq ass_expression_unary
00:A092 C956            	  1218:   cmp #TOKEN_LOW_BYTE
00:A094 F013            	  1219:   beq ass_expression_unary
00:A096 C957            	  1220:   cmp #TOKEN_HIGH_BYTE
00:A098 F00F            	  1221:   beq ass_expression_unary
                        	  1222: 
                        	  1223: ;
                        	  1224: ;  if a binary operator get the second value
                        	  1225: ;
00:A09A A500            	  1226:   lda VALUE                 ; copy top value to VALUE2
00:A09C 8503            	  1227:   sta VALUE2
00:A09E A501            	  1228:   lda VALUE+1
00:A0A0 8504            	  1229:   sta VALUE2+1
00:A0A2 A502            	  1230:   lda VALUE+2
00:A0A4 8505            	  1231:   sta VALUE2+2
00:A0A6 20739E          	  1232:   jsr exp_pop_value         ; second pop
                        	  1233: ass_expression_unary:
                        	  1234: 
                        	  1235: ;
                        	  1236: ;  now we have the top two values in VALUE (and VALUE2 in the case of binary operators)
                        	  1237: ;
00:A0A9 20AE9E          	  1238:   jsr exp_pop_operator      ; 1 Pop the operator from the operator stack.
00:A0AC 857D            	  1239:   sta exp_operator
00:A0AE 202C9F          	  1240:   jsr exp_get_precedence    ; find the evaluation function
00:A0B1 C000            	  1241:   cpy #0
00:A0B3 F0CB            	  1242:   beq ass_expression_apply_operator ; should not be here if the operator isn't in the table
00:A0B5 20C1A0          	  1243:   jsr ass_evaluate_operator ; do the evaluation
00:A0B8 20489E          	  1244:   jsr exp_push_value        ; 4 Push the result onto the value stack.
00:A0BB 60              	  1245:   rts
                        	  1246: 
                        	  1247: ass_expression_apply_operator_bug:
00:A0BC A206            	  1248:   ldx #6
00:A0BE 4C2E96          	  1249:   jmp ass_error
                        	  1250: 
                        	  1251: ass_evaluate_operator:
00:A0C1 6C7F00          	  1252:   jmp (exp_evaluation_function)
                        	  1253: 
                        	  1254: 
                        	  1255: ;
                        	  1256: ;  look up opcodes in a table
                        	  1257: ;  returns carry set if found, carry clear if not found
                        	  1258: ;
                        	  1259: ass_lookup_loop:
00:A0C4 A46E            	  1260:   ldy OPCODE_LEN
00:A0C6 202A94          	  1261:   jsr COMSTL
00:A0C9 F017            	  1262:   beq ass_opcode_found
                        	  1263: ;
                        	  1264: ;  add the opcode length, plus 1 to DEST
                        	  1265: ;
00:A0CB 18              	  1266:   clc
00:A0CC A46E            	  1267:   ldy OPCODE_LEN
00:A0CE C8              	  1268:   iny
00:A0CF 98              	  1269:   tya
00:A0D0 6503            	  1270:   adc DEST
00:A0D2 8503            	  1271:   sta DEST
00:A0D4 A504            	  1272:   lda DEST+1
00:A0D6 6900            	  1273:   adc #0
00:A0D8 8504            	  1274:   sta DEST+1
                        	  1275: ;
                        	  1276: ;  end of table?
                        	  1277: ;
00:A0DA A000            	  1278:   ldy #0
00:A0DC B103            	  1279:   lda (DEST),Y
00:A0DE D0E4            	  1280:   bne ass_lookup_loop   ; not yet
00:A0E0 18              	  1281:   clc
00:A0E1 60              	  1282:   rts
                        	  1283: 
                        	  1284: 
                        	  1285: ass_opcode_found:
00:A0E2 A46E            	  1286:   ldy OPCODE_LEN
00:A0E4 B103            	  1287:   lda (DEST),Y
00:A0E6 38              	  1288:   sec   ; indicate found
00:A0E7 60              	  1289:   rts
                        	  1290: 
                        	  1291: ass_emit:
00:A0E8 A476            	  1292:   ldy ASS_PASS
00:A0EA F031            	  1293:   beq ass_emit3  ; only emit codes on 2nd pass
                        	  1294:   ;
                        	  1295:   ;  first time for this line of code, indent by two spaces
                        	  1296:   ;
00:A0EC A46F            	  1297:   ldy ASS_EMIT_COUNT
00:A0EE D00C            	  1298:   bne ass_emit2
00:A0F0 A42E            	  1299:   ldy DCODE
00:A0F2 F008            	  1300:   beq ass_emit2
00:A0F4 48              	  1301:   pha
00:A0F5 20B094          	  1302:   jsr PUTSP
00:A0F8 20B094          	  1303:   jsr PUTSP
00:A0FB 68              	  1304:   pla
                        	  1305: ass_emit2:
                        	  1306: ;
                        	  1307: ;  if this is the *first* byte we emitted, then make that the start address
                        	  1308: ;  for running the code. That is, if you relocate the code, the first byte
                        	  1309: ;  actually emitted will be considered the runtime address.
                        	  1310: ;
                        	  1311: ;  this lets you relocate code (eg. to $4500) and have it run from there if
                        	  1312: ;  you happen to hit Run.
                        	  1313: ;
00:A0FC 48              	  1314:   pha
00:A0FD A577            	  1315:   lda ass_emit_bytes
00:A0FF 0578            	  1316:   ora ass_emit_bytes+1
00:A101 D008            	  1317:   bne ass_already_emitted
00:A103 A523            	  1318:   lda PCODE
00:A105 8525            	  1319:   sta ACT_PCDA
00:A107 A524            	  1320:   lda PCODE+1
00:A109 8526            	  1321:   sta ACT_PCDA+1
                        	  1322: ass_already_emitted:
00:A10B 68              	  1323:   pla
                        	  1324: ;
                        	  1325: ;  write the byte to memory
                        	  1326: ;
00:A10C A000            	  1327:   ldy #0
00:A10E 9123            	  1328:   sta (PCODE),Y
00:A110 E677            	  1329:   inc ass_emit_bytes
00:A112 D002            	  1330:   bne ass_emit4
00:A114 E678            	  1331:   inc ass_emit_bytes+1
                        	  1332: ass_emit4:
                        	  1333: 
                        	  1334: ;
                        	  1335: ;  if displaying codes, show the emitted byte
                        	  1336: ;
00:A116 A42E            	  1337:   ldy DCODE
00:A118 F003            	  1338:   beq ass_emit3
00:A11A 203A94          	  1339:   jsr DISHX
                        	  1340: ;
                        	  1341: ;  increment the PCODE (output) address
                        	  1342: ;
                        	  1343: ass_emit3:
00:A11D E623            	  1344:   inc PCODE
00:A11F D002            	  1345:   bne ass_emit1
00:A121 E624            	  1346:   inc PCODE+1
                        	  1347: ass_emit1:
00:A123 E66F            	  1348:   inc ASS_EMIT_COUNT
00:A125 60              	  1349:   rts
                        	  1350: 
                        	  1351: ass_fixup_bbr_branch:
00:A126 A507            	  1352:   lda REMAIN+1
00:A128 D043            	  1353:   bne ass_emit_zero_page_too_high
00:A12A A508            	  1354:   lda REMAIN+2
00:A12C D03F            	  1355:   bne ass_emit_zero_page_too_high
00:A12E A506            	  1356:   lda REMAIN
00:A130 20E8A0          	  1357:   jsr ass_emit  ; output zero page address
                        	  1358: 
                        	  1359: ;
                        	  1360: ;  now fall down and emit the branch
                        	  1361: ;
                        	  1362: 
                        	  1363: ass_fixup_branch:
00:A133 18              	  1364:   clc         ; I want to subtract one more, so I CLEAR carry <sigh>
00:A134 A573            	  1365:   lda ASS_VALUE
00:A136 E523            	  1366:   sbc PCODE
00:A138 8573            	  1367:   sta ASS_VALUE
                        	  1368: 
00:A13A A574            	  1369:   lda ASS_VALUE+1
00:A13C E524            	  1370:   sbc PCODE+1
00:A13E C9FF            	  1371:   cmp #$FF  ; backwards branch
00:A140 F00A            	  1372:   beq ass_branch_backwards
00:A142 C900            	  1373:   cmp #0
00:A144 D010            	  1374:   bne ass_branch_out_of_range
00:A146 A573            	  1375:   lda ASS_VALUE ; must be 0x00 to 0x7F
00:A148 300C            	  1376:   bmi ass_branch_out_of_range
00:A14A 8004            	  1377:   bra ass_branch_ok
                        	  1378: 
                        	  1379: ass_branch_backwards:
00:A14C A573            	  1380:   lda ASS_VALUE   ; must be 0x80 to 0xFF
00:A14E 1006            	  1381:   bpl ass_branch_out_of_range
                        	  1382: 
                        	  1383: ass_branch_ok:
00:A150 A573            	  1384:   lda ASS_VALUE
00:A152 20E8A0          	  1385:   jsr ass_emit  ; output relative address
00:A155 60              	  1386:   rts
                        	  1387: 
                        	  1388: ass_branch_out_of_range:
00:A156 A576            	  1389:   lda ASS_PASS
00:A158 F0F6            	  1390:   beq ass_branch_ok   ; out of range is OK on first pass, we don't know how far the branch is
00:A15A A22A            	  1391:   ldx #42
00:A15C 4C2E96          	  1392:   jmp ass_error  ; branch out of range
                        	  1393: 
                        	  1394: ass_emit_zero_page:
00:A15F A574            	  1395:   lda ASS_VALUE+1
00:A161 D00A            	  1396:   bne ass_emit_zero_page_too_high
00:A163 A575            	  1397:   lda ASS_VALUE+2
00:A165 D006            	  1398:   bne ass_emit_zero_page_too_high
00:A167 A573            	  1399:   lda ASS_VALUE
00:A169 20E8A0          	  1400:   jsr ass_emit  ; output zero page address
00:A16C 60              	  1401:   rts
                        	  1402: 
                        	  1403: 
                        	  1404: ass_emit_zero_page_too_high:
00:A16D A22B            	  1405:   ldx #43       ; Need zero page address
00:A16F 4C2E96          	  1406:   jmp ass_error
                        	  1407: 
                        	  1408: ass_emit_immediate:
00:A172 A574            	  1409:   lda ASS_VALUE+1
00:A174 D00A            	  1410:   bne ass_emit_immediate_too_high
00:A176 A575            	  1411:   lda ASS_VALUE+2
00:A178 D006            	  1412:   bne ass_emit_immediate_too_high
00:A17A A573            	  1413:   lda ASS_VALUE
00:A17C 20E8A0          	  1414:   jsr ass_emit  ; output immediate operand
00:A17F 60              	  1415:   rts
                        	  1416: 
                        	  1417: ass_emit_immediate_too_high:
00:A180 A22C            	  1418:   ldx #44
00:A182 4C2E96          	  1419:   jmp ass_error
                        	  1420: 
                        	  1421: 
                        	  1422: ass_emit_absolute:
00:A185 A573            	  1423:   lda ASS_VALUE
00:A187 20E8A0          	  1424:   jsr ass_emit  ; output absolute address - low-order byte
00:A18A A574            	  1425:   lda ASS_VALUE+1
00:A18C 20E8A0          	  1426:   jsr ass_emit  ; output absolute address - high-order byte
00:A18F 60              	  1427:   rts
                        	  1428: 
                        	  1429: 
                        	  1430: ;------------------------------------
                        	  1431: ;  Opcode master table
                        	  1432: ;------------------------------------
                        	  1433: 
                        	  1434:    .macro makeOpcodeLookup ; table of opcodes, length of opcode, wanted operand type, special handler
                        	  1435:      dfb   \1
                        	  1436:      dfb   \2
                        	  1437:      word  \3
                        	  1438:      word   \4
                        	  1439:    .endmacro
                        	  1440: 
                        	  1441: ;
                        	  1442: ;  So, for an opcode to match, it has to:
                        	  1443: ;     a) be the right length (usually 3 or 4 characters)
                        	  1444: ;     b) have the right type of operand (eg. ASS_OPERAND_IMMEDIATE)
                        	  1445: ;     c) the opcode must match the name in the list
                        	  1446: ;
                        	  1447: ;   If those conditions are met we output the corresponding opcode,
                        	  1448: ;   return with the operand type in A
                        	  1449: ;
                        	  1450: ;   Otherwise, we return 0 in A
                        	  1451: ;
                        	  1452: 
                        	  1453: OPCODE_LOOKUP_OPCODE_LENGTH = 0
                        	  1454: OPCODE_LOOKUP_OPERAND_TYPE = 1
                        	  1455: OPCODE_LOOKUP_OPCODE_TABLE = 2    ; 2 bytes
                        	  1456: OPCODE_LOOKUP_HANDLER = 4         ; 2 bytes
                        	  1457: OPCODE_LOOKUP_TABLE_SIZE = 6      ; all of the above
                        	  1458: 
                        	  1459: OPCODE_LOOKUP_TABLE = *
                        	  1460: ;
                        	  1461: ;  zero-page opcodes go first as they are preferred if we are accessing a zero-page address
                        	  1462: ;
                        	  1463:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE, OPCODE_ASS_OPERAND_ZERO_PAGE, ass_emit_zero_page ; (11)
00:A190 03              	     1M      dfb   3
00:A191 0B              	     2M      dfb   ASS_OPERAND_ZERO_PAGE
00:A192 1DA5            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE
00:A194 5FA1            	     4M      word   ass_emit_zero_page 
                        	  1464:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE, OPCODE_ASS_OPERAND_ZERO_PAGE_TOKENISED, ass_emit_zero_page ; (11)
00:A196 01              	     1M      dfb   1
00:A197 0B              	     2M      dfb   ASS_OPERAND_ZERO_PAGE
00:A198 7EA5            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_TOKENISED
00:A19A 5FA1            	     4M      word   ass_emit_zero_page 
                        	  1465:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT, ass_em
00:A19C 03              	     1M      dfb   3
00:A19D 0C              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
00:A19E 81A5            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
00:A1A0 5FA1            	     4M      word   ass_emit_zero_page 
                        	  1466:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT_TOKENIS
00:A1A2 01              	     1M      dfb   1
00:A1A3 0C              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
00:A1A4 A2A5            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT_TOKENISED
00:A1A6 5FA1            	     4M      word   ass_emit_zero_page 
                        	  1467:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X, ass_emit_z
00:A1A8 03              	     1M      dfb   3
00:A1A9 0D              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
00:A1AA A5A5            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
00:A1AC 5FA1            	     4M      word   ass_emit_zero_page 
                        	  1468:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X_TOKENISED, 
00:A1AE 01              	     1M      dfb   1
00:A1AF 0D              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
00:A1B0 EEA5            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X_TOKENISED
00:A1B2 5FA1            	     4M      word   ass_emit_zero_page 
                        	  1469:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y, ass_emit_z
00:A1B4 03              	     1M      dfb   3
00:A1B5 0E              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
00:A1B6 F1A5            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
00:A1B8 5FA1            	     4M      word   ass_emit_zero_page 
                        	  1470:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDIRECT, OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT, ass_emit_zero_page ; (
00:A1BA 03              	     1M      dfb   3
00:A1BB 0F              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDIRECT
00:A1BC FAA5            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT
00:A1BE 5FA1            	     4M      word   ass_emit_zero_page 
                        	  1471:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE_INDIRECT, OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_TOKENISED, ass_emit_zer
00:A1C0 01              	     1M      dfb   1
00:A1C1 0F              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDIRECT
00:A1C2 1BA6            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_TOKENISED
00:A1C4 5FA1            	     4M      word   ass_emit_zero_page 
                        	  1472:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_
00:A1C6 03              	     1M      dfb   3
00:A1C7 10              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
00:A1C8 1EA6            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
00:A1CA 5FA1            	     4M      word   ass_emit_zero_page 
                        	  1473:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_
00:A1CC 01              	     1M      dfb   1
00:A1CD 10              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
00:A1CE 3FA6            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y_TOKENISED
00:A1D0 5FA1            	     4M      word   ass_emit_zero_page 
                        	  1474: 
                        	  1475: ;
                        	  1476: ;  non zero-page opcodes
                        	  1477: ;
                        	  1478:     makeOpcodeLookup  4,  ASS_OPERAND_ABSOLUTE, OPCODE_4_CHAR_ZERO_PAGE,  ass_emit_zero_page  ; (11)
00:A1D2 04              	     1M      dfb   4
00:A1D3 01              	     2M      dfb   ASS_OPERAND_ABSOLUTE
00:A1D4 99A3            	     3M      word  OPCODE_4_CHAR_ZERO_PAGE
00:A1D6 5FA1            	     4M      word   ass_emit_zero_page  
                        	  1479:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE, OPCODE_ASS_OPERAND_ABSOLUTE,  ass_emit_absolute  ; (1)
00:A1D8 03              	     1M      dfb   3
00:A1D9 01              	     2M      dfb   ASS_OPERAND_ABSOLUTE
00:A1DA EAA3            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE
00:A1DC 85A1            	     4M      word   ass_emit_absolute  
                        	  1480:     makeOpcodeLookup  1,  ASS_OPERAND_ABSOLUTE, OPCODE_ASS_OPERAND_ABSOLUTE_TOKENISED,  ass_emit_absolute  ; (1)
00:A1DE 01              	     1M      dfb   1
00:A1DF 01              	     2M      dfb   ASS_OPERAND_ABSOLUTE
00:A1E0 53A4            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_TOKENISED
00:A1E2 85A1            	     4M      word   ass_emit_absolute  
                        	  1481: 
                        	  1482:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT, ass_emit
00:A1E4 03              	     1M      dfb   3
00:A1E5 02              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
00:A1E6 56A4            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
00:A1E8 85A1            	     4M      word   ass_emit_absolute 
                        	  1483:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X, ass_emit_abs
00:A1EA 03              	     1M      dfb   3
00:A1EB 03              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
00:A1EC 5BA4            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
00:A1EE 85A1            	     4M      word   ass_emit_absolute 
                        	  1484:     makeOpcodeLookup  1,  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X_TOKENISED, as
00:A1F0 01              	     1M      dfb   1
00:A1F1 03              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
00:A1F2 A0A4            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X_TOKENISED
00:A1F4 85A1            	     4M      word   ass_emit_absolute 
                        	  1485:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y, ass_emit_abs
00:A1F6 03              	     1M      dfb   3
00:A1F7 04              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
00:A1F8 A3A4            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
00:A1FA 85A1            	     4M      word   ass_emit_absolute 
                        	  1486:     makeOpcodeLookup  1,  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y_TOKENISED, as
00:A1FC 01              	     1M      dfb   1
00:A1FD 04              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
00:A1FE C8A4            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y_TOKENISED
00:A200 85A1            	     4M      word   ass_emit_absolute 
                        	  1487:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDIRECT, OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT, ass_emit_absolute ; (5)
00:A202 03              	     1M      dfb   3
00:A203 05              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDIRECT
00:A204 E4A4            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT
00:A206 85A1            	     4M      word   ass_emit_absolute 
                        	  1488:     makeOpcodeLookup  1,  ASS_OPERAND_ABSOLUTE_INDIRECT, OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED, ass_emit_absolute ; (5
00:A208 01              	     1M      dfb   1
00:A209 05              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDIRECT
00:A20A 1AA5            	     3M      word  OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED
00:A20C 85A1            	     4M      word   ass_emit_absolute 
                        	  1489:     makeOpcodeLookup  3,  ASS_OPERAND_ACCUMULATOR_A, OPCODE_ASS_OPERAND_ACCUMULATOR_A, 0 ; (6)
00:A20E 03              	     1M      dfb   3
00:A20F 06              	     2M      dfb   ASS_OPERAND_ACCUMULATOR_A
00:A210 CBA4            	     3M      word  OPCODE_ASS_OPERAND_ACCUMULATOR_A
00:A212 0000            	     4M      word   0 
                        	  1490:     makeOpcodeLookup  3,  ASS_OPERAND_IMMEDIATE, OPCODE_ASS_OPERAND_IMMEDIATE, ass_emit_immediate ; (7)
00:A214 03              	     1M      dfb   3
00:A215 07              	     2M      dfb   ASS_OPERAND_IMMEDIATE
00:A216 E9A4            	     3M      word  OPCODE_ASS_OPERAND_IMMEDIATE
00:A218 72A1            	     4M      word   ass_emit_immediate 
                        	  1491:     makeOpcodeLookup  1,  ASS_OPERAND_IMMEDIATE, OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED, ass_emit_immediate ; (7)
00:A21A 01              	     1M      dfb   1
00:A21B 07              	     2M      dfb   ASS_OPERAND_IMMEDIATE
00:A21C 1AA5            	     3M      word  OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED
00:A21E 72A1            	     4M      word   ass_emit_immediate 
                        	  1492:     makeOpcodeLookup  3,  ASS_OPERAND_IMPLIED,  OPCODE_3_CHAR_IMPLIED,    0  ; (8) and (10)
00:A220 03              	     1M      dfb   3
00:A221 08              	     2M      dfb   ASS_OPERAND_IMPLIED
00:A222 1CA3            	     3M      word  OPCODE_3_CHAR_IMPLIED
00:A224 0000            	     4M      word   0  
                        	  1493:     makeOpcodeLookup  4,  ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE, OPCODE_4_CHAR_BRANCH,     ass_fixup_bbr_branch  ; (9)
00:A226 04              	     1M      dfb   4
00:A227 12              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE
00:A228 A6A2            	     3M      word  OPCODE_4_CHAR_BRANCH
00:A22A 26A1            	     4M      word   ass_fixup_bbr_branch  
                        	  1494:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE, OPCODE_3_CHAR_BRANCH,     ass_fixup_branch  ; (9)
00:A22C 03              	     1M      dfb   3
00:A22D 01              	     2M      dfb   ASS_OPERAND_ABSOLUTE
00:A22E F7A2            	     3M      word  OPCODE_3_CHAR_BRANCH
00:A230 33A1            	     4M      word   ass_fixup_branch  
00:A232 00              	  1495:     dfb 0
                        	  1496: 
                        	  1497: 
                        	  1498: ;------------------------------------
                        	  1499: ;  directives
                        	  1500: ;------------------------------------
                        	  1501: 
                        	  1502: 
                        	  1503: DIRECTIVES = *
                        	  1504:   makeHandler "ASSERT",   asm_do_assert
00:A233 415353455254    	     1M    asciiz   "ASSERT"
00:A239 00
00:A23A 42A6            	     2M    word  asm_do_assert
                        	  1505:   makeHandler "LIST",     asm_do_list
00:A23C 4C495354        	     1M    asciiz   "LIST"
00:A240 00
00:A241 59A6            	     2M    word  asm_do_list
                        	  1506:   makeHandler "NOLIST",   asm_do_nolist
00:A243 4E4F4C495354    	     1M    asciiz   "NOLIST"
00:A249 00
00:A24A 68A6            	     2M    word  asm_do_nolist
                        	  1507:   makeHandler "ASC",      asm_do_asc
00:A24C 415343          	     1M    asciiz   "ASC"
00:A24F 00
00:A250 A7A6            	     2M    word  asm_do_asc
                        	  1508:   makeHandler "ASCII",    asm_do_asc
00:A252 4153434949      	     1M    asciiz   "ASCII"
00:A257 00
00:A258 A7A6            	     2M    word  asm_do_asc
                        	  1509:   makeHandler "ASCIIZ",   asm_do_string
00:A25A 41534349495A    	     1M    asciiz   "ASCIIZ"
00:A260 00
00:A261 C2A6            	     2M    word  asm_do_string
                        	  1510:   makeHandler "STRING",   asm_do_string
00:A263 535452494E47    	     1M    asciiz   "STRING"
00:A269 00
00:A26A C2A6            	     2M    word  asm_do_string
                        	  1511:   makeHandler "EQU",      asm_do_equ
00:A26C 455155          	     1M    asciiz   "EQU"
00:A26F 00
00:A270 CBA6            	     2M    word  asm_do_equ
                        	  1512:   makeHandler "=",        asm_do_equ
00:A272 3D              	     1M    asciiz   "="
00:A273 00
00:A274 CBA6            	     2M    word  asm_do_equ
                        	  1513:   makeHandler "ORG",      asm_do_org
00:A276 4F5247          	     1M    asciiz   "ORG"
00:A279 00
00:A27A E8A6            	     2M    word  asm_do_org
                        	  1514:   makeHandler "DFB",      asm_do_dfb
00:A27C 444642          	     1M    asciiz   "DFB"
00:A27F 00
00:A280 FCA6            	     2M    word  asm_do_dfb
                        	  1515:   makeHandler "DFW",      asm_do_dfw
00:A282 444657          	     1M    asciiz   "DFW"
00:A285 00
00:A286 3CA7            	     2M    word  asm_do_dfw
                        	  1516:   makeHandler "WORD",     asm_do_dfw
00:A288 574F5244        	     1M    asciiz   "WORD"
00:A28C 00
00:A28D 3CA7            	     2M    word  asm_do_dfw
                        	  1517:   makeHandler "BLK",      asm_do_blk
00:A28F 424C4B          	     1M    asciiz   "BLK"
00:A292 00
00:A293 79A7            	     2M    word  asm_do_blk
                        	  1518:   makeHandler "RESERVE",  asm_do_reserve
00:A295 52455345525645  	     1M    asciiz   "RESERVE"
00:A29C 00
00:A29D 97A7            	     2M    word  asm_do_reserve
                        	  1519:   makeHandler "SYM",      asm_do_sym
00:A29F 53594D          	     1M    asciiz   "SYM"
00:A2A2 00
00:A2A3 B2A7            	     2M    word  asm_do_sym
                        	  1520: 
00:A2A5 00              	  1521:   dfb 0
                        	  1522: 
                        	  1523: ;------------------------------------
                        	  1524: ;  4-character branch opcodes
                        	  1525: ;------------------------------------
                        	  1526: 
                        	  1527: 
                        	  1528: OPCODE_4_CHAR_BRANCH = *
00:A2A6 42425230        	  1529:   asc "BBR0",$0F
00:A2AA 0F
00:A2AB 42425231        	  1530:   asc "BBR1",$1F
00:A2AF 1F
00:A2B0 42425232        	  1531:   asc "BBR2",$2F
00:A2B4 2F
00:A2B5 42425233        	  1532:   asc "BBR3",$3F
00:A2B9 3F
00:A2BA 42425234        	  1533:   asc "BBR4",$4F
00:A2BE 4F
00:A2BF 42425235        	  1534:   asc "BBR5",$5F
00:A2C3 5F
00:A2C4 42425236        	  1535:   asc "BBR6",$6F
00:A2C8 6F
00:A2C9 42425237        	  1536:   asc "BBR7",$7F
00:A2CD 7F
00:A2CE 42425330        	  1537:   asc "BBS0",$8F
00:A2D2 8F
00:A2D3 42425331        	  1538:   asc "BBS1",$9F
00:A2D7 9F
00:A2D8 42425332        	  1539:   asc "BBS2",$AF
00:A2DC AF
00:A2DD 42425333        	  1540:   asc "BBS3",$BF
00:A2E1 BF
00:A2E2 42425334        	  1541:   asc "BBS4",$CF
00:A2E6 CF
00:A2E7 42425335        	  1542:   asc "BBS5",$DF
00:A2EB DF
00:A2EC 42425336        	  1543:   asc "BBS6",$EF
00:A2F0 EF
00:A2F1 42425337        	  1544:   asc "BBS7",$FF
00:A2F5 FF
00:A2F6 00              	  1545:   dfb 0
                        	  1546: 
                        	  1547: ;------------------------------------
                        	  1548: ;  3-character branch opcodes
                        	  1549: ;------------------------------------
                        	  1550: 
                        	  1551: 
                        	  1552: OPCODE_3_CHAR_BRANCH = *
00:A2F7 424343          	  1553:   asc "BCC",$90
00:A2FA 90
00:A2FB 424353          	  1554:   asc "BCS",$B0
00:A2FE B0
00:A2FF 424551          	  1555:   asc "BEQ",$F0
00:A302 F0
00:A303 424D49          	  1556:   asc "BMI",$30
00:A306 30
00:A307 424E45          	  1557:   asc "BNE",$D0
00:A30A D0
00:A30B 42504C          	  1558:   asc "BPL",$10
00:A30E 10
00:A30F 425241          	  1559:   asc "BRA",$80
00:A312 80
00:A313 425643          	  1560:   asc "BVC",$50
00:A316 50
00:A317 425653          	  1561:   asc "BVS",$70
00:A31A 70
00:A31B 00              	  1562:   dfb 0
                        	  1563: 
                        	  1564: 
                        	  1565: ;------------------------------------
                        	  1566: ;  3-character implied opcodes (no operand)
                        	  1567: ;------------------------------------
                        	  1568: 
                        	  1569: OPCODE_3_CHAR_IMPLIED = *
00:A31C 42524B          	  1570:   asc "BRK",$00
00:A31F 00
00:A320 434C43          	  1571:   asc "CLC",$18
00:A323 18
00:A324 434C44          	  1572:   asc "CLD",$D8
00:A327 D8
00:A328 434C49          	  1573:   asc "CLI",$58
00:A32B 58
00:A32C 434C56          	  1574:   asc "CLV",$B8
00:A32F B8
00:A330 444558          	  1575:   asc "DEX",$CA
00:A333 CA
00:A334 444559          	  1576:   asc "DEY",$88
00:A337 88
00:A338 494E58          	  1577:   asc "INX",$E8
00:A33B E8
00:A33C 494E59          	  1578:   asc "INY",$C8
00:A33F C8
00:A340 4E4F50          	  1579:   asc "NOP",$EA
00:A343 EA
00:A344 504841          	  1580:   asc "PHA",$48
00:A347 48
00:A348 504850          	  1581:   asc "PHP",$08
00:A34B 08
00:A34C 504858          	  1582:   asc "PHX",$DA
00:A34F DA
00:A350 504859          	  1583:   asc "PHY",$5A
00:A353 5A
00:A354 504C41          	  1584:   asc "PLA",$68
00:A357 68
00:A358 504C50          	  1585:   asc "PLP",$28
00:A35B 28
00:A35C 504C58          	  1586:   asc "PLX",$FA
00:A35F FA
00:A360 504C59          	  1587:   asc "PLY",$7A
00:A363 7A
00:A364 525449          	  1588:   asc "RTI",$40
00:A367 40
00:A368 525453          	  1589:   asc "RTS",$60
00:A36B 60
00:A36C 534543          	  1590:   asc "SEC",$38
00:A36F 38
00:A370 534544          	  1591:   asc "SED",$F8
00:A373 F8
00:A374 534549          	  1592:   asc "SEI",$78
00:A377 78
00:A378 535450          	  1593:   asc "STP",$DB
00:A37B DB
00:A37C 544158          	  1594:   asc "TAX",$AA
00:A37F AA
00:A380 544159          	  1595:   asc "TAY",$A8
00:A383 A8
00:A384 545358          	  1596:   asc "TSX",$BA
00:A387 BA
00:A388 545841          	  1597:   asc "TXA",$8A
00:A38B 8A
00:A38C 545853          	  1598:   asc "TXS",$9A
00:A38F 9A
00:A390 545941          	  1599:   asc "TYA",$98
00:A393 98
00:A394 574149          	  1600:   asc "WAI",$CB
00:A397 CB
00:A398 00              	  1601:   dfb 0
                        	  1602: 
                        	  1603: ;------------------------------------
                        	  1604: ;  4-character zero page opcodes (operand must be zero-page address)
                        	  1605: ;------------------------------------
                        	  1606: OPCODE_4_CHAR_ZERO_PAGE = *
00:A399 534D4230        	  1607:   asc "SMB0",$87
00:A39D 87
00:A39E 534D4231        	  1608:   asc "SMB1",$97
00:A3A2 97
00:A3A3 534D4232        	  1609:   asc "SMB2",$A7
00:A3A7 A7
00:A3A8 534D4233        	  1610:   asc "SMB3",$B7
00:A3AC B7
00:A3AD 534D4234        	  1611:   asc "SMB4",$C7
00:A3B1 C7
00:A3B2 534D4235        	  1612:   asc "SMB5",$D7
00:A3B6 D7
00:A3B7 534D4236        	  1613:   asc "SMB6",$E7
00:A3BB E7
00:A3BC 534D4237        	  1614:   asc "SMB7",$F7
00:A3C0 F7
00:A3C1 524D4230        	  1615:   asc "RMB0",$07
00:A3C5 07
00:A3C6 524D4231        	  1616:   asc "RMB1",$17
00:A3CA 17
00:A3CB 524D4232        	  1617:   asc "RMB2",$27
00:A3CF 27
00:A3D0 524D4233        	  1618:   asc "RMB3",$37
00:A3D4 37
00:A3D5 524D4234        	  1619:   asc "RMB4",$47
00:A3D9 47
00:A3DA 524D4235        	  1620:   asc "RMB5",$57
00:A3DE 57
00:A3DF 524D4236        	  1621:   asc "RMB6",$67
00:A3E3 67
00:A3E4 524D4237        	  1622:   asc "RMB7",$77
00:A3E8 77
00:A3E9 00              	  1623:   dfb 0
                        	  1624: 
                        	  1625: ;------------------------------------
                        	  1626: ;  ASS_OPERAND_ABSOLUTE
                        	  1627: ;------------------------------------
                        	  1628: OPCODE_ASS_OPERAND_ABSOLUTE = *
00:A3EA 414443          	  1629:   asc "ADC",$6D
00:A3ED 6D
00:A3EE 414E44          	  1630:   asc "AND",$2D
00:A3F1 2D
00:A3F2 41534C          	  1631:   asc "ASL",$0E
00:A3F5 0E
00:A3F6 424954          	  1632:   asc "BIT",$2C
00:A3F9 2C
00:A3FA 434D50          	  1633:   asc "CMP",$CD
00:A3FD CD
00:A3FE 435058          	  1634:   asc "CPX",$EC
00:A401 EC
00:A402 435059          	  1635:   asc "CPY",$CC
00:A405 CC
00:A406 444543          	  1636:   asc "DEC",$CE
00:A409 CE
00:A40A 454F52          	  1637:   asc "EOR",$4D
00:A40D 4D
00:A40E 494E43          	  1638:   asc "INC",$EE
00:A411 EE
00:A412 4A4D50          	  1639:   asc "JMP",$4C
00:A415 4C
00:A416 4A5352          	  1640:   asc "JSR",$20
00:A419 20
00:A41A 4C4441          	  1641:   asc "LDA",$AD
00:A41D AD
00:A41E 4C4458          	  1642:   asc "LDX",$AE
00:A421 AE
00:A422 4C4459          	  1643:   asc "LDY",$AC
00:A425 AC
00:A426 4C5352          	  1644:   asc "LSR",$4E
00:A429 4E
00:A42A 4F5241          	  1645:   asc "ORA",$0D
00:A42D 0D
00:A42E 524F4C          	  1646:   asc "ROL",$2E
00:A431 2E
00:A432 524F52          	  1647:   asc "ROR",$6E
00:A435 6E
00:A436 534243          	  1648:   asc "SBC",$ED
00:A439 ED
00:A43A 535441          	  1649:   asc "STA",$8D
00:A43D 8D
00:A43E 535458          	  1650:   asc "STX",$8E
00:A441 8E
00:A442 535459          	  1651:   asc "STY",$8C
00:A445 8C
00:A446 53545A          	  1652:   asc "STZ",$9C
00:A449 9C
00:A44A 545242          	  1653:   asc "TRB",$1C
00:A44D 1C
00:A44E 545342          	  1654:   asc "TSB",$0C
00:A451 0C
00:A452 00              	  1655:   dfb 0
                        	  1656: 
                        	  1657: ;------------------------------------
                        	  1658: ;  ASS_OPERAND_ABSOLUTE - for tokenised opcodes like AND
                        	  1659: ;------------------------------------
                        	  1660: OPCODE_ASS_OPERAND_ABSOLUTE_TOKENISED = *
00:A453 8D              	  1661:   dfb TOKEN_AND,$2D
00:A454 2D
00:A455 00              	  1662:   dfb 0
                        	  1663: 
                        	  1664: 
                        	  1665: ;------------------------------------
                        	  1666: ;  ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
                        	  1667: ;------------------------------------
                        	  1668: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT = *
00:A456 4A4D50          	  1669:   asc "JMP",$7C
00:A459 7C
00:A45A 00              	  1670:   dfb 0
                        	  1671: 
                        	  1672: ;------------------------------------
                        	  1673: ;  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
                        	  1674: ;------------------------------------
                        	  1675: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X = *
00:A45B 414443          	  1676:   asc "ADC",$7D
00:A45E 7D
00:A45F 414E44          	  1677:   asc "AND",$3D
00:A462 3D
00:A463 41534C          	  1678:   asc "ASL",$1E
00:A466 1E
00:A467 424954          	  1679:   asc "BIT",$3C
00:A46A 3C
00:A46B 434D50          	  1680:   asc "CMP",$DD
00:A46E DD
00:A46F 444543          	  1681:   asc "DEC",$DE
00:A472 DE
00:A473 454F52          	  1682:   asc "EOR",$5D
00:A476 5D
00:A477 494E43          	  1683:   asc "INC",$FE
00:A47A FE
00:A47B 4C4441          	  1684:   asc "LDA",$BD
00:A47E BD
00:A47F 4C4459          	  1685:   asc "LDY",$BC
00:A482 BC
00:A483 4C5352          	  1686:   asc "LSR",$5E
00:A486 5E
00:A487 4F5241          	  1687:   asc "ORA",$1D
00:A48A 1D
00:A48B 524F4C          	  1688:   asc "ROL",$3E
00:A48E 3E
00:A48F 524F52          	  1689:   asc "ROR",$7E
00:A492 7E
00:A493 534243          	  1690:   asc "SBC",$FD
00:A496 FD
00:A497 535441          	  1691:   asc "STA",$9D
00:A49A 9D
00:A49B 53545A          	  1692:   asc "STZ",$9E
00:A49E 9E
00:A49F 00              	  1693:   dfb 0
                        	  1694: 
                        	  1695: ;------------------------------------
                        	  1696: ;  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X - for tokenised opcodes like AND
                        	  1697: ;------------------------------------
                        	  1698: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X_TOKENISED = *
00:A4A0 8D              	  1699:   dfb TOKEN_AND,$3D
00:A4A1 3D
00:A4A2 00              	  1700:   dfb 0
                        	  1701: 
                        	  1702: ;------------------------------------
                        	  1703: ;  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
                        	  1704: ;------------------------------------
                        	  1705: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y = *
00:A4A3 414443          	  1706:   asc "ADC",$79
00:A4A6 79
00:A4A7 414E44          	  1707:   asc "AND",$39
00:A4AA 39
00:A4AB 434D50          	  1708:   asc "CMP",$D9
00:A4AE D9
00:A4AF 454F52          	  1709:   asc "EOR",$59
00:A4B2 59
00:A4B3 4C4441          	  1710:   asc "LDA",$B9
00:A4B6 B9
00:A4B7 4C4458          	  1711:   asc "LDX",$BE
00:A4BA BE
00:A4BB 4F5241          	  1712:   asc "ORA",$19
00:A4BE 19
00:A4BF 534243          	  1713:   asc "SBC",$F9
00:A4C2 F9
00:A4C3 535441          	  1714:   asc "STA",$99
00:A4C6 99
00:A4C7 00              	  1715:   dfb 0
                        	  1716: 
                        	  1717: ;------------------------------------
                        	  1718: ;  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y - for tokenised opcodes like AND
                        	  1719: ;------------------------------------
                        	  1720: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y_TOKENISED = *
00:A4C8 8D              	  1721:   dfb TOKEN_AND,$39
00:A4C9 39
00:A4CA 00              	  1722:   dfb 0
                        	  1723: 
                        	  1724: ;------------------------------------
                        	  1725: ;  ASS_OPERAND_ACCUMULATOR_A
                        	  1726: ;------------------------------------
                        	  1727: OPCODE_ASS_OPERAND_ACCUMULATOR_A = *
00:A4CB 41534C          	  1728:   asc "ASL",$0A
00:A4CE 0A
00:A4CF 444543          	  1729:   asc "DEC",$3A
00:A4D2 3A
00:A4D3 494E43          	  1730:   asc "INC",$1A
00:A4D6 1A
00:A4D7 4C5352          	  1731:   asc "LSR",$4A
00:A4DA 4A
00:A4DB 524F4C          	  1732:   asc "ROL",$2A
00:A4DE 2A
00:A4DF 524F52          	  1733:   asc "ROR",$6A
00:A4E2 6A
00:A4E3 00              	  1734:   dfb 0
                        	  1735: 
                        	  1736: ;------------------------------------
                        	  1737: ;  ASS_OPERAND_ABSOLUTE_INDIRECT
                        	  1738: ;------------------------------------
                        	  1739: OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT = *
00:A4E4 4A4D50          	  1740:   asc "JMP",$6C
00:A4E7 6C
00:A4E8 00              	  1741:   dfb 0
                        	  1742: 
                        	  1743: ;------------------------------------
                        	  1744: ;  ASS_OPERAND_IMMEDIATE
                        	  1745: ;------------------------------------
                        	  1746: OPCODE_ASS_OPERAND_IMMEDIATE = *
00:A4E9 414443          	  1747:   asc "ADC",$69
00:A4EC 69
00:A4ED 414E44          	  1748:   asc "AND",$29
00:A4F0 29
00:A4F1 424954          	  1749:   asc "BIT",$89
00:A4F4 89
00:A4F5 434D50          	  1750:   asc "CMP",$C9
00:A4F8 C9
00:A4F9 435058          	  1751:   asc "CPX",$E0
00:A4FC E0
00:A4FD 435059          	  1752:   asc "CPY",$C0
00:A500 C0
00:A501 454F52          	  1753:   asc "EOR",$49
00:A504 49
00:A505 4C4441          	  1754:   asc "LDA",$A9
00:A508 A9
00:A509 4C4458          	  1755:   asc "LDX",$A2
00:A50C A2
00:A50D 4C4459          	  1756:   asc "LDY",$A0
00:A510 A0
00:A511 4F5241          	  1757:   asc "ORA",$09
00:A514 09
00:A515 534243          	  1758:   asc "SBC",$E9
00:A518 E9
00:A519 00              	  1759:   dfb 0
                        	  1760: 
                        	  1761: ;------------------------------------
                        	  1762: ;  ASS_OPERAND_IMMEDIATE - for tokenised opcodes like AND
                        	  1763: ;------------------------------------
                        	  1764: OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED = *
00:A51A 8D              	  1765:   dfb TOKEN_AND,$29
00:A51B 29
00:A51C 00              	  1766:   dfb 0
                        	  1767: 
                        	  1768: ;------------------------------------
                        	  1769: ;  ASS_OPERAND_ZERO_PAGE
                        	  1770: ;------------------------------------
                        	  1771: OPCODE_ASS_OPERAND_ZERO_PAGE = *
00:A51D 414443          	  1772:   asc "ADC",$65
00:A520 65
00:A521 414E44          	  1773:   asc "AND",$25
00:A524 25
00:A525 41534C          	  1774:   asc "ASL",$06
00:A528 06
00:A529 424954          	  1775:   asc "BIT",$24
00:A52C 24
00:A52D 434D50          	  1776:   asc "CMP",$C5
00:A530 C5
00:A531 435058          	  1777:   asc "CPX",$E4
00:A534 E4
00:A535 435059          	  1778:   asc "CPY",$C4
00:A538 C4
00:A539 444543          	  1779:   asc "DEC",$C6
00:A53C C6
00:A53D 454F52          	  1780:   asc "EOR",$45
00:A540 45
00:A541 494E43          	  1781:   asc "INC",$E6
00:A544 E6
00:A545 4C4441          	  1782:   asc "LDA",$A5
00:A548 A5
00:A549 4C4458          	  1783:   asc "LDX",$A6
00:A54C A6
00:A54D 4C4459          	  1784:   asc "LDY",$A4
00:A550 A4
00:A551 4C5352          	  1785:   asc "LSR",$46
00:A554 46
00:A555 4F5241          	  1786:   asc "ORA",$05
00:A558 05
00:A559 524F4C          	  1787:   asc "ROL",$26
00:A55C 26
00:A55D 524F52          	  1788:   asc "ROR",$66
00:A560 66
00:A561 534243          	  1789:   asc "SBC",$E5
00:A564 E5
00:A565 535441          	  1790:   asc "STA",$85
00:A568 85
00:A569 535458          	  1791:   asc "STX",$86
00:A56C 86
00:A56D 535459          	  1792:   asc "STY",$84
00:A570 84
00:A571 53545A          	  1793:   asc "STZ",$64
00:A574 64
00:A575 545242          	  1794:   asc "TRB",$14
00:A578 14
00:A579 545342          	  1795:   asc "TSB",$04
00:A57C 04
00:A57D 00              	  1796:   dfb 0
                        	  1797: 
                        	  1798: ;------------------------------------
                        	  1799: ;  ASS_OPERAND_ZERO_PAGE  - for tokenised opcodes like AND
                        	  1800: ;------------------------------------
                        	  1801: OPCODE_ASS_OPERAND_ZERO_PAGE_TOKENISED = *
00:A57E 8D              	  1802:   dfb TOKEN_AND,$25
00:A57F 25
00:A580 00              	  1803:   dfb 0
                        	  1804: 
                        	  1805: 
                        	  1806: ;------------------------------------
                        	  1807: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
                        	  1808: ;------------------------------------
                        	  1809: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT = *
00:A581 414443          	  1810:   asc "ADC",$61
00:A584 61
00:A585 414E44          	  1811:   asc "AND",$21
00:A588 21
00:A589 434D50          	  1812:   asc "CMP",$C1
00:A58C C1
00:A58D 454F52          	  1813:   asc "EOR",$41
00:A590 41
00:A591 4C4441          	  1814:   asc "LDA",$A1
00:A594 A1
00:A595 4F5241          	  1815:   asc "ORA",$01
00:A598 01
00:A599 534243          	  1816:   asc "SBC",$E1
00:A59C E1
00:A59D 535441          	  1817:   asc "STA",$81
00:A5A0 81
00:A5A1 00              	  1818:   dfb 0
                        	  1819: 
                        	  1820: ;------------------------------------
                        	  1821: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT  - for tokenised opcodes like AND
                        	  1822: ;------------------------------------
                        	  1823: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT_TOKENISED  = *
00:A5A2 8D              	  1824:   dfb TOKEN_AND,$21
00:A5A3 21
00:A5A4 00              	  1825:   dfb 0
                        	  1826: 
                        	  1827: 
                        	  1828: ;------------------------------------
                        	  1829: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
                        	  1830: ;------------------------------------
                        	  1831: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X = *
00:A5A5 414443          	  1832:   asc "ADC",$75
00:A5A8 75
00:A5A9 414E44          	  1833:   asc "AND",$35
00:A5AC 35
00:A5AD 41534C          	  1834:   asc "ASL",$16
00:A5B0 16
00:A5B1 424954          	  1835:   asc "BIT",$34
00:A5B4 34
00:A5B5 434D50          	  1836:   asc "CMP",$D5
00:A5B8 D5
00:A5B9 444543          	  1837:   asc "DEC",$D6
00:A5BC D6
00:A5BD 454F52          	  1838:   asc "EOR",$55
00:A5C0 55
00:A5C1 494E43          	  1839:   asc "INC",$F6
00:A5C4 F6
00:A5C5 4C4441          	  1840:   asc "LDA",$B5
00:A5C8 B5
00:A5C9 4C4459          	  1841:   asc "LDY",$B4
00:A5CC B4
00:A5CD 4C5352          	  1842:   asc "LSR",$56
00:A5D0 56
00:A5D1 4F5241          	  1843:   asc "ORA",$15
00:A5D4 15
00:A5D5 524F4C          	  1844:   asc "ROL",$36
00:A5D8 36
00:A5D9 524F52          	  1845:   asc "ROR",$76
00:A5DC 76
00:A5DD 534243          	  1846:   asc "SBC",$F5
00:A5E0 F5
00:A5E1 535441          	  1847:   asc "STA",$95
00:A5E4 95
00:A5E5 535459          	  1848:   asc "STY",$94
00:A5E8 94
00:A5E9 53545A          	  1849:   asc "STZ",$74
00:A5EC 74
00:A5ED 00              	  1850:   dfb 0
                        	  1851: 
                        	  1852: ;------------------------------------
                        	  1853: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X  - for tokenised opcodes like AND
                        	  1854: ;------------------------------------
                        	  1855: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X_TOKENISED = *
00:A5EE 8D              	  1856:   dfb TOKEN_AND,$35
00:A5EF 35
00:A5F0 00              	  1857:   dfb 0
                        	  1858: 
                        	  1859: ;------------------------------------
                        	  1860: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
                        	  1861: ;------------------------------------
                        	  1862: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y = *
00:A5F1 4C4458          	  1863:   asc "LDX",$B6
00:A5F4 B6
00:A5F5 535458          	  1864:   asc "STX",$96
00:A5F8 96
00:A5F9 00              	  1865:   dfb 0
                        	  1866: 
                        	  1867: ;------------------------------------
                        	  1868: ;  ASS_OPERAND_ZERO_PAGE_INDIRECT
                        	  1869: ;------------------------------------
                        	  1870: OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT = *
00:A5FA 414443          	  1871:   asc "ADC",$72
00:A5FD 72
00:A5FE 414E44          	  1872:   asc "AND",$32
00:A601 32
00:A602 434D50          	  1873:   asc "CMP",$D2
00:A605 D2
00:A606 454F52          	  1874:   asc "EOR",$52
00:A609 52
00:A60A 4C4441          	  1875:   asc "LDA",$B2
00:A60D B2
00:A60E 4F5241          	  1876:   asc "ORA",$12
00:A611 12
00:A612 534243          	  1877:   asc "SBC",$F2
00:A615 F2
00:A616 535441          	  1878:   asc "STA",$92
00:A619 92
00:A61A 00              	  1879:   dfb 0
                        	  1880: 
                        	  1881: ;------------------------------------
                        	  1882: ;  ASS_OPERAND_ZERO_PAGE_INDIRECT  - for tokenised opcodes like AND
                        	  1883: ;------------------------------------
                        	  1884: OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_TOKENISED = *
00:A61B 8D              	  1885:   dfb TOKEN_AND,$32
00:A61C 32
00:A61D 00              	  1886:   dfb 0
                        	  1887: 
                        	  1888: ;------------------------------------
                        	  1889: ;  ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
                        	  1890: ;------------------------------------
                        	  1891: OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y = *
00:A61E 414443          	  1892:   asc "ADC",$71
00:A621 71
00:A622 414E44          	  1893:   asc "AND",$31
00:A625 31
00:A626 434D50          	  1894:   asc "CMP",$D1
00:A629 D1
00:A62A 454F52          	  1895:   asc "EOR",$51
00:A62D 51
00:A62E 4C4441          	  1896:   asc "LDA",$B1
00:A631 B1
00:A632 4F5241          	  1897:   asc "ORA",$11
00:A635 11
00:A636 534243          	  1898:   asc "SBC",$F1
00:A639 F1
00:A63A 535441          	  1899:   asc "STA",$91
00:A63D 91
00:A63E 00              	  1900:   dfb 0
                        	  1901: 
                        	  1902: ;------------------------------------
                        	  1903: ;  ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y - for tokenised opcodes like AND
                        	  1904: ;------------------------------------
                        	  1905: OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y_TOKENISED  = *
00:A63F 8D              	  1906:   dfb TOKEN_AND,$31
00:A640 31
00:A641 00              	  1907:   dfb 0
                        	  1908: 
                        	  1909: 
                        	  1910: ; ---------------------------
                        	  1911: ; Compiler directives
                        	  1912: ; ---------------------------
                        	  1913: 
                        	  1914: ;
                        	  1915: ;  ASSERT <expression>  - raises an error if <expression> is zero
                        	  1916: ;
                        	  1917: asm_do_assert:
00:A642 A56B            	  1918:   lda ASS_OPERAND
00:A644 C901            	  1919:   cmp #ASS_OPERAND_ABSOLUTE
00:A646 D00E            	  1920:   bne asm_do_constant_expectedJ
00:A648 A500            	  1921:   lda VALUE
00:A64A 0501            	  1922:   ora VALUE+1
00:A64C 0502            	  1923:   ora VALUE+2
00:A64E F001            	  1924:   beq asm_do_assert_failed
00:A650 60              	  1925:   rts
                        	  1926: 
                        	  1927: asm_do_assert_failed:
00:A651 A234            	  1928:   ldx #52
00:A653 4C2E96          	  1929:   jmp ass_error
                        	  1930: 
00:A656 4CEEA6          	  1931: asm_do_constant_expectedJ jmp asm_do_constant_expected
                        	  1932: 
                        	  1933: ;
                        	  1934: ; LIST (0= none, 1=source, 2=opcodes, 4=symbols, can OR these together)
                        	  1935: ; LIST  is the same as LIST 3
                        	  1936: 
                        	  1937: asm_do_list = *
                        	  1938: 
                        	  1939: ;   lda #'f'
                        	  1940: ;   jsr ass_debug_point
                        	  1941: 
00:A659 A56B            	  1942:   lda ASS_OPERAND
00:A65B C908            	  1943:   cmp #ASS_OPERAND_IMPLIED      ; implied (ie. no operand) will resolve to be the same as LIST 3
00:A65D F01A            	  1944:   beq asm_do_list_no_operand
00:A65F C901            	  1945:   cmp #ASS_OPERAND_ABSOLUTE
00:A661 F01A            	  1946:   beq asm_do_list_ok
00:A663 A202            	  1947:   ldx #2    ; ERROR: constant expected
00:A665 4C2E96          	  1948:   jmp ass_error
                        	  1949: 
                        	  1950: ;
                        	  1951: ;  NOLIST is the same as LIST 0
                        	  1952: ;
                        	  1953: asm_do_nolist:
00:A668 A56B            	  1954:   lda ASS_OPERAND
00:A66A C908            	  1955:   cmp #ASS_OPERAND_IMPLIED
00:A66C F005            	  1956:   beq asm_do_nolist_ok              ; should have no operand
00:A66E A217            	  1957:   ldx #23   ; ERROR: Illegal factor
00:A670 4C2E96          	  1958:   jmp ass_error
                        	  1959: asm_do_nolist_ok:
00:A673 A900            	  1960:   lda #0
00:A675 8500            	  1961:   sta VALUE
00:A677 8004            	  1962:   bra asm_do_list_ok
                        	  1963: 
                        	  1964: asm_do_list_no_operand:
00:A679 A903            	  1965:   lda #3
00:A67B 8573            	  1966:   sta ASS_VALUE
                        	  1967: asm_do_list_ok:
00:A67D A576            	  1968:   lda ASS_PASS
00:A67F F025            	  1969:   beq asm_do_list_first_pass  ; ignore on first pass
                        	  1970: 
                        	  1971: ;  lda ASS_VALUE
                        	  1972: ;  clc
                        	  1973: ;  adc #'0'
                        	  1974: ;  jsr ass_debug_point
                        	  1975: 
00:A681 A573            	  1976:   lda ASS_VALUE
00:A683 2901            	  1977:   and #$01
00:A685 F00C            	  1978:   beq asm_do_list_not    ; no listing wanted
00:A687 A904            	  1979:   lda #FLAG_LIST_SOURCE ; already listing?
00:A689 25BE            	  1980:   and system_flags
00:A68B D00A            	  1981:   bne  asm_do_list1   ; yep
00:A68D A904            	  1982:   lda #FLAG_LIST_SOURCE
00:A68F 04BE            	  1983:   tsb system_flags
                        	  1984: ;  jsr token_line        ; list the current line  TODO: don't know, I think it bumps the line number wrongly
00:A691 8004            	  1985:   bra asm_do_list1
                        	  1986: 
                        	  1987: ;
                        	  1988: ;  turn off list flag
                        	  1989: ;
                        	  1990: asm_do_list_not:
00:A693 A904            	  1991:   lda #FLAG_LIST_SOURCE
00:A695 14BE            	  1992:   trb system_flags
                        	  1993: 
                        	  1994: asm_do_list1:
                        	  1995: 
                        	  1996: 
00:A697 A573            	  1997:   lda ASS_VALUE
00:A699 2902            	  1998:   and #$02
00:A69B 852E            	  1999:   sta DCODE
                        	  2000: 
                        	  2001: 
00:A69D A573            	  2002:   lda ASS_VALUE
00:A69F 290C            	  2003:   and #($04|$08)
00:A6A1 8582            	  2004:   sta show_symbols
                        	  2005: ;
                        	  2006: ;  output a newline, to get past the asterisks
                        	  2007: ;
00:A6A3 202594          	  2008:   jsr CROUT
                        	  2009: asm_do_list_first_pass:
00:A6A6 60              	  2010:   rts
                        	  2011: 
                        	  2012: ;
                        	  2013: ;  ASC "String"
                        	  2014: ;
                        	  2015: asm_do_asc = *
00:A6A7 A56B            	  2016:   lda ASS_OPERAND
00:A6A9 C911            	  2017:   cmp #ASS_OPERAND_STRING
00:A6AB F005            	  2018:   beq asm_do_asc_ok
00:A6AD A208            	  2019:   ldx #8    ; ERROR: incorrect string
00:A6AF 4C2E96          	  2020:   jmp ass_error
                        	  2021: ;
                        	  2022: ;  now emit the string
                        	  2023: ;
                        	  2024: asm_do_asc_ok:
00:A6B2 A000            	  2025:   ldy  #0
                        	  2026: asm_do_asc_loop:
00:A6B4 B90002          	  2027:   lda  INBUF,Y
00:A6B7 C8              	  2028:   iny         ; onto next character in the string
00:A6B8 5A              	  2029:   phy
00:A6B9 20E8A0          	  2030:   jsr ass_emit
00:A6BC 7A              	  2031:   ply
                        	  2032: 
                        	  2033: asm_do_asc_next:
00:A6BD C692            	  2034:   dec token_length
00:A6BF D0F3            	  2035:   bne asm_do_asc_loop
00:A6C1 60              	  2036:   rts
                        	  2037: 
                        	  2038: 
                        	  2039: ;
                        	  2040: ;  ASCIIZ / STRING - output a string with a null terminator
                        	  2041: ;
                        	  2042: 
                        	  2043: asm_do_string:
00:A6C2 20A7A6          	  2044:   jsr asm_do_asc    ; do the string
00:A6C5 A900            	  2045:   lda #0            ; and the terminator
00:A6C7 20E8A0          	  2046:   jsr ass_emit
00:A6CA 60              	  2047:   rts
                        	  2048: 
                        	  2049: 
                        	  2050: ;
                        	  2051: ;  EQU
                        	  2052: ;
                        	  2053: ;  The label, which must be present, takes on the value of the expression
                        	  2054: ;
                        	  2055: 
                        	  2056: asm_do_equ:
00:A6CB A56B            	  2057:   lda ASS_OPERAND
00:A6CD C901            	  2058:   cmp #ASS_OPERAND_ABSOLUTE
00:A6CF D01D            	  2059:   bne asm_do_constant_expected
00:A6D1 A583            	  2060:   lda ass_current_label
00:A6D3 0584            	  2061:   ora ass_current_label+1
00:A6D5 D005            	  2062:   bne asm_do_equ_have_label
00:A6D7 A230            	  2063:   ldx #48    ; ERROR: label required
00:A6D9 4C2E96          	  2064:   jmp ass_error
                        	  2065: 
                        	  2066: asm_do_equ_have_label:
00:A6DC A004            	  2067:   ldy #SYMDSP
00:A6DE A573            	  2068:   lda ASS_VALUE
00:A6E0 9183            	  2069:   sta (ass_current_label),y
00:A6E2 C8              	  2070:   iny
00:A6E3 A574            	  2071:   lda ASS_VALUE+1
00:A6E5 9183            	  2072:   sta (ass_current_label),y
00:A6E7 60              	  2073:   rts
                        	  2074: 
                        	  2075: ;
                        	  2076: ;  ORG
                        	  2077: ;
                        	  2078: ;  The program counter becomes the value of the expression
                        	  2079: ;
                        	  2080: 
                        	  2081: asm_do_org:
00:A6E8 A56B            	  2082:   lda ASS_OPERAND
00:A6EA C901            	  2083:   cmp #ASS_OPERAND_ABSOLUTE
00:A6EC F005            	  2084:   beq asm_do_org_ok
                        	  2085: asm_do_constant_expected:
00:A6EE A202            	  2086:   ldx #2    ; ERROR: constant expected
00:A6F0 4C2E96          	  2087:   jmp ass_error
                        	  2088: 
                        	  2089: asm_do_org_ok:
00:A6F3 A573            	  2090:   lda ASS_VALUE
00:A6F5 8523            	  2091:   sta PCODE
00:A6F7 A574            	  2092:   lda ASS_VALUE+1
00:A6F9 8524            	  2093:   sta PCODE+1
00:A6FB 60              	  2094:   rts
                        	  2095: 
                        	  2096: ;
                        	  2097: ;  DFB - define one byte (value being the expression)
                        	  2098: ;
                        	  2099: 
                        	  2100: asm_do_dfb:
00:A6FC A56B            	  2101:   lda ASS_OPERAND
00:A6FE C912            	  2102:   cmp #ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE  ; multiple values?
00:A700 F008            	  2103:   beq asm_do_dfb_multiple
00:A702 C901            	  2104:   cmp #ASS_OPERAND_ABSOLUTE
00:A704 D0E8            	  2105:   bne asm_do_constant_expected
00:A706 202EA7          	  2106:   jsr asm_emit_one_byte
00:A709 60              	  2107:   rts
                        	  2108: 
                        	  2109: ;
                        	  2110: ;  so if we got here we thought we had two values (like a BBR0 $12,foo)
                        	  2111: ;  - the first is in REMAIN and the other in VALUE
                        	  2112: ;
                        	  2113: ;  let's emit REMAIN, then VALUE, then look for other values
                        	  2114: ;
                        	  2115: asm_do_dfb_multiple:
00:A70A A507            	  2116:   lda REMAIN+1
00:A70C D01B            	  2117:   bne asm_do_dfb_too_big
00:A70E A508            	  2118:   lda REMAIN+2
00:A710 D017            	  2119:   bne asm_do_dfb_too_big
00:A712 A506            	  2120:   lda REMAIN
00:A714 20E8A0          	  2121:   jsr ass_emit  ; emit REMAIN
                        	  2122: asm_do_dfb_multiple_loop:
00:A717 202EA7          	  2123:   jsr asm_emit_one_byte  ; emit VALUE
00:A71A A593            	  2124:   lda token_type
00:A71C C92C            	  2125:   cmp #','      ; another?
00:A71E D008            	  2126:   bne asm_do_dfb_multiple_done
00:A720 209FCB          	  2127:   jsr get_token
00:A723 20539F          	  2128:   jsr ass_get_value  ; should have some sort of address now in VALUE
00:A726 80EF            	  2129:   bra asm_do_dfb_multiple_loop
                        	  2130: 
                        	  2131: asm_do_dfb_multiple_done:
00:A728 60              	  2132:   rts
                        	  2133: 
                        	  2134: 
                        	  2135: asm_do_dfb_too_big:
00:A729 A22C            	  2136:   ldx #44
00:A72B 4C2E96          	  2137:   jmp ass_error
                        	  2138: 
                        	  2139: asm_emit_one_byte:
00:A72E A574            	  2140:   lda ASS_VALUE+1
00:A730 D0F7            	  2141:   bne asm_do_dfb_too_big
00:A732 A575            	  2142:   lda ASS_VALUE+2
00:A734 D0F3            	  2143:   bne asm_do_dfb_too_big
00:A736 A573            	  2144:   lda ASS_VALUE
00:A738 20E8A0          	  2145:   jsr ass_emit
00:A73B 60              	  2146:   rts
                        	  2147: 
                        	  2148: 
                        	  2149: ;
                        	  2150: ;  DFW - define two bytes (value being the expression)
                        	  2151: ;
                        	  2152: 
                        	  2153: asm_do_dfw:
00:A73C A56B            	  2154:   lda ASS_OPERAND
00:A73E C912            	  2155:   cmp #ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE  ; multiple values?
00:A740 F008            	  2156:   beq asm_do_dfw_multiple
00:A742 C901            	  2157:   cmp #ASS_OPERAND_ABSOLUTE
00:A744 D0A8            	  2158:   bne asm_do_constant_expected
00:A746 206AA7          	  2159:   jsr asm_emit_two_bytes
00:A749 60              	  2160:   rts
                        	  2161: 
                        	  2162: ;
                        	  2163: ;  so if we got here we thought we had two values (like a BBR0 $12,foo)
                        	  2164: ;  - the first is in REMAIN and the other in VALUE
                        	  2165: ;
                        	  2166: ;  let's emit REMAIN, then VALUE, then look for other values
                        	  2167: ;
                        	  2168: asm_do_dfw_multiple:
00:A74A A508            	  2169:   lda REMAIN+2
00:A74C D0DB            	  2170:   bne asm_do_dfb_too_big
00:A74E A506            	  2171:   lda REMAIN
00:A750 20E8A0          	  2172:   jsr ass_emit  ; emit REMAIN
00:A753 A507            	  2173:   lda REMAIN+1
00:A755 20E8A0          	  2174:   jsr ass_emit  ; emit REMAIN+1
                        	  2175: asm_do_dfw_multiple_loop:
00:A758 206AA7          	  2176:   jsr asm_emit_two_bytes  ; emit VALUE
00:A75B A593            	  2177:   lda token_type
00:A75D C92C            	  2178:   cmp #','      ; another?
00:A75F D008            	  2179:   bne asm_do_dfw_multiple_done
00:A761 209FCB          	  2180:   jsr get_token
00:A764 20539F          	  2181:   jsr ass_get_value  ; should have some sort of address now in VALUE
00:A767 80EF            	  2182:   bra asm_do_dfw_multiple_loop
                        	  2183: 
                        	  2184: asm_do_dfw_multiple_done:
00:A769 60              	  2185:   rts
                        	  2186: 
                        	  2187: 
                        	  2188: asm_emit_two_bytes:
00:A76A A575            	  2189:   lda ASS_VALUE+2
00:A76C D0BB            	  2190:   bne asm_do_dfb_too_big
00:A76E A573            	  2191:   lda ASS_VALUE
00:A770 20E8A0          	  2192:   jsr ass_emit
00:A773 A574            	  2193:   lda ASS_VALUE+1
00:A775 20E8A0          	  2194:   jsr ass_emit
00:A778 60              	  2195:   rts
                        	  2196: 
                        	  2197: 
                        	  2198: 
                        	  2199: ;
                        	  2200: ;  BLK - zero fill <expression> bytes (eg. BLK 5 output 5 zeroes)
                        	  2201: ;
                        	  2202: 
                        	  2203: asm_do_blk:
00:A779 A56B            	  2204:   lda ASS_OPERAND
00:A77B C901            	  2205:   cmp #ASS_OPERAND_ABSOLUTE
00:A77D D030            	  2206:   bne asm_do_constant_expectedJ2
00:A77F A575            	  2207:   lda ASS_VALUE+2
00:A781 D0A6            	  2208:   bne asm_do_dfb_too_big
                        	  2209: ;
                        	  2210: ; handle (obscure) case of them defining zero bytes
                        	  2211: ;
00:A783 A573            	  2212:   lda ASS_VALUE
00:A785 0574            	  2213:   ora ASS_VALUE+1
00:A787 F00D            	  2214:   beq asm_do_blk_done
                        	  2215: asm_do_blk_loop:
                        	  2216: ;
                        	  2217: ;  emit one zero
                        	  2218: ;
00:A789 A900            	  2219:   lda #0
00:A78B 20E8A0          	  2220:   jsr ass_emit
00:A78E C673            	  2221:   dec ASS_VALUE
00:A790 D0F7            	  2222:   bne asm_do_blk_loop
00:A792 C674            	  2223:   dec ASS_VALUE+1
00:A794 10F3            	  2224:   bpl asm_do_blk_loop
                        	  2225: asm_do_blk_done:
00:A796 60              	  2226:   rts
                        	  2227: 
                        	  2228: ;
                        	  2229: ;  RESERVE - reserve <expression> bytes without writing to them
                        	  2230: ;   useful for leaving a gap (eg. for zero-page variables)
                        	  2231: ;
                        	  2232: 
                        	  2233: asm_do_reserve:
00:A797 A56B            	  2234:   lda ASS_OPERAND
00:A799 C901            	  2235:   cmp #ASS_OPERAND_ABSOLUTE
00:A79B D012            	  2236:   bne asm_do_constant_expectedJ2
00:A79D A575            	  2237:   lda ASS_VALUE+2
00:A79F D088            	  2238:   bne asm_do_dfb_too_big
00:A7A1 18              	  2239:   clc
00:A7A2 A523            	  2240:   lda PCODE
00:A7A4 6573            	  2241:   adc ASS_VALUE
00:A7A6 8523            	  2242:   sta PCODE
00:A7A8 A524            	  2243:   lda PCODE+1
00:A7AA 6574            	  2244:   adc ASS_VALUE+1
00:A7AC 8524            	  2245:   sta PCODE+1
00:A7AE 60              	  2246:   rts
                        	  2247: 
00:A7AF 4CEEA6          	  2248: asm_do_constant_expectedJ2 jmp asm_do_constant_expected
                        	  2249: 
                        	  2250: ;
                        	  2251: ;  SYM <address> symbol table relocation
                        	  2252: ;
                        	  2253: asm_do_sym:
00:A7B2 A56B            	  2254:   lda ASS_OPERAND
00:A7B4 C901            	  2255:   cmp #ASS_OPERAND_ABSOLUTE
00:A7B6 D0F7            	  2256:   bne asm_do_constant_expectedJ2
                        	  2257: ;
                        	  2258: ;  only relocate symbol table on the first pass
                        	  2259: ;
00:A7B8 A576            	  2260:   lda ASS_PASS
00:A7BA D00F            	  2261:   bne asm_do_sym_done
                        	  2262: 
00:A7BC A573            	  2263:   lda  ASS_VALUE
00:A7BE 8531            	  2264:   sta  ENDSYM
00:A7C0 852F            	  2265:   sta  STARTSYM
00:A7C2 A574            	  2266:   lda  ASS_VALUE+1
00:A7C4 8532            	  2267:   sta  ENDSYM+1        ; store symbol table address
00:A7C6 8530            	  2268:   sta  STARTSYM+1
                        	  2269: ;
                        	  2270: ;  put our library functions back into the symbol table
                        	  2271: ;
00:A7C8 20F8AC          	  2272:   jsr  add_assembler_library_functions  ; add our inbuilt functions to the symbol table
                        	  2273: 
                        	  2274: asm_do_sym_done:
00:A7CB 60              	  2275:   rts
                        	  2276: ;
                        	  2277: 
                        	  2278: 
00:A7CC 41646472204E616D	  2279: info_message asciiz "Addr Name\n"
00:A7D4 650A
00:A7D6 00
                        	  2280: 
                        	  2281: list_symbols  = *
00:A7D7 A9CC            	  2282:          lda #<info_message
00:A7D9 A2A7            	  2283:          ldx #>info_message
00:A7DB 202682          	  2284:          jsr print
                        	  2285: 
00:A7DE A532            	  2286:          lda  ENDSYM+1    ; get the end of the symbol table
00:A7E0 8541            	  2287:          sta  SYMITM+1    ; make it the current symbol
00:A7E2 A531            	  2288:          lda  ENDSYM
00:A7E4 800B            	  2289:          bra  list_symbols_check
                        	  2290: 
                        	  2291: list_symbols_next =  *
00:A7E6 A000            	  2292:          ldy  #SYMPRV
00:A7E8 B140            	  2293:          lda  (SYMITM),Y
00:A7EA AA              	  2294:          tax
00:A7EB C8              	  2295:          iny
00:A7EC B140            	  2296:          lda  (SYMITM),Y
00:A7EE 8541            	  2297:          sta  SYMITM+1   ; previous link
00:A7F0 8A              	  2298:          txa
                        	  2299: ;
                        	  2300: ;  go to the previous symbol table item
                        	  2301: ;
                        	  2302: list_symbols_check     =  *
00:A7F1 8540            	  2303:          sta  SYMITM
00:A7F3 C52F            	  2304:          cmp  STARTSYM
00:A7F5 D009            	  2305:          bne  list_symbols_line
00:A7F7 A541            	  2306:          lda  SYMITM+1
00:A7F9 C530            	  2307:          cmp  STARTSYM+1
00:A7FB D003            	  2308:          bne  list_symbols_line       ; more to go
00:A7FD 4C37A8          	  2309:          jmp  list_symbols_done       ; finished if symitm and symitm+1 are both zero
                        	  2310: 
                        	  2311: list_symbols_line = *
00:A800 A002            	  2312:          ldy  #SYMLIB
00:A802 B140            	  2313:          lda  (SYMITM),Y
00:A804 F006            	  2314:          beq  list_symbols_user
                        	  2315: ;
                        	  2316: ;  this is a library symbol - do they want to see it?
                        	  2317: ;
00:A806 A582            	  2318:          lda show_symbols
00:A808 2908            	  2319:          and #8
00:A80A F0DA            	  2320:          beq list_symbols_next  ; apparently not
                        	  2321: ;
                        	  2322: ;  here to show this symbol
                        	  2323: ;
                        	  2324: list_symbols_user:
00:A80C A004            	  2325:          ldy  #SYMDSP
00:A80E C8              	  2326:          iny
00:A80F B140            	  2327:          lda  (SYMITM),Y  ; displacement
00:A811 209A94          	  2328:          jsr  PRBYTE
00:A814 88              	  2329:          dey
00:A815 B140            	  2330:          lda  (SYMITM),Y  ; displacement
00:A817 209A94          	  2331:          jsr  PRBYTE
00:A81A A920            	  2332:          lda  #' '
00:A81C 208294          	  2333:          jsr  PRCHAR
00:A81F A009            	  2334:          ldy  #SYMLEN
00:A821 B140            	  2335:          lda  (SYMITM),Y  ; length
00:A823 AA              	  2336:          tax
00:A824 A00A            	  2337:          ldy  #SYMNAM
                        	  2338: list_symbols_name = *
00:A826 B140            	  2339:          lda  (SYMITM),Y  ; name
00:A828 5A              	  2340:          phy
00:A829 208294          	  2341:          jsr  PRCHAR
00:A82C 7A              	  2342:          ply
00:A82D C8              	  2343:          iny
00:A82E CA              	  2344:          dex
00:A82F D0F5            	  2345:          bne list_symbols_name
00:A831 202594          	  2346:          jsr CROUT
00:A834 4CE6A7          	  2347:          jmp list_symbols_next
                        	  2348: 
                        	  2349: list_symbols_done = *
00:A837 60              	  2350:          rts
                        	  2351: 
                        	  2352: assembler_library_functions_table:
                        	  2353:   makeAsmLibraryFunction "bcd_result",           bcd_result
00:A838 6263645F72657375	     1M      asciiz   "bcd_result"
00:A840 6C74
00:A842 00
00:A843 6000            	     2M      word     bcd_result
                        	  2354:   makeAsmLibraryFunction "binary_to_decimal",    binary_to_decimal
00:A845 62696E6172795F74	     1M      asciiz   "binary_to_decimal"
00:A84D 6F5F646563696D61
00:A855 6C
00:A856 00
00:A857 7893            	     2M      word     binary_to_decimal
                        	  2355:   makeAsmLibraryFunction "call_a",               call_a
00:A859 63616C6C5F61    	     1M      asciiz   "call_a"
00:A85F 00
00:A860 1000            	     2M      word     call_a
                        	  2356:   makeAsmLibraryFunction "call_p",               call_p
00:A862 63616C6C5F70    	     1M      asciiz   "call_p"
00:A868 00
00:A869 1300            	     2M      word     call_p
                        	  2357:   makeAsmLibraryFunction "call_s",               call_s
00:A86B 63616C6C5F73    	     1M      asciiz   "call_s"
00:A871 00
00:A872 1400            	     2M      word     call_s
                        	  2358:   makeAsmLibraryFunction "call_x",               call_x
00:A874 63616C6C5F78    	     1M      asciiz   "call_x"
00:A87A 00
00:A87B 1100            	     2M      word     call_x
                        	  2359:   makeAsmLibraryFunction "call_y",               call_y
00:A87D 63616C6C5F79    	     1M      asciiz   "call_y"
00:A883 00
00:A884 1200            	     2M      word     call_y
                        	  2360:   makeAsmLibraryFunction "comstl",               COMSTL
00:A886 636F6D73746C    	     1M      asciiz   "comstl"
00:A88C 00
00:A88D 2A94            	     2M      word     COMSTL
                        	  2361:   makeAsmLibraryFunction "cout",                 COUT
00:A88F 636F7574        	     1M      asciiz   "cout"
00:A893 00
00:A894 B395            	     2M      word     COUT
                        	  2362:   .if USE_CP437_FONT
                        	  2363:     makeAsmLibraryFunction "cp437_font",         cp437_font
00:A896 63703433375F666F	     1M      asciiz   "cp437_font"
00:A89E 6E74
00:A8A0 00
00:A8A1 D6D3            	     2M      word     cp437_font
                        	  2364:   .endif
                        	  2365:   makeAsmLibraryFunction "crc16",                crc16
00:A8A3 6372633136      	     1M      asciiz   "crc16"
00:A8A8 00
00:A8A9 FA91            	     2M      word     crc16
                        	  2366:   makeAsmLibraryFunction "crc_addr",             crc_addr
00:A8AB 6372635F61646472	     1M      asciiz   "crc_addr"
00:A8B3 00
00:A8B4 0000            	     2M      word     crc_addr
                        	  2367:   makeAsmLibraryFunction "crc_byte",             crc_byte
00:A8B6 6372635F62797465	     1M      asciiz   "crc_byte"
00:A8BE 00
00:A8BF 2292            	     2M      word     crc_byte
                        	  2368:   makeAsmLibraryFunction "crc_num",              crc_num
00:A8C1 6372635F6E756D  	     1M      asciiz   "crc_num"
00:A8C8 00
00:A8C9 0300            	     2M      word     crc_num
                        	  2369:   makeAsmLibraryFunction "crc_val",              crc_val
00:A8CB 6372635F76616C  	     1M      asciiz   "crc_val"
00:A8D2 00
00:A8D3 0600            	     2M      word     crc_val
                        	  2370:   makeAsmLibraryFunction "crout",                CROUT
00:A8D5 63726F7574      	     1M      asciiz   "crout"
00:A8DA 00
00:A8DB 2594            	     2M      word     CROUT
                        	  2371:   makeAsmLibraryFunction "delay_1ms",            delay_1ms
00:A8DD 64656C61795F316D	     1M      asciiz   "delay_1ms"
00:A8E5 73
00:A8E6 00
00:A8E7 C892            	     2M      word     delay_1ms
                        	  2372:   makeAsmLibraryFunction "delay",                delay
00:A8E9 64656C6179      	     1M      asciiz   "delay"
00:A8EE 00
00:A8EF D292            	     2M      word     delay
                        	  2373:   makeAsmLibraryFunction "dest",                 DEST
00:A8F1 64657374        	     1M      asciiz   "dest"
00:A8F5 00
00:A8F6 0300            	     2M      word     DEST
                        	  2374:   makeAsmLibraryFunction "digitalread",          digitalread
00:A8F8 6469676974616C72	     1M      asciiz   "digitalread"
00:A900 656164
00:A903 00
00:A904 ECCA            	     2M      word     digitalread
                        	  2375:   makeAsmLibraryFunction "digitalwrite",         digitalwrite
00:A906 6469676974616C77	     1M      asciiz   "digitalwrite"
00:A90E 72697465
00:A912 00
00:A913 BDCA            	     2M      word     digitalwrite
                        	  2376:   makeAsmLibraryFunction "display_in_decimal",   display_in_decimal
00:A915 646973706C61795F	     1M      asciiz   "display_in_decimal"
00:A91D 696E5F646563696D
00:A925 616C
00:A927 00
00:A928 4F93            	     2M      word     display_in_decimal
                        	  2377:   makeAsmLibraryFunction "exp_abs_val",          exp_abs_val
00:A92A 6578705F6162735F	     1M      asciiz   "exp_abs_val"
00:A932 76616C
00:A935 00
00:A936 B2AE            	     2M      word     exp_abs_val
                        	  2378:   makeAsmLibraryFunction "exp_add",              exp_add
00:A938 6578705F616464  	     1M      asciiz   "exp_add"
00:A93F 00
00:A940 49AD            	     2M      word     exp_add
                        	  2379:   makeAsmLibraryFunction "exp_bitwise_and",      exp_bitwise_and
00:A942 6578705F62697477	     1M      asciiz   "exp_bitwise_and"
00:A94A 6973655F616E64
00:A951 00
00:A952 ECAD            	     2M      word     exp_bitwise_and
                        	  2380:   makeAsmLibraryFunction "exp_bitwise_or",       exp_bitwise_or
00:A954 6578705F62697477	     1M      asciiz   "exp_bitwise_or"
00:A95C 6973655F6F72
00:A962 00
00:A963 D7AD            	     2M      word     exp_bitwise_or
                        	  2381:   makeAsmLibraryFunction "exp_bitwise_xor",      exp_bitwise_xor
00:A965 6578705F62697477	     1M      asciiz   "exp_bitwise_xor"
00:A96D 6973655F786F72
00:A974 00
00:A975 01AE            	     2M      word     exp_bitwise_xor
                        	  2382:   makeAsmLibraryFunction "exp_divide",           exp_divide
00:A977 6578705F64697669	     1M      asciiz   "exp_divide"
00:A97F 6465
00:A981 00
00:A982 50AF            	     2M      word     exp_divide
                        	  2383:   makeAsmLibraryFunction "exp_eql",              exp_eql
00:A984 6578705F65716C  	     1M      asciiz   "exp_eql"
00:A98B 00
00:A98C 83AD            	     2M      word     exp_eql
                        	  2384:   makeAsmLibraryFunction "exp_false",            exp_false
00:A98E 6578705F66616C73	     1M      asciiz   "exp_false"
00:A996 65
00:A997 00
00:A998 7CAD            	     2M      word     exp_false
                        	  2385:   makeAsmLibraryFunction "exp_geq",              exp_geq
00:A99A 6578705F676571  	     1M      asciiz   "exp_geq"
00:A9A1 00
00:A9A2 D0AD            	     2M      word     exp_geq
                        	  2386:   makeAsmLibraryFunction "exp_greater_than",     exp_greater_than
00:A9A4 6578705F67726561	     1M      asciiz   "exp_greater_than"
00:A9AC 7465725F7468616E
00:A9B4 00
00:A9B5 B2AD            	     2M      word     exp_greater_than
                        	  2387:   makeAsmLibraryFunction "exp_high_byte",        exp_high_byte
00:A9B7 6578705F68696768	     1M      asciiz   "exp_high_byte"
00:A9BF 5F62797465
00:A9C4 00
00:A9C5 A9AE            	     2M      word     exp_high_byte
                        	  2388:   makeAsmLibraryFunction "exp_leq",              exp_leq
00:A9C7 6578705F6C6571  	     1M      asciiz   "exp_leq"
00:A9CE 00
00:A9CF C1AD            	     2M      word     exp_leq
                        	  2389:   makeAsmLibraryFunction "exp_less_than",        exp_less_than
00:A9D1 6578705F6C657373	     1M      asciiz   "exp_less_than"
00:A9D9 5F7468616E
00:A9DE 00
00:A9DF ABAD            	     2M      word     exp_less_than
                        	  2390:   makeAsmLibraryFunction "exp_logical_and",      exp_logical_and
00:A9E1 6578705F6C6F6769	     1M      asciiz   "exp_logical_and"
00:A9E9 63616C5F616E64
00:A9F0 00
00:A9F1 2BAE            	     2M      word     exp_logical_and
                        	  2391:   makeAsmLibraryFunction "exp_logical_or",       exp_logical_or
00:A9F3 6578705F6C6F6769	     1M      asciiz   "exp_logical_or"
00:A9FB 63616C5F6F72
00:AA01 00
00:AA02 1CAE            	     2M      word     exp_logical_or
                        	  2392:   makeAsmLibraryFunction "exp_low_byte",         exp_low_byte
00:AA04 6578705F6C6F775F	     1M      asciiz   "exp_low_byte"
00:AA0C 62797465
00:AA10 00
00:AA11 A4AE            	     2M      word     exp_low_byte
                        	  2393:   makeAsmLibraryFunction "exp_modulo",           exp_modulo
00:AA13 6578705F6D6F6475	     1M      asciiz   "exp_modulo"
00:AA1B 6C6F
00:AA1D 00
00:AA1E B0AF            	     2M      word     exp_modulo
                        	  2394:   makeAsmLibraryFunction "exp_multiply",         exp_multiply
00:AA20 6578705F6D756C74	     1M      asciiz   "exp_multiply"
00:AA28 69706C79
00:AA2C 00
00:AA2D 17AF            	     2M      word     exp_multiply
                        	  2395:   makeAsmLibraryFunction "exp_negate",           exp_negate
00:AA2F 6578705F6E656761	     1M      asciiz   "exp_negate"
00:AA37 7465
00:AA39 00
00:AA3A 6FAE            	     2M      word     exp_negate
                        	  2396:   makeAsmLibraryFunction "exp_neq",              exp_neq
00:AA3C 6578705F6E6571  	     1M      asciiz   "exp_neq"
00:AA43 00
00:AA44 97AD            	     2M      word     exp_neq
                        	  2397:   makeAsmLibraryFunction "exp_not",              exp_not
00:AA46 6578705F6E6F74  	     1M      asciiz   "exp_not"
00:AA4D 00
00:AA4E 82AE            	     2M      word     exp_not
                        	  2398:   makeAsmLibraryFunction "exp_shift_left",       exp_shift_left
00:AA50 6578705F73686966	     1M      asciiz   "exp_shift_left"
00:AA58 745F6C656674
00:AA5E 00
00:AA5F 3DAE            	     2M      word     exp_shift_left
                        	  2399:   makeAsmLibraryFunction "exp_shift_right",      exp_shift_right
00:AA61 6578705F73686966	     1M      asciiz   "exp_shift_right"
00:AA69 745F7269676874
00:AA70 00
00:AA71 56AE            	     2M      word     exp_shift_right
                        	  2400:   makeAsmLibraryFunction "exp_subtract",         exp_subtract
00:AA73 6578705F73756274	     1M      asciiz   "exp_subtract"
00:AA7B 72616374
00:AA7F 00
00:AA80 5DAD            	     2M      word     exp_subtract
                        	  2401:   makeAsmLibraryFunction "exp_true",             exp_true
00:AA82 6578705F74727565	     1M      asciiz   "exp_true"
00:AA8A 00
00:AA8B 73AD            	     2M      word     exp_true
                        	  2402:   makeAsmLibraryFunction "exp_unary_minus",      exp_unary_minus
00:AA8D 6578705F756E6172	     1M      asciiz   "exp_unary_minus"
00:AA95 795F6D696E7573
00:AA9C 00
00:AA9D 90AE            	     2M      word     exp_unary_minus
                        	  2403:   makeAsmLibraryFunction "gen_random",           gen_random
00:AA9F 67656E5F72616E64	     1M      asciiz   "gen_random"
00:AAA7 6F6D
00:AAA9 00
00:AAAA D791            	     2M      word     gen_random
                        	  2404:   makeAsmLibraryFunction "getin",                GETIN
00:AAAC 676574696E      	     1M      asciiz   "getin"
00:AAB1 00
00:AAB2 1FCB            	     2M      word     GETIN
                        	  2405:   makeAsmLibraryFunction "hardware_init",        hardware_init
00:AAB4 6861726477617265	     1M      asciiz   "hardware_init"
00:AABC 5F696E6974
00:AAC1 00
00:AAC2 36CB            	     2M      word     hardware_init
                        	  2406:   makeAsmLibraryFunction "i2c_init",             i2c_init
00:AAC4 6932635F696E6974	     1M      asciiz   "i2c_init"
00:AACC 00
00:AACD C0D1            	     2M      word     i2c_init
                        	  2407:   makeAsmLibraryFunction "i2c_receive",          i2c_receive
00:AACF 6932635F72656365	     1M      asciiz   "i2c_receive"
00:AAD7 697665
00:AADA 00
00:AADB EFD2            	     2M      word     i2c_receive
                        	  2408:   makeAsmLibraryFunction "i2c_send",             i2c_send
00:AADD 6932635F73656E64	     1M      asciiz   "i2c_send"
00:AAE5 00
00:AAE6 C6D2            	     2M      word     i2c_send
                        	  2409:   makeAsmLibraryFunction "inbuf",                INBUF
00:AAE8 696E627566      	     1M      asciiz   "inbuf"
00:AAED 00
00:AAEE 0002            	     2M      word     INBUF
                        	  2410:   makeAsmLibraryFunction "isalnum",              isalnum
00:AAF0 6973616C6E756D  	     1M      asciiz   "isalnum"
00:AAF7 00
00:AAF8 6281            	     2M      word     isalnum
                        	  2411:   makeAsmLibraryFunction "isalpha",              isalpha
00:AAFA 6973616C706861  	     1M      asciiz   "isalpha"
00:AB01 00
00:AB02 2681            	     2M      word     isalpha
                        	  2412:   makeAsmLibraryFunction "iscntrl",              iscntrl
00:AB04 6973636E74726C  	     1M      asciiz   "iscntrl"
00:AB0B 00
00:AB0C 5681            	     2M      word     iscntrl
                        	  2413:   makeAsmLibraryFunction "isdigit",              isdigit
00:AB0E 69736469676974  	     1M      asciiz   "isdigit"
00:AB15 00
00:AB16 3281            	     2M      word     isdigit
                        	  2414:   makeAsmLibraryFunction "islower",              islower
00:AB18 69736C6F776572  	     1M      asciiz   "islower"
00:AB1F 00
00:AB20 1A81            	     2M      word     islower
                        	  2415:   makeAsmLibraryFunction "isspace",              isspace
00:AB22 69737370616365  	     1M      asciiz   "isspace"
00:AB29 00
00:AB2A 4A81            	     2M      word     isspace
                        	  2416:   makeAsmLibraryFunction "isupper",              isupper
00:AB2C 69737570706572  	     1M      asciiz   "isupper"
00:AB33 00
00:AB34 0E81            	     2M      word     isupper
                        	  2417:   makeAsmLibraryFunction "isxdigit",             isxdigit
00:AB36 6973786469676974	     1M      asciiz   "isxdigit"
00:AB3E 00
00:AB3F 3E81            	     2M      word     isxdigit
                        	  2418:   makeAsmLibraryFunction "lcd_clear_display",    lcd_clear_display
00:AB41 6C63645F636C6561	     1M      asciiz   "lcd_clear_display"
00:AB49 725F646973706C61
00:AB51 79
00:AB52 00
00:AB53 E0C8            	     2M      word     lcd_clear_display
                        	  2419:   makeAsmLibraryFunction "lcd_get_address",      lcd_get_address
00:AB55 6C63645F6765745F	     1M      asciiz   "lcd_get_address"
00:AB5D 61646472657373
00:AB64 00
00:AB65 6CC8            	     2M      word     lcd_get_address
                        	  2420:   makeAsmLibraryFunction "lcd_home",             lcd_home
00:AB67 6C63645F686F6D65	     1M      asciiz   "lcd_home"
00:AB6F 00
00:AB70 F0C8            	     2M      word     lcd_home
                        	  2421:   makeAsmLibraryFunction "lcd_instruction",      lcd_instruction
00:AB72 6C63645F696E7374	     1M      asciiz   "lcd_instruction"
00:AB7A 72756374696F6E
00:AB81 00
00:AB82 8CC8            	     2M      word     lcd_instruction
                        	  2422:   makeAsmLibraryFunction "lcd_print_char",       lcd_print_char
00:AB84 6C63645F7072696E	     1M      asciiz   "lcd_print_char"
00:AB8C 745F63686172
00:AB92 00
00:AB93 AEC8            	     2M      word     lcd_print_char
                        	  2423:   makeAsmLibraryFunction "lcd_print_message",    lcd_print_message
00:AB95 6C63645F7072696E	     1M      asciiz   "lcd_print_message"
00:AB9D 745F6D6573736167
00:ABA5 65
00:ABA6 00
00:ABA7 F8C8            	     2M      word     lcd_print_message
                        	  2424:   makeAsmLibraryFunction "lcd_second_line",      lcd_second_line
00:ABA9 6C63645F7365636F	     1M      asciiz   "lcd_second_line"
00:ABB1 6E645F6C696E65
00:ABB8 00
00:ABB9 E8C8            	     2M      word     lcd_second_line
                        	  2425:   makeAsmLibraryFunction "lcd_wait",             lcd_wait
00:ABBB 6C63645F77616974	     1M      asciiz   "lcd_wait"
00:ABC3 00
00:ABC4 51C8            	     2M      word     lcd_wait
                        	  2426:   makeAsmLibraryFunction "nmi",                  RESTART
00:ABC6 6E6D69          	     1M      asciiz   "nmi"
00:ABC9 00
00:ABCA 65DC            	     2M      word     RESTART
                        	  2427:   makeAsmLibraryFunction "pinmode",              pinmode
00:ABCC 70696E6D6F6465  	     1M      asciiz   "pinmode"
00:ABD3 00
00:ABD4 8ECA            	     2M      word     pinmode
                        	  2428:   makeAsmLibraryFunction "prbyte",               PRBYTE
00:ABD6 707262797465    	     1M      asciiz   "prbyte"
00:ABDC 00
00:ABDD 9A94            	     2M      word     PRBYTE
                        	  2429:   makeAsmLibraryFunction "prchar",               PRCHAR
00:ABDF 707263686172    	     1M      asciiz   "prchar"
00:ABE5 00
00:ABE6 8294            	     2M      word     PRCHAR
                        	  2430:   makeAsmLibraryFunction "print",                print
00:ABE8 7072696E74      	     1M      asciiz   "print"
00:ABED 00
00:ABEE 2682            	     2M      word     print
                        	  2431:   makeAsmLibraryFunction "putsp",                PUTSP
00:ABF0 7075747370      	     1M      asciiz   "putsp"
00:ABF5 00
00:ABF6 B094            	     2M      word     PUTSP
                        	  2432:   makeAsmLibraryFunction "random",               random
00:ABF8 72616E646F6D    	     1M      asciiz   "random"
00:ABFE 00
00:ABFF 0900            	     2M      word     random
                        	  2433:   makeAsmLibraryFunction "remain",               REMAIN
00:AC01 72656D61696E    	     1M      asciiz   "remain"
00:AC07 00
00:AC08 0600            	     2M      word     REMAIN
                        	  2434:   makeAsmLibraryFunction "reset",                START
00:AC0A 7265736574      	     1M      asciiz   "reset"
00:AC0F 00
00:AC10 49DC            	     2M      word     START
                        	  2435:   makeAsmLibraryFunction "serial_available",     serial_available
00:AC12 73657269616C5F61	     1M      asciiz   "serial_available"
00:AC1A 7661696C61626C65
00:AC22 00
00:AC23 30CB            	     2M      word     serial_available
                        	  2436:   makeAsmLibraryFunction "serial_print_message", serial_print_message
00:AC25 73657269616C5F70	     1M      asciiz   "serial_print_message"
00:AC2D 72696E745F6D6573
00:AC35 73616765
00:AC39 00
00:AC3A 8ECB            	     2M      word     serial_print_message
                        	  2437:   makeAsmLibraryFunction "spi_init",             spi_init
00:AC3C 7370695F696E6974	     1M      asciiz   "spi_init"
00:AC44 00
00:AC45 1CD3            	     2M      word     spi_init
                        	  2438:   makeAsmLibraryFunction "spi_send_two_bytes",   spi_send_two_bytes
00:AC47 7370695F73656E64	     1M      asciiz   "spi_send_two_bytes"
00:AC4F 5F74776F5F627974
00:AC57 6573
00:AC59 00
00:AC5A C6D3            	     2M      word     spi_send_two_bytes
                        	  2439:   makeAsmLibraryFunction "spi_ss_high",          spi_ss_high
00:AC5C 7370695F73735F68	     1M      asciiz   "spi_ss_high"
00:AC64 696768
00:AC67 00
00:AC68 BED3            	     2M      word     spi_ss_high
                        	  2440:   makeAsmLibraryFunction "spi_ss_low",           spi_ss_low
00:AC6A 7370695F73735F6C	     1M      asciiz   "spi_ss_low"
00:AC72 6F77
00:AC74 00
00:AC75 B6D3            	     2M      word     spi_ss_low
                        	  2441:   makeAsmLibraryFunction "spi_transfer",         spi_transfer
00:AC77 7370695F7472616E	     1M      asciiz   "spi_transfer"
00:AC7F 73666572
00:AC83 00
00:AC84 52D3            	     2M      word     spi_transfer
                        	  2442:   makeAsmLibraryFunction "srce",                 SRCE
00:AC86 73726365        	     1M      asciiz   "srce"
00:AC8A 00
00:AC8B 0000            	     2M      word     SRCE
                        	  2443:   makeAsmLibraryFunction "tknjmp",               TKNJMP
00:AC8D 746B6E6A6D70    	     1M      asciiz   "tknjmp"
00:AC93 00
00:AC94 8F91            	     2M      word     TKNJMP
                        	  2444:   makeAsmLibraryFunction "typing_latency",       typing_latency
00:AC96 747970696E675F6C	     1M      asciiz   "typing_latency"
00:AC9E 6174656E6379
00:ACA4 00
00:ACA5 0D00            	     2M      word     typing_latency
                        	  2445:   makeAsmLibraryFunction "value2",               VALUE2
00:ACA7 76616C756532    	     1M      asciiz   "value2"
00:ACAD 00
00:ACAE 0300            	     2M      word     VALUE2
                        	  2446:   makeAsmLibraryFunction "value",                VALUE
00:ACB0 76616C7565      	     1M      asciiz   "value"
00:ACB5 00
00:ACB6 0000            	     2M      word     VALUE
                        	  2447:   makeAsmLibraryFunction "write_char",           write_char
00:ACB8 77726974655F6368	     1M      asciiz   "write_char"
00:ACC0 6172
00:ACC2 00
00:ACC3 69CB            	     2M      word     write_char
                        	  2448:   makeAsmLibraryFunction "write_function",       write_function
00:ACC5 77726974655F6675	     1M      asciiz   "write_function"
00:ACCD 6E6374696F6E
00:ACD3 00
00:ACD4 1700            	     2M      word     write_function
                        	  2449:   makeAsmLibraryFunction "write_to_lcd",         write_to_lcd
00:ACD6 77726974655F746F	     1M      asciiz   "write_to_lcd"
00:ACDE 5F6C6364
00:ACE2 00
00:ACE3 14CB            	     2M      word     write_to_lcd
                        	  2450:   makeAsmLibraryFunction "write_to_serial",      write_to_serial
00:ACE5 77726974655F746F	     1M      asciiz   "write_to_serial"
00:ACED 5F73657269616C
00:ACF4 00
00:ACF5 09CB            	     2M      word     write_to_serial
                        	  2451: 
00:ACF7 00              	  2452:   dfb 0   ; end of table
                        	  2453: 
                        	  2454: ;
                        	  2455: ;  Assembler library symbols will be loaded from the above table into
                        	  2456: ;  the symbol table. The symbol type will be SYMBOL_CONSTANT, the
                        	  2457: ;  displacement will be the address of the symbol, and SYMLIB will
                        	  2458: ;  be 1 to indicate an inbuilt symbol.
                        	  2459: ;
                        	  2460: 
                        	  2461: add_assembler_library_functions:
00:ACF8 A938            	  2462:   lda #<assembler_library_functions_table
00:ACFA 8500            	  2463:   sta REG
00:ACFC A9A8            	  2464:   lda #>assembler_library_functions_table
00:ACFE 8501            	  2465:   sta REG+1
                        	  2466: add_assembler_library_functions_loop:
00:AD00 A000            	  2467:   ldy #0
00:AD02 B100            	  2468:   lda (REG),Y
00:AD04 F042            	  2469:   beq add_assembler_library_functions_done
00:AD06 A500            	  2470:   lda REG
00:AD08 8590            	  2471:   sta token_address
00:AD0A A501            	  2472:   lda REG+1
00:AD0C 8591            	  2473:   sta token_address+1
00:AD0E 6492            	  2474:   stz token_length
                        	  2475: ;
                        	  2476: ;  find name length
                        	  2477: ;
                        	  2478: add_assembler_library_functions_name_loop
00:AD10 C8              	  2479:   iny
00:AD11 E692            	  2480:   inc token_length
00:AD13 B100            	  2481:   lda (REG),Y
00:AD15 D0F9            	  2482:   bne add_assembler_library_functions_name_loop
00:AD17 5A              	  2483:   phy
00:AD18 202FCA          	  2484:   jsr CHKDUP
00:AD1B A943            	  2485:   lda #SYMBOL_CONSTANT  ; add the symbol as a constant for now
00:AD1D 2088C9          	  2486:   jsr ADDSYM
00:AD20 7A              	  2487:   ply
                        	  2488: 
00:AD21 C8              	  2489:   iny             ; get next byte
00:AD22 B100            	  2490:   lda (REG),Y     ; get function address low-byte
00:AD24 5A              	  2491:   phy
00:AD25 A004            	  2492:   ldy #SYMDSP
00:AD27 9140            	  2493:   sta (SYMITM),Y  ; save function address low-byte
00:AD29 7A              	  2494:   ply
                        	  2495: 
00:AD2A C8              	  2496:   iny             ; get next byte
00:AD2B B100            	  2497:   lda (REG),Y     ; get function address high-byte
00:AD2D 5A              	  2498:   phy
00:AD2E A005            	  2499:   ldy #SYMDSP+1
00:AD30 9140            	  2500:   sta (SYMITM),Y  ; save function address high-byte
00:AD32 A002            	  2501:   ldy #SYMLIB     ; the "level" of library symbols is 1
00:AD34 A901            	  2502:   lda #1
00:AD36 9140            	  2503:   sta (SYMITM),Y
00:AD38 7A              	  2504:   ply
                        	  2505: 
00:AD39 C8              	  2506:   iny         ; get past that last byte
00:AD3A 98              	  2507:   tya         ; move REG onto next entry
00:AD3B 18              	  2508:   clc
00:AD3C 6500            	  2509:   adc REG
00:AD3E 8500            	  2510:   sta REG
00:AD40 A900            	  2511:   lda #0
00:AD42 6501            	  2512:   adc REG+1
00:AD44 8501            	  2513:   sta REG+1
00:AD46 80B8            	  2514:   bra add_assembler_library_functions_loop
                        	  2515: 
                        	  2516: add_assembler_library_functions_done:
00:AD48 60              	  2517:   rts
                        	  2518: 

Source: "gpascal.asm"
                        	   187:   .endif    ; USE_ASSEMBLER
                        	   188: 
                        	   189:   .include "math.inc"

Source: "math.inc"
                        	     1: ;--------------------------------------------------
                        	     2: ; Maths routines. 3-byte operations on VALUE and VALUE2
                        	     3: ;
                        	     4: ;--------------------------------------------------
                        	     5: exp_add:
00:AD49 18              	     6:   clc
00:AD4A A500            	     7:   lda VALUE
00:AD4C 6503            	     8:   adc VALUE2
00:AD4E 8500            	     9:   sta VALUE
00:AD50 A501            	    10:   lda VALUE+1
00:AD52 6504            	    11:   adc VALUE2+1
00:AD54 8501            	    12:   sta VALUE+1
00:AD56 A502            	    13:   lda VALUE+2
00:AD58 6505            	    14:   adc VALUE2+2
00:AD5A 8502            	    15:   sta VALUE+2
00:AD5C 60              	    16:   rts
                        	    17: 
                        	    18: ;
                        	    19: ;  subtract VALUE2 from VALUE, store in VALUE, also set the sign bit
                        	    20: ;   and put the low order two bytes in X and Y
                        	    21: ;
                        	    22: exp_subtract:
00:AD5D 38              	    23:   sec
00:AD5E A500            	    24:   lda VALUE
00:AD60 E503            	    25:   sbc VALUE2
00:AD62 8500            	    26:   sta VALUE
00:AD64 A8              	    27:   tay
00:AD65 A501            	    28:   lda VALUE+1
00:AD67 E504            	    29:   sbc VALUE2+1
00:AD69 AA              	    30:   tax
00:AD6A 8501            	    31:   sta VALUE+1
00:AD6C A502            	    32:   lda VALUE+2
00:AD6E E505            	    33:   sbc VALUE2+2
00:AD70 8502            	    34:   sta VALUE+2
00:AD72 60              	    35:   rts
                        	    36: 
                        	    37: exp_true:
00:AD73 A901            	    38:   lda #1
00:AD75 8500            	    39:   sta VALUE
00:AD77 6401            	    40:   stz VALUE+1
00:AD79 6402            	    41:   stz VALUE+2
00:AD7B 60              	    42:   rts
                        	    43: 
                        	    44: exp_false:
00:AD7C 6400            	    45:   stz VALUE
00:AD7E 6401            	    46:   stz VALUE+1
00:AD80 6402            	    47:   stz VALUE+2
00:AD82 60              	    48:   rts
                        	    49: 
                        	    50: exp_eql:
00:AD83 A500            	    51:   lda VALUE
00:AD85 C503            	    52:   cmp VALUE2
00:AD87 D0F3            	    53:   bne exp_false
00:AD89 A501            	    54:   lda VALUE+1
00:AD8B C504            	    55:   cmp VALUE2+1
00:AD8D D0ED            	    56:   bne exp_false
00:AD8F A502            	    57:   lda VALUE+2
00:AD91 C505            	    58:   cmp VALUE2+2
00:AD93 D0E7            	    59:   bne exp_false
00:AD95 80DC            	    60:   bra exp_true
                        	    61: 
                        	    62: exp_neq:
00:AD97 A500            	    63:   lda VALUE
00:AD99 C503            	    64:   cmp VALUE2
00:AD9B D0D6            	    65:   bne exp_true
00:AD9D A501            	    66:   lda VALUE+1
00:AD9F C504            	    67:   cmp VALUE2+1
00:ADA1 D0D0            	    68:   bne exp_true
00:ADA3 A502            	    69:   lda VALUE+2
00:ADA5 C505            	    70:   cmp VALUE2+2
00:ADA7 D0CA            	    71:   bne exp_true
00:ADA9 80D1            	    72:   bra exp_false
                        	    73: 
                        	    74: exp_less_than:
00:ADAB 205DAD          	    75:   jsr exp_subtract
00:ADAE 30C3            	    76:   bmi exp_true
00:ADB0 10CA            	    77:   bpl exp_false
                        	    78: 
                        	    79: exp_greater_than:
00:ADB2 205DAD          	    80:   jsr exp_subtract
00:ADB5 30C5            	    81:   bmi exp_false
00:ADB7 D0BA            	    82:   bne exp_true
00:ADB9 98              	    83:   tya
00:ADBA D0B7            	    84:   bne exp_true
00:ADBC 8A              	    85:   txa
00:ADBD D0B4            	    86:   bne exp_true
00:ADBF 10BB            	    87:   bpl exp_false
                        	    88: 
                        	    89: exp_leq:
00:ADC1 205DAD          	    90:   jsr exp_subtract
00:ADC4 30AD            	    91:   bmi exp_true
00:ADC6 D0B4            	    92:   bne exp_false
00:ADC8 98              	    93:   tya
00:ADC9 D0B1            	    94:   bne exp_false
00:ADCB 8A              	    95:   txa
00:ADCC D0AE            	    96:   bne exp_false
00:ADCE 10A3            	    97:   bpl exp_true
                        	    98: 
                        	    99: exp_geq:
00:ADD0 205DAD          	   100:   jsr exp_subtract
00:ADD3 30A7            	   101:   bmi exp_false
00:ADD5 109C            	   102:   bpl exp_true
                        	   103: 
                        	   104: exp_bitwise_or:
00:ADD7 A500            	   105:   lda VALUE
00:ADD9 0503            	   106:   ora VALUE2
00:ADDB 8500            	   107:   sta VALUE
00:ADDD A8              	   108:   tay
00:ADDE A501            	   109:   lda VALUE+1
00:ADE0 0504            	   110:   ora VALUE2+1
00:ADE2 8501            	   111:   sta VALUE+1
00:ADE4 AA              	   112:   tax
00:ADE5 A502            	   113:   lda VALUE+2
00:ADE7 0505            	   114:   ora VALUE2+2
00:ADE9 8502            	   115:   sta VALUE+2
00:ADEB 60              	   116:   rts
                        	   117: 
                        	   118: exp_bitwise_and:
00:ADEC A500            	   119:   lda VALUE
00:ADEE 2503            	   120:   and VALUE2
00:ADF0 8500            	   121:   sta VALUE
00:ADF2 A8              	   122:   tay
00:ADF3 A501            	   123:   lda VALUE+1
00:ADF5 2504            	   124:   and VALUE2+1
00:ADF7 8501            	   125:   sta VALUE+1
00:ADF9 AA              	   126:   tax
00:ADFA A502            	   127:   lda VALUE+2
00:ADFC 2505            	   128:   and VALUE2+2
00:ADFE 8502            	   129:   sta VALUE+2
00:AE00 60              	   130:   rts
                        	   131: 
                        	   132: exp_bitwise_xor:
00:AE01 A500            	   133:   lda VALUE
00:AE03 4503            	   134:   eor VALUE2
00:AE05 8500            	   135:   sta VALUE
00:AE07 A8              	   136:   tay
00:AE08 A501            	   137:   lda VALUE+1
00:AE0A 4504            	   138:   eor VALUE2+1
00:AE0C 8501            	   139:   sta VALUE+1
00:AE0E AA              	   140:   tax
00:AE0F A502            	   141:   lda VALUE+2
00:AE11 4505            	   142:   eor VALUE2+2
00:AE13 8502            	   143:   sta VALUE+2
00:AE15 60              	   144:   rts
                        	   145: 
                        	   146: 
00:AE16 4C73AD          	   147: exp_trueJ jmp exp_true
00:AE19 4C7CAD          	   148: exp_falseJ jmp exp_false
                        	   149: 
                        	   150: exp_logical_or:
00:AE1C 20D7AD          	   151:   jsr exp_bitwise_or
00:AE1F D0F5            	   152:   bne exp_trueJ
00:AE21 E000            	   153:   cpx #0
00:AE23 D0F1            	   154:   bne exp_trueJ
00:AE25 C000            	   155:   cpy #0
00:AE27 D0ED            	   156:   bne exp_trueJ
00:AE29 80EE            	   157:   bra exp_falseJ
                        	   158: 
                        	   159: exp_logical_and:
00:AE2B A500            	   160:   lda VALUE
00:AE2D 0501            	   161:   ora VALUE+1
00:AE2F 0502            	   162:   ora VALUE+2
00:AE31 F0E6            	   163:   beq exp_falseJ  ; if VALUE has all bits zero the logical "and" must be false
                        	   164: ;
                        	   165: ;  VALUE is non-zero, how about VALUE2?
                        	   166: ;
00:AE33 A503            	   167:   lda VALUE2
00:AE35 0504            	   168:   ora VALUE2+1
00:AE37 0505            	   169:   ora VALUE2+2
00:AE39 F0DE            	   170:   beq exp_falseJ  ; if VALUE2 has all bits zero the logical "and" must be false
00:AE3B 80D9            	   171:   bra exp_trueJ   ; both are non-zero, therefore the result is true
                        	   172: 
                        	   173: exp_shift_left:
00:AE3D A504            	   174:   lda VALUE2+1
00:AE3F 0505            	   175:   ora VALUE2+2
00:AE41 D0D6            	   176:   bne exp_falseJ  ; big shifts will return zero
00:AE43 A503            	   177:   lda VALUE2
00:AE45 F00E            	   178:   beq exp_shift_left_done ; shift by zero? we are done then
00:AE47 AA              	   179:   tax
00:AE48 29E0            	   180:   and #$E0        ; maximum of 32 shifts
00:AE4A D0CD            	   181:   bne exp_falseJ
                        	   182: exp_shift_left_loop:
00:AE4C 0600            	   183:   asl VALUE
00:AE4E 2601            	   184:   rol VALUE+1
00:AE50 2602            	   185:   rol VALUE+2
00:AE52 CA              	   186:   dex
00:AE53 D0F7            	   187:   bne exp_shift_left_loop
                        	   188: exp_shift_left_done:
00:AE55 60              	   189:   rts
                        	   190: 
                        	   191: exp_shift_right:
00:AE56 A504            	   192:   lda VALUE2+1
00:AE58 0505            	   193:   ora VALUE2+2
00:AE5A D0BD            	   194:   bne exp_falseJ  ; big shifts will return zero
00:AE5C A503            	   195:   lda VALUE2
00:AE5E F00E            	   196:   beq exp_shift_right_done ; shift by zero? we are done then
00:AE60 AA              	   197:   tax
00:AE61 29E0            	   198:   and #$E0        ; maximum of 32 shifts
00:AE63 D0B4            	   199:   bne exp_falseJ
                        	   200: exp_shift_right_loop:
00:AE65 4602            	   201:   lsr VALUE+2
00:AE67 6601            	   202:   ror VALUE+1
00:AE69 6600            	   203:   ror VALUE
00:AE6B CA              	   204:   dex
00:AE6C D0F7            	   205:   bne exp_shift_right_loop
                        	   206: exp_shift_right_done:
00:AE6E 60              	   207:   rts
                        	   208: 
                        	   209: exp_negate:
00:AE6F A500            	   210:   lda VALUE
00:AE71 49FF            	   211:   eor #$FF
00:AE73 8500            	   212:   sta VALUE
00:AE75 A501            	   213:   lda VALUE+1
00:AE77 49FF            	   214:   eor #$FF
00:AE79 8501            	   215:   sta VALUE+1
00:AE7B A502            	   216:   lda VALUE+2
00:AE7D 49FF            	   217:   eor #$FF
00:AE7F 8502            	   218:   sta VALUE+2
00:AE81 60              	   219:   rts
                        	   220: 
                        	   221: exp_not:
00:AE82 A500            	   222:   lda VALUE
00:AE84 D093            	   223:   bne exp_falseJ
00:AE86 A501            	   224:   lda VALUE+1
00:AE88 D08F            	   225:   bne exp_falseJ
00:AE8A A502            	   226:   lda VALUE+2
00:AE8C D08B            	   227:   bne exp_falseJ
00:AE8E 8086            	   228:   bra exp_trueJ
                        	   229: 
                        	   230: exp_unary_minus:
00:AE90 38              	   231:   sec
00:AE91 A900            	   232:   lda #0
00:AE93 E500            	   233:   sbc VALUE
00:AE95 8500            	   234:   sta VALUE
00:AE97 A900            	   235:   lda #0
00:AE99 E501            	   236:   sbc VALUE+1
00:AE9B 8501            	   237:   sta VALUE+1
00:AE9D A900            	   238:   lda #0
00:AE9F E502            	   239:   sbc VALUE+2
00:AEA1 8502            	   240:   sta VALUE+2
00:AEA3 60              	   241:   rts
                        	   242: 
                        	   243: 
                        	   244: exp_low_byte:
00:AEA4 6401            	   245:   stz VALUE+1
00:AEA6 6402            	   246:   stz VALUE+2
00:AEA8 60              	   247:   rts
                        	   248: 
                        	   249: exp_high_byte:
00:AEA9 A501            	   250:   lda VALUE+1
00:AEAB 8500            	   251:   sta VALUE
00:AEAD 6401            	   252:   stz VALUE+1
00:AEAF 6402            	   253:   stz VALUE+2
00:AEB1 60              	   254:   rts
                        	   255: 
                        	   256: ;
                        	   257: ;  make VALUE positive
                        	   258: ;
                        	   259: exp_abs_val:
00:AEB2 A502            	   260:   lda  VALUE+2  ; check high-order byte, see if negative
00:AEB4 1013            	   261:   bpl  exp_abs_val_done
                        	   262: exp_negate_val:
00:AEB6 38              	   263:   sec
00:AEB7 A900            	   264:   lda  #0
00:AEB9 E500            	   265:   sbc  VALUE
00:AEBB 8500            	   266:   sta  VALUE
00:AEBD A900            	   267:   lda  #0
00:AEBF E501            	   268:   sbc  VALUE+1
00:AEC1 8501            	   269:   sta  VALUE+1
00:AEC3 A900            	   270:   lda  #0
00:AEC5 E502            	   271:   sbc  VALUE+2
00:AEC7 8502            	   272:   sta  VALUE+2
                        	   273: exp_abs_val_done:
00:AEC9 60              	   274:   rts
                        	   275: 
                        	   276: ;
                        	   277: ;  make VALUE2 positive
                        	   278: ;
                        	   279: exp_abs_val2:
00:AECA A505            	   280:   lda  VALUE2+2  ; check high-order byte, see if negative
00:AECC 1013            	   281:   bpl  exp_abs_val2_done
                        	   282: exp_negate_val2:
00:AECE 38              	   283:   sec
00:AECF A900            	   284:   lda  #0
00:AED1 E503            	   285:   sbc  VALUE2
00:AED3 8503            	   286:   sta  VALUE2
00:AED5 A900            	   287:   lda  #0
00:AED7 E504            	   288:   sbc  VALUE2+1
00:AED9 8504            	   289:   sta  VALUE2+1
00:AEDB A900            	   290:   lda  #0
00:AEDD E505            	   291:   sbc  VALUE2+2
00:AEDF 8505            	   292:   sta  VALUE2+2
                        	   293: exp_abs_val2_done:
00:AEE1 60              	   294:   rts
                        	   295: 
                        	   296: 
                        	   297: ZERRES:
00:AEE2 A900            	   298:   lda  #0
00:AEE4 8552            	   299:   sta  RES
00:AEE6 8553            	   300:   sta  RES+1
00:AEE8 8554            	   301:   sta  RES+2
00:AEEA 60              	   302:   rts
                        	   303: 
                        	   304: exp_find_sign:
00:AEEB 20E2AE          	   305:    jsr  ZERRES     ; zero result
00:AEEE A502            	   306:    lda  VALUE+2
00:AEF0 2980            	   307:    and  #$80
00:AEF2 855B            	   308:    sta  RMNDR
00:AEF4 A505            	   309:    lda  VALUE2+2
00:AEF6 2980            	   310:    and  #$80
00:AEF8 455B            	   311:    eor  RMNDR
00:AEFA 855B            	   312:    sta  RMNDR     ; RMNDR is 0x80 if the result needs to be negative
00:AEFC 20B2AE          	   313:    jsr  exp_abs_val
00:AEFF 20CAAE          	   314:    jsr  exp_abs_val2
00:AF02 60              	   315:    rts
                        	   316: ;
                        	   317: 
                        	   318: exp_fix_sign:
00:AF03 A55B            	   319:   lda  RMNDR
00:AF05 100F            	   320:   bpl  exp_fix_sign_done      ; nothing needs to be changed
00:AF07 38              	   321:   sec                         ; subtract result from zero
00:AF08 A900            	   322:   lda  #0
00:AF0A E552            	   323:   sbc  RES
00:AF0C AA              	   324:   tax
00:AF0D A900            	   325:   lda  #0
00:AF0F E553            	   326:   sbc  RES+1
00:AF11 A8              	   327:   tay
00:AF12 A900            	   328:   lda  #0
00:AF14 E554            	   329:   sbc  RES+2
                        	   330: exp_fix_sign_done:
00:AF16 60              	   331:   rts
                        	   332: 
                        	   333: 
                        	   334: ;
                        	   335: ;  multiply VALUE1 by VALUE2 and store in VALUE
                        	   336: ;
                        	   337: ;  see: https://llx.com/Neil/a2/mult.html for a discussion
                        	   338: ;
                        	   339: 
                        	   340: exp_multiply:
00:AF17 20EBAE          	   341:   jsr exp_find_sign
00:AF1A A218            	   342:   ldx  #24       ; for all 24 bits
                        	   343: exp_multiply_loop:
00:AF1C 0652            	   344:   asl  RES
00:AF1E 2653            	   345:   rol  RES+1
00:AF20 2654            	   346:   rol  RES+2                    ; shift RES left one bit
00:AF22 0600            	   347:   asl  VALUE
00:AF24 2601            	   348:   rol  VALUE+1
00:AF26 2602            	   349:   rol  VALUE+2                  ; shift one argument left one bit and get the low-order bit into carry
00:AF28 9013            	   350:   bcc  exp_multiply_no_add      ; if no low-order bit, don't add anything
00:AF2A 18              	   351:   clc                           ; add the other argument to the result
00:AF2B A503            	   352:   lda  VALUE2
00:AF2D 6552            	   353:   adc  RES
00:AF2F 8552            	   354:   sta  RES
00:AF31 A504            	   355:   lda  VALUE2+1
00:AF33 6553            	   356:   adc  RES+1
00:AF35 8553            	   357:   sta  RES+1
00:AF37 A505            	   358:   lda  VALUE2+2
00:AF39 6554            	   359:   adc  RES+2
00:AF3B 8554            	   360:   sta  RES+2
                        	   361: exp_multiply_no_add:
00:AF3D CA              	   362:   dex                      ; count bits
00:AF3E D0DC            	   363:   bne  exp_multiply_loop   ; go back if more to go
00:AF40 2003AF          	   364:   jsr  exp_fix_sign
00:AF43 A552            	   365:   lda  RES
00:AF45 8500            	   366:   sta  VALUE
00:AF47 A553            	   367:   lda  RES+1
00:AF49 8501            	   368:   sta  VALUE+1
00:AF4B A554            	   369:   lda  RES+2
00:AF4D 8502            	   370:   sta  VALUE+2
00:AF4F 60              	   371:   rts
                        	   372: 
                        	   373: ;
                        	   374: ;  divide VALUE by VALUE2, store result in VALUE
                        	   375: ;
                        	   376: exp_divide:
00:AF50 20EBAE          	   377:   jsr exp_find_sign
                        	   378: 
00:AF53 A503            	   379:   lda  VALUE2
00:AF55 0504            	   380:   ora  VALUE2+1
00:AF57 0505            	   381:   ora  VALUE2+2
00:AF59 D005            	   382:   bne  exp_divide_not_zero  ; check not dividing by zero
00:AF5B A22F            	   383:   ldx  #47                  ; ERROR: divide by zero
00:AF5D 4C2E96          	   384:   jmp  ass_error
                        	   385:   ;
                        	   386: exp_divide_not_zero:
00:AF60 20E2AE          	   387:   jsr  ZERRES     ; zero result (RES) - leaves zero in A register
00:AF63 8506            	   388:   sta  REMAIN
00:AF65 8507            	   389:   sta  REMAIN+1
00:AF67 8508            	   390:   sta  REMAIN+2
00:AF69 A918            	   391:   lda  #24       ; for all 24 bits of the operands ...
00:AF6B 858D            	   392:   sta  maths_work
                        	   393: exp_divide_loop:
00:AF6D 0600            	   394:   asl  VALUE
00:AF6F 2601            	   395:   rol  VALUE+1
00:AF71 2602            	   396:   rol  VALUE+2    ; shift the dividend left one bit
00:AF73 2606            	   397:   rol  REMAIN    ; the low-order bit of the dividend is shifted into the remainder
00:AF75 2607            	   398:   rol  REMAIN+1
00:AF77 2608            	   399:   rol  REMAIN+2
00:AF79 38              	   400:   sec
00:AF7A A506            	   401:   lda  REMAIN    ; do a trial subtraction of: remainder - divisor
00:AF7C E503            	   402:   sbc  VALUE2
00:AF7E AA              	   403:   tax
00:AF7F A507            	   404:   lda  REMAIN+1
00:AF81 E504            	   405:   sbc  VALUE2+1
00:AF83 A8              	   406:   tay
00:AF84 A508            	   407:   lda  REMAIN+2
00:AF86 E505            	   408:   sbc  VALUE2+2
00:AF88 300B            	   409:   bmi  exp_divide_subtraction_negative      ; if the subtraction fails (is negative) then discard the result
00:AF8A 8508            	   410:   sta  REMAIN+2  ; if it succeeds then the result of the subtraction is our new remainder
00:AF8C 98              	   411:   tya
00:AF8D 8507            	   412:   sta  REMAIN+1
00:AF8F 8A              	   413:   txa
00:AF90 8506            	   414:   sta  REMAIN
00:AF92 38              	   415:   sec            ; shift a one-bit into the quotient
00:AF93 B001            	   416:   bcs  exp_divide_subtraction_positive
                        	   417: exp_divide_subtraction_negative:
00:AF95 18              	   418:   clc            ; here if subtraction failed, quotient (RES) gets a 0-bit shifted in
                        	   419: exp_divide_subtraction_positive:
00:AF96 2652            	   420:   rol  RES       ; the carry bit (from above) is shifted into the quotient
00:AF98 2653            	   421:   rol  RES+1
00:AF9A 2654            	   422:   rol  RES+2
00:AF9C C68D            	   423:   dec  maths_work      ; one less bit to go
00:AF9E D0CD            	   424:   bne  exp_divide_loop      ; repeat until 24 bits done
00:AFA0 2003AF          	   425:   jsr  exp_fix_sign
00:AFA3 A552            	   426:   lda  RES
00:AFA5 8500            	   427:   sta  VALUE
00:AFA7 A553            	   428:   lda  RES+1
00:AFA9 8501            	   429:   sta  VALUE+1
00:AFAB A554            	   430:   lda  RES+2
00:AFAD 8502            	   431:   sta  VALUE+2
00:AFAF 60              	   432:   rts
                        	   433: 
                        	   434: exp_modulo:
00:AFB0 2050AF          	   435:   jsr exp_divide
00:AFB3 A506            	   436:   lda REMAIN
00:AFB5 8500            	   437:   sta VALUE
00:AFB7 A507            	   438:   lda REMAIN+1
00:AFB9 8501            	   439:   sta VALUE+1
00:AFBB A508            	   440:   lda REMAIN+2
00:AFBD 8502            	   441:   sta VALUE+2
00:AFBF 60              	   442:   rts
                        	   443: 

Source: "gpascal.asm"
                        	   190: 
                        	   191:   .if USE_PASCAL
                        	   192:   .include "compiler.inc"

Source: "compiler.inc"
                        	     1: 
                        	     2: ;***********************************************
                        	     3: ; COMPILER
                        	     4: ;***********************************************
                        	     5: 
                        	     6: 
                        	     7: ;
                        	     8: ;
                        	     9: ;  Compiler directives:
                        	    10: ;
                        	    11: ;    {%L} - list during compile (source code and current P-code address)
                        	    12: ;    {%P} - show generated P-codes during compile - only works during compile (not syntax check)
                        	    13: ;    {%N} - stop listing during compile (cancels %L and %P)
                        	    14: ;    {%S <address>} - relocate symbol table to <address> - must be done before defining symbols
                        	    15: ;                     also generates an opcode to relocate the runtime stack
                        	    16: ;
                        	    17: ;   The % must directly follow the start of the comment.
                        	    18: ;
                        	    19: ;
                        	    20: ;  Comments:  (* some comment *) or { some comment }
                        	    21: ;             "(*" / "{", and "*)" / "}" are treated interchangeably so (* some comment } would work
                        	    22: ;  Comments cannot be nested.
                        	    23: ;
                        	    24: ;  Tips:
                        	    25: ;
                        	    26: ;   Procedures and functions must be declared at the START of a block, not in the middle.
                        	    27: ;   The order is important. CONST first, then VAR, then procedure/function declarations, then BEGIN
                        	    28: 
                        	    29: ;    eg.
                        	    30: ;
                        	    31: ;    const limit = 10;   { <-- this is the start of a block: CONST before VAR }
                        	    32: ;    var k: integer;     { we declare variables and constants here - BEFORE "begin" }
                        	    33: ;    line : array [100] of char;  { array }
                        	    34: ;    function foo;       { and functions and procedures - this is the start of another block}
                        	    35: ;    begin
                        	    36: ;      foo := 42         { assign to function return value }
                        	    37: ;    end;                { end of the function block - note semicolon }
                        	    38: ;    begin               { end of declarations - now we have the block statements }
                        	    39: ;     for k := 1 to limit do
                        	    40: ;       writeln ("square of ", k, " is ", k * k);
                        	    41: ;     write (foo)        { call function }
                        	    42: ;    end.
                        	    43: ;
                        	    44: ;    ARGUMENTS: If the procedure or function does not take arguments OMIT THE BRACKETS.
                        	    45: ;               Likewise, omit the brackets if you call the procedure or function (unlike C)
                        	    46: ;
                        	    47: ;    Semicolons SEPARATE statements, they don't terminate them.
                        	    48: ;
                        	    49: ; Warnings: * Functions which do not assign to the function return value give undefined results.
                        	    50: ;           * Multiplication discards high-order bits if result is too large.
                        	    51: ;           * Divide remainder is always positive (ie. MOD always gives a positive result, regardless of operand signs)
                        	    52: ;           * Function arguments are always integers and always return an integer.
                        	    53: ;           * One to three-byte strings can be used as integer constants
                        	    54: ;               eg. a := "abc"; write (a);   --> Result: 6513249 (ie. 0x636261 or "abc")
                        	    55: ;               The first character is the low-order byte in the number, explaining the above results.
                        	    56: ;           * Strings can start with single or double quotes, whatever starts the string must terminate it.
                        	    57: ;           * String literals can have the same character that started the string embedded, to do that put it twice.
                        	    58: ;             eg. 'Nick''s cat'
                        	    59: ;           * Array access it not range-checked.
                        	    60: ;           * Arrays start at zero. The array size declared is the maximum index (unlike C) so foo: array [10] of integ
                        	    61: ;               would declare an array of 11 elements, numbered from foo [0] to foo [10]
                        	    62: ;           * Maximum arguments to a procedure/function is 85 (255 / 3) due to internal coding
                        	    63: ;
                        	    64: 
                        	    65: 
                        	    66: ;
00:AFC0 A2FF            	    67: COMPIL   LDX  #NEW_STK
00:AFC2 9A              	    68:   txs    ; set stack back to 0xFF
                        	    69: 
00:AFC3 20D793          	    70:   jsr  INIT
00:AFC6 A901            	    71:   lda  #FLAG_COMPILING
00:AFC8 04BE            	    72:   tsb  system_flags
00:AFCA 20F5BB          	    73:   jsr  add_pascal_library_functions
00:AFCD 204DD1          	    74:   jsr  pas_get_token
00:AFD0 2078B8          	    75:   jsr  BLOCK
00:AFD3 A92E            	    76:   lda  #'.'
00:AFD5 A209            	    77:   ldx  #9        ; ERROR: . expected
00:AFD7 20B1D1          	    78:   jsr  CHKTKN
00:AFDA A900            	    79:   lda  #0
00:AFDC A213            	    80:   ldx  #19       ; ERROR: Incorrect Symbol
00:AFDE 20A1D1          	    81:   jsr  GETCHK
00:AFE1 202594          	    82:   jsr  CROUT
00:AFE4 A9DC            	    83:   lda  #<pcodes_ended_message  ; P-codes ended at
00:AFE6 A294            	    84:   ldx  #>pcodes_ended_message
00:AFE8 202682          	    85:   jsr  print
00:AFEB A524            	    86:   lda  PCODE+1
00:AFED 8544            	    87:   sta  END_PCD+1
00:AFEF 209A94          	    88:   jsr  PRBYTE
00:AFF2 A523            	    89:   lda  PCODE
00:AFF4 8543            	    90:   sta  END_PCD
00:AFF6 204F95          	    91:   jsr  PRBYTECR
00:AFF9 204E8E          	    92:   jsr  show_symbol_table_end
00:AFFC 20738E          	    93:   jsr  show_source_end
                        	    94: 
00:AFFF A9EF            	    95:   lda  #<compile_finished_message  ; <C>ompile finished: No Errors
00:B001 A294            	    96:   ldx  #>compile_finished_message
00:B003 202682          	    97:   jsr  print
00:B006 A642            	    98:   ldx  SYNTAX
00:B008 D004            	    99:   bne  END_CMP
00:B00A A908            	   100:   lda  #FLAG_VALID_COMPILE
00:B00C 04BE            	   101:   tsb  system_flags
                        	   102: END_CMP  =  *
00:B00E 4C7282          	   103:   jmp  main_prompt
                        	   104: ;
                        	   105: 
                        	   106: ;
                        	   107: CHKLHP   =  *
00:B011 A928            	   108:          LDA  #'('
00:B013 A21F            	   109:          LDX  #31     ; ERROR: ( expected
00:B015 4CA1D1          	   110:          JMP  GETCHK
                        	   111: ;
                        	   112: CHKRHP   =  *
00:B018 A929            	   113:          LDA  #')'
00:B01A A216            	   114:          LDX  #22     ; ERROR: ) expected
00:B01C 20B1D1          	   115:          JSR  CHKTKN
00:B01F 4C4DD1          	   116:          JMP  pas_get_token
                        	   117: ;
                        	   118: GETSUB   =  *
00:B022 202BB0          	   119:          JSR  CHKLHB
00:B025 2000B3          	   120:          JSR  EXPRES
00:B028 4C35B0          	   121:          JMP  CHKRHB
                        	   122: ;
                        	   123: CHKLHB   =  *
00:B02B A95B            	   124:          LDA  #'['
00:B02D A221            	   125:          LDX  #33     ; ERROR: [ expected
00:B02F 20A1D1          	   126:          JSR  GETCHK
00:B032 4C4DD1          	   127:          JMP  pas_get_token
                        	   128: ;
                        	   129: CHKRHB   =  *
00:B035 A95D            	   130:          LDA  #']'
00:B037 A222            	   131:          LDX  #34     ; ERROR: ] expected
00:B039 20B1D1          	   132:          JSR  CHKTKN
00:B03C 4C4DD1          	   133:          JMP  pas_get_token
                        	   134: 
                        	   135: 
                        	   136: 
                        	   137: ; CONSTANT DEC
                        	   138: ;
                        	   139: CONDEC   =  *
00:B03F A949            	   140:          LDA  #TOKEN_IDENTIFIER
00:B041 A204            	   141:          LDX  #4        ; ERROR: Identifier expected
00:B043 20B1D1          	   142:          JSR  CHKTKN
00:B046 20C694          	   143:          JSR  TKNWRK
00:B049 A592            	   144:          LDA  token_length
00:B04B 48              	   145:          PHA
00:B04C A93D            	   146:          LDA  #'='
00:B04E A203            	   147:          LDX  #3        ; ERROR: = expected
00:B050 20A1D1          	   148:          JSR  GETCHK
00:B053 204DD1          	   149:          JSR  pas_get_token
00:B056 2007B1          	   150:          JSR  CONST
00:B059 20D194          	   151:          JSR  WRKTKN
00:B05C 68              	   152:          PLA
00:B05D 8592            	   153:          STA  token_length
00:B05F 202FCA          	   154:          JSR  CHKDUP
00:B062 A943            	   155:          LDA  #SYMBOL_CONSTANT
00:B064 2088C9          	   156:          JSR  ADDSYM
00:B067 4C4DD1          	   157:          JMP  pas_get_token
                        	   158: ;
                        	   159: ;
                        	   160: ;--- SYMITM --> WORK
                        	   161: ;
                        	   162: SYMWRK   =  *
00:B06A 48              	   163:          PHA
00:B06B A540            	   164:          LDA  SYMITM
00:B06D 8537            	   165:          STA  WORK
00:B06F A541            	   166:          LDA  SYMITM+1
00:B071 8538            	   167:          STA  WORK+1
00:B073 68              	   168:          PLA
00:B074 60              	   169:          RTS
                        	   170: ;
                        	   171: ;--- WORK --> SYMITM
                        	   172: ;
                        	   173: WRKSYM   =  *
00:B075 48              	   174:          PHA
00:B076 A537            	   175:          LDA  WORK
00:B078 8540            	   176:          STA  SYMITM
00:B07A A538            	   177:          LDA  WORK+1
00:B07C 8541            	   178:          STA  SYMITM+1
00:B07E 68              	   179:          PLA
00:B07F 60              	   180:          RTS
                        	   181: ;
                        	   182: ; PUSH PCODE ONTO STACK
                        	   183: ;
                        	   184: PSHPCODE =  *
00:B080 8536            	   185:          STA  BSAVE
00:B082 68              	   186:          PLA
00:B083 AA              	   187:          TAX
00:B084 68              	   188:          PLA
00:B085 A8              	   189:          TAY
00:B086 A524            	   190:          LDA  PCODE+1
00:B088 48              	   191:          PHA
00:B089 A523            	   192:          LDA  PCODE
00:B08B 48              	   193:          PHA
00:B08C 98              	   194:          TYA
00:B08D 48              	   195:          PHA
00:B08E 8A              	   196:          TXA
00:B08F 48              	   197:          PHA
00:B090 A536            	   198:          LDA  BSAVE
00:B092 60              	   199:          RTS
                        	   200: 
                        	   201: ;
                        	   202: GETEXPR  =  *
00:B093 204DD1          	   203:          JSR  pas_get_token
00:B096 4C00B3          	   204:          JMP  EXPRES
                        	   205: ;
                        	   206: ;
                        	   207: PCD_WRKD =  *
00:B099 48              	   208:          PHA
00:B09A A523            	   209:          LDA  PCODE
00:B09C 8533            	   210:          STA  WORKD
00:B09E A524            	   211:          LDA  PCODE+1
00:B0A0 8534            	   212:          STA  WORKD+1
00:B0A2 68              	   213:          PLA
00:B0A3 60              	   214:          RTS
                        	   215: ;
                        	   216: WRK_OPND =  *
00:B0A4 48              	   217:          PHA
00:B0A5 A537            	   218:          LDA  WORK
00:B0A7 852B            	   219:          STA  OPND
00:B0A9 A538            	   220:          LDA  WORK+1
00:B0AB 852C            	   221:          STA  OPND+1
00:B0AD 68              	   222:          PLA
00:B0AE 60              	   223:          RTS
                        	   224: ;
                        	   225: WRKD_WRK =  *
00:B0AF 48              	   226:          PHA
00:B0B0 A533            	   227:          LDA  WORKD
00:B0B2 8537            	   228:          STA  WORK
00:B0B4 A534            	   229:          LDA  WORKD+1
00:B0B6 8538            	   230:          STA  WORK+1
00:B0B8 68              	   231:          PLA
00:B0B9 60              	   232:          RTS
                        	   233: ;
                        	   234: WRK_WRKD =  *
00:B0BA 48              	   235:          PHA
00:B0BB A537            	   236:          LDA  WORK
00:B0BD 8533            	   237:          STA  WORKD
00:B0BF A538            	   238:          LDA  WORK+1
00:B0C1 8534            	   239:          STA  WORKD+1
00:B0C3 68              	   240:          PLA
00:B0C4 60              	   241:          RTS
                        	   242: ;
                        	   243: GET_COMM =  *
00:B0C5 A92C            	   244:          LDA  #','
00:B0C7 A220            	   245:          LDX  #32     ; ERROR: , expected
00:B0C9 4CB1D1          	   246:          JMP  CHKTKN
                        	   247: ;
                        	   248: GET_ITEM =  *
00:B0CC 20C5B0          	   249:          JSR  GET_COMM   ; check for comma
00:B0CF 4C93B0          	   250:          JMP  GETEXPR
                        	   251: ;
                        	   252: ;  Load (push) a constant (ie. a literal number)
                        	   253: ;
                        	   254: ;  Numbers in the range 0 to 0x7F are turned into a "low literal" which is a P-code
                        	   255: ;  with the 0x80 bit set. These then become a single-byte P-code which simply pushes
                        	   256: ;  that number onto the stack, thus saving having to have a 4-byte P-code being PCODE_LIT
                        	   257: ;  followed by a 3-byte number, 2 bytes of which would be zero.
                        	   258: ;
                        	   259: VAL_MOVE =  *
00:B0D2 48              	   260:          PHA
00:B0D3 18              	   261:          CLC
00:B0D4 A594            	   262:          LDA  token_value
00:B0D6 8527            	   263:          STA  DISPL   ; why?
00:B0D8 1001            	   264:          BPL  VAL_1   ; is it 0x00 to 0x7F?
00:B0DA 38              	   265:          SEC          ; no, set carry bit
                        	   266: VAL_1    =  *
00:B0DB A595            	   267:          LDA  token_value+1
00:B0DD F001            	   268:          BEQ  VAL_2   ; is second byte 0x00?
00:B0DF 38              	   269:          SEC          ; no, set carry bit
                        	   270: VAL_2    =  *
00:B0E0 8529            	   271:          STA  OFFSET
00:B0E2 A596            	   272:          LDA  token_value+2
00:B0E4 852A            	   273:          STA  OFFSET+1
00:B0E6 F001            	   274:          BEQ  VAL_3   ; is third byte 0x00?
00:B0E8 38              	   275:          SEC          ; no, set carry bit
                        	   276: VAL_3    =  *
00:B0E9 9007            	   277:          BCC  VAL_5   ; did we ever set the carry bit?
00:B0EB A900            	   278:          LDA  #PCODE_LIT  ; yes, so just generate a "load literal"
00:B0ED 20B8BC          	   279:          JSR  GENADR
00:B0F0 68              	   280:          PLA
00:B0F1 60              	   281:          RTS
                        	   282: VAL_5    =  *
00:B0F2 A594            	   283:          LDA  token_value   ; get the low-order byte back
00:B0F4 0980            	   284:          ORA  #$80    ; set the 0x80 bit as a flag
00:B0F6 209FBC          	   285:          JSR  GENNOP  ; output one P-code
00:B0F9 68              	   286:          PLA
00:B0FA 60              	   287:          RTS
                        	   288: ;
                        	   289: ;
                        	   290: CHK_STAK =  *
00:B0FB BA              	   291:          TSX
00:B0FC 8A              	   292:          TXA
00:B0FD C920            	   293:          CMP  #MAX_STK
00:B0FF 9001            	   294:          BCC  STK_FULL
00:B101 60              	   295:          RTS
                        	   296: STK_FULL =  *
00:B102 A21B            	   297: STK_ERR  LDX  #27     ; ERROR: Stack full
00:B104 4CE099          	   298:          jmp  ERROR      ; FULL
                        	   299: ;
                        	   300: ;
                        	   301: ; CONST get the value into token_value
                        	   302: ;
                        	   303: CONST    =  *
00:B107 A593            	   304:          LDA  token_type
00:B109 C94E            	   305:          CMP  #TOKEN_NUMBER
00:B10B F01F            	   306:          BEQ  CONST9
00:B10D C949            	   307:          CMP  #TOKEN_IDENTIFIER
00:B10F F00D            	   308:          BEQ  CONST1
00:B111 C922            	   309:          CMP  #TOKEN_STRING
00:B113 D00E            	   310:          BNE  CONST3
00:B115 A692            	   311:          LDX  token_length
00:B117 E004            	   312:          CPX  #4
00:B119 9011            	   313:          BCC  CONST9
00:B11B 4CAFB2          	   314:          JMP  FACERR1    ; STRING TOO BIG
00:B11E 200CC9          	   315: CONST1   JSR  SEARCH
00:B121 D005            	   316:          BNE  CONST2
                        	   317: CONST3   =  *
00:B123 A202            	   318:          LDX  #2        ; ERROR: Constant expected
00:B125 4CE099          	   319:          jmp  ERROR
00:B128 C943            	   320: CONST2   CMP  #SYMBOL_CONSTANT
00:B12A D0F7            	   321:          BNE  CONST3
00:B12C 60              	   322: CONST9   RTS
                        	   323: ;
                        	   324: ; VARIABLE DEC
                        	   325: ;
00:B12D A949            	   326: VARDEC   LDA  #TOKEN_IDENTIFIER
00:B12F A204            	   327:          LDX  #4      ; ERROR: Identifier expected
00:B131 20B1D1          	   328:          JSR  CHKTKN
00:B134 202FCA          	   329:          JSR  CHKDUP
00:B137 A956            	   330:          LDA  #SYMBOL_VARIABLE
00:B139 2088C9          	   331:          JSR  ADDSYM
00:B13C 4C4DD1          	   332:          JMP  pas_get_token
                        	   333: ;
                        	   334: ; SIMPLE EXPRESSION
                        	   335: ;
                        	   336: SIMEXP   =  *
00:B13F A593            	   337:          LDA  token_type
00:B141 C92B            	   338:          CMP  #'+'
00:B143 F004            	   339:          BEQ  SIM1
00:B145 C92D            	   340:          CMP  #'-'
00:B147 D048            	   341:          BNE  SIM2
00:B149 48              	   342: SIM1     PHA
00:B14A 204DD1          	   343:          JSR  pas_get_token
00:B14D 20B1B1          	   344:          JSR  TERM
00:B150 68              	   345:          PLA
00:B151 C92D            	   346:          CMP  #'-'
00:B153 D005            	   347:          BNE  SIM3
00:B155 A902            	   348:          LDA  #PCODE_NEG      ; NEG       Negate (sp)
00:B157 209FBC          	   349:          JSR  GENNOP     ; NEGATE
00:B15A A593            	   350: SIM3     LDA  token_type
00:B15C C92B            	   351:          CMP  #'+'
00:B15E F00D            	   352:          BEQ  SIM4
00:B160 C92D            	   353:          CMP  #'-'
00:B162 F009            	   354:          BEQ  SIM4
00:B164 C98A            	   355:          CMP  #TOKEN_OR       ; OR
00:B166 F005            	   356:          BEQ  SIM4
00:B168 C9A4            	   357:          CMP  #TOKEN_XOR      ; XOR
00:B16A F001            	   358:          BEQ  SIM4
00:B16C 60              	   359:          RTS
00:B16D 48              	   360: SIM4     PHA
00:B16E 204DD1          	   361:          JSR  pas_get_token
00:B171 20B1B1          	   362:          JSR  TERM
00:B174 68              	   363:          PLA
00:B175 C92D            	   364:          CMP  #'-'
00:B177 F010            	   365:          BEQ  SIM5
00:B179 C92B            	   366:          CMP  #'+'
00:B17B F010            	   367:          BEQ  SIM6
00:B17D C9A4            	   368:          CMP  #TOKEN_XOR          ; XOR
00:B17F F016            	   369:          BEQ  SIM8
00:B181 A91A            	   370:          LDA  #PCODE_ORR          ; ORR       OR  (sp - 1) | (sp)
00:B183 209FBC          	   371: SIM7     JSR  GENNOP
00:B186 4C5AB1          	   372:          JMP  SIM3
00:B189 A906            	   373: SIM5     LDA  #PCODE_SUB          ; MINUS
00:B18B D0F6            	   374:          BNE  SIM7
00:B18D A904            	   375: SIM6     LDA  #PCODE_ADD          ; PLUS
00:B18F D0F2            	   376:          BNE  SIM7
00:B191 20B1B1          	   377: SIM2     JSR  TERM
00:B194 4C5AB1          	   378:          JMP  SIM3
00:B197 A93A            	   379: SIM8     LDA  #PCODE_XOR         ; XOR
00:B199 D0E8            	   380:          BNE  SIM7
                        	   381: ;
                        	   382: ; TERM
                        	   383: ;
00:B19B 2A              	   384: TERMT1   ASC    '*'
00:B19C BEB1            	   385:          word   TERM1
00:B19E 8B              	   386:          DFB    TOKEN_DIV    ; div
00:B19F BEB1            	   387:          word   TERM1
00:B1A1 2F              	   388:          ASC    '/'
00:B1A2 BEB1            	   389:          word   TERM1
00:B1A4 8D              	   390:          DFB    TOKEN_AND    ; and
00:B1A5 BEB1            	   391:          word   TERM1
00:B1A7 8C              	   392:          DFB    TOKEN_MOD    ; mod
00:B1A8 BEB1            	   393:          word   TERM1
00:B1AA 8E              	   394:          DFB    TOKEN_SHL    ; shl
00:B1AB BEB1            	   395:          word   TERM1
00:B1AD 8F              	   396:          DFB    TOKEN_SHR    ; shr
00:B1AE BEB1            	   397:          word   TERM1
00:B1B0 00              	   398:          DFB    0
                        	   399: ;
00:B1B1 20FFB1          	   400: TERM     JSR  FACTOR
00:B1B4 A29B            	   401: TERM2    LDX  #<TERMT1
00:B1B6 A0B1            	   402:          LDY  #>TERMT1
00:B1B8 A593            	   403:          LDA  token_type
00:B1BA 208F91          	   404:          JSR  TKNJMP
00:B1BD 60              	   405:          RTS
                        	   406: ;
00:B1BE 48              	   407: TERM1    PHA
00:B1BF 204DD1          	   408:          JSR  pas_get_token
00:B1C2 20FFB1          	   409:          JSR  FACTOR
00:B1C5 68              	   410:          PLA
00:B1C6 A2E9            	   411:          LDX  #<TERMT3
00:B1C8 A0B1            	   412:          LDY  #>TERMT3
00:B1CA 208F91          	   413:          JSR  TKNJMP
                        	   414: ;
00:B1CD A90A            	   415: TERM4    LDA  #PCODE_DIV       ; Divide (sp - 1) / (sp)
00:B1CF 209FBC          	   416: TERM3    JSR  GENNOP
00:B1D2 4CB4B1          	   417:          JMP  TERM2
00:B1D5 A91B            	   418: TERM5    LDA  #PCODE_AND        ; AND
00:B1D7 D0F6            	   419:          BNE  TERM3
00:B1D9 A90B            	   420: TERM6    LDA  #PCODE_MOD        ; MOD
00:B1DB D0F2            	   421:          BNE  TERM3
00:B1DD A922            	   422: TERM7    LDA  #PCODE_SHL       ; Shift left (sp) bits
00:B1DF D0EE            	   423:          BNE  TERM3
00:B1E1 A924            	   424: TERM8    LDA  #PCODE_SHR       ; Shift right (sp) bits
00:B1E3 D0EA            	   425:          BNE  TERM3
00:B1E5 A908            	   426: TERM9    LDA  #PCODE_MUL        ; Multiply (sp) * (sp - 1)
00:B1E7 D0E6            	   427:          BNE  TERM3
                        	   428: ;
00:B1E9 8B              	   429: TERMT3   DFB    TOKEN_DIV     ; div
00:B1EA CDB1            	   430:          word   TERM4
00:B1EC 2F              	   431:          ASC    '/'
00:B1ED CDB1            	   432:          word   TERM4
00:B1EF 8D              	   433:          DFB    TOKEN_AND     ; and
00:B1F0 D5B1            	   434:          word   TERM5
00:B1F2 8C              	   435:          DFB    TOKEN_MOD     ; mod
00:B1F3 D9B1            	   436:          word   TERM6
00:B1F5 8E              	   437:          DFB    TOKEN_SHL     ; shl
00:B1F6 DDB1            	   438:          word   TERM7
00:B1F8 8F              	   439:          DFB    TOKEN_SHR     ; shr
00:B1F9 E1B1            	   440:          word   TERM8
00:B1FB 2A              	   441:          ASC    '*'
00:B1FC E5B1            	   442:          word   TERM9
00:B1FE 00              	   443:          DFB  0
                        	   444: ;
                        	   445: ; FACTOR
                        	   446: ;
00:B1FF 20FBB0          	   447: FACTOR   JSR  CHK_STAK
00:B202 A593            	   448:          LDA  token_type
00:B204 A2E7            	   449:          LDX  #<FACTB1
00:B206 A0B2            	   450:          LDY  #>FACTB1
00:B208 208F91          	   451:          JSR  TKNJMP
00:B20B A217            	   452:          LDX  #23     ; ERROR: Illegal factor
00:B20D 4CE099          	   453:          jmp  ERROR
                        	   454: ;
00:B210 2024CA          	   455: IDENT    JSR  LOOKUP
00:B213 C950            	   456: IDENT1   CMP  #SYMBOL_PROCEDURE
00:B215 F004            	   457:          beq  IDENT1A
00:B217 C951            	   458:          CMP  #SYMBOL_LIBRARY_PROCEDURE
00:B219 D005            	   459:          BNE  IDENT2
                        	   460: IDENT1A:
00:B21B A215            	   461:          LDX  #21     ; ERROR: Use of procedure Identifier in expression
00:B21D 4CE099          	   462:          jmp  ERROR
00:B220 C959            	   463: IDENT2   CMP  #SYMBOL_FUNCTION_RETURN
00:B222 D015            	   464:          BNE  IDENT2A
00:B224 A000            	   465:          LDY  #SYMPRV      ; this symbol is actually the function return value symbol
00:B226 B140            	   466:          LDA  (SYMITM),Y   ; so go to the previous symbol which will be the function
00:B228 AA              	   467:          TAX               ; declaration symbol with the address of the function to be called
00:B229 C8              	   468:          INY
00:B22A B140            	   469:          LDA  (SYMITM),Y
00:B22C 8541            	   470:          STA  SYMITM+1
00:B22E 8A              	   471:          TXA
00:B22F 8540            	   472:          STA  SYMITM
00:B231 A980            	   473:          lda  #$80       ; push 0 onto the stack which will be the default function return value
00:B233 209FBC          	   474:          jsr  GENNOP     ; when the function returns this will be left on the top of the stack
00:B236 4C80B5          	   475:          JMP  FNCPRC     ; with the function's assigned value in it (or zero if nothing assigned);
                        	   476: 
00:B239 C952            	   477: IDENT2A  CMP #SYMBOL_LIBRARY_FUNCTION
00:B23B D003            	   478:          bne IDENT3
00:B23D 4C4FBC          	   479:          jmp  library_function_call
                        	   480: 
00:B240 C941            	   481: IDENT3   CMP  #SYMBOL_ARRAY
00:B242 F030            	   482:          BEQ  IDENT4
00:B244 C943            	   483:          CMP  #SYMBOL_CONSTANT
00:B246 D00E            	   484:          BNE  IDENT5
00:B248 20D2B0          	   485:          JSR  VAL_MOVE
00:B24B 4C69B2          	   486:          JMP  IDENT7
                        	   487: ;
                        	   488: ;   Here for address of integer variable
                        	   489: ;
00:B24E A90C            	   490: FACAD1   LDA  #PCODE_ADRNN
00:B250 2058B2          	   491:          JSR  IDENT5_A
00:B253 4C18B0          	   492:          JMP  CHKRHP
                        	   493: ;
00:B256 A92C            	   494: IDENT5   LDA  #PCODE_LOD   ; load integer onto stack
00:B258 48              	   495: IDENT5_A PHA
                        	   496: ;
00:B259 8636            	   497:          STX  BSAVE
00:B25B A522            	   498:          LDA  LEVEL
00:B25D 38              	   499:          SEC
00:B25E E536            	   500:          SBC  BSAVE
00:B260 8527            	   501:          STA  DISPL
00:B262 68              	   502:          PLA
00:B263 18              	   503: IDENT6   CLC
00:B264 654A            	   504:          ADC  DATTYP
00:B266 20B8BC          	   505:          JSR  GENADR
00:B269 4C4DD1          	   506: IDENT7   JMP  pas_get_token
                        	   507: ;
00:B26C A90E            	   508: FACAD2   LDA  #PCODE_ADRAN  ; address of integer array
00:B26E 2076B2          	   509:          JSR  IDENT4_A
00:B271 4C18B0          	   510:          JMP  CHKRHP
                        	   511: ;
                        	   512: ;    Here for load indexed integer
                        	   513: ;
00:B274 A930            	   514: IDENT4   LDA  #PCODE_LDI         ; Load integer indexed
00:B276 48              	   515: IDENT4_A PHA
                        	   516: ;
00:B277 206AB0          	   517:          JSR  SYMWRK
00:B27A 205C94          	   518:          JSR  PSHWRK
00:B27D 2022B0          	   519:          JSR  GETSUB
00:B280 206F94          	   520:          JSR  PULWRK
00:B283 2075B0          	   521:          JSR  WRKSYM
00:B286 2074CA          	   522:          JSR  GET_DAT
00:B289 206ACA          	   523:          JSR  GET_LEV
00:B28C 203FCA          	   524:          JSR  GET_OFF
00:B28F 68              	   525:          PLA
00:B290 18              	   526:          CLC
00:B291 654A            	   527:          ADC  DATTYP
00:B293 4CB8BC          	   528:          JMP  GENADR
                        	   529: ;
                        	   530: ; ADDRESS (IDENTIFIER)
                        	   531: ;
                        	   532: ;
                        	   533: FACADR   =  *
00:B296 2011B0          	   534:          JSR  CHKLHP
00:B299 20B6D1          	   535:          JSR  GET_LOOK
00:B29C C956            	   536:          CMP  #SYMBOL_VARIABLE
00:B29E F0AE            	   537:          BEQ  FACAD1
00:B2A0 C941            	   538:          CMP  #SYMBOL_ARRAY
00:B2A2 F0C8            	   539:          BEQ  FACAD2
00:B2A4 A217            	   540:          LDX  #23     ; ERROR: Illegal factor
00:B2A6 4CE099          	   541:          jmp  ERROR
                        	   542: ;
                        	   543: ;
00:B2A9 A592            	   544: FACSTR   LDA  token_length
00:B2AB C904            	   545:          CMP  #4
00:B2AD 9005            	   546:          BCC  FACNUM    ; BLT
00:B2AF A21D            	   547: FACERR1  LDX  #29        ; ERROR: string literal too big
00:B2B1 4CE099          	   548:          jmp  ERROR
                        	   549: FACNUM   =  *
00:B2B4 20D2B0          	   550:          JSR  VAL_MOVE
00:B2B7 4C69B2          	   551:          JMP  IDENT7
                        	   552: ;
00:B2BA 2093B0          	   553: PAREN    JSR  GETEXPR
00:B2BD 4C18B0          	   554:          JMP  CHKRHP
                        	   555: ;
00:B2C0 A900            	   556: FACMEM   LDA  #0          ; add zero below to get PCODE_LDA
00:B2C2 854A            	   557:          STA  DATTYP
00:B2C4 F004            	   558:          BEQ  FACM2
00:B2C6 A901            	   559: FACMMC   LDA  #1          ; add one below to get PCODE_LDAC
00:B2C8 854A            	   560:          STA  DATTYP
00:B2CA A54A            	   561: FACM2    LDA  DATTYP
00:B2CC 48              	   562:          PHA
00:B2CD 2022B0          	   563:          JSR  GETSUB
00:B2D0 68              	   564:          PLA
00:B2D1 18              	   565:          CLC
00:B2D2 692E            	   566:          ADC  #PCODE_LDA    ; Load absolute address integer or PCODE_LDAC if we added 1
00:B2D4 D008            	   567:          BNE  GENNOP1
                        	   568: ;
00:B2D6 204DD1          	   569: FACNOT   JSR  pas_get_token
00:B2D9 20FFB1          	   570:          JSR  FACTOR
00:B2DC A920            	   571:          LDA  #PCODE_EOR     ; Not (sp) (logical negate)
00:B2DE 4C9FBC          	   572: GENNOP1  JMP  GENNOP
                        	   573: ;
00:B2E1 209FBC          	   574: FACRND1  JSR  GENNOP
00:B2E4 4C4DD1          	   575:          JMP  pas_get_token
                        	   576: ;
                        	   577: ;
                        	   578: ;
00:B2E7 49              	   579: FACTB1   DFB    TOKEN_IDENTIFIER
00:B2E8 10B2            	   580:          word   IDENT
00:B2EA 4E              	   581:          ASC    TOKEN_NUMBER
00:B2EB B4B2            	   582:          word   FACNUM
00:B2ED 22              	   583: FACTQT1  DFB    TOKEN_STRING        ; QUOTE SYMBOL
00:B2EE A9B2            	   584:          word   FACSTR
00:B2F0 28              	   585:          ASC    '('
00:B2F1 BAB2            	   586:          word   PAREN
00:B2F3 91              	   587:          DFB    TOKEN_MEM
00:B2F4 C0B2            	   588:          word   FACMEM     ; MEM
00:B2F6 90              	   589:          DFB    TOKEN_NOT
00:B2F7 D6B2            	   590:          word   FACNOT
00:B2F9 A2              	   591:          DFB    TOKEN_MEMC
00:B2FA C6B2            	   592:          word   FACMMC     ; MEMC
00:B2FC A9              	   593:          DFB    TOKEN_ADDRESS
00:B2FD 96B2            	   594:          word   FACADR
00:B2FF 00              	   595:          DFB  0
                        	   596: ;
                        	   597: ; EXPRESSION
                        	   598: ;
00:B300 20FBB0          	   599: EXPRES   JSR  CHK_STAK
00:B303 203FB1          	   600:          JSR  SIMEXP
00:B306 A593            	   601:          LDA  token_type
00:B308 A210            	   602:          LDX  #<EXPTB1
00:B30A A0B3            	   603:          LDY  #>EXPTB1
00:B30C 208F91          	   604:          JSR  TKNJMP
00:B30F 60              	   605:          RTS
                        	   606: ;
00:B310 3D              	   607: EXPTB1   ASC    '='
00:B311 23B3            	   608:          word   EXPR1
00:B313 55              	   609:          DFB    TOKEN_NEQ
00:B314 23B3            	   610:          word   EXPR1
00:B316 3C              	   611:          ASC    '<'
00:B317 23B3            	   612:          word   EXPR1
00:B319 80              	   613:          DFB    TOKEN_LEQ
00:B31A 23B3            	   614:          word   EXPR1
00:B31C 81              	   615:          DFB    TOKEN_GEQ
00:B31D 23B3            	   616:          word   EXPR1
00:B31F 3E              	   617:          ASC    '>'
00:B320 23B3            	   618:          word   EXPR1
00:B322 00              	   619:          DFB  0
                        	   620: ;
00:B323 48              	   621: EXPR1    PHA
00:B324 204DD1          	   622:          JSR  pas_get_token
00:B327 203FB1          	   623:          JSR  SIMEXP
00:B32A 68              	   624:          PLA
00:B32B A232            	   625:          LDX  #<EXPTB3
00:B32D A0B3            	   626:          LDY  #>EXPTB3
00:B32F 208F91          	   627:          JSR  TKNJMP
                        	   628: ;
00:B332 3D              	   629: EXPTB3   ASC    '='
00:B333 45B3            	   630:          word   EXPR2
00:B335 55              	   631:          ASC    TOKEN_NEQ
00:B336 4BB3            	   632:          word   EXPR3
00:B338 3C              	   633:          ASC    '<'
00:B339 4FB3            	   634:          word   EXPR4
00:B33B 81              	   635:          DFB    TOKEN_GEQ
00:B33C 53B3            	   636:          word   EXPR5
00:B33E 3E              	   637:          ASC    '>'
00:B33F 57B3            	   638:          word   EXPR6
00:B341 80              	   639:          DFB    TOKEN_LEQ
00:B342 5BB3            	   640:          word   EXPR7
00:B344 00              	   641:          DFB  0
                        	   642: ;
00:B345 A910            	   643: EXPR2    LDA  #PCODE_EQL       ; EQL      Test (sp - 1) == (sp)
00:B347 209FBC          	   644: EXPR8    JSR  GENNOP
00:B34A 60              	   645:          RTS
00:B34B A912            	   646: EXPR3    LDA  #PCODE_NEQ       ; NEQ      Test (sp - 1) != (sp)
00:B34D D0F8            	   647:          BNE  EXPR8
00:B34F A914            	   648: EXPR4    LDA  #PCODE_LSS       ; LSS      Test (sp - 1) < (sp)
00:B351 D0F4            	   649:          BNE  EXPR8
00:B353 A916            	   650: EXPR5    LDA  #PCODE_GEQ       ; GEQ      Test (sp - 1) >= (sp)
00:B355 D0F0            	   651:          BNE  EXPR8
00:B357 A918            	   652: EXPR6    LDA  #PCODE_GTR       ; GTR      Test (sp - 1) > (sp)
00:B359 D0EC            	   653:          BNE  EXPR8
00:B35B A919            	   654: EXPR7    LDA  #PCODE_LEQ       ; LEQ      Test (sp - 1) <= (sp)
00:B35D D0E8            	   655:          BNE  EXPR8
                        	   656: ;
                        	   657: ; STATEMENT
                        	   658: ;
00:B35F 20FBB0          	   659: STMNT    JSR  CHK_STAK
00:B362 A593            	   660:          LDA  token_type
00:B364 A26C            	   661:          LDX  #<STMNT1
00:B366 A0B3            	   662:          LDY  #>STMNT1
00:B368 208F91          	   663:          JSR  TKNJMP
00:B36B 60              	   664:          RTS
                        	   665: ;
00:B36C 49              	   666: STMNT1   DFB    TOKEN_IDENTIFIER
00:B36D 97B3            	   667:          word   ASSIGN
00:B36F 92              	   668:          DFB    TOKEN_IF
00:B370 07B6            	   669:          word   IF
00:B372 9A              	   670:          DFB    TOKEN_FOR
00:B373 6EB7            	   671:          word   FOR
00:B375 96              	   672:          DFB    TOKEN_WHILE
00:B376 81B6            	   673:          word   WHILE
00:B378 95              	   674:          DFB    TOKEN_CASE
00:B379 B3B6            	   675:          word   CASE
00:B37B 98              	   676:          DFB    TOKEN_REPEAT
00:B37C 5DB6            	   677:          word   REPEAT
00:B37E 88              	   678:          DFB    TOKEN_BEGIN
00:B37F 47B6            	   679:          word   BEG
00:B381 9E              	   680:          DFB    TOKEN_READ
00:B382 AFB4            	   681:          word   READ
00:B384 9D              	   682:          DFB    TOKEN_WRITE
00:B385 0DB4            	   683:          word   WRITE
00:B387 91              	   684:          DFB    TOKEN_MEM
00:B388 58B5            	   685:          word   MEM
00:B38A 9F              	   686:          DFB    TOKEN_CALL
00:B38B 73B5            	   687:          word   CALLSB
00:B38D A2              	   688:          DFB    TOKEN_MEMC
00:B38E 5DB5            	   689:          word   MEMC
00:B390 FF              	   690:          DFB    TOKEN_WRITELN
00:B391 FEB3            	   691:          word   WRITELN
00:B393 F1              	   692:          DB     TOKEN_LCDWRITE
00:B394 5EB4            	   693:          word   STMNT_WRITE_LCD
00:B396 00              	   694:          DFB  0
                        	   695: ;
                        	   696: ; ASSIGNMENT - this is where we store an integer/char into a variable or array index
                        	   697: ;
00:B397 2024CA          	   698: ASSIGN   JSR  LOOKUP
00:B39A A2A6            	   699: ASS1     LDX  #<ASSTB1
00:B39C A0B3            	   700:          LDY  #>ASSTB1
00:B39E 208F91          	   701:          JSR  TKNJMP
00:B3A1 A218            	   702:          LDX  #24     ; ERROR: Type mismatch
00:B3A3 4CE099          	   703:          jmp  ERROR
                        	   704: ;
00:B3A6 41              	   705: ASSTB1   DFB   SYMBOL_ARRAY
00:B3A7 C1B3            	   706:          word  ASSARR
00:B3A9 56              	   707:          DFB   SYMBOL_VARIABLE
00:B3AA D3B3            	   708:          word  ASSVAR
00:B3AC 59              	   709:          DFB   SYMBOL_FUNCTION_RETURN
00:B3AD D3B3            	   710:          word  ASSVAR
00:B3AF 50              	   711:          DFB   SYMBOL_PROCEDURE
00:B3B0 80B5            	   712:          word  FNCPRC
00:B3B2 51              	   713:          DFB   SYMBOL_LIBRARY_PROCEDURE
00:B3B3 4FBC            	   714:          word  library_function_call
00:B3B5 46              	   715:          DFB   SYMBOL_FUNCTION
00:B3B6 BCB3            	   716:          word  assign_bad_identifier
00:B3B8 52              	   717:          DFB   SYMBOL_LIBRARY_FUNCTION
00:B3B9 BCB3            	   718:          word  assign_bad_identifier
00:B3BB 00              	   719:          DFB  0
                        	   720: 
                        	   721: assign_bad_identifier:
00:B3BC A235            	   722:           ldx #53   ; ERROR: Use of function identifier in statement
00:B3BE 4CE099          	   723:           jmp ERROR
                        	   724: ;
00:B3C1 206AB0          	   725: ASSARR   JSR  SYMWRK
00:B3C4 205C94          	   726:          JSR  PSHWRK
00:B3C7 A936            	   727:          LDA  #PCODE_STI    ; Store integer indexed
00:B3C9 18              	   728:          CLC
00:B3CA 654A            	   729:          ADC  DATTYP        ; A becomes PCODE_STIC (Store character indexed) if DATTYP == 1
00:B3CC 48              	   730:          PHA
00:B3CD 2022B0          	   731:          JSR  GETSUB
00:B3D0 4CE2B3          	   732:          JMP  ASS2
                        	   733: ;
00:B3D3 206AB0          	   734: ASSVAR   JSR  SYMWRK
00:B3D6 205C94          	   735:          JSR  PSHWRK
00:B3D9 A932            	   736:          LDA  #PCODE_STO    ;  Store integer
00:B3DB 18              	   737:          CLC
00:B3DC 654A            	   738:          ADC  DATTYP        ; A becomes PCODE_STOC (Store character indexed) if DATTYP == 1
00:B3DE 48              	   739:          PHA
00:B3DF 204DD1          	   740:          JSR  pas_get_token
00:B3E2 A941            	   741: ASS2     LDA  #TOKEN_ASSIGN
00:B3E4 A20D            	   742:          LDX  #13       ; ERROR: := expected
00:B3E6 20B1D1          	   743:          JSR  CHKTKN
00:B3E9 2093B0          	   744:          JSR  GETEXPR
00:B3EC 68              	   745:          PLA
00:B3ED 206F94          	   746:          JSR  PULWRK
00:B3F0 2075B0          	   747:          JSR  WRKSYM
00:B3F3 48              	   748:          PHA
00:B3F4 206ACA          	   749:          JSR  GET_LEV
00:B3F7 203FCA          	   750:          JSR  GET_OFF
00:B3FA 68              	   751:          PLA
00:B3FB 4CB8BC          	   752:          JMP  GENADR
                        	   753: ;
                        	   754: 
                        	   755: ;
                        	   756: ;
                        	   757: ; WRITELN
                        	   758: ;
00:B3FE 204DD1          	   759: WRITELN  JSR  pas_get_token     ; SEE IF ( PRESENT
00:B401 C928            	   760:          CMP  #'('
00:B403 D003            	   761:          BNE  WRITELN9   ; NOPE
00:B405 2010B4          	   762:          JSR  WRIT9
                        	   763: WRITELN9 =  *
00:B408 A940            	   764:          LDA  #PCODE_OUTCR   ; OUTPUT C/R
00:B40A 4C9FBC          	   765:          JMP  GENNOP
                        	   766: ;
                        	   767: ;
                        	   768: ; WRITE
                        	   769: ;
00:B40D 2011B0          	   770: WRITE    JSR  CHKLHP
00:B410 204DD1          	   771: WRIT9    JSR  pas_get_token
00:B413 C922            	   772:          CMP  #TOKEN_STRING
00:B415 D022            	   773:          BNE  WRIT1
00:B417 A923            	   774:          LDA  #PCODE_OUS    ; Output string
00:B419 201FB4          	   775:          JSR  W_STRING
00:B41C 4C49B4          	   776:          JMP  WRIT5
                        	   777: ;
                        	   778: W_STRING =  *
00:B41F 209FBC          	   779:          JSR  GENNOP
00:B422 A592            	   780:          LDA  token_length
00:B424 209FBC          	   781:          JSR  GENNOP
00:B427 A000            	   782:          LDY  #0
00:B429 B90002          	   783: WRIT2    LDA  INBUF,Y
00:B42C C8              	   784: WRIT10   INY
00:B42D 5A              	   785:          phy
00:B42E 209FBC          	   786:          JSR  GENNOP
00:B431 7A              	   787:          ply
00:B432 C692            	   788:          DEC  token_length
00:B434 D0F3            	   789:          BNE  WRIT2
00:B436 4C4DD1          	   790:          JMP  pas_get_token
                        	   791: ;
                        	   792: WRIT1    =  *          ; here if not string
00:B439 C9AB            	   793:          CMP  #TOKEN_CHR       ; CHR?
00:B43B F015            	   794:          BEQ  W_CHR      ; yes
00:B43D C9AC            	   795:          CMP  #TOKEN_HEX       ; HEX?
00:B43F F019            	   796:          BEQ  W_HEX      ; yes
00:B441 2000B3          	   797:          JSR  EXPRES     ; just ordinary number - get it
00:B444 A91E            	   798:          LDA  #PCODE_OUT        ; OUT       Output number
00:B446 209FBC          	   799:          JSR  GENNOP
00:B449 A593            	   800: WRIT5    LDA  token_type
00:B44B C92C            	   801:          CMP  #','
00:B44D F0C1            	   802:          BEQ  WRIT9
00:B44F 4C18B0          	   803:          JMP  CHKRHP
                        	   804: ;
                        	   805: ; here for write (chr(x))
                        	   806: ;
                        	   807: W_CHR    =  *
00:B452 A91F            	   808:          LDA  #PCODE_OUTC   ; OUTC      Output character
                        	   809: W_CHR1   =  *
00:B454 204EB5          	   810:          JSR  WAIT_1     ; process expression in parentheses
00:B457 4C49B4          	   811:          JMP  WRIT5      ; back for next item
                        	   812: ;
                        	   813: ; here for write (hex(x))
                        	   814: ;
                        	   815: W_HEX    =  *
00:B45A A921            	   816:          LDA  #PCODE_OUH        ; OUH       Output hex number
00:B45C D0F6            	   817:          BNE  W_CHR1
                        	   818: 
                        	   819: ;
                        	   820: ;
                        	   821: ; WRITELCD: can write number, string, hex or chr
                        	   822: ;
00:B45E 2011B0          	   823: STMNT_WRITE_LCD    JSR  CHKLHP
00:B461 204DD1          	   824: WRITE_LCD9    JSR  pas_get_token
00:B464 C922            	   825:          CMP  #TOKEN_STRING
00:B466 D022            	   826:          BNE  WRITE_LCD1
00:B468 A943            	   827:          LDA  #PCODE_LCD_WRITE_STR    ; Output string
00:B46A 2070B4          	   828:          JSR  WRITE_LCD_STRING
00:B46D 4C9AB4          	   829:          JMP  WRITE_LCD5
                        	   830: ;
                        	   831: WRITE_LCD_STRING =  *
00:B470 209FBC          	   832:          JSR  GENNOP
00:B473 A592            	   833:          LDA  token_length
00:B475 209FBC          	   834:          JSR  GENNOP
00:B478 A000            	   835:          LDY  #0
00:B47A B90002          	   836: WRITE_LCD2    LDA  INBUF,Y    ; strings are placed in INBUF during parsing
00:B47D C8              	   837:          INY
00:B47E 5A              	   838:          phy
00:B47F 209FBC          	   839:          JSR  GENNOP
00:B482 7A              	   840:          ply
00:B483 C692            	   841:          DEC  token_length
00:B485 D0F3            	   842:          BNE  WRITE_LCD2
00:B487 4C4DD1          	   843:          JMP  pas_get_token
                        	   844: ;
                        	   845: WRITE_LCD1    =  *            ; here if not string
00:B48A C9AB            	   846:          CMP  #TOKEN_CHR      ; CHR?
00:B48C F015            	   847:          BEQ  WRITE_LDC_CHR   ; yes
00:B48E C9AC            	   848:          CMP  #TOKEN_HEX      ; HEX?
00:B490 F019            	   849:          BEQ  WRITE_LDC_HEX   ; yes
00:B492 2000B3          	   850:          JSR  EXPRES          ; just ordinary number - get it
00:B495 A942            	   851:          LDA  #PCODE_LCD_WRITE_NUM        ; OUT       Output number
00:B497 209FBC          	   852:          JSR  GENNOP
00:B49A A593            	   853: WRITE_LCD5    LDA  token_type
00:B49C C92C            	   854:          CMP  #','
00:B49E F0C1            	   855:          BEQ  WRITE_LCD9
00:B4A0 4C18B0          	   856:          JMP  CHKRHP
                        	   857: ;
                        	   858: ; here for lcdwrite (chr(x))
                        	   859: ;
                        	   860: WRITE_LDC_CHR    =  *
00:B4A3 A945            	   861:          LDA  #PCODE_LCD_WRITE_CHR   ; OUTC     Output character
                        	   862: WRITE_LDC_CHR1   =  *
00:B4A5 204EB5          	   863:          JSR  WAIT_1          ; process expression in parentheses
00:B4A8 4C9AB4          	   864:          JMP  WRITE_LCD5      ; back for next item
                        	   865: ;
                        	   866: ; here for lcdwrite (hex(x))
                        	   867: ;
                        	   868: WRITE_LDC_HEX    =  *
00:B4AB A944            	   869:          LDA  #PCODE_LCD_WRITE_HEX        ; OUH       Output hex number
00:B4AD D0F6            	   870:          BNE  WRITE_LDC_CHR1
                        	   871: 
                        	   872: ;
                        	   873: ;
                        	   874: ; READ
                        	   875: ;
00:B4AF 2011B0          	   876: READ     jsr  CHKLHP    ; check for "("
00:B4B2 20B6D1          	   877: READ8    jsr  GET_LOOK
00:B4B5 206AB0          	   878: READ2    jsr  SYMWRK      ; SYMITM --> WORK
00:B4B8 205C94          	   879:          jsr  PSHWRK
00:B4BB A200            	   880:          ldx  #0
00:B4BD 864B            	   881:          stx  COUNT1      ; this will have 1 in it if we are reading into an array element
00:B4BF C941            	   882:          cmp  #SYMBOL_ARRAY
00:B4C1 F03B            	   883:          beq  READ3
00:B4C3 C956            	   884:          cmp  #SYMBOL_VARIABLE
00:B4C5 F005            	   885:          beq  READ9
00:B4C7 A20C            	   886:          ldx  #12     ; ERROR: Illegal Identifier
00:B4C9 4CE099          	   887:          jmp  ERROR
                        	   888: 
00:B4CC 209FCB          	   889: READ9    jsr get_token
00:B4CF A91C            	   890: READ11   lda  #PCODE_INP  ; Input number
00:B4D1 18              	   891:          clc
00:B4D2 654A            	   892:          adc  DATTYP      ; becomes PCODE_INPC (input character) if DATTYP == 1
00:B4D4 209FBC          	   893:          jsr  GENNOP
00:B4D7 206F94          	   894:          jsr  PULWRK
00:B4DA 2075B0          	   895:          jsr  WRKSYM      ; WORK --> SYMITM
00:B4DD 2074CA          	   896:          jsr  GET_DAT
00:B4E0 206ACA          	   897:          jsr  GET_LEV
00:B4E3 203FCA          	   898:          jsr  GET_OFF
00:B4E6 A932            	   899:          lda  #PCODE_STO    ; Store integer
00:B4E8 A64B            	   900:          ldx  COUNT1
00:B4EA F002            	   901:          beq  READ7
00:B4EC A936            	   902:          lda  #PCODE_STI    ; Store integer indexed
00:B4EE 18              	   903: READ7    clc
00:B4EF 654A            	   904:          adc  DATTYP        ; add 1 if a char to become PCODE_STOC / PCODE_STIC
00:B4F1 20B8BC          	   905:          jsr  GENADR
00:B4F4 A593            	   906: READ7_A  lda  token_type
00:B4F6 C92C            	   907:          cmp  #','
00:B4F8 F0B8            	   908:          beq  READ8         ; get another variable to read into
                        	   909: ;
                        	   910: ;  done with READ statement
                        	   911: ;
00:B4FA 2018B0          	   912:          jsr  CHKRHP        ; check for ")"
00:B4FD 60              	   913:          rts
                        	   914: ;
                        	   915: ;  here for reading into an array
                        	   916: ;
00:B4FE A54A            	   917: READ3    lda  DATTYP
00:B500 48              	   918:          pha              ; push data type of array
00:B501 204DD1          	   919:          jsr  pas_get_token
00:B504 C95B            	   920:          cmp  #'['
00:B506 F025            	   921:          beq  READ3_A
00:B508 68              	   922:          pla            ; get back data type of array
00:B509 854A            	   923:          sta  DATTYP    ; 0 = integer, 1 = char
00:B50B D005            	   924:          bne  READ3_B
00:B50D A218            	   925:          ldx  #24       ; ERROR: Type mismatch (cannot read into array of integer)
00:B50F 4CE099          	   926:          jmp  ERROR
00:B512 206F94          	   927: READ3_B  jsr  PULWRK
00:B515 2075B0          	   928:          jsr  WRKSYM     ; WORK --> SYMITM
00:B518 A925            	   929:          lda  #PCODE_INS        ; READ STRING - Input string into array
00:B51A 209FBC          	   930:          jsr  GENNOP
00:B51D 206ACA          	   931:          jsr  GET_LEV
00:B520 203FCA          	   932:          jsr  GET_OFF
00:B523 A006            	   933:          ldy  #SYMSUB
00:B525 B140            	   934:          lda  (SYMITM),Y  ; maximum array size
00:B527 20B8BC          	   935:          jsr  GENADR     ; A = length, not the P-code which we just output above
00:B52A 4CF4B4          	   936:          jmp  READ7_A
                        	   937: ;
                        	   938: ;  read into subscripted item
                        	   939: ;
00:B52D 2093B0          	   940: READ3_A  jsr  GETEXPR   ; subscript
00:B530 2035B0          	   941:          jsr  CHKRHB    ; check for "]"
00:B533 E64B            	   942:          inc  COUNT1    ; flag for reading into array element
00:B535 68              	   943:          pla            ; get back data type of array
00:B536 854A            	   944:          sta  DATTYP    ; save
00:B538 4CCFB4          	   945:          jmp  READ11
                        	   946: ;
                        	   947: 
                        	   948: ;
                        	   949: ;
00:B53B 2011B0          	   950: TWO_OP   JSR  CHKLHP
00:B53E 2093B0          	   951:          JSR  GETEXPR
00:B541 20CCB0          	   952: ONE_OP2  JSR  GET_ITEM
00:B544 2018B0          	   953: ONE_OP   JSR  CHKRHP
00:B547 68              	   954:          PLA
00:B548 4C9FBC          	   955:          JMP  GENNOP
                        	   956: 
                        	   957: 
                        	   958: 
00:B54B 4C9FBC          	   959: GENNOP2  JMP  GENNOP
                        	   960: ;
                        	   961: 
00:B54E 48              	   962: WAIT_1   PHA
00:B54F 2011B0          	   963:          JSR  CHKLHP
00:B552 2093B0          	   964:          JSR  GETEXPR
00:B555 4C44B5          	   965:          JMP  ONE_OP
                        	   966: ;
                        	   967: ; MEM
                        	   968: ;
00:B558 A900            	   969: MEM      LDA  #0        ; integer
00:B55A 48              	   970:          PHA
00:B55B F003            	   971:          BEQ  MEM2
00:B55D A901            	   972: MEMC     LDA  #1        ; character
00:B55F 48              	   973:          PHA
00:B560 2022B0          	   974: MEM2     JSR  GETSUB
00:B563 A941            	   975:          LDA  #TOKEN_ASSIGN
00:B565 A20D            	   976:          LDX  #13     ; ERROR: := expected
00:B567 20B1D1          	   977:          JSR  CHKTKN
00:B56A 2093B0          	   978:          JSR  GETEXPR
00:B56D 68              	   979:          PLA
00:B56E 18              	   980:          CLC
00:B56F 6934            	   981:          ADC  #PCODE_STA     ; Store integer absolute address (or PCODE_STAC if A == 1)
00:B571 D0D8            	   982:          BNE  GENNOP2
                        	   983: ;
                        	   984: ; CALL ABSOLUTE ADDRESS
                        	   985: ;
00:B573 2011B0          	   986: CALLSB   JSR  CHKLHP
00:B576 2093B0          	   987:          JSR  GETEXPR
00:B579 2018B0          	   988:          JSR  CHKRHP
00:B57C A92B            	   989:          LDA  #PCODE_CLA    ; Call absolute address
00:B57E D0CB            	   990:          BNE  GENNOP2
                        	   991: ;
                        	   992: ; FUNCTION OR PROCEDURE CALL
                        	   993: ;
00:B580 A900            	   994: FNCPRC   LDA  #0
00:B582 854B            	   995:          STA  COUNT1      ; number of arguments
00:B584 A006            	   996:          LDY  #SYMARG
00:B586 B140            	   997:          LDA  (SYMITM),Y
00:B588 F033            	   998:          BEQ  FNC1
00:B58A 2011B0          	   999:          JSR  CHKLHP
00:B58D A54B            	  1000: FNC2     LDA  COUNT1    ; save on stack in case the expression calls functions
00:B58F 48              	  1001:          PHA
00:B590 206AB0          	  1002:          JSR  SYMWRK
00:B593 205C94          	  1003:          JSR  PSHWRK
00:B596 2093B0          	  1004:          JSR  GETEXPR
00:B599 206F94          	  1005:          JSR  PULWRK
00:B59C 2075B0          	  1006:          JSR  WRKSYM
00:B59F 68              	  1007:          PLA            ; get number of arguments back
00:B5A0 854B            	  1008:          STA  COUNT1
00:B5A2 E64B            	  1009:          INC  COUNT1    ; add 1 for the one we just processed
00:B5A4 A593            	  1010:          LDA  token_type
00:B5A6 C92C            	  1011:          CMP  #','
00:B5A8 F0E3            	  1012:          BEQ  FNC2
00:B5AA A54B            	  1013:          LDA  COUNT1
00:B5AC A006            	  1014:          LDY  #SYMARG
00:B5AE D140            	  1015:          CMP  (SYMITM),Y   ; check we got the right number of arguments
00:B5B0 F005            	  1016:          BEQ  FNC3
00:B5B2 A223            	  1017:          LDX  #35     ; ERROR: Parameters mismatched
00:B5B4 4CE099          	  1018:          jmp  ERROR
00:B5B7 2018B0          	  1019: FNC3     JSR  CHKRHP
00:B5BA 4CC0B5          	  1020:          JMP  FNC5
00:B5BD 204DD1          	  1021: FNC1     JSR  pas_get_token
00:B5C0 206ACA          	  1022: FNC5     JSR  GET_LEV
00:B5C3 203FCA          	  1023:          JSR  GET_OFF
00:B5C6 A008            	  1024:          LDY  #SYMDAT
00:B5C8 B140            	  1025:          LDA  (SYMITM),Y
00:B5CA D011            	  1026:          BNE  FNC5A
00:B5CC A529            	  1027:          LDA  OFFSET
00:B5CE 38              	  1028:          SEC
00:B5CF E523            	  1029:          SBC  PCODE         ; calculate relative procedure address
00:B5D1 8529            	  1030:          STA  OFFSET
00:B5D3 A52A            	  1031:          LDA  OFFSET+1
00:B5D5 E524            	  1032:          SBC  PCODE+1
00:B5D7 852A            	  1033:          STA  OFFSET+1
00:B5D9 A927            	  1034:          LDA  #PCODE_CLL         ; Relative procedure/function call
00:B5DB D002            	  1035:          BNE  FNC5B
00:B5DD A938            	  1036: FNC5A    LDA  #PCODE_ABSCLL      ; Absolute procedure/function call
00:B5DF 20B8BC          	  1037: FNC5B    JSR  GENADR
00:B5E2 A54B            	  1038:          LDA  COUNT1    ; number of arguments
00:B5E4 F01B            	  1039:          BEQ  FNC4
00:B5E6 A54B            	  1040:          LDA  COUNT1     ; TIMES 3
00:B5E8 0A              	  1041:          ASL             ; multiply by two then add one more COUNT1
00:B5E9 B017            	  1042:          BCS  FNC6
00:B5EB 654B            	  1043:          ADC  COUNT1
00:B5ED 854B            	  1044:          STA  COUNT1
00:B5EF B011            	  1045:          BCS  FNC6
00:B5F1 A900            	  1046:          LDA  #0
00:B5F3 38              	  1047:          SEC
00:B5F4 E54B            	  1048:          SBC  COUNT1
00:B5F6 852B            	  1049:          STA  OPND
00:B5F8 A9FF            	  1050:          LDA  #$FF
00:B5FA 852C            	  1051:          STA  OPND+1      ;  calculate: 0 - (number_of_arguments * 3)
00:B5FC A93B            	  1052:          LDA  #PCODE_INT     ; Increment stack pointer (allow for arguments)
00:B5FE 2028BD          	  1053:          JSR  GENJMP
00:B601 60              	  1054: FNC4     RTS
00:B602 A20F            	  1055: FNC6     LDX  #15       ; ERROR: compiler limits exceeded
00:B604 4CE099          	  1056:          jmp  ERROR
                        	  1057: ;
                        	  1058: ;
                        	  1059: ; IF
                        	  1060: ;
00:B607 2093B0          	  1061: IF       JSR  GETEXPR
00:B60A A993            	  1062:          LDA  #TOKEN_THEN
00:B60C A210            	  1063:          LDX  #16     ; ERROR: THEN expected
00:B60E 20B1D1          	  1064:          JSR  CHKTKN
00:B611 204DD1          	  1065:          JSR  pas_get_token
00:B614 2080B0          	  1066:          JSR  PSHPCODE
00:B617 A93D            	  1067:          LDA  #PCODE_JMZ     ; JMZ      Jump if (sp) zero
00:B619 2022BD          	  1068:          JSR  GENNJM
00:B61C 205FB3          	  1069:          JSR  STMNT
00:B61F A593            	  1070:          LDA  token_type
00:B621 C994            	  1071:          CMP  #TOKEN_ELSE       ; ELSE
00:B623 F007            	  1072:          BEQ  IF1
00:B625 206F94          	  1073: IF2      JSR  PULWRK
00:B628 2056BD          	  1074:          JSR  FIXAD
00:B62B 60              	  1075:          RTS
00:B62C 206F94          	  1076: IF1      JSR  PULWRK     ; HERE FOR ELSE
00:B62F 20BAB0          	  1077:          JSR  WRK_WRKD
00:B632 2080B0          	  1078:          JSR  PSHPCODE
00:B635 2020BD          	  1079:          JSR  GENNJP
00:B638 20AFB0          	  1080:          JSR  WRKD_WRK
00:B63B 2056BD          	  1081:          JSR  FIXAD
00:B63E 204DD1          	  1082:          JSR  pas_get_token
00:B641 205FB3          	  1083:          JSR  STMNT
00:B644 4C25B6          	  1084:          JMP  IF2
                        	  1085: ;
                        	  1086: ; BEGIN
                        	  1087: ;
00:B647 204DD1          	  1088: BEG      JSR  pas_get_token
00:B64A 205FB3          	  1089:          JSR  STMNT
00:B64D A593            	  1090:          LDA  token_type
00:B64F C93B            	  1091:          CMP  #';'
00:B651 F0F4            	  1092:          BEQ  BEG
00:B653 A989            	  1093:          LDA  #TOKEN_END       ; END
00:B655 A211            	  1094:          LDX  #17         ; ERROR: ; or END expected
00:B657 20B1D1          	  1095:          JSR  CHKTKN
00:B65A 4C4DD1          	  1096:          JMP  pas_get_token
                        	  1097: ;
                        	  1098: ; REPEAT
                        	  1099: ;
00:B65D 2080B0          	  1100: REPEAT   JSR  PSHPCODE
00:B660 204DD1          	  1101: REP1     JSR  pas_get_token
00:B663 205FB3          	  1102:          JSR  STMNT
00:B666 A593            	  1103:          LDA  token_type
00:B668 C93B            	  1104:          CMP  #';'
00:B66A F0F4            	  1105:          BEQ  REP1
00:B66C A999            	  1106:          LDA  #TOKEN_UNTIL
00:B66E A20A            	  1107:          LDX  #10           ; ERROR: ; expected
00:B670 20B1D1          	  1108:          JSR  CHKTKN
00:B673 2093B0          	  1109:          JSR  GETEXPR
00:B676 206F94          	  1110:          JSR  PULWRK
00:B679 20A4B0          	  1111:          JSR  WRK_OPND
00:B67C A93D            	  1112:          LDA  #PCODE_JMZ         ; JMZ      Jump if (sp) zero
00:B67E 4C0EBD          	  1113:          JMP  GENRJMP
                        	  1114: ;
                        	  1115: ; WHILE
                        	  1116: ;
00:B681 2080B0          	  1117: WHILE    JSR  PSHPCODE
00:B684 2093B0          	  1118:          JSR  GETEXPR
00:B687 2080B0          	  1119:          JSR  PSHPCODE
00:B68A A93D            	  1120:          LDA  #PCODE_JMZ       ; JMZ      Jump if (sp) zero
00:B68C 2022BD          	  1121:          JSR  GENNJM
00:B68F A997            	  1122:          LDA  #TOKEN_DO
00:B691 A212            	  1123:          LDX  #18             ; ERROR: DO expected
00:B693 20B1D1          	  1124:          JSR  CHKTKN
00:B696 204DD1          	  1125:          JSR  pas_get_token
00:B699 205FB3          	  1126:          JSR  STMNT
00:B69C 206F94          	  1127:          JSR  PULWRK
00:B69F 20BAB0          	  1128:          JSR  WRK_WRKD
00:B6A2 206F94          	  1129:          JSR  PULWRK
00:B6A5 20A4B0          	  1130:          JSR  WRK_OPND
00:B6A8 A93C            	  1131:          LDA  #PCODE_JMP     ; JMP      Jump unconditionally
00:B6AA 200EBD          	  1132:          JSR  GENRJMP
00:B6AD 20AFB0          	  1133:          JSR  WRKD_WRK
00:B6B0 4C56BD          	  1134:          JMP  FIXAD
                        	  1135: ;
                        	  1136: ; CASE
                        	  1137: ;
00:B6B3 2093B0          	  1138: CASE     JSR  GETEXPR
00:B6B6 A985            	  1139:          LDA  #TOKEN_OF       ; OF
00:B6B8 A21A            	  1140:          LDX  #26         ; ERROR: "of " expected
00:B6BA 20B1D1          	  1141:          JSR  CHKTKN
00:B6BD A901            	  1142:          LDA  #1
00:B6BF 854B            	  1143:          STA  COUNT1
00:B6C1 A900            	  1144: CASE7    LDA  #0
00:B6C3 854C            	  1145:          STA  COUNT2
                        	  1146: CASE2    =  *
00:B6C5 A92A            	  1147:          LDA  #PCODE_MOV  ; make copy of selector:  MOV       Copy (sp) to (sp + 1)
00:B6C7 209FBC          	  1148:          JSR  GENNOP
00:B6CA 2093B0          	  1149:          JSR  GETEXPR    ; next expression to compare
00:B6CD A910            	  1150:          LDA  #PCODE_EQL       ;  EQL       Test (sp - 1) == (sp)
00:B6CF 209FBC          	  1151:          JSR  GENNOP
00:B6D2 A593            	  1152:          LDA  token_type
00:B6D4 C93A            	  1153:          CMP  #':'
00:B6D6 F014            	  1154:          BEQ  CASE1
00:B6D8 A92C            	  1155:          LDA  #','
00:B6DA A205            	  1156:          LDX  #5      ; ERROR: , or : expected
00:B6DC 20B1D1          	  1157:          JSR  CHKTKN
00:B6DF 2080B0          	  1158:          JSR  PSHPCODE
00:B6E2 A93E            	  1159:          LDA  #PCODE_JM1     ; JM1      Jump if (sp) not zero
00:B6E4 2022BD          	  1160:          JSR  GENNJM
00:B6E7 E64C            	  1161:          INC  COUNT2
00:B6E9 4CC5B6          	  1162:          JMP  CASE2
00:B6EC 2099B0          	  1163: CASE1    JSR  PCD_WRKD
00:B6EF A93D            	  1164:          LDA  #PCODE_JMZ     ; JMZ      Jump if (sp) zero
00:B6F1 2022BD          	  1165:          JSR  GENNJM
00:B6F4 A54C            	  1166:          LDA  COUNT2
00:B6F6 F00A            	  1167:          BEQ  CASE3
00:B6F8 206F94          	  1168: CASE4    JSR  PULWRK
00:B6FB 2056BD          	  1169:          JSR  FIXAD
00:B6FE C64C            	  1170:          DEC  COUNT2
00:B700 D0F6            	  1171:          BNE  CASE4
00:B702 20AFB0          	  1172: CASE3    JSR  WRKD_WRK
00:B705 205C94          	  1173:          JSR  PSHWRK
00:B708 204DD1          	  1174:          JSR  pas_get_token
00:B70B A54B            	  1175:          LDA  COUNT1
00:B70D 48              	  1176:          PHA
00:B70E 205FB3          	  1177:          JSR  STMNT
00:B711 68              	  1178:          PLA
00:B712 854B            	  1179:          STA  COUNT1
00:B714 A593            	  1180:          LDA  token_type
00:B716 C994            	  1181:          CMP  #TOKEN_ELSE       ; ELSE
00:B718 F01B            	  1182:          BEQ  CASE5
00:B71A C93B            	  1183:          CMP  #';'
00:B71C D035            	  1184:          BNE  CASE6
00:B71E 2099B0          	  1185:          JSR  PCD_WRKD
00:B721 2020BD          	  1186:          JSR  GENNJP
00:B724 206F94          	  1187:          JSR  PULWRK
00:B727 2056BD          	  1188:          JSR  FIXAD
00:B72A 20AFB0          	  1189:          JSR  WRKD_WRK
00:B72D 205C94          	  1190:          JSR  PSHWRK
00:B730 E64B            	  1191:          INC  COUNT1
00:B732 4CC1B6          	  1192:          JMP  CASE7
00:B735 2099B0          	  1193: CASE5    JSR  PCD_WRKD
00:B738 2020BD          	  1194:          JSR  GENNJP
00:B73B 206F94          	  1195:          JSR  PULWRK
00:B73E 2056BD          	  1196:          JSR  FIXAD
00:B741 20AFB0          	  1197:          JSR  WRKD_WRK
00:B744 205C94          	  1198:          JSR  PSHWRK
00:B747 204DD1          	  1199:          JSR  pas_get_token
00:B74A A54B            	  1200:          LDA  COUNT1
00:B74C 48              	  1201:          PHA
00:B74D 205FB3          	  1202:          JSR  STMNT
00:B750 68              	  1203:          PLA
00:B751 854B            	  1204:          STA  COUNT1
00:B753 A989            	  1205: CASE6    LDA  #TOKEN_END       ; END
00:B755 A211            	  1206:          LDX  #17         ; ERROR: ; or END expected
00:B757 20B1D1          	  1207:          JSR  CHKTKN
00:B75A A54B            	  1208:          LDA  COUNT1
00:B75C F00A            	  1209:          BEQ  CASE8
00:B75E 206F94          	  1210: CASE9    JSR  PULWRK
00:B761 2056BD          	  1211:          JSR  FIXAD
00:B764 C64B            	  1212:          DEC  COUNT1
00:B766 D0F6            	  1213:          BNE  CASE9
00:B768 2034B8          	  1214: CASE8    JSR  FOR6
00:B76B 4C4DD1          	  1215:          JMP  pas_get_token
                        	  1216: ;
                        	  1217: ; FOR
                        	  1218: ;
00:B76E A949            	  1219: FOR      LDA  #TOKEN_IDENTIFIER
00:B770 A204            	  1220:          LDX  #4      ; ERROR:  Identifier expected
00:B772 20A1D1          	  1221:          JSR  GETCHK
00:B775 2024CA          	  1222:          JSR  LOOKUP
00:B778 C956            	  1223: FOR1     CMP  #SYMBOL_VARIABLE
00:B77A F009            	  1224:          BEQ  FOR2
00:B77C C959            	  1225:          CMP  #SYMBOL_FUNCTION_RETURN
00:B77E F005            	  1226:          BEQ  FOR2
00:B780 A20C            	  1227:          LDX  #12   ; ERROR: Illegal Identifier
00:B782 4CE099          	  1228:          jmp  ERROR
00:B785 20D3B3          	  1229: FOR2     JSR  ASSVAR
00:B788 206AB0          	  1230:          JSR  SYMWRK
00:B78B A900            	  1231:          LDA  #0
00:B78D 854B            	  1232:          STA  COUNT1
00:B78F A593            	  1233:          LDA  token_type
00:B791 C99B            	  1234:          CMP  #TOKEN_TO       ; TO
00:B793 F009            	  1235:          BEQ  FOR3
00:B795 A99C            	  1236:          LDA  #TOKEN_DOWNTO       ; DOWNTO
00:B797 A21C            	  1237:          LDX  #28       ; ERROR: TO or DOWNTO expected
00:B799 20B1D1          	  1238:          JSR  CHKTKN
00:B79C C64B            	  1239:          DEC  COUNT1
00:B79E A54B            	  1240: FOR3     LDA  COUNT1
00:B7A0 48              	  1241:          PHA
00:B7A1 205C94          	  1242:          JSR  PSHWRK
00:B7A4 2093B0          	  1243:          JSR  GETEXPR
00:B7A7 206F94          	  1244:          JSR  PULWRK
00:B7AA 2075B0          	  1245:          JSR  WRKSYM
00:B7AD 68              	  1246:          PLA
00:B7AE 854B            	  1247:          STA  COUNT1
00:B7B0 2080B0          	  1248:          JSR  PSHPCODE
00:B7B3 A92A            	  1249:          LDA  #PCODE_MOV     ; MOV      Copy (sp) to (sp + 1)
00:B7B5 209FBC          	  1250:          JSR  GENNOP
00:B7B8 206ACA          	  1251:          JSR  GET_LEV
00:B7BB 203FCA          	  1252:          JSR  GET_OFF
00:B7BE 2074CA          	  1253:          JSR  GET_DAT
00:B7C1 18              	  1254:          CLC
00:B7C2 692C            	  1255:          ADC  #PCODE_LOD  ; Load integer onto stack or PCODE_LODC if a char
00:B7C4 20B8BC          	  1256:          JSR  GENADR
00:B7C7 A916            	  1257:          LDA  #PCODE_GEQ        ; UP (GEQ): GEQ       Test (sp - 1) >= (sp)
00:B7C9 A64B            	  1258:          LDX  COUNT1
00:B7CB F002            	  1259:          BEQ  FOR4
00:B7CD A919            	  1260:          LDA  #PCODE_LEQ        ; DOWN (LEQ): LEQ       Test (sp - 1) <= (sp)
00:B7CF 209FBC          	  1261: FOR4     JSR  GENNOP
00:B7D2 2080B0          	  1262:          JSR  PSHPCODE
00:B7D5 A93D            	  1263:          LDA  #PCODE_JMZ       ;  JMZ       Jump if (sp) zero
00:B7D7 2022BD          	  1264:          JSR  GENNJM
00:B7DA A54B            	  1265:          LDA  COUNT1
00:B7DC 48              	  1266:          PHA
00:B7DD 206AB0          	  1267:          JSR  SYMWRK
00:B7E0 205C94          	  1268:          JSR  PSHWRK
00:B7E3 A997            	  1269:          LDA  #TOKEN_DO
00:B7E5 A212            	  1270:          LDX  #18       ; ERROR: DO expected
00:B7E7 20B1D1          	  1271:          JSR  CHKTKN
00:B7EA 204DD1          	  1272:          JSR  pas_get_token
00:B7ED 205FB3          	  1273:          JSR  STMNT
00:B7F0 206F94          	  1274:          JSR  PULWRK
00:B7F3 2075B0          	  1275:          JSR  WRKSYM
00:B7F6 206ACA          	  1276:          JSR  GET_LEV
00:B7F9 2074CA          	  1277:          JSR  GET_DAT
00:B7FC 203FCA          	  1278:          JSR  GET_OFF
00:B7FF A54A            	  1279:          LDA  DATTYP
00:B801 18              	  1280:          CLC
00:B802 692C            	  1281:          ADC  #PCODE_LOD       ; LOD      Load integer onto stack
00:B804 20B8BC          	  1282:          JSR  GENADR
00:B807 68              	  1283:          PLA
00:B808 854B            	  1284:          STA  COUNT1
00:B80A A926            	  1285:          LDA  #PCODE_INC     ; INC      Increment (sp) by 1
00:B80C A64B            	  1286:          LDX  COUNT1
00:B80E F002            	  1287:          BEQ  FOR5
00:B810 A928            	  1288:          LDA  #PCODE_DEC        ; DEC       Decrement (sp) by 1
00:B812 209FBC          	  1289: FOR5     JSR  GENNOP
00:B815 A932            	  1290:          LDA  #PCODE_STO       ; STO      Store integer
00:B817 18              	  1291:          CLC
00:B818 654A            	  1292:          ADC  DATTYP          ; may become PCODE_STOC if a char
00:B81A 20B8BC          	  1293:          JSR  GENADR
00:B81D 206F94          	  1294:          JSR  PULWRK
00:B820 20BAB0          	  1295:          JSR  WRK_WRKD
00:B823 206F94          	  1296:          JSR  PULWRK
00:B826 20A4B0          	  1297:          JSR  WRK_OPND
00:B829 A93C            	  1298:          LDA  #PCODE_JMP       ; JMP      Jump unconditionally
00:B82B 200EBD          	  1299:          JSR  GENRJMP
00:B82E 20AFB0          	  1300:          JSR  WRKD_WRK
00:B831 2056BD          	  1301:          JSR  FIXAD
00:B834 A9FF            	  1302: FOR6     LDA  #$FF
00:B836 852C            	  1303:          STA  OPND+1
00:B838 A9FD            	  1304:          LDA  #$FD
00:B83A 852B            	  1305:          STA  OPND
00:B83C A93B            	  1306:          LDA  #PCODE_INT       ;  INT       Increment stack pointer
00:B83E 4C28BD          	  1307:          JMP  GENJMP
                        	  1308: 
                        	  1309: 
                        	  1310: ;***********************************************
                        	  1311: ; MORE OF THE COMPILER (PROCESSING A 'BLOCK')
                        	  1312: ;***********************************************
                        	  1313: 
                        	  1314: CHKGET   =  *
00:B841 20B1D1          	  1315:          JSR  CHKTKN
00:B844 4C4DD1          	  1316:          JMP  pas_get_token
                        	  1317: ;
                        	  1318: ;  copy WORK to token_value
                        	  1319: ;
                        	  1320: WRK_VAL  =  *
00:B847 48              	  1321:          PHA
00:B848 A537            	  1322:          LDA  WORK
00:B84A 8594            	  1323:          STA  token_value
00:B84C A538            	  1324:          LDA  WORK+1
00:B84E 8595            	  1325:          STA  token_value+1
00:B850 68              	  1326:          PLA
00:B851 60              	  1327:          RTS
                        	  1328: ;
                        	  1329: ;  copy VALUE to WORK
                        	  1330: ;
                        	  1331: VAL_WRK  =  *
00:B852 48              	  1332:          PHA
00:B853 A594            	  1333:          LDA  token_value
00:B855 8537            	  1334:          STA  WORK
00:B857 A595            	  1335:          LDA  token_value+1
00:B859 8538            	  1336:          STA  WORK+1
00:B85B 68              	  1337:          PLA
00:B85C 60              	  1338:          RTS
                        	  1339: ;
                        	  1340: ;  copy ENDSYM to WORK
                        	  1341: ;
                        	  1342: END_WRK  =  *
00:B85D 48              	  1343:          PHA
00:B85E A531            	  1344:          LDA  ENDSYM
00:B860 8537            	  1345:          STA  WORK
00:B862 A532            	  1346:          LDA  ENDSYM+1
00:B864 8538            	  1347:          STA  WORK+1
00:B866 68              	  1348:          PLA
00:B867 60              	  1349:          RTS
                        	  1350: ;
                        	  1351: ;***********************************************
                        	  1352: ;
                        	  1353: ;
                        	  1354: ; BLOCK
                        	  1355: ;
00:B868 82              	  1356: BLCKT1   DFB  TOKEN_CONST
00:B869 BFB8            	  1357:          word BLKCNS
00:B86B 83              	  1358: BLCKT2   DFB  TOKEN_VAR
00:B86C D6B8            	  1359:          word BLKVAR
00:B86E 86              	  1360: BLCKT3   DFB  TOKEN_PROCEDURE
00:B86F 13BA            	  1361:          word BLKPRC
00:B871 87              	  1362:          DFB  TOKEN_FUNCTION
00:B872 33BA            	  1363:          word BLKFNC
00:B874 88              	  1364:          DFB  TOKEN_BEGIN
00:B875 FBBA            	  1365:          word BLKBEG
00:B877 00              	  1366:          DFB  0
                        	  1367: ;
                        	  1368: ;
00:B878 20FBB0          	  1369: BLOCK    JSR  CHK_STAK
00:B87B A900            	  1370:          LDA  #0
00:B87D 8521            	  1371:          STA  FRAME+1
00:B87F A906            	  1372:          LDA  #6
00:B881 8520            	  1373:          STA  FRAME
00:B883 A539            	  1374:          LDA  PRCITM
00:B885 8537            	  1375:          STA  WORK
00:B887 A63A            	  1376:          LDX  PRCITM+1
00:B889 8638            	  1377:          STX  WORK+1
00:B88B 053A            	  1378:          ORA  PRCITM+1
00:B88D F014            	  1379:          BEQ  BLK1
                        	  1380: 
                        	  1381: ;
00:B88F A004            	  1382: BLK1A    LDY  #SYMDSP
00:B891 A523            	  1383:          LDA  PCODE
00:B893 9137            	  1384:          STA  (WORK),Y
00:B895 C8              	  1385:          INY
00:B896 A524            	  1386:          LDA  PCODE+1
00:B898 9137            	  1387:          STA  (WORK),Y
00:B89A A900            	  1388:          LDA  #0
00:B89C A008            	  1389:          LDY  #SYMDAT
00:B89E 9137            	  1390:          STA  (WORK),Y   ; FLAG RELATIVE PROCEDURE
00:B8A0 4CABB8          	  1391:          JMP  BLK2
00:B8A3 A523            	  1392: BLK1     LDA  PCODE
00:B8A5 8537            	  1393:          STA  WORK
00:B8A7 A524            	  1394:          LDA  PCODE+1
00:B8A9 8538            	  1395:          STA  WORK+1
00:B8AB 205C94          	  1396: BLK2     JSR  PSHWRK
00:B8AE 2020BD          	  1397:          JSR  GENNJP
00:B8B1 A268            	  1398:          LDX  #<BLCKT1
00:B8B3 A0B8            	  1399:          LDY  #>BLCKT1
00:B8B5 A593            	  1400: BLK4     LDA  token_type
00:B8B7 208F91          	  1401:          JSR  TKNJMP
00:B8BA A219            	  1402:          LDX  #25       ; ERROR: BEGIN expected
00:B8BC 4CE099          	  1403:          jmp  ERROR
                        	  1404: ;
                        	  1405: ;
                        	  1406: ; CONSTANT
                        	  1407: ;
00:B8BF 204DD1          	  1408: BLKCNS   JSR  pas_get_token
00:B8C2 203FB0          	  1409: BLKCN1   JSR  CONDEC
00:B8C5 A93B            	  1410:          LDA  #';'
00:B8C7 A20A            	  1411:          LDX  #10       ; ERROR: ; expected
00:B8C9 2041B8          	  1412:          JSR  CHKGET
00:B8CC A26B            	  1413:          LDX  #<BLCKT2
00:B8CE A0B8            	  1414:          LDY  #>BLCKT2
00:B8D0 208F91          	  1415:          JSR  TKNJMP
00:B8D3 4CC2B8          	  1416:          JMP  BLKCN1
                        	  1417: ;
                        	  1418: ; VARIABLE
                        	  1419: ;
00:B8D6 A900            	  1420: BLKVAR   LDA  #0
00:B8D8 854B            	  1421:          STA  COUNT1
00:B8DA 204DD1          	  1422: BLKVR1   JSR  pas_get_token
00:B8DD 202DB1          	  1423: BLKVR6   JSR  VARDEC    ; check we have an identifier, add it to the symbol table, get another token
00:B8E0 E64B            	  1424:          INC  COUNT1    ; how many variables in this declaration
00:B8E2 1003            	  1425:          BPL  BLKVR7
00:B8E4 4C54B9          	  1426:          JMP  BLKV13     ; ERROR  - compiler limits exceeded (more than 127 variables?)
00:B8E7 A593            	  1427: BLKVR7   LDA  token_type
00:B8E9 C92C            	  1428:          CMP  #','
00:B8EB F0ED            	  1429:          BEQ  BLKVR1    ; back for another
00:B8ED A93A            	  1430:          LDA  #':'
00:B8EF A205            	  1431:          LDX  #5        ; ERROR: , or : expected
00:B8F1 2041B8          	  1432:          JSR  CHKGET
00:B8F4 C984            	  1433:          CMP  #TOKEN_ARRAY   ; ARRAY
00:B8F6 F043            	  1434:          BEQ  BLKVR2
00:B8F8 C9FE            	  1435:          CMP  #TOKEN_INTEGER ; INTEGER
00:B8FA F00A            	  1436:          BEQ  BLKVR8
00:B8FC A9A1            	  1437:          LDA  #TOKEN_CHAR    ; CHAR
00:B8FE A224            	  1438:          LDX  #36            ; ERROR: Data Type not recognised
00:B900 20B1D1          	  1439:          JSR  CHKTKN
00:B903 4CFBB9          	  1440:          JMP  BLKVR3
                        	  1441: 
                        	  1442: ;
                        	  1443: ;  integer variable
                        	  1444: ;
00:B906 20A0B9          	  1445: BLKVR8   JSR  BLKVR9  ; subtract COUNT1 from FRAME, put WORK into VALUE, put ENDSYM into WORK
                        	  1446: BLKV10   = *
00:B909 A008            	  1447:          LDY  #SYMDAT
00:B90B A900            	  1448:          LDA  #0         ; INTEGER TYPE
00:B90D 9137            	  1449:          STA  (WORK),Y
00:B90F A520            	  1450:          LDA  FRAME
00:B911 A004            	  1451:          LDY  #SYMDSP
00:B913 9137            	  1452:          STA  (WORK),Y
00:B915 C8              	  1453:          INY
00:B916 A521            	  1454:          LDA  FRAME+1
00:B918 9137            	  1455:          STA  (WORK),Y
00:B91A 18              	  1456:          CLC
00:B91B A520            	  1457:          LDA  FRAME
00:B91D 6903            	  1458:          ADC  #3
00:B91F 8520            	  1459:          STA  FRAME
00:B921 9002            	  1460:          BCC  BLKV10_A
00:B923 E621            	  1461:          INC  FRAME+1
                        	  1462: BLKV10_A =  *
00:B925 C64B            	  1463:          DEC  COUNT1
00:B927 D003            	  1464:          BNE  BLKV10_B
00:B929 4CFBB9          	  1465:          JMP  BLKVR3
                        	  1466: 
                        	  1467: BLKV10_B = *
                        	  1468: ;
                        	  1469: ;  more in the list, go to the previous symbol
                        	  1470: ;
00:B92C A000            	  1471:          LDY  #SYMPRV
00:B92E B137            	  1472:          LDA  (WORK),Y
00:B930 AA              	  1473:          TAX
00:B931 C8              	  1474:          INY
00:B932 B137            	  1475:          LDA  (WORK),Y
00:B934 8538            	  1476:          STA  WORK+1
00:B936 8A              	  1477:          TXA
00:B937 8537            	  1478:          STA  WORK       ; PREVIOUS ITEM
00:B939 80CE            	  1479:          BRA  BLKV10
                        	  1480: 
                        	  1481: ;
                        	  1482: ; ARRAY [ N ] OF ...
                        	  1483: ;
00:B93B 202BB0          	  1484: BLKVR2   JSR  CHKLHB
00:B93E 2007B1          	  1485:          JSR  CONST     ; get how many are in the array
00:B941 A596            	  1486:          LDA  token_value+2   ; can't be more than 65536
00:B943 D00F            	  1487:          BNE  BLKV13
00:B945 A594            	  1488:          LDA  token_value     ; add 1 to the count since array [3] of char means 4 elements
00:B947 18              	  1489:          CLC
00:B948 6901            	  1490:          ADC  #1
00:B94A 8594            	  1491:          STA  token_value
00:B94C A595            	  1492:          LDA  token_value+1
00:B94E 3004            	  1493:          BMI  BLKV13
00:B950 6900            	  1494:          ADC  #0
00:B952 1005            	  1495:          BPL  BLKVR4
00:B954 A20F            	  1496: BLKV13   LDX  #15       ; ERROR: compiler limits exceeded
00:B956 4CE099          	  1497:          jmp  ERROR
00:B959 8595            	  1498: BLKVR4   STA  token_value+1
00:B95B 2052B8          	  1499:          JSR  VAL_WRK   ; put the value (array count) in WORK
00:B95E 204DD1          	  1500:          JSR  pas_get_token
00:B961 2035B0          	  1501:          JSR  CHKRHB
00:B964 A901            	  1502:          LDA  #1        ; char
00:B966 854A            	  1503:          STA  DATTYP
00:B968 A985            	  1504:          LDA  #TOKEN_OF  ; OF
00:B96A A21A            	  1505:          LDX  #26        ; ERROR: "of " expected
00:B96C 2041B8          	  1506:          JSR  CHKGET
00:B96F C9FE            	  1507:          CMP  #TOKEN_INTEGER  ; INTEGER
00:B971 D020            	  1508:          BNE  BLKV11
00:B973 C64A            	  1509:          DEC  DATTYP    ; DATTYP of 0 is integer, and 1 is char
00:B975 2047B8          	  1510:          JSR  WRK_VAL   ; get the array count back into token_value
                        	  1511: ;
                        	  1512: ; MULTIPLY token_value BY 3
                        	  1513: ;
00:B978 A594            	  1514:          LDA  token_value
00:B97A A695            	  1515:          LDX  token_value+1
00:B97C 0694            	  1516:          ASL  token_value
00:B97E 2695            	  1517:          ROL  token_value+1
00:B980 B0D2            	  1518:          BCS  BLKV13
00:B982 6594            	  1519:          ADC  token_value
00:B984 8594            	  1520:          STA  token_value
00:B986 8A              	  1521:          TXA
00:B987 6595            	  1522:          ADC  token_value+1
00:B989 B0C9            	  1523:          BCS  BLKV13
00:B98B 8595            	  1524:          STA  token_value+1
00:B98D 2052B8          	  1525:          JSR  VAL_WRK     ; put the array count (times 3) back into WORK
00:B990 4C9AB9          	  1526:          JMP  BLKV12
                        	  1527:  ;
                        	  1528:  ;  here for array of char
                        	  1529:  ;
00:B993 A9A1            	  1530: BLKV11   LDA  #TOKEN_CHAR       ; CHAR
00:B995 A224            	  1531:          LDX  #36           ; ERROR: Data Type not recognised
00:B997 20B1D1          	  1532:          JSR  CHKTKN
00:B99A 20A0B9          	  1533: BLKV12   JSR  BLKVR9        ; we are COUNT1 frames back
00:B99D 4CB9B9          	  1534:          JMP  BLKVR5
                        	  1535: 
                        	  1536: BLKVR9   =  *
00:B9A0 A520            	  1537:          LDA  FRAME         ; subtract COUNT1 (the variable position) from the frame number
00:B9A2 38              	  1538:          SEC
00:B9A3 E54B            	  1539:          SBC  COUNT1
00:B9A5 8520            	  1540:          STA  FRAME
00:B9A7 A521            	  1541:          LDA  FRAME+1
00:B9A9 E900            	  1542:          SBC  #0
00:B9AB 8521            	  1543:          STA  FRAME+1
00:B9AD 2047B8          	  1544:          JSR  WRK_VAL     ; copy WORK to VALUE (array count, possibly multiplied by 3)
00:B9B0 A531            	  1545:          LDA  ENDSYM      ; end of symbol table into WORK
00:B9B2 8537            	  1546:          STA  WORK
00:B9B4 A532            	  1547:          LDA  ENDSYM+1
00:B9B6 8538            	  1548:          STA  WORK+1
00:B9B8 60              	  1549:          RTS
                        	  1550: 
                        	  1551: ;
                        	  1552: ;  we should be here with ENDSYM in WORK (for walking back through the symbol table for all the variables we just decla
                        	  1553: ;  COUNT1 will be the number of symbols we have to fix up
                        	  1554: ;
                        	  1555: BLKVR5   = *
00:B9B9 A003            	  1556:          ldy  #SYMTYP
00:B9BB A941            	  1557:          lda  #SYMBOL_ARRAY
00:B9BD 9137            	  1558:          sta  (WORK),Y    ; make symbol type array
00:B9BF A004            	  1559:          ldy  #SYMDSP
00:B9C1 A520            	  1560:          lda  FRAME       ; FRAME is the displacement
00:B9C3 9137            	  1561:          sta  (WORK),Y
00:B9C5 C8              	  1562:          iny
00:B9C6 A521            	  1563:          lda  FRAME+1
00:B9C8 9137            	  1564:          sta  (WORK),Y
00:B9CA A594            	  1565:          lda  token_value       ; array count (multiplied by 3 in the case of integers)
00:B9CC 18              	  1566:          clc
00:B9CD 6520            	  1567:          adc  FRAME       ; add to the stack frame address
00:B9CF 8520            	  1568:          sta  FRAME
00:B9D1 A595            	  1569:          lda  token_value+1
00:B9D3 6521            	  1570:          adc  FRAME+1
00:B9D5 8521            	  1571:          sta  FRAME+1
00:B9D7 A008            	  1572:          ldy  #SYMDAT
00:B9D9 A54A            	  1573:          lda  DATTYP       ; save the data type in the symbol
00:B9DB 9137            	  1574:          sta  (WORK),Y
00:B9DD A006            	  1575:          ldy  #SYMSUB
00:B9DF A594            	  1576:          lda  token_value        ; max subscript + 1
00:B9E1 9137            	  1577:          sta  (WORK),Y
00:B9E3 A595            	  1578:          lda  token_value+1
00:B9E5 C8              	  1579:          iny
00:B9E6 9137            	  1580:          sta  (WORK),Y
00:B9E8 C64B            	  1581:          dec  COUNT1
00:B9EA F00F            	  1582:          beq  BLKVR3
                        	  1583: ;
                        	  1584: ;  onto the previous symbol
                        	  1585: ;
00:B9EC A000            	  1586:          ldy  #SYMPRV
00:B9EE B137            	  1587:          lda  (WORK),Y
00:B9F0 AA              	  1588:          tax
00:B9F1 C8              	  1589:          iny
00:B9F2 B137            	  1590:          lda  (WORK),Y
00:B9F4 8538            	  1591:          sta  WORK+1
00:B9F6 8A              	  1592:          txa
00:B9F7 8537            	  1593:          sta  WORK       ; PREVIOUS ITEM
00:B9F9 80BE            	  1594:          bra  BLKVR5
                        	  1595: ;
                        	  1596: ;  here at end of variable declaration (after INTEGER / CHAR)
                        	  1597: ;
00:B9FB A93B            	  1598: BLKVR3   LDA  #';'
00:B9FD A20A            	  1599:          LDX  #10       ; ERROR: ; expected
00:B9FF 20A1D1          	  1600:          JSR  GETCHK
00:BA02 204DD1          	  1601:          JSR  pas_get_token
00:BA05 A26E            	  1602:          LDX  #<BLCKT3  ; now look for procedure / function / begin
00:BA07 A0B8            	  1603:          LDY  #>BLCKT3
00:BA09 208F91          	  1604:          JSR  TKNJMP    ; if not there, look for another variable declaration
00:BA0C A900            	  1605:          LDA  #0        ; zero variables in this list so far
00:BA0E 854B            	  1606:          STA  COUNT1
00:BA10 4CDDB8          	  1607:          JMP  BLKVR6
                        	  1608: ;
                        	  1609: ; PROCEDURE DECLARATION
                        	  1610: ;
00:BA13 A949            	  1611: BLKPRC   LDA  #'I'
00:BA15 A204            	  1612:          LDX  #4         ; ERROR: Identifier expected
00:BA17 20A1D1          	  1613:          JSR  GETCHK
00:BA1A A900            	  1614:          LDA  #0
00:BA1C 854B            	  1615:          STA  COUNT1    ; no function return value
00:BA1E 202FCA          	  1616:          JSR  CHKDUP
00:BA21 A950            	  1617:          LDA  #SYMBOL_PROCEDURE
00:BA23 2088C9          	  1618:          JSR  ADDSYM
00:BA26 E622            	  1619:          INC  LEVEL
00:BA28 A540            	  1620:          LDA  SYMITM
00:BA2A 8539            	  1621:          STA  PRCITM    ; PRCITM is the symbol of the procedure/function
00:BA2C A541            	  1622:          LDA  SYMITM+1
00:BA2E 853A            	  1623:          STA  PRCITM+1
00:BA30 4C55BA          	  1624:          JMP  BLKPR1
                        	  1625: ;
                        	  1626: ; FUNCTION DECLARATION
                        	  1627: ;
00:BA33 A949            	  1628: BLKFNC   LDA  #TOKEN_IDENTIFIER
00:BA35 A204            	  1629:          LDX  #4      ; ERROR: Identifier expected
00:BA37 20A1D1          	  1630:          JSR  GETCHK
00:BA3A 202FCA          	  1631:          JSR  CHKDUP
00:BA3D A946            	  1632:          LDA  #SYMBOL_FUNCTION
00:BA3F 2088C9          	  1633:          JSR  ADDSYM
00:BA42 E622            	  1634:          INC  LEVEL
00:BA44 A901            	  1635:          LDA  #1
00:BA46 854B            	  1636:          STA  COUNT1    ; we have the function return as a symbol
00:BA48 A540            	  1637:          LDA  SYMITM
00:BA4A 8539            	  1638:          STA  PRCITM   ; PRCITM is the symbol of the procedure/function
00:BA4C A541            	  1639:          LDA  SYMITM+1
00:BA4E 853A            	  1640:          STA  PRCITM+1
00:BA50 A959            	  1641:          LDA  #SYMBOL_FUNCTION_RETURN ; for assigning the results to
00:BA52 2088C9          	  1642:          JSR  ADDSYM
                        	  1643: ;
                        	  1644: ; PROCEDURE AND FUNCTION COMMON CODE
                        	  1645: ;
00:BA55 A54B            	  1646: BLKPR1   LDA  COUNT1
00:BA57 854C            	  1647:          STA  COUNT2    ; remember if we had 0 or 1 extra symbols (function return)
00:BA59 205DB8          	  1648:          JSR  END_WRK
00:BA5C 205C94          	  1649:          JSR  PSHWRK
00:BA5F A520            	  1650:          LDA  FRAME
00:BA61 8537            	  1651:          STA  WORK
00:BA63 A521            	  1652:          LDA  FRAME+1
00:BA65 8538            	  1653:          STA  WORK+1
00:BA67 205C94          	  1654:          JSR  PSHWRK
00:BA6A 204DD1          	  1655:          JSR  pas_get_token
00:BA6D C928            	  1656:          CMP  #'('      ; opening bracket after procedure/function name?
00:BA6F D016            	  1657:          BNE  BLKPR2
00:BA71 204DD1          	  1658: BLKPR3   JSR  pas_get_token
00:BA74 202DB1          	  1659:          JSR  VARDEC
00:BA77 E64B            	  1660:          INC  COUNT1    ; count arguments
00:BA79 1003            	  1661:          BPL  BLKPR6
00:BA7B 4C54B9          	  1662:          JMP  BLKV13
00:BA7E A593            	  1663: BLKPR6   LDA  token_type
00:BA80 C92C            	  1664:          CMP  #','
00:BA82 F0ED            	  1665:          BEQ  BLKPR3
00:BA84 2018B0          	  1666:          JSR  CHKRHP
00:BA87 A539            	  1667: BLKPR2   LDA  PRCITM      ; here after argument list, if any
00:BA89 8537            	  1668:          STA  WORK
00:BA8B A53A            	  1669:          LDA  PRCITM+1
00:BA8D 8538            	  1670:          STA  WORK+1
00:BA8F A006            	  1671:          LDY  #SYMARG
00:BA91 A54B            	  1672:          LDA  COUNT1
00:BA93 38              	  1673:          SEC
00:BA94 E54C            	  1674:          SBC  COUNT2      ; subtract 0 or 1 depending on if this is a function or not
00:BA96 9137            	  1675:          STA  (WORK),Y    ; store the number of arguments to this procedure/function
00:BA98 A93B            	  1676:          LDA  #';'
00:BA9A A20A            	  1677:          LDX  #10         ; ERROR: ; expected
00:BA9C 20B1D1          	  1678:          JSR  CHKTKN
00:BA9F A54B            	  1679:          LDA  COUNT1
00:BAA1 F02C            	  1680:          BEQ  BLKPR4
00:BAA3 205DB8          	  1681:          JSR  END_WRK     ; ENDSYM -> WORK
00:BAA6 A2FD            	  1682:          LDX  #$FD        ; X = -3
                        	  1683: ; WORK starts off pointing to the procedure/function symbol
                        	  1684: BLKPR5   = *
00:BAA8 A008            	  1685:          LDY  #SYMDAT
00:BAAA A900            	  1686:          LDA  #0
00:BAAC 9137            	  1687:          STA  (WORK),Y    ; data type = integer
00:BAAE A004            	  1688:          LDY  #SYMDSP
00:BAB0 8A              	  1689:          TXA
00:BAB1 9137            	  1690:          STA  (WORK),Y
00:BAB3 38              	  1691:          SEC
00:BAB4 E903            	  1692:          SBC  #3
00:BAB6 AA              	  1693:          TAX
00:BAB7 A9FF            	  1694:          LDA  #$FF
00:BAB9 C8              	  1695:          INY
00:BABA 9137            	  1696:          STA  (WORK),Y
00:BABC C64B            	  1697:          DEC  COUNT1
00:BABE F00F            	  1698:          beq  BLKPR4
                        	  1699: ;
                        	  1700: ;  back to previous symbol
                        	  1701: ;
00:BAC0 A000            	  1702:          LDY  #SYMPRV
00:BAC2 B137            	  1703:          LDA  (WORK),Y
00:BAC4 48              	  1704:          PHA
00:BAC5 C8              	  1705:          INY
00:BAC6 B137            	  1706:          LDA  (WORK),Y
00:BAC8 8538            	  1707:          STA  WORK+1
00:BACA 68              	  1708:          PLA
00:BACB 8537            	  1709:          STA  WORK
00:BACD 80D9            	  1710:          bra  BLKPR5
00:BACF 204DD1          	  1711: BLKPR4   JSR  pas_get_token
00:BAD2 2078B8          	  1712:          JSR  BLOCK
00:BAD5 C622            	  1713:          DEC  LEVEL
00:BAD7 206F94          	  1714:          JSR  PULWRK
00:BADA A537            	  1715:          LDA  WORK
00:BADC 8520            	  1716:          STA  FRAME
00:BADE A538            	  1717:          LDA  WORK+1
00:BAE0 8521            	  1718:          STA  FRAME+1
00:BAE2 206F94          	  1719:          JSR  PULWRK
00:BAE5 A537            	  1720:          LDA  WORK
00:BAE7 8531            	  1721:          STA  ENDSYM
00:BAE9 A538            	  1722:          LDA  WORK+1
00:BAEB 8532            	  1723:          STA  ENDSYM+1
00:BAED A93B            	  1724:          LDA  #';'
00:BAEF A20A            	  1725:          LDX  #10       ; ERROR: ; expected
00:BAF1 2041B8          	  1726:          JSR  CHKGET
00:BAF4 A26E            	  1727:          LDX  #<BLCKT3
00:BAF6 A0B8            	  1728:          LDY  #>BLCKT3
00:BAF8 4CB5B8          	  1729:          JMP  BLK4
                        	  1730: ;
                        	  1731: ; BEGIN (COMPOUND STATEMENT)
                        	  1732: ;
00:BAFB 204DD1          	  1733: BLKBEG   JSR  pas_get_token
00:BAFE 206F94          	  1734:          JSR  PULWRK
00:BB01 A522            	  1735:          LDA  LEVEL
00:BB03 D006            	  1736:          BNE  BLKB1
00:BB05 2056BD          	  1737: BLKB3    JSR  FIXAD
00:BB08 4C27BB          	  1738:          JMP  BLKB2
00:BB0B 2075B0          	  1739: BLKB1    JSR  WRKSYM
00:BB0E A004            	  1740:          LDY  #SYMDSP
00:BB10 B140            	  1741:          LDA  (SYMITM),Y
00:BB12 8537            	  1742:          STA  WORK
00:BB14 C8              	  1743:          INY
00:BB15 B140            	  1744:          LDA  (SYMITM),Y
00:BB17 8538            	  1745:          STA  WORK+1
00:BB19 A004            	  1746:          LDY  #SYMDSP
00:BB1B A523            	  1747:          LDA  PCODE
00:BB1D 9140            	  1748:          STA  (SYMITM),Y
00:BB1F A524            	  1749:          LDA  PCODE+1
00:BB21 C8              	  1750:          INY
00:BB22 9140            	  1751:          STA  (SYMITM),Y
00:BB24 4C05BB          	  1752:          JMP  BLKB3
00:BB27 A520            	  1753: BLKB2    LDA  FRAME
00:BB29 852B            	  1754:          STA  OPND
00:BB2B A521            	  1755:          LDA  FRAME+1
00:BB2D 852C            	  1756:          STA  OPND+1
00:BB2F A93B            	  1757:          LDA  #PCODE_INT         ; INT      Increment stack pointer
00:BB31 2028BD          	  1758:          JSR  GENJMP
00:BB34 205FB3          	  1759: BLKB5    JSR  STMNT
00:BB37 A593            	  1760:          LDA  token_type
00:BB39 C93B            	  1761:          CMP  #';'
00:BB3B D006            	  1762:          BNE  BLKB4
00:BB3D 204DD1          	  1763:          JSR  pas_get_token
00:BB40 4C34BB          	  1764:          JMP  BLKB5
00:BB43 A989            	  1765: BLKB4    LDA  #TOKEN_END       ; END
00:BB45 A211            	  1766:          LDX  #17         ; ERROR: ; or END expected
00:BB47 2041B8          	  1767:          JSR  CHKGET
00:BB4A A929            	  1768:          LDA  #PCODE_RTN  ; OK - we are at the end of a block - this is a procedure/function return
00:BB4C A622            	  1769:          LDX  LEVEL       ; OR - if we are at level 0, then that is the end of the program
00:BB4E D002            	  1770:          BNE  BLKB6
00:BB50 A911            	  1771:          LDA  #PCODE_FINISHD        ; Opcode: FINISHED  Stop run (end program)
                        	  1772: TEST1    =  *
00:BB52 4C9FBC          	  1773: BLKB6    JMP  GENNOP
                        	  1774: ;
                        	  1775: 
                        	  1776: 
                        	  1777: ;
                        	  1778: ;  Writing library functions is quite easy:
                        	  1779: ;
                        	  1780: ;   1. For each of the n arguments that they have (could be zero) do a PULTOP to get
                        	  1781: ;      that value from the runtime stack into REG. Or, PULTOP2 to get the value into REG2.
                        	  1782: ;      For two arguments you can do PULBOTH to get them into REG and REG2.
                        	  1783: ;   2. Do whatever the function/procedure is supposed to do with those arguments
                        	  1784: ;   3. If a procedure, you are finished: JMP MAIN
                        	  1785: ;      For a function, put the result into REG, and then JMP MAINP
                        	  1786: ;      - or - (equivalently): JSR PSHTOP, JMP MAIN
                        	  1787: ;
                        	  1788: ;  Note: PULTOP puts the value into REG and also: A, X and Y registers where A is the low-order
                        	  1789: ;        byte, X the middle byte, and Y the high-order byte.
                        	  1790: ;
                        	  1791: 
                        	  1792: ;                         Name           function or procedure   Args Execution address
                        	  1793: pascal_library_functions_table:
                        	  1794: ;
                        	  1795: ;    functions
                        	  1796: ;
                        	  1797:   makePasLibraryFunction "ABS",          SYMBOL_LIBRARY_FUNCTION,  1, EX_ABS
00:BB55 414253          	     1M      asciiz   "ABS"
00:BB58 00
00:BB59 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:BB5A 01              	     3M      dfb      1
00:BB5B E2C0            	     4M      word     EX_ABS
                        	  1798:   makePasLibraryFunction "DIGITALREAD",  SYMBOL_LIBRARY_FUNCTION,  1, EX_DIGITALREAD
00:BB5D 4449474954414C52	     1M      asciiz   "DIGITALREAD"
00:BB65 454144
00:BB68 00
00:BB69 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:BB6A 01              	     3M      dfb      1
00:BB6B 5CC5            	     4M      word     EX_DIGITALREAD
                        	  1799:   makePasLibraryFunction "GETKEY",       SYMBOL_LIBRARY_FUNCTION,  0, EX_GETKEY
00:BB6D 4745544B4559    	     1M      asciiz   "GETKEY"
00:BB73 00
00:BB74 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:BB75 00              	     3M      dfb      0
00:BB76 9CC0            	     4M      word     EX_GETKEY
                        	  1800:   makePasLibraryFunction "RANDOM",       SYMBOL_LIBRARY_FUNCTION,  0, EX_RANDOM
00:BB78 52414E444F4D    	     1M      asciiz   "RANDOM"
00:BB7E 00
00:BB7F 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:BB80 00              	     3M      dfb      0
00:BB81 84C5            	     4M      word     EX_RANDOM
                        	  1801:   makePasLibraryFunction "LATENCY",      SYMBOL_LIBRARY_FUNCTION,  0, EX_LATENCY
00:BB83 4C4154454E4359  	     1M      asciiz   "LATENCY"
00:BB8A 00
00:BB8B 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:BB8C 00              	     3M      dfb      0
00:BB8D 96C5            	     4M      word     EX_LATENCY
                        	  1802: ;
                        	  1803: ;      procedures
                        	  1804: ;
                        	  1805:   makePasLibraryFunction "ASSERT",       SYMBOL_LIBRARY_PROCEDURE, 1, EX_ASSERT
00:BB8F 415353455254    	     1M      asciiz   "ASSERT"
00:BB95 00
00:BB96 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:BB97 01              	     3M      dfb      1
00:BB98 E9C5            	     4M      word     EX_ASSERT
                        	  1806:   makePasLibraryFunction "DELAY",        SYMBOL_LIBRARY_PROCEDURE, 1, EX_DELAY
00:BB9A 44454C4159      	     1M      asciiz   "DELAY"
00:BB9F 00
00:BBA0 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:BBA1 01              	     3M      dfb      1
00:BBA2 A5C5            	     4M      word     EX_DELAY
                        	  1807:   makePasLibraryFunction "DIGITALWRITE", SYMBOL_LIBRARY_PROCEDURE, 2, EX_DIGITALWRITE
00:BBA4 4449474954414C57	     1M      asciiz   "DIGITALWRITE"
00:BBAC 52495445
00:BBB0 00
00:BBB1 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:BBB2 02              	     3M      dfb      2
00:BBB3 D4C5            	     4M      word     EX_DIGITALWRITE
                        	  1808:   makePasLibraryFunction "LCDCLEAR",     SYMBOL_LIBRARY_PROCEDURE, 0, EX_LCDCLEAR
00:BBB5 4C4344434C454152	     1M      asciiz   "LCDCLEAR"
00:BBBD 00
00:BBBE 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:BBBF 00              	     3M      dfb      0
00:BBC0 CEC4            	     4M      word     EX_LCDCLEAR
                        	  1809:   makePasLibraryFunction "LCDHOME",      SYMBOL_LIBRARY_PROCEDURE, 0, EX_LCDHOME
00:BBC2 4C4344484F4D45  	     1M      asciiz   "LCDHOME"
00:BBC9 00
00:BBCA 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:BBCB 00              	     3M      dfb      0
00:BBCC C8C4            	     4M      word     EX_LCDHOME
                        	  1810:   makePasLibraryFunction "LCDPOS",       SYMBOL_LIBRARY_PROCEDURE, 2, EX_LCDPOS
00:BBCE 4C4344504F53    	     1M      asciiz   "LCDPOS"
00:BBD4 00
00:BBD5 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:BBD6 02              	     3M      dfb      2
00:BBD7 6AC5            	     4M      word     EX_LCDPOS
                        	  1811:   makePasLibraryFunction "PINMODE",      SYMBOL_LIBRARY_PROCEDURE, 2, EX_PINMODE
00:BBD9 50494E4D4F4445  	     1M      asciiz   "PINMODE"
00:BBE0 00
00:BBE1 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:BBE2 02              	     3M      dfb      2
00:BBE3 C5C5            	     4M      word     EX_PINMODE
                        	  1812:   makePasLibraryFunction "RANDOMSEED",   SYMBOL_LIBRARY_PROCEDURE, 1, EX_RANDOMSEED
00:BBE5 52414E444F4D5345	     1M      asciiz   "RANDOMSEED"
00:BBED 4544
00:BBEF 00
00:BBF0 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:BBF1 01              	     3M      dfb      1
00:BBF2 B5C5            	     4M      word     EX_RANDOMSEED
00:BBF4 00              	  1813:   dfb 0   ; end of table
                        	  1814: 
                        	  1815: add_pascal_library_functions:
00:BBF5 A955            	  1816:   lda #<pascal_library_functions_table
00:BBF7 8500            	  1817:   sta REG
00:BBF9 A9BB            	  1818:   lda #>pascal_library_functions_table
00:BBFB 8501            	  1819:   sta REG+1
                        	  1820: add_pascal_library_functions_loop:
00:BBFD A000            	  1821:   ldy #0
00:BBFF B100            	  1822:   lda (REG),Y
00:BC01 F04B            	  1823:   beq add_pascal_library_functions_done
00:BC03 A500            	  1824:   lda REG
00:BC05 8590            	  1825:   sta token_address
00:BC07 A501            	  1826:   lda REG+1
00:BC09 8591            	  1827:   sta token_address+1
00:BC0B 6492            	  1828:   stz token_length
                        	  1829: ;
                        	  1830: ;  find name length
                        	  1831: ;
                        	  1832: add_pascal_library_functions_name_loop
00:BC0D C8              	  1833:   iny
00:BC0E E692            	  1834:   inc token_length
00:BC10 B100            	  1835:   lda (REG),Y
00:BC12 D0F9            	  1836:   bne add_pascal_library_functions_name_loop
00:BC14 5A              	  1837:   phy
00:BC15 A943            	  1838:   lda #SYMBOL_CONSTANT  ; add the symbol as a constant for now
00:BC17 2088C9          	  1839:   jsr ADDSYM
00:BC1A 7A              	  1840:   ply
                        	  1841: 
00:BC1B C8              	  1842:   iny             ; get past the 0x00
00:BC1C B100            	  1843:   lda (REG),Y     ; get symbol type
00:BC1E 5A              	  1844:   phy
00:BC1F A003            	  1845:   ldy #SYMTYP
00:BC21 9140            	  1846:   sta (SYMITM),Y  ; change symbol type to be correct
00:BC23 7A              	  1847:   ply
                        	  1848: 
00:BC24 C8              	  1849:   iny             ; get next byte
00:BC25 B100            	  1850:   lda (REG),Y     ; get number of arguments
00:BC27 5A              	  1851:   phy
00:BC28 A006            	  1852:   ldy #SYMARG
00:BC2A 9140            	  1853:   sta (SYMITM),Y  ; save number of arguments
00:BC2C 7A              	  1854:   ply
                        	  1855: 
00:BC2D C8              	  1856:   iny             ; get next byte
00:BC2E B100            	  1857:   lda (REG),Y     ; get function address low-byte
00:BC30 5A              	  1858:   phy
00:BC31 A004            	  1859:   ldy #SYMDSP
00:BC33 9140            	  1860:   sta (SYMITM),Y  ; save function address low-byte
00:BC35 7A              	  1861:   ply
                        	  1862: 
00:BC36 C8              	  1863:   iny             ; get next byte
00:BC37 B100            	  1864:   lda (REG),Y     ; get function address high-byte
00:BC39 5A              	  1865:   phy
00:BC3A A005            	  1866:   ldy #SYMDSP+1
00:BC3C 9140            	  1867:   sta (SYMITM),Y  ; save function address high-byte
00:BC3E 7A              	  1868:   ply
                        	  1869: 
00:BC3F C8              	  1870:   iny         ; get past that last byte
00:BC40 98              	  1871:   tya         ; move REG onto next entry
00:BC41 18              	  1872:   clc
00:BC42 6500            	  1873:   adc REG
00:BC44 8500            	  1874:   sta REG
00:BC46 A900            	  1875:   lda #0
00:BC48 6501            	  1876:   adc REG+1
00:BC4A 8501            	  1877:   sta REG+1
00:BC4C 80AF            	  1878:   bra add_pascal_library_functions_loop
                        	  1879: 
                        	  1880: add_pascal_library_functions_done:
00:BC4E 60              	  1881:   rts
                        	  1882: 
                        	  1883: 
                        	  1884: library_function_call:
                        	  1885: 
00:BC4F A900            	  1886:   lda  #0
00:BC51 854B            	  1887:   sta  COUNT1      ; number of arguments
00:BC53 A006            	  1888:   ldy  #SYMARG
00:BC55 B140            	  1889:   lda  (SYMITM),Y
00:BC57 F032            	  1890:   beq  library_function_call_1
                        	  1891: 
                        	  1892: ;
                        	  1893: ;  here if it has arguments - push them on the stack
                        	  1894: ;
                        	  1895: 
00:BC59 2011B0          	  1896:   jsr  CHKLHP
                        	  1897: library_function_call_2
00:BC5C A54B            	  1898:   lda  COUNT1    ; save on stack in case the expression calls functions
00:BC5E 48              	  1899:   pha
00:BC5F 206AB0          	  1900:   jsr  SYMWRK
00:BC62 205C94          	  1901:   jsr  PSHWRK
00:BC65 2093B0          	  1902:   jsr  GETEXPR
00:BC68 206F94          	  1903:   jsr  PULWRK
00:BC6B 2075B0          	  1904:   jsr  WRKSYM
00:BC6E 68              	  1905:   pla            ; get number of arguments back
00:BC6F 854B            	  1906:   sta  COUNT1
00:BC71 E64B            	  1907:   inc  COUNT1    ; add 1 for the one we just processed
00:BC73 A593            	  1908:   lda  token_type
00:BC75 C92C            	  1909:   cmp  #','
00:BC77 F0E3            	  1910:   beq  library_function_call_2
                        	  1911: 
00:BC79 A54B            	  1912:   lda  COUNT1
00:BC7B A006            	  1913:   ldy  #SYMARG
00:BC7D D140            	  1914:   cmp  (SYMITM),Y   ; check we got the right number of arguments
00:BC7F F005            	  1915:   beq  library_function_call_3
                        	  1916: 
00:BC81 A223            	  1917:   ldx  #35     ; ERROR: Parameters mismatched
00:BC83 4CE099          	  1918:   jmp  ERROR
                        	  1919: library_function_call_3:
00:BC86 2018B0          	  1920:   jsr  CHKRHP
00:BC89 8003            	  1921:   bra  library_function_call_5
                        	  1922: 
                        	  1923: ;
                        	  1924: ;  here for no arguments
                        	  1925: ;
                        	  1926: 
                        	  1927: library_function_call_1:
00:BC8B 204DD1          	  1928:   jsr  pas_get_token      ; one token look-ahead
                        	  1929: 
                        	  1930: library_function_call_5:
00:BC8E A004            	  1931:   ldy  #SYMDSP
00:BC90 B140            	  1932:   lda  (SYMITM),Y
00:BC92 852B            	  1933:   sta  OPND
00:BC94 C8              	  1934:   iny
00:BC95 B140            	  1935:   lda  (SYMITM),Y
00:BC97 852C            	  1936:   sta  OPND+1
00:BC99 A903            	  1937:   lda  #PCODE_LIB_CALL
00:BC9B 2028BD          	  1938:   jsr  GENJMP
00:BC9E 60              	  1939:   rts
                        	  1940: 
                        	  1941: 
                        	  1942: ;***********************************************
                        	  1943: ; GENERATE P-CODES - NO OPERANDS
                        	  1944: ;***********************************************
                        	  1945: GENNOP   =  *
00:BC9F A442            	  1946:          LDY  SYNTAX
00:BCA1 D011            	  1947:          BNE  GEN1      ; no storing/displaying if syntax-only compile
00:BCA3 9123            	  1948:          STA  (PCODE),Y
00:BCA5 48              	  1949:          PHA
00:BCA6 204094          	  1950:          JSR  DISPAD
00:BCA9 68              	  1951:          PLA
00:BCAA A62E            	  1952:          LDX  DCODE
00:BCAC F006            	  1953:          BEQ  GEN1
00:BCAE 203A94          	  1954:          JSR  DISHX
00:BCB1 202594          	  1955:          JSR  CROUT
                        	  1956: GEN1     =  *
00:BCB4 A901            	  1957:          LDA  #1      ; 1-byte P-code
00:BCB6 D035            	  1958:          BNE  GEN2_B
                        	  1959: ;***********************************************
                        	  1960: ; GENERATE P-CODES - WITH ADDRESS (3-bytes stored in DISPL (1)/OFFSET(2))
                        	  1961: ;***********************************************
                        	  1962: GENADR   =  *
00:BCB8 A442            	  1963:          LDY  SYNTAX
00:BCBA D02F            	  1964:          BNE  GEN2    ; no storing/displaying if syntax-only compile
00:BCBC 9123            	  1965:          STA  (PCODE),Y
00:BCBE 48              	  1966:          PHA
00:BCBF A527            	  1967:          LDA  DISPL
00:BCC1 C8              	  1968:          INY
00:BCC2 9123            	  1969:          STA  (PCODE),Y
00:BCC4 A529            	  1970:          LDA  OFFSET
00:BCC6 C8              	  1971:          INY
00:BCC7 9123            	  1972:          STA  (PCODE),Y
00:BCC9 A52A            	  1973:          LDA  OFFSET+1
00:BCCB C8              	  1974:          INY
00:BCCC 9123            	  1975:          STA  (PCODE),Y
00:BCCE 204094          	  1976:          JSR  DISPAD
00:BCD1 68              	  1977:          PLA
00:BCD2 A62E            	  1978:          LDX  DCODE
00:BCD4 F015            	  1979:          BEQ  GEN2
00:BCD6 203A94          	  1980:          JSR  DISHX
00:BCD9 A527            	  1981:          LDA  DISPL
00:BCDB 203A94          	  1982:          JSR  DISHX
00:BCDE A529            	  1983:          LDA  OFFSET
00:BCE0 203A94          	  1984:          JSR  DISHX
00:BCE3 A52A            	  1985:          LDA  OFFSET+1
00:BCE5 203A94          	  1986:          JSR  DISHX
00:BCE8 202594          	  1987:          JSR  CROUT
                        	  1988: GEN2     =  *
00:BCEB A904            	  1989:          LDA  #4      ; 4-byte P-code
                        	  1990: GEN2_B   =  *
00:BCED 18              	  1991:          CLC
00:BCEE 6523            	  1992:          ADC  PCODE
00:BCF0 8523            	  1993:          STA  PCODE
00:BCF2 9002            	  1994:          BCC  GEN2_A
00:BCF4 E624            	  1995:          INC  PCODE+1
                        	  1996: GEN2_A   =  *
00:BCF6 A542            	  1997:          LDA  SYNTAX
00:BCF8 D013            	  1998:          BNE  GEN2_C      ; no storing/displaying if syntax-only compile
00:BCFA A524            	  1999:          LDA  PCODE+1     ; see if P-codes full
00:BCFC C532            	  2000:          CMP  ENDSYM+1   ; in other words, have we hit the symbol table?
00:BCFE 900D            	  2001:          BCC  GEN2_C      ; less than
00:BD00 D006            	  2002:          BNE  GEN_FULL
00:BD02 A523            	  2003:          LDA  PCODE
00:BD04 C531            	  2004:          CMP  ENDSYM   ; TODO - what?
00:BD06 9005            	  2005:          BCC  GEN2_C
00:BD08 A201            	  2006: GEN_FULL LDX  #1         ; MEM FULL
00:BD0A 4CE099          	  2007:          jmp  ERROR
                        	  2008: GEN2_C   =  *
00:BD0D 60              	  2009: DISP9    RTS
                        	  2010: ;***********************************************
                        	  2011: ; GENERATE P-CODES - JUMP ADDRESS (relative to current P-code address in OPND)
                        	  2012: ;***********************************************
                        	  2013: GENRJMP  =  *
00:BD0E 48              	  2014:          PHA
00:BD0F A52B            	  2015:          LDA  OPND
00:BD11 38              	  2016:          SEC
00:BD12 E523            	  2017:          SBC  PCODE
00:BD14 852B            	  2018:          STA  OPND      ; subtract P-code address to find difference
00:BD16 A52C            	  2019:          LDA  OPND+1
00:BD18 E524            	  2020:          SBC  PCODE+1
00:BD1A 852C            	  2021:          STA  OPND+1
00:BD1C 68              	  2022:          PLA
00:BD1D 4C28BD          	  2023:          JMP  GENJMP
                        	  2024: ;
                        	  2025: GENNJP   =  *
00:BD20 A93C            	  2026:          LDA  #PCODE_JMP       ; JMP
                        	  2027: 
                        	  2028: ; Generate jump, P-code is in "A" register (eg. PCODE_JMZ, PCODE_JM1)
                        	  2029: ;
                        	  2030: ;  Note: the destination here is 0000, however FIXAD will be called later to fix up
                        	  2031: ;        the jump, once we know what the destination will be (ie. further down the code)
                        	  2032: ;
00:BD22 A200            	  2033: GENNJM   LDX  #0
00:BD24 862B            	  2034:          STX  OPND
00:BD26 862C            	  2035:          STX  OPND+1
                        	  2036: ;
                        	  2037: ;***********************************************
                        	  2038: ; GENERATE P-CODES - JUMP ADDRESS (absolute address in OPND)
                        	  2039: ;   also used in other places, like increment stack address
                        	  2040: ;***********************************************
                        	  2041: GENJMP   =  *
00:BD28 A442            	  2042:          LDY  SYNTAX
00:BD2A D025            	  2043:          BNE  GEN3     ; no storing/displaying if syntax-only compile
00:BD2C 9123            	  2044:          STA  (PCODE),Y
00:BD2E 48              	  2045:          PHA
00:BD2F A52B            	  2046:          LDA  OPND
00:BD31 C8              	  2047:          INY
00:BD32 9123            	  2048:          STA  (PCODE),Y
00:BD34 A52C            	  2049:          LDA  OPND+1
00:BD36 C8              	  2050:          INY
00:BD37 9123            	  2051:          STA  (PCODE),Y
00:BD39 204094          	  2052:          JSR  DISPAD
00:BD3C 68              	  2053:          PLA
00:BD3D A62E            	  2054:          LDX  DCODE
00:BD3F F010            	  2055:          BEQ  GEN3
00:BD41 203A94          	  2056:          JSR  DISHX
00:BD44 A52B            	  2057:          LDA  OPND
00:BD46 203A94          	  2058:          JSR  DISHX
00:BD49 A52C            	  2059:          LDA  OPND+1
00:BD4B 203A94          	  2060:          JSR  DISHX
00:BD4E 202594          	  2061:          JSR  CROUT
                        	  2062: GEN3     =  *
00:BD51 A903            	  2063:          LDA  #3        ; 3-byte P-code
00:BD53 4CEDBC          	  2064:          JMP  GEN2_B
                        	  2065: 
                        	  2066: ;***********************************************
                        	  2067: ; FIXUP ADDRESSES
                        	  2068: ;***********************************************
                        	  2069: FIXAD    =  *
00:BD56 A442            	  2070:          LDY  SYNTAX
00:BD58 D039            	  2071:          BNE  FIXAD1
00:BD5A A001            	  2072:          LDY  #1
00:BD5C A523            	  2073:          LDA  PCODE
00:BD5E 38              	  2074:          SEC
00:BD5F E537            	  2075:          SBC  WORK
00:BD61 9137            	  2076:          STA  (WORK),Y
00:BD63 C8              	  2077:          INY
00:BD64 A524            	  2078:          LDA  PCODE+1
00:BD66 E538            	  2079:          SBC  WORK+1
00:BD68 9137            	  2080:          STA  (WORK),Y
00:BD6A A52E            	  2081:          LDA  DCODE
00:BD6C F025            	  2082:          BEQ  FIXAD1
00:BD6E A994            	  2083:          LDA  #<FIXM1
00:BD70 A2BD            	  2084:          LDX  #>FIXM1
00:BD72 202682          	  2085:          JSR  print
00:BD75 A538            	  2086:          LDA  WORK+1
00:BD77 209A94          	  2087:          JSR  PRBYTE
00:BD7A A537            	  2088:          LDA  WORK
00:BD7C 203A94          	  2089:          JSR  DISHX
00:BD7F A99D            	  2090:          LDA  #<FIXM2
00:BD81 A2BD            	  2091:          LDX  #>FIXM2
00:BD83 202682          	  2092:          JSR  print
00:BD86 A524            	  2093:          LDA  PCODE+1
00:BD88 209A94          	  2094:          JSR  PRBYTE
00:BD8B A523            	  2095:          LDA  PCODE
00:BD8D 203A94          	  2096:          JSR  DISHX
00:BD90 4C2594          	  2097:          JMP  CROUT
00:BD93 60              	  2098: FIXAD1    rts
                        	  2099: 
00:BD94 4A756D7020617420	  2100: FIXM1    asciiz  'Jump at '
00:BD9C 00
00:BD9D 6368616E67656420	  2101: FIXM2    asciiz  'changed to '   ; changed to
00:BDA5 746F20
00:BDA8 00
                        	  2102: 
                        	  2103: 

Source: "gpascal.asm"
                        	   193:   .include "interpreter.inc"

Source: "interpreter.inc"
                        	     1: ;--------------------------------------------------
                        	     2: ; Runtime P-code interpreter
                        	     3: ;
                        	     4: ;--------------------------------------------------
                        	     5: 
                        	     6: 
                        	     7: ;--------------------------------
                        	     8: ; P-codes - these are generated in the compilation phase and looked up
                        	     9: ;           in execution_address_table at runtime
                        	    10: ;
                        	    11: ; Note: some P-codes must appear in sequence, eg. PCODE_STO and PCODE_STOC
                        	    12: ;       That is because one refers to integers (STO) and one refers to characters (STOC)
                        	    13: ;       The code in various places is virtually identical except it adds 1 to the P-code
                        	    14: ;       for characters. These generally are the Load/Store operations.
                        	    15: ;--------------------------------
                        	    16: 
                        	    17: ; Not implemented yet: $05, $13, $15, $39
                        	    18: 
                        	    19: ;                 Code            Description                         Arguments
                        	    20: ;                 ----            -----------------------------       -----------------------
                        	    21: PCODE_LIT     =   $00 ; Dec:  0 - Load constant                     - 3-byte literal (number)
                        	    22: PCODE_STACK   =   $01 ; Dec:  1 - Alter runtime stack to address    - 2-byte stack address
                        	    23: PCODE_NEG     =   $02 ; Dec:  2 - Unary minus 0 - (sp)              - none
                        	    24: PCODE_LIB_CALL =  $03 ; Dec:  3 - Call library function/procedure   - absolute address
                        	    25: PCODE_ADD     =   $04 ; Dec:  4 - Add (sp) to (sp - 1)              - none
                        	    26: PCODE_SUB     =   $06 ; Dec:  6 - Subtract (sp) from (sp - 1)       - none
                        	    27: PCODE_MUL     =   $08 ; Dec:  8 - Multiply (sp) * (sp - 1)          - none
                        	    28: PCODE_DIV     =   $0A ; Dec: 10 - Divide (sp - 1) / (sp)            - none
                        	    29: PCODE_MOD     =   $0B ; Dec: 11 - Modulus (sp - 1) MOD (sp)         - none
                        	    30: PCODE_ADRNN   =   $0C ; Dec: 12 - Address of integer                - level, displ
                        	    31: PCODE_ADRNC   =   $0D ; Dec: 13 - Address of character              - level, displ
                        	    32: PCODE_ADRAN   =   $0E ; Dec: 14 - Address of integer array          - level, displ
                        	    33: PCODE_ADRAC   =   $0F ; Dec: 15 - Address of character array        - level, displ
                        	    34: PCODE_EQL     =   $10 ; Dec: 16 - Test (sp - 1) == (sp)             - none
                        	    35: PCODE_FINISHD =   $11 ; Dec: 17 - Stop run (end program)            - none
                        	    36: PCODE_NEQ     =   $12 ; Dec: 18 - Test (sp - 1) != (sp)             - none
                        	    37: PCODE_LSS     =   $14 ; Dec: 20 - Test (sp - 1) < (sp)              - none
                        	    38: PCODE_GEQ     =   $16 ; Dec: 22 - Test (sp - 1) >= (sp)             - none
                        	    39: PCODE_GTR     =   $18 ; Dec: 24 - Test (sp - 1) > (sp)              - none
                        	    40: PCODE_LEQ     =   $19 ; Dec: 25 - Test (sp - 1) <= (sp)             - none
                        	    41: PCODE_ORR     =   $1A ; Dec: 26 - OR  (sp - 1) | (sp)               - none
                        	    42: PCODE_AND     =   $1B ; Dec: 27 - AND (sp - 1) & (sp)               - none
                        	    43: PCODE_INP     =   $1C ; Dec: 28 - Input number                      - none
                        	    44: PCODE_INPC    =   $1D ; Dec: 29 - Input character                   - none
                        	    45: PCODE_OUT     =   $1E ; Dec: 30 - Output number                     - none
                        	    46: PCODE_OUTC    =   $1F ; Dec: 31 - Output character                  - none
                        	    47: PCODE_EOR     =   $20 ; Dec: 32 - Not (sp) (logical negate)         - none
                        	    48: PCODE_OUH     =   $21 ; Dec: 33 - Output hex number                 - none
                        	    49: PCODE_SHL     =   $22 ; Dec: 34 - Shift left (sp) bits              - none
                        	    50: PCODE_OUS     =   $23 ; Dec: 35 - Output string                     - length, string
                        	    51: PCODE_SHR     =   $24 ; Dec: 36 - Shift right (sp) bits             - none
                        	    52: PCODE_INS     =   $25 ; Dec: 37 - Input string into array           - max, level, displ
                        	    53: PCODE_INC     =   $26 ; Dec: 38 - Increment (sp) by 1               - none
                        	    54: PCODE_CLL     =   $27 ; Dec: 39 - Relative procedure/function call  - level, relative address
                        	    55: PCODE_DEC     =   $28 ; Dec: 40 - Decrement (sp) by 1               - none
                        	    56: PCODE_RTN     =   $29 ; Dec: 41 - Procedure/function return         - none
                        	    57: PCODE_MOV     =   $2A ; Dec: 42 - Copy (sp) to (sp + 1)             - none
                        	    58: PCODE_CLA     =   $2B ; Dec: 43 - Call absolute address             - none
                        	    59: PCODE_LOD     =   $2C ; Dec: 44 - Load integer onto stack           - level, displ
                        	    60: PCODE_LODC    =   $2D ; Dec: 45 - Load character onto stack         - level, displ
                        	    61: PCODE_LDA     =   $2E ; Dec: 46 - Load absolute address integer     - none
                        	    62: PCODE_LDAC    =   $2F ; Dec: 47 - Load absolute address character   - none
                        	    63: PCODE_LDI     =   $30 ; Dec: 48 - Load integer indexed              - level, displ
                        	    64: PCODE_LDIC    =   $31 ; Dec: 49 - Load character indexed            - level, displ
                        	    65: PCODE_STO     =   $32 ; Dec: 50 - Store integer                     - level, displ
                        	    66: PCODE_STOC    =   $33 ; Dec: 51 - Store character                   - level, displ
                        	    67: PCODE_STA     =   $34 ; Dec: 52 - Store integer absolute address    - none
                        	    68: PCODE_STAC    =   $35 ; Dec: 53 - Store character absolute address  - none
                        	    69: PCODE_STI     =   $36 ; Dec: 54 - Store integer indexed             - level, displ
                        	    70: PCODE_STIC    =   $37 ; Dec: 55 - Store character indexed           - level, displ
                        	    71: PCODE_ABSCLL  =   $38 ; Dec: 56 - Absolute procedure/function call  - level, absolute address
                        	    72: PCODE_XOR     =   $3A ; Dec: 58 - XOR (sp - 1) ^ (sp)               - none
                        	    73: PCODE_INT     =   $3B ; Dec: 59 - Increment stack pointer           - increment
                        	    74: PCODE_JMP     =   $3C ; Dec: 60 - Jump unconditionally              - relative address
                        	    75: PCODE_JMZ     =   $3D ; Dec: 61 - Jump if (sp) zero                 - relative address
                        	    76: PCODE_JM1     =   $3E ; Dec: 62 - Jump if (sp) not zero             - relative address
                        	    77: PCODE_OUTCR   =   $40 ; Dec: 64 - Output a carriage-return          - none
                        	    78: PCODE_LCD_WRITE_NUM = $42 ; Dec: 66 - Write number to LCD           - none
                        	    79: PCODE_LCD_WRITE_STR = $43 ; Dec: 67 - Write string to LCD           - none
                        	    80: PCODE_LCD_WRITE_HEX = $44 ; Dec: 68 - Write hex number to LCD       - none
                        	    81: PCODE_LCD_WRITE_CHR = $45 ; Dec: 69 - Write character to LCD        - none
                        	    82: 
                        	    83: PCODE_LAST    =   PCODE_LCD_WRITE_CHR  ; PUT THIS LAST! (error check)                  -
                        	    84: 
                        	    85: ; 0x80 to 0xFF - Load low literal (onto stack), where literal is P-code with 8-bit clear (ie. P-code & 0x7F)
                        	    86: 
                        	    87: 
                        	    88: ;
                        	    89: ;  P-code execution routine lookup.
                        	    90: ;  For symbolic version see list above
                        	    91: ;
                        	    92: ;  Y is zero when starting to execute these routines
                        	    93: ;
                        	    94: execution_address_table  =  *
00:BDA9 63C0            	    95:   word  EX_LIT             ; $00 = LIT      Load constant
00:BDAB 57C4            	    96:   word  EX_NEW_STACK       ; $01 =          Change stack to addr
00:BDAD 75C0            	    97:   word  EX_NEG             ; $02 = NEG      Unary minus: 0 - (sp)
00:BDAF E3C5            	    98:   word  EX_LIB_CALL        ; $03 = LIB_CALL Library function call
00:BDB1 7EC0            	    99:   word  EX_ADD             ; $04 = ADD      Add (sp) to (sp - 1)
00:BDB3 91BF            	   100:   word  EX_INVINS          ; $05 =          NOT IMPLEMENTED
00:BDB5 87C0            	   101:   word  EX_SUB             ; $06 = SUB      Subtract (sp) from (sp - 1)
00:BDB7 91BF            	   102:   word  EX_INVINS          ; $07 =          NOT IMPLEMENTED
00:BDB9 93C0            	   103:   word  EX_MUL             ; $08 = MUL      Multiply (sp) * (sp - 1)
00:BDBB 91BF            	   104:   word  EX_INVINS          ; $09 =          NOT IMPLEMENTED
00:BDBD CEC0            	   105:   word  EX_DIV             ; $0A = DIV      Divide (sp - 1) / (sp)
00:BDBF A3C0            	   106:   word  EX_MOD             ; $0B = MOD      Modulus (sp - 1) MOD (sp)
00:BDC1 42C5            	   107:   word  EX_ADRNN           ; $0C = ADRNN    Address of integer
00:BDC3 32C5            	   108:   word  EX_ADRNC           ; $0D = ADRNC    Address of character
00:BDC5 50C5            	   109:   word  EX_ADRAN           ; $0E = ADRAN    Address of integer array
00:BDC7 56C5            	   110:   word  EX_ADRAC           ; $0F = ADRAC    Address of character array
00:BDC9 EBC0            	   111:   word  EX_EQL             ; $10 = EQL      Test (sp - 1) == (sp)
00:BDCB F895            	   112:   word  EX_FINISHD         ; $11 = FINISHD  Stop run (end program)
00:BDCD 05C1            	   113:   word  EX_NEQ             ; $12 = NEQ      Test (sp - 1) != (sp)
00:BDCF 91BF            	   114:   word  EX_INVINS          ; $13 =          NOT IMPLEMENTED
00:BDD1 0EC1            	   115:   word  EX_LSS             ; $14 = LSS      Test (sp - 1) < (sp)
00:BDD3 91BF            	   116:   word  EX_INVINS          ; $15 =          NOT IMPLEMENTED
00:BDD5 26C1            	   117:   word  EX_GEQ             ; $16 = GEQ      Test (sp - 1) >= (sp)
00:BDD7 91BF            	   118:   word  EX_INVINS          ; $17 =          NOT IMPLEMENTED
00:BDD9 1AC1            	   119:   word  EX_GTR             ; $18 = GTR      Test (sp - 1) > (sp)
00:BDDB 32C1            	   120:   word  EX_LEQ             ; $19 = LEQ      Test (sp - 1) <= (sp)
00:BDDD 47C1            	   121:   word  EX_ORR             ; $1A = ORR      OR  (sp - 1) | (sp)
00:BDDF 50C1            	   122:   word  EX_AND             ; $1B = AND      AND (sp - 1) & (sp)
00:BDE1 D0C2            	   123:   word  EX_INP             ; $1C = INP      Input number
00:BDE3 98C4            	   124:   word  EX_INPC            ; $1D = INPC     Input character
00:BDE5 10C3            	   125:   word  EX_OUT             ; $1E = OUT      Output number
00:BDE7 B2C4            	   126:   word  EX_OUTC            ; $1F = OUTC     Output character
00:BDE9 59C1            	   127:   word  EX_EOR             ; $20 = EOR      Not (sp) (logical negate)
00:BDEB 24C3            	   128:   word  EX_OUH             ; $21 = OUH      Output hex number
00:BDED 62C1            	   129:   word  EX_SHL             ; $22 = SHL      Shift left (sp) bits
00:BDEF 44C3            	   130:   word  EX_OUS             ; $23 = OUS      Output string
00:BDF1 6EC1            	   131:   word  EX_SHR             ; $24 = SHR      Shift right (sp) bits
00:BDF3 D4C4            	   132:   word  EX_INS             ; $25 = INS      Input string into array
00:BDF5 7AC1            	   133:   word  EX_INC             ; $26 = INC      Increment (sp) by 1
00:BDF7 7EC3            	   134:   word  EX_CLL             ; $27 = CLL      Relative procedure/function call
00:BDF9 92C1            	   135:   word  EX_DEC             ; $28 = DEC      Decrement (sp) by 1
00:BDFB 97C2            	   136:   word  EX_RTN             ; $29 = RTN      Procedure/function return
00:BDFD AAC1            	   137:   word  EX_MOV             ; $2A = MOV      Copy (sp) to (sp + 1)
00:BDFF 0DC4            	   138:   word  EX_CLA             ; $2B = CLA      Call absolute address
00:BE01 CDC1            	   139:   word  EX_LOD             ; $2C = LOD      Load integer onto stack
00:BE03 BBC1            	   140:   word  EX_LODC            ; $2D = LODC     Load character onto stack
00:BE05 EEC1            	   141:   word  EX_LDA             ; $2E = LDA      Load absolute address integer
00:BE07 E3C1            	   142:   word  EX_LDAC            ; $2F = LDAC     Load absolute address character
00:BE09 29C2            	   143:   word  EX_LDI             ; $30 = LDI      Load integer indexed
00:BE0B 23C2            	   144:   word  EX_LDIC            ; $31 = LDIC     Load character indexed
00:BE0D 3CC2            	   145:   word  EX_STO             ; $32 = STO      Store integer
00:BE0F 2FC2            	   146:   word  EX_STOC            ; $33 = STOC     Store character
00:BE11 4FC2            	   147:   word  EX_STA             ; $34 = STA      Store integer absolute address
00:BE13 65C2            	   148:   word  EX_STAC            ; $35 = STAC     Store character absolute address
00:BE15 7CC2            	   149:   word  EX_STI             ; $36 = STI      Store integer indexed
00:BE17 6EC2            	   150:   word  EX_STIC            ; $37 = STIC     Store character indexed
00:BE19 77C3            	   151:   word  EX_ABSCLL          ; $38 = ABSCLL   Absolute procedure/function call
00:BE1B 91BF            	   152:   word  EX_INVINS          ; $39 =          NOT IMPLEMENTED
00:BE1D 3EC1            	   153:   word  EX_XOR             ; $3A = XOR      XOR (sp - 1) ^ (sp)
00:BE1F 2DC4            	   154:   word  EX_INT             ; $3B = INT      Increment stack pointer
00:BE21 69C4            	   155:   word  EX_JMP             ; $3C = JMP      Jump unconditionally
00:BE23 7CC4            	   156:   word  EX_JMZ             ; $3D = JMZ      Jump if (sp) zero
00:BE25 8DC4            	   157:   word  EX_JM1             ; $3E = JM1      Jump if (sp) not zero
00:BE27 91BF            	   158:   word  EX_INVINS          ; $3F =          NOT IMPLEMENTED
00:BE29 3EBF            	   159:   word  EX_OUTCR           ; $40 = OUTCR    Output a carriage-return
00:BE2B 91BF            	   160:   word  EX_INVINS          ; $41 =          NOT IMPLEMENTED
00:BE2D 15C3            	   161:   word  EX_LCD_WRITE_NUM   ; $42 = LCD_WRITE_NUM  Write number to LCD
00:BE2F 49C3            	   162:   word  EX_LCD_WRITE_STR   ; $43 = LCD_WRITE_STR  Write string to LCD
00:BE31 29C3            	   163:   word  EX_LCD_WRITE_HEX   ; $44 = LCD_WRITE_HEX  Write hex to LCD
00:BE33 B7C4            	   164:   word  EX_LCD_WRITE_CHR   ; $45 = LCD_WRITE_CHR  Write character to LCD
                        	   165: 
                        	   166: ;--------------------------------------------------------------------------
                        	   167: ;
                        	   168: ;  STACK FRAMES
                        	   169: ;
                        	   170: ;  The compiler can't know where variables are actually going to be stored because
                        	   171: ;  they will be relative to the (interpreter) stack (not the processor stack) which
                        	   172: ;  is an unknown address because procedures/functions can be called directly or from
                        	   173: ;  other procedures/functions.
                        	   174: ;
                        	   175: ;  Hence variables are referenced to BASE which is the base of the current stack frame,
                        	   176: ;  thus a variable will be a certain offset from that. However in the case of nested
                        	   177: ;  calls we need to go back to a previous stack frame. That is what the 6-byte "stack
                        	   178: ;  frame linkage data" is about.
                        	   179: ;
                        	   180: ;  Variables are referred to by a "level difference" and a displacement. For the current
                        	   181: ;  procedure the level difference will be zero, and thus the variable will be BASE +
                        	   182: ;  the offset for this particular variable.
                        	   183: ;
                        	   184: ;  For variables in earlier procedures/functions (ones which called this one) there will
                        	   185: ;  be a level difference, being the depth (lexically) between the called function and the
                        	   186: ;  one with the variable. For example, if foo calls bar, and bar recurses five times, foo
                        	   187: ;  and bar are still only one level apart, from the point of view of accessing foo's
                        	   188: ;  variables.
                        	   189: ;
                        	   190: ;  Thus, to find an address we need to "walk" back through the STATIC stack frame links
                        	   191: ;  (bytes 5 and 6 of the stack frame data) to find the appropriate stack frame, and then
                        	   192: ;  take the offset from that.
                        	   193: ;
                        	   194: ;  However for recursive calls, once a recursed call ends, we need to get back the stack
                        	   195: ;  frame of the caller, which will be different from the static frame. So, to restore the
                        	   196: ;  stack frame after a procedure/function ends, we must take the DYNAMIC stack frame address
                        	   197: ;  (bytes 3 and 4 of the stack frame data) to get back the previous stack frame. In fact,
                        	   198: ;  all procedures/functions do this, it's just that the static and dynamic stack frames will
                        	   199: ;  be the same if the procedure/function does not recurse.
                        	   200: ;
                        	   201: ;  Finally, the return address (in the P-codes) for the procedure/function call is also
                        	   202: ;  stored in the stack frame data (bytes 1 and 2 of the stack frame data) so that, after
                        	   203: ;  doing a return, we can restore the P-code address to the PCODE variable after the call.
                        	   204: ;
                        	   205: ;  When a procedure/function is called these 6 bytes are pushed onto the stack. Then, for
                        	   206: ;  some reason, the code moves the stack pointer back 6 (adds to it). Then as part of the
                        	   207: ;  procedure/function initialisation the stack pointer has 6 or 9 added to it, to allow
                        	   208: ;  for not overwriting this stack frame data, and in the case of functions, the extra 3
                        	   209: ;  bytes are for the returned value.
                        	   210: ;
                        	   211: ;  Note that the stack grows downwards, as it starts at "high memory" (whatever that is
                        	   212: ;  defined as, and grows downwards, taking the gap between the end of the P-codes and the
                        	   213: ;  end of memory.
                        	   214: ;
                        	   215: ;  Then the function will add additional spaces to the stack (ie. by subtracting from the
                        	   216: ;  stack pointer) to make room for variables declared in that procedure/function. Now we
                        	   217: ;  are ready to push data onto the stack as part of normal expression evalution. It follows
                        	   218: ;  from this that variables initially have undefined values, as they will contain whatever
                        	   219: ;  happened to be in the stack when this space was allocated.
                        	   220: ;
                        	   221: ;  The function GETADR resolves these addresses by starting with BASE, the stack frame base
                        	   222: ;  for the current procedure/function, and then using the static stack frame link to load a
                        	   223: ;  (temporary) new base, and repeating that until the level difference is zero. Then it adds
                        	   224: ;  the offset of the wanted variable to the stack base to derive the actual variable address.
                        	   225: ;
                        	   226: ;--------------------------------------------------------------------------
                        	   227: 
                        	   228: 
                        	   229: ;
00:BE35 20537461636B3A20	   230: DM1               asciiz  ' Stack: '
00:BE3D 00
00:BE3E 20426173653A2020	   231: DM2               asciiz  ' Base:  '
00:BE46 00
                        	   232: 
                        	   233: ;
                        	   234: DEBUG    =  *
00:BE47 204094          	   235: DB11     jsr  DISPAD    ; display P-code address
00:BE4A A523            	   236:          lda  PCODE
00:BE4C 8537            	   237:          sta  WORK
00:BE4E A524            	   238:          lda  PCODE+1
00:BE50 8538            	   239:          sta  WORK+1
00:BE52 A204            	   240:          ldx  #4
00:BE54 20F6BE          	   241:          jsr  display_x_characters      ; display 4 bytes from WORK (ie. the P-codes)
00:BE57 202594          	   242:          jsr  CROUT
00:BE5A A649            	   243:          ldx  DBGFLG
00:BE5C 3051            	   244:          bmi  DEBUG_DONE        ; trace only
00:BE5E A935            	   245:          lda  #<DM1             ; ' Stack: '
00:BE60 A2BE            	   246:          ldx  #>DM1
00:BE62 202682          	   247:          jsr  print
00:BE65 A532            	   248:          lda  T+1
00:BE67 209A94          	   249:          jsr  PRBYTE        ; display the stack pointer address
00:BE6A A531            	   250:          lda  T
00:BE6C 203A94          	   251:          jsr  DISHX         ; display hex and a space after
00:BE6F A93D            	   252:          lda  #'='
00:BE71 20B395          	   253:          jsr  COUT
00:BE74 A531            	   254:          lda  T
00:BE76 8537            	   255:          sta  WORK
00:BE78 A532            	   256:          lda  T+1
00:BE7A 8538            	   257:          sta  WORK+1
00:BE7C A209            	   258:          ldx  #9         ; show 9 bytes on stack, namely 3 variables
00:BE7E 20F6BE          	   259:          jsr  display_x_characters
00:BE81 202594          	   260:          jsr  CROUT
00:BE84 A93E            	   261:          lda  #<DM2       ; ' Base:  '
00:BE86 A2BE            	   262:          ldx  #>DM2
00:BE88 202682          	   263:          jsr  print
00:BE8B A53C            	   264:          lda  BASE+1
00:BE8D 209A94          	   265:          jsr  PRBYTE      ; display the base pointer address
00:BE90 A53B            	   266:          lda  BASE
00:BE92 203A94          	   267:          jsr  DISHX
00:BE95 A93D            	   268:          lda  #'='
00:BE97 20B395          	   269:          jsr  COUT
00:BE9A A53B            	   270:          lda  BASE
00:BE9C 38              	   271:          sec
00:BE9D E906            	   272:          sbc  #6    ; the linkage data is 6 bytes below the base
00:BE9F 8537            	   273:          sta  WORK
00:BEA1 A53C            	   274:          lda  BASE+1
00:BEA3 E900            	   275:          sbc  #0
00:BEA5 8538            	   276:          sta  WORK+1
00:BEA7 A206            	   277:          ldx  #6    ; show 6 bytes of base linkage data (return, dynamic link, static link)
00:BEA9 20F6BE          	   278:          jsr  display_x_characters
00:BEAC 4C2594          	   279:          jmp  CROUT
                        	   280: 
00:BEAF 60              	   281: DEBUG_DONE rts
                        	   282: 
                        	   283: 
                        	   284: ;***********************************************
                        	   285: ; Interpreter initialization
                        	   286: ;***********************************************
                        	   287: 
                        	   288: INTERP   =  *
00:BEB0 08              	   289:   php
00:BEB1 68              	   290:   pla
00:BEB2 8513            	   291:   sta  call_p   ; make sure call_p has some reasonable value in it
                        	   292: ;
                        	   293: ;  Move the start of where the P-codes start into PCODE (our first P-code)
                        	   294: ;
00:BEB4 A525            	   295:   lda  ACT_PCDA
00:BEB6 8523            	   296:   sta  PCODE
00:BEB8 A526            	   297:   lda  ACT_PCDA+1
00:BEBA 8524            	   298:   sta  PCODE+1
                        	   299: ;
                        	   300: ;  Running message
                        	   301: ;
00:BEBC A940            	   302:   lda  #<running_message   ; Running
00:BEBE A2DC            	   303:   ldx  #>running_message
00:BEC0 202682          	   304:   jsr  print
                        	   305: ;
                        	   306: ;  Running flag
                        	   307: ;
00:BEC3 A00C            	   308:   ldy  #$0C
00:BEC5 843F            	   309:   sty  RUNNING
                        	   310: ;
                        	   311: ;  Set up the runtime stack pointer which is also our first stack frame base
                        	   312: ;
00:BEC7 A9FF            	   313:   lda  #<HIGHEST_RAM
00:BEC9 8531            	   314:   sta  T
00:BECB 853B            	   315:   sta  BASE
00:BECD A93F            	   316:   lda  #>HIGHEST_RAM
00:BECF 8532            	   317:   sta  T+1
00:BED1 853C            	   318:   sta  BASE+1
                        	   319: 
00:BED3 4C53BF          	   320:   jmp  MAIN ; start interpreting
                        	   321: ;
                        	   322: ;
                        	   323: ;
                        	   324: 
                        	   325: 
                        	   326: ;***********************************************
                        	   327: ;  INTERPRETER
                        	   328: ;***********************************************
                        	   329: 
                        	   330: ;
                        	   331: ;
00:BED6 496C6C6567616C20	   332: DM5      asciiz  "Illegal instruction\n"
00:BEDE 696E737472756374
00:BEE6 696F6E0A
00:BEEA 00
00:BEEB 427265616B202E2E	   333: DM6      asciiz  'Break ...\n'
00:BEF3 2E0A
00:BEF5 00
                        	   334: 
                        	   335: ;
                        	   336: ; DISPLAY (X) CHARACTERS FROM (WORK)
                        	   337: ;
                        	   338: display_x_characters:
00:BEF6 8A              	   339:          txa
00:BEF7 48              	   340:          pha
00:BEF8 20B094          	   341:          jsr  PUTSP
00:BEFB 68              	   342:          pla
00:BEFC AA              	   343:          tax
00:BEFD A000            	   344: DIS5     ldy  #0
00:BEFF B137            	   345:          lda  (WORK),Y
00:BF01 E637            	   346:          inc  WORK
00:BF03 D002            	   347:          bne  DIS5_A
00:BF05 E638            	   348:          inc  WORK+1
                        	   349: DIS5_A   =  *
00:BF07 A8              	   350:          tay
00:BF08 8A              	   351:          txa
00:BF09 48              	   352:          pha
00:BF0A 98              	   353:          tya
00:BF0B 203A94          	   354:          jsr  DISHX
00:BF0E 68              	   355:          pla
00:BF0F AA              	   356:          tax
00:BF10 CA              	   357:          dex
00:BF11 D0EA            	   358:          bne  DIS5
00:BF13 60              	   359:          rts
                        	   360: 
                        	   361: ;
                        	   362: ;
                        	   363: CHK_KBD  =  *
00:BF14 C90E            	   364:          cmp  #KEY_STOP_TRACE       ; Ctrl+N - stop tracing
00:BF16 D008            	   365:          bne  CHK_NOTN
00:BF18 648B            	   366:          stz  serial_in_byte_received
00:BF1A A900            	   367:          lda  #0
00:BF1C 8549            	   368:          sta  DBGFLG
00:BF1E 38              	   369:          sec
00:BF1F 60              	   370:          rts
00:BF20 C914            	   371: CHK_NOTN cmp  #KEY_TRACE      ; Ctrl+T - start tracing
00:BF22 D00A            	   372:          bne  CHK_NOTT
00:BF24 648B            	   373:          stz  serial_in_byte_received
00:BF26 A980            	   374:          lda  #$80
00:BF28 8549            	   375:          sta  DBGFLG
00:BF2A 852E            	   376:          sta  DCODE
00:BF2C 38              	   377:          sec
00:BF2D 60              	   378:          rts
00:BF2E C904            	   379: CHK_NOTT cmp  #KEY_DEBUG      ; Ctrl+D - start debugging
00:BF30 D00A            	   380:          bne  CHK_NOTD
00:BF32 648B            	   381:          stz  serial_in_byte_received
00:BF34 A901            	   382:          lda  #1
00:BF36 8549            	   383:          sta  DBGFLG
00:BF38 852E            	   384:          sta  DCODE
00:BF3A 38              	   385:          sec
00:BF3B 60              	   386:          rts
00:BF3C 18              	   387: CHK_NOTD clc
00:BF3D 60              	   388:          rts
                        	   389: ;
                        	   390: EX_OUTCR    =  *
00:BF3E 202594          	   391:   jsr  CROUT      ; OUTPUT C/R
00:BF41 4C53BF          	   392:   jmp  MAIN
                        	   393: ;
                        	   394: ;  Here for a "low literal" - a P-code with the 0x80 bit set. Clear that bit and push
                        	   395: ;   the resulting number onto the stack
                        	   396: ;
                        	   397: LOWLIT:
00:BF44 E623            	   398:   inc  PCODE     ; increment P-code past the low literal
00:BF46 D002            	   399:   bne  LOWLIT1
00:BF48 E624            	   400:   inc  PCODE+1
                        	   401: LOWLIT1:
00:BF4A 8401            	   402:   sty  REG+1     ; Y and REGB were cleared below
00:BF4C 297F            	   403:   and  #$7F
00:BF4E 8500            	   404:   sta  REG
                        	   405: ;
                        	   406: ;  fall down to push this value
                        	   407: ;
                        	   408: 
                        	   409: 
                        	   410: ;
                        	   411: ; Push previous result (REG) and then drop down to do the next instruction
                        	   412: ;
                        	   413: MAINP:
00:BF50 2030C0          	   414:  jsr  PSHTOP    ; push REG onto stack and go back to MAIN
                        	   415: 
                        	   416: ;
                        	   417: ;  Main interpreter loop - each instruction jumps back here (or to MAINP above if it
                        	   418: ;              needs to push a previous calculation result)
                        	   419: ;
                        	   420: MAIN:
00:BF53 A549            	   421:   lda  DBGFLG   ; debugging?
00:BF55 F003            	   422:   beq  MAIN_2   ; no
00:BF57 2047BE          	   423:   jsr  DEBUG    ; yes - show debug info
                        	   424: MAIN_2   =  *
                        	   425: ; check if key pressed here, to abort, or turn on/off tracing or debugging
00:BF5A A58B            	   426:   lda  serial_in_byte_received
00:BF5C F00A            	   427:   beq  MAIN_OK
00:BF5E C903            	   428:   cmp  #KEY_ABORT
00:BF60 D003            	   429:   bne  MAIN_NOT_ABORT
00:BF62 4CF895          	   430:   jmp  EX_FINISHD
                        	   431: MAIN_NOT_ABORT = *
00:BF65 2014BF          	   432:   jsr  CHK_KBD          ; check for turning on trace, debug, etc.
                        	   433: MAIN_OK  =  *
00:BF68 A523            	   434:   lda  PCODE             ; save P-code address as LASTP (for errors I presume)
00:BF6A 854D            	   435:   sta  LASTP
00:BF6C A524            	   436:   lda  PCODE+1
00:BF6E 854E            	   437:   sta  LASTP+1
                        	   438: ;
                        	   439: ;  now grab the P-code
                        	   440: ;
00:BF70 A000            	   441:   ldy  #0
00:BF72 8402            	   442:   sty  REGB
00:BF74 B123            	   443:   lda  (PCODE),Y         ; get the P-code from the P-codes
00:BF76 30CC            	   444:   bmi  LOWLIT            ; low literal - just handle it
00:BF78 C946            	   445:   cmp  #PCODE_LAST+1
00:BF7A B015            	   446:   bcs  EX_INVINS         ; error if off end of table
                        	   447: ;
                        	   448: ;  increment past this P-code
                        	   449: ;
                        	   450: MAIN_5   =  *
00:BF7C E623            	   451:   inc  PCODE
00:BF7E D002            	   452:   bne  MAIN_1
00:BF80 E624            	   453:   inc  PCODE+1
                        	   454: ;
                        	   455: ;  grab the execution handler from the execution_address_table
                        	   456: ;
                        	   457: MAIN_1   =  *
00:BF82 0A              	   458:   asl  A             ; double the P-code because each address takes 2 bytes
00:BF83 AA              	   459:   tax
00:BF84 BDA9BD          	   460:   lda  execution_address_table,X      ; otherwise get the execution address
00:BF87 8537            	   461:   sta  WORK
00:BF89 BDAABD          	   462:   lda  execution_address_table+1,X    ; and the high-order byte
00:BF8C 8538            	   463:   sta  WORK+1
00:BF8E 6C3700          	   464:   jmp  (WORK)        ; execute the appropriate P-code implementation routine
                        	   465: 
                        	   466: ;
                        	   467: NOTIMP   =  *
                        	   468: EX_INVINS   =  *
00:BF91 A9D6            	   469:          LDA  #<DM5   ; Illegal Instruction
00:BF93 A2BE            	   470:          LDX  #>DM5
                        	   471: NOTIM1   =  *
00:BF95 202682          	   472:          JSR  print
00:BF98 4CE495          	   473:          JMP  RUNERR
                        	   474: ;
                        	   475: BREAK    =  *
00:BF9B A9EB            	   476:          LDA  #<DM6  ; Break ...
00:BF9D A2BE            	   477:          LDX  #>DM6
00:BF9F 4C95BF          	   478:          JMP  NOTIM1
                        	   479: 
                        	   480: 
00:BFA2 A000            	   481: GETADR   LDY  #0
00:BFA4 B123            	   482:          LDA  (PCODE),Y     ; level
00:BFA6 854B            	   483:          STA  COUNT1        ; count of levels to work through
00:BFA8 A53C            	   484:          LDA  BASE+1        ; start with our stack base address
00:BFAA A63B            	   485:          LDX  BASE
                        	   486: GET2     =  *
00:BFAC 853E            	   487:          STA  DATA+1        ; our data is relative to the stack base
00:BFAE 863D            	   488:          STX  DATA
00:BFB0 A8              	   489:          TAY
00:BFB1 A54B            	   490:          LDA  COUNT1        ; any levels left?
00:BFB3 F018            	   491:          BEQ  GETADR1       ; no, we can continue
00:BFB5 38              	   492:          SEC                ; yes
00:BFB6 8A              	   493:          TXA                ; subtract 2 from the base to get the static link
00:BFB7 E902            	   494:          SBC  #2
00:BFB9 8537            	   495:          STA  WORK
00:BFBB 98              	   496:          TYA
00:BFBC E900            	   497:          SBC  #0
00:BFBE 8538            	   498:          STA  WORK+1        ; BASE - 2 -> WORK
00:BFC0 A000            	   499:          LDY  #0
00:BFC2 B137            	   500:          LDA  (WORK),Y      ; grab contents of BASE-2
00:BFC4 C8              	   501:          INY
00:BFC5 AA              	   502:          TAX
00:BFC6 B137            	   503:          LDA  (WORK),Y
00:BFC8 C64B            	   504:          DEC  COUNT1        ; one less level
00:BFCA 4CACBF          	   505:          JMP  GET2          ; keep going until we used all levels
                        	   506: 
                        	   507: GETADR1     =  *
00:BFCD A001            	   508:          LDY  #1            ; now get the offset
00:BFCF 18              	   509:          CLC
00:BFD0 B123            	   510:          LDA  (PCODE),Y     ; offset low-order byte
00:BFD2 653D            	   511:          ADC  DATA          ; add base
00:BFD4 853D            	   512:          STA  DATA
00:BFD6 C8              	   513:          INY
00:BFD7 B123            	   514:          LDA  (PCODE),Y     ; offset high-order byte
00:BFD9 653E            	   515:          ADC  DATA+1        ; add base
00:BFDB 853E            	   516:          STA  DATA+1        ; DATA now holds the data address
00:BFDD A523            	   517:          LDA  PCODE         ; add 3 to PCODE to skip level and offset
00:BFDF 18              	   518:          CLC
00:BFE0 6903            	   519:          ADC  #3
00:BFE2 8523            	   520:          STA  PCODE
00:BFE4 9002            	   521:          BCC  GET1_A
00:BFE6 E624            	   522:          INC  PCODE+1
                        	   523: GET1_A   =  *
00:BFE8 60              	   524:          RTS                ; done - we can use DATA to access whatever-it-is
                        	   525: 
                        	   526: ;
                        	   527: ;  Pull the top item on the runtime stack into REG (aka VALUE)
                        	   528: ;
                        	   529: PULTOP   =  *
00:BFE9 A000            	   530:          LDY  #0
00:BFEB B131            	   531:          LDA  (T),Y
00:BFED 8500            	   532:          STA  REG
00:BFEF C8              	   533:          INY
00:BFF0 B131            	   534:          LDA  (T),Y
00:BFF2 8501            	   535:          STA  REG+1
00:BFF4 C8              	   536:          INY
00:BFF5 B131            	   537:          LDA  (T),Y
00:BFF7 8502            	   538:          STA  REGB
00:BFF9 A531            	   539:          LDA  T
00:BFFB 18              	   540:          CLC      ; add 3 to the stack because we removed one integer from it
00:BFFC 6903            	   541:          ADC  #3
00:BFFE 8531            	   542:          STA  T
00:C000 9002            	   543:          BCC  PUL_END
00:C002 E632            	   544:          INC  T+1
                        	   545: PUL_END  =  *
00:C004 A500            	   546:          LDA  REG
00:C006 A601            	   547:          LDX  REG+1
00:C008 A402            	   548:          LDY  REGB
00:C00A 60              	   549:          RTS
                        	   550: 
00:C00B 20E9BF          	   551: PULBOTH  JSR  PULTOP     ; Pulls both of them - do one and then fall through to do the other
                        	   552: 
                        	   553: ;
                        	   554: ;  Pull the top item on the runtime stack into REG2 (aka VALUE2)
                        	   555: ;
                        	   556: PULTOP2  =  *
00:C00E A000            	   557:          LDY  #0
00:C010 B131            	   558:          LDA  (T),Y
00:C012 8503            	   559:          STA  REG2
00:C014 C8              	   560:          INY
00:C015 B131            	   561:          LDA  (T),Y
00:C017 8504            	   562:          STA  REG2+1
00:C019 C8              	   563:          INY
00:C01A B131            	   564:          LDA  (T),Y
00:C01C 8505            	   565:          STA  REG2B
00:C01E A531            	   566:          LDA  T
00:C020 18              	   567:          CLC         ; add 3 to the stack because we removed one integer from it
00:C021 6903            	   568:          ADC  #3
00:C023 8531            	   569:          STA  T
00:C025 9002            	   570:          BCC  PUL2_END
00:C027 E632            	   571:          INC  T+1
                        	   572: PUL2_END =  *
00:C029 A503            	   573:          LDA  REG2
00:C02B A604            	   574:          LDX  REG2+1
00:C02D A405            	   575:          LDY  REG2B
00:C02F 60              	   576:          RTS
                        	   577: 
                        	   578: ;
                        	   579: ;  Push REG (aka VALUE) onto the runtime stack
                        	   580: ;
                        	   581: PSHTOP   =  *
00:C030 38              	   582:          SEC        ;  subtract 3 from the stack because we are about to add one integer to it
00:C031 A531            	   583:          LDA  T
00:C033 E903            	   584:          SBC  #3
00:C035 8531            	   585:          STA  T
00:C037 B002            	   586:          BCS  PSH1
00:C039 C632            	   587:          DEC  T+1
                        	   588: PSH1     =  *
00:C03B A000            	   589:          LDY  #0
00:C03D A500            	   590:          LDA  REG
00:C03F 9131            	   591:          STA  (T),Y
00:C041 C8              	   592:          INY
00:C042 A501            	   593:          LDA  REG+1
00:C044 9131            	   594:          STA  (T),Y
00:C046 C8              	   595:          INY
00:C047 A502            	   596:          LDA  REGB
00:C049 9131            	   597:          STA  (T),Y
00:C04B 60              	   598:          RTS
                        	   599: ;
                        	   600: ;  get a literal (2 bytes) from the P-codes and put it into REG
                        	   601: ;
                        	   602: GETLIT   =  *
00:C04C A000            	   603:   ldy  #0
00:C04E B123            	   604:   lda  (PCODE),Y
00:C050 8500            	   605:   sta  REG
00:C052 C8              	   606:   iny
00:C053 B123            	   607:   lda  (PCODE),Y
00:C055 8501            	   608:   sta  REG+1
00:C057 A523            	   609:   lda  PCODE
00:C059 18              	   610:   clc         ; P-code address goes up by 2
00:C05A 6902            	   611:   adc  #2
00:C05C 8523            	   612:   sta  PCODE
00:C05E 9002            	   613:   bcc  GET_END
00:C060 E624            	   614:   inc  PCODE+1
                        	   615: GET_END:
00:C062 60              	   616:   rts
                        	   617: ;
                        	   618: ; load literal onto the stack (the literal is the next 3 bytes after the P-code)
                        	   619: ;
                        	   620: EX_LIT:
00:C063 204CC0          	   621:   jsr  GETLIT   ; get the first 2 bytes
00:C066 A000            	   622:   ldy  #0
00:C068 B123            	   623:   lda  (PCODE),Y    ; now the third byte
00:C06A 8502            	   624:   sta  REGB
00:C06C E623            	   625:   inc  PCODE
00:C06E D002            	   626:   bne  LIT1
00:C070 E624            	   627:   inc  PCODE+1
                        	   628: LIT1:
00:C072 4C50BF          	   629:   jmp  MAINP    ; now we can push it
                        	   630: ;
                        	   631: ;  Negate (0 - (sp) )
                        	   632: ;
                        	   633: EX_NEG:
00:C075 20E9BF          	   634:   jsr PULTOP
00:C078 2090AE          	   635:   jsr exp_unary_minus
00:C07B 4C50BF          	   636:   jmp MAINP
                        	   637: ;
                        	   638: ;  Add (sp) to (sp -1)
                        	   639: ;
                        	   640: EX_ADD:
00:C07E 200BC0          	   641:   JSR  PULBOTH
00:C081 2049AD          	   642:   jsr  exp_add
00:C084 4C50BF          	   643:   JMP  MAINP
                        	   644: ;
                        	   645: ;
                        	   646: ;  Add (sp) from (sp - 1)
                        	   647: ;
                        	   648: EX_SUB:
00:C087 200EC0          	   649:   JSR  PULTOP2
00:C08A 20E9BF          	   650:   jsr  PULTOP
00:C08D 205DAD          	   651:   jsr  exp_subtract
00:C090 4C50BF          	   652:   JMP  MAINP
                        	   653: ;
                        	   654: ;  Multiply (sp) by (sp - 1)
                        	   655: ;
                        	   656: EX_MUL:
00:C093 200BC0          	   657:   jsr PULBOTH
00:C096 2017AF          	   658:   jsr exp_multiply
00:C099 4C50BF          	   659:   jmp MAINP
                        	   660: 
                        	   661: ;
                        	   662: ;  we will take the current key (and return to the user)
                        	   663: ;  and zero it out anyway, so that consumes the key
                        	   664: ;
                        	   665: EX_GETKEY   =  *
00:C09C A58B            	   666:   lda  serial_in_byte_received
00:C09E 648B            	   667:   stz  serial_in_byte_received
00:C0A0 4CF6C0          	   668:   jmp  TRUE2
                        	   669: ;
                        	   670: ;  Modulus (remainder)
                        	   671: ;
                        	   672: EX_MOD:
00:C0A3 200EC0          	   673:   jsr PULTOP2
                        	   674: ;
                        	   675: ;  check for divide by zero because I want a run-time error message
                        	   676: ;
00:C0A6 A503            	   677:   lda VALUE2
00:C0A8 0504            	   678:   ora VALUE2+1
00:C0AA 0505            	   679:   ora VALUE2+2
00:C0AC F009            	   680:   beq EX_DIVIDE_BY_ZERO
00:C0AE 20E9BF          	   681:   jsr PULTOP
00:C0B1 20B0AF          	   682:   jsr exp_modulo
00:C0B4 4C50BF          	   683:   jmp MAINP
                        	   684: ;
                        	   685: 
                        	   686: EX_DIVIDE_BY_ZERO:
00:C0B7 A9BE            	   687:   lda  #<DIVBY0
00:C0B9 A2C0            	   688:   ldx  #>DIVBY0
00:C0BB 4C95BF          	   689:   jmp  NOTIM1
                        	   690: 
00:C0BE 4469766964652062	   691: DIVBY0   asciiz  'Divide by zero\n'
00:C0C6 79207A65726F0A
00:C0CD 00
                        	   692: ;
                        	   693: ;  Divide (sp - 1) by (sp)
                        	   694: ;
                        	   695: EX_DIV:
00:C0CE 200EC0          	   696:   jsr PULTOP2
00:C0D1 A503            	   697:   lda VALUE2
00:C0D3 0504            	   698:   ora VALUE2+1
00:C0D5 0505            	   699:   ora VALUE2+2
00:C0D7 F0DE            	   700:   beq EX_DIVIDE_BY_ZERO
00:C0D9 20E9BF          	   701:   jsr PULTOP
00:C0DC 2050AF          	   702:   jsr exp_divide
00:C0DF 4C50BF          	   703:   jmp MAINP
                        	   704: 
                        	   705: ;
                        	   706: ;  Absolute value of (sp)
                        	   707: ;
                        	   708: EX_ABS:
00:C0E2 20E9BF          	   709:   jsr  PULTOP
00:C0E5 20B2AE          	   710:   jsr exp_abs_val
00:C0E8 4C50BF          	   711:   jmp  MAINP
                        	   712: 
                        	   713: ; Equal
                        	   714: ;
                        	   715: EX_EQL:
00:C0EB 200BC0          	   716:   jsr PULBOTH
00:C0EE 2083AD          	   717:   jsr exp_eql
00:C0F1 4C50BF          	   718:   jmp MAINP
                        	   719: 
                        	   720: ;
                        	   721: ;  Push 1
                        	   722: ;
                        	   723: TRUE:
00:C0F4 A901            	   724:   lda  #1
                        	   725: ;
                        	   726: ;  Push A into low-order byte, zero other two bytes
                        	   727: ;
                        	   728: TRUE2:
00:C0F6 8500            	   729:   sta  REG
00:C0F8 A900            	   730:   lda  #0
00:C0FA 8501            	   731:   sta  REG+1
00:C0FC 8502            	   732:   sta  REGB
00:C0FE 4C50BF          	   733:   jmp  MAINP
                        	   734: 
                        	   735: ;
                        	   736: ;  Push 0
                        	   737: ;
                        	   738: FALSE:
00:C101 A900            	   739:   lda  #0
00:C103 80F1            	   740:   bra TRUE2
                        	   741: ;
                        	   742: ;  Not equal
                        	   743: ;
                        	   744: EX_NEQ:
00:C105 200BC0          	   745:     jsr PULBOTH
00:C108 2097AD          	   746:     jsr exp_neq
00:C10B 4C50BF          	   747:     jmp MAINP
                        	   748: 
                        	   749: ;
                        	   750: ;  Less than
                        	   751: ;
                        	   752: EX_LSS:
00:C10E 200EC0          	   753:   jsr PULTOP2
00:C111 20E9BF          	   754:   jsr PULTOP
00:C114 20ABAD          	   755:   jsr exp_less_than
00:C117 4C50BF          	   756:   jmp MAINP
                        	   757: 
                        	   758: ;
                        	   759: ;  Greater than
                        	   760: ;
                        	   761: EX_GTR:
00:C11A 200EC0          	   762:   jsr PULTOP2
00:C11D 20E9BF          	   763:   jsr PULTOP
00:C120 20B2AD          	   764:   jsr exp_greater_than
00:C123 4C50BF          	   765:   jmp MAINP
                        	   766: 
                        	   767: ;
                        	   768: ;  Greater than or equal
                        	   769: ;
                        	   770: EX_GEQ:
00:C126 200EC0          	   771:   jsr PULTOP2
00:C129 20E9BF          	   772:   jsr PULTOP
00:C12C 20D0AD          	   773:   jsr exp_geq
00:C12F 4C50BF          	   774:   jmp MAINP
                        	   775: 
                        	   776: ;
                        	   777: ;  Less than or equal
                        	   778: ;
                        	   779: EX_LEQ:
00:C132 200EC0          	   780:   jsr PULTOP2
00:C135 20E9BF          	   781:   jsr PULTOP
00:C138 20C1AD          	   782:   jsr exp_leq
00:C13B 4C50BF          	   783:   jmp MAINP
                        	   784: 
                        	   785: ;
                        	   786: ;  Exclusive OR
                        	   787: ;
                        	   788: EX_XOR:
00:C13E 200BC0          	   789:   jsr PULBOTH
00:C141 2001AE          	   790:   jsr exp_bitwise_xor
00:C144 4C50BF          	   791:   jmp MAINP
                        	   792: ;
                        	   793: ;  Or
                        	   794: ;
                        	   795: EX_ORR:
00:C147 200BC0          	   796:   jsr PULBOTH
00:C14A 20D7AD          	   797:   jsr exp_bitwise_or
00:C14D 4C50BF          	   798:   jmp MAINP
                        	   799: 
                        	   800: ;
                        	   801: ;  And
                        	   802: ;
                        	   803: EX_AND:
00:C150 200BC0          	   804:   jsr  PULBOTH
00:C153 20ECAD          	   805:   jsr exp_bitwise_and
00:C156 4C50BF          	   806:   jmp MAINP
                        	   807: 
                        	   808: ;
                        	   809: ;  Not
                        	   810: ;
                        	   811: EX_EOR:
00:C159 20E9BF          	   812:   jsr PULTOP
00:C15C 2082AE          	   813:   jsr exp_not
00:C15F 4C50BF          	   814:   jmp MAINP
                        	   815: ;
                        	   816: ; Shift left
                        	   817: ;
                        	   818: EX_SHL:
00:C162 200EC0          	   819:   jsr PULTOP2
00:C165 20E9BF          	   820:   jsr PULTOP
00:C168 203DAE          	   821:   jsr exp_shift_left
00:C16B 4C50BF          	   822:   jmp MAINP
                        	   823: 
                        	   824: ;
                        	   825: ;  Shift right
                        	   826: ;
                        	   827: EX_SHR:
00:C16E 200EC0          	   828:   jsr PULTOP2
00:C171 20E9BF          	   829:   jsr PULTOP
00:C174 2056AE          	   830:   jsr exp_shift_right
00:C177 4C50BF          	   831:   jmp MAINP
                        	   832: 
                        	   833: ;
                        	   834: ;  increment number on top of stack by one
                        	   835: ;
                        	   836: EX_INC:
00:C17A 18              	   837:   clc
00:C17B B131            	   838:   lda  (T),Y
00:C17D 6901            	   839:   adc  #1
00:C17F 9131            	   840:   sta  (T),Y
00:C181 C8              	   841:   iny
00:C182 B131            	   842:   lda  (T),Y
00:C184 6900            	   843:   adc  #0
00:C186 9131            	   844:   sta  (T),Y
00:C188 C8              	   845:   iny
00:C189 B131            	   846:   lda  (T),Y
00:C18B 6900            	   847:   adc  #0
00:C18D 9131            	   848:   sta  (T),Y
00:C18F 4C53BF          	   849:   jmp  MAIN
                        	   850: ;
                        	   851: ;  decrement number on top of stack by one
                        	   852: ;
                        	   853: 
                        	   854: EX_DEC:
00:C192 38              	   855:   sec
00:C193 B131            	   856:   lda  (T),Y
00:C195 E901            	   857:   sbc  #1
00:C197 9131            	   858:   sta  (T),Y
00:C199 C8              	   859:   iny
00:C19A B131            	   860:   lda  (T),Y
00:C19C E900            	   861:   sbc  #0
00:C19E 9131            	   862:   sta  (T),Y
00:C1A0 C8              	   863:   iny
00:C1A1 B131            	   864:   lda  (T),Y
00:C1A3 E900            	   865:   sbc  #0
00:C1A5 9131            	   866:   sta  (T),Y
00:C1A7 4C53BF          	   867:   jmp  MAIN
                        	   868: 
                        	   869: ;
                        	   870: ;  Copy (sp) to (sp + 1)
                        	   871: ;
                        	   872: EX_MOV:
00:C1AA B131            	   873:   lda  (T),Y  ; get item at top of stack
00:C1AC 8500            	   874:   sta REG
00:C1AE C8              	   875:   iny
00:C1AF B131            	   876:   lda  (T),Y
00:C1B1 8501            	   877:   sta REG+1
00:C1B3 C8              	   878:   iny
00:C1B4 B131            	   879:   lda  (T),Y
00:C1B6 8502            	   880:   sta REGB
00:C1B8 4C50BF          	   881:   jmp MAINP   ; push it
                        	   882: 
                        	   883: ;
                        	   884: ;  Load a single-character value (variable) onto the stack
                        	   885: ;
                        	   886: 
                        	   887: EX_LODC:
00:C1BB 20A2BF          	   888:   jsr  GETADR
                        	   889: EX_LOD3:
00:C1BE A002            	   890:   ldy  #2
                        	   891: EX_LOD3_A:
00:C1C0 A900            	   892:   lda  #0      ; since this is a character zero out the high-order bytes
00:C1C2 8501            	   893:   sta  REG+1
00:C1C4 8502            	   894:   sta  REGB
00:C1C6 B13D            	   895:   lda  (DATA),Y  ; (DATA) contains the lower-order byte
00:C1C8 8500            	   896:   sta  REG       ; REG will be pushed
00:C1CA 4C50BF          	   897:   jmp  MAINP     ; push REG and go to MAIN
                        	   898: ;
                        	   899: ;  Load a 3-byte value (variable) onto the stack
                        	   900: ;
                        	   901: EX_LOD:
00:C1CD 20A2BF          	   902:   jsr  GETADR
                        	   903: EX_LOD2:
00:C1D0 A000            	   904:   ldy  #0
00:C1D2 B13D            	   905:   lda  (DATA),Y    ; (DATA) contains the variable value
00:C1D4 8500            	   906:   sta  REG
00:C1D6 C8              	   907:   iny
00:C1D7 B13D            	   908:   lda  (DATA),Y
00:C1D9 8501            	   909:   sta  REG+1
00:C1DB C8              	   910:   iny
00:C1DC B13D            	   911:   lda  (DATA),Y
00:C1DE 8502            	   912:   sta REGB
00:C1E0 4C50BF          	   913:   jmp MAINP   ; push it
                        	   914: 
                        	   915: ;
                        	   916: ;  Load absolute address character
                        	   917: ;
                        	   918: EX_LDAC:
00:C1E3 20E9BF          	   919:   jsr  PULTOP
00:C1E6 853D            	   920:   sta  DATA
00:C1E8 863E            	   921:   stx  DATA+1
00:C1EA A000            	   922:   ldy  #0
00:C1EC F0D2            	   923:   beq  EX_LOD3_A
                        	   924: ;
                        	   925: ;  Load absolute address integer
                        	   926: ;
                        	   927: EX_LDA:
00:C1EE 20E9BF          	   928:   jsr  PULTOP
00:C1F1 853D            	   929:   sta  DATA
00:C1F3 863E            	   930:   stx  DATA+1
00:C1F5 4CD0C1          	   931:   jmp  EX_LOD2
                        	   932: ;
                        	   933: ;  Get address of indexed character
                        	   934: ;
                        	   935: GETIDC:
00:C1F8 200EC0          	   936:   jsr  PULTOP2    ; pull index into REG2
00:C1FB 20A2BF          	   937:   jsr  GETADR
00:C1FE 4C15C2          	   938:   jmp  GETID2
                        	   939: ;
                        	   940: ;  Get address of indexed integer
                        	   941: ;
                        	   942: GETIDX   =  *
00:C201 200EC0          	   943:   jsr  PULTOP2  ; pull index into REG2
00:C204 0603            	   944:   asl  REG2     ; now multiply by 3
00:C206 2604            	   945:   rol  REG2+1
00:C208 18              	   946:   clc
00:C209 6503            	   947:   adc  REG2
00:C20B 8503            	   948:   sta  REG2
00:C20D 8A              	   949:   txa
00:C20E 6504            	   950:   adc  REG2+1
00:C210 8504            	   951:   sta  REG2+1     ; TIMES 3
00:C212 20A2BF          	   952:   jsr  GETADR
                        	   953: ;
                        	   954: ;  Get address of indexed integer/character
                        	   955: ;
                        	   956: ;  It looks like arrays expand downwards
                        	   957: ;
                        	   958: GETID2:
00:C215 A53D            	   959:   lda  DATA     ; initial address
00:C217 38              	   960:   sec           ; subtract subscript
00:C218 E503            	   961:   sbc  REG2
00:C21A 853D            	   962:   sta  DATA
00:C21C A53E            	   963:   lda  DATA+1
00:C21E E504            	   964:   sbc  REG2+1
00:C220 853E            	   965:   sta  DATA+1
00:C222 60              	   966:   rts
                        	   967: ;
                        	   968: ;  Load indexed character
                        	   969: ;
                        	   970: EX_LDIC:
00:C223 20F8C1          	   971:   jsr  GETIDC
00:C226 4CBEC1          	   972:   jmp  EX_LOD3
                        	   973: ;
                        	   974: ;  Load indexed integer
                        	   975: ;
                        	   976: EX_LDI:
00:C229 2001C2          	   977:   jsr  GETIDX
00:C22C 4CD0C1          	   978:   jmp  EX_LOD2
                        	   979: ;
                        	   980: ;  Store character
                        	   981: ;
                        	   982: EX_STOC:
00:C22F 20A2BF          	   983:   jsr  GETADR
00:C232 20E9BF          	   984:   jsr  PULTOP
00:C235 A002            	   985:   ldy  #2   ; why?
                        	   986: EX_STO5:
00:C237 913D            	   987:   sta  (DATA),Y
00:C239 4C53BF          	   988:   jmp  MAIN
                        	   989: ;
                        	   990: ;  Store integer
                        	   991: ;
                        	   992: EX_STO:
00:C23C 20A2BF          	   993:   jsr  GETADR   ; get its address
00:C23F 20E9BF          	   994:   jsr  PULTOP   ; get the value to store
                        	   995: EX_STO2:
00:C242 A000            	   996:   ldy  #0
00:C244 913D            	   997:   sta  (DATA),Y
00:C246 C8              	   998:   iny
00:C247 8A              	   999:   txa
00:C248 913D            	  1000:   sta  (DATA),Y
00:C24A A502            	  1001:   lda  REGB
00:C24C C8              	  1002:   iny
00:C24D D0E8            	  1003:   bne  EX_STO5
                        	  1004: ;
                        	  1005: ;  Store integer at absolute address
                        	  1006: ;
                        	  1007: EX_STA:
00:C24F 200BC0          	  1008:   jsr  PULBOTH  ; get address into REG2 and value into REG
00:C252 A000            	  1009:   ldy  #0
00:C254 A500            	  1010:   lda  REG
00:C256 9103            	  1011:   sta  (REG2),Y
00:C258 C8              	  1012:   iny
00:C259 A501            	  1013:   lda  REG+1
00:C25B 9103            	  1014:   sta  (REG2),Y
00:C25D C8              	  1015:   iny
00:C25E A502            	  1016:   lda  REGB
                        	  1017: EX_STA5:
00:C260 9103            	  1018:   sta  (REG2),Y
00:C262 4C53BF          	  1019:   jmp  MAIN
                        	  1020: ;
                        	  1021: ;  Store character at absolute address
                        	  1022: ;
                        	  1023: EX_STAC:
00:C265 200BC0          	  1024:   jsr  PULBOTH  ; get address into REG2 and value into REG
00:C268 A500            	  1025:   lda  REG
00:C26A A000            	  1026:   ldy  #0
00:C26C F0F2            	  1027:   beq  EX_STA5
                        	  1028: ;
                        	  1029: ;     Store character indexed
                        	  1030: ;
                        	  1031: EX_STIC:
00:C26E 20E9BF          	  1032:   jsr  PULTOP
00:C271 8545            	  1033:   sta  TEMP
00:C273 20F8C1          	  1034:   jsr  GETIDC
00:C276 A545            	  1035:   lda  TEMP
00:C278 A002            	  1036:   ldy  #2
00:C27A D0BB            	  1037:   bne  EX_STO5
                        	  1038: ;
                        	  1039: ;     Store integer indexed
                        	  1040: ;
                        	  1041: EX_STI :
00:C27C 20E9BF          	  1042:   jsr  PULTOP
00:C27F 8545            	  1043:   sta  TEMP
00:C281 8646            	  1044:   stx  TEMP+1
00:C283 98              	  1045:   tya
00:C284 48              	  1046:   pha
00:C285 2001C2          	  1047:   jsr  GETIDX
00:C288 A000            	  1048:   ldy  #0
00:C28A A545            	  1049:   lda  TEMP
00:C28C 913D            	  1050:   sta  (DATA),Y
00:C28E A546            	  1051:   lda  TEMP+1
00:C290 C8              	  1052:   iny
00:C291 913D            	  1053:   sta  (DATA),Y
00:C293 68              	  1054:   pla
00:C294 C8              	  1055:   iny
00:C295 D0A0            	  1056:   bne  EX_STO5
                        	  1057: ;
                        	  1058: ;  Procedure/function return
                        	  1059: ;
                        	  1060: ;  Stack frame linkage data:
                        	  1061: ;
                        	  1062: ;    (from low to high address)
                        	  1063: ;
                        	  1064: ;    Return address <-- P-code to return to when function/procedure exits
                        	  1065: ;    Dynamic link   <-- The previous stack frame from the earlier function call
                        	  1066: ;    Static link    <-- The stack frame of the previous static function
                        	  1067: ;
                        	  1068: ;  Static and dynamic links will be the same except for recursive calls.
                        	  1069: ;
                        	  1070: ;  To unwind the stack we have to go back to the previous dynamic link (on a return)
                        	  1071: ;
                        	  1072: ;  However to find variables in previous lexical declarations we have to use the static link.
                        	  1073: ;
                        	  1074: ;
                        	  1075: EX_RTN:
                        	  1076: ;
                        	  1077: ;  Subtract 6 from the base address, put result into WORK
                        	  1078: ;
00:C297 38              	  1079:   sec
00:C298 A53B            	  1080:   lda  BASE
00:C29A E906            	  1081:   sbc  #6
00:C29C 8537            	  1082:   sta  WORK
00:C29E A53C            	  1083:   lda  BASE+1
00:C2A0 E900            	  1084:   sbc  #0
00:C2A2 8538            	  1085:   sta  WORK+1
                        	  1086: ;
                        	  1087: ;  The return address was at the bottom of BASE, so put that into PCODE
                        	  1088: ;
00:C2A4 A000            	  1089:   ldy  #0
00:C2A6 B137            	  1090:   lda  (WORK),Y
00:C2A8 8523            	  1091:   sta  PCODE
00:C2AA C8              	  1092:   iny
00:C2AB B137            	  1093:   lda  (WORK),Y
00:C2AD 8524            	  1094:   sta  PCODE+1
                        	  1095: 
                        	  1096: ;
                        	  1097: ;  The base address becomes our new top of runtime stack
                        	  1098: ;
00:C2AF A53C            	  1099:   lda  BASE+1
00:C2B1 8532            	  1100:   sta  T+1
00:C2B3 A53B            	  1101:   lda  BASE
00:C2B5 8531            	  1102:   sta  T
                        	  1103: ;
                        	  1104: ;  The dynamic stack frame address is 4 bytes down from the BASE - put that into WORK
                        	  1105: ;
00:C2B7 38              	  1106:   sec
00:C2B8 E904            	  1107:   sbc  #4
00:C2BA 8537            	  1108:   sta  WORK
00:C2BC A53C            	  1109:   lda  BASE+1
00:C2BE E900            	  1110:   sbc  #0
00:C2C0 8538            	  1111:   sta  WORK+1
                        	  1112: ;
                        	  1113: ;  Get the previous dynamic stack frame address and put it into BASE (in case of
                        	  1114: ;   recursive function calls)
                        	  1115: ;
00:C2C2 A000            	  1116:   ldy  #0
00:C2C4 B137            	  1117:   lda  (WORK),Y
00:C2C6 853B            	  1118:   sta  BASE
00:C2C8 C8              	  1119:   iny
00:C2C9 B137            	  1120:   lda  (WORK),Y
00:C2CB 853C            	  1121:   sta  BASE+1
                        	  1122: ;
                        	  1123: ;  Stack, base and Pcode all changed, ready for next instruction
                        	  1124: ;
00:C2CD 4C53BF          	  1125:   jmp  MAIN
                        	  1126: 
                        	  1127: ;
                        	  1128: ; Input a number into a variable
                        	  1129: ;
                        	  1130: EX_INP      =  *
00:C2D0 A980            	  1131:   lda #$80
00:C2D2 853F            	  1132:   sta  RUNNING
00:C2D4 208B95          	  1133:   JSR  GET_LINE
00:C2D7 AD0002          	  1134:   lda  INBUF
00:C2DA C903            	  1135:   cmp  #KEY_ABORT   ; check for aborting with Ctrl+C
00:C2DC D003            	  1136:   bne  EX_INP_OK
00:C2DE 4C2BC5          	  1137:   jmp  ex_input_aborted
                        	  1138: 
                        	  1139: EX_INP_OK:
00:C2E1 A900            	  1140:   lda #<INBUF
00:C2E3 858E            	  1141:   sta token_start
00:C2E5 A902            	  1142:   lda #>INBUF
00:C2E7 858F            	  1143:   sta token_start+1
00:C2E9 6493            	  1144:   stz token_type
00:C2EB 209FCB          	  1145:   jsr get_token
00:C2EE C94E            	  1146:   cmp #TOKEN_NUMBER
00:C2F0 D016            	  1147:   bne BAD_INP
00:C2F2 A694            	  1148:   LDX  token_value
00:C2F4 A495            	  1149:   LDY  token_value+1
00:C2F6 A596            	  1150:   LDA  token_value+2
                        	  1151: INP3:
00:C2F8 8401            	  1152:   sty  REG+1
00:C2FA 8600            	  1153:   stx  REG
00:C2FC 8502            	  1154:   sta  REGB
00:C2FE 2030C0          	  1155:   jsr  PSHTOP
00:C301 A20C            	  1156:   ldx  #12
00:C303 863F            	  1157:   stx  RUNNING
00:C305 4C53BF          	  1158:   jmp  MAIN
                        	  1159: ;
                        	  1160: ;  bad number: set it to $800000
                        	  1161: ;
                        	  1162: BAD_INP:
00:C308 A980            	  1163:   lda #$80
00:C30A A200            	  1164:   ldx #0
00:C30C A000            	  1165:   ldy #0
00:C30E F0E8            	  1166:   beq INP3
                        	  1167: ;
                        	  1168: ; write a number to output
                        	  1169: ;
                        	  1170: EX_OUT:
00:C310 2009CB          	  1171:   jsr write_to_serial
00:C313 8003            	  1172:   bra OUT_COMMON
                        	  1173: 
                        	  1174: EX_LCD_WRITE_NUM:
00:C315 2014CB          	  1175:   jsr write_to_lcd
                        	  1176: 
                        	  1177: OUT_COMMON:
00:C318 20E9BF          	  1178:   jsr  PULTOP
00:C31B 204F93          	  1179:   jsr  display_in_decimal
00:C31E 2009CB          	  1180:   jsr  write_to_serial
00:C321 4C53BF          	  1181:   jmp  MAIN
                        	  1182: ;
                        	  1183: ;
                        	  1184: ; Output 6 hex characters (3 bytes)
                        	  1185: ;
                        	  1186: EX_OUH:
00:C324 2009CB          	  1187:   jsr write_to_serial
00:C327 8003            	  1188:   bra EX_OUH_COMMON
                        	  1189: 
                        	  1190: EX_LCD_WRITE_HEX:
00:C329 2014CB          	  1191:   jsr write_to_lcd
                        	  1192: 
                        	  1193: EX_OUH_COMMON:
00:C32C 20E9BF          	  1194:   jsr  PULTOP
00:C32F A502            	  1195:   lda  REGB
00:C331 209A94          	  1196:   jsr  PRBYTE
00:C334 A501            	  1197:   lda  REG+1
00:C336 209A94          	  1198:   jsr  PRBYTE
00:C339 A500            	  1199:   lda  REG
00:C33B 209A94          	  1200:   jsr  PRBYTE
00:C33E 2009CB          	  1201:   jsr  write_to_serial
00:C341 4C53BF          	  1202:   jmp  MAIN
                        	  1203: ;
                        	  1204: ;  write a string to output
                        	  1205: ;
                        	  1206: EX_OUS      =  *
00:C344 2009CB          	  1207:   jsr write_to_serial
00:C347 8003            	  1208:   bra EX_OUS_COMMON
                        	  1209: 
                        	  1210: EX_LCD_WRITE_STR:
00:C349 2014CB          	  1211:   jsr write_to_lcd
                        	  1212: 
                        	  1213: EX_OUS_COMMON:
00:C34C A523            	  1214:   lda  PCODE
00:C34E 18              	  1215:   clc
00:C34F 6901            	  1216:   adc  #1
00:C351 8537            	  1217:   sta  WORK
00:C353 A524            	  1218:   lda  PCODE+1
00:C355 6900            	  1219:   adc  #0
00:C357 8538            	  1220:   sta  WORK+1
00:C359 B123            	  1221:   lda  (PCODE),Y
00:C35B 854B            	  1222:   sta  COUNT1     ; NO. OF CHARS
00:C35D 18              	  1223:   clc
00:C35E 6901            	  1224:   adc  #1
00:C360 6523            	  1225:   adc  PCODE
00:C362 8523            	  1226:   sta  PCODE
00:C364 9002            	  1227:   bcc  EX_OUS1
00:C366 E624            	  1228:   inc  PCODE+1
                        	  1229: EX_OUS1:
00:C368 A537            	  1230:   lda  WORK
00:C36A A638            	  1231:   ldx  WORK+1
00:C36C A44B            	  1232:   ldy  COUNT1
00:C36E 20B494          	  1233:   jsr  PT
00:C371 2009CB          	  1234:   jsr write_to_serial
00:C374 4C53BF          	  1235:   jmp  MAIN
                        	  1236: 
                        	  1237: 
                        	  1238: 
                        	  1239: ;
                        	  1240: ;  Stack frame linkage data:
                        	  1241: ;
                        	  1242: ;    (from low to high address)
                        	  1243: ;
                        	  1244: ;    Return address <-- P-code to return to when function/procedure exits
                        	  1245: ;    Dynamic link   <-- The previous stack frame from the earlier function call
                        	  1246: ;    Static link    <-- The stack frame of the previous static function
                        	  1247: ;
                        	  1248: ;  Static and dynamic links will be the same except for recursive calls.
                        	  1249: ;
                        	  1250: ;  To unwind the stack we have to go back to the previous dynamic link (on a return)
                        	  1251: ;
                        	  1252: ;  However to find variables in previous lexical declarations we have to use the static link.
                        	  1253: ;
                        	  1254: ;
                        	  1255: ; Call absolute procedure - I don't think this is used in this version TBH
                        	  1256: ;
                        	  1257: ; Note: Y is zero when entering
                        	  1258: ;
                        	  1259: EX_ABSCLL   =  *
00:C377 8447            	  1260:   sty  CALL      ; zero out address to be called
00:C379 8448            	  1261:   sty  CALL+1    ; (offset therefore becomes absolute address)
00:C37B 4C86C3          	  1262:   jmp  EX_CLL_A
                        	  1263: ;
                        	  1264: ; Call relative procedure
                        	  1265: ;
                        	  1266: ; Note: Y is zero when entering
                        	  1267: ;
                        	  1268: EX_CLL      =  *
00:C37E A54D            	  1269:   lda  LASTP
00:C380 8547            	  1270:   sta  CALL
00:C382 A54E            	  1271:   lda  LASTP+1
00:C384 8548            	  1272:   sta  CALL+1
                        	  1273: EX_CLL_A    =  *
00:C386 B123            	  1274:   lda  (PCODE),Y     ; level
00:C388 854B            	  1275:   sta  COUNT1
00:C38A C8              	  1276:   iny
00:C38B 18              	  1277:   clc
00:C38C B123            	  1278:   lda  (PCODE),Y     ; relative address
00:C38E 6547            	  1279:   adc  CALL          ; add to current P-code address
00:C390 8547            	  1280:   sta  CALL
00:C392 C8              	  1281:   iny
00:C393 B123            	  1282:   lda  (PCODE),Y
00:C395 6548            	  1283:   adc  CALL+1
00:C397 8548            	  1284:   sta  CALL+1
00:C399 A523            	  1285:   lda  PCODE         ; add 3 to P-code to bypass level / address
00:C39B 18              	  1286:   clc                ; this will become our return address
00:C39C 6903            	  1287:   adc  #3
00:C39E 8523            	  1288:   sta  PCODE
00:C3A0 9002            	  1289:   bcc  EX_CLL4
00:C3A2 E624            	  1290:   inc  PCODE+1
                        	  1291: EX_CLL4     =  *
00:C3A4 A53C            	  1292:   lda  BASE+1
00:C3A6 A63B            	  1293:   ldx  BASE
                        	  1294: EX_CLL2     =  *
00:C3A8 853E            	  1295:   sta  DATA+1      ; this was BASE
00:C3AA 863D            	  1296:   stx  DATA
00:C3AC A8              	  1297:   tay
00:C3AD A54B            	  1298:   lda  COUNT1      ; this was the level
00:C3AF F018            	  1299:   beq  EX_CLL3
00:C3B1 38              	  1300:   sec
00:C3B2 8A              	  1301:   txa
00:C3B3 E902            	  1302:   sbc  #2          ; subtract 2 from BASE, store in WORK
00:C3B5 8537            	  1303:   sta  WORK
00:C3B7 98              	  1304:   tya
00:C3B8 E900            	  1305:   sbc  #0
00:C3BA 8538            	  1306:   sta  WORK+1
00:C3BC A000            	  1307:   ldy  #0
00:C3BE B137            	  1308:   lda  (WORK),Y
00:C3C0 C8              	  1309:   iny
00:C3C1 AA              	  1310:   tax
00:C3C2 B137            	  1311:   lda  (WORK),Y
00:C3C4 C64B            	  1312:   dec  COUNT1
00:C3C6 4CA8C3          	  1313:   jmp  EX_CLL2
                        	  1314: EX_CLL3     =  *
00:C3C9 A531            	  1315:   lda  T         ; our stack pointer
00:C3CB 8545            	  1316:   sta  TEMP      ; save it
00:C3CD A532            	  1317:   lda  T+1
00:C3CF 8546            	  1318:   sta  TEMP+1
                        	  1319: ;
                        	  1320: ; this is as confusing as all-get-out but it looks like we
                        	  1321: ; are pushing onto the stack: DATA / BASE / PCODE (return address)
                        	  1322: ;  (which is why we saved T into TEMP so it didn't change during the pushes)
                        	  1323: ;
                        	  1324: 
00:C3D1 A53D            	  1325:   lda  DATA      ; put DATA into REG
00:C3D3 8501            	  1326:   sta  REG+1
00:C3D5 A53E            	  1327:   lda  DATA+1
00:C3D7 8502            	  1328:   sta  REGB
00:C3D9 A53C            	  1329:   lda  BASE+1
00:C3DB 8500            	  1330:   sta  REG
00:C3DD 2030C0          	  1331:   jsr  PSHTOP      ; push REG (DATA + BASE[1])
00:C3E0 A53B            	  1332:   lda  BASE
00:C3E2 8502            	  1333:   sta  REGB
00:C3E4 A545            	  1334:   lda  TEMP        ; old stack pointer
00:C3E6 853B            	  1335:   sta  BASE        ; becomes BASE
00:C3E8 A546            	  1336:   lda  TEMP+1      ; ditto for other byte
00:C3EA 853C            	  1337:   sta  BASE+1
00:C3EC A523            	  1338:   lda  PCODE       ; get ready to push current P-Code
00:C3EE 8500            	  1339:   sta  REG
00:C3F0 A524            	  1340:   lda  PCODE+1
00:C3F2 8501            	  1341:   sta  REG+1
00:C3F4 2030C0          	  1342:   jsr  PSHTOP     ; push REG (BASE[0] + PCODE)
00:C3F7 A547            	  1343:   lda  CALL       ; now get the address of the place we want to call
00:C3F9 8523            	  1344:   sta  PCODE      ; and put it into PCODE
00:C3FB A548            	  1345:   lda  CALL+1
00:C3FD 8524            	  1346:   sta  PCODE+1
00:C3FF 18              	  1347:   clc             ; add 6 to the stack pointer because we later emit the code to INT 6 (leave room for base stuff)
00:C400 A531            	  1348:   lda  T
00:C402 6906            	  1349:   adc  #6
00:C404 8531            	  1350:   sta  T
00:C406 9002            	  1351:   bcc  EX_CLL5
00:C408 E632            	  1352:   inc  T+1
                        	  1353: EX_CLL5     =  *
00:C40A 4C53BF          	  1354:   jmp  MAIN        ; we are done, MAIN will now go to the called subroutine
                        	  1355: ;
                        	  1356: ;  Here for calling machine code from Pascal
                        	  1357: ;
                        	  1358: EX_CLA:
00:C40D 20E9BF          	  1359:   jsr  PULTOP      ; pull the address to be called from the stack
00:C410 A513            	  1360:   lda  call_p      ; status register
00:C412 48              	  1361:   pha
00:C413 A510            	  1362:   lda  call_a      ; A register
00:C415 A611            	  1363:   ldx  call_x      ; X register
00:C417 A412            	  1364:   ldy  call_y      ; Y register
00:C419 28              	  1365:   plp              ; get status register back
00:C41A 202AC4          	  1366:   jsr  EX_CLL_JMP  ; call the subroutine
00:C41D 08              	  1367:   php              ; save the status register
00:C41E 8510            	  1368:   sta  call_a      ; store the A/X/Y register
00:C420 8611            	  1369:   stx  call_x
00:C422 8412            	  1370:   sty  call_y
00:C424 68              	  1371:   pla              ; get status register back
00:C425 8513            	  1372:   sta  call_p      ; save it
00:C427 4C53BF          	  1373:   jmp  MAIN        ; done!
                        	  1374: 
00:C42A 6C0000          	  1375: EX_CLL_JMP  jmp  (REG)
                        	  1376: ;
                        	  1377: ;
                        	  1378: ; increment stack pointer (that is, subtract the literal from it, as it grows downwards)
                        	  1379: ;
                        	  1380: EX_INT:
00:C42D 204CC0          	  1381:   jsr  GETLIT
00:C430 38              	  1382:   sec
00:C431 A531            	  1383:   lda  T
00:C433 E500            	  1384:   sbc  REG
00:C435 8531            	  1385:   sta  T
00:C437 A532            	  1386:   lda  T+1
00:C439 E501            	  1387:   sbc  REG+1
00:C43B 8532            	  1388:   sta  T+1
00:C43D C544            	  1389:   cmp  END_PCD+1
00:C43F 9003            	  1390:   bcc  INT_ERR
00:C441 4C53BF          	  1391:   jmp  MAIN
                        	  1392: ;
                        	  1393: INT_ERR  =  *
00:C444 A94B            	  1394:   lda  #<INT_ERRM    ; stack full
00:C446 A2C4            	  1395:   ldx  #>INT_ERRM
00:C448 4C95BF          	  1396:   jmp  NOTIM1
                        	  1397: ;
00:C44B 537461636B206675	  1398: INT_ERRM asciiz "Stack full\n"    ; stack full
00:C453 6C6C0A
00:C456 00
                        	  1399: ;
                        	  1400: 
                        	  1401: ;
                        	  1402: ;  Change the runtime stack to the address given (assuming stack is empty)
                        	  1403: ;   Done by the {%S nnnn} compiler directive.
                        	  1404: ;
                        	  1405: EX_NEW_STACK:
00:C457 204CC0          	  1406:   jsr GETLIT
00:C45A A500            	  1407:   lda REG
00:C45C 8531            	  1408:   sta T
00:C45E 853B            	  1409:   sta BASE
00:C460 A501            	  1410:   lda REG+1
00:C462 8532            	  1411:   sta T+1
00:C464 853C            	  1412:   sta BASE+1
00:C466 4C53BF          	  1413:   jmp MAIN
                        	  1414: 
                        	  1415: ;
                        	  1416: ;  Jump to the address following the P-code
                        	  1417: ;
                        	  1418: EX_JMP:
00:C469 204CC0          	  1419:   jsr  GETLIT   ; get the address
00:C46C 18              	  1420:   clc
00:C46D A500            	  1421:   lda  REG
00:C46F 654D            	  1422:   adc  LASTP
00:C471 8523            	  1423:   sta  PCODE
00:C473 A501            	  1424:   lda  REG+1
00:C475 654E            	  1425:   adc  LASTP+1
00:C477 8524            	  1426:   sta  PCODE+1
00:C479 4C53BF          	  1427:   jmp  MAIN
                        	  1428: ;
                        	  1429: ;  Jump if the top of the stack is zero
                        	  1430: ;
                        	  1431: EX_JMZ:
00:C47C 20E9BF          	  1432:   jsr  PULTOP   ; puts REG into A
00:C47F 0501            	  1433:   ora  REG+1
00:C481 0502            	  1434:   ora  REGB
00:C483 D002            	  1435:   bne  EX_NOJUMP
00:C485 F0E2            	  1436:   beq  EX_JMP
                        	  1437: ;
                        	  1438: ;  Don't jump, just move past the address (TODO: just add 2?)
                        	  1439: ;
                        	  1440: EX_NOJUMP:
00:C487 204CC0          	  1441:   jsr  GETLIT
00:C48A 4C53BF          	  1442:   jmp  MAIN
                        	  1443: ;
                        	  1444: ;  Jump if the top of the stack is non-zero
                        	  1445: ;
                        	  1446: EX_JM1:
00:C48D 20E9BF          	  1447:   jsr  PULTOP    ; puts REG into A
00:C490 0501            	  1448:   ora  REG+1
00:C492 0502            	  1449:   ora  REGB
00:C494 D0D3            	  1450:   bne  EX_JMP
00:C496 F0EF            	  1451:   beq  EX_NOJUMP
                        	  1452: ;
                        	  1453: ;
                        	  1454: EX_INPC:
00:C498 201FCB          	  1455:   jsr GETIN
00:C49B C903            	  1456:   cmp  #KEY_ABORT   ; check for aborting with Ctrl+C
00:C49D D003            	  1457:   bne  EX_INPC_OK
00:C49F 4C2BC5          	  1458:   jmp  ex_input_aborted
                        	  1459: 
                        	  1460: EX_INPC_OK:
00:C4A2 2014BF          	  1461:   jsr CHK_KBD
00:C4A5 B0F1            	  1462:   bcs EX_INPC
00:C4A7 8500            	  1463:   sta REG
00:C4A9 A900            	  1464:   lda #0
00:C4AB 8501            	  1465:   sta REG+1
00:C4AD 8502            	  1466:   sta REGB
00:C4AF 4C50BF          	  1467:   jmp  MAINP
                        	  1468: ;
                        	  1469: EX_OUTC:
00:C4B2 2009CB          	  1470:   jsr write_to_serial
00:C4B5 8003            	  1471:   bra EX_OUTC_COMMON
                        	  1472: 
                        	  1473: EX_LCD_WRITE_CHR:
00:C4B7 2014CB          	  1474:   jsr write_to_lcd
                        	  1475: 
                        	  1476: EX_OUTC_COMMON:
00:C4BA 20E9BF          	  1477:   jsr  PULTOP
00:C4BD A500            	  1478:   lda  REG
00:C4BF 20B395          	  1479:   jsr  COUT
00:C4C2 2009CB          	  1480:   jsr write_to_serial
00:C4C5 4C53BF          	  1481:   jmp  MAIN
                        	  1482:   ;
                        	  1483: 
                        	  1484: EX_LCDHOME:
00:C4C8 20F0C8          	  1485:   jsr lcd_home
00:C4CB 4C53BF          	  1486:   JMP MAIN
                        	  1487: 
                        	  1488: 
                        	  1489: EX_LCDCLEAR:
00:C4CE 20E0C8          	  1490:   jsr lcd_clear_display
00:C4D1 4C53BF          	  1491:   JMP MAIN
                        	  1492: 
                        	  1493: EX_INS      =  *
00:C4D4 B123            	  1494:   lda  (PCODE),Y   ; wanted length
00:C4D6 8545            	  1495:   sta  TEMP
00:C4D8 E623            	  1496:   inc  PCODE
00:C4DA D002            	  1497:   bne  EX_INS3
00:C4DC E624            	  1498:   inc  PCODE+1
                        	  1499: EX_INS3     =  *
00:C4DE 208B95          	  1500:   jsr  GET_LINE
00:C4E1 AD0002          	  1501:   lda  INBUF
00:C4E4 C903            	  1502:   cmp  #KEY_ABORT     ; check for them aborting the run on input
00:C4E6 F043            	  1503:   beq  ex_input_aborted
00:C4E8 2014BF          	  1504:   jsr  CHK_KBD
00:C4EB B0F1            	  1505:   bcs  EX_INS3      ; we turned on/off tracing etc, ignore this line
00:C4ED 98              	  1506:   tya               ; length of line
00:C4EE 18              	  1507:   clc
00:C4EF 6901            	  1508:   adc  #1        ; why?
00:C4F1 C545            	  1509:   cmp  TEMP
00:C4F3 9002            	  1510:   bcc  EX_INS1
00:C4F5 A545            	  1511:   lda  TEMP      ; use max allowed length rather than received length
                        	  1512: EX_INS1     =  *
00:C4F7 8546            	  1513:   sta  TEMP+1    ; this is the length we are copying
00:C4F9 20A2BF          	  1514:   jsr  GETADR    ; get address to put the line
00:C4FC A003            	  1515:   ldy  #3        ; why?
00:C4FE A200            	  1516:   ldx  #0
                        	  1517: ;
                        	  1518: ;  copying loop - arrays are stored downwards, so we subtract from DATA each time
                        	  1519: ;
                        	  1520: EX_INS2     =  *
00:C500 C63D            	  1521:   dec  DATA
00:C502 A53D            	  1522:   lda  DATA
00:C504 C9FF            	  1523:   cmp  #$FF
00:C506 D002            	  1524:   bne  EX_INS4
00:C508 C63E            	  1525:   dec  DATA+1
                        	  1526: EX_INS4     =  *
00:C50A BD0002          	  1527:   lda  INBUF,X
00:C50D 913D            	  1528:   sta  (DATA),Y
00:C50F E8              	  1529:   inx
00:C510 C646            	  1530:   dec  TEMP+1      ; count of bytes to copy
00:C512 D0EC            	  1531:   bne  EX_INS2
00:C514 4C53BF          	  1532:   jmp  MAIN        ; stop now
                        	  1533:   ;
                        	  1534: 
00:C517 0A45786563757469	  1535: execution_aborted_message asciiz "\nExecution aborted\n"
00:C51F 6F6E2061626F7274
00:C527 65640A
00:C52A 00
                        	  1536: 
                        	  1537: ex_input_aborted:
00:C52B A917            	  1538:   lda #<execution_aborted_message
00:C52D A2C5            	  1539:   ldx #>execution_aborted_message
00:C52F 4C95BF          	  1540:   jmp NOTIM1
                        	  1541: ;
                        	  1542: ;
                        	  1543: EX_ADRNC    =  *
00:C532 20A2BF          	  1544:   jsr  GETADR
                        	  1545: EX_ADRNC2   =  *
00:C535 A53D            	  1546:   lda  DATA
00:C537 18              	  1547:   clc
00:C538 6902            	  1548:   adc  #2
00:C53A 853D            	  1549:   sta  DATA
00:C53C 9007            	  1550:   bcc  EX_ADRN2
00:C53E E63E            	  1551:   inc  DATA+1
00:C540 B003            	  1552:   bcs  EX_ADRN2
                        	  1553: EX_ADRNN    =  *
00:C542 20A2BF          	  1554:   jsr  GETADR
                        	  1555: EX_ADRN2    =  *
00:C545 A53D            	  1556:   lda  DATA
00:C547 8500            	  1557:   sta  REG
00:C549 A53E            	  1558:   lda  DATA+1
00:C54B 8501            	  1559:   sta  REG+1
00:C54D 4C50BF          	  1560:   jmp  MAINP
                        	  1561: ;
                        	  1562: EX_ADRAN    =  *
00:C550 2001C2          	  1563:   jsr  GETIDX
00:C553 4C45C5          	  1564:   jmp  EX_ADRN2
                        	  1565: ;
                        	  1566: EX_ADRAC    =  *
00:C556 20F8C1          	  1567:    jsr  GETIDC
00:C559 4C35C5          	  1568:    jmp  EX_ADRNC2
                        	  1569: ;
                        	  1570: ;
                        	  1571: ;
                        	  1572: 
                        	  1573: 
                        	  1574: ;
                        	  1575: ;  DIGITALREAD (pin) pin:0 to 15; pushes 0 or 1
                        	  1576: ;
                        	  1577: EX_DIGITALREAD = *
00:C55C 20E9BF          	  1578:   jsr PULTOP  ; which pin
00:C55F 20ECCA          	  1579:   jsr digitalread
00:C562 D003            	  1580:   bne EX_DIGITALREAD_ONE
00:C564 4C01C1          	  1581:   jmp FALSE
                        	  1582: EX_DIGITALREAD_ONE:
00:C567 4CF4C0          	  1583:   jmp TRUE    ; done
                        	  1584: 
                        	  1585: ;
                        	  1586: ;  LCDPOS (line, column)
                        	  1587: ;
                        	  1588: 
                        	  1589: EX_LCDPOS = *
00:C56A 20E9BF          	  1590:   jsr PULTOP   ; x
00:C56D 290F            	  1591:   and #$0F     ; max 15
00:C56F 858C            	  1592:   sta hardware_work  ; save it
00:C571 20E9BF          	  1593:   jsr PULTOP   ; y
00:C574 2901            	  1594:   and #1       ; can be 0 or 1
00:C576 F002            	  1595:   beq EX_LCDPOS_1
00:C578 A940            	  1596:   lda #$40
                        	  1597: EX_LCDPOS_1:
00:C57A 058C            	  1598:   ora hardware_work  ; or in the column
00:C57C 0980            	  1599:   ora #$80     ; command to set the address
00:C57E 208CC8          	  1600:   jsr lcd_instruction
00:C581 4C53BF          	  1601:   jmp MAIN
                        	  1602: 
                        	  1603: ;
                        	  1604: ;  RANDOM
                        	  1605: ;
                        	  1606: EX_RANDOM:
00:C584 20D791          	  1607:   jsr gen_random
00:C587 A509            	  1608:   lda random
00:C589 8500            	  1609:   sta REG
00:C58B A50A            	  1610:   lda random+1
00:C58D 8501            	  1611:   sta REG+1
00:C58F A50B            	  1612:   lda random+2
00:C591 8502            	  1613:   sta REGB
00:C593 4C50BF          	  1614:   jmp MAINP
                        	  1615: 
                        	  1616: 
                        	  1617: ;
                        	  1618: ;  LATENCY
                        	  1619: ;
                        	  1620: EX_LATENCY:
00:C596 A50D            	  1621:   lda typing_latency
00:C598 8500            	  1622:   sta REG
00:C59A A50E            	  1623:   lda typing_latency+1
00:C59C 8501            	  1624:   sta REG+1
00:C59E A50F            	  1625:   lda typing_latency+2
00:C5A0 8502            	  1626:   sta REGB
00:C5A2 4C50BF          	  1627:   jmp MAINP
                        	  1628: 
                        	  1629: ; PULTOP puts stuff here thus:
                        	  1630: ;
                        	  1631: ;        LDA  REG
                        	  1632: ;        LDX  REG+1
                        	  1633: ;        LDY  REGB
                        	  1634: 
                        	  1635: EX_DELAY = *
00:C5A5 20E9BF          	  1636:   JSR  PULTOP  ; get the time interval in ms
                        	  1637:   ; (Y = high-order byte, X = lo-order byte)
00:C5A8 A600            	  1638:   ldx REG
00:C5AA A501            	  1639:   lda REG+1
00:C5AC 297F            	  1640:   and #$7F
00:C5AE A8              	  1641:   tay
00:C5AF 20D292          	  1642:   jsr delay
00:C5B2 4C53BF          	  1643:   jmp MAIN
                        	  1644: 
                        	  1645: ;
                        	  1646: ;  RANDOMSEED
                        	  1647: ;
                        	  1648: EX_RANDOMSEED = *
00:C5B5 20E9BF          	  1649:   JSR  PULTOP  ; get the seed
00:C5B8 850A            	  1650:   sta random+1
00:C5BA 860B            	  1651:   stx random+2
00:C5BC 840C            	  1652:   sty random+3
00:C5BE A9FF            	  1653:   lda #$FF     ; ensure seed has some 1 bits
00:C5C0 8509            	  1654:   sta random
00:C5C2 4C53BF          	  1655:   jmp MAIN
                        	  1656: 
                        	  1657: ;
                        	  1658: ;  PINMODE (pin, mode) pin:0 to 15; mode: 0=read, 1=write
                        	  1659: ;
                        	  1660: EX_PINMODE = *
00:C5C5 20E9BF          	  1661:   jsr PULTOP  ; the mode
00:C5C8 AA              	  1662:   tax         ; input or output?
00:C5C9 DA              	  1663:   phx         ; save the mode
00:C5CA 20E9BF          	  1664:   jsr PULTOP  ; which pin
00:C5CD FA              	  1665:   plx         ; get mode back
00:C5CE 208ECA          	  1666:   jsr pinmode ; pin in A, mode in X
00:C5D1 4C53BF          	  1667:   jmp MAIN    ; done
                        	  1668: 
                        	  1669: ;
                        	  1670: ;  DIGITALWRITE (pin, value) pin:0 to 15; value: 0 or 1
                        	  1671: ;
                        	  1672: EX_DIGITALWRITE = *
00:C5D4 20E9BF          	  1673:   jsr PULTOP  ; the value
00:C5D7 AA              	  1674:   tax         ;
00:C5D8 DA              	  1675:   phx         ; save the value
00:C5D9 20E9BF          	  1676:   jsr PULTOP  ; which pin
00:C5DC FA              	  1677:   plx         ; get mode back
00:C5DD 20BDCA          	  1678:   jsr digitalwrite ; pin in A, value in X
00:C5E0 4C53BF          	  1679:   jmp MAIN    ; done
                        	  1680: 
                        	  1681: EX_LIB_CALL:
00:C5E3 204CC0          	  1682:   JSR  GETLIT
00:C5E6 6C0000          	  1683:   jmp  (REG)
                        	  1684: 
                        	  1685: ;
                        	  1686: ;  Assert (expression)
                        	  1687: ;
                        	  1688: 
                        	  1689: EX_ASSERT:
00:C5E9 20E9BF          	  1690:   jsr PULTOP  ; the value
00:C5EC A500            	  1691:   lda REG
00:C5EE 0501            	  1692:   ora REG+1
00:C5F0 0502            	  1693:   ora REGB
00:C5F2 D00A            	  1694:   bne EX_ASSERT_OK
00:C5F4 A99A            	  1695:   lda #<assertion_failed_message  ; "Assertion failed"
00:C5F6 A299            	  1696:   ldx #>assertion_failed_message
00:C5F8 202682          	  1697:   jsr print
00:C5FB 4CE495          	  1698:   jmp RUNERR
                        	  1699: 
                        	  1700: EX_ASSERT_OK:
00:C5FE 4C53BF          	  1701:   jmp MAIN
                        	  1702: 

Source: "gpascal.asm"
                        	   194:   .endif  ; USE_PASCAL
                        	   195: 
                        	   196:   .include "interrupts.inc"

Source: "interrupts.inc"
                        	     1: 
00:C601 0A42524B20657865	     2: break_message     asciiz "\nBRK executed at address $"
00:C609 6375746564206174
00:C611 2061646472657373
00:C619 2024
00:C61B 00
00:C61C 2C2041203D2024  	     3: a_equals_message  asciiz ", A = $"
00:C623 00
00:C624 2C2058203D2024  	     4: x_equals_message  asciiz ", X = $"
00:C62B 00
00:C62C 2C2059203D2024  	     5: y_equals_message  asciiz ", Y = $"
00:C633 00
00:C634 2C2050203D2024  	     6: p_equals_message  asciiz ", P = $"
00:C63B 00
00:C63C 2C2053203D2024  	     7: s_equals_message  asciiz ", S = $"
00:C643 00
00:C644 2C206964203D2024	     8: id_equals_message asciiz ", id = $"
00:C64C 00
                        	     9: 
                        	    10: ;--------------------------------------------------
                        	    11: ;  IRQ - here on BRK interrupt
                        	    12: ;--------------------------------------------------
                        	    13: brk_executed:
00:C64D 8412            	    14:   sty call_y    ; save Y - we didn't touch that
00:C64F 8614            	    15:   stx call_s    ; X still has the stack pointer in it
00:C651 FA              	    16:   plx           ; get X back
00:C652 8611            	    17:   stx call_x
00:C654 68              	    18:   pla           ; get A back
00:C655 8510            	    19:   sta call_a    ; save A
00:C657 68              	    20:   pla           ; get the processor flags from the stack
00:C658 8513            	    21:   sta call_p
00:C65A 68              	    22:   pla           ; low-order address of BRK
00:C65B 8515            	    23:   sta brk_address
00:C65D 68              	    24:   pla           ; high order address of BRK
00:C65E 8516            	    25:   sta brk_address+1
                        	    26: 
00:C660 A2FF            	    27:   ldx  #NEW_STK
00:C662 9A              	    28:   txs             ; reset stack so we don't write over it
                        	    29: 
00:C663 58              	    30:   cli           ; allow interrupts now so we can print
                        	    31: 
                        	    32: ;
                        	    33: ;  display BRK info for the user
                        	    34: ;
                        	    35:   ;
                        	    36:   ;  subtract 2 from brk_address to get where it actually was
                        	    37:   ;
00:C664 38              	    38:   sec
00:C665 A515            	    39:   lda brk_address
00:C667 E902            	    40:   sbc #2
00:C669 8515            	    41:   sta brk_address
00:C66B A516            	    42:   lda brk_address+1
00:C66D E900            	    43:   sbc #0
00:C66F 8516            	    44:   sta brk_address+1
00:C671 A901            	    45:   lda #<break_message
00:C673 A2C6            	    46:   ldx #>break_message
00:C675 202682          	    47:   jsr print
00:C678 A516            	    48:   lda brk_address+1
00:C67A 209A94          	    49:   jsr PRBYTE
00:C67D A515            	    50:   lda brk_address
00:C67F 209A94          	    51:   jsr PRBYTE
                        	    52: ;
                        	    53: ;  show A, X, Y, P, S
                        	    54: ;
00:C682 A91C            	    55:   lda #<a_equals_message
00:C684 A2C6            	    56:   ldx #>a_equals_message
00:C686 202682          	    57:   jsr print
00:C689 A510            	    58:   lda call_a
00:C68B 209A94          	    59:   jsr PRBYTE
00:C68E A924            	    60:   lda #<x_equals_message
00:C690 A2C6            	    61:   ldx #>x_equals_message
00:C692 202682          	    62:   jsr print
00:C695 A511            	    63:   lda call_x
00:C697 209A94          	    64:   jsr PRBYTE
00:C69A A92C            	    65:   lda #<y_equals_message
00:C69C A2C6            	    66:   ldx #>y_equals_message
00:C69E 202682          	    67:   jsr print
00:C6A1 A512            	    68:   lda call_y
00:C6A3 209A94          	    69:   jsr PRBYTE
00:C6A6 A934            	    70:   lda #<p_equals_message
00:C6A8 A2C6            	    71:   ldx #>p_equals_message
00:C6AA 202682          	    72:   jsr print
00:C6AD A513            	    73:   lda call_p
00:C6AF 209A94          	    74:   jsr PRBYTE
00:C6B2 A93C            	    75:   lda #<s_equals_message
00:C6B4 A2C6            	    76:   ldx #>s_equals_message
00:C6B6 202682          	    77:   jsr print
00:C6B9 A514            	    78:   lda call_s
00:C6BB 209A94          	    79:   jsr PRBYTE
00:C6BE A944            	    80:   lda #<id_equals_message
00:C6C0 A2C6            	    81:   ldx #>id_equals_message
00:C6C2 202682          	    82:   jsr print
                        	    83: ;
                        	    84: ;  advance one byte to get the break ID (byte after the BRK)
                        	    85: ;
00:C6C5 E615            	    86:   inc brk_address
00:C6C7 D002            	    87:   bne brk_executed1
00:C6C9 E616            	    88:   inc brk_address+1
                        	    89: brk_executed1:
00:C6CB A000            	    90:   ldy #0
00:C6CD B115            	    91:   lda (brk_address),Y
00:C6CF 209A94          	    92:   jsr PRBYTE
                        	    93: ;
                        	    94: ;  put brk_address back to where we should resume from
                        	    95: ;
00:C6D2 E615            	    96:   inc brk_address
00:C6D4 D002            	    97:   bne brk_executed2
00:C6D6 E616            	    98:   inc brk_address+1
                        	    99: brk_executed2:
                        	   100: 
00:C6D8 202594          	   101:   jsr CROUT
                        	   102: ;
                        	   103: ;  display stack
                        	   104: ;
00:C6DB A90C            	   105:   lda #<stack_message
00:C6DD A2C7            	   106:   ldx #>stack_message
00:C6DF 202682          	   107:   jsr print
00:C6E2 A514            	   108:   lda call_s
00:C6E4 18              	   109:   clc
00:C6E5 6906            	   110:   adc #6  ; the interrupt pushed 3 we pushed 2, plus the stack points to the first UNUSED spot
00:C6E7 AA              	   111:   tax
                        	   112: brk_executed3:
00:C6E8 BD0001          	   113:   lda $100,x
00:C6EB DA              	   114:   phx
00:C6EC 209A94          	   115:   jsr PRBYTE
00:C6EF 20B094          	   116:   jsr PUTSP
00:C6F2 FA              	   117:   plx
00:C6F3 E8              	   118:   inx
00:C6F4 F00C            	   119:   beq brk_executed4
00:C6F6 A910            	   120:   lda #FLAG_VALID_ASSEMBLE
00:C6F8 25BE            	   121:   and system_flags
00:C6FA F0EC            	   122:   beq brk_executed3
                        	   123: ;
                        	   124: ;  for run/assembler break, stop when stack reaches RUNNING_STACK_TOP
                        	   125: ;
00:C6FC E0D0            	   126:   cpx #(RUNNING_STACK_TOP + 1)
00:C6FE F002            	   127:   beq brk_executed4         ; we started here so let's stop here
00:C700 80E6            	   128:   bra brk_executed3
                        	   129: 
                        	   130: ;
                        	   131: ;  we are done now
                        	   132: ;
                        	   133: brk_executed4:
00:C702 202594          	   134:   jsr CROUT
00:C705 A980            	   135:   lda #FLAG_BRK_REACHED
00:C707 04BE            	   136:   tsb system_flags
00:C709 4C7282          	   137:   jmp main_prompt
                        	   138: 
00:C70C 537461636B3A20  	   139: stack_message asciiz "Stack: "
00:C713 00
                        	   140: 
00:C714 4C4DC6          	   141: brk_executedJ jmp brk_executed
                        	   142: 
                        	   143: ;--------------------------------------------------
                        	   144: ;  IRQ - here on maskable interrupt
                        	   145: ;--------------------------------------------------
                        	   146: 
                        	   147: irq:
00:C717 48              	   148:   pha       ; save A and X
00:C718 DA              	   149:   phx
00:C719 BA              	   150:   tsx       ; get stack pointer
00:C71A E0FB            	   151:   cpx #$FB  ; should be lesss than $FB (since the interrupt pushed 3 and we pushed 2)
00:C71C 9006            	   152:   bcc irq1
00:C71E A21B            	   153:   ldx #27   ; ERROR: stack full
00:C720 58              	   154:   cli       ; allow interrupts or error won't print
00:C721 4CE099          	   155:   jmp ERROR
                        	   156: 
                        	   157: irq1:
00:C724 BD0301          	   158:   lda $103,X    ; this will be the processor flags on the stack (3 up from where we are now)
00:C727 2910            	   159:   and #$10      ; check BRK flag
00:C729 D0E9            	   160:   bne brk_executedJ
                        	   161: ;
                        	   162: ;  here for a hardware IRQ
                        	   163: ;
00:C72B ADFD7F          	   164:   lda VIA_IFR
00:C72E 2908            	   165:   and #VIA_FLAG_CB2        ; CB2 active edge
00:C730 D00A            	   166:   bne cb2_interrupt
                        	   167: 
00:C732 ADFD7F          	   168:   lda VIA_IFR
00:C735 2940            	   169:   and #VIA_FLAG_TIMER1     ; Time out of T1
00:C737 D034            	   170:   bne timer1_interrupt
                        	   171: 
                        	   172: 
                        	   173: ;
                        	   174: ;  we shouldn't get here, and if we do we will probably just loop servicing the interrupt
                        	   175: ;
                        	   176:   .if SERIAL_DEBUGGING
                        	   177: 
                        	   178:     lda #SERIAL_SPARE2_MASK
                        	   179:     tsb VIA_PORTA
                        	   180:     trb VIA_PORTA
                        	   181: 
                        	   182:   .endif  ; SERIAL_DEBUGGING
                        	   183: 
00:C739 4C9CC7          	   184:   jmp irq_done
                        	   185: 
                        	   186: ;
                        	   187: ;  here for incoming start bit
                        	   188: ;
                        	   189: cb2_interrupt:
                        	   190: 
00:C73C 8DFE7F          	   191:   sta VIA_IER           ; turn off that interrupt
00:C73F 8DFD7F          	   192:   sta VIA_IFR           ; indicate we noticed it
                        	   193: 
00:C742 DA              	   194:   phx
00:C743 5A              	   195:   phy
                        	   196: 
00:C744 A208            	   197:   ldx #8              ; count of bits
00:C746 A030            	   198:   ldy #SERIAL_DELAY1  ; delay interval for first bit (allow for code above) TODO - probably needs to be less now
                        	   199: serial_in_loop:
                        	   200: ;
                        	   201: ; wait for bit time to be up
                        	   202: ;
00:C748 88              	   203:   dey
00:C749 D0FD            	   204:   bne serial_in_loop
                        	   205: 
                        	   206:   .if SERIAL_DEBUGGING
                        	   207:     lda #SERIAL_DEBUG1_MASK     ; toggle debug flag (2 cycles)
                        	   208:     tsb VIA_PORTA               ; paint the fence: up (6 cycles)
                        	   209:     trb VIA_PORTA               ; down (6 cycles)
                        	   210:                                 ; look eye! always look eye
                        	   211:   .else
00:C74B EA              	   212:     NOP    ; take the same time so the timing isn't thrown out
00:C74C EA              	   213:     NOP    ; 2 cycles each
00:C74D EA              	   214:     NOP
00:C74E EA              	   215:     NOP
00:C74F EA              	   216:     NOP
00:C750 EA              	   217:     NOP
00:C751 EA              	   218:     NOP    ; total of 14 cycles
                        	   219:   .endif  ; SERIAL_DEBUGGING
                        	   220: 
00:C752 ADF17F          	   221:   lda VIA_PORTA
00:C755 6A              	   222:   ror A                 ; put incoming bit into carry
00:C756 668A            	   223:   ror serial_in_byte    ; shift one bit in
00:C758 A023            	   224:   ldy #SERIAL_DELAY2    ; delay interval for remaining bits
00:C75A CA              	   225:   dex
00:C75B D0EB            	   226:   bne serial_in_loop
                        	   227: 
00:C75D 7A              	   228:   ply
00:C75E FA              	   229:   plx
                        	   230: ;
                        	   231: ;  re-enable interrupts on the falling edge
                        	   232: ;
00:C75F A988            	   233:   lda #VIA_FLAG_ENABLE | VIA_FLAG_CB2
00:C761 8DFE7F          	   234:   sta VIA_IER
00:C764 8DFD7F          	   235:   sta VIA_IFR   ; indicate we know about previous falling edges
                        	   236: 
                        	   237: ;
                        	   238: ;  move to place that we know it will be noticed
                        	   239: ;
00:C767 A58A            	   240:   lda serial_in_byte
00:C769 858B            	   241:   sta serial_in_byte_received
                        	   242: 
00:C76B 802F            	   243:   bra irq_done
                        	   244: 
                        	   245: ;
                        	   246: ;  here for time to send another outgoing bit
                        	   247: ;
                        	   248: timer1_interrupt :
                        	   249: 
00:C76D 8DFD7F          	   250:   sta VIA_IFR           ; indicate we noticed it
00:C770 A589            	   251:   lda serial_out_bit    ; are we in fact sending a byte?
00:C772 F028            	   252:   beq irq_done          ; no, just exit
                        	   253: 
                        	   254:   .if SERIAL_DEBUGGING
                        	   255: 
                        	   256:   lda #SERIAL_DEBUG2_MASK     ; toggle debug flag (2 cycles)
                        	   257:   tsb VIA_PORTA               ; wash on   (6 cycles)
                        	   258:   trb VIA_PORTA               ; wash off  (6 cycles)
                        	   259:                               ; now, sand the floor
                        	   260:  .else
00:C774 EA              	   261:      NOP    ; take the same time so the timing isn't thrown out
00:C775 EA              	   262:      NOP    ; 2 cycles each
00:C776 EA              	   263:      NOP
00:C777 EA              	   264:      NOP
00:C778 EA              	   265:      NOP
00:C779 EA              	   266:      NOP
00:C77A EA              	   267:      NOP    ; total of 14 cycles
                        	   268:   .endif  ; SERIAL_DEBUGGING
                        	   269: 
00:C77B 6688            	   270:   ror serial_out_byte+1  ; we don't care about the high-order bit
00:C77D 6687            	   271:   ror serial_out_byte    ; get the low-order bit into Carry
00:C77F 9007            	   272:   bcc write_zero
00:C781 A902            	   273:   lda #SERIAL_OUT_MASK   ; (send a 1 bit)
00:C783 0DF17F          	   274:   ora VIA_PORTA
00:C786 8005            	   275:   bra serial_send_count_bits
                        	   276: 
                        	   277: write_zero:
00:C788 A9FD            	   278:   lda #~SERIAL_OUT_MASK  ; (send a 0 bit)
00:C78A 2DF17F          	   279:   and VIA_PORTA
                        	   280: 
                        	   281: serial_send_count_bits:
00:C78D 8DF17F          	   282:   sta VIA_PORTA          ; output this bit
00:C790 C689            	   283:   dec serial_out_bit     ; remember bit count for later
00:C792 D008            	   284:   bne irq_done
                        	   285: 
                        	   286: ; here when all bits have been sent
                        	   287: ; disable the timer as we don't need it any more
                        	   288: ; and this will be a flag that we can send another byte
                        	   289: 
00:C794 A940            	   290:   lda #VIA_FLAG_DISABLE | VIA_FLAG_TIMER1  ; cancel interrupt on T1 timeout
00:C796 8DFE7F          	   291:   sta VIA_IER
00:C799 ADF47F          	   292:   lda VIA_T1C_L     ; clear interrupt flag
                        	   293: 
                        	   294: irq_done:
00:C79C FA              	   295:   plx   ; restore X
00:C79D 68              	   296:   pla   ; restore A
00:C79E 40              	   297:   rti
                        	   298: 

Source: "gpascal.asm"
                        	   197:   .include "lcd.inc"

Source: "lcd.inc"
                        	     1:   .if !EMULATOR
                        	     2:   .if LCD_SUPPORT
                        	     3: 
                        	     4: ;
                        	     5: ;  LCD stuff
                        	     6: ;
                        	     7: 
                        	     8: lcd_initialise:
                        	     9: ;
                        	    10: ;  LCD initialise
                        	    11: ;
                        	    12: 
00:C79F ADF37F          	    13:   lda VIA_DDRA
00:C7A2 09E0            	    14:   ora #(LCD_RW|LCD_RS|LCD_E)    ; set appropriate pins on Port A to output
00:C7A4 8DF37F          	    15:   sta VIA_DDRA
                        	    16: 
                        	    17:   ; see HD44780U documentation: "Initializing by Instruction" (page 46)
00:C7A7 2020C8          	    18:   jsr lcd_prepare_to_write_instruction
00:C7AA A930            	    19:   lda #$30
00:C7AC 2080C8          	    20:   jsr lcd_write_instruction_nibble
                        	    21:   ; wait > 4.1 ms
00:C7AF A214            	    22:   ldx #20
00:C7B1 A000            	    23:   ldy #0
00:C7B3 20D292          	    24:   jsr delay      ; 20 ms delay (in case of faster board clock speeds)
00:C7B6 2080C8          	    25:   jsr lcd_write_instruction_nibble
00:C7B9 20C892          	    26:   jsr delay_1ms  ; do it 4 times in case of faster board clock speeds
00:C7BC 20C892          	    27:   jsr delay_1ms
00:C7BF 20C892          	    28:   jsr delay_1ms
00:C7C2 20C892          	    29:   jsr delay_1ms
00:C7C5 2080C8          	    30:   jsr lcd_write_instruction_nibble
00:C7C8 20C892          	    31:   jsr delay_1ms  ; do it 4 times in case of faster board clock speeds
00:C7CB 20C892          	    32:   jsr delay_1ms
00:C7CE 20C892          	    33:   jsr delay_1ms
00:C7D1 20C892          	    34:   jsr delay_1ms
00:C7D4 A920            	    35:   lda #$20    ; switch to 4-bit mode
00:C7D6 2080C8          	    36:   jsr lcd_write_instruction_nibble
00:C7D9 20C892          	    37:   jsr delay_1ms  ; do it 4 times in case of faster board clock speeds
00:C7DC 20C892          	    38:   jsr delay_1ms
00:C7DF 20C892          	    39:   jsr delay_1ms
00:C7E2 20C892          	    40:   jsr delay_1ms
                        	    41: ;
                        	    42: ;  now we can switch to sending 8-bits in two nibbles
                        	    43: ;
00:C7E5 A928            	    44:   lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
00:C7E7 208CC8          	    45:   jsr lcd_instruction
00:C7EA A90C            	    46:   lda #%00001100 ; DCB: Display on; cursor off; blink off
00:C7EC 208CC8          	    47:   jsr lcd_instruction
00:C7EF A906            	    48:   lda #%00000110 ; Increment and shift cursor; don't shift display
00:C7F1 208CC8          	    49:   jsr lcd_instruction
00:C7F4 20E0C8          	    50:   jsr lcd_clear_display
00:C7F7 60              	    51:   rts
                        	    52: 
                        	    53: lcd_prepare_to_read_register:
00:C7F8 ADF17F          	    54:   lda VIA_PORTA
00:C7FB 0940            	    55:   ora #LCD_RW             ; set RW bit  (ie. enable reading)
00:C7FD 295F            	    56:   and #<(~(LCD_RS|LCD_E)) ; Clear RS/E bits
00:C7FF 8DF17F          	    57:   sta VIA_PORTA
00:C802 ADF27F          	    58:   lda VIA_DDRB
00:C805 290F            	    59:   and #$0F
00:C807 8DF27F          	    60:   sta VIA_DDRB            ; we are reading from DDRB
00:C80A 60              	    61:   rts
                        	    62: 
                        	    63: lcd_prepare_to_write_data:
00:C80B 48              	    64:   pha
00:C80C ADF17F          	    65:   lda VIA_PORTA
00:C80F 293F            	    66:   and #<(~(LCD_RW|LCD_E))  ; clear RW and E (enable writing)
00:C811 0920            	    67:   ora #LCD_RS              ; setting this means we write a character
00:C813 8DF17F          	    68:   sta VIA_PORTA
00:C816 ADF27F          	    69:   lda VIA_DDRB
00:C819 09F0            	    70:   ora #$F0      ; Set high-order pins on port B to output
00:C81B 8DF27F          	    71:   sta VIA_DDRB
00:C81E 68              	    72:   pla
00:C81F 60              	    73:   rts
                        	    74: 
                        	    75: lcd_prepare_to_write_instruction:
00:C820 48              	    76:   pha
00:C821 ADF17F          	    77:   lda VIA_PORTA
00:C824 291F            	    78:   and #<(~(LCD_RW|LCD_RS|LCD_E))  ; clear RW, RS and E (enable writing)
00:C826 8DF17F          	    79:   sta VIA_PORTA
00:C829 ADF27F          	    80:   lda VIA_DDRB
00:C82C 09F0            	    81:   ora #$F0      ; Set high-order pins on port B to output
00:C82E 8DF27F          	    82:   sta VIA_DDRB
00:C831 68              	    83:   pla
00:C832 60              	    84:   rts
                        	    85: 
                        	    86: lcd_set_enable:
00:C833 ADF17F          	    87:   lda VIA_PORTA
00:C836 0980            	    88:   ora #LCD_E
00:C838 8DF17F          	    89:   sta VIA_PORTA   ; Set enable (E)
00:C83B 60              	    90:   rts
                        	    91: 
                        	    92: lcd_clear_enable:
00:C83C ADF17F          	    93:   lda VIA_PORTA
00:C83F 297F            	    94:   and #<(~LCD_E)  ; Clear enable (E)
00:C841 8DF17F          	    95:   sta VIA_PORTA
00:C844 60              	    96:   rts
                        	    97: 
                        	    98: lcd_read_instruction_nibble:
00:C845 2033C8          	    99:   jsr lcd_set_enable
00:C848 ADF07F          	   100:   lda VIA_PORTB   ; read the data on port B
00:C84B 48              	   101:   pha             ; save the data
00:C84C 203CC8          	   102:   jsr lcd_clear_enable
00:C84F 68              	   103:   pla             ; get the data back
00:C850 60              	   104:   rts
                        	   105: 
                        	   106: ;
                        	   107: ; wait until LCD is not busy
                        	   108: ;
                        	   109: lcd_wait:
00:C851 DA              	   110:   phx
00:C852 5A              	   111:   phy
00:C853 48              	   112:   pha
00:C854 20F8C7          	   113:   jsr lcd_prepare_to_read_register
00:C857 A200            	   114:   ldx #0
                        	   115: lcdbusy:
                        	   116: ;
                        	   117: ;  timeout after 256 iterations of this loop so we don't hang
                        	   118: ;  if there is no LCD or it doesn't respond
                        	   119: ;
00:C859 CA              	   120:   dex
00:C85A F00C            	   121:   beq lcd_wait_timeout
00:C85C 2045C8          	   122:   jsr lcd_read_instruction_nibble
00:C85F 2980            	   123:   and #$80        ; get busy flag
00:C861 A8              	   124:   tay             ; save busy status
00:C862 2045C8          	   125:   jsr lcd_read_instruction_nibble   ; do second nibble
00:C865 98              	   126:   tya             ; get busy status back
00:C866 D0F1            	   127:   bne lcdbusy     ; if busy go back
                        	   128: ;
                        	   129: ;  here when not busy any more
                        	   130: ;
                        	   131: lcd_wait_timeout:
00:C868 68              	   132:   pla
00:C869 7A              	   133:   ply
00:C86A FA              	   134:   plx
00:C86B 60              	   135:   rts
                        	   136: 
                        	   137: ;
                        	   138: ;  Find the current LCD (cursor) address - useful for knowing
                        	   139: ;  if we exceed the limit of line 1
                        	   140: ;
                        	   141: lcd_get_address:
00:C86C 20F8C7          	   142:   jsr lcd_prepare_to_read_register
00:C86F 2045C8          	   143:   jsr lcd_read_instruction_nibble
00:C872 2970            	   144:   and #$70        ; ignore busy bit, mask out other junk
00:C874 8586            	   145:   sta lcd_work
00:C876 2045C8          	   146:   jsr lcd_read_instruction_nibble
00:C879 4A              	   147:   lsr A   ; shift this lot into low-order bits
00:C87A 4A              	   148:   lsr A
00:C87B 4A              	   149:   lsr A
00:C87C 4A              	   150:   lsr A
00:C87D 0586            	   151:   ora lcd_work    ; get the high-order bits back
00:C87F 60              	   152:   rts
                        	   153: 
                        	   154: lcd_write_instruction_nibble:
00:C880 48              	   155:   pha
00:C881 8DF07F          	   156:   sta VIA_PORTB         ; set up the data
00:C884 2033C8          	   157:   jsr lcd_set_enable    ; toggle enable
00:C887 203CC8          	   158:   jsr lcd_clear_enable
00:C88A 68              	   159:   pla
00:C88B 60              	   160:   rts
                        	   161: 
                        	   162: ;
                        	   163: ;  send an instruction to the LCD
                        	   164: ;
                        	   165: lcd_instruction:
00:C88C 2051C8          	   166:   jsr lcd_wait
00:C88F 2020C8          	   167:   jsr lcd_prepare_to_write_instruction
00:C892 2080C8          	   168:   jsr lcd_write_instruction_nibble
00:C895 48              	   169:   pha
00:C896 0A              	   170:   asl a   ; move the low-order bits into the high-order bits
00:C897 0A              	   171:   asl a   ; because the high-order 4 bits are the active ones
00:C898 0A              	   172:   asl a
00:C899 0A              	   173:   asl a
00:C89A 2080C8          	   174:   jsr lcd_write_instruction_nibble
00:C89D 68              	   175:   pla
00:C89E 60              	   176:   rts
                        	   177: 
                        	   178: lcd_data_nibble:
00:C89F 48              	   179:   pha
00:C8A0 200BC8          	   180:   jsr lcd_prepare_to_write_data
00:C8A3 8DF07F          	   181:   sta VIA_PORTB
00:C8A6 2033C8          	   182:   jsr lcd_set_enable
00:C8A9 203CC8          	   183:   jsr lcd_clear_enable
00:C8AC 68              	   184:   pla
00:C8AD 60              	   185:   rts
                        	   186: 
                        	   187: ;
                        	   188: ;  print a character to the LCD
                        	   189: ;
                        	   190: lcd_print_char:
00:C8AE 2051C8          	   191:   jsr lcd_wait  ; wait for previous write to finish
00:C8B1 C90A            	   192:   cmp #NL
00:C8B3 D004            	   193:   bne lcd_print_not_newline ; newline jumps to 2nd line
00:C8B5 20E8C8          	   194:   jsr lcd_second_line       ; go to second line
00:C8B8 60              	   195:   rts                       ; and don't print the newline :)
                        	   196: 
                        	   197: lcd_print_not_newline:
00:C8B9 48              	   198:   pha                   ; save the character we want to print
00:C8BA 206CC8          	   199:   jsr lcd_get_address
00:C8BD C910            	   200:   cmp #16         ; 16 characters on the first line
00:C8BF 900E            	   201:   bcc lcd_print_char_ok ; not there yet
00:C8C1 D005            	   202:   bne lcd_print_char_on_2nd_line  ; not < 16 and not == 16, must be > 16
                        	   203:   ; we have exactly 16, so drop down to address 64
00:C8C3 20E8C8          	   204:   jsr lcd_second_line  ; at char 16 go to 2nd line (address 64)
00:C8C6 8007            	   205:   bra lcd_print_char_ok
                        	   206: 
                        	   207: lcd_print_char_on_2nd_line:
00:C8C8 C950            	   208:   cmp #80                  ; more than 16 characters on in 2nd line? (64 + 16)
00:C8CA 9003            	   209:   bcc lcd_print_char_ok    ; nah
00:C8CC 20E0C8          	   210:   jsr lcd_clear_display    ; yes, clear display then and start again
                        	   211: lcd_print_char_ok:
                        	   212: lcd_print_char_newline:
00:C8CF 200BC8          	   213:   jsr lcd_prepare_to_write_data
00:C8D2 68              	   214:   pla                      ; get the character back
00:C8D3 209FC8          	   215:   jsr lcd_data_nibble
00:C8D6 48              	   216:   pha
00:C8D7 0A              	   217:   asl a     ; now send the low-order bits
00:C8D8 0A              	   218:   asl a
00:C8D9 0A              	   219:   asl a
00:C8DA 0A              	   220:   asl a
00:C8DB 209FC8          	   221:   jsr lcd_data_nibble
00:C8DE 68              	   222:   pla
00:C8DF 60              	   223:   rts
                        	   224: 
                        	   225: lcd_clear_display:
00:C8E0 48              	   226:   pha
00:C8E1 A901            	   227:   lda #%00000001 ; Clear display
00:C8E3 208CC8          	   228:   jsr lcd_instruction
00:C8E6 68              	   229:   pla
00:C8E7 60              	   230:   rts
                        	   231: 
                        	   232: lcd_second_line:
00:C8E8 48              	   233:   pha
00:C8E9 A9C0            	   234:   lda #$C0 ; set output address to 0x40 (set DDRAM address)
00:C8EB 208CC8          	   235:   jsr lcd_instruction
00:C8EE 68              	   236:   pla
00:C8EF 60              	   237:   rts
                        	   238: 
                        	   239: lcd_home:
00:C8F0 48              	   240:   pha
00:C8F1 A980            	   241:   lda #$80 ; set output address to 0 (set DDRAM address)
00:C8F3 208CC8          	   242:   jsr lcd_instruction
00:C8F6 68              	   243:   pla
00:C8F7 60              	   244:   rts
                        	   245: 
                        	   246: 
                        	   247: ;
                        	   248: ;  print null-terminated message on LCD, message in A (lo) and X (hi)
                        	   249: ;  returns the length of the message in Y
                        	   250: ;
                        	   251: lcd_print_message:
00:C8F8 8503            	   252:   sta REG2
00:C8FA 8604            	   253:   stx REG2+1
00:C8FC A000            	   254:   ldy #0
00:C8FE 20E0C8          	   255:   jsr lcd_clear_display
                        	   256: lcd_print:
00:C901 B103            	   257:   lda (REG2),y
00:C903 F006            	   258:   beq lcd_print_done
00:C905 20AEC8          	   259:   jsr lcd_print_char
00:C908 C8              	   260:   iny
00:C909 80F6            	   261:   bra lcd_print
                        	   262: 
00:C90B 60              	   263: lcd_print_done rts
                        	   264: 
                        	   265:   .else ; LCD_SUPPORT
                        	   266: 
                        	   267: lcd_print_char :
                        	   268: lcd_clear_display :
                        	   269: lcd_second_line:
                        	   270: lcd_print_message:
                        	   271: lcd_instruction:
                        	   272: lcd_get_address:
                        	   273: lcd_home:
                        	   274: lcd_wait:
                        	   275:     ldx #50     ; No LCD
                        	   276:     jmp ERROR
                        	   277: 
                        	   278: 
                        	   279:   .endif  ; (no) LCD_SUPPORT
                        	   280: 
                        	   281:   .endif  ; not emulator
                        	   282: 

Source: "gpascal.asm"
                        	   198:   .include "symbols.inc"

Source: "symbols.inc"
                        	     1: ;***********************************************
                        	     2: ; SYMBOL TABLE STUFF: Offsets from the start of a particular symbol
                        	     3: ; Stored as a linked list, where you search backwards so the more local one is found first
                        	     4: ;***********************************************
                        	     5: 
                        	     6: SYMPRV   =  0         ; address of previous symbol (for working backwards through symbols)
                        	     7: SYMLVL   =  2         ; nested level (eg. entering a procedure/function increments the level,
                        	     8:                       ;                   and leaving it decrements the level)
                        	     9:                       ; - used to detect duplicate symbols at the same level
                        	    10: SYMLIB   =  2         ; (re-used above for assembler symbols: 0 = user-declared, 1 = library)
                        	    11: SYMTYP   =  3         ; Symbol type: C = constant, V = variable, Y = function return value
                        	    12:                       ;              P = procedure, F = function, A = array
                        	    13:                       ;              p = library procedure, f = library function
                        	    14:                       ;  See defines below.
                        	    15: SYMDSP   =  4         ; if the symbol is a constant, what the value is (3 bytes)
                        	    16:                       ; if the symbol is a variable, array or function return then this is the offset (2 bytes)
                        	    17: SYMARG   =  6         ; if the symbol is a procedure/function, count of arguments (can be zero)
                        	    18: SYMSUB   =  6         ; MAX SUBSCRIPT+1 - for arrays, so this is the actual array length
                        	    19: SYMDAT   =  8         ; data type: 0 = integer, 1 = char
                        	    20: SYMLEN   =  9         ; length of the name, der
                        	    21: SYMNAM   =  10        ; name of symbol for SYMLEN characters, stored in upper-case
                        	    22: 
                        	    23: ;
                        	    24: ; Symbol types
                        	    25: ;
                        	    26: 
                        	    27: SYMBOL_CONSTANT          = 'C'
                        	    28: SYMBOL_VARIABLE          = 'V'
                        	    29: SYMBOL_FUNCTION_RETURN   = 'Y'
                        	    30: SYMBOL_PROCEDURE         = 'P'
                        	    31: SYMBOL_FUNCTION          = 'F'
                        	    32: SYMBOL_LIBRARY_PROCEDURE = 'Q'  ; library procedures and functions are implemented in assembler
                        	    33: SYMBOL_LIBRARY_FUNCTION  = 'R'
                        	    34: SYMBOL_ARRAY             = 'A'
                        	    35: 
                        	    36: 
                        	    37: 
                        	    38: ;
                        	    39: ;***********************************************
                        	    40: ;SEARCH SYMBOL TABLE - returns Z if not found (BEQ <not found>)
                        	    41: ;***********************************************
                        	    42: SEARCH   =  *
00:C90C A532            	    43:          lda  ENDSYM+1    ; get the end of the symbol table
00:C90E 8541            	    44:          sta  SYMITM+1    ; make it the current symbol
00:C910 A531            	    45:          lda  ENDSYM
00:C912 800B            	    46:          bra  SEA1
                        	    47: 
                        	    48: SEA_NEXT =  *
00:C914 A000            	    49:          ldy  #SYMPRV
00:C916 B140            	    50:          lda  (SYMITM),Y
00:C918 AA              	    51:          tax
00:C919 C8              	    52:          iny
00:C91A B140            	    53:          lda  (SYMITM),Y
00:C91C 8541            	    54:          sta  SYMITM+1   ; previous link
00:C91E 8A              	    55:          txa
                        	    56: ;
                        	    57: ;  go to the previous symbol table item
                        	    58: ;
                        	    59: SEA1     =  *
00:C91F 8540            	    60:          sta  SYMITM
00:C921 C52F            	    61:          cmp  STARTSYM
00:C923 D007            	    62:          bne  SEA2
00:C925 A541            	    63:          lda  SYMITM+1
00:C927 C530            	    64:          cmp  STARTSYM+1
00:C929 D001            	    65:          bne  SEA2       ; more to go
00:C92B 60              	    66:          rts             ; finished if we are back at the start of the symbol table
                        	    67: 
                        	    68: SEA2     =  *
00:C92C A009            	    69:          ldy  #SYMLEN
00:C92E B140            	    70:          lda  (SYMITM),Y  ; get this item's length
00:C930 C592            	    71:          cmp  token_length      ; compare to the token legnth we got
00:C932 D0E0            	    72:          bne  SEA_NEXT    ; wrong length - try another
00:C934 A540            	    73:          lda  SYMITM      ; back to this symbol's start address
00:C936 18              	    74:          clc
00:C937 690A            	    75:          adc  #SYMNAM     ; add the offset of the name to it
00:C939 8503            	    76:          sta  DEST
00:C93B A541            	    77:          lda  SYMITM+1
00:C93D 6900            	    78:          adc  #0
00:C93F 8504            	    79:          sta  DEST+1      ; the memory location of the symbol name is in DEST
00:C941 A590            	    80:          lda  token_address      ; now put the token's address into SRCE
00:C943 8500            	    81:          sta  SRCE
00:C945 A591            	    82:          lda  token_address+1
00:C947 8501            	    83:          sta  SRCE+1
00:C949 A492            	    84:          ldy  token_length
00:C94B 202A94          	    85:          jsr  COMSTL      ; compare SRCE to DEST
00:C94E D0C4            	    86:          bne  SEA_NEXT    ; not that one - try another
00:C950 2074CA          	    87:          jsr  GET_DAT     ; get the symbol's data type into DATTYP
00:C953 A002            	    88:          ldy  #SYMLVL     ; and level - why isn't this a function, huh?
00:C955 B140            	    89:          lda  (SYMITM),Y
00:C957 AA              	    90:          tax              ; level into X
00:C958 A003            	    91:          ldy  #SYMTYP
00:C95A B140            	    92:          lda  (SYMITM),Y  ; get type of symbol
00:C95C 8536            	    93:          sta  BSAVE       ; symbol type -> BSAVE
00:C95E C943            	    94:          cmp  #SYMBOL_CONSTANT       ; constant?
00:C960 D013            	    95:          bne  SEA4        ; nah
                        	    96: ;
                        	    97: ;  symbol is a constant
                        	    98: ;
00:C962 A004            	    99:          ldy  #SYMDSP     ; if a constant, this is the value
00:C964 B140            	   100:          lda  (SYMITM),Y
00:C966 8594            	   101:          sta  token_value
00:C968 C8              	   102:          iny
00:C969 B140            	   103:          lda  (SYMITM),Y
00:C96B 8595            	   104:          sta  token_value+1
00:C96D C8              	   105:          iny
00:C96E B140            	   106:          lda  (SYMITM),Y
00:C970 8596            	   107:          sta  token_value+2     ; token_value (3 bytes) now has the value in it
00:C972 4C80C9          	   108:          jmp  SEA3
                        	   109: ;
                        	   110: ;  symbol is not a constant
                        	   111: ;
                        	   112: SEA4     =  *                           ; not constant
00:C975 C956            	   113:          cmp  #SYMBOL_VARIABLE          ; variable?
00:C977 F004            	   114:          beq  SEA5                      ; yes
00:C979 C959            	   115:          cmp  #SYMBOL_FUNCTION_RETURN   ; argument?
00:C97B D003            	   116:          bne  SEA3                      ; no - must be SYMBOL_ARRAY, SYMBOL_PROCEDURE or SYMBOL_FUNCTION
                        	   117: ;
                        	   118: ;  here for variables and function return values
                        	   119: ;
                        	   120: SEA5     =  *
00:C97D 203FCA          	   121:          jsr  GET_OFF    ; get the variable's offset
                        	   122: SEA3     =  *
00:C980 A536            	   123:          lda  BSAVE      ; A now has the symbol type in it
                        	   124: 
                        	   125: ; Types are: SYMBOL_CONSTANT, SYMBOL_VARIABLE, SYMBOL_FUNCTION_RETURN,
                        	   126: ;            SYMBOL_PROCEDURE, SYMBOL_FUNCTION, SYMBOL_ARRAY
                        	   127: 
00:C982 60              	   128:          rts             ; SHOULD SET 'NEQ' FLAG
                        	   129: 
                        	   130: 
00:C983 A225            	   131: SYM_FULL ldx  #37     ; ERROR: Symbol table full
00:C985 4CE099          	   132:          jmp  ERROR
                        	   133: 
                        	   134: ;***********************************************
                        	   135: ; ADD SYMBOL TO SYMBOL TABLE - going downwards until we hit the P-codes
                        	   136: ;  A = the symbol type
                        	   137: ;***********************************************
                        	   138: ADDSYM   =  *
00:C988 48              	   139:          pha            ; save the symbol type
                        	   140: 
00:C989 A631            	   141:          ldx  ENDSYM    ; get the end of the symbol table
00:C98B 8640            	   142:          stx  SYMITM    ; make it the current symbol
00:C98D A632            	   143:          ldx  ENDSYM+1
00:C98F 8641            	   144:          stx  SYMITM+1
                        	   145: ;
                        	   146: ;  since we are going downwards, we need to subtract the fixed size of a symbol table item,
                        	   147: ;  plus the symbol length, from SYMITM
                        	   148: ;
00:C991 38              	   149:          sec            ; first subtract the token length
00:C992 A540            	   150:          lda  SYMITM
00:C994 E592            	   151:          sbc  token_length
00:C996 8540            	   152:          sta  SYMITM
00:C998 8503            	   153:          sta  DEST      ; put this spot into DEST for copying the name
00:C99A A541            	   154:          lda  SYMITM+1
00:C99C E900            	   155:          sbc  #0
00:C99E 8541            	   156:          sta  SYMITM+1
00:C9A0 8504            	   157:          sta  DEST+1
00:C9A2 38              	   158:          sec            ; and now the fixed size
00:C9A3 A540            	   159:          lda  SYMITM
00:C9A5 E90A            	   160:          sbc  #SYMNAM
00:C9A7 8540            	   161:          sta  SYMITM
00:C9A9 A541            	   162:          lda  SYMITM+1
00:C9AB E900            	   163:          sbc  #0
00:C9AD 8541            	   164:          sta  SYMITM+1
                        	   165: ;
                        	   166: ;  check we haven't hit the P-codes
                        	   167: ;
00:C9AF A902            	   168:          lda  #FLAG_ASSEMBLING
00:C9B1 25BE            	   169:          and  system_flags
00:C9B3 D008            	   170:          bne  ADDSYM_NOT_FULL
00:C9B5 A524            	   171:          lda  PCODE+1
00:C9B7 C541            	   172:          cmp  SYMITM+1
00:C9B9 9002            	   173:          bcc  ADDSYM_NOT_FULL   ; less than - ok
00:C9BB 80C6            	   174:          bra  SYM_FULL          ; greater than or equal (high-order byte) - uh oh
                        	   175: ;
                        	   176: ;  ah, for assembling it is a pain to know whether the symbol table has overflowed, so I'm going
                        	   177: ;  to ignore that as a problem for now. Checking against PCODE will not work if the assembler output
                        	   178: ;  has been relocated to above the symbol table, and the only other thing we can compare against is
                        	   179: ;  the end of the source which we don't necessarily know.
                        	   180: ;
                        	   181: ;
                        	   182: ;  now put the previous start in as the link for the previous one for this item
                        	   183: ;
                        	   184: ADDSYM_NOT_FULL:
00:C9BD A000            	   185:          ldy  #SYMPRV
00:C9BF A531            	   186:          lda  ENDSYM
00:C9C1 9140            	   187:          sta  (SYMITM),Y
00:C9C3 A532            	   188:          lda  ENDSYM+1
00:C9C5 C8              	   189:          iny
00:C9C6 9140            	   190:          sta  (SYMITM),Y
                        	   191: ;
                        	   192: ;  SYMITM now becomes the start of the symbol table
                        	   193: ;
00:C9C8 A540            	   194:          lda  SYMITM
00:C9CA 8531            	   195:          sta  ENDSYM
00:C9CC A541            	   196:          lda  SYMITM+1
00:C9CE 8532            	   197:          sta  ENDSYM+1
                        	   198: ;
                        	   199: ;  OK, we should be done linking it in.
                        	   200: ;  SYMITM now points to this (as yet unfilled-in) item and the first two bytes now point to
                        	   201: ;   where the symbols previously ended
                        	   202: ;
00:C9D0 68              	   203:          pla                ; get symbol type back
00:C9D1 A003            	   204:          ldy  #SYMTYP
00:C9D3 9140            	   205:          sta  (SYMITM),Y    ; store the type which was in A
00:C9D5 A002            	   206:          ldy  #SYMLVL
00:C9D7 48              	   207:          pha                ; save symbol type again
00:C9D8 A522            	   208:          lda  LEVEL
00:C9DA 9140            	   209:          sta  (SYMITM),Y    ; store the level
00:C9DC A009            	   210:          ldy  #SYMLEN
00:C9DE A592            	   211:          lda  token_length
00:C9E0 9140            	   212:          sta  (SYMITM),Y    ; store the token length
00:C9E2 A8              	   213:          tay
00:C9E3 88              	   214:          dey                ; make zero-relative
                        	   215: ADD1     =  *               ; copy the name across, in upper case
00:C9E4 B190            	   216:          lda  (token_address),Y
00:C9E6 20C191          	   217:          jsr  MAKE_UPPER
00:C9E9 9103            	   218:          sta  (DEST),Y
00:C9EB 88              	   219:          dey
00:C9EC 10F6            	   220:          bpl  ADD1      ; keep copying
                        	   221: 
                        	   222: ;
                        	   223: ;  we have added name to the table, now do the rest
                        	   224: ;
00:C9EE 68              	   225:          pla                     ; get symbol type back again
00:C9EF AA              	   226:          tax                     ; symbol type
00:C9F0 C943            	   227:          cmp  #SYMBOL_CONSTANT   ; CONSTANT??
00:C9F2 D013            	   228:          bne  ADD4
                        	   229: ;
                        	   230: ;  constant
                        	   231: ;
00:C9F4 A004            	   232:          ldy  #SYMDSP            ; put this token's value into SYMDSP offset from SYMITM (for 3 bytes)
00:C9F6 A594            	   233:          lda  token_value
00:C9F8 9140            	   234:          sta  (SYMITM),Y
00:C9FA C8              	   235:          iny
00:C9FB A595            	   236:          lda  token_value+1
00:C9FD 9140            	   237:          sta  (SYMITM),Y
00:C9FF C8              	   238:          iny
00:CA00 A596            	   239:          lda  token_value+2
00:CA02 9140            	   240:          sta  (SYMITM),Y
00:CA04 4C23CA          	   241:          jmp  ADD9
                        	   242: ;
                        	   243: ;  not a constant
                        	   244: ;
                        	   245: ADD4     =  *
00:CA07 A008            	   246:          ldy  #SYMDAT
00:CA09 A901            	   247:          lda  #1            ; char type (?)
00:CA0B 9140            	   248:          sta  (SYMITM),Y
00:CA0D 8A              	   249:          txa                ; get symbol type back
00:CA0E C956            	   250:          cmp  #SYMBOL_VARIABLE
00:CA10 D011            	   251:          bne  ADD9
                        	   252: ;
                        	   253: ;  variable type
                        	   254: ;
00:CA12 A005            	   255:          ldy  #SYMDSP+1
00:CA14 A521            	   256:          lda  FRAME+1       ; save frame
00:CA16 9140            	   257:          sta  (SYMITM),Y
00:CA18 88              	   258:          dey
00:CA19 A520            	   259:          lda  FRAME
00:CA1B 9140            	   260:          sta  (SYMITM),Y
00:CA1D E620            	   261:          inc  FRAME         ; add 1 to frame number
00:CA1F D002            	   262:          bne  ADD9
00:CA21 E621            	   263:          inc  FRAME+1
                        	   264: ADD9     =  *
00:CA23 60              	   265:          rts
                        	   266: ;
                        	   267: 
                        	   268: ;
                        	   269: LOOKUP   =  *
00:CA24 200CC9          	   270:          JSR  SEARCH
00:CA27 D005            	   271:          BNE  LOOK1
00:CA29 A20B            	   272:          LDX  #11     ; ERROR: Undeclared Identifier
00:CA2B 4CE099          	   273:          jmp  ERROR
00:CA2E 60              	   274: LOOK1    RTS
                        	   275: ;
00:CA2F 200CC9          	   276: CHKDUP   JSR  SEARCH
00:CA32 F00A            	   277:          BEQ  DUP9
00:CA34 8A              	   278:          TXA
00:CA35 C522            	   279:          CMP  LEVEL
00:CA37 D005            	   280:          BNE  DUP9
00:CA39 A226            	   281:          LDX  #38   ; ERROR: Duplicate Identifier
00:CA3B 4CE099          	   282:          jmp  ERROR
00:CA3E 60              	   283: DUP9     RTS
                        	   284: 
                        	   285: ;
                        	   286: ;  Get the offset of this current symbol into OFFSET
                        	   287: ;
                        	   288: GET_OFF  =  *
00:CA3F 48              	   289:          PHA
00:CA40 A004            	   290:          LDY  #SYMDSP
00:CA42 B140            	   291:          LDA  (SYMITM),Y
00:CA44 8529            	   292:          STA  OFFSET
00:CA46 C8              	   293:          INY
00:CA47 B140            	   294:          LDA  (SYMITM),Y
00:CA49 852A            	   295:          STA  OFFSET+1
00:CA4B A003            	   296:          LDY  #SYMTYP
00:CA4D B140            	   297:          LDA  (SYMITM),Y
00:CA4F C956            	   298:          CMP  #SYMBOL_VARIABLE
00:CA51 F008            	   299:          BEQ  GETO_1
00:CA53 C941            	   300:          CMP  #SYMBOL_ARRAY
00:CA55 F004            	   301:          BEQ  GETO_1
00:CA57 C959            	   302:          CMP  #SYMBOL_FUNCTION_RETURN
00:CA59 D00D            	   303:          BNE  GETO_2
                        	   304: ;
                        	   305: ;  here if the symbol is a variable, array or function return value
                        	   306: ;   subtract the offset from -3
                        	   307: ;
                        	   308: GETO_1   =  *
00:CA5B 38              	   309:          SEC
00:CA5C A9FD            	   310:          LDA  #$FD
00:CA5E E529            	   311:          SBC  OFFSET
00:CA60 8529            	   312:          STA  OFFSET
00:CA62 A9FF            	   313:          LDA  #$FF
00:CA64 E52A            	   314:          SBC  OFFSET+1
00:CA66 852A            	   315:          STA  OFFSET+1
                        	   316: GETO_2   =  *
00:CA68 68              	   317:          PLA
00:CA69 60              	   318:          RTS
                        	   319: 
                        	   320: ;
                        	   321: GET_LEV  =  *
00:CA6A A522            	   322:          LDA  LEVEL
00:CA6C A002            	   323:          LDY  #SYMLVL
00:CA6E 38              	   324:          SEC
00:CA6F F140            	   325:          SBC  (SYMITM),Y
00:CA71 8527            	   326:          STA  DISPL
00:CA73 60              	   327:          RTS
                        	   328: ;
                        	   329: GET_DAT  =  *
00:CA74 A008            	   330:          LDY  #SYMDAT
00:CA76 B140            	   331:          LDA  (SYMITM),Y
00:CA78 854A            	   332:          STA  DATTYP
00:CA7A 60              	   333:          RTS
                        	   334: ;
                        	   335: 
                        	   336: 

Source: "gpascal.asm"
                        	   199:   .include "hardware.inc"

Source: "hardware.inc"
                        	     1: 
                        	     2: ; VIA - Versatile Interface Adapter (W65C22) hardware
                        	     3: 
                        	     4: VIA_PORTB   = $7FF0   ; input/output register "B"
                        	     5: VIA_PORTA   = $7FF1   ; input/output register "A"
                        	     6: VIA_DDRB    = $7FF2   ; data direction register "B"
                        	     7: VIA_DDRA    = $7FF3   ; data direction register "A"
                        	     8: VIA_T1C_L   = $7FF4   ; T1 write: latch (L), read: counter (L)
                        	     9: VIA_T1C_H   = $7FF5   ; T1 high_order counter
                        	    10: VIA_T1L_L   = $7FF6   ; T1 low_order latches
                        	    11: VIA_T1L_H   = $7FF7   ; T1 high_order latches
                        	    12: VIA_T2C_L   = $7FF8   ; T2 write: latch (L), read: counter (L)
                        	    13: VIA_T2C_H   = $7FF9   ; T2 high_order counter
                        	    14: VIA_SR      = $7FFA   ; shift register
                        	    15: VIA_ACR     = $7FFB   ; auxilliary control register
                        	    16: VIA_PCR     = $7FFC   ; peripheral control register
                        	    17: VIA_IFR     = $7FFD   ; interrupt flag register
                        	    18: VIA_IER     = $7FFE   ; interrupt enable register
                        	    19: 
                        	    20: VIA_FLAG_ENABLE   = %10000000 ; high-order bit set enables the flag
                        	    21: VIA_FLAG_DISABLE  = %00000000 ; high-order bit clear disables the flag
                        	    22: VIA_FLAG_TIMER1   = %01000000
                        	    23: VIA_FLAG_TIMER2   = %00100000
                        	    24: VIA_FLAG_CB1      = %00010000
                        	    25: VIA_FLAG_CB2      = %00001000
                        	    26: VIA_FLAG_SHIFT    = %00000100
                        	    27: VIA_FLAG_CA1      = %00000010
                        	    28: VIA_FLAG_CA2      = %00000001
                        	    29: 
                        	    30: ;
                        	    31: ; VIA Port A pin masks
                        	    32: ;
                        	    33: 
                        	    34: SERIAL_IN_MASK     = %00000001   ; serial in on PA0 (also connect to CB2) (to FTDI TxD pin - pin 4)
                        	    35: SERIAL_OUT_MASK    = %00000010   ; serial out on PA1 (to FTDI RxD pin - pin 5)
                        	    36: SERIAL_DEBUG1_MASK = %00000100   ; serial debugging on PA2
                        	    37: SERIAL_DEBUG2_MASK = %00001000   ; serial debugging on PA3
                        	    38: SERIAL_SPARE2_MASK = %00010000   ; spare VIA pins (PA4)
                        	    39: 
                        	    40: 
                        	    41: ;***********************************************
                        	    42: ;  Functions added for Ben's Board
                        	    43: ;***********************************************
                        	    44: 
                        	    45: ;
                        	    46: ;  Converts a pin number in the range 0 to 15 to a mask
                        	    47: ;  eg. 00000001, 00000010, 00000100 and so on
                        	    48: ;
                        	    49: ;  Returns mask in Y
                        	    50: ;
                        	    51: ;  Returns with Z set if the range was 0 to 7 an
                        	    52: ;  and Z clear if the range was 8 to 15
                        	    53: ;
                        	    54: pin_number_to_mask = *
00:CA7B 48              	    55:   pha         ; save for a moment
00:CA7C 2907            	    56:   and #$7     ; make in range 0 to 7
00:CA7E A8              	    57:   tay
00:CA7F A901            	    58:   lda #1      ; initial mask
                        	    59: pin_number_to_mask_loop:
00:CA81 C000            	    60:   cpy #0
00:CA83 F004            	    61:   beq pin_number_to_mask_done
00:CA85 0A              	    62:   asl A
00:CA86 88              	    63:   dey
00:CA87 80F8            	    64:   bra pin_number_to_mask_loop
                        	    65: pin_number_to_mask_done:
00:CA89 A8              	    66:   tay         ; save mask in Y
00:CA8A 68              	    67:   pla
00:CA8B 2908            	    68:   and #$8     ; DDRA or DDRB ?
00:CA8D 60              	    69:   rts
                        	    70: 
                        	    71: ;
                        	    72: ;  pin in A, mode in X
                        	    73: ;
                        	    74: pinmode:
00:CA8E 868C            	    75:   stx hardware_work ; input or output
00:CA90 207BCA          	    76:   jsr pin_number_to_mask  ; convert to appropriate mask bit
00:CA93 D00A            	    77:   bne pinmode_B        ; Z is clear if it is DDRB
00:CA95 A9F3            	    78:   lda #<VIA_DDRA
00:CA97 8500            	    79:   sta REG
00:CA99 A97F            	    80:   lda #>VIA_DDRA
00:CA9B 8501            	    81:   sta REG+1
00:CA9D 8008            	    82:   bra pinmode_C
                        	    83: pinmode_B:
00:CA9F A9F2            	    84:   lda #<VIA_DDRB
00:CAA1 8500            	    85:   sta REG
00:CAA3 A97F            	    86:   lda #>VIA_DDRB
00:CAA5 8501            	    87:   sta REG+1
                        	    88: ;
                        	    89: ;  The DDR register is now in REG
                        	    90: ;
                        	    91: pinmode_C:
00:CAA7 A58C            	    92:   lda hardware_work     ; input or output?
00:CAA9 D00A            	    93:   bne pinmode_OUTPUT
                        	    94: ;
                        	    95: ;  here to set input mode
                        	    96: ;
00:CAAB 98              	    97:   tya       ; get the mask back
00:CAAC A000            	    98:   ldy #0
00:CAAE 49FF            	    99:   eor #$FF  ; negate the mask
00:CAB0 3100            	   100:   and (REG),y
00:CAB2 9100            	   101:   sta (REG),y
00:CAB4 60              	   102:   rts       ; done
                        	   103: ;
                        	   104: ;  here to set output mode
                        	   105: ;
                        	   106: pinmode_OUTPUT:
00:CAB5 98              	   107:   tya          ; get the mask back
00:CAB6 A000            	   108:   ldy #0
00:CAB8 1100            	   109:   ora (REG),y  ; or in with the existing DDR register
00:CABA 9100            	   110:   sta (REG),y  ; and write it back
00:CABC 60              	   111:   rts          ; done
                        	   112: 
                        	   113: 
                        	   114: ;
                        	   115: ;  DIGITALWRITE (pin, value) pin:0 to 15; value: 0 or 1 : pin in A, mode in X
                        	   116: ;
                        	   117: digitalwrite = *
00:CABD 868C            	   118:   stx hardware_work ; save what to write (0 or 1)
00:CABF 207BCA          	   119:   jsr pin_number_to_mask  ; convert to appropriate mask bit
00:CAC2 D00A            	   120:   bne digitalwrite_B        ; Z is clear if it is PORTB
00:CAC4 A9F1            	   121:   lda #<VIA_PORTA
00:CAC6 8500            	   122:   sta REG
00:CAC8 A97F            	   123:   lda #>VIA_PORTA
00:CACA 8501            	   124:   sta REG+1
00:CACC 8008            	   125:   bra digitalwrite_C
                        	   126: digitalwrite_B:
00:CACE A9F0            	   127:   lda #<VIA_PORTB
00:CAD0 8500            	   128:   sta REG
00:CAD2 A97F            	   129:   lda #>VIA_PORTB
00:CAD4 8501            	   130:   sta REG+1
                        	   131: ;
                        	   132: ;  The PORT register is now in REG
                        	   133: ;
                        	   134: digitalwrite_C:
00:CAD6 A58C            	   135:   lda hardware_work
00:CAD8 D00A            	   136:   bne digitalwrite_ONE  ; any non-zero value is writing a 1
                        	   137: ;
                        	   138: ;  here to write a zero
                        	   139: ;
00:CADA 98              	   140:   tya
00:CADB A000            	   141:   ldy #0
00:CADD 49FF            	   142:   eor #$FF  ; negate the mask
00:CADF 3100            	   143:   and (REG),y
00:CAE1 9100            	   144:   sta (REG),y
00:CAE3 60              	   145:   rts       ; done
                        	   146: 
                        	   147: ;
                        	   148: ;  here to write a one
                        	   149: ;
                        	   150: digitalwrite_ONE:
00:CAE4 98              	   151:   tya          ; get the mask back
00:CAE5 A000            	   152:   ldy #0
00:CAE7 1100            	   153:   ora (REG),y  ; or in with the existing DDR register
00:CAE9 9100            	   154:   sta (REG),y  ; and write it back
00:CAEB 60              	   155:   rts          ; done
                        	   156: 
                        	   157: 
                        	   158: ;
                        	   159: ;  DIGITALREAD (pin) pin:0 to 15; Pin to read is in in A. returns or non-zero in A.
                        	   160: ;
                        	   161: digitalread = *
00:CAEC 207BCA          	   162:   jsr pin_number_to_mask  ; convert to appropriate mask bit
00:CAEF D00A            	   163:   bne digitalread_B        ; Z is clear if it is PORTB
00:CAF1 A9F1            	   164:   lda #<VIA_PORTA
00:CAF3 8500            	   165:   sta REG
00:CAF5 A97F            	   166:   lda #>VIA_PORTA
00:CAF7 8501            	   167:   sta REG+1
00:CAF9 8008            	   168:   bra digitalread_C
                        	   169: digitalread_B:
00:CAFB A9F0            	   170:   lda #<VIA_PORTB
00:CAFD 8500            	   171:   sta REG
00:CAFF A97F            	   172:   lda #>VIA_PORTB
00:CB01 8501            	   173:   sta REG+1
                        	   174: ;
                        	   175: ;  The PORT register is now in REG
                        	   176: ;
                        	   177: digitalread_C:
00:CB03 98              	   178:   tya         ; get the mask back
00:CB04 A000            	   179:   ldy #0
00:CB06 3100            	   180:   and (REG),y ; get that bit
00:CB08 60              	   181:   rts
                        	   182: 
                        	   183: 
                        	   184: 
                        	   185: ;
                        	   186: ;  Functions to change where writing is done
                        	   187: ;
                        	   188: write_to_serial:
00:CB09 48              	   189:   pha
00:CB0A A969            	   190:   lda  #<write_char
00:CB0C 8517            	   191:   sta  write_function
00:CB0E A9CB            	   192:   lda  #>write_char
00:CB10 8518            	   193:   sta  write_function+1
00:CB12 68              	   194:   pla
00:CB13 60              	   195:   rts
                        	   196: 
                        	   197: write_to_lcd:
00:CB14 48              	   198:   pha
00:CB15 A9AE            	   199:   lda  #<lcd_print_char
00:CB17 8517            	   200:   sta  write_function
00:CB19 A9C8            	   201:   lda  #>lcd_print_char
00:CB1B 8518            	   202:   sta  write_function+1
00:CB1D 68              	   203:   pla
00:CB1E 60              	   204:   rts
                        	   205: 
                        	   206: 
                        	   207: 
                        	   208: ; ---------------------------
                        	   209: ; Simulate kernel interfaces
                        	   210: ; ---------------------------
                        	   211: ; We interface by reading/writing to special
                        	   212: ; RAM that is implemented in the emulator
                        	   213: 
                        	   214: 
                        	   215: 
                        	   216:     .if EMULATOR
                        	   217: 
                        	   218: ;
                        	   219: ;  Emulator testing
                        	   220: ;
                        	   221: CHRIN    =  *
                        	   222:          lda  $7F22
                        	   223:          rts
                        	   224: 
                        	   225: write_char   =  *
                        	   226:          sta  $7F23
                        	   227:          rts
                        	   228: 
                        	   229: 
                        	   230: GETIN    =  *
                        	   231:          lda  $7F29
                        	   232:          rts
                        	   233: 
                        	   234: hardware_init rts
                        	   235: 
                        	   236: ;
                        	   237: ;  put debug number in A
                        	   238: ;
                        	   239: EMULATOR_DEBUG = *
                        	   240:          sta $7F46
                        	   241:          rts
                        	   242: 
                        	   243: START_TRACE = *
                        	   244:          sta $7F47
                        	   245:          rts
                        	   246: 
                        	   247: STOP_TRACE = *
                        	   248:          sta $7F48
                        	   249:          rts
                        	   250: ;
                        	   251: ;  not applicable in emulator
                        	   252: ;
                        	   253: lcd_print_message   rts
                        	   254: lcd_clear_display   rts
                        	   255: lcd_print_char      rts
                        	   256: lcd_second_line     rts
                        	   257: lcd_instruction     rts
                        	   258: lcd_get_address     rts
                        	   259: lcd_wait            rts
                        	   260: lcd_home            rts
                        	   261: lcd_initialise      rts
                        	   262: serial_available    rts
                        	   263: serial_print_message rts
                        	   264: 
                        	   265:   .else
                        	   266: 
                        	   267: ;
                        	   268: ;  Ben's Board
                        	   269: ;
                        	   270: 
                        	   271: ;
                        	   272: ;  typing_latency could be used as a seed for the random number generator
                        	   273: ;    - the exact time between keypresses would be somewhat unpredictable
                        	   274: ;
                        	   275: CHRIN  = *
                        	   276: GETIN    =  *
00:CB1F E60D            	   277:          inc typing_latency
00:CB21 D006            	   278:          bne GETIN1
00:CB23 E60E            	   279:          inc typing_latency+1
00:CB25 D002            	   280:          bne GETIN1
00:CB27 E60F            	   281:          inc typing_latency+2
                        	   282: GETIN1:
00:CB29 A58B            	   283:          lda serial_in_byte_received
00:CB2B F0F2            	   284:          beq GETIN    ; nothing yet
00:CB2D 648B            	   285:          stz serial_in_byte_received
00:CB2F 60              	   286:          rts
                        	   287: 
                        	   288: serial_available = *
00:CB30 A58B            	   289:          lda serial_in_byte_received
00:CB32 60              	   290:          rts
                        	   291: 
                        	   292: 
00:CB33 60              	   293: EMULATOR_DEBUG rts
00:CB34 60              	   294: START_TRACE rts
00:CB35 60              	   295: STOP_TRACE rts
                        	   296: 
                        	   297: 
                        	   298: ;
                        	   299: ;  set up serial hardware
                        	   300: ;
                        	   301: 
                        	   302: hardware_init:
                        	   303: 
00:CB36 A902            	   304:   lda #SERIAL_OUT_MASK  ; set 1 bit (idle serial comms), and others to zero
00:CB38 8DF17F          	   305:   sta VIA_PORTA
                        	   306: 
                        	   307:   ; set output enable bits
00:CB3B A91E            	   308:   lda #(SERIAL_OUT_MASK | SERIAL_DEBUG1_MASK | SERIAL_DEBUG2_MASK | SERIAL_SPARE2_MASK)
00:CB3D 8DF37F          	   309:   sta VIA_DDRA
                        	   310: 
00:CB40 A940            	   311:   lda #%01000000      ; continuous interrupts on T1
00:CB42 8DFB7F          	   312:   sta VIA_ACR
                        	   313: 
00:CB45 A900            	   314:   lda #0              ; Input-negative active edge
00:CB47 8DFC7F          	   315:   sta VIA_PCR
                        	   316: 
00:CB4A A9D0            	   317:   lda #<BIT_INTERVAL  ; ie. baud rate interval
00:CB4C 8DF47F          	   318:   sta VIA_T1C_L       ; for sending bits
00:CB4F A900            	   319:   lda #>BIT_INTERVAL
00:CB51 8DF57F          	   320:   sta VIA_T1C_H       ; this starts the counter
                        	   321: 
                        	   322:   ; set up for serial input
                        	   323: 
00:CB54 A988            	   324:   lda #VIA_FLAG_ENABLE | VIA_FLAG_CB2  ; interrupt on CB2 falling edge
00:CB56 8DFE7F          	   325:   sta VIA_IER
                        	   326: 
00:CB59 A9FF            	   327:   lda #$FF         ; clear all interrupt flags
00:CB5B 8DFD7F          	   328:   sta VIA_IFR
                        	   329: 
                        	   330:   .if LCD_SUPPORT
00:CB5E 209FC7          	   331:   jsr lcd_initialise
                        	   332:   .endif
                        	   333: 
00:CB61 648A            	   334:   stz serial_in_byte    ; non-zero means an interrupt put in incoming byte there
00:CB63 6489            	   335:   stz serial_out_bit
00:CB65 6468            	   336:   stz spi_mode          ; default to SPI mode zero
                        	   337: 
00:CB67 58              	   338:   cli         ; enable interrupts
00:CB68 60              	   339:   rts
                        	   340: 
                        	   341: 
                        	   342: ;
                        	   343: ;  Write a character (in A) to the serial port.
                        	   344: ;   Interrupts MUST be enabled for this to work!
                        	   345: ;
                        	   346: write_char:
00:CB69 48              	   347:   pha                   ; save original character
00:CB6A 0A              	   348:   asl a                 ; shift in a zero which will be the start bit
00:CB6B 8587            	   349:   sta serial_out_byte
00:CB6D A9FF            	   350:   lda #0xff             ; will become the stop bit(s)
00:CB6F 2A              	   351:   rol a                 ; rotate in the high-order bit from the data byte
00:CB70 8588            	   352:   sta serial_out_byte+1
00:CB72 A90B            	   353:   lda #11               ; 8 data bits, one start bit, two stop bits
00:CB74 8589            	   354:   sta serial_out_bit    ; number of bits to shift out
00:CB76 A9D0            	   355:   lda #<BIT_INTERVAL    ; ie. baud rate interval
00:CB78 8DF47F          	   356:   sta VIA_T1C_L         ; for sending bits
00:CB7B A900            	   357:   lda #>BIT_INTERVAL
00:CB7D 8DF57F          	   358:   sta VIA_T1C_H         ; this starts the counter
00:CB80 A9C0            	   359:   lda #VIA_FLAG_ENABLE | VIA_FLAG_TIMER1  ; interrupt on T1 timeout
00:CB82 8DFE7F          	   360:   sta VIA_IER
                        	   361: 
                        	   362: ;
                        	   363: ; wait for this byte to finish - otherwise it might interfere with many things
                        	   364: ;
                        	   365: 
                        	   366: write_char_loop:
00:CB85 ADFE7F          	   367:   lda VIA_IER
00:CB88 2940            	   368:   and #VIA_FLAG_TIMER1  ; are T1 interrupts enabled?
00:CB8A D0F9            	   369:   bne write_char_loop   ; loop until this character sent
00:CB8C 68              	   370:   pla                   ; get character back
00:CB8D 60              	   371:   rts
                        	   372: 
                        	   373: 
                        	   374: ;
                        	   375: ;  sends null-terminated message to serial port, message in A (lo) and X (hi)
                        	   376: ;  returns the length of the message in Y
                        	   377: ;
                        	   378: serial_print_message:
00:CB8E 8503            	   379:   sta REG2
00:CB90 8604            	   380:   stx REG2+1
00:CB92 A000            	   381:   ldy #0
                        	   382: serial_print:
00:CB94 B103            	   383:   lda (REG2),y
00:CB96 F006            	   384:   beq serial_print_done
00:CB98 2069CB          	   385:   jsr write_char
00:CB9B C8              	   386:   iny
00:CB9C 80F6            	   387:   bra serial_print
                        	   388: 
00:CB9E 60              	   389: serial_print_done rts
                        	   390: 
                        	   391:   .endif  ; not EMULATOR
                        	   392: 
                        	   393: 

Source: "gpascal.asm"
                        	   200:   .include "gtoken.inc"

Source: "gtoken.inc"
                        	     1: ;
                        	     2: ;  get_token
                        	     3: ;
                        	     4: ;  Gets a lexical token from the specified address.
                        	     5: ;
                        	     6: ;  - Start parsing at token_start (this should be the first character of the token)
                        	     7: ;  - The first found character (after spaces, comments, newlines) is in token_address
                        	     8: ;      - this is mainly used for knowing what the identifier is so we can put it in the symbol table
                        	     9: ;      - strings are put into INBUF after processing, so token_address is not as useful in that case
                        	    10: ;  - The length is in token_length (in the case of strings, this is the processed length)
                        	    11: ;  - The type is in token_type - zero would mean end of file
                        	    12: ;
                        	    13: ;  The types are one of the token codes below
                        	    14: ;
                        	    15: ;  Tokens which start with a letter and are possibly followed by letters, numbers, and
                        	    16: ;    the underscore character become TOKEN_IDENTIFIER.
                        	    17: ;
                        	    18: ;  Tokens starting with a number (TOKEN_NUMBER) are parsed for the value which is placed into token_value.
                        	    19: ;
                        	    20: ;  Tokens starting with a single or double quote are parsed for the internal string (TOKEN_STRING)
                        	    21: ;  which is placed in INBUF. The internal string has internal double-quotes turned
                        	    22: ;  into single quotes, and sequences like \n or \x42 turned into their appropriate characters.
                        	    23: ;
                        	    24: ;  String tokens which are up to 3 bytes long also have the 3 bytes placed into token_value.
                        	    25: ;
                        	    26: ;  Hex and binary tokens are parsed for their value which is placed into token_value.
                        	    27: ;
                        	    28: ;  Various 2-character tokens are given their own code (eg. <> == != := << >> and so on).
                        	    29: ;
                        	    30: ;  Spaces and comments are skipped, however Pascal directives inside comments are processed
                        	    31: ;
                        	    32: ;  Newlines are skipped in Pascal but returned as a token in assembler (ASSEMBLING == true)
                        	    33: ;  If newlines are skipped then token_line is called to handle listing the line (the line
                        	    34: ;   we are about to process, not the previous line)
                        	    35: ;
                        	    36: ; Rewritten in February 2022 to be easier to read and have well-defined work variables (zero-page variables)
                        	    37: 
                        	    38: ; multi-byte token codes (single byte tokens are themselves)
                        	    39: 
                        	    40: TOKEN_ASSIGN     = 'A'   ; :=
                        	    41: TOKEN_IDENTIFIER = 'I'   ; alpha-numeric identifiers
                        	    42: TOKEN_NUMBER     = 'N'   ; numbers
                        	    43: TOKEN_STRING     = '"'   ; string literal
                        	    44: TOKEN_LEQ        = $80   ; <=
                        	    45: TOKEN_GEQ        = $81   ; >=
                        	    46: TOKEN_NEQ        = 'U'   ; <>
                        	    47: 
                        	    48: ;
                        	    49: ;  the ones below are used in the assembler
                        	    50: ;
                        	    51: TOKEN_EQUALITY    = 'E'     ; ==
                        	    52: TOKEN_SHIFT_LEFT  = 'L'     ; <<
                        	    53: TOKEN_SHIFT_RIGHT = 'R'     ; >>
                        	    54: TOKEN_UNARY_MINUS = 'M'     ; -
                        	    55: TOKEN_LOW_BYTE    = 'V'     ; eg. lda #<foo
                        	    56: TOKEN_HIGH_BYTE   = 'W'     ; eg. lda #>foo
                        	    57: TOKEN_LOGICAL_AND = 'X'     ; &&
                        	    58: TOKEN_LOGICAL_OR  = 'Y'     ; ||
                        	    59: TOKEN_INEQUALITY  = 'Z'     ; !=
                        	    60: 
                        	    61: 
                        	    62: get_token:
00:CB9F A593            	    63:   lda token_type      ; remember previous token for checking if + or - stand on their own
00:CBA1 8598            	    64:   sta token_work
                        	    65: get_token_loop:
00:CBA3 A000            	    66:   ldy #0              ; offset into the token address
00:CBA5 8497            	    67:   sty token_sign      ; Y is zero at this point
00:CBA7 8494            	    68:   sty token_value     ; no value yet
00:CBA9 8495            	    69:   sty token_value+1
00:CBAB 8496            	    70:   sty token_value+2
                        	    71: 
                        	    72: gc_skip_spaces:
00:CBAD B18E            	    73:   lda (token_start),y
00:CBAF F034            	    74:   beq gc_done         ; 0x00 means end, so return it WITHOUT incrementing the pointer
00:CBB1 C90A            	    75:   cmp #NL             ; newline need special handling
00:CBB3 F00D            	    76:   beq gc_newline
00:CBB5 204A81          	    77:   jsr isspace
00:CBB8 9043            	    78:   bcc gc_not_space
00:CBBA E68E            	    79:   inc token_start     ; increment pointer because spaces can be any length
00:CBBC D0EF            	    80:   bne gc_skip_spaces
00:CBBE E68F            	    81:   inc token_start+1
00:CBC0 80EB            	    82:   bra gc_skip_spaces
                        	    83: 
                        	    84: ;
                        	    85: ;  got a newline - if assembling, return that so we know where lines end
                        	    86: ;  otherwise just call token_line to display the next line and press on looking
                        	    87: ;  for tokens.
                        	    88: ;
                        	    89: gc_newline:
00:CBC2 A902            	    90:   lda #FLAG_ASSEMBLING
00:CBC4 25BE            	    91:   and system_flags
00:CBC6 D014            	    92:   bne gc_newline_assembling    ; return the newline as a token
00:CBC8 C8              	    93:   iny              ; length in Y (ie. one)
00:CBC9 E68E            	    94:   inc token_start
00:CBCB D002            	    95:   bne gc_newline1
00:CBCD E68F            	    96:   inc token_start+1
                        	    97: gc_newline1:
00:CBCF A58E            	    98:   lda token_start
00:CBD1 859C            	    99:   sta token_line_start
00:CBD3 A58F            	   100:   lda token_start+1
00:CBD5 859D            	   101:   sta token_line_start+1
00:CBD7 203FCC          	   102:   jsr token_line        ; list the next line
00:CBDA 80C7            	   103:   bra get_token_loop    ; look for another token
                        	   104: 
                        	   105: gc_newline_assembling:
00:CBDC A90A            	   106:   lda #NL       ; get the newline back
00:CBDE 4CE3CB          	   107:   jmp gc_single_byte_token
                        	   108: 
                        	   109: ;
                        	   110: ;  wrap up getting a token:
                        	   111: ;
                        	   112: ;   - save the type
                        	   113: ;   - save the current address as token_address
                        	   114: ;   - add the length to token_start ready for next time
                        	   115: ;
                        	   116: gc_single_byte_already_known:
00:CBE1 A593            	   117:   lda token_type        ; get back saved token type
                        	   118: gc_single_byte_token:
00:CBE3 A001            	   119:   ldy #1
                        	   120: gc_done:
00:CBE5 8492            	   121:   sty token_length      ; Y has our length
00:CBE7 8593            	   122:   sta token_type        ; A has our type
00:CBE9 18              	   123:   clc
00:CBEA A58E            	   124:   lda token_start
00:CBEC 8590            	   125:   sta token_address     ; save the starting address of the token
00:CBEE 6592            	   126:   adc token_length      ; now add its length
00:CBF0 858E            	   127:   sta token_start       ; that gives the ending address
                        	   128: 
00:CBF2 A58F            	   129:   lda token_start+1     ; repeat for high-order byte
00:CBF4 8591            	   130:   sta token_address+1
00:CBF6 6900            	   131:   adc #0
00:CBF8 858F            	   132:   sta token_start+1
                        	   133: 
00:CBFA A593            	   134:   lda token_type        ; get token type back into A
00:CBFC 60              	   135:   rts
                        	   136: 
                        	   137: ;
                        	   138: ;  not a space (or newline) so this must be the actual start of it
                        	   139: ;
                        	   140: 
                        	   141: gc_not_space:
                        	   142: 
                        	   143: ;
                        	   144: ;  first look for classes of characters (ie. alpha, numeric)
                        	   145: ;
00:CBFD 202681          	   146:   jsr isalpha
00:CC00 9026            	   147:   bcc gc_not_alpha
                        	   148: 
                        	   149: ;
                        	   150: ;  find end of identifier
                        	   151: ;
                        	   152: gc_alpha_loop:
00:CC02 C8              	   153:   iny
00:CC03 D005            	   154:   bne gc_alpha_ok   ; if it becomes zero now, we have 256+ long identifier
00:CC05 A20C            	   155:   ldx #12       ; ERROR: Illegal Identifier (too long)
00:CC07 4CE099          	   156:   jmp ERROR
                        	   157: 
                        	   158: gc_alpha_ok:
00:CC0A A940            	   159:   lda #FLAG_ONLY_ALPHA
00:CC0C 24BE            	   160:   bit system_flags
00:CC0E D00F            	   161:   bne gc_alpha_alpha_only
00:CC10 B18E            	   162:   lda (token_start),y
00:CC12 206281          	   163:   jsr isalnum
00:CC15 B0EB            	   164:   bcs gc_alpha_loop
00:CC17 C95F            	   165:   cmp #'_'
00:CC19 F0E7            	   166:   beq gc_alpha_loop
                        	   167: 
                        	   168: ;
                        	   169: ; end of identifier
                        	   170: ;
                        	   171: gc_alpha_done:
00:CC1B A949            	   172:   lda #TOKEN_IDENTIFIER
00:CC1D 80C6            	   173:   bra gc_done
                        	   174: 
                        	   175: 
                        	   176: gc_alpha_alpha_only:
00:CC1F B18E            	   177:   lda (token_start),y
00:CC21 202681          	   178:   jsr isalpha
00:CC24 B0DC            	   179:   bcs gc_alpha_loop
00:CC26 80F3            	   180:   bra gc_alpha_done
                        	   181: 
                        	   182: ;
                        	   183: ; now see if it is a digit
                        	   184: ;
                        	   185: gc_not_alpha:
00:CC28 203281          	   186:   jsr isdigit
00:CC2B 9007            	   187:   bcc gc_not_digit
                        	   188: 
00:CC2D 208ECC          	   189:   jsr atoi
00:CC30 A94E            	   190:   lda  #TOKEN_NUMBER
00:CC32 80B1            	   191:   bra  gc_done
                        	   192: 
                        	   193: ;
                        	   194: ;  not alpha and not digit - so let's consider:
                        	   195: ;   * prefixes: $ for hex and % for binary
                        	   196: ;   *  + or - in front of numbers or on their own
                        	   197: ;   * single character tokens, eg. =, (, ) and so on
                        	   198: ;   * double-character tokens, eg. ==, >= << and so on
                        	   199: ;   * strings, eg. "foo"
                        	   200: ;
                        	   201: ;  we'll do a jump on the first character
                        	   202: ;
                        	   203: gc_not_digit:
00:CC34 8593            	   204:   sta token_type            ; remember it in case of possible two-byte sequences
00:CC36 A21C            	   205:   ldx #<gtoken_table
00:CC38 A0CD            	   206:   ldy #>gtoken_table
00:CC3A 208F91          	   207:   jsr TKNJMP
00:CC3D 80A2            	   208:   bra gc_single_byte_already_known  ; it is what it is
                        	   209: 
                        	   210: ;
                        	   211: ;  here when get_token discovers a newline - print the next line if wanted
                        	   212: ;
                        	   213: 
                        	   214: token_line:
                        	   215: ;
                        	   216: ;  count lines
                        	   217: ;
00:CC3F E6A2            	   218:   inc current_line
00:CC41 D002            	   219:   bne token_line1
00:CC43 E6A3            	   220:   inc current_line+1
                        	   221: token_line1:
                        	   222: ;
                        	   223: ;  compiling or assembling?
                        	   224: ;
00:CC45 A901            	   225:   lda #FLAG_COMPILING
00:CC47 0902            	   226:   ora #FLAG_ASSEMBLING
00:CC49 25BE            	   227:   and system_flags
00:CC4B F040            	   228:   beq token_line_done ; no - no listing
                        	   229: ;
                        	   230: ;  listing wanted?
                        	   231: ;
00:CC4D A904            	   232:   lda #FLAG_LIST_SOURCE
00:CC4F 25BE            	   233:   and system_flags
00:CC51 D00D            	   234:   bne token_line_listing ; yes
                        	   235: 
                        	   236: ;
                        	   237: ;  no listing - show an asterisk every 15 lines
                        	   238: ;
00:CC53 A5A2            	   239:   lda current_line
00:CC55 290F            	   240:   and #$0F
00:CC57 D034            	   241:   bne token_line_done
00:CC59 A92A            	   242:   lda #'*'
00:CC5B 20B395          	   243:   jsr COUT
00:CC5E 802D            	   244:   bra token_line_done
                        	   245: 
                        	   246: token_line_listing:
00:CC60 A52E            	   247:   lda DCODE
00:CC62 48              	   248:   pha
00:CC63 A901            	   249:   lda #1
00:CC65 852E            	   250:   sta DCODE
00:CC67 204094          	   251:   jsr DISPAD
00:CC6A 68              	   252:   pla
00:CC6B 852E            	   253:   sta DCODE
00:CC6D 20478C          	   254:   jsr show_current_line_number
                        	   255: 
00:CC70 A59C            	   256:   lda token_line_start
00:CC72 8598            	   257:   sta token_work
00:CC74 A59D            	   258:   lda token_line_start+1
00:CC76 8599            	   259:   sta token_work+1
                        	   260: 
                        	   261: token_line_loop:
00:CC78 A000            	   262:   ldy #0
00:CC7A B198            	   263:   lda (token_work),Y
00:CC7C F00F            	   264:   beq token_line_done
00:CC7E 48              	   265:   pha
00:CC7F 20B395          	   266:   jsr COUT
00:CC82 E698            	   267:   inc token_work
00:CC84 D002            	   268:   bne token_line_loop1
00:CC86 E699            	   269:   inc token_work+1
                        	   270: token_line_loop1:
00:CC88 68              	   271:   pla
00:CC89 C90A            	   272:   cmp #NL
00:CC8B D0EB            	   273:   bne token_line_loop
                        	   274: 
                        	   275: token_line_done:
00:CC8D 60              	   276:   rts
                        	   277: 
                        	   278: 
                        	   279: ;
                        	   280: ;  atoi
                        	   281: ;
                        	   282: ; get a decimal number - returns carry flag set if bad number and running
                        	   283: ;   (if compiling and a bad number gives an error)
                        	   284: ;
                        	   285: ;  token_start : the start address of the number
                        	   286: ;  Y : offset into token_start
                        	   287: ;  token_sign : non-zero if negative
                        	   288: ;
                        	   289: ;  returns: token_value  and carry clear (if no error)
                        	   290: ;           carry set if error (for use at runtime)
                        	   291: ;           Y at offset of first non-numeric character
                        	   292: 
                        	   293: atoi:
00:CC8E 38              	   294:   sec
00:CC8F E930            	   295:   sbc  #'0'   ;  ; subtract out ASCII stuff, save first digit
00:CC91 8594            	   296:   sta  token_value
00:CC93 6495            	   297:   stz  token_value+1
00:CC95 6496            	   298:   stz  token_value+2
                        	   299: atoi_loop    =  *
00:CC97 C8              	   300:   iny
00:CC98 B18E            	   301:   lda  (token_start),y
00:CC9A 203281          	   302:   jsr  isdigit
00:CC9D B009            	   303:   bcs  atoi_more      ; more digits
                        	   304: ;
                        	   305: ; end of number - make negative if we got a sign earlier
                        	   306: ;
00:CC9F A597            	   307:   lda  token_sign
00:CCA1 F003            	   308:   beq  atoi_positive    ; not signed
                        	   309: ;
                        	   310: ;  make negative
                        	   311: ;
00:CCA3 2008CD          	   312:   jsr negate_token_value
                        	   313: ;
                        	   314: ;  done! clear carry and return
                        	   315: ;
                        	   316: atoi_positive:
00:CCA6 18              	   317:   clc                   ; indicate no error for numeric conversion
00:CCA7 60              	   318:   rts
                        	   319: ;
                        	   320: ;  Multiply previous value by 10, add in new digit
                        	   321: ;
                        	   322: atoi_more    =  *
00:CCA8 38              	   323:   sec
00:CCA9 E930            	   324:   sbc  #'0'
00:CCAB 859B            	   325:   sta  token_digit
00:CCAD 0694            	   326:   asl  token_value         ; multiply token_value by 2
00:CCAF 2695            	   327:   rol  token_value+1
00:CCB1 2696            	   328:   rol  token_value+2
00:CCB3 3048            	   329:   bmi  atoi_error
                        	   330: 
00:CCB5 A594            	   331:   lda  token_value         ; save token_value*2 in token_work
00:CCB7 8598            	   332:   sta  token_work
00:CCB9 A595            	   333:   lda  token_value+1
00:CCBB 8599            	   334:   sta  token_work+1
00:CCBD A596            	   335:   lda  token_value+2
00:CCBF 859A            	   336:   sta  token_work+2
                        	   337: 
00:CCC1 0694            	   338:   asl  token_value         ; now token_value is multiplied by 4
00:CCC3 2695            	   339:   rol  token_value+1
00:CCC5 2696            	   340:   rol  token_value+2
00:CCC7 3034            	   341:   bmi  atoi_error
                        	   342: 
00:CCC9 0694            	   343:   asl  token_value         ; now token_value is multiplied by 8
00:CCCB 2695            	   344:   rol  token_value+1
00:CCCD 2696            	   345:   rol  token_value+2
00:CCCF 302C            	   346:   bmi  atoi_error
                        	   347: 
00:CCD1 A598            	   348:   lda  token_work          ; now add back in token_value*2 (giving token_value*10)
00:CCD3 6594            	   349:   adc  token_value
00:CCD5 8594            	   350:   sta  token_value
00:CCD7 A599            	   351:   lda  token_work+1
00:CCD9 6595            	   352:   adc  token_value+1
00:CCDB 8595            	   353:   sta  token_value+1
00:CCDD A59A            	   354:   lda  token_work+2
00:CCDF 6596            	   355:   adc  token_value+2
00:CCE1 8596            	   356:   sta  token_value+2
00:CCE3 3018            	   357:   bmi  atoi_error      ; if negative, the number was too big
00:CCE5 18              	   358:   clc
00:CCE6 A594            	   359:   lda  token_value     ; now take the value and add in our new digit
00:CCE8 659B            	   360:   adc  token_digit
00:CCEA 8594            	   361:   sta  token_value
00:CCEC A900            	   362:   lda #0
00:CCEE 6595            	   363:   adc  token_value+1   ; increment next byte if necessary
00:CCF0 8595            	   364:   sta  token_value+1
00:CCF2 A900            	   365:   lda #0
00:CCF4 6596            	   366:   adc  token_value+2
00:CCF6 8596            	   367:   sta  token_value+2
00:CCF8 3003            	   368:   bmi  atoi_error
00:CCFA 4C97CC          	   369:   jmp  atoi_loop     ; onwards for next digit
                        	   370: 
                        	   371: atoi_error    =  *
00:CCFD A53F            	   372:   lda  RUNNING
00:CCFF 1002            	   373:   bpl  atoi_not_running
00:CD01 38              	   374:   sec             ; otherwise set carry and return
00:CD02 60              	   375:   rts
                        	   376: atoi_not_running  =  *
00:CD03 A21E            	   377:   ldx  #30       ; ERROR: Number out of Range
00:CD05 4CE099          	   378:   jmp  ERROR
                        	   379: 
                        	   380: ;
                        	   381: ;  for negative numbers, subtract token_value from zero
                        	   382: ;
                        	   383: negate_token_value:
00:CD08 38              	   384:   sec
00:CD09 A900            	   385:   lda  #0
00:CD0B E594            	   386:   sbc  token_value
00:CD0D 8594            	   387:   sta  token_value
00:CD0F A900            	   388:   lda  #0
00:CD11 E595            	   389:   sbc  token_value+1
00:CD13 8595            	   390:   sta  token_value+1
00:CD15 A900            	   391:   lda  #0
00:CD17 E596            	   392:   sbc  token_value+2
00:CD19 8596            	   393:   sta  token_value+2
00:CD1B 60              	   394:   rts
                        	   395: 
                        	   396: 
                        	   397: gtoken_table:
                        	   398: ;
                        	   399: ;  Pascal comments
                        	   400: ;
                        	   401:   .if USE_PASCAL
                        	   402:   tknjmpItem '(',gc_lh_paren
00:CD1C 28              	     1M    dfb   '('
00:CD1D 64CD            	     2M    word  gc_lh_paren
                        	   403:   tknjmpItem '{',gc_lh_brace
00:CD1F 7B              	     1M    dfb   '{'
00:CD20 60CD            	     2M    word  gc_lh_brace
                        	   404:   .endif    ; USE_PASCAL
                        	   405: ;
                        	   406: ;  Assembler comments
                        	   407: ;
                        	   408:   .if USE_ASSEMBLER
                        	   409:   tknjmpItem ';',gc_semicolon
00:CD22 3B              	     1M    dfb   ';'
00:CD23 1ACE            	     2M    word  gc_semicolon
                        	   410:   .endif  ; USE_ASSEMBLER
                        	   411: 
                        	   412: ;
                        	   413: ;  Other tokens which need special processing
                        	   414: ;
                        	   415:   tknjmpItem '"',gc_quote             ; quoted string
00:CD25 22              	     1M    dfb   '"'
00:CD26 53CE            	     2M    word  gc_quote             
                        	   416:   tknjmpItem SINGLE_QUOTE,gc_quote    ; quoted string
00:CD28 27              	     1M    dfb   SINGLE_QUOTE
00:CD29 53CE            	     2M    word  gc_quote    
                        	   417:   tknjmpItem '$',gc_dollar            ; hex literal
00:CD2B 24              	     1M    dfb   '$'
00:CD2C 21CF            	     2M    word  gc_dollar            
                        	   418:   tknjmpItem '%',gc_percent           ; binary literal
00:CD2E 25              	     1M    dfb   '%'
00:CD2F 7BCF            	     2M    word  gc_percent           
                        	   419:   tknjmpItem ':',gc_colon             ; might be :=
00:CD31 3A              	     1M    dfb   ':'
00:CD32 A5CF            	     2M    word  gc_colon             
                        	   420:   tknjmpItem '<',gc_less_than         ; might be <= or <>
00:CD34 3C              	     1M    dfb   '<'
00:CD35 B6CF            	     2M    word  gc_less_than         
                        	   421:   tknjmpItem '>',gc_greater_than      ; might be >=
00:CD37 3E              	     1M    dfb   '>'
00:CD38 D9CF            	     2M    word  gc_greater_than      
                        	   422:   tknjmpItem '-',gc_minus             ; might be start of numeric literal
00:CD3A 2D              	     1M    dfb   '-'
00:CD3B F3CF            	     2M    word  gc_minus             
                        	   423:   tknjmpItem '+',gc_plus              ; might be start of numeric literal
00:CD3D 2B              	     1M    dfb   '+'
00:CD3E F5CF            	     2M    word  gc_plus              
                        	   424:   tknjmpItem '&',gc_ampersand         ; might be &&
00:CD40 26              	     1M    dfb   '&'
00:CD41 14D0            	     2M    word  gc_ampersand         
                        	   425:   tknjmpItem '|',gc_bar               ; might be ||
00:CD43 7C              	     1M    dfb   '|'
00:CD44 25D0            	     2M    word  gc_bar               
                        	   426:   tknjmpItem '=',gc_equals            ; might be ==
00:CD46 3D              	     1M    dfb   '='
00:CD47 36D0            	     2M    word  gc_equals            
                        	   427:   tknjmpItem '!',gc_bang              ; might be !=
00:CD49 21              	     1M    dfb   '!'
00:CD4A 47D0            	     2M    word  gc_bang              
                        	   428: 
00:CD4C 00              	   429:   dfb        0   ; end of table
                        	   430: 
                        	   431:   .if USE_PASCAL
                        	   432: gtoken_directive_table:
                        	   433:   tknjmpItem 'S',gc_directive_symbols
00:CD4D 53              	     1M    dfb   'S'
00:CD4E CCCD            	     2M    word  gc_directive_symbols
                        	   434:   tknjmpItem 'L',gc_directive_list
00:CD50 4C              	     1M    dfb   'L'
00:CD51 04CE            	     2M    word  gc_directive_list
                        	   435:   tknjmpItem 'P',gc_directive_pcodes
00:CD53 50              	     1M    dfb   'P'
00:CD54 0BCE            	     2M    word  gc_directive_pcodes
                        	   436:   tknjmpItem 'N',gc_directive_nolist
00:CD56 4E              	     1M    dfb   'N'
00:CD57 11CE            	     2M    word  gc_directive_nolist
00:CD59 00              	   437:   dfb        0
                        	   438:   .endif    ; USE_PASCAL
                        	   439: 
                        	   440: ; single byte token, in A
00:CD5A 4CE3CB          	   441: gc_single_byte_tokenJ jmp gc_single_byte_token
                        	   442: ; single byte token in token_type
00:CD5D 4CE1CB          	   443: gc_single_byte_already_knownJ jmp gc_single_byte_already_known
                        	   444: 
                        	   445:   .if USE_PASCAL
                        	   446: 
                        	   447: gc_lh_brace:
00:CD60 A000            	   448:   ldy #0
00:CD62 800E            	   449:   bra gc_pascal_comment
                        	   450: gc_lh_paren:
00:CD64 A902            	   451:   lda #FLAG_ASSEMBLING
00:CD66 25BE            	   452:   and system_flags
00:CD68 D0F3            	   453:   bne gc_single_byte_already_knownJ
00:CD6A A001            	   454:   ldy #1
00:CD6C B18E            	   455:   lda (token_start),Y
00:CD6E C92A            	   456:   cmp #'*'      ; was it: (* ?
00:CD70 D0EB            	   457:   bne gc_single_byte_already_knownJ  ; nope
                        	   458: 
                        	   459: ;
                        	   460: ;  Y will be 0 or 1 depending on the sort of starting comment
                        	   461: ;  first look for % which indicates a compiler directive
                        	   462: ;
                        	   463: gc_pascal_comment:
00:CD72 C8              	   464:   iny
00:CD73 B18E            	   465:   lda (token_start),Y
00:CD75 C925            	   466:   cmp #'%'   ; directive?
00:CD77 D018            	   467:   bne gc_pascal_comment_find_end
00:CD79 C8              	   468:   iny
00:CD7A B18E            	   469:   lda (token_start),Y ; get the directive: S, L, P or N
00:CD7C 48              	   470:   pha   ; save the directive for now
00:CD7D 98              	   471:   tya
                        	   472: ;
                        	   473: ;  make token_start point to where we are up to, so we can skip the comment, even if it is long
                        	   474: ;
00:CD7E 38              	   475:   sec               ; I actually want to be one past where the directive letter is
00:CD7F 658E            	   476:   adc token_start
00:CD81 858E            	   477:   sta token_start
00:CD83 A900            	   478:   lda #0
00:CD85 658F            	   479:   adc token_start+1
00:CD87 858F            	   480:   sta token_start+1
00:CD89 68              	   481:   pla   ; get the directive back
00:CD8A A24D            	   482:   ldx #<gtoken_directive_table
00:CD8C A0CD            	   483:   ldy #>gtoken_directive_table
00:CD8E 208F91          	   484:   jsr TKNJMP  ; do the directive handler
                        	   485: ;
                        	   486: ;  fall through if not found and just find the end of the comment
                        	   487: ;
                        	   488: 
                        	   489: gc_pascal_comment_find_end:
00:CD91 A000            	   490:   ldy #0    ; we normalised token_start to be where we want to start
00:CD93 B18E            	   491:   lda (token_start),Y
00:CD95 D005            	   492:   bne gc_comment_not_eof
00:CD97 A207            	   493:   ldx  #7           ; NO } FOUND
00:CD99 4CE099          	   494:   jmp  ERROR
                        	   495: gc_comment_not_eof:
00:CD9C C90A            	   496:   cmp #NL
00:CD9E D005            	   497:   bne gc_comment_not_newline
00:CDA0 203FCC          	   498:   jsr token_line    ; handle the newline (we can't be assembling or we wouldn't be here)
00:CDA3 800F            	   499:   bra gc_comment_keep_looking
                        	   500: gc_comment_not_newline:
00:CDA5 C97D            	   501:   cmp #'}'
00:CDA7 F013            	   502:   beq gc_comment_found_end
00:CDA9 C92A            	   503:   cmp #'*'
00:CDAB D007            	   504:   bne gc_comment_keep_looking
00:CDAD C8              	   505:   iny
00:CDAE B18E            	   506:   lda (token_start),Y
00:CDB0 C929            	   507:   cmp #')'
00:CDB2 F008            	   508:   beq gc_comment_found_end
                        	   509: 
                        	   510: ;
                        	   511: ;  skip this byte and keep looking for the end of comment
                        	   512: ;
                        	   513: gc_comment_keep_looking:
00:CDB4 E68E            	   514:   inc token_start
00:CDB6 D0D9            	   515:   bne gc_pascal_comment_find_end
00:CDB8 E68F            	   516:   inc token_start+1
00:CDBA 80D5            	   517:   bra gc_pascal_comment_find_end
                        	   518: 
                        	   519: ;
                        	   520: ;  found end of comment, so move token_start to this character
                        	   521: ;   (the one past the end of the comment) and try again for a token
                        	   522: ;
                        	   523: gc_comment_found_end:
00:CDBC C8              	   524:   iny   ; get past end of comment
00:CDBD 98              	   525:   tya
00:CDBE 18              	   526:   clc
00:CDBF 658E            	   527:   adc token_start
00:CDC1 858E            	   528:   sta token_start
00:CDC3 A900            	   529:   lda #0
00:CDC5 658F            	   530:   adc token_start+1
00:CDC7 858F            	   531:   sta token_start+1
00:CDC9 4CA3CB          	   532:   jmp get_token_loop
                        	   533: 
                        	   534: ;
                        	   535: ;  {%S $nnnn}
                        	   536: ;  symbol table relocation
                        	   537: ;
                        	   538: gc_directive_symbols:
00:CDCC 20A3CB          	   539:    jsr  get_token_loop     ; re-call get_token to find the address
00:CDCF C94E            	   540:    cmp  #TOKEN_NUMBER ; number?
00:CDD1 F005            	   541:    beq  gc_directive_symbols_ok      ; yes
00:CDD3 A202            	   542:    ldx  #2
00:CDD5 4CE099          	   543:    jmp  ERROR      ; 'Constant expected'
                        	   544: 
                        	   545: gc_directive_symbols_ok:
                        	   546:   ;
                        	   547:   ;  check we haven't generated any code
                        	   548:   ;
00:CDD8 A523            	   549:   lda PCODE
00:CDDA C525            	   550:   cmp ACT_PCDA
00:CDDC D021            	   551:   bne gc_directive_symbols_too_late
00:CDDE A524            	   552:   lda PCODE+1
00:CDE0 C526            	   553:   cmp ACT_PCDA+1
00:CDE2 D01B            	   554:   bne gc_directive_symbols_too_late
                        	   555: 
00:CDE4 A594            	   556:   lda  token_value
00:CDE6 8531            	   557:   sta  ENDSYM
00:CDE8 852F            	   558:   sta  STARTSYM
00:CDEA 852B            	   559:   sta  OPND
00:CDEC A595            	   560:   lda  token_value+1
00:CDEE 8532            	   561:   sta  ENDSYM+1        ; store symbol table address
00:CDF0 8530            	   562:   sta  STARTSYM+1
00:CDF2 852C            	   563:   sta  OPND+1
00:CDF4 A901            	   564:   lda  #PCODE_STACK    ; change runtime stack
00:CDF6 2028BD          	   565:   jsr  GENJMP
                        	   566: ;
                        	   567: ;  put the library functions back
                        	   568: ;
00:CDF9 20F5BB          	   569:   jsr  add_pascal_library_functions
                        	   570: 
00:CDFC 4C91CD          	   571:   jmp  gc_pascal_comment_find_end     ; go back and find the end of the comment
                        	   572: ;
                        	   573: 
                        	   574: gc_directive_symbols_too_late:
00:CDFF A233            	   575:   ldx #51        ; code already generated
00:CE01 4CE099          	   576:   JMP  ERROR
                        	   577: 
                        	   578: 
                        	   579: ;
                        	   580: ;  {%L} - list source
                        	   581: ;
                        	   582: gc_directive_list:
00:CE04 A904            	   583:   lda #FLAG_LIST_SOURCE
00:CE06 04BE            	   584:   tsb system_flags
00:CE08 4C91CD          	   585:   jmp gc_pascal_comment_find_end
                        	   586: 
                        	   587: ;
                        	   588: ;  {%P} - list source and P-codes
                        	   589: ;
                        	   590: gc_directive_pcodes:
00:CE0B A901            	   591:   lda #1
00:CE0D 852E            	   592:   sta DCODE
00:CE0F 80F3            	   593:   bra gc_directive_list   ; also list source
                        	   594: ;
                        	   595: ;  {%N} - do not list source or P-codes
                        	   596: ;
                        	   597: gc_directive_nolist:
00:CE11 A904            	   598:   lda #FLAG_LIST_SOURCE
00:CE13 14BE            	   599:   trb system_flags    ; clear both of the above flags
00:CE15 642E            	   600:   stz DCODE
00:CE17 4C91CD          	   601:   jmp gc_pascal_comment_find_end
                        	   602: 
                        	   603:   .endif   ; USE_PASCAL
                        	   604: 
                        	   605:   .if USE_ASSEMBLER
                        	   606: ;
                        	   607: ;  semicolons start comments in the assembler
                        	   608: ;
                        	   609: gc_semicolon:
00:CE1A A902            	   610:   lda #FLAG_ASSEMBLING
00:CE1C 25BE            	   611:   and system_flags
00:CE1E D003            	   612:   bne gc_assembler_comment_find_end
00:CE20 4CE1CB          	   613:   jmp gc_single_byte_already_known
                        	   614: 
                        	   615: gc_assembler_comment_find_end:
00:CE23 A000            	   616:   ldy #0
00:CE25 B18E            	   617:   lda (token_start),Y
00:CE27 D005            	   618:   bne gc_assembler_comment_not_eof
00:CE29 A90A            	   619:   lda #NL
00:CE2B 8593            	   620:   sta token_type
00:CE2D 60              	   621:   rts     ; exit without incrementing token_start
                        	   622: 
                        	   623: gc_assembler_comment_not_eof:
00:CE2E C90A            	   624:   cmp #NL
00:CE30 D003            	   625:   bne gc_assembler_comment_keep_looking
00:CE32 4CE3CB          	   626:   jmp gc_single_byte_token
                        	   627: ;
                        	   628: ;  skip this byte and keep looking for the newline at the end of comment
                        	   629: ;
                        	   630: gc_assembler_comment_keep_looking:
00:CE35 E68E            	   631:   inc token_start
00:CE37 D0EA            	   632:   bne gc_assembler_comment_find_end
00:CE39 E68F            	   633:   inc token_start+1
00:CE3B 80E6            	   634:   bra gc_assembler_comment_find_end
                        	   635: 
                        	   636:   .endif  ; USE_ASSEMBLER
                        	   637: 
                        	   638: gc_backslash_tokens:
00:CE3D 41              	   639:          DFB  'A',$07  ; bell ($07)
00:CE3E 07
00:CE3F 42              	   640:          DFB  'B',$08  ; backspace ($08)
00:CE40 08
00:CE41 45              	   641:          DFB  'E',$1B  ; escape  (0x1B)
00:CE42 1B
00:CE43 46              	   642:          DFB  'F',$0C  ; formfeed ($0C)
00:CE44 0C
00:CE45 4E              	   643:          DFB  'N',$0A  ; newline  (0x0A)
00:CE46 0A
00:CE47 52              	   644:          DFB  'R',$0D  ; carriage return (0x0D)
00:CE48 0D
00:CE49 54              	   645:          DFB  'T',$09  ; horizontal tab (0x09)
00:CE4A 09
00:CE4B 56              	   646:          DFB  'V',$0B  ; vertical tab (0x0B)
00:CE4C 0B
00:CE4D 5C              	   647:          DFB  $5C,$5C  ; backslash
00:CE4E 5C
00:CE4F 22              	   648:          DFB  '"','"'  ; double quote
00:CE50 22
00:CE51 27              	   649:          DFB  SINGLE_QUOTE,SINGLE_QUOTE  ; single quote
00:CE52 27
                        	   650: gc_backslash_tokens_end = *
                        	   651: gc_backslash_tokens_length = gc_backslash_tokens_end - gc_backslash_tokens
                        	   652: 
                        	   653: ;
                        	   654: ;  quoted string
                        	   655: ;
                        	   656: ;  resolve double quotes and backslash sequences and store it in INBUF
                        	   657: ;
                        	   658: ;
                        	   659: gc_quote:
00:CE53 8598            	   660:   sta token_work    ; remember which sort
00:CE55 A000            	   661:   ldy #0            ; back to the start
00:CE57 6492            	   662:   stz token_length  ; zero-length string so far
00:CE59 A58E            	   663:   lda token_start
00:CE5B 8590            	   664:   sta token_address   ; save the starting address of the token (not that it matters too much)
00:CE5D A58F            	   665:   lda token_start+1   ; repeat for high-order byte
00:CE5F 8591            	   666:   sta token_address+1
                        	   667: 
                        	   668: gc_quote_loop:
00:CE61 C8              	   669:   iny                 ; onto next character
00:CE62 B18E            	   670:   lda (token_start),Y ; get the next character in the string
00:CE64 F004            	   671:   beq gc_quote_bad
00:CE66 C90A            	   672:   cmp  #NL
00:CE68 D005            	   673:   bne  gc_quote_loop_not_end_of_line
                        	   674: 
                        	   675: gc_quote_bad:
00:CE6A A208            	   676:   ldx  #8         ; MISSING QUOTE: Incorrect string
00:CE6C 4CE099          	   677:   jmp  ERROR
                        	   678: 
                        	   679: gc_quote_loop_not_end_of_line:
00:CE6F C598            	   680:   cmp  token_work  ; same as start quote?
00:CE71 D037            	   681:   bne  gc_quote_not_finished       ; no
00:CE73 C8              	   682:   iny
00:CE74 B18E            	   683:   lda (token_start),Y ; see if another quote follows
00:CE76 C598            	   684:   cmp  token_work
00:CE78 F05A            	   685:   beq  gc_quote_not_backslash      ; embedded quote (ie. two quotes in a row)? Store a single quote symbol
                        	   686:   ;
                        	   687:   ;  here at end of quoted string
                        	   688:   ;
00:CE7A 8498            	   689:   sty  token_work  ; remember how far through our input we are
00:CE7C A003            	   690:   ldy  #3          ; OK, we have the final quote, so is the string <= 3 characters long?
00:CE7E C492            	   691:   cpy  token_length
00:CE80 9002            	   692:   bcc  gc_quote_long_string   ; BLT - no
00:CE82 A492            	   693:   ldy  token_length           ; yes - load its actual length into Y (ie. 0, 1, 2, 3)
                        	   694: gc_quote_long_string:
00:CE84 88              	   695:   dey      ; zero-relative
00:CE85 3008            	   696:   bmi  gc_quote_copied_value   ; keep going into the length done
00:CE87 B90002          	   697:   lda  INBUF,Y   ; store the (up to) 3 bytes into VALUE as the token value
00:CE8A 999400          	   698:   sta  token_value,Y
00:CE8D D0F5            	   699:   bne  gc_quote_long_string   ; keep going until we hit the 0x00 at the end
                        	   700: 
                        	   701: gc_quote_copied_value:
00:CE8F A592            	   702:   lda  token_length    ; now see how long it is?
00:CE91 D005            	   703:   bne  gc_quote_done     ; don't allow zero length strings
00:CE93 A20E            	   704:   ldx  #14        ; BAD STRING: literal string of zero length
00:CE95 4CE099          	   705:   jmp  ERROR
                        	   706: 
                        	   707: gc_quote_done:
00:CE98 18              	   708:   clc
00:CE99 A58E            	   709:   lda token_start       ; bump up our token_start address to past the quoted string
00:CE9B 6598            	   710:   adc token_work        ; now add its (actual) length, not the length afer mucking around
00:CE9D 858E            	   711:   sta token_start       ; that gives the ending address
00:CE9F A58F            	   712:   lda token_start+1   ; repeat for high-order byte
00:CEA1 6900            	   713:   adc #0
00:CEA3 858F            	   714:   sta token_start+1
00:CEA5 A922            	   715:   lda  #TOKEN_STRING   ; it's a string token
00:CEA7 8593            	   716:   sta  token_type
00:CEA9 60              	   717:   rts
                        	   718: 
                        	   719: 
                        	   720: gc_quote_not_finished:
00:CEAA C95C            	   721:   cmp #$5C    ; backslash?
00:CEAC D026            	   722:   bne  gc_quote_not_backslash
                        	   723: ;
                        	   724: ;  backslash - see what follows
                        	   725: ;
00:CEAE C8              	   726:   iny
00:CEAF B18E            	   727:   lda (token_start),Y ; the character after the backslash
00:CEB1 F0B7            	   728:   beq gc_quote_bad    ; nothing? bad
00:CEB3 20C191          	   729:   jsr MAKE_UPPER
00:CEB6 C958            	   730:   cmp #'X'
00:CEB8 F038            	   731:   beq gc_quote_hex_character
00:CEBA A200            	   732:   ldx #0
                        	   733: gc_quote_backslash_loop:
00:CEBC DD3DCE          	   734:   cmp gc_backslash_tokens,X
00:CEBF F00F            	   735:   beq gc_quote_found_backslash_character   ; good match
00:CEC1 E8              	   736:   inx
00:CEC2 E8              	   737:   inx
00:CEC3 E016            	   738:   cpx #gc_backslash_tokens_length
00:CEC5 90F5            	   739:   bcc gc_quote_backslash_loop
                        	   740: gc_quote_bad_string:
00:CEC7 A208            	   741:   ldx #8
00:CEC9 4CE099          	   742:   jmp ERROR   ; ERROR: Incorrect string
                        	   743: 
                        	   744: gc_quote_hex_character_done:
00:CECC A594            	   745:   lda token_value
00:CECE 8004            	   746:   bra gc_quote_not_backslash
                        	   747: 
                        	   748: gc_quote_found_backslash_character:
00:CED0 E8              	   749:   inx
00:CED1 BD3DCE          	   750:   lda gc_backslash_tokens,X  ; get its replacement
                        	   751: 
                        	   752: gc_quote_not_backslash:
00:CED4 A692            	   753:   ldx  token_length
00:CED6 9D0002          	   754:   sta  INBUF,x           ; store it in INBUF
00:CED9 E692            	   755:   inc  token_length
00:CEDB F003            	   756:   beq  gc_quote_too_long
00:CEDD 4C61CE          	   757:   jmp  gc_quote_loop     ; keep adding to string
                        	   758: 
                        	   759: 
                        	   760: gc_quote_too_long:
                        	   761:   ;            string over 255 characters long - error!
00:CEE0 A21D            	   762:   ldx   #29  ; ERROR: string literal too big
00:CEE2 4CE099          	   763:   jmp  ERROR
                        	   764: 
                        	   765: ;
                        	   766: ;  "fix" a hex digit by making it upper-case, then subtracting 7 if it is A-F
                        	   767: ;   then subtracting '0' so we get a number in the range 0x00 to 0x0F in A
                        	   768: ;
                        	   769: gc_fix_hex:
00:CEE5 20C191          	   770:   jsr  MAKE_UPPER
00:CEE8 C941            	   771:   cmp  #'A'
00:CEEA 9002            	   772:   bcc  gc_fix_hex_not_a_to_f
00:CEEC E907            	   773:   sbc  #7
                        	   774: gc_fix_hex_not_a_to_f:
00:CEEE 38              	   775:   sec
00:CEEF E930            	   776:   sbc  #'0'
00:CEF1 60              	   777:   rts
                        	   778: 
                        	   779: gc_quote_hex_character:
00:CEF2 C8              	   780:   iny
00:CEF3 F0EB            	   781:   beq  gc_quote_too_long
00:CEF5 B18E            	   782:   lda  (token_start),Y ; the character after the backslash
00:CEF7 203E81          	   783:   jsr  isxdigit
00:CEFA 90CB            	   784:   bcc  gc_quote_bad_string  ; what? should be hex
00:CEFC 20E5CE          	   785:   jsr  gc_fix_hex
00:CEFF 8594            	   786:   sta  token_value  ; first nibble
00:CF01 C8              	   787:   iny
00:CF02 F0DC            	   788:   beq  gc_quote_too_long
00:CF04 B18E            	   789:   lda  (token_start),Y ; a second hex character?
00:CF06 F0BF            	   790:   beq  gc_quote_bad_string
00:CF08 203E81          	   791:   jsr  isxdigit
00:CF0B 9011            	   792:   bcc  gc_quote_hex_character_one_only
00:CF0D 20E5CE          	   793:   jsr  gc_fix_hex
00:CF10 0694            	   794:   asl  token_value    ; shift existing value 4 bits left
00:CF12 0694            	   795:   asl  token_value
00:CF14 0694            	   796:   asl  token_value
00:CF16 0694            	   797:   asl  token_value
00:CF18 0594            	   798:   ora  token_value
00:CF1A 8594            	   799:   sta  token_value
00:CF1C 80AE            	   800:   bra  gc_quote_hex_character_done
                        	   801: 
                        	   802: gc_quote_hex_character_one_only:
00:CF1E 88              	   803:   dey         ; undo add since we didn't find another hex character
00:CF1F 80AB            	   804:   bra gc_quote_hex_character_done
                        	   805: 
                        	   806: ;
                        	   807: ;  $nnnnnn where nnnnnn is one or more hex digits
                        	   808: ;    if no hex digits, then it is the token '$'
                        	   809: ;
                        	   810: gc_dollar:
00:CF21 A001            	   811:   ldy  #1    ; start with the character after the dollar
00:CF23 B18E            	   812:   lda  (token_start),Y ; followed by a hex character?
00:CF25 203E81          	   813:   jsr  isxdigit
00:CF28 B003            	   814:   bcs  gc_hex_literal
00:CF2A 4CE1CB          	   815:   jmp  gc_single_byte_already_known
                        	   816: 
                        	   817: gc_hex_literal:
00:CF2D 20E5CE          	   818:   jsr gc_fix_hex
00:CF30 8594            	   819:   sta token_value       ; store the first digit
00:CF32 6495            	   820:   stz token_value+1
00:CF34 6496            	   821:   stz token_value+2
                        	   822: gc_hex_loop:
00:CF36 C8              	   823:   iny
00:CF37 B18E            	   824:   lda (token_start),Y ; followed by another hex character?
00:CF39 203E81          	   825:   jsr isxdigit
00:CF3C 9033            	   826:   bcc gc_hex_done
00:CF3E 20E5CE          	   827:   jsr gc_fix_hex
                        	   828: ;
                        	   829: ;  shift the existing value left 4 bits to make room for the new nibble
                        	   830: ;
00:CF41 0694            	   831:   asl  token_value        ; token_value shifted left 1 bit
00:CF43 2695            	   832:   rol  token_value+1
00:CF45 2696            	   833:   rol  token_value+2
00:CF47 B02D            	   834:   bcs  gc_hex_too_big
00:CF49 0694            	   835:   asl  token_value        ; token_value shifted left 2 bits
00:CF4B 2695            	   836:   rol  token_value+1
00:CF4D 2696            	   837:   rol  token_value+2
00:CF4F B025            	   838:   bcs  gc_hex_too_big
00:CF51 0694            	   839:   asl  token_value        ; token_value shifted left 3 bits
00:CF53 2695            	   840:   rol  token_value+1
00:CF55 2696            	   841:   rol  token_value+2
00:CF57 B01D            	   842:   bcs  gc_hex_too_big
00:CF59 0694            	   843:   asl  token_value        ; token_value shifted left 4 bits
00:CF5B 2695            	   844:   rol  token_value+1
00:CF5D 2696            	   845:   rol  token_value+2
00:CF5F B015            	   846:   bcs  gc_hex_too_big
00:CF61 6594            	   847:   adc  token_value        ; now add in this last digit (carry will be clear)
00:CF63 8594            	   848:   sta  token_value        ; store the new result
00:CF65 90CF            	   849:   bcc  gc_hex_loop
00:CF67 E695            	   850:   inc  token_value+1
00:CF69 90CB            	   851:   bcc  gc_hex_loop
00:CF6B E695            	   852:   inc  token_value+1
00:CF6D B007            	   853:   bcs  gc_hex_too_big
00:CF6F 80C5            	   854:   bra  gc_hex_loop
                        	   855: 
                        	   856: gc_hex_done:
00:CF71 A94E            	   857:   lda #TOKEN_NUMBER
00:CF73 4CE5CB          	   858:   jmp gc_done
                        	   859: 
                        	   860: gc_hex_too_big:
00:CF76 A21E            	   861:   ldx  #30       ; ERROR: Number out of Range
00:CF78 4CE099          	   862:   jmp  ERROR
                        	   863: 
                        	   864: ;
                        	   865: ;  %nnnnnn where nnnnnn is one or more binary digits
                        	   866: ;    if no binary digits, then it is the token '%'
                        	   867: ;
                        	   868: 
                        	   869: gc_percent:
00:CF7B A001            	   870:   ldy  #1    ; start with the character after the %
00:CF7D B18E            	   871:   lda  (token_start),Y ; followed by a binary character?
00:CF7F 206E81          	   872:   jsr  isbinary
00:CF82 B003            	   873:   bcs  gc_binary_literal
00:CF84 4CE1CB          	   874:   jmp  gc_single_byte_already_known
                        	   875: 
                        	   876: gc_binary_literal:
00:CF87 E930            	   877:   sbc #'0'              ; we know carry is set
00:CF89 8594            	   878:   sta token_value       ; store the first digit
00:CF8B 6495            	   879:   stz token_value+1
00:CF8D 6496            	   880:   stz token_value+2
                        	   881: gc_binary_loop:
00:CF8F C8              	   882:   iny
00:CF90 B18E            	   883:   lda (token_start),Y ; followed by another binary character?
00:CF92 206E81          	   884:   jsr isbinary
00:CF95 90DA            	   885:   bcc gc_hex_done
00:CF97 E930            	   886:   sbc #'0'              ; we know carry is set
                        	   887: 
00:CF99 6A              	   888:   ror A   ; get the new bit into Carry
00:CF9A 2694            	   889:   rol token_value
00:CF9C 2695            	   890:   rol token_value+1
00:CF9E 2696            	   891:   rol token_value+2
00:CFA0 90ED            	   892:   bcc gc_binary_loop
00:CFA2 4C76CF          	   893:   jmp gc_hex_too_big   ; number too large
                        	   894: 
                        	   895: ;
                        	   896: ;  token : might be :=
                        	   897: ;
                        	   898: gc_colon:
00:CFA5 A001            	   899:   ldy  #1               ; get the next character
00:CFA7 B18E            	   900:   lda  (token_start),Y  ; followed by = ?
00:CFA9 C93D            	   901:   cmp  #'='
00:CFAB F003            	   902:   beq  gc_assign
00:CFAD 4CE1CB          	   903:   jmp  gc_single_byte_already_known
                        	   904: 
                        	   905: gc_assign:
00:CFB0 A941            	   906:   lda #TOKEN_ASSIGN
00:CFB2 C8              	   907:   iny
00:CFB3 4CE5CB          	   908:   jmp gc_done
                        	   909: 
                        	   910: ;
                        	   911: ;  token: < might be <=, <>, <<
                        	   912: ;
                        	   913: gc_less_than:
00:CFB6 A001            	   914:   ldy  #1               ; get the next character
00:CFB8 B18E            	   915:   lda  (token_start),Y  ; followed by = ?
00:CFBA C8              	   916:   iny                   ; make it a 2-byte token
00:CFBB C93D            	   917:   cmp  #'='
00:CFBD F00B            	   918:   beq  gc_leq
00:CFBF C93E            	   919:   cmp  #'>'
00:CFC1 F00C            	   920:   beq  gc_neq
00:CFC3 C93C            	   921:   cmp  #'<'
00:CFC5 F00D            	   922:   beq  gc_shift_left
00:CFC7 4CE1CB          	   923:   jmp  gc_single_byte_already_known
                        	   924: 
                        	   925: gc_leq:
00:CFCA A980            	   926:   lda #TOKEN_LEQ
00:CFCC 4CE5CB          	   927:   jmp gc_done
                        	   928: 
                        	   929: gc_neq:
00:CFCF A955            	   930:   lda #TOKEN_NEQ
00:CFD1 4CE5CB          	   931:   jmp gc_done
                        	   932: 
                        	   933: gc_shift_left:
00:CFD4 A94C            	   934:   lda #TOKEN_SHIFT_LEFT
00:CFD6 4CE5CB          	   935:   jmp gc_done
                        	   936: 
                        	   937: ;
                        	   938: ;  token: > might be <>=, >>
                        	   939: ;
                        	   940: gc_greater_than:
00:CFD9 A001            	   941:   ldy  #1               ; get the next character
00:CFDB B18E            	   942:   lda  (token_start),Y  ; followed by = ?
00:CFDD C8              	   943:   iny                   ; make it a 2-byte token
00:CFDE C93D            	   944:   cmp  #'='
00:CFE0 F007            	   945:   beq  gc_geq
00:CFE2 C93E            	   946:   cmp  #'>'
00:CFE4 F008            	   947:   beq  gc_shift_right
                        	   948: 
                        	   949: gc_single_byte_already_knownJ2:
00:CFE6 4CE1CB          	   950:   jmp  gc_single_byte_already_known
                        	   951: 
                        	   952: gc_geq:
00:CFE9 A981            	   953:   lda #TOKEN_GEQ
00:CFEB 4CE5CB          	   954:   jmp gc_done
                        	   955: 
                        	   956: gc_shift_right:
00:CFEE A952            	   957:   lda #TOKEN_SHIFT_RIGHT
00:CFF0 4CE5CB          	   958:   jmp gc_done
                        	   959: 
                        	   960: 
                        	   961: ;
                        	   962: ;  minus and plus sign
                        	   963: ;
                        	   964: 
                        	   965: gc_minus:
00:CFF3 8597            	   966:   sta token_sign
                        	   967: gc_plus:
                        	   968: 
                        	   969: ;
                        	   970: ;  new stuff - treat a sign as a token on its own if the previous token was one of:
                        	   971: ;    a) a number
                        	   972: ;    b) an identifier
                        	   973: ;    c) a RH bracket
                        	   974: ;
                        	   975: ;  So, for example: 2+3 is three tokens, but 2+-5 is also three, as the -5 becomes one token
                        	   976: ;
00:CFF5 A598            	   977:   lda  token_work            ; saved previous token on entry to get_token
00:CFF7 C94E            	   978:   cmp  #TOKEN_NUMBER
00:CFF9 F0EB            	   979:   beq  gc_single_byte_already_knownJ2
00:CFFB C949            	   980:   cmp  #TOKEN_IDENTIFIER
00:CFFD F0E7            	   981:   beq  gc_single_byte_already_knownJ2
00:CFFF C929            	   982:   cmp  #')'
00:D001 F0E3            	   983:   beq  gc_single_byte_already_knownJ2
                        	   984: ;
                        	   985: ;  if not, see if this is a signed number (ie. it is directly followed by a digit)
                        	   986: ;
00:D003 A001            	   987:   ldy  #1               ; get the next character
00:D005 B18E            	   988:   lda  (token_start),Y  ; followed by a digit?
00:D007 203281          	   989:   jsr  isdigit
00:D00A 90DA            	   990:   bcc  gc_single_byte_already_knownJ2
00:D00C 208ECC          	   991:   jsr atoi
00:D00F A94E            	   992:   lda  #TOKEN_NUMBER
00:D011 4CE5CB          	   993:   jmp  gc_done
                        	   994: 
                        	   995: 
                        	   996: ;
                        	   997: ;  token: & might be &&
                        	   998: ;
                        	   999: gc_ampersand:
00:D014 A001            	  1000:   ldy  #1               ; get the next character
00:D016 B18E            	  1001:   lda  (token_start),Y  ; followed by & ?
00:D018 C926            	  1002:   cmp  #'&'
00:D01A F003            	  1003:   beq  gc_logical_and
00:D01C 4CE1CB          	  1004:   jmp  gc_single_byte_already_known
                        	  1005: 
                        	  1006: gc_logical_and:
00:D01F A958            	  1007:   lda #TOKEN_LOGICAL_AND
00:D021 C8              	  1008:   iny
00:D022 4CE5CB          	  1009:   jmp gc_done
                        	  1010: 
                        	  1011: ;
                        	  1012: ;  token: | might be ||
                        	  1013: ;
                        	  1014: gc_bar:
00:D025 A001            	  1015:   ldy  #1               ; get the next character
00:D027 B18E            	  1016:   lda  (token_start),Y  ; followed by | ?
00:D029 C97C            	  1017:   cmp  #'|'
00:D02B F003            	  1018:   beq  gc_logical_or
00:D02D 4CE1CB          	  1019:   jmp  gc_single_byte_already_known
                        	  1020: 
                        	  1021: gc_logical_or:
00:D030 A959            	  1022:   lda #TOKEN_LOGICAL_OR
00:D032 C8              	  1023:   iny
00:D033 4CE5CB          	  1024:   jmp gc_done
                        	  1025: 
                        	  1026: ;
                        	  1027: ;  token: = might be ==
                        	  1028: ;
                        	  1029: gc_equals:
00:D036 A001            	  1030:   ldy  #1               ; get the next character
00:D038 B18E            	  1031:   lda  (token_start),Y  ; followed by = ?
00:D03A C93D            	  1032:   cmp  #'='
00:D03C F003            	  1033:   beq  gc_equality
00:D03E 4CE1CB          	  1034:   jmp  gc_single_byte_already_known
                        	  1035: 
                        	  1036: gc_equality:
00:D041 A945            	  1037:   lda #TOKEN_EQUALITY
00:D043 C8              	  1038:   iny
00:D044 4CE5CB          	  1039:   jmp gc_done
                        	  1040: 
                        	  1041: ;
                        	  1042: ;  token: ! might be !=
                        	  1043: ;
                        	  1044: gc_bang:
00:D047 A001            	  1045:   ldy  #1               ; get the next character
00:D049 B18E            	  1046:   lda  (token_start),Y  ; followed by = ?
00:D04B C93D            	  1047:   cmp  #'='
00:D04D F003            	  1048:   beq  gc_inequality
00:D04F 4CE1CB          	  1049:   jmp  gc_single_byte_already_known
                        	  1050: 
                        	  1051: gc_inequality:
00:D052 A95A            	  1052:   lda #TOKEN_INEQUALITY
00:D054 C8              	  1053:   iny
00:D055 4CE5CB          	  1054:   jmp gc_done
                        	  1055: 
                        	  1056: 
                        	  1057: 
                        	  1058: ; Pascal tokens
                        	  1059: 
                        	  1060: TOKEN_CONST     = $82
                        	  1061: TOKEN_VAR       = $83
                        	  1062: TOKEN_ARRAY     = $84
                        	  1063: TOKEN_OF        = $85
                        	  1064: TOKEN_PROCEDURE = $86
                        	  1065: TOKEN_FUNCTION  = $87
                        	  1066: TOKEN_BEGIN     = $88
                        	  1067: TOKEN_END       = $89
                        	  1068: TOKEN_OR        = $8A
                        	  1069: TOKEN_DIV       = $8B
                        	  1070: TOKEN_MOD       = $8C
                        	  1071: TOKEN_AND       = $8D
                        	  1072: TOKEN_SHL       = $8E
                        	  1073: TOKEN_SHR       = $8F
                        	  1074: TOKEN_NOT       = $90
                        	  1075: TOKEN_MEM       = $91
                        	  1076: TOKEN_IF        = $92
                        	  1077: TOKEN_THEN      = $93
                        	  1078: TOKEN_ELSE      = $94
                        	  1079: TOKEN_CASE      = $95
                        	  1080: TOKEN_WHILE     = $96
                        	  1081: TOKEN_DO        = $97
                        	  1082: TOKEN_REPEAT    = $98
                        	  1083: TOKEN_UNTIL     = $99
                        	  1084: TOKEN_FOR       = $9A
                        	  1085: TOKEN_TO        = $9B
                        	  1086: TOKEN_DOWNTO    = $9C
                        	  1087: TOKEN_WRITE     = $9D
                        	  1088: TOKEN_READ      = $9E
                        	  1089: TOKEN_CALL      = $9F
                        	  1090: TOKEN_CHAR      = $A1
                        	  1091: TOKEN_MEMC      = $A2
                        	  1092: TOKEN_XOR       = $A4
                        	  1093: TOKEN_ADDRESS   = $A9
                        	  1094: TOKEN_CHR       = $AB
                        	  1095: TOKEN_HEX       = $AC
                        	  1096: ; $B0 to $DE used by message tokens
                        	  1097: TOKEN_LCDWRITE  = $F1
                        	  1098: TOKEN_INTEGER   = $FE
                        	  1099: TOKEN_WRITELN   = $FF
                        	  1100: 
                        	  1101: 
                        	  1102: 
                        	  1103: ; RESERVED WORD TABLE
                        	  1104: ;
                        	  1105: ;***********************************************
                        	  1106:          .macro makeToken  ; MACRO DEFINITION FOR TOKENS: Length, token number, token name
                        	  1107:          DFB  \1
                        	  1108:          DFB  \2
                        	  1109:          text  \3
                        	  1110:          .endmacro           ; END OF MACRO
                        	  1111: 
                        	  1112: ;
                        	  1113: ; Reserved words are identified internally by their code (eg. $86 for PROCEDURE)
                        	  1114: ;
                        	  1115: ;  They are also stored "tokenised" and expanded out when you list the source
                        	  1116: ;
                        	  1117: ; Other tokens are:
                        	  1118: ;  * Punctuation (eg. "<", ">", "=", ".", "(", ")", "$", "+", "-"
                        	  1119: ;  * Identifiers: "I"        (eg. MY_VARIABLE)
                        	  1120: ;  * Constant numbers: "N"   (eg. -1234 and $1234)
                        	  1121: ;  * Literal strings:  '"' (quote symbol)  (eg. "Nick")
                        	  1122: ;  * Double-character punctuation:
                        	  1123: ;       <= : $80
                        	  1124: ;       >= : $81
                        	  1125: ;       Unequal (<>) : "U"
                        	  1126: ;       Assignment (:=) : "A"
                        	  1127: ;
                        	  1128: ; Comments are skipped: (* some comment *)
                        	  1129: ;
                        	  1130: ;
                        	  1131: ; However comments can have compiler directives embedded, eg. (*%A $4000) - put P-codes at $4000
                        	  1132: ;    (*%L*) - list during compile
                        	  1133: ;    (*%N*) - stop listing during compile (cancels %L and %P)
                        	  1134: ;    (*%P*) - show P-codes during compile
                        	  1135: ;    (*%A  $nnnn *) - put P-codes at address $nnnn - must be at START of program
                        	  1136: ;
                        	  1137: ;
                        	  1138: 
                        	  1139: ;              Length   Code             Name
                        	  1140: ;                  --   --------------- ---------------
                        	  1141: RSVWRD   =  *
                        	  1142:    makeToken   5, TOKEN_CONST     ,"CONST"
00:D058 05              	     1M          DFB  5
00:D059 82              	     2M          DFB  TOKEN_CONST     
00:D05A 434F4E5354      	     3M          text  "CONST"
                        	  1143:    makeToken   3, TOKEN_VAR       ,"VAR"
00:D05F 03              	     1M          DFB  3
00:D060 83              	     2M          DFB  TOKEN_VAR       
00:D061 564152          	     3M          text  "VAR"
                        	  1144:    makeToken   5, TOKEN_ARRAY     ,"ARRAY"
00:D064 05              	     1M          DFB  5
00:D065 84              	     2M          DFB  TOKEN_ARRAY     
00:D066 4152524159      	     3M          text  "ARRAY"
                        	  1145:    makeToken   2, TOKEN_OF        ,"OF"
00:D06B 02              	     1M          DFB  2
00:D06C 85              	     2M          DFB  TOKEN_OF        
00:D06D 4F46            	     3M          text  "OF"
                        	  1146:    makeToken   9, TOKEN_PROCEDURE ,"PROCEDURE"
00:D06F 09              	     1M          DFB  9
00:D070 86              	     2M          DFB  TOKEN_PROCEDURE 
00:D071 50524F4345445552	     3M          text  "PROCEDURE"
00:D079 45
                        	  1147:    makeToken   8, TOKEN_FUNCTION  ,"FUNCTION"
00:D07A 08              	     1M          DFB  8
00:D07B 87              	     2M          DFB  TOKEN_FUNCTION  
00:D07C 46554E4354494F4E	     3M          text  "FUNCTION"
                        	  1148:    makeToken   5, TOKEN_BEGIN     ,"BEGIN"
00:D084 05              	     1M          DFB  5
00:D085 88              	     2M          DFB  TOKEN_BEGIN     
00:D086 424547494E      	     3M          text  "BEGIN"
                        	  1149:    makeToken   3, TOKEN_END       ,"END"
00:D08B 03              	     1M          DFB  3
00:D08C 89              	     2M          DFB  TOKEN_END       
00:D08D 454E44          	     3M          text  "END"
                        	  1150:    makeToken   2, TOKEN_OR        ,"OR"
00:D090 02              	     1M          DFB  2
00:D091 8A              	     2M          DFB  TOKEN_OR        
00:D092 4F52            	     3M          text  "OR"
                        	  1151:    makeToken   3, TOKEN_DIV       ,"DIV"
00:D094 03              	     1M          DFB  3
00:D095 8B              	     2M          DFB  TOKEN_DIV       
00:D096 444956          	     3M          text  "DIV"
                        	  1152:    makeToken   3, TOKEN_MOD       ,"MOD"
00:D099 03              	     1M          DFB  3
00:D09A 8C              	     2M          DFB  TOKEN_MOD       
00:D09B 4D4F44          	     3M          text  "MOD"
                        	  1153:    makeToken   3, TOKEN_AND       ,"AND"
00:D09E 03              	     1M          DFB  3
00:D09F 8D              	     2M          DFB  TOKEN_AND       
00:D0A0 414E44          	     3M          text  "AND"
                        	  1154:    makeToken   3, TOKEN_SHL       ,"SHL"
00:D0A3 03              	     1M          DFB  3
00:D0A4 8E              	     2M          DFB  TOKEN_SHL       
00:D0A5 53484C          	     3M          text  "SHL"
                        	  1155:    makeToken   3, TOKEN_SHR       ,"SHR"
00:D0A8 03              	     1M          DFB  3
00:D0A9 8F              	     2M          DFB  TOKEN_SHR       
00:D0AA 534852          	     3M          text  "SHR"
                        	  1156:    makeToken   3, TOKEN_NOT       ,"NOT"
00:D0AD 03              	     1M          DFB  3
00:D0AE 90              	     2M          DFB  TOKEN_NOT       
00:D0AF 4E4F54          	     3M          text  "NOT"
                        	  1157:    makeToken   3, TOKEN_MEM       ,"MEM"
00:D0B2 03              	     1M          DFB  3
00:D0B3 91              	     2M          DFB  TOKEN_MEM       
00:D0B4 4D454D          	     3M          text  "MEM"
                        	  1158:    makeToken   2, TOKEN_IF        ,"IF"
00:D0B7 02              	     1M          DFB  2
00:D0B8 92              	     2M          DFB  TOKEN_IF        
00:D0B9 4946            	     3M          text  "IF"
                        	  1159:    makeToken   4, TOKEN_THEN      ,"THEN"
00:D0BB 04              	     1M          DFB  4
00:D0BC 93              	     2M          DFB  TOKEN_THEN      
00:D0BD 5448454E        	     3M          text  "THEN"
                        	  1160:    makeToken   4, TOKEN_ELSE      ,"ELSE"
00:D0C1 04              	     1M          DFB  4
00:D0C2 94              	     2M          DFB  TOKEN_ELSE      
00:D0C3 454C5345        	     3M          text  "ELSE"
                        	  1161:    makeToken   4, TOKEN_CASE      ,"CASE"
00:D0C7 04              	     1M          DFB  4
00:D0C8 95              	     2M          DFB  TOKEN_CASE      
00:D0C9 43415345        	     3M          text  "CASE"
                        	  1162:    makeToken   5, TOKEN_WHILE     ,"WHILE"
00:D0CD 05              	     1M          DFB  5
00:D0CE 96              	     2M          DFB  TOKEN_WHILE     
00:D0CF 5748494C45      	     3M          text  "WHILE"
                        	  1163:    makeToken   2, TOKEN_DO        ,"DO"
00:D0D4 02              	     1M          DFB  2
00:D0D5 97              	     2M          DFB  TOKEN_DO        
00:D0D6 444F            	     3M          text  "DO"
                        	  1164:    makeToken   6, TOKEN_REPEAT    ,"REPEAT"
00:D0D8 06              	     1M          DFB  6
00:D0D9 98              	     2M          DFB  TOKEN_REPEAT    
00:D0DA 524550454154    	     3M          text  "REPEAT"
                        	  1165:    makeToken   5, TOKEN_UNTIL     ,"UNTIL"
00:D0E0 05              	     1M          DFB  5
00:D0E1 99              	     2M          DFB  TOKEN_UNTIL     
00:D0E2 554E54494C      	     3M          text  "UNTIL"
                        	  1166:    makeToken   3, TOKEN_FOR       ,"FOR"
00:D0E7 03              	     1M          DFB  3
00:D0E8 9A              	     2M          DFB  TOKEN_FOR       
00:D0E9 464F52          	     3M          text  "FOR"
                        	  1167:    makeToken   2, TOKEN_TO        ,"TO"
00:D0EC 02              	     1M          DFB  2
00:D0ED 9B              	     2M          DFB  TOKEN_TO        
00:D0EE 544F            	     3M          text  "TO"
                        	  1168:    makeToken   6, TOKEN_DOWNTO    ,"DOWNTO"
00:D0F0 06              	     1M          DFB  6
00:D0F1 9C              	     2M          DFB  TOKEN_DOWNTO    
00:D0F2 444F574E544F    	     3M          text  "DOWNTO"
                        	  1169:    makeToken   5, TOKEN_WRITE     ,"WRITE"
00:D0F8 05              	     1M          DFB  5
00:D0F9 9D              	     2M          DFB  TOKEN_WRITE     
00:D0FA 5752495445      	     3M          text  "WRITE"
                        	  1170:    makeToken   4, TOKEN_READ      ,"READ"
00:D0FF 04              	     1M          DFB  4
00:D100 9E              	     2M          DFB  TOKEN_READ      
00:D101 52454144        	     3M          text  "READ"
                        	  1171:    makeToken   4, TOKEN_CALL      ,"CALL"
00:D105 04              	     1M          DFB  4
00:D106 9F              	     2M          DFB  TOKEN_CALL      
00:D107 43414C4C        	     3M          text  "CALL"
                        	  1172:    makeToken   4, TOKEN_CHAR      ,"CHAR"
00:D10B 04              	     1M          DFB  4
00:D10C A1              	     2M          DFB  TOKEN_CHAR      
00:D10D 43484152        	     3M          text  "CHAR"
                        	  1173:    makeToken   4, TOKEN_MEMC      ,"MEMC"
00:D111 04              	     1M          DFB  4
00:D112 A2              	     2M          DFB  TOKEN_MEMC      
00:D113 4D454D43        	     3M          text  "MEMC"
                        	  1174:    makeToken   3, TOKEN_XOR       ,"XOR"
00:D117 03              	     1M          DFB  3
00:D118 A4              	     2M          DFB  TOKEN_XOR       
00:D119 584F52          	     3M          text  "XOR"
                        	  1175:    makeToken   7, TOKEN_ADDRESS   ,"ADDRESS"
00:D11C 07              	     1M          DFB  7
00:D11D A9              	     2M          DFB  TOKEN_ADDRESS   
00:D11E 41444452455353  	     3M          text  "ADDRESS"
                        	  1176:    makeToken   3, TOKEN_CHR       ,"CHR"
00:D125 03              	     1M          DFB  3
00:D126 AB              	     2M          DFB  TOKEN_CHR       
00:D127 434852          	     3M          text  "CHR"
                        	  1177:    makeToken   3, TOKEN_HEX       ,"HEX"
00:D12A 03              	     1M          DFB  3
00:D12B AC              	     2M          DFB  TOKEN_HEX       
00:D12C 484558          	     3M          text  "HEX"
                        	  1178:    makeToken   7, TOKEN_INTEGER   ,"INTEGER"
00:D12F 07              	     1M          DFB  7
00:D130 FE              	     2M          DFB  TOKEN_INTEGER   
00:D131 494E5445474552  	     3M          text  "INTEGER"
                        	  1179:    makeToken   7, TOKEN_WRITELN   ,"WRITELN"
00:D138 07              	     1M          DFB  7
00:D139 FF              	     2M          DFB  TOKEN_WRITELN   
00:D13A 57524954454C4E  	     3M          text  "WRITELN"
                        	  1180:    makeToken   8, TOKEN_LCDWRITE  ,"LCDWRITE"
00:D141 08              	     1M          DFB  8
00:D142 F1              	     2M          DFB  TOKEN_LCDWRITE  
00:D143 4C43445752495445	     3M          text  "LCDWRITE"
                        	  1181: 
                        	  1182: 
00:D14B 00              	  1183: RSVEND   DFB  0,0        ; END OF TABLE
00:D14C 00
                        	  1184: ;
                        	  1185: 
                        	  1186: ;
                        	  1187: ;  Pascal get_token
                        	  1188: ;
                        	  1189: ;  Used in the Pascal section. Does a get_token, and then if an identifier is found tries to look
                        	  1190: ;  it up.
                        	  1191: ;
                        	  1192: pas_get_token:
00:D14D 209FCB          	  1193:   jsr get_token
00:D150 F004            	  1194:   beq pas_get_token_eof   ; branch to make sure Z flag stays set
00:D152 C949            	  1195:   cmp #TOKEN_IDENTIFIER
00:D154 F001            	  1196:   beq pas_gc_identifier
                        	  1197: pas_get_token_eof:
00:D156 60              	  1198:   rts
                        	  1199: ;
                        	  1200: ;  here if get_token got an identifier
                        	  1201: ;
                        	  1202: pas_gc_identifier:
00:D157 A958            	  1203:   lda  #<RSVWRD
00:D159 8598            	  1204:   sta  token_work
00:D15B A9D0            	  1205:   lda  #>RSVWRD
00:D15D 8599            	  1206:   sta  token_work+1
                        	  1207: pas_gc_loop:
00:D15F A000            	  1208:   ldy  #0
00:D161 B198            	  1209:   lda  (token_work),Y
00:D163 D003            	  1210:   bne  pas_gc_more        ; MORE TO GO
00:D165 A949            	  1211:   lda  #TOKEN_IDENTIFIER
00:D167 60              	  1212:   rts
                        	  1213: ;
                        	  1214: ; SEARCH for RESERVED WORD
                        	  1215: ;
                        	  1216: pas_gc_more:
00:D168 B198            	  1217:   lda  (token_work),Y     ; length of word in table
00:D16A C592            	  1218:   cmp  token_length       ; same?
00:D16C D022            	  1219:   bne  pas_gc_no_match    ; no - can't be it then
00:D16E A8              	  1220:   tay                     ; length
00:D16F A590            	  1221:   lda  token_address      ; put token start address into SRCE
00:D171 8500            	  1222:   sta  SRCE
00:D173 A591            	  1223:   lda  token_address+1
00:D175 8501            	  1224:   sta  SRCE+1
00:D177 A598            	  1225:   lda  token_work         ; put current token_work+2 into DEST
00:D179 18              	  1226:   clc
00:D17A 6902            	  1227:   adc  #2
00:D17C 8503            	  1228:   sta  DEST
00:D17E A599            	  1229:   lda  token_work+1
00:D180 6900            	  1230:   adc  #0
00:D182 8504            	  1231:   sta  DEST+1
00:D184 200182          	  1232:   jsr  str_ic_compare
00:D187 D007            	  1233:   bne  pas_gc_no_match      ; NOT FOUND
00:D189 A001            	  1234:   ldy  #1
00:D18B B198            	  1235:   lda  (token_work),Y
00:D18D 8593            	  1236:   sta  token_type
00:D18F 60              	  1237:   rts
                        	  1238: pas_gc_no_match    =  *
00:D190 A000            	  1239:   ldy  #0
00:D192 B198            	  1240:   lda  (token_work),Y     ; token_work points to reserved word entry
00:D194 18              	  1241:   clc
00:D195 6902            	  1242:   adc  #2         ; add 2 to bypass length and code
00:D197 6598            	  1243:   adc  token_work
00:D199 8598            	  1244:   sta  token_work         ; put it back
00:D19B 90C2            	  1245:   bcc  pas_gc_loop
00:D19D E699            	  1246:   inc  token_work+1       ; handle overflow
00:D19F 80BE            	  1247:   bra  pas_gc_loop     ; try for another
                        	  1248: 
                        	  1249: 
                        	  1250: 
                        	  1251: ;***********************************************
                        	  1252: ; GET A TOKEN - CHECK THAT IT
                        	  1253: ; IS THE SAME AS IN "A", IF NOT
                        	  1254: ; CALL ERROR "X"
                        	  1255: ;***********************************************
                        	  1256: GETCHK:
00:D1A1 DA              	  1257:   phx   ; save error number
00:D1A2 48              	  1258:   pha   ; save wanted token type
00:D1A3 204DD1          	  1259:   jsr pas_get_token
00:D1A6 68              	  1260:   pla   ; get it back
00:D1A7 C593            	  1261:   cmp token_type
00:D1A9 F004            	  1262:   beq CHKOK
00:D1AB FA              	  1263:   plx   ; get error number back
                        	  1264: CHKNOK   =  *
00:D1AC 4CE099          	  1265:   jmp ERROR
                        	  1266: CHKOK    =  *
00:D1AF FA              	  1267:   plx   ; get error number back
00:D1B0 60              	  1268:   rts
                        	  1269: 
                        	  1270: ;***********************************************
                        	  1271: ; CHECK TOKEN AGREES WITH "A",
                        	  1272: ; IF NOT, GIVE ERROR "X"
                        	  1273: ;***********************************************
                        	  1274: CHKTKN:
00:D1B1 C593            	  1275:   cmp  token_type
00:D1B3 D0F7            	  1276:   bne  CHKNOK
00:D1B5 60              	  1277:   rts
                        	  1278: 
                        	  1279: ;***********************************************
                        	  1280: ;
                        	  1281: ; GET NEXT TOKEN - MUST BE IDENTIFIER
                        	  1282: ; THEN LOOK IT UP IN SYMBOL TABLE
                        	  1283: ;***********************************************
                        	  1284: 
                        	  1285: GET_LOOK:
00:D1B6 A949            	  1286:   lda  #TOKEN_IDENTIFIER
00:D1B8 A204            	  1287:   ldx  #4      ; ERROR: Identifier expected
00:D1BA 20A1D1          	  1288:   jsr  GETCHK
00:D1BD 4C24CA          	  1289:   jmp  LOOKUP
                        	  1290: 

Source: "gpascal.asm"
                        	   201:   .include "i2c.inc"

Source: "i2c.inc"
                        	     1: ;
                        	     2: ;  I2C interface routines
                        	     3: ;
                        	     4: ; Author: Nick Gammon
                        	     5: ; Date: 2 March 2022
                        	     6: 
                        	     7: ; PROTOCOL
                        	     8: ;
                        	     9: ;  BUS NOT BUSY: Both data and clock lines remain HIGH.
                        	    10: ;
                        	    11: ;  START DATA TRANSFER: A change in the state of the data line, from HIGH to LOW, while the clock is
                        	    12: ;  HIGH, defines a START condition.
                        	    13: ;
                        	    14: ;  STOP DATA TRANSFER: A change in the state of the data line, from LOW to HIGH, while the clock line
                        	    15: ;  is HIGH, defines the STOP condition.
                        	    16: ;
                        	    17: ;  DATA VALID: The state of the data line represents valid data when, after a START condition, the data
                        	    18: ;  line is stable for the duration of the HIGH period of the clock signal. The data on the line must be
                        	    19: ;  changed during the LOW period of the clock signal. There is one clock pulse per bit of data.
                        	    20: ;  Each data transfer is initiated with a START co ndition and terminated with a STOP condition. The
                        	    21: ;  number of data bytes transferred between START and STOP conditions is not limited, and is
                        	    22: ;  determined by the master device. The information is transferred byte-wise and each receiver
                        	    23: ;  acknowledges with a ninth bit.
                        	    24: ;
                        	    25: ;  CLOCK STRETCHING
                        	    26: ;
                        	    27: ;  If a slave wants us to wait, or another master is attempting to take over the bus, SCL will not go
                        	    28: ;  high immediately after we set it to input (high impedance) so we therefore wait until SCL is in
                        	    29: ;  fact high before proceeding.
                        	    30: ;
                        	    31: ;  ARBITRATION
                        	    32: ;
                        	    33: ;  If two masters are attempting to write to the bus we can detect that as soon as one of them writes
                        	    34: ;  a one, but reads back a zero. This indicates that another master wrote the zero. The master that
                        	    35: ;  read back the one then abandons its attempt to write (to try again later).
                        	    36: ;
                        	    37: ;  Since, up to this point, both have read back what they wrote, the bus is not corrupted.
                        	    38: ;
                        	    39: 
                        	    40: 
                        	    41: ; Configuration of which VIA ports are used by SCL and SDA
                        	    42: 
                        	    43: I2C_SCL     = %00000100   ; SCL (serial clock) - PA2
                        	    44: I2C_SDA     = %00001000   ; SDA (serial data)  - PA3
                        	    45: 
                        	    46: I2C_PORT    = VIA_PORTA   ; PORT A
                        	    47: I2C_DDR     = VIA_DDRA    ; DDR  A
                        	    48: 
                        	    49: ;
                        	    50: ;  Initialise hardware for I2C comms.
                        	    51: ;
                        	    52: ;  Set SCL and SDA to high, however make the ports input for now
                        	    53: ;
                        	    54: i2c_init:
                        	    55: 
                        	    56: ;
                        	    57: ;  Set ports to low
                        	    58: ;
00:D1C0 A90C            	    59:   lda #I2C_SCL | I2C_SDA
00:D1C2 1CF17F          	    60:   trb I2C_PORT
                        	    61: 
                        	    62: ;
                        	    63: ;  Set ports to input
                        	    64: ;
                        	    65: 
00:D1C5 A90C            	    66:   lda #I2C_SCL | I2C_SDA
00:D1C7 1CF37F          	    67:   trb I2C_DDR
                        	    68: 
                        	    69: 
00:D1CA 60              	    70:   rts
                        	    71: 
                        	    72: ;---------------------------------------------
                        	    73: ;  delay between clock bits - could make shorter if using a 1 MHz clock
                        	    74: ;---------------------------------------------
                        	    75: i2c_delay:
00:D1CB EA              	    76:     nop
00:D1CC EA              	    77:     nop
00:D1CD EA              	    78:     nop
00:D1CE 60              	    79:     rts
                        	    80: 
                        	    81: ;---------------------------------------------
                        	    82: ;  toggle the SCL line from low to high and back again
                        	    83: ;---------------------------------------------
                        	    84: i2c_toggle_clock:
00:D1CF A904            	    85:   lda #I2C_SCL
00:D1D1 1CF37F          	    86:   trb I2C_DDR      ; SCL high
00:D1D4 20CBD1          	    87:   jsr i2c_delay
                        	    88: ;
                        	    89: ;  check if the slave wants us to wait by pulling the clock low
                        	    90: ;
                        	    91: i2c_toggle_clock_wait:
00:D1D7 ADF17F          	    92:   lda I2C_PORT
00:D1DA 2904            	    93:   and #I2C_SCL
00:D1DC F0F9            	    94:   beq i2c_toggle_clock_wait   ; should be high, but is low
                        	    95: ;
                        	    96: ;  we let the clock go high, and it actually IS high, so we can proceed
                        	    97: ;
00:D1DE 0CF37F          	    98:   tsb I2C_DDR       ; SCL low
00:D1E1 A908            	    99:   lda #I2C_SDA      ; immediately set SDA to low
00:D1E3 1CF37F          	   100:   trb I2C_DDR
00:D1E6 20CBD1          	   101:   jsr i2c_delay
00:D1E9 60              	   102:   rts
                        	   103: 
                        	   104: ;---------------------------------------------
                        	   105: ;
                        	   106: ;  Begin transmission: send a start condition
                        	   107: ;
                        	   108: ;  Slave address in A, read/write bit in low-order bit
                        	   109: ;    0 = write, 1 = read
                        	   110: ;
                        	   111: ;  Sets carry if OK
                        	   112: ;
                        	   113: ;  START CONDITION:
                        	   114: ;
                        	   115: ;  A change in the state of the data line, from HIGH to LOW, while the clock is HIGH
                        	   116: ;---------------------------------------------
                        	   117: 
                        	   118: i2c_begin_transmission:
                        	   119: 
00:D1EA 48              	   120:   pha             ; save address
                        	   121: 
00:D1EB 20C0D1          	   122:   jsr i2c_init    ; set ports to low, and ports to input
                        	   123: 
                        	   124: ;
                        	   125: ;  Check if SDA or SCL are in use (low) - if so, wait until they are not
                        	   126: ;
                        	   127: i2c_begin_transmission_loop:
00:D1EE A908            	   128:   lda #I2C_SDA
00:D1F0 2DF17F          	   129:   and I2C_PORT
00:D1F3 F0F9            	   130:   beq i2c_begin_transmission_loop
00:D1F5 A904            	   131:   lda #I2C_SCL
00:D1F7 2DF17F          	   132:   and I2C_PORT
00:D1FA F0F2            	   133:   beq i2c_begin_transmission_loop
                        	   134: 
                        	   135: ;
                        	   136: ;  The start condition pulls SDA low but SCL stays high
                        	   137: ;
                        	   138: 
00:D1FC A908            	   139:   lda #I2C_SDA
00:D1FE 0CF37F          	   140:   tsb I2C_DDR
00:D201 20CBD1          	   141:   jsr i2c_delay
                        	   142: 
                        	   143: ;
                        	   144: ;  But now we pull SCL low ready for clocking out bits
                        	   145: ;
                        	   146: 
00:D204 A904            	   147:   lda #I2C_SCL
00:D206 0CF37F          	   148:   tsb I2C_DDR
00:D209 20CBD1          	   149:   jsr i2c_delay
                        	   150: 
00:D20C 68              	   151:   pla   ; get address back
                        	   152: 
00:D20D 2011D2          	   153:   jsr i2c_write
                        	   154: 
00:D210 60              	   155:   rts
                        	   156: 
                        	   157: ;---------------------------------------------
                        	   158: ;
                        	   159: ;  I2C write: send 8 data bits, wait for acknowledge
                        	   160: ;
                        	   161: ;---------------------------------------------
                        	   162: 
                        	   163: i2c_write:
00:D211 A208            	   164:   ldx #8  ; count of bits
00:D213 A8              	   165:   tay
                        	   166: 
                        	   167: i2c_write_loop:
00:D214 98              	   168:   tya
00:D215 2A              	   169:   rol a   ; get bit to write into carry
00:D216 A8              	   170:   tay
                        	   171: 
00:D217 B007            	   172:   bcs i2c_write_one
                        	   173: ;
                        	   174: ;  write a zero by setting SDA to output
                        	   175: ;
00:D219 A908            	   176:   lda #I2C_SDA
00:D21B 0CF37F          	   177:   tsb I2C_DDR
00:D21E 800B            	   178:   bra i2c_write_clock
                        	   179: ;
                        	   180: ;  write a one by setting SDA to input
                        	   181: ;
                        	   182: i2c_write_one:
00:D220 A908            	   183:   lda #I2C_SDA
00:D222 1CF37F          	   184:   trb I2C_DDR
                        	   185: ;
                        	   186: ;  if SDA is not high, another master has taken control of the bus, abandon this write
                        	   187: ;
00:D225 EA              	   188:   nop
00:D226 2DF17F          	   189:   and I2C_PORT
00:D229 F028            	   190:   beq i2c_write_lost_arbitration   ; error return, give up
                        	   191: 
                        	   192: ;---------------------------------------------
                        	   193: ;
                        	   194: ;  toggle clock
                        	   195: ;
                        	   196: ;---------------------------------------------
                        	   197: i2c_write_clock:
00:D22B 20CFD1          	   198:   jsr i2c_toggle_clock
                        	   199: ;
                        	   200: ;  back for another bit?
                        	   201: ;
00:D22E CA              	   202:   dex
00:D22F D0E3            	   203:   bne i2c_write_loop
                        	   204: 
                        	   205:   ;---------------------------------------------
                        	   206:   ;  wait for acknowledge bit
                        	   207:   ;---------------------------------------------
                        	   208: 
                        	   209:   ;
                        	   210:   ;  make SDA input and see if it is pulled low
                        	   211:   ;
                        	   212: 
00:D231 A908            	   213:   lda #I2C_SDA
00:D233 1CF37F          	   214:   trb I2C_DDR         ; SDA to input
                        	   215: 
00:D236 A904            	   216:   lda #I2C_SCL        ; clock high
00:D238 1CF37F          	   217:   trb I2C_DDR
                        	   218: 
                        	   219: ;
                        	   220: ;  check if the slave wants us to wait by pulling the clock low
                        	   221: ;
                        	   222: i2c_write_clock_wait:
00:D23B ADF17F          	   223:   lda I2C_PORT
00:D23E 2904            	   224:   and #I2C_SCL
00:D240 F0F9            	   225:   beq i2c_write_clock_wait   ; should be high, but is low
                        	   226: 
00:D242 20CBD1          	   227:   jsr i2c_delay       ; give it time to respond
                        	   228: 
00:D245 A908            	   229:   lda #I2C_SDA
00:D247 2DF17F          	   230:   and I2C_PORT        ; read SDA
                        	   231: 
00:D24A AA              	   232:   tax                 ; save result for a moment
00:D24B A904            	   233:   lda #I2C_SCL        ; clock low
00:D24D 0CF37F          	   234:   tsb I2C_DDR
                        	   235: 
00:D250 8A              	   236:   txa             ; get ack/nak bit back
                        	   237: 
00:D251 F002            	   238:   beq i2c_write_got_ack
                        	   239: 
                        	   240: i2c_write_lost_arbitration:
00:D253 18              	   241:   clc   ; error return
00:D254 60              	   242:   rts
                        	   243: 
                        	   244: i2c_write_got_ack:
00:D255 38              	   245:   sec   ; carry means OK
00:D256 60              	   246:   rts
                        	   247: 
                        	   248: 
                        	   249: ;---------------------------------------------
                        	   250: ;
                        	   251: ;  I2C read: receive 8 data bits, then acknowledge unless hardware_work is zero
                        	   252: ;    hardware_work will be the count of outstanding bytes to be sent
                        	   253: ;    on the last bit we NAK it to tell the sender not to send any more
                        	   254: ;
                        	   255: ;---------------------------------------------
                        	   256: 
                        	   257: i2c_read:
00:D257 A208            	   258:   ldx #8  ; count of bits
00:D259 A000            	   259:   ldy #0  ; current result
                        	   260: 
00:D25B A908            	   261:   lda #I2C_SDA
00:D25D 1CF37F          	   262:   trb I2C_DDR         ; SDA to input
                        	   263: 
                        	   264: i2c_read_loop:
                        	   265: 
00:D260 A904            	   266:   lda #I2C_SCL        ; clock high
00:D262 1CF37F          	   267:   trb I2C_DDR
00:D265 20CBD1          	   268:   jsr i2c_delay       ; give it time to respond
                        	   269: 
00:D268 A908            	   270:   lda #I2C_SDA
00:D26A 2DF17F          	   271:   and I2C_PORT        ; read SDA
00:D26D F006            	   272:   beq i2c_read_zero
                        	   273: ;
                        	   274: ;  read a 1
                        	   275: ;
00:D26F 98              	   276:   tya       ; get previous result
00:D270 38              	   277:   sec
00:D271 2A              	   278:   rol a     ; rotate in a one-bit
00:D272 A8              	   279:   tay       ; keep for later
00:D273 8004            	   280:   bra i2c_read_next
                        	   281: 
                        	   282: ;
                        	   283: ;  read a 0
                        	   284: ;
                        	   285: i2c_read_zero:
00:D275 98              	   286:   tya       ; get previous result
00:D276 18              	   287:   clc
00:D277 2A              	   288:   rol a     ; rotate in a zero-bit
00:D278 A8              	   289:   tay       ; keep for later
                        	   290: 
                        	   291: i2c_read_next:
                        	   292: 
00:D279 A904            	   293:   lda #I2C_SCL        ; clock low
00:D27B 0CF37F          	   294:   tsb I2C_DDR
00:D27E 20CBD1          	   295:   jsr i2c_delay       ; give it time to respond
                        	   296: 
                        	   297: ;
                        	   298: ;  back for another bit?
                        	   299: ;
00:D281 CA              	   300:   dex
00:D282 D0DC            	   301:   bne i2c_read_loop
                        	   302: 
00:D284 A58C            	   303:   lda hardware_work   ; NAK on last read so they stop sending
00:D286 F007            	   304:   beq i2c_read_nak
                        	   305: 
00:D288 A908            	   306:   lda #I2C_SDA
00:D28A 0CF37F          	   307:   tsb I2C_DDR         ; pull SDA low to ACK the byte
00:D28D 8005            	   308:   bra i2c_read_ack_or_nak
                        	   309: 
                        	   310: i2c_read_nak:
00:D28F A908            	   311:   lda #I2C_SDA
00:D291 1CF37F          	   312:   trb I2C_DDR         ; pull SDA high to NAK the final byte
                        	   313: 
                        	   314: i2c_read_ack_or_nak:
                        	   315: 
00:D294 A904            	   316:   lda #I2C_SCL        ; clock high
00:D296 1CF37F          	   317:   trb I2C_DDR
                        	   318: 
                        	   319: ;
                        	   320: ;  check if the slave wants us to wait by pulling the clock low
                        	   321: ;   (clock stretching)
                        	   322: ;
                        	   323: 
                        	   324: i2c_read_ack_or_nak_wait:
00:D299 ADF17F          	   325:   lda I2C_PORT
00:D29C 2904            	   326:   and #I2C_SCL
00:D29E F0F9            	   327:   beq i2c_read_ack_or_nak_wait   ; should be high, but is low
                        	   328: 
00:D2A0 20CBD1          	   329:   jsr i2c_delay       ; give it time to respond
                        	   330: 
00:D2A3 A904            	   331:   lda #I2C_SCL        ; clock low
00:D2A5 0CF37F          	   332:   tsb I2C_DDR
00:D2A8 20CBD1          	   333:   jsr i2c_delay
                        	   334: 
                        	   335: i2c_read_done:
                        	   336: 
00:D2AB 98              	   337:   tya                 ; result in A
00:D2AC 60              	   338:   rts
                        	   339: 
                        	   340: 
                        	   341: ;---------------------------------------------
                        	   342: ;  end transmission - send stop condition
                        	   343: ;
                        	   344: ;  STOP CONDITION:
                        	   345: ;
                        	   346: ;  A change in the state of the data line, from LOW to HIGH, while the clock is HIGH
                        	   347: ;---------------------------------------------
                        	   348: 
                        	   349: i2c_end_transmission:
                        	   350: 
                        	   351: ;
                        	   352: ;  make sure SDA is low, otherwise it can't transition low to high
                        	   353: ;
00:D2AD A908            	   354:   lda #I2C_SDA
00:D2AF 0CF37F          	   355:   tsb I2C_DDR
                        	   356: 
00:D2B2 20CBD1          	   357:   jsr i2c_delay
                        	   358: 
                        	   359: ;
                        	   360: ;  Set SCL to input so it floats high
                        	   361: ;
00:D2B5 A904            	   362:   lda #I2C_SCL
00:D2B7 1CF37F          	   363:   trb I2C_DDR
                        	   364: 
00:D2BA 20CBD1          	   365:   jsr i2c_delay
                        	   366: 
                        	   367: ;
                        	   368: ;  Now with SCL high, set SDA to input so it also floats high
                        	   369: ;
00:D2BD A908            	   370:   lda #I2C_SDA
00:D2BF 1CF37F          	   371:   trb I2C_DDR
                        	   372: 
00:D2C2 20CBD1          	   373:   jsr i2c_delay
                        	   374: 
                        	   375: ;
                        	   376: ;  Both SDA and SCL are now high (by the pull-up resistors) so we are done
                        	   377: ;
00:D2C5 60              	   378:   rts
                        	   379: 
                        	   380: ;---------------------------------------------
                        	   381: ;
                        	   382: ;  Send a message, address in A (excluding write bit)
                        	   383: ;  Message in (VALUE)
                        	   384: ;  Length in Y
                        	   385: ;  Returns carry set on success, carry clear on failure
                        	   386: ;
                        	   387: ;---------------------------------------------
                        	   388: i2c_send:
00:D2C6 848C            	   389:   sty hardware_work
00:D2C8 0A              	   390:   asl A     ; move zero into write bit
00:D2C9 20EAD1          	   391:   jsr i2c_begin_transmission
00:D2CC 901C            	   392:   bcc i2c_send_fail
                        	   393: 
                        	   394: ;
                        	   395: ;  send each byte
                        	   396: ;
                        	   397: i2c_send_loop:
00:D2CE A58C            	   398:   lda hardware_work           ; number of bytes to go
00:D2D0 F013            	   399:   beq i2c_send_done
00:D2D2 C68C            	   400:   dec hardware_work
00:D2D4 A000            	   401:   ldy #0
00:D2D6 B100            	   402:   lda (VALUE),Y
00:D2D8 2011D2          	   403:   jsr i2c_write
00:D2DB 900D            	   404:   bcc i2c_send_fail
00:D2DD E600            	   405:   inc VALUE
00:D2DF D0ED            	   406:   bne i2c_send_loop
00:D2E1 E601            	   407:   inc VALUE+1
00:D2E3 80E9            	   408:   bra i2c_send_loop
                        	   409: ;
                        	   410: ;  sending done
                        	   411: ;
                        	   412: i2c_send_done:
00:D2E5 20ADD2          	   413:   jsr i2c_end_transmission
00:D2E8 38              	   414:   sec
00:D2E9 60              	   415:   rts
                        	   416: ;
                        	   417: ;  sending failure
                        	   418: ;
                        	   419: i2c_send_fail:
00:D2EA 20ADD2          	   420:   jsr i2c_end_transmission
00:D2ED 18              	   421:   clc
00:D2EE 60              	   422:   rts
                        	   423: 
                        	   424: ;---------------------------------------------
                        	   425: ;
                        	   426: ;  Receive messave, slave address in A (excluding write bit)
                        	   427: ;  Message in (VALUE)
                        	   428: ;  Length in Y
                        	   429: ;---------------------------------------------
                        	   430: 
                        	   431: i2c_receive:
00:D2EF 848C            	   432:   sty hardware_work
00:D2F1 38              	   433:   sec
00:D2F2 2A              	   434:   rol A   ; move one into write bit (so it is read mode)
00:D2F3 20EAD1          	   435:   jsr i2c_begin_transmission
00:D2F6 901F            	   436:   bcc i2c_receive_fail
                        	   437: 
                        	   438: ;
                        	   439: ;  put serial data (SDA) into input mode so we can read from it
                        	   440: ;
00:D2F8 A908            	   441:   lda #I2C_SDA
00:D2FA 1CF37F          	   442:   trb I2C_DDR
                        	   443: 
                        	   444: ;
                        	   445: ;  receive each byte
                        	   446: ;
                        	   447: i2c_receive_loop:
00:D2FD A58C            	   448:   lda hardware_work           ; number of bytes to go
00:D2FF F011            	   449:   beq i2c_receive_done
00:D301 C68C            	   450:   dec hardware_work
00:D303 2057D2          	   451:   jsr i2c_read
00:D306 A000            	   452:   ldy #0
00:D308 9100            	   453:   sta (VALUE),Y
00:D30A E600            	   454:   inc VALUE
00:D30C D0EF            	   455:   bne i2c_receive_loop
00:D30E E601            	   456:   inc VALUE+1
00:D310 80EB            	   457:   bra i2c_receive_loop
                        	   458: ;
                        	   459: ;  receiving done
                        	   460: ;
                        	   461: i2c_receive_done:
00:D312 20ADD2          	   462:   jsr i2c_end_transmission
00:D315 38              	   463:   sec
00:D316 60              	   464:   rts
                        	   465: ;
                        	   466: ;  receiving failure
                        	   467: ;
                        	   468: i2c_receive_fail:
00:D317 20ADD2          	   469:   jsr i2c_end_transmission
00:D31A 18              	   470:   clc
00:D31B 60              	   471:   rts
                        	   472: 
                        	   473: 

Source: "gpascal.asm"
                        	   202:   .include "spi.inc"

Source: "spi.inc"
                        	     1: ;
                        	     2: ;  SPI interface routines
                        	     3: ;
                        	     4: ; Author: Nick Gammon
                        	     5: ; Date: 6 March 2022
                        	     6: ;
                        	     7: 
                        	     8: ; Configuration of which VIA ports are used by SS, MOSI, MISO, SCK
                        	     9: 
                        	    10: SPI_SS    = %00000001   ; SS   (slave select) - PB0
                        	    11: SPI_MOSI  = %00000010   ; MOSI (master out, slave in) - PB1
                        	    12: SPI_MISO  = %00000100   ; MISO (master in, slave out) - PB2
                        	    13: SPI_SCK   = %00001000   ; SCK  (serial clock) - PB3
                        	    14: 
                        	    15: SPI_PORT    = VIA_PORTB   ; PORT B
                        	    16: SPI_DDR     = VIA_DDRB    ; DDR  B
                        	    17: 
                        	    18: ;---------------------------------------------
                        	    19: ;  Initialise hardware for SPI comms.
                        	    20: ;
                        	    21: ;  SPI mode in A, as follows:
                        	    22: 
                        	    23: ;   Mode 0 - clock is normally low,  the data is sampled on the transition from low to high (leading edge)
                        	    24: ;   Mode 1 - clock is normally low,  the data is sampled on the transition from high to low (trailing edge)
                        	    25: ;   Mode 2 - clock is normally high, the data is sampled on the transition from high to low (leading edge)
                        	    26: ;   Mode 3 - clock is normally high, the data is sampled on the transition from low to high (trailing edge)
                        	    27: ;
                        	    28: ;  Set SS, MOSI and SCK to outputs. Set MISO to input.
                        	    29: ;---------------------------------------------
                        	    30: spi_init:
                        	    31: 
00:D31C 8568            	    32:   sta spi_mode
                        	    33: 
                        	    34: ;
                        	    35: ;  Set MISO to input
                        	    36: ;
                        	    37: 
00:D31E A904            	    38:   lda #SPI_MISO
00:D320 1CF27F          	    39:   trb SPI_DDR
                        	    40: 
                        	    41: ;
                        	    42: ;  Set SS to high (it is active low)
                        	    43: ;
00:D323 A901            	    44:   lda #SPI_SS
00:D325 0CF07F          	    45:   tsb SPI_PORT
                        	    46: 
                        	    47: ;
                        	    48: ; In modes 0 and 1, the clock is normally low
                        	    49: ;
00:D328 A568            	    50:   lda spi_mode
00:D32A 2902            	    51:   and #2
00:D32C D007            	    52:   bne spi_init_clock_high
                        	    53: 
00:D32E A908            	    54:   lda #SPI_SCK
00:D330 1CF07F          	    55:   trb SPI_PORT
00:D333 8005            	    56:   bra spi_init2
                        	    57: 
                        	    58: ;
                        	    59: ; In modes 2 and 3, the clock is normally high
                        	    60: ;
                        	    61: spi_init_clock_high:
00:D335 A908            	    62:   lda #SPI_SCK
00:D337 0CF07F          	    63:   tsb SPI_PORT
                        	    64: ;
                        	    65: ;  Now set up MOSI
                        	    66: ;
                        	    67: 
                        	    68: spi_init2:
                        	    69: 
00:D33A A568            	    70:   lda spi_mode
00:D33C 2901            	    71:   and #1
00:D33E D007            	    72:   bne spi_init_mosi_low
                        	    73: 
                        	    74: ;
                        	    75: ;  In modes 0 and 2, MOSI idles high
                        	    76: ;
00:D340 A902            	    77:   lda #SPI_MOSI
00:D342 0CF07F          	    78:   tsb SPI_PORT
00:D345 8005            	    79:   bra spi_init3
                        	    80: 
                        	    81: ;
                        	    82: ;  In modes 1 and 3, MOSI idles low
                        	    83: ;
                        	    84: 
                        	    85: spi_init_mosi_low:
00:D347 A902            	    86:   lda #SPI_MOSI
00:D349 1CF07F          	    87:   trb SPI_PORT
                        	    88: 
                        	    89: ;
                        	    90: ;   Set SS, MOSI and SCK to outputs
                        	    91: ;
                        	    92: 
                        	    93: spi_init3:
00:D34C A90B            	    94:   lda #SPI_SS | SPI_MOSI | SPI_SCK
00:D34E 0CF27F          	    95:   tsb SPI_DDR
                        	    96: 
00:D351 60              	    97:   rts
                        	    98: 
                        	    99: ;---------------------------------------------
                        	   100: ;  Transfer one byte.
                        	   101: ;    Byte to be sent in A.
                        	   102: ;    Returns received byte in A.
                        	   103: ;    Preserves X and Y
                        	   104: ;
                        	   105: ;   Mode 0 - clock is normally low,  the data is sampled on the transition from low to high (leading edge)
                        	   106: ;   Mode 1 - clock is normally low,  the data is sampled on the transition from high to low (trailing edge)
                        	   107: ;   Mode 2 - clock is normally high, the data is sampled on the transition from high to low (leading edge)
                        	   108: ;   Mode 3 - clock is normally high, the data is sampled on the transition from low to high (trailing edge)
                        	   109: ;---------------------------------------------
                        	   110: 
                        	   111: spi_transfer:
00:D352 DA              	   112:   phx
00:D353 5A              	   113:   phy
00:D354 A208            	   114:   ldx  #8               ; count of bits
00:D356 A8              	   115:   tay                   ; save the byte we are sending
                        	   116: spi_transfer_loop:
00:D357 98              	   117:   tya                   ; get the byte we are sending back
                        	   118: ;
                        	   119: ;  set up MOSI, ready to be sampled on the clock transition
                        	   120: ;
00:D358 2A              	   121:   rol A                 ; get MSB into carry
00:D359 A8              	   122:   tay                   ; save the byte which we shifted left
00:D35A 9007            	   123:   bcc spi_send_zero     ; if no carry, we are sending a zero
                        	   124: 
                        	   125: ;
                        	   126: ; here to send a one bit
                        	   127: ;
00:D35C A902            	   128:   lda #SPI_MOSI
00:D35E 0CF07F          	   129:   tsb SPI_PORT    ; set MOSI to high
00:D361 8005            	   130:   bra spi_send_clock_pulse_1
                        	   131: 
                        	   132: ;
                        	   133: ; here to send a zero bit
                        	   134: ;
                        	   135: spi_send_zero:
00:D363 A902            	   136:   lda #SPI_MOSI
00:D365 1CF07F          	   137:   trb SPI_PORT    ; set MOSI to low
                        	   138: 
                        	   139: ;
                        	   140: ; transition clock
                        	   141: ;
                        	   142: spi_send_clock_pulse_1:
                        	   143: 
                        	   144: ;
                        	   145: ; In modes 0 and 1, the clock is normally low, so we need to make it high
                        	   146: ;
00:D368 A568            	   147:   lda spi_mode
00:D36A 2902            	   148:   and #2
00:D36C D007            	   149:   bne spi_send_clock_high_low
                        	   150: 
                        	   151: ;
                        	   152: ; Make SCK high
                        	   153: ;
00:D36E A908            	   154:   lda #SPI_SCK
00:D370 0CF07F          	   155:   tsb SPI_PORT
00:D373 8005            	   156:   bra spi_send2
                        	   157: 
                        	   158: ;
                        	   159: ; Otherwise we need to make it low
                        	   160: ;
                        	   161: spi_send_clock_high_low:
                        	   162: ;
                        	   163: ;  Make SCK low
                        	   164: ;
00:D375 A908            	   165:   lda #SPI_SCK
00:D377 1CF07F          	   166:   trb SPI_PORT
                        	   167: 
                        	   168: ;
                        	   169: ;  We have done the leading edge of SCK
                        	   170: ;
                        	   171: spi_send2:
                        	   172: 
                        	   173: ;
                        	   174: ;  In modes 1 and 3 we sample on the trailing edge, so do nothing here
                        	   175: ;
00:D37A A568            	   176:   lda spi_mode
00:D37C 2901            	   177:   and #1
00:D37E D00B            	   178:   bne spi_send3
                        	   179: 
                        	   180: ;
                        	   181: ;  sample incoming data on leading edge
                        	   182: ;
00:D380 18              	   183:   clc
00:D381 A904            	   184:   lda #SPI_MISO
00:D383 2DF07F          	   185:   and SPI_PORT
00:D386 F001            	   186:   beq spi_read_02_done
00:D388 38              	   187:   sec
                        	   188: spi_read_02_done:
00:D389 268C            	   189:   rol hardware_work   ; rotate in zero or one from carry
                        	   190: 
                        	   191: spi_send3:
                        	   192: 
                        	   193: ;
                        	   194: ;  transition clock again to give the trailing edge
                        	   195: ;
                        	   196: 
                        	   197: ;
                        	   198: ; In modes 0 and 1, the clock is normally low, so we need to make it low again
                        	   199: ;
00:D38B A568            	   200:   lda spi_mode
00:D38D 2902            	   201:   and #2
00:D38F D007            	   202:   bne spi_send_clock_low_high
                        	   203: 
00:D391 A908            	   204:   lda #SPI_SCK
00:D393 1CF07F          	   205:   trb SPI_PORT
00:D396 8005            	   206:   bra spi_send4
                        	   207: 
                        	   208: spi_send_clock_low_high:
00:D398 A908            	   209:   lda #SPI_SCK
00:D39A 0CF07F          	   210:   tsb SPI_PORT
                        	   211: 
                        	   212: spi_send4:
                        	   213: 
                        	   214: ;
                        	   215: ;  In modes 1 and 3 we sample on the trailing edge
                        	   216: ;
00:D39D A568            	   217:   lda spi_mode
00:D39F 2901            	   218:   and #1
00:D3A1 F00B            	   219:   beq spi_send_bit_done
                        	   220: 
                        	   221: ;
                        	   222: ;  sample incoming data on trailing edge
                        	   223: ;
00:D3A3 18              	   224:   clc
00:D3A4 A904            	   225:   lda #SPI_MISO
00:D3A6 2DF07F          	   226:   and SPI_PORT
00:D3A9 F001            	   227:   beq spi_read_13_done
00:D3AB 38              	   228:   sec
                        	   229: spi_read_13_done:
00:D3AC 268C            	   230:   rol hardware_work   ; rotate in zero or one from carry
                        	   231: 
                        	   232: spi_send_bit_done:
00:D3AE CA              	   233:   dex
00:D3AF D0A6            	   234:   bne spi_transfer_loop
                        	   235: 
                        	   236: ;
                        	   237: ;  get incoming byte back into A
                        	   238: ;
00:D3B1 7A              	   239:   ply
00:D3B2 FA              	   240:   plx
00:D3B3 A58C            	   241:   lda hardware_work
00:D3B5 60              	   242:   rts
                        	   243: 
                        	   244: 
                        	   245: ;---------------------------------------------
                        	   246: ; Select the slave (send SS low) - preserves all registers
                        	   247: ;---------------------------------------------
                        	   248: spi_ss_low:
00:D3B6 48              	   249:   pha
00:D3B7 A901            	   250:   lda #SPI_SS
00:D3B9 1CF07F          	   251:   trb SPI_PORT
00:D3BC 68              	   252:   pla
00:D3BD 60              	   253:   rts
                        	   254: 
                        	   255: ;---------------------------------------------
                        	   256: ; Deselect the slave (send SS high) - preserves all registers
                        	   257: ;---------------------------------------------
                        	   258: spi_ss_high:
00:D3BE 48              	   259:   pha
00:D3BF A901            	   260:   lda #SPI_SS
00:D3C1 0CF07F          	   261:   tsb SPI_PORT
00:D3C4 68              	   262:   pla
00:D3C5 60              	   263:   rts
                        	   264: 
                        	   265: ;---------------------------------------------
                        	   266: ;  send two bytes: first in A, second in X
                        	   267: ;   preserves all registers
                        	   268: ;---------------------------------------------
                        	   269: spi_send_two_bytes:
00:D3C6 48              	   270:   pha
00:D3C7 20B6D3          	   271:   jsr spi_ss_low    ; SS low
00:D3CA 2052D3          	   272:   jsr spi_transfer  ; send first byte
00:D3CD 8A              	   273:   txa               ; get second byte
00:D3CE 2052D3          	   274:   jsr spi_transfer  ; send second byte
00:D3D1 20BED3          	   275:   jsr spi_ss_high   ; SS high again
00:D3D4 68              	   276:   pla
00:D3D5 60              	   277:   rts
                        	   278: 
                        	   279: 

Source: "gpascal.asm"
                        	   203: 
                        	   204:   .if USE_CP437_FONT
                        	   205:     .include "cp437_font.inc"

Source: "cp437_font.inc"
                        	     1: ; bit patterns for the CP437 font
                        	     2: 
                        	     3: cp437_font:
                        	     4: 
00:D3D6 00              	     5:   dfb $00,$00,$00,$00,$00,$00,$00,$00 ; $00
00:D3D7 00
00:D3D8 00
00:D3D9 00
00:D3DA 00
00:D3DB 00
00:D3DC 00
00:D3DD 00
00:D3DE 7E              	     6:   dfb $7E,$81,$A5,$81,$BD,$99,$81,$7E ; $01
00:D3DF 81
00:D3E0 A5
00:D3E1 81
00:D3E2 BD
00:D3E3 99
00:D3E4 81
00:D3E5 7E
00:D3E6 7E              	     7:   dfb $7E,$FF,$DB,$FF,$C3,$E7,$FF,$7E ; $02
00:D3E7 FF
00:D3E8 DB
00:D3E9 FF
00:D3EA C3
00:D3EB E7
00:D3EC FF
00:D3ED 7E
00:D3EE 6C              	     8:   dfb $6C,$FE,$FE,$FE,$7C,$38,$10,$00 ; $03
00:D3EF FE
00:D3F0 FE
00:D3F1 FE
00:D3F2 7C
00:D3F3 38
00:D3F4 10
00:D3F5 00
00:D3F6 10              	     9:   dfb $10,$38,$7C,$FE,$7C,$38,$10,$00 ; $04
00:D3F7 38
00:D3F8 7C
00:D3F9 FE
00:D3FA 7C
00:D3FB 38
00:D3FC 10
00:D3FD 00
00:D3FE 38              	    10:   dfb $38,$7C,$38,$FE,$FE,$7C,$38,$7C ; $05
00:D3FF 7C
00:D400 38
00:D401 FE
00:D402 FE
00:D403 7C
00:D404 38
00:D405 7C
00:D406 10              	    11:   dfb $10,$10,$38,$7C,$FE,$7C,$38,$7C ; $06
00:D407 10
00:D408 38
00:D409 7C
00:D40A FE
00:D40B 7C
00:D40C 38
00:D40D 7C
00:D40E 00              	    12:   dfb $00,$00,$18,$3C,$3C,$18,$00,$00 ; $07
00:D40F 00
00:D410 18
00:D411 3C
00:D412 3C
00:D413 18
00:D414 00
00:D415 00
00:D416 FF              	    13:   dfb $FF,$FF,$E7,$C3,$C3,$E7,$FF,$FF ; $08
00:D417 FF
00:D418 E7
00:D419 C3
00:D41A C3
00:D41B E7
00:D41C FF
00:D41D FF
00:D41E 00              	    14:   dfb $00,$3C,$66,$42,$42,$66,$3C,$00 ; $09
00:D41F 3C
00:D420 66
00:D421 42
00:D422 42
00:D423 66
00:D424 3C
00:D425 00
00:D426 FF              	    15:   dfb $FF,$C3,$99,$BD,$BD,$99,$C3,$FF ; $0A
00:D427 C3
00:D428 99
00:D429 BD
00:D42A BD
00:D42B 99
00:D42C C3
00:D42D FF
00:D42E 0F              	    16:   dfb $0F,$07,$0F,$7D,$CC,$CC,$CC,$78 ; $0B
00:D42F 07
00:D430 0F
00:D431 7D
00:D432 CC
00:D433 CC
00:D434 CC
00:D435 78
00:D436 3C              	    17:   dfb $3C,$66,$66,$66,$3C,$18,$7E,$18 ; $0C
00:D437 66
00:D438 66
00:D439 66
00:D43A 3C
00:D43B 18
00:D43C 7E
00:D43D 18
00:D43E 3F              	    18:   dfb $3F,$33,$3F,$30,$30,$70,$F0,$E0 ; $0D
00:D43F 33
00:D440 3F
00:D441 30
00:D442 30
00:D443 70
00:D444 F0
00:D445 E0
00:D446 7F              	    19:   dfb $7F,$63,$7F,$63,$63,$67,$E6,$C0 ; $0E
00:D447 63
00:D448 7F
00:D449 63
00:D44A 63
00:D44B 67
00:D44C E6
00:D44D C0
00:D44E 99              	    20:   dfb $99,$5A,$3C,$E7,$E7,$3C,$5A,$99 ; $0F
00:D44F 5A
00:D450 3C
00:D451 E7
00:D452 E7
00:D453 3C
00:D454 5A
00:D455 99
00:D456 80              	    21:   dfb $80,$E0,$F8,$FE,$F8,$E0,$80,$00 ; $10
00:D457 E0
00:D458 F8
00:D459 FE
00:D45A F8
00:D45B E0
00:D45C 80
00:D45D 00
00:D45E 02              	    22:   dfb $02,$0E,$3E,$FE,$3E,$0E,$02,$00 ; $11
00:D45F 0E
00:D460 3E
00:D461 FE
00:D462 3E
00:D463 0E
00:D464 02
00:D465 00
00:D466 18              	    23:   dfb $18,$3C,$7E,$18,$18,$7E,$3C,$18 ; $12
00:D467 3C
00:D468 7E
00:D469 18
00:D46A 18
00:D46B 7E
00:D46C 3C
00:D46D 18
00:D46E 66              	    24:   dfb $66,$66,$66,$66,$66,$00,$66,$00 ; $13
00:D46F 66
00:D470 66
00:D471 66
00:D472 66
00:D473 00
00:D474 66
00:D475 00
00:D476 7F              	    25:   dfb $7F,$DB,$DB,$7B,$1B,$1B,$1B,$00 ; $14
00:D477 DB
00:D478 DB
00:D479 7B
00:D47A 1B
00:D47B 1B
00:D47C 1B
00:D47D 00
00:D47E 3E              	    26:   dfb $3E,$63,$38,$6C,$6C,$38,$CC,$78 ; $15
00:D47F 63
00:D480 38
00:D481 6C
00:D482 6C
00:D483 38
00:D484 CC
00:D485 78
00:D486 00              	    27:   dfb $00,$00,$00,$00,$7E,$7E,$7E,$00 ; $16
00:D487 00
00:D488 00
00:D489 00
00:D48A 7E
00:D48B 7E
00:D48C 7E
00:D48D 00
00:D48E 18              	    28:   dfb $18,$3C,$7E,$18,$7E,$3C,$18,$FF ; $17
00:D48F 3C
00:D490 7E
00:D491 18
00:D492 7E
00:D493 3C
00:D494 18
00:D495 FF
00:D496 18              	    29:   dfb $18,$3C,$7E,$18,$18,$18,$18,$00 ; $18
00:D497 3C
00:D498 7E
00:D499 18
00:D49A 18
00:D49B 18
00:D49C 18
00:D49D 00
00:D49E 18              	    30:   dfb $18,$18,$18,$18,$7E,$3C,$18,$00 ; $19
00:D49F 18
00:D4A0 18
00:D4A1 18
00:D4A2 7E
00:D4A3 3C
00:D4A4 18
00:D4A5 00
00:D4A6 00              	    31:   dfb $00,$18,$0C,$FE,$0C,$18,$00,$00 ; $1A
00:D4A7 18
00:D4A8 0C
00:D4A9 FE
00:D4AA 0C
00:D4AB 18
00:D4AC 00
00:D4AD 00
00:D4AE 00              	    32:   dfb $00,$30,$60,$FE,$60,$30,$00,$00 ; $1B
00:D4AF 30
00:D4B0 60
00:D4B1 FE
00:D4B2 60
00:D4B3 30
00:D4B4 00
00:D4B5 00
00:D4B6 00              	    33:   dfb $00,$00,$C0,$C0,$C0,$FE,$00,$00 ; $1C
00:D4B7 00
00:D4B8 C0
00:D4B9 C0
00:D4BA C0
00:D4BB FE
00:D4BC 00
00:D4BD 00
00:D4BE 00              	    34:   dfb $00,$24,$66,$FF,$66,$24,$00,$00 ; $1D
00:D4BF 24
00:D4C0 66
00:D4C1 FF
00:D4C2 66
00:D4C3 24
00:D4C4 00
00:D4C5 00
00:D4C6 00              	    35:   dfb $00,$18,$3C,$7E,$FF,$FF,$00,$00 ; $1E
00:D4C7 18
00:D4C8 3C
00:D4C9 7E
00:D4CA FF
00:D4CB FF
00:D4CC 00
00:D4CD 00
00:D4CE 00              	    36:   dfb $00,$FF,$FF,$7E,$3C,$18,$00,$00 ; $1F
00:D4CF FF
00:D4D0 FF
00:D4D1 7E
00:D4D2 3C
00:D4D3 18
00:D4D4 00
00:D4D5 00
00:D4D6 00              	    37:   dfb $00,$00,$00,$00,$00,$00,$00,$00 ; ' '
00:D4D7 00
00:D4D8 00
00:D4D9 00
00:D4DA 00
00:D4DB 00
00:D4DC 00
00:D4DD 00
00:D4DE 30              	    38:   dfb $30,$78,$78,$30,$30,$00,$30,$00 ; '!'
00:D4DF 78
00:D4E0 78
00:D4E1 30
00:D4E2 30
00:D4E3 00
00:D4E4 30
00:D4E5 00
00:D4E6 6C              	    39:   dfb $6C,$6C,$6C,$00,$00,$00,$00,$00 ; '"'
00:D4E7 6C
00:D4E8 6C
00:D4E9 00
00:D4EA 00
00:D4EB 00
00:D4EC 00
00:D4ED 00
00:D4EE 6C              	    40:   dfb $6C,$6C,$FE,$6C,$FE,$6C,$6C,$00 ; '#'
00:D4EF 6C
00:D4F0 FE
00:D4F1 6C
00:D4F2 FE
00:D4F3 6C
00:D4F4 6C
00:D4F5 00
00:D4F6 30              	    41:   dfb $30,$7C,$C0,$78,$0C,$F8,$30,$00 ; '$'
00:D4F7 7C
00:D4F8 C0
00:D4F9 78
00:D4FA 0C
00:D4FB F8
00:D4FC 30
00:D4FD 00
00:D4FE 00              	    42:   dfb $00,$C6,$CC,$18,$30,$66,$C6,$00 ; '%'
00:D4FF C6
00:D500 CC
00:D501 18
00:D502 30
00:D503 66
00:D504 C6
00:D505 00
00:D506 38              	    43:   dfb $38,$6C,$38,$76,$DC,$CC,$76,$00 ; '&'
00:D507 6C
00:D508 38
00:D509 76
00:D50A DC
00:D50B CC
00:D50C 76
00:D50D 00
00:D50E 60              	    44:   dfb $60,$60,$C0,$00,$00,$00,$00,$00 ; '''
00:D50F 60
00:D510 C0
00:D511 00
00:D512 00
00:D513 00
00:D514 00
00:D515 00
00:D516 18              	    45:   dfb $18,$30,$60,$60,$60,$30,$18,$00 ; '('
00:D517 30
00:D518 60
00:D519 60
00:D51A 60
00:D51B 30
00:D51C 18
00:D51D 00
00:D51E 60              	    46:   dfb $60,$30,$18,$18,$18,$30,$60,$00 ; ')'
00:D51F 30
00:D520 18
00:D521 18
00:D522 18
00:D523 30
00:D524 60
00:D525 00
00:D526 00              	    47:   dfb $00,$66,$3C,$FF,$3C,$66,$00,$00 ; '*'
00:D527 66
00:D528 3C
00:D529 FF
00:D52A 3C
00:D52B 66
00:D52C 00
00:D52D 00
00:D52E 00              	    48:   dfb $00,$30,$30,$FC,$30,$30,$00,$00 ; '+'
00:D52F 30
00:D530 30
00:D531 FC
00:D532 30
00:D533 30
00:D534 00
00:D535 00
00:D536 00              	    49:   dfb $00,$00,$00,$00,$00,$30,$30,$60 ; ','
00:D537 00
00:D538 00
00:D539 00
00:D53A 00
00:D53B 30
00:D53C 30
00:D53D 60
00:D53E 00              	    50:   dfb $00,$00,$00,$FC,$00,$00,$00,$00 ; '-'
00:D53F 00
00:D540 00
00:D541 FC
00:D542 00
00:D543 00
00:D544 00
00:D545 00
00:D546 00              	    51:   dfb $00,$00,$00,$00,$00,$30,$30,$00 ; '.'
00:D547 00
00:D548 00
00:D549 00
00:D54A 00
00:D54B 30
00:D54C 30
00:D54D 00
00:D54E 06              	    52:   dfb $06,$0C,$18,$30,$60,$C0,$80,$00 ; '/'
00:D54F 0C
00:D550 18
00:D551 30
00:D552 60
00:D553 C0
00:D554 80
00:D555 00
00:D556 7C              	    53:   dfb $7C,$C6,$CE,$DE,$F6,$E6,$7C,$00 ; '0'
00:D557 C6
00:D558 CE
00:D559 DE
00:D55A F6
00:D55B E6
00:D55C 7C
00:D55D 00
00:D55E 30              	    54:   dfb $30,$70,$30,$30,$30,$30,$FC,$00 ; '1'
00:D55F 70
00:D560 30
00:D561 30
00:D562 30
00:D563 30
00:D564 FC
00:D565 00
00:D566 78              	    55:   dfb $78,$CC,$0C,$38,$60,$CC,$FC,$00 ; '2'
00:D567 CC
00:D568 0C
00:D569 38
00:D56A 60
00:D56B CC
00:D56C FC
00:D56D 00
00:D56E 78              	    56:   dfb $78,$CC,$0C,$38,$0C,$CC,$78,$00 ; '3'
00:D56F CC
00:D570 0C
00:D571 38
00:D572 0C
00:D573 CC
00:D574 78
00:D575 00
00:D576 1C              	    57:   dfb $1C,$3C,$6C,$CC,$FE,$0C,$1E,$00 ; '4'
00:D577 3C
00:D578 6C
00:D579 CC
00:D57A FE
00:D57B 0C
00:D57C 1E
00:D57D 00
00:D57E FC              	    58:   dfb $FC,$C0,$F8,$0C,$0C,$CC,$78,$00 ; '5'
00:D57F C0
00:D580 F8
00:D581 0C
00:D582 0C
00:D583 CC
00:D584 78
00:D585 00
00:D586 38              	    59:   dfb $38,$60,$C0,$F8,$CC,$CC,$78,$00 ; '6'
00:D587 60
00:D588 C0
00:D589 F8
00:D58A CC
00:D58B CC
00:D58C 78
00:D58D 00
00:D58E FC              	    60:   dfb $FC,$CC,$0C,$18,$30,$30,$30,$00 ; '7'
00:D58F CC
00:D590 0C
00:D591 18
00:D592 30
00:D593 30
00:D594 30
00:D595 00
00:D596 78              	    61:   dfb $78,$CC,$CC,$78,$CC,$CC,$78,$00 ; '8'
00:D597 CC
00:D598 CC
00:D599 78
00:D59A CC
00:D59B CC
00:D59C 78
00:D59D 00
00:D59E 78              	    62:   dfb $78,$CC,$CC,$7C,$0C,$18,$70,$00 ; '9'
00:D59F CC
00:D5A0 CC
00:D5A1 7C
00:D5A2 0C
00:D5A3 18
00:D5A4 70
00:D5A5 00
00:D5A6 00              	    63:   dfb $00,$30,$30,$00,$00,$30,$30,$00 ; ':'
00:D5A7 30
00:D5A8 30
00:D5A9 00
00:D5AA 00
00:D5AB 30
00:D5AC 30
00:D5AD 00
00:D5AE 00              	    64:   dfb $00,$30,$30,$00,$00,$30,$30,$60 ; ';'
00:D5AF 30
00:D5B0 30
00:D5B1 00
00:D5B2 00
00:D5B3 30
00:D5B4 30
00:D5B5 60
00:D5B6 18              	    65:   dfb $18,$30,$60,$C0,$60,$30,$18,$00 ; '<'
00:D5B7 30
00:D5B8 60
00:D5B9 C0
00:D5BA 60
00:D5BB 30
00:D5BC 18
00:D5BD 00
00:D5BE 00              	    66:   dfb $00,$00,$FC,$00,$00,$FC,$00,$00 ; '='
00:D5BF 00
00:D5C0 FC
00:D5C1 00
00:D5C2 00
00:D5C3 FC
00:D5C4 00
00:D5C5 00
00:D5C6 60              	    67:   dfb $60,$30,$18,$0C,$18,$30,$60,$00 ; '>'
00:D5C7 30
00:D5C8 18
00:D5C9 0C
00:D5CA 18
00:D5CB 30
00:D5CC 60
00:D5CD 00
00:D5CE 78              	    68:   dfb $78,$CC,$0C,$18,$30,$00,$30,$00 ; '?'
00:D5CF CC
00:D5D0 0C
00:D5D1 18
00:D5D2 30
00:D5D3 00
00:D5D4 30
00:D5D5 00
00:D5D6 7C              	    69:   dfb $7C,$C6,$DE,$DE,$DE,$C0,$78,$00 ; '@'
00:D5D7 C6
00:D5D8 DE
00:D5D9 DE
00:D5DA DE
00:D5DB C0
00:D5DC 78
00:D5DD 00
00:D5DE 30              	    70:   dfb $30,$78,$CC,$CC,$FC,$CC,$CC,$00 ; 'A'
00:D5DF 78
00:D5E0 CC
00:D5E1 CC
00:D5E2 FC
00:D5E3 CC
00:D5E4 CC
00:D5E5 00
00:D5E6 FC              	    71:   dfb $FC,$66,$66,$7C,$66,$66,$FC,$00 ; 'B'
00:D5E7 66
00:D5E8 66
00:D5E9 7C
00:D5EA 66
00:D5EB 66
00:D5EC FC
00:D5ED 00
00:D5EE 3C              	    72:   dfb $3C,$66,$C0,$C0,$C0,$66,$3C,$00 ; 'C'
00:D5EF 66
00:D5F0 C0
00:D5F1 C0
00:D5F2 C0
00:D5F3 66
00:D5F4 3C
00:D5F5 00
00:D5F6 F8              	    73:   dfb $F8,$6C,$66,$66,$66,$6C,$F8,$00 ; 'D'
00:D5F7 6C
00:D5F8 66
00:D5F9 66
00:D5FA 66
00:D5FB 6C
00:D5FC F8
00:D5FD 00
00:D5FE FE              	    74:   dfb $FE,$62,$68,$78,$68,$62,$FE,$00 ; 'E'
00:D5FF 62
00:D600 68
00:D601 78
00:D602 68
00:D603 62
00:D604 FE
00:D605 00
00:D606 FE              	    75:   dfb $FE,$62,$68,$78,$68,$60,$F0,$00 ; 'F'
00:D607 62
00:D608 68
00:D609 78
00:D60A 68
00:D60B 60
00:D60C F0
00:D60D 00
00:D60E 3C              	    76:   dfb $3C,$66,$C0,$C0,$CE,$66,$3E,$00 ; 'G'
00:D60F 66
00:D610 C0
00:D611 C0
00:D612 CE
00:D613 66
00:D614 3E
00:D615 00
00:D616 CC              	    77:   dfb $CC,$CC,$CC,$FC,$CC,$CC,$CC,$00 ; 'H'
00:D617 CC
00:D618 CC
00:D619 FC
00:D61A CC
00:D61B CC
00:D61C CC
00:D61D 00
00:D61E 78              	    78:   dfb $78,$30,$30,$30,$30,$30,$78,$00 ; 'I'
00:D61F 30
00:D620 30
00:D621 30
00:D622 30
00:D623 30
00:D624 78
00:D625 00
00:D626 1E              	    79:   dfb $1E,$0C,$0C,$0C,$CC,$CC,$78,$00 ; 'J'
00:D627 0C
00:D628 0C
00:D629 0C
00:D62A CC
00:D62B CC
00:D62C 78
00:D62D 00
00:D62E E6              	    80:   dfb $E6,$66,$6C,$78,$6C,$66,$E6,$00 ; 'K'
00:D62F 66
00:D630 6C
00:D631 78
00:D632 6C
00:D633 66
00:D634 E6
00:D635 00
00:D636 F0              	    81:   dfb $F0,$60,$60,$60,$62,$66,$FE,$00 ; 'L'
00:D637 60
00:D638 60
00:D639 60
00:D63A 62
00:D63B 66
00:D63C FE
00:D63D 00
00:D63E C6              	    82:   dfb $C6,$EE,$FE,$FE,$D6,$C6,$C6,$00 ; 'M'
00:D63F EE
00:D640 FE
00:D641 FE
00:D642 D6
00:D643 C6
00:D644 C6
00:D645 00
00:D646 C6              	    83:   dfb $C6,$E6,$F6,$DE,$CE,$C6,$C6,$00 ; 'N'
00:D647 E6
00:D648 F6
00:D649 DE
00:D64A CE
00:D64B C6
00:D64C C6
00:D64D 00
00:D64E 38              	    84:   dfb $38,$6C,$C6,$C6,$C6,$6C,$38,$00 ; 'O'
00:D64F 6C
00:D650 C6
00:D651 C6
00:D652 C6
00:D653 6C
00:D654 38
00:D655 00
00:D656 FC              	    85:   dfb $FC,$66,$66,$7C,$60,$60,$F0,$00 ; 'P'
00:D657 66
00:D658 66
00:D659 7C
00:D65A 60
00:D65B 60
00:D65C F0
00:D65D 00
00:D65E 78              	    86:   dfb $78,$CC,$CC,$CC,$DC,$78,$1C,$00 ; 'Q'
00:D65F CC
00:D660 CC
00:D661 CC
00:D662 DC
00:D663 78
00:D664 1C
00:D665 00
00:D666 FC              	    87:   dfb $FC,$66,$66,$7C,$6C,$66,$E6,$00 ; 'R'
00:D667 66
00:D668 66
00:D669 7C
00:D66A 6C
00:D66B 66
00:D66C E6
00:D66D 00
00:D66E 78              	    88:   dfb $78,$CC,$E0,$70,$1C,$CC,$78,$00 ; 'S'
00:D66F CC
00:D670 E0
00:D671 70
00:D672 1C
00:D673 CC
00:D674 78
00:D675 00
00:D676 FC              	    89:   dfb $FC,$B4,$30,$30,$30,$30,$78,$00 ; 'T'
00:D677 B4
00:D678 30
00:D679 30
00:D67A 30
00:D67B 30
00:D67C 78
00:D67D 00
00:D67E CC              	    90:   dfb $CC,$CC,$CC,$CC,$CC,$CC,$FC,$00 ; 'U'
00:D67F CC
00:D680 CC
00:D681 CC
00:D682 CC
00:D683 CC
00:D684 FC
00:D685 00
00:D686 CC              	    91:   dfb $CC,$CC,$CC,$CC,$CC,$78,$30,$00 ; 'V'
00:D687 CC
00:D688 CC
00:D689 CC
00:D68A CC
00:D68B 78
00:D68C 30
00:D68D 00
00:D68E C6              	    92:   dfb $C6,$C6,$C6,$D6,$FE,$EE,$C6,$00 ; 'W'
00:D68F C6
00:D690 C6
00:D691 D6
00:D692 FE
00:D693 EE
00:D694 C6
00:D695 00
00:D696 C6              	    93:   dfb $C6,$C6,$6C,$38,$38,$6C,$C6,$00 ; 'X'
00:D697 C6
00:D698 6C
00:D699 38
00:D69A 38
00:D69B 6C
00:D69C C6
00:D69D 00
00:D69E CC              	    94:   dfb $CC,$CC,$CC,$78,$30,$30,$78,$00 ; 'Y'
00:D69F CC
00:D6A0 CC
00:D6A1 78
00:D6A2 30
00:D6A3 30
00:D6A4 78
00:D6A5 00
00:D6A6 FE              	    95:   dfb $FE,$C6,$8C,$18,$32,$66,$FE,$00 ; 'Z'
00:D6A7 C6
00:D6A8 8C
00:D6A9 18
00:D6AA 32
00:D6AB 66
00:D6AC FE
00:D6AD 00
00:D6AE 78              	    96:   dfb $78,$60,$60,$60,$60,$60,$78,$00 ; '['
00:D6AF 60
00:D6B0 60
00:D6B1 60
00:D6B2 60
00:D6B3 60
00:D6B4 78
00:D6B5 00
00:D6B6 C0              	    97:   dfb $C0,$60,$30,$18,$0C,$06,$02,$00 ; back
00:D6B7 60
00:D6B8 30
00:D6B9 18
00:D6BA 0C
00:D6BB 06
00:D6BC 02
00:D6BD 00
00:D6BE 78              	    98:   dfb $78,$18,$18,$18,$18,$18,$78,$00 ; ']'
00:D6BF 18
00:D6C0 18
00:D6C1 18
00:D6C2 18
00:D6C3 18
00:D6C4 78
00:D6C5 00
00:D6C6 10              	    99:   dfb $10,$38,$6C,$C6,$00,$00,$00,$00 ; '^'
00:D6C7 38
00:D6C8 6C
00:D6C9 C6
00:D6CA 00
00:D6CB 00
00:D6CC 00
00:D6CD 00
00:D6CE 00              	   100:   dfb $00,$00,$00,$00,$00,$00,$00,$FF ; '_'
00:D6CF 00
00:D6D0 00
00:D6D1 00
00:D6D2 00
00:D6D3 00
00:D6D4 00
00:D6D5 FF
00:D6D6 30              	   101:   dfb $30,$30,$18,$00,$00,$00,$00,$00 ; '`'
00:D6D7 30
00:D6D8 18
00:D6D9 00
00:D6DA 00
00:D6DB 00
00:D6DC 00
00:D6DD 00
00:D6DE 00              	   102:   dfb $00,$00,$78,$0C,$7C,$CC,$76,$00 ; 'a'
00:D6DF 00
00:D6E0 78
00:D6E1 0C
00:D6E2 7C
00:D6E3 CC
00:D6E4 76
00:D6E5 00
00:D6E6 E0              	   103:   dfb $E0,$60,$60,$7C,$66,$66,$DC,$00 ; 'b'
00:D6E7 60
00:D6E8 60
00:D6E9 7C
00:D6EA 66
00:D6EB 66
00:D6EC DC
00:D6ED 00
00:D6EE 00              	   104:   dfb $00,$00,$78,$CC,$C0,$CC,$78,$00 ; 'c'
00:D6EF 00
00:D6F0 78
00:D6F1 CC
00:D6F2 C0
00:D6F3 CC
00:D6F4 78
00:D6F5 00
00:D6F6 1C              	   105:   dfb $1C,$0C,$0C,$7C,$CC,$CC,$76,$00 ; 'd'
00:D6F7 0C
00:D6F8 0C
00:D6F9 7C
00:D6FA CC
00:D6FB CC
00:D6FC 76
00:D6FD 00
00:D6FE 00              	   106:   dfb $00,$00,$78,$CC,$FC,$C0,$78,$00 ; 'e'
00:D6FF 00
00:D700 78
00:D701 CC
00:D702 FC
00:D703 C0
00:D704 78
00:D705 00
00:D706 38              	   107:   dfb $38,$6C,$60,$F0,$60,$60,$F0,$00 ; 'f'
00:D707 6C
00:D708 60
00:D709 F0
00:D70A 60
00:D70B 60
00:D70C F0
00:D70D 00
00:D70E 00              	   108:   dfb $00,$00,$76,$CC,$CC,$7C,$0C,$F8 ; 'g'
00:D70F 00
00:D710 76
00:D711 CC
00:D712 CC
00:D713 7C
00:D714 0C
00:D715 F8
00:D716 E0              	   109:   dfb $E0,$60,$6C,$76,$66,$66,$E6,$00 ; 'h'
00:D717 60
00:D718 6C
00:D719 76
00:D71A 66
00:D71B 66
00:D71C E6
00:D71D 00
00:D71E 30              	   110:   dfb $30,$00,$70,$30,$30,$30,$78,$00 ; 'i'
00:D71F 00
00:D720 70
00:D721 30
00:D722 30
00:D723 30
00:D724 78
00:D725 00
00:D726 0C              	   111:   dfb $0C,$00,$0C,$0C,$0C,$CC,$CC,$78 ; 'j'
00:D727 00
00:D728 0C
00:D729 0C
00:D72A 0C
00:D72B CC
00:D72C CC
00:D72D 78
00:D72E E0              	   112:   dfb $E0,$60,$66,$6C,$78,$6C,$E6,$00 ; 'k'
00:D72F 60
00:D730 66
00:D731 6C
00:D732 78
00:D733 6C
00:D734 E6
00:D735 00
00:D736 70              	   113:   dfb $70,$30,$30,$30,$30,$30,$78,$00 ; 'l'
00:D737 30
00:D738 30
00:D739 30
00:D73A 30
00:D73B 30
00:D73C 78
00:D73D 00
00:D73E 00              	   114:   dfb $00,$00,$CC,$FE,$FE,$D6,$C6,$00 ; 'm'
00:D73F 00
00:D740 CC
00:D741 FE
00:D742 FE
00:D743 D6
00:D744 C6
00:D745 00
00:D746 00              	   115:   dfb $00,$00,$F8,$CC,$CC,$CC,$CC,$00 ; 'n'
00:D747 00
00:D748 F8
00:D749 CC
00:D74A CC
00:D74B CC
00:D74C CC
00:D74D 00
00:D74E 00              	   116:   dfb $00,$00,$78,$CC,$CC,$CC,$78,$00 ; 'o'
00:D74F 00
00:D750 78
00:D751 CC
00:D752 CC
00:D753 CC
00:D754 78
00:D755 00
00:D756 00              	   117:   dfb $00,$00,$DC,$66,$66,$7C,$60,$F0 ; 'p'
00:D757 00
00:D758 DC
00:D759 66
00:D75A 66
00:D75B 7C
00:D75C 60
00:D75D F0
00:D75E 00              	   118:   dfb $00,$00,$76,$CC,$CC,$7C,$0C,$1E ; 'q'
00:D75F 00
00:D760 76
00:D761 CC
00:D762 CC
00:D763 7C
00:D764 0C
00:D765 1E
00:D766 00              	   119:   dfb $00,$00,$DC,$76,$66,$60,$F0,$00 ; 'r'
00:D767 00
00:D768 DC
00:D769 76
00:D76A 66
00:D76B 60
00:D76C F0
00:D76D 00
00:D76E 00              	   120:   dfb $00,$00,$7C,$C0,$78,$0C,$F8,$00 ; 's'
00:D76F 00
00:D770 7C
00:D771 C0
00:D772 78
00:D773 0C
00:D774 F8
00:D775 00
00:D776 10              	   121:   dfb $10,$30,$7C,$30,$30,$34,$18,$00 ; 't'
00:D777 30
00:D778 7C
00:D779 30
00:D77A 30
00:D77B 34
00:D77C 18
00:D77D 00
00:D77E 00              	   122:   dfb $00,$00,$CC,$CC,$CC,$CC,$76,$00 ; 'u'
00:D77F 00
00:D780 CC
00:D781 CC
00:D782 CC
00:D783 CC
00:D784 76
00:D785 00
00:D786 00              	   123:   dfb $00,$00,$CC,$CC,$CC,$78,$30,$00 ; 'v'
00:D787 00
00:D788 CC
00:D789 CC
00:D78A CC
00:D78B 78
00:D78C 30
00:D78D 00
00:D78E 00              	   124:   dfb $00,$00,$C6,$D6,$FE,$FE,$6C,$00 ; 'w'
00:D78F 00
00:D790 C6
00:D791 D6
00:D792 FE
00:D793 FE
00:D794 6C
00:D795 00
00:D796 00              	   125:   dfb $00,$00,$C6,$6C,$38,$6C,$C6,$00 ; 'x'
00:D797 00
00:D798 C6
00:D799 6C
00:D79A 38
00:D79B 6C
00:D79C C6
00:D79D 00
00:D79E 00              	   126:   dfb $00,$00,$CC,$CC,$CC,$7C,$0C,$F8 ; 'y'
00:D79F 00
00:D7A0 CC
00:D7A1 CC
00:D7A2 CC
00:D7A3 7C
00:D7A4 0C
00:D7A5 F8
00:D7A6 00              	   127:   dfb $00,$00,$FC,$98,$30,$64,$FC,$00 ; 'z'
00:D7A7 00
00:D7A8 FC
00:D7A9 98
00:D7AA 30
00:D7AB 64
00:D7AC FC
00:D7AD 00
00:D7AE 1C              	   128:   dfb $1C,$30,$30,$E0,$30,$30,$1C,$00 ; '{'
00:D7AF 30
00:D7B0 30
00:D7B1 E0
00:D7B2 30
00:D7B3 30
00:D7B4 1C
00:D7B5 00
00:D7B6 18              	   129:   dfb $18,$18,$18,$00,$18,$18,$18,$00 ; '|'
00:D7B7 18
00:D7B8 18
00:D7B9 00
00:D7BA 18
00:D7BB 18
00:D7BC 18
00:D7BD 00
00:D7BE E0              	   130:   dfb $E0,$30,$30,$1C,$30,$30,$E0,$00 ; '}'
00:D7BF 30
00:D7C0 30
00:D7C1 1C
00:D7C2 30
00:D7C3 30
00:D7C4 E0
00:D7C5 00
00:D7C6 76              	   131:   dfb $76,$DC,$00,$00,$00,$00,$00,$00 ; '~'
00:D7C7 DC
00:D7C8 00
00:D7C9 00
00:D7CA 00
00:D7CB 00
00:D7CC 00
00:D7CD 00
00:D7CE 00              	   132:   dfb $00,$10,$38,$6C,$C6,$C6,$FE,$00 ; $7F
00:D7CF 10
00:D7D0 38
00:D7D1 6C
00:D7D2 C6
00:D7D3 C6
00:D7D4 FE
00:D7D5 00
00:D7D6 78              	   133:   dfb $78,$CC,$C0,$CC,$78,$18,$0C,$78 ; $80
00:D7D7 CC
00:D7D8 C0
00:D7D9 CC
00:D7DA 78
00:D7DB 18
00:D7DC 0C
00:D7DD 78
00:D7DE 00              	   134:   dfb $00,$CC,$00,$CC,$CC,$CC,$7E,$00 ; $81
00:D7DF CC
00:D7E0 00
00:D7E1 CC
00:D7E2 CC
00:D7E3 CC
00:D7E4 7E
00:D7E5 00
00:D7E6 1C              	   135:   dfb $1C,$00,$78,$CC,$FC,$C0,$78,$00 ; $82
00:D7E7 00
00:D7E8 78
00:D7E9 CC
00:D7EA FC
00:D7EB C0
00:D7EC 78
00:D7ED 00
00:D7EE 7E              	   136:   dfb $7E,$C3,$3C,$06,$3E,$66,$3F,$00 ; $83
00:D7EF C3
00:D7F0 3C
00:D7F1 06
00:D7F2 3E
00:D7F3 66
00:D7F4 3F
00:D7F5 00
00:D7F6 CC              	   137:   dfb $CC,$00,$78,$0C,$7C,$CC,$7E,$00 ; $84
00:D7F7 00
00:D7F8 78
00:D7F9 0C
00:D7FA 7C
00:D7FB CC
00:D7FC 7E
00:D7FD 00
00:D7FE E0              	   138:   dfb $E0,$00,$78,$0C,$7C,$CC,$7E,$00 ; $85
00:D7FF 00
00:D800 78
00:D801 0C
00:D802 7C
00:D803 CC
00:D804 7E
00:D805 00
00:D806 30              	   139:   dfb $30,$30,$78,$0C,$7C,$CC,$7E,$00 ; $86
00:D807 30
00:D808 78
00:D809 0C
00:D80A 7C
00:D80B CC
00:D80C 7E
00:D80D 00
00:D80E 00              	   140:   dfb $00,$00,$78,$C0,$C0,$78,$0C,$38 ; $87
00:D80F 00
00:D810 78
00:D811 C0
00:D812 C0
00:D813 78
00:D814 0C
00:D815 38
00:D816 7E              	   141:   dfb $7E,$C3,$3C,$66,$7E,$60,$3C,$00 ; $88
00:D817 C3
00:D818 3C
00:D819 66
00:D81A 7E
00:D81B 60
00:D81C 3C
00:D81D 00
00:D81E CC              	   142:   dfb $CC,$00,$78,$CC,$FC,$C0,$78,$00 ; $89
00:D81F 00
00:D820 78
00:D821 CC
00:D822 FC
00:D823 C0
00:D824 78
00:D825 00
00:D826 E0              	   143:   dfb $E0,$00,$78,$CC,$FC,$C0,$78,$00 ; $8A
00:D827 00
00:D828 78
00:D829 CC
00:D82A FC
00:D82B C0
00:D82C 78
00:D82D 00
00:D82E CC              	   144:   dfb $CC,$00,$70,$30,$30,$30,$78,$00 ; $8B
00:D82F 00
00:D830 70
00:D831 30
00:D832 30
00:D833 30
00:D834 78
00:D835 00
00:D836 7C              	   145:   dfb $7C,$C6,$38,$18,$18,$18,$3C,$00 ; $8C
00:D837 C6
00:D838 38
00:D839 18
00:D83A 18
00:D83B 18
00:D83C 3C
00:D83D 00
00:D83E E0              	   146:   dfb $E0,$00,$70,$30,$30,$30,$78,$00 ; $8D
00:D83F 00
00:D840 70
00:D841 30
00:D842 30
00:D843 30
00:D844 78
00:D845 00
00:D846 C6              	   147:   dfb $C6,$38,$6C,$C6,$FE,$C6,$C6,$00 ; $8E
00:D847 38
00:D848 6C
00:D849 C6
00:D84A FE
00:D84B C6
00:D84C C6
00:D84D 00
00:D84E 30              	   148:   dfb $30,$30,$00,$78,$CC,$FC,$CC,$00 ; $8F
00:D84F 30
00:D850 00
00:D851 78
00:D852 CC
00:D853 FC
00:D854 CC
00:D855 00
00:D856 1C              	   149:   dfb $1C,$00,$FC,$60,$78,$60,$FC,$00 ; $90
00:D857 00
00:D858 FC
00:D859 60
00:D85A 78
00:D85B 60
00:D85C FC
00:D85D 00
00:D85E 00              	   150:   dfb $00,$00,$7F,$0C,$7F,$CC,$7F,$00 ; $91
00:D85F 00
00:D860 7F
00:D861 0C
00:D862 7F
00:D863 CC
00:D864 7F
00:D865 00
00:D866 3E              	   151:   dfb $3E,$6C,$CC,$FE,$CC,$CC,$CE,$00 ; $92
00:D867 6C
00:D868 CC
00:D869 FE
00:D86A CC
00:D86B CC
00:D86C CE
00:D86D 00
00:D86E 78              	   152:   dfb $78,$CC,$00,$78,$CC,$CC,$78,$00 ; $93
00:D86F CC
00:D870 00
00:D871 78
00:D872 CC
00:D873 CC
00:D874 78
00:D875 00
00:D876 00              	   153:   dfb $00,$CC,$00,$78,$CC,$CC,$78,$00 ; $94
00:D877 CC
00:D878 00
00:D879 78
00:D87A CC
00:D87B CC
00:D87C 78
00:D87D 00
00:D87E 00              	   154:   dfb $00,$E0,$00,$78,$CC,$CC,$78,$00 ; $95
00:D87F E0
00:D880 00
00:D881 78
00:D882 CC
00:D883 CC
00:D884 78
00:D885 00
00:D886 78              	   155:   dfb $78,$CC,$00,$CC,$CC,$CC,$7E,$00 ; $96
00:D887 CC
00:D888 00
00:D889 CC
00:D88A CC
00:D88B CC
00:D88C 7E
00:D88D 00
00:D88E 00              	   156:   dfb $00,$E0,$00,$CC,$CC,$CC,$7E,$00 ; $97
00:D88F E0
00:D890 00
00:D891 CC
00:D892 CC
00:D893 CC
00:D894 7E
00:D895 00
00:D896 00              	   157:   dfb $00,$CC,$00,$CC,$CC,$7C,$0C,$F8 ; $98
00:D897 CC
00:D898 00
00:D899 CC
00:D89A CC
00:D89B 7C
00:D89C 0C
00:D89D F8
00:D89E C3              	   158:   dfb $C3,$18,$3C,$66,$66,$3C,$18,$00 ; $99
00:D89F 18
00:D8A0 3C
00:D8A1 66
00:D8A2 66
00:D8A3 3C
00:D8A4 18
00:D8A5 00
00:D8A6 CC              	   159:   dfb $CC,$00,$CC,$CC,$CC,$CC,$78,$00 ; $9A
00:D8A7 00
00:D8A8 CC
00:D8A9 CC
00:D8AA CC
00:D8AB CC
00:D8AC 78
00:D8AD 00
00:D8AE 18              	   160:   dfb $18,$18,$7E,$C0,$C0,$7E,$18,$18 ; $9B
00:D8AF 18
00:D8B0 7E
00:D8B1 C0
00:D8B2 C0
00:D8B3 7E
00:D8B4 18
00:D8B5 18
00:D8B6 38              	   161:   dfb $38,$6C,$64,$F0,$60,$E6,$FC,$00 ; $9C
00:D8B7 6C
00:D8B8 64
00:D8B9 F0
00:D8BA 60
00:D8BB E6
00:D8BC FC
00:D8BD 00
00:D8BE CC              	   162:   dfb $CC,$CC,$78,$FC,$30,$FC,$30,$30 ; $9D
00:D8BF CC
00:D8C0 78
00:D8C1 FC
00:D8C2 30
00:D8C3 FC
00:D8C4 30
00:D8C5 30
00:D8C6 F8              	   163:   dfb $F8,$CC,$CC,$FA,$C6,$CF,$C6,$C7 ; $9E
00:D8C7 CC
00:D8C8 CC
00:D8C9 FA
00:D8CA C6
00:D8CB CF
00:D8CC C6
00:D8CD C7
00:D8CE 0E              	   164:   dfb $0E,$1B,$18,$3C,$18,$18,$D8,$70 ; $9F
00:D8CF 1B
00:D8D0 18
00:D8D1 3C
00:D8D2 18
00:D8D3 18
00:D8D4 D8
00:D8D5 70
00:D8D6 1C              	   165:   dfb $1C,$00,$78,$0C,$7C,$CC,$7E,$00 ; $A0
00:D8D7 00
00:D8D8 78
00:D8D9 0C
00:D8DA 7C
00:D8DB CC
00:D8DC 7E
00:D8DD 00
00:D8DE 38              	   166:   dfb $38,$00,$70,$30,$30,$30,$78,$00 ; $A1
00:D8DF 00
00:D8E0 70
00:D8E1 30
00:D8E2 30
00:D8E3 30
00:D8E4 78
00:D8E5 00
00:D8E6 00              	   167:   dfb $00,$1C,$00,$78,$CC,$CC,$78,$00 ; $A2
00:D8E7 1C
00:D8E8 00
00:D8E9 78
00:D8EA CC
00:D8EB CC
00:D8EC 78
00:D8ED 00
00:D8EE 00              	   168:   dfb $00,$1C,$00,$CC,$CC,$CC,$7E,$00 ; $A3
00:D8EF 1C
00:D8F0 00
00:D8F1 CC
00:D8F2 CC
00:D8F3 CC
00:D8F4 7E
00:D8F5 00
00:D8F6 00              	   169:   dfb $00,$F8,$00,$F8,$CC,$CC,$CC,$00 ; $A4
00:D8F7 F8
00:D8F8 00
00:D8F9 F8
00:D8FA CC
00:D8FB CC
00:D8FC CC
00:D8FD 00
00:D8FE FC              	   170:   dfb $FC,$00,$CC,$EC,$FC,$DC,$CC,$00 ; $A5
00:D8FF 00
00:D900 CC
00:D901 EC
00:D902 FC
00:D903 DC
00:D904 CC
00:D905 00
00:D906 3C              	   171:   dfb $3C,$6C,$6C,$3E,$00,$7E,$00,$00 ; $A6
00:D907 6C
00:D908 6C
00:D909 3E
00:D90A 00
00:D90B 7E
00:D90C 00
00:D90D 00
00:D90E 38              	   172:   dfb $38,$6C,$6C,$38,$00,$7C,$00,$00 ; $A7
00:D90F 6C
00:D910 6C
00:D911 38
00:D912 00
00:D913 7C
00:D914 00
00:D915 00
00:D916 30              	   173:   dfb $30,$00,$30,$60,$C0,$CC,$78,$00 ; $A8
00:D917 00
00:D918 30
00:D919 60
00:D91A C0
00:D91B CC
00:D91C 78
00:D91D 00
00:D91E 00              	   174:   dfb $00,$00,$00,$FC,$C0,$C0,$00,$00 ; $A9
00:D91F 00
00:D920 00
00:D921 FC
00:D922 C0
00:D923 C0
00:D924 00
00:D925 00
00:D926 00              	   175:   dfb $00,$00,$00,$FC,$0C,$0C,$00,$00 ; $AA
00:D927 00
00:D928 00
00:D929 FC
00:D92A 0C
00:D92B 0C
00:D92C 00
00:D92D 00
00:D92E C3              	   176:   dfb $C3,$C6,$CC,$DE,$33,$66,$CC,$0F ; $AB
00:D92F C6
00:D930 CC
00:D931 DE
00:D932 33
00:D933 66
00:D934 CC
00:D935 0F
00:D936 C3              	   177:   dfb $C3,$C6,$CC,$DB,$37,$6F,$CF,$03 ; $AC
00:D937 C6
00:D938 CC
00:D939 DB
00:D93A 37
00:D93B 6F
00:D93C CF
00:D93D 03
00:D93E 18              	   178:   dfb $18,$18,$00,$18,$18,$18,$18,$00 ; $AD
00:D93F 18
00:D940 00
00:D941 18
00:D942 18
00:D943 18
00:D944 18
00:D945 00
00:D946 00              	   179:   dfb $00,$33,$66,$CC,$66,$33,$00,$00 ; $AE
00:D947 33
00:D948 66
00:D949 CC
00:D94A 66
00:D94B 33
00:D94C 00
00:D94D 00
00:D94E 00              	   180:   dfb $00,$CC,$66,$33,$66,$CC,$00,$00 ; $AF
00:D94F CC
00:D950 66
00:D951 33
00:D952 66
00:D953 CC
00:D954 00
00:D955 00
00:D956 22              	   181:   dfb $22,$88,$22,$88,$22,$88,$22,$88 ; $B0
00:D957 88
00:D958 22
00:D959 88
00:D95A 22
00:D95B 88
00:D95C 22
00:D95D 88
00:D95E 55              	   182:   dfb $55,$AA,$55,$AA,$55,$AA,$55,$AA ; $B1
00:D95F AA
00:D960 55
00:D961 AA
00:D962 55
00:D963 AA
00:D964 55
00:D965 AA
00:D966 DB              	   183:   dfb $DB,$77,$DB,$EE,$DB,$77,$DB,$EE ; $B2
00:D967 77
00:D968 DB
00:D969 EE
00:D96A DB
00:D96B 77
00:D96C DB
00:D96D EE
00:D96E 18              	   184:   dfb $18,$18,$18,$18,$18,$18,$18,$18 ; $B3
00:D96F 18
00:D970 18
00:D971 18
00:D972 18
00:D973 18
00:D974 18
00:D975 18
00:D976 18              	   185:   dfb $18,$18,$18,$18,$F8,$18,$18,$18 ; $B4
00:D977 18
00:D978 18
00:D979 18
00:D97A F8
00:D97B 18
00:D97C 18
00:D97D 18
00:D97E 18              	   186:   dfb $18,$18,$F8,$18,$F8,$18,$18,$18 ; $B5
00:D97F 18
00:D980 F8
00:D981 18
00:D982 F8
00:D983 18
00:D984 18
00:D985 18
00:D986 36              	   187:   dfb $36,$36,$36,$36,$F6,$36,$36,$36 ; $B6
00:D987 36
00:D988 36
00:D989 36
00:D98A F6
00:D98B 36
00:D98C 36
00:D98D 36
00:D98E 00              	   188:   dfb $00,$00,$00,$00,$FE,$36,$36,$36 ; $B7
00:D98F 00
00:D990 00
00:D991 00
00:D992 FE
00:D993 36
00:D994 36
00:D995 36
00:D996 00              	   189:   dfb $00,$00,$F8,$18,$F8,$18,$18,$18 ; $B8
00:D997 00
00:D998 F8
00:D999 18
00:D99A F8
00:D99B 18
00:D99C 18
00:D99D 18
00:D99E 36              	   190:   dfb $36,$36,$F6,$06,$F6,$36,$36,$36 ; $B9
00:D99F 36
00:D9A0 F6
00:D9A1 06
00:D9A2 F6
00:D9A3 36
00:D9A4 36
00:D9A5 36
00:D9A6 36              	   191:   dfb $36,$36,$36,$36,$36,$36,$36,$36 ; $BA
00:D9A7 36
00:D9A8 36
00:D9A9 36
00:D9AA 36
00:D9AB 36
00:D9AC 36
00:D9AD 36
00:D9AE 00              	   192:   dfb $00,$00,$FE,$06,$F6,$36,$36,$36 ; $BB
00:D9AF 00
00:D9B0 FE
00:D9B1 06
00:D9B2 F6
00:D9B3 36
00:D9B4 36
00:D9B5 36
00:D9B6 36              	   193:   dfb $36,$36,$F6,$06,$FE,$00,$00,$00 ; $BC
00:D9B7 36
00:D9B8 F6
00:D9B9 06
00:D9BA FE
00:D9BB 00
00:D9BC 00
00:D9BD 00
00:D9BE 36              	   194:   dfb $36,$36,$36,$36,$FE,$00,$00,$00 ; $BD
00:D9BF 36
00:D9C0 36
00:D9C1 36
00:D9C2 FE
00:D9C3 00
00:D9C4 00
00:D9C5 00
00:D9C6 18              	   195:   dfb $18,$18,$F8,$18,$F8,$00,$00,$00 ; $BE
00:D9C7 18
00:D9C8 F8
00:D9C9 18
00:D9CA F8
00:D9CB 00
00:D9CC 00
00:D9CD 00
00:D9CE 00              	   196:   dfb $00,$00,$00,$00,$F8,$18,$18,$18 ; $BF
00:D9CF 00
00:D9D0 00
00:D9D1 00
00:D9D2 F8
00:D9D3 18
00:D9D4 18
00:D9D5 18
00:D9D6 18              	   197:   dfb $18,$18,$18,$18,$1F,$00,$00,$00 ; $C0
00:D9D7 18
00:D9D8 18
00:D9D9 18
00:D9DA 1F
00:D9DB 00
00:D9DC 00
00:D9DD 00
00:D9DE 18              	   198:   dfb $18,$18,$18,$18,$FF,$00,$00,$00 ; $C1
00:D9DF 18
00:D9E0 18
00:D9E1 18
00:D9E2 FF
00:D9E3 00
00:D9E4 00
00:D9E5 00
00:D9E6 00              	   199:   dfb $00,$00,$00,$00,$FF,$18,$18,$18 ; $C2
00:D9E7 00
00:D9E8 00
00:D9E9 00
00:D9EA FF
00:D9EB 18
00:D9EC 18
00:D9ED 18
00:D9EE 18              	   200:   dfb $18,$18,$18,$18,$1F,$18,$18,$18 ; $C3
00:D9EF 18
00:D9F0 18
00:D9F1 18
00:D9F2 1F
00:D9F3 18
00:D9F4 18
00:D9F5 18
00:D9F6 00              	   201:   dfb $00,$00,$00,$00,$FF,$00,$00,$00 ; $C4
00:D9F7 00
00:D9F8 00
00:D9F9 00
00:D9FA FF
00:D9FB 00
00:D9FC 00
00:D9FD 00
00:D9FE 18              	   202:   dfb $18,$18,$18,$18,$FF,$18,$18,$18 ; $C5
00:D9FF 18
00:DA00 18
00:DA01 18
00:DA02 FF
00:DA03 18
00:DA04 18
00:DA05 18
00:DA06 18              	   203:   dfb $18,$18,$1F,$18,$1F,$18,$18,$18 ; $C6
00:DA07 18
00:DA08 1F
00:DA09 18
00:DA0A 1F
00:DA0B 18
00:DA0C 18
00:DA0D 18
00:DA0E 36              	   204:   dfb $36,$36,$36,$36,$37,$36,$36,$36 ; $C7
00:DA0F 36
00:DA10 36
00:DA11 36
00:DA12 37
00:DA13 36
00:DA14 36
00:DA15 36
00:DA16 36              	   205:   dfb $36,$36,$37,$30,$3F,$00,$00,$00 ; $C8
00:DA17 36
00:DA18 37
00:DA19 30
00:DA1A 3F
00:DA1B 00
00:DA1C 00
00:DA1D 00
00:DA1E 00              	   206:   dfb $00,$00,$3F,$30,$37,$36,$36,$36 ; $C9
00:DA1F 00
00:DA20 3F
00:DA21 30
00:DA22 37
00:DA23 36
00:DA24 36
00:DA25 36
00:DA26 36              	   207:   dfb $36,$36,$F7,$00,$FF,$00,$00,$00 ; $CA
00:DA27 36
00:DA28 F7
00:DA29 00
00:DA2A FF
00:DA2B 00
00:DA2C 00
00:DA2D 00
00:DA2E 00              	   208:   dfb $00,$00,$FF,$00,$F7,$36,$36,$36 ; $CB
00:DA2F 00
00:DA30 FF
00:DA31 00
00:DA32 F7
00:DA33 36
00:DA34 36
00:DA35 36
00:DA36 36              	   209:   dfb $36,$36,$37,$30,$37,$36,$36,$36 ; $CC
00:DA37 36
00:DA38 37
00:DA39 30
00:DA3A 37
00:DA3B 36
00:DA3C 36
00:DA3D 36
00:DA3E 00              	   210:   dfb $00,$00,$FF,$00,$FF,$00,$00,$00 ; $CD
00:DA3F 00
00:DA40 FF
00:DA41 00
00:DA42 FF
00:DA43 00
00:DA44 00
00:DA45 00
00:DA46 36              	   211:   dfb $36,$36,$F7,$00,$F7,$36,$36,$36 ; $CE
00:DA47 36
00:DA48 F7
00:DA49 00
00:DA4A F7
00:DA4B 36
00:DA4C 36
00:DA4D 36
00:DA4E 18              	   212:   dfb $18,$18,$FF,$00,$FF,$00,$00,$00 ; $CF
00:DA4F 18
00:DA50 FF
00:DA51 00
00:DA52 FF
00:DA53 00
00:DA54 00
00:DA55 00
00:DA56 36              	   213:   dfb $36,$36,$36,$36,$FF,$00,$00,$00 ; $D0
00:DA57 36
00:DA58 36
00:DA59 36
00:DA5A FF
00:DA5B 00
00:DA5C 00
00:DA5D 00
00:DA5E 00              	   214:   dfb $00,$00,$FF,$00,$FF,$18,$18,$18 ; $D1
00:DA5F 00
00:DA60 FF
00:DA61 00
00:DA62 FF
00:DA63 18
00:DA64 18
00:DA65 18
00:DA66 00              	   215:   dfb $00,$00,$00,$00,$FF,$36,$36,$36 ; $D2
00:DA67 00
00:DA68 00
00:DA69 00
00:DA6A FF
00:DA6B 36
00:DA6C 36
00:DA6D 36
00:DA6E 36              	   216:   dfb $36,$36,$36,$36,$3F,$00,$00,$00 ; $D3
00:DA6F 36
00:DA70 36
00:DA71 36
00:DA72 3F
00:DA73 00
00:DA74 00
00:DA75 00
00:DA76 18              	   217:   dfb $18,$18,$1F,$18,$1F,$00,$00,$00 ; $D4
00:DA77 18
00:DA78 1F
00:DA79 18
00:DA7A 1F
00:DA7B 00
00:DA7C 00
00:DA7D 00
00:DA7E 00              	   218:   dfb $00,$00,$1F,$18,$1F,$18,$18,$18 ; $D5
00:DA7F 00
00:DA80 1F
00:DA81 18
00:DA82 1F
00:DA83 18
00:DA84 18
00:DA85 18
00:DA86 00              	   219:   dfb $00,$00,$00,$00,$3F,$36,$36,$36 ; $D6
00:DA87 00
00:DA88 00
00:DA89 00
00:DA8A 3F
00:DA8B 36
00:DA8C 36
00:DA8D 36
00:DA8E 36              	   220:   dfb $36,$36,$36,$36,$FF,$36,$36,$36 ; $D7
00:DA8F 36
00:DA90 36
00:DA91 36
00:DA92 FF
00:DA93 36
00:DA94 36
00:DA95 36
00:DA96 18              	   221:   dfb $18,$18,$FF,$18,$FF,$18,$18,$18 ; $D8
00:DA97 18
00:DA98 FF
00:DA99 18
00:DA9A FF
00:DA9B 18
00:DA9C 18
00:DA9D 18
00:DA9E 18              	   222:   dfb $18,$18,$18,$18,$F8,$00,$00,$00 ; $D9
00:DA9F 18
00:DAA0 18
00:DAA1 18
00:DAA2 F8
00:DAA3 00
00:DAA4 00
00:DAA5 00
00:DAA6 00              	   223:   dfb $00,$00,$00,$00,$1F,$18,$18,$18 ; $DA
00:DAA7 00
00:DAA8 00
00:DAA9 00
00:DAAA 1F
00:DAAB 18
00:DAAC 18
00:DAAD 18
00:DAAE FF              	   224:   dfb $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF ; $DB
00:DAAF FF
00:DAB0 FF
00:DAB1 FF
00:DAB2 FF
00:DAB3 FF
00:DAB4 FF
00:DAB5 FF
00:DAB6 00              	   225:   dfb $00,$00,$00,$00,$FF,$FF,$FF,$FF ; $DC
00:DAB7 00
00:DAB8 00
00:DAB9 00
00:DABA FF
00:DABB FF
00:DABC FF
00:DABD FF
00:DABE F0              	   226:   dfb $F0,$F0,$F0,$F0,$F0,$F0,$F0,$F0 ; $DD
00:DABF F0
00:DAC0 F0
00:DAC1 F0
00:DAC2 F0
00:DAC3 F0
00:DAC4 F0
00:DAC5 F0
00:DAC6 0F              	   227:   dfb $0F,$0F,$0F,$0F,$0F,$0F,$0F,$0F ; $DE
00:DAC7 0F
00:DAC8 0F
00:DAC9 0F
00:DACA 0F
00:DACB 0F
00:DACC 0F
00:DACD 0F
00:DACE FF              	   228:   dfb $FF,$FF,$FF,$FF,$00,$00,$00,$00 ; $DF
00:DACF FF
00:DAD0 FF
00:DAD1 FF
00:DAD2 00
00:DAD3 00
00:DAD4 00
00:DAD5 00
00:DAD6 00              	   229:   dfb $00,$00,$76,$DC,$C8,$DC,$76,$00 ; $E0
00:DAD7 00
00:DAD8 76
00:DAD9 DC
00:DADA C8
00:DADB DC
00:DADC 76
00:DADD 00
00:DADE 00              	   230:   dfb $00,$78,$CC,$F8,$CC,$F8,$C0,$C0 ; $E1
00:DADF 78
00:DAE0 CC
00:DAE1 F8
00:DAE2 CC
00:DAE3 F8
00:DAE4 C0
00:DAE5 C0
00:DAE6 00              	   231:   dfb $00,$FC,$CC,$C0,$C0,$C0,$C0,$00 ; $E2
00:DAE7 FC
00:DAE8 CC
00:DAE9 C0
00:DAEA C0
00:DAEB C0
00:DAEC C0
00:DAED 00
00:DAEE 00              	   232:   dfb $00,$FE,$6C,$6C,$6C,$6C,$6C,$00 ; $E3
00:DAEF FE
00:DAF0 6C
00:DAF1 6C
00:DAF2 6C
00:DAF3 6C
00:DAF4 6C
00:DAF5 00
00:DAF6 FC              	   233:   dfb $FC,$CC,$60,$30,$60,$CC,$FC,$00 ; $E4
00:DAF7 CC
00:DAF8 60
00:DAF9 30
00:DAFA 60
00:DAFB CC
00:DAFC FC
00:DAFD 00
00:DAFE 00              	   234:   dfb $00,$00,$7E,$D8,$D8,$D8,$70,$00 ; $E5
00:DAFF 00
00:DB00 7E
00:DB01 D8
00:DB02 D8
00:DB03 D8
00:DB04 70
00:DB05 00
00:DB06 00              	   235:   dfb $00,$66,$66,$66,$66,$7C,$60,$C0 ; $E6
00:DB07 66
00:DB08 66
00:DB09 66
00:DB0A 66
00:DB0B 7C
00:DB0C 60
00:DB0D C0
00:DB0E 00              	   236:   dfb $00,$76,$DC,$18,$18,$18,$18,$00 ; $E7
00:DB0F 76
00:DB10 DC
00:DB11 18
00:DB12 18
00:DB13 18
00:DB14 18
00:DB15 00
00:DB16 FC              	   237:   dfb $FC,$30,$78,$CC,$CC,$78,$30,$FC ; $E8
00:DB17 30
00:DB18 78
00:DB19 CC
00:DB1A CC
00:DB1B 78
00:DB1C 30
00:DB1D FC
00:DB1E 38              	   238:   dfb $38,$6C,$C6,$FE,$C6,$6C,$38,$00 ; $E9
00:DB1F 6C
00:DB20 C6
00:DB21 FE
00:DB22 C6
00:DB23 6C
00:DB24 38
00:DB25 00
00:DB26 38              	   239:   dfb $38,$6C,$C6,$C6,$6C,$6C,$EE,$00 ; $EA
00:DB27 6C
00:DB28 C6
00:DB29 C6
00:DB2A 6C
00:DB2B 6C
00:DB2C EE
00:DB2D 00
00:DB2E 1C              	   240:   dfb $1C,$30,$18,$7C,$CC,$CC,$78,$00 ; $EB
00:DB2F 30
00:DB30 18
00:DB31 7C
00:DB32 CC
00:DB33 CC
00:DB34 78
00:DB35 00
00:DB36 00              	   241:   dfb $00,$00,$7E,$DB,$DB,$7E,$00,$00 ; $EC
00:DB37 00
00:DB38 7E
00:DB39 DB
00:DB3A DB
00:DB3B 7E
00:DB3C 00
00:DB3D 00
00:DB3E 06              	   242:   dfb $06,$0C,$7E,$DB,$DB,$7E,$60,$C0 ; $ED
00:DB3F 0C
00:DB40 7E
00:DB41 DB
00:DB42 DB
00:DB43 7E
00:DB44 60
00:DB45 C0
00:DB46 38              	   243:   dfb $38,$60,$C0,$F8,$C0,$60,$38,$00 ; $EE
00:DB47 60
00:DB48 C0
00:DB49 F8
00:DB4A C0
00:DB4B 60
00:DB4C 38
00:DB4D 00
00:DB4E 78              	   244:   dfb $78,$CC,$CC,$CC,$CC,$CC,$CC,$00 ; $EF
00:DB4F CC
00:DB50 CC
00:DB51 CC
00:DB52 CC
00:DB53 CC
00:DB54 CC
00:DB55 00
00:DB56 00              	   245:   dfb $00,$FC,$00,$FC,$00,$FC,$00,$00 ; $F0
00:DB57 FC
00:DB58 00
00:DB59 FC
00:DB5A 00
00:DB5B FC
00:DB5C 00
00:DB5D 00
00:DB5E 30              	   246:   dfb $30,$30,$FC,$30,$30,$00,$FC,$00 ; $F1
00:DB5F 30
00:DB60 FC
00:DB61 30
00:DB62 30
00:DB63 00
00:DB64 FC
00:DB65 00
00:DB66 60              	   247:   dfb $60,$30,$18,$30,$60,$00,$FC,$00 ; $F2
00:DB67 30
00:DB68 18
00:DB69 30
00:DB6A 60
00:DB6B 00
00:DB6C FC
00:DB6D 00
00:DB6E 18              	   248:   dfb $18,$30,$60,$30,$18,$00,$FC,$00 ; $F3
00:DB6F 30
00:DB70 60
00:DB71 30
00:DB72 18
00:DB73 00
00:DB74 FC
00:DB75 00
00:DB76 0E              	   249:   dfb $0E,$1B,$1B,$18,$18,$18,$18,$18 ; $F4
00:DB77 1B
00:DB78 1B
00:DB79 18
00:DB7A 18
00:DB7B 18
00:DB7C 18
00:DB7D 18
00:DB7E 18              	   250:   dfb $18,$18,$18,$18,$18,$D8,$D8,$70 ; $F5
00:DB7F 18
00:DB80 18
00:DB81 18
00:DB82 18
00:DB83 D8
00:DB84 D8
00:DB85 70
00:DB86 30              	   251:   dfb $30,$30,$00,$FC,$00,$30,$30,$00 ; $F6
00:DB87 30
00:DB88 00
00:DB89 FC
00:DB8A 00
00:DB8B 30
00:DB8C 30
00:DB8D 00
00:DB8E 00              	   252:   dfb $00,$76,$DC,$00,$76,$DC,$00,$00 ; $F7
00:DB8F 76
00:DB90 DC
00:DB91 00
00:DB92 76
00:DB93 DC
00:DB94 00
00:DB95 00
00:DB96 38              	   253:   dfb $38,$6C,$6C,$38,$00,$00,$00,$00 ; $F8
00:DB97 6C
00:DB98 6C
00:DB99 38
00:DB9A 00
00:DB9B 00
00:DB9C 00
00:DB9D 00
00:DB9E 00              	   254:   dfb $00,$00,$00,$18,$18,$00,$00,$00 ; $F9
00:DB9F 00
00:DBA0 00
00:DBA1 18
00:DBA2 18
00:DBA3 00
00:DBA4 00
00:DBA5 00
00:DBA6 00              	   255:   dfb $00,$00,$00,$00,$18,$00,$00,$00 ; $FA
00:DBA7 00
00:DBA8 00
00:DBA9 00
00:DBAA 18
00:DBAB 00
00:DBAC 00
00:DBAD 00
00:DBAE 0F              	   256:   dfb $0F,$0C,$0C,$0C,$EC,$6C,$3C,$1C ; $FB
00:DBAF 0C
00:DBB0 0C
00:DBB1 0C
00:DBB2 EC
00:DBB3 6C
00:DBB4 3C
00:DBB5 1C
00:DBB6 78              	   257:   dfb $78,$6C,$6C,$6C,$6C,$00,$00,$00 ; $FC
00:DBB7 6C
00:DBB8 6C
00:DBB9 6C
00:DBBA 6C
00:DBBB 00
00:DBBC 00
00:DBBD 00
00:DBBE 70              	   258:   dfb $70,$18,$30,$60,$78,$00,$00,$00 ; $FD
00:DBBF 18
00:DBC0 30
00:DBC1 60
00:DBC2 78
00:DBC3 00
00:DBC4 00
00:DBC5 00
00:DBC6 00              	   259:   dfb $00,$00,$3C,$3C,$3C,$3C,$00,$00 ; $FE
00:DBC7 00
00:DBC8 3C
00:DBC9 3C
00:DBCA 3C
00:DBCB 3C
00:DBCC 00
00:DBCD 00
00:DBCE 00              	   260:   dfb $00,$00,$00,$00,$00,$00,$00,$00 ; $FF
00:DBCF 00
00:DBD0 00
00:DBD1 00
00:DBD2 00
00:DBD3 00
00:DBD4 00
00:DBD5 00
                        	   261: 

Source: "gpascal.asm"
                        	   206:   .endif
                        	   207: 
00:DBD6 472D50617363616C	   208: introduction asc    "G-Pascal compiler, version 4.05.\n"
00:DBDE 20636F6D70696C65
00:DBE6 722C207665727369
00:DBEE 6F6E20342E30352E
00:DBF6 0A
00:DBF7 5772697474656E20	   209:              asciiz "Written by Nick Gammon.\nType H for help.\n"
00:DBFF 6279204E69636B20
00:DC07 47616D6D6F6E2E0A
00:DC0F 5479706520482066
00:DC17 6F722068656C702E
00:DC1F 0A
00:DC20 00
                        	   210: 
                        	   211:   .if LCD_SUPPORT
00:DC21 4E69636B27732047	   212: LCD_welcome asciiz "Nick's G-Pascal\nCompiler v4.05"
00:DC29 2D50617363616C0A
00:DC31 436F6D70696C6572
00:DC39 2076342E3035
00:DC3F 00
                        	   213:   .endif
                        	   214: 
00:DC40 52756E6E696E670A	   215: running_message   asciiz  'Running\n'
00:DC48 00
                        	   216: 
                        	   217: ;
                        	   218: ; here for cold start - clear text file to null etc. etc.
                        	   219: ;
                        	   220: START    =  *
00:DC49 D8              	   221:   cld             ; cancel decimal mode
00:DC4A 78              	   222:   sei             ; no interrupts yet
00:DC4B A9FF            	   223:   lda #$FF
00:DC4D 8509            	   224:   sta random      ; initialise random numbers
00:DC4F 850A            	   225:   sta random+1
00:DC51 850B            	   226:   sta random+2
00:DC53 850C            	   227:   sta random+3
                        	   228: ;
                        	   229: ;  Put 0x00 at start of source
                        	   230: ;
00:DC55 A900            	   231:   lda  #<TEXT_START
00:DC57 8500            	   232:   sta  REG
00:DC59 A903            	   233:   lda  #>TEXT_START
00:DC5B 8501            	   234:   sta  REG+1
00:DC5D A900            	   235:   lda  #0
00:DC5F A8              	   236:   tay
00:DC60 9100            	   237:   sta  (REG),Y     ; null edit file
00:DC62 84BE            	   238:   sty  system_flags
00:DC64 AA              	   239:   tax
                        	   240: ;
                        	   241: ;  now do rest of initialization
                        	   242: ;
                        	   243: RESTART  =  *
00:DC65 A2FF            	   244:   ldx  #NEW_STK
00:DC67 9A              	   245:   txs             ; reset stack
00:DC68 58              	   246:   cli             ; allow interrupts after a NMI
00:DC69 D8              	   247:   cld             ; cancel decimal mode
00:DC6A 2036CB          	   248:   jsr hardware_init
                        	   249: 
                        	   250: ;
                        	   251: REST1    =  *
                        	   252:   .if LCD_SUPPORT
                        	   253:     ;
                        	   254:     ;  put message on the LCD screen to prove it is working
                        	   255:     ;
00:DC6D A921            	   256:     lda  #<LCD_welcome  ; G-pascal compiler
00:DC6F A2DC            	   257:     ldx  #>LCD_welcome
00:DC71 20F8C8          	   258:     jsr lcd_print_message
                        	   259:   .endif
                        	   260: 
                        	   261: ;
                        	   262: ;  now direct output to the serial port
                        	   263: ;
00:DC74 2009CB          	   264:   jsr  write_to_serial   ; set up outputting function
00:DC77 A900            	   265:   lda  #0
00:DC79 853F            	   266:   sta  RUNNING
00:DC7B 4C6B82          	   267:   jmp  main_start    ; go to "shell"
                        	   268: 
00:DC7E 00              	   269: end_of_rom_routines dfb 0
                        	   270: 
                        	   271: ;
                        	   272: ;  processor hardware vectors
                        	   273: ;
                        	   274:   .org $FFFA
01:FFFA 65DC            	   275:   .word RESTART   ; non-maskable interrupt (NMI)
01:FFFC 49DC            	   276:   .word START     ; reset vector
01:FFFE 17C7            	   277:   .word irq       ; maskable interrupt (IRQ)
                        	   278: 


Symbols by name:
ACT_PCDA                         S:0025
ADD1                             E:C9E4
ADD4                             E:CA07
ADD9                             E:CA23
ADDSYM                           E:C988
ADDSYM_NOT_FULL                  A:C9BD
ASS1                             A:B39A
ASS2                             A:B3E2
ASSARR                           A:B3C1
ASSEMBLE                         A:9ABE
ASSEMBLE_PASS                    A:9AD0
ASSEMBLE_SECOND_PASS             A:9ACB
ASSIGN                           A:B397
ASSTB1                           A:B3A6
ASSVAR                           A:B3D3
ASS_COUNT                        S:0072
ASS_EMIT_COUNT                   S:006F
ASS_OPCODE_WORK                  S:0070
ASS_OPERAND                      S:006B
ASS_OPERAND_ABSOLUTE             E:0001
ASS_OPERAND_ABSOLUTE_INDEXED_IN  E:0002
ASS_OPERAND_ABSOLUTE_INDEXED_WI  E:0003
ASS_OPERAND_ABSOLUTE_INDEXED_WI  E:0004
ASS_OPERAND_ABSOLUTE_INDIRECT    E:0005
ASS_OPERAND_ACCUMULATOR_A        E:0006
ASS_OPERAND_IMMEDIATE            E:0007
ASS_OPERAND_IMPLIED              E:0008
ASS_OPERAND_STRING               E:0011
ASS_OPERAND_ZERO_PAGE            E:000B
ASS_OPERAND_ZERO_PAGE_AND_ABSOL  E:0012
ASS_OPERAND_ZERO_PAGE_INDEXED_I  E:000C
ASS_OPERAND_ZERO_PAGE_INDEXED_W  E:000D
ASS_OPERAND_ZERO_PAGE_INDEXED_W  E:000E
ASS_OPERAND_ZERO_PAGE_INDIRECT   E:000F
ASS_OPERAND_ZERO_PAGE_INDIRECT_  E:0010
ASS_PASS                         S:0076
ASS_VALUE                        S:0073
BACKSPACE                        E:0008
BAD_INP                          A:C308
BASE                             S:003B
BAUD_RATE                        E:12C0
BEG                              A:B647
BELL1                            E:95DA
BIT_INTERVAL                     E:00D0
BLCKT1                           A:B868
BLCKT2                           A:B86B
BLCKT3                           A:B86E
BLK1                             A:B8A3
BLK1A                            A:B88F
BLK2                             A:B8AB
BLK4                             A:B8B5
BLKB1                            A:BB0B
BLKB2                            A:BB27
BLKB3                            A:BB05
BLKB4                            A:BB43
BLKB5                            A:BB34
BLKB6                            A:BB52
BLKBEG                           A:BAFB
BLKCN1                           A:B8C2
BLKCNS                           A:B8BF
BLKFNC                           A:BA33
BLKPR1                           A:BA55
BLKPR2                           A:BA87
BLKPR3                           A:BA71
BLKPR4                           A:BACF
BLKPR5                           E:BAA8
BLKPR6                           A:BA7E
BLKPRC                           A:BA13
BLKV10                           E:B909
BLKV10_A                         E:B925
BLKV10_B                         E:B92C
BLKV11                           A:B993
BLKV12                           A:B99A
BLKV13                           A:B954
BLKVAR                           A:B8D6
BLKVR1                           A:B8DA
BLKVR2                           A:B93B
BLKVR3                           A:B9FB
BLKVR4                           A:B959
BLKVR5                           E:B9B9
BLKVR6                           A:B8DD
BLKVR7                           A:B8E7
BLKVR8                           A:B906
BLKVR9                           E:B9A0
BLOCK                            A:B878
BSAVE                            S:0036
CALL                             S:0047
CALLSB                           A:B573
CASE                             A:B6B3
CASE1                            A:B6EC
CASE2                            E:B6C5
CASE3                            A:B702
CASE4                            A:B6F8
CASE5                            A:B735
CASE6                            A:B753
CASE7                            A:B6C1
CASE8                            A:B768
CASE9                            A:B75E
CHKDUP                           A:CA2F
CHKGET                           E:B841
CHKLHB                           E:B02B
CHKLHP                           E:B011
CHKNOK                           E:D1AC
CHKOK                            E:D1AF
CHKRHB                           E:B035
CHKRHP                           E:B018
CHKTKN                           A:D1B1
CHK_KBD                          E:BF14
CHK_NOTD                         A:BF3C
CHK_NOTN                         A:BF20
CHK_NOTT                         A:BF2E
CHK_RUN                          A:9568
CHK_STAK                         E:B0FB
CHK_VAL                          E:9555
CHK_VAL9                         E:9567
CHRIN                            E:CB1F
CLOCK_RATE                       E:4240
COMPIL                           A:AFC0
COMS8                            A:9437
COMS9                            A:9436
COMSTL                           E:942A
CONDEC                           E:B03F
CONST                            E:B107
CONST1                           A:B11E
CONST2                           A:B128
CONST3                           E:B123
CONST9                           A:B12C
COUNT1                           S:004B
COUNT2                           S:004C
COUT                             A:95B3
COUT_CALL                        A:95BD
CR                               E:000D
CROUT                            E:9425
DATA                             S:003D
DATTYP                           S:004A
DB11                             A:BE47
DBGFLG                           S:0049
DCODE                            S:002E
DEBUG                            E:BE47
DEBUG_DONE                       A:BEAF
DEST                             E:0003
DIRECTIVES                       E:A233
DIS5                             A:BEFD
DIS5_A                           E:BF07
DISHX                            A:943A
DISP9                            A:BD0D
DISPAD                           E:9440
DISPAD2                          A:945B
DISPL                            S:0027
DIVBY0                           A:C0BE
DM1                              A:BE35
DM2                              A:BE3E
DM5                              A:BED6
DM6                              A:BEEB
DM7                              A:95C0
DUP9                             A:CA3E
EFLAG_ALLOW_ZERO_FROM            E:0002
EFLAG_FIND                       E:0010
EFLAG_LOAD                       E:0004
EFLAG_NO_LINE_NUMBERS            E:0080
EFLAG_REPLACE                    E:0020
EFLAG_SAVE                       E:0008
EFLAG_SHOW_LINE                  E:0001
EFLAG_SUPPRESS_NEWLINE           E:0040
EMULATOR                         E:0000
EMULATOR_DEBUG                   A:CB33
ENDSYM                           S:0031
END_CMP                          E:B00E
END_EDITOR_INPUT                 E:001B
END_PCD                          S:0043
END_WRK                          E:B85D
ERR1                             E:99F3
ERR3                             E:9A07
ERR5                             E:9A17
ERR6                             E:9A1D
ERR7                             E:99E9
ERRLIT                           A:99D4
ERRNO                            S:0035
ERROR                            A:99E0
EXPR1                            A:B323
EXPR2                            A:B345
EXPR3                            A:B34B
EXPR4                            A:B34F
EXPR5                            A:B353
EXPR6                            A:B357
EXPR7                            A:B35B
EXPR8                            A:B347
EXPRES                           A:B300
EXPTB1                           A:B310
EXPTB3                           A:B332
EX_ABS                           A:C0E2
EX_ABSCLL                        E:C377
EX_ADD                           A:C07E
EX_ADRAC                         E:C556
EX_ADRAN                         E:C550
EX_ADRN2                         E:C545
EX_ADRNC                         E:C532
EX_ADRNC2                        E:C535
EX_ADRNN                         E:C542
EX_AND                           A:C150
EX_ASSERT                        A:C5E9
EX_ASSERT_OK                     A:C5FE
EX_CLA                           A:C40D
EX_CLL                           E:C37E
EX_CLL2                          E:C3A8
EX_CLL3                          E:C3C9
EX_CLL4                          E:C3A4
EX_CLL5                          E:C40A
EX_CLL_A                         E:C386
EX_CLL_JMP                       A:C42A
EX_DEC                           A:C192
EX_DELAY                         E:C5A5
EX_DIGITALREAD                   E:C55C
EX_DIGITALREAD_ONE               A:C567
EX_DIGITALWRITE                  E:C5D4
EX_DIV                           A:C0CE
EX_DIVIDE_BY_ZERO                A:C0B7
EX_EOR                           A:C159
EX_EQL                           A:C0EB
EX_FINISHD                       E:95F8
EX_GEQ                           A:C126
EX_GETKEY                        E:C09C
EX_GTR                           A:C11A
EX_INC                           A:C17A
EX_INP                           E:C2D0
EX_INPC                          A:C498
EX_INPC_OK                       A:C4A2
EX_INP_OK                        A:C2E1
EX_INS                           E:C4D4
EX_INS1                          E:C4F7
EX_INS2                          E:C500
EX_INS3                          E:C4DE
EX_INS4                          E:C50A
EX_INT                           A:C42D
EX_INVINS                        E:BF91
EX_JM1                           A:C48D
EX_JMP                           A:C469
EX_JMZ                           A:C47C
EX_LATENCY                       A:C596
EX_LCDCLEAR                      A:C4CE
EX_LCDHOME                       A:C4C8
EX_LCDPOS                        E:C56A
EX_LCDPOS_1                      A:C57A
EX_LCD_WRITE_CHR                 A:C4B7
EX_LCD_WRITE_HEX                 A:C329
EX_LCD_WRITE_NUM                 A:C315
EX_LCD_WRITE_STR                 A:C349
EX_LDA                           A:C1EE
EX_LDAC                          A:C1E3
EX_LDI                           A:C229
EX_LDIC                          A:C223
EX_LEQ                           A:C132
EX_LIB_CALL                      A:C5E3
EX_LIT                           A:C063
EX_LOD                           A:C1CD
EX_LOD2                          A:C1D0
EX_LOD3                          A:C1BE
EX_LOD3_A                        A:C1C0
EX_LODC                          A:C1BB
EX_LSS                           A:C10E
EX_MOD                           A:C0A3
EX_MOV                           A:C1AA
EX_MUL                           A:C093
EX_NEG                           A:C075
EX_NEQ                           A:C105
EX_NEW_STACK                     A:C457
EX_NOJUMP                        A:C487
EX_ORR                           A:C147
EX_OUH                           A:C324
EX_OUH_COMMON                    A:C32C
EX_OUS                           E:C344
EX_OUS1                          A:C368
EX_OUS_COMMON                    A:C34C
EX_OUT                           A:C310
EX_OUTC                          A:C4B2
EX_OUTCR                         E:BF3E
EX_OUTC_COMMON                   A:C4BA
EX_PINMODE                       E:C5C5
EX_RANDOM                        A:C584
EX_RANDOMSEED                    E:C5B5
EX_RTN                           A:C297
EX_SHL                           A:C162
EX_SHR                           A:C16E
EX_STA                           A:C24F
EX_STA5                          A:C260
EX_STAC                          A:C265
EX_STI                           A:C27C
EX_STIC                          A:C26E
EX_STO                           A:C23C
EX_STO2                          A:C242
EX_STO5                          A:C237
EX_STOC                          A:C22F
EX_SUB                           A:C087
EX_XOR                           A:C13E
FACAD1                           A:B24E
FACAD2                           A:B26C
FACADR                           E:B296
FACERR1                          A:B2AF
FACM2                            A:B2CA
FACMEM                           A:B2C0
FACMMC                           A:B2C6
FACNOT                           A:B2D6
FACNUM                           E:B2B4
FACRND1                          A:B2E1
FACSTR                           A:B2A9
FACTB1                           A:B2E7
FACTOR                           A:B1FF
FACTQT1                          A:B2ED
FALSE                            A:C101
FFLAG_GLOBAL                     E:0002
FFLAG_IGNORE_CASE                E:0001
FFLAG_QUIET                      E:0004
FIN_MSG                          A:960F
FIXAD                            E:BD56
FIXAD1                           A:BD93
FIXM1                            A:BD94
FIXM2                            A:BD9D
FLAG_ASSEMBLING                  E:0002
FLAG_BRK_REACHED                 E:0080
FLAG_COMPILING                   E:0001
FLAG_LIST_SOURCE                 E:0004
FLAG_ONLY_ALPHA                  E:0040
FLAG_VALID_ASSEMBLE              E:0010
FLAG_VALID_COMPILE               E:0008
FNC1                             A:B5BD
FNC2                             A:B58D
FNC3                             A:B5B7
FNC4                             A:B601
FNC5                             A:B5C0
FNC5A                            A:B5DD
FNC5B                            A:B5DF
FNC6                             A:B602
FNCPRC                           A:B580
FOR                              A:B76E
FOR1                             A:B778
FOR2                             A:B785
FOR3                             A:B79E
FOR4                             A:B7CF
FOR5                             A:B812
FOR6                             A:B834
FRAME                            S:0020
FROM                             E:0040
GEN1                             E:BCB4
GEN2                             E:BCEB
GEN2_A                           E:BCF6
GEN2_B                           E:BCED
GEN2_C                           E:BD0D
GEN3                             E:BD51
GENADR                           E:BCB8
GENJMP                           E:BD28
GENNJM                           A:BD22
GENNJP                           E:BD20
GENNOP                           E:BC9F
GENNOP1                          A:B2DE
GENNOP2                          A:B54B
GENRJMP                          E:BD0E
GEN_FULL                         A:BD08
GET1                             A:958D
GET1_A                           E:BFE8
GET2                             E:BFAC
GET3                             A:95AA
GETADR                           A:BFA2
GETADR1                          E:BFCD
GETCHK                           A:D1A1
GETEXPR                          E:B093
GETID2                           A:C215
GETIDC                           A:C1F8
GETIDX                           E:C201
GETIN                            E:CB1F
GETIN1                           A:CB29
GETLIT                           E:C04C
GETLN1                           E:958B
GETLN_OVERFLOW                   A:95B0
GETO_1                           E:CA5B
GETO_2                           E:CA68
GETSUB                           E:B022
GET_COMM                         E:B0C5
GET_DAT                          E:CA74
GET_END                          A:C062
GET_ITEM                         E:B0CC
GET_LEV                          E:CA6A
GET_LINE                         E:958B
GET_LOOK                         A:D1B6
GET_OFF                          E:CA3F
HIGHEST_RAM                      E:3FFF
I2C_DDR                          E:7FF3
I2C_PORT                         E:7FF1
I2C_SCL                          E:0004
I2C_SDA                          E:0008
IDENT                            A:B210
IDENT1                           A:B213
IDENT1A                          A:B21B
IDENT2                           A:B220
IDENT2A                          A:B239
IDENT3                           A:B240
IDENT4                           A:B274
IDENT4_A                         A:B276
IDENT5                           A:B256
IDENT5_A                         A:B258
IDENT6                           A:B263
IDENT7                           A:B269
IF                               A:B607
IF1                              A:B62C
IF2                              A:B625
INBUF                            S:0200
INBUF_SIZE                       E:0100
INIT                             E:93D7
INIT9                            A:9424
INIT_SECOND_PASS                 A:93E3
INP3                             A:C2F8
INTERP                           E:BEB0
INT_ERR                          E:C444
INT_ERRM                         A:C44B
JMP1                             E:9197
JMP2                             E:919F
JMP3                             E:91B4
KEY_ABORT                        E:0003
KEY_DEBUG                        E:0004
KEY_STOP_TRACE                   E:000E
KEY_TRACE                        E:0014
LASTP                            S:004D
LCD_E                            E:0080
LCD_RS                           E:0020
LCD_RW                           E:0040
LCD_SUPPORT                      E:0001
LCD_welcome                      A:DC21
LEVEL                            S:0022
LINE_CNT                         S:0019
LIST                             S:001D
LIT1                             A:C072
LOOK1                            A:CA2E
LOOKUP                           E:CA24
LOWLIT                           A:BF44
LOWLIT1                          A:BF4A
MAIN                             A:BF53
MAINP                            A:BF50
MAIN_1                           E:BF82
MAIN_2                           E:BF5A
MAIN_NOT_ABORT                   E:BF65
MAIN_OK                          E:BF68
MAKE_LOWER                       E:91CC
MAKE_LOWER_DONE                  E:91D6
MAKE_UPPER                       E:91C1
MAKE_UPPER_DONE                  E:91CB
MAX_STK                          E:0020
MEM                              A:B558
MEM2                             A:B560
MEMC                             A:B55D
NEW_STK                          E:00FF
NL                               E:000A
NOSCE                            A:93C6
NOTIM1                           E:BF95
OFFSET                           S:0029
ONE_OP                           A:B544
ONE_OP2                          A:B541
OPCODE                           S:006C
OPCODE_3_CHAR_BRANCH             E:A2F7
OPCODE_3_CHAR_IMPLIED            E:A31C
OPCODE_4_CHAR_BRANCH             E:A2A6
OPCODE_4_CHAR_ZERO_PAGE          E:A399
OPCODE_ASS_OPERAND_ABSOLUTE      E:A3EA
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A456
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A45B
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A4A0
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A4A3
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A4C8
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A4E4
OPCODE_ASS_OPERAND_ABSOLUTE_TOK  E:A453
OPCODE_ASS_OPERAND_ACCUMULATOR_  E:A4CB
OPCODE_ASS_OPERAND_IMMEDIATE     E:A4E9
OPCODE_ASS_OPERAND_IMMEDIATE_TO  E:A51A
OPCODE_ASS_OPERAND_ZERO_PAGE     E:A51D
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A581
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A5A2
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A5A5
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A5EE
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A5F1
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A5FA
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A61E
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A63F
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A61B
OPCODE_ASS_OPERAND_ZERO_PAGE_TO  E:A57E
OPCODE_LEN                       S:006E
OPCODE_LOOKUP_HANDLER            E:0004
OPCODE_LOOKUP_OPCODE_LENGTH      E:0000
OPCODE_LOOKUP_OPCODE_TABLE       E:0002
OPCODE_LOOKUP_OPERAND_TYPE       E:0001
OPCODE_LOOKUP_TABLE              E:A190
OPCODE_LOOKUP_TABLE_SIZE         E:0006
OPND                             S:002B
OUT_COMMON                       A:C318
PAREN                            A:B2BA
PCD_WRKD                         E:B099
PCODE                            S:0023
PCODE_ABSCLL                     E:0038
PCODE_ADD                        E:0004
PCODE_ADRAN                      E:000E
PCODE_ADRNN                      E:000C
PCODE_AND                        E:001B
PCODE_CLA                        E:002B
PCODE_CLL                        E:0027
PCODE_DEC                        E:0028
PCODE_DIV                        E:000A
PCODE_EOR                        E:0020
PCODE_EQL                        E:0010
PCODE_FINISHD                    E:0011
PCODE_GEQ                        E:0016
PCODE_GTR                        E:0018
PCODE_INC                        E:0026
PCODE_INP                        E:001C
PCODE_INS                        E:0025
PCODE_INT                        E:003B
PCODE_JM1                        E:003E
PCODE_JMP                        E:003C
PCODE_JMZ                        E:003D
PCODE_LAST                       E:0045
PCODE_LCD_WRITE_CHR              E:0045
PCODE_LCD_WRITE_HEX              E:0044
PCODE_LCD_WRITE_NUM              E:0042
PCODE_LCD_WRITE_STR              E:0043
PCODE_LDA                        E:002E
PCODE_LDI                        E:0030
PCODE_LEQ                        E:0019
PCODE_LIB_CALL                   E:0003
PCODE_LIT                        E:0000
PCODE_LOD                        E:002C
PCODE_LSS                        E:0014
PCODE_MOD                        E:000B
PCODE_MOV                        E:002A
PCODE_MUL                        E:0008
PCODE_NEG                        E:0002
PCODE_NEQ                        E:0012
PCODE_ORR                        E:001A
PCODE_OUH                        E:0021
PCODE_OUS                        E:0023
PCODE_OUT                        E:001E
PCODE_OUTC                       E:001F
PCODE_OUTCR                      E:0040
PCODE_RTN                        E:0029
PCODE_SHL                        E:0022
PCODE_SHR                        E:0024
PCODE_STA                        E:0034
PCODE_STACK                      E:0001
PCODE_STI                        E:0036
PCODE_STO                        E:0032
PCODE_SUB                        E:0006
PCODE_XOR                        E:003A
PRBYTE                           A:949A
PRBYTECR                         E:954F
PRCHAR                           E:9482
PRCITM                           S:0039
PRHEX                            A:94A3
PRHEX1                           A:94AD
PRHEXZ                           A:94A5
PSH1                             E:C03B
PSH9                             A:946E
PSHPCODE                         E:B080
PSHTOP                           E:C030
PSHWRK                           E:945C
PT                               A:94B4
PT6                              A:94BC
PUL2_END                         E:C029
PULBOTH                          A:C00B
PULTOP                           E:BFE9
PULTOP2                          E:C00E
PULWRK                           E:946F
PUL_END                          E:C004
PUTSP                            E:94B0
READ                             A:B4AF
READ11                           A:B4CF
READ2                            A:B4B5
READ3                            A:B4FE
READ3_A                          A:B52D
READ3_B                          A:B512
READ7                            A:B4EE
READ7_A                          A:B4F4
READ8                            A:B4B2
READ9                            A:B4CC
REG                              E:0000
REG2                             E:0003
REG2B                            E:0005
REGB                             E:0002
REMAIN                           S:0006
REP1                             A:B660
REPEAT                           A:B65D
RES                              S:0052
RESTART                          E:DC65
RMNDR                            S:005B
RSVEND                           A:D14B
RSVWRD                           E:D058
RUNERR                           A:95E4
RUNNING                          S:003F
RUNNING_STACK_TOP                E:00CF
SEA1                             E:C91F
SEA2                             E:C92C
SEA3                             E:C980
SEA4                             E:C975
SEA5                             E:C97D
SEARCH                           E:C90C
SEA_NEXT                         E:C914
SERIAL_DEBUG1_MASK               E:0004
SERIAL_DEBUG2_MASK               E:0008
SERIAL_DEBUGGING                 E:0000
SERIAL_DELAY1                    E:0030
SERIAL_DELAY2                    E:0023
SERIAL_OUT_MASK                  E:0002
SERIAL_SPARE2_MASK               E:0010
SIM1                             A:B149
SIM2                             A:B191
SIM3                             A:B15A
SIM4                             A:B16D
SIM5                             A:B189
SIM6                             A:B18D
SIM7                             A:B183
SIM8                             A:B197
SIMEXP                           E:B13F
SINGLE_QUOTE                     E:0027
SPI_DDR                          E:7FF2
SPI_MISO                         E:0004
SPI_MOSI                         E:0002
SPI_PORT                         E:7FF0
SPI_SCK                          E:0008
SPI_SS                           E:0001
SRCE                             E:0000
START                            E:DC49
STARTSYM                         S:002F
START_OF_ROM                     E:8000
START_TRACE                      A:CB34
STK_ERR                          A:B102
STK_FULL                         E:B102
STMNT                            A:B35F
STMNT1                           A:B36C
STMNT_WRITE_LCD                  A:B45E
STOP_TRACE                       A:CB35
SYMARG                           E:0006
SYMBOL_ARRAY                     E:0041
SYMBOL_CONSTANT                  E:0043
SYMBOL_FUNCTION                  E:0046
SYMBOL_FUNCTION_RETURN           E:0059
SYMBOL_LIBRARY_FUNCTION          E:0052
SYMBOL_LIBRARY_PROCEDURE         E:0051
SYMBOL_PROCEDURE                 E:0050
SYMBOL_TABLE_START               E:3FFF
SYMBOL_VARIABLE                  E:0056
SYMDAT                           E:0008
SYMDSP                           E:0004
SYMITM                           S:0040
SYMLEN                           E:0009
SYMLIB                           E:0002
SYMLVL                           E:0002
SYMNAM                           E:000A
SYMPRV                           E:0000
SYMSUB                           E:0006
SYMTYP                           E:0003
SYMWRK                           E:B06A
SYM_FULL                         A:C983
SYNTAX                           S:0042
T                                E:0031
TEMP                             S:0045
TERM                             A:B1B1
TERM1                            A:B1BE
TERM2                            A:B1B4
TERM3                            A:B1CF
TERM4                            A:B1CD
TERM5                            A:B1D5
TERM6                            A:B1D9
TERM7                            A:B1DD
TERM8                            A:B1E1
TERM9                            A:B1E5
TERMT1                           A:B19B
TERMT3                           A:B1E9
TEXT_START                       E:0300
TKNJMP                           E:918F
TKNWRK                           E:94C6
TOKEN_ADDRESS                    E:00A9
TOKEN_AND                        E:008D
TOKEN_ARRAY                      E:0084
TOKEN_ASSIGN                     E:0041
TOKEN_BEGIN                      E:0088
TOKEN_CALL                       E:009F
TOKEN_CASE                       E:0095
TOKEN_CHAR                       E:00A1
TOKEN_CHR                        E:00AB
TOKEN_CONST                      E:0082
TOKEN_DIV                        E:008B
TOKEN_DO                         E:0097
TOKEN_DOWNTO                     E:009C
TOKEN_ELSE                       E:0094
TOKEN_END                        E:0089
TOKEN_EQUALITY                   E:0045
TOKEN_FOR                        E:009A
TOKEN_FUNCTION                   E:0087
TOKEN_GEQ                        E:0081
TOKEN_HEX                        E:00AC
TOKEN_HIGH_BYTE                  E:0057
TOKEN_IDENTIFIER                 E:0049
TOKEN_IF                         E:0092
TOKEN_INEQUALITY                 E:005A
TOKEN_INTEGER                    E:00FE
TOKEN_LCDWRITE                   E:00F1
TOKEN_LEQ                        E:0080
TOKEN_LOGICAL_AND                E:0058
TOKEN_LOGICAL_OR                 E:0059
TOKEN_LOW_BYTE                   E:0056
TOKEN_MEM                        E:0091
TOKEN_MEMC                       E:00A2
TOKEN_MOD                        E:008C
TOKEN_NEQ                        E:0055
TOKEN_NOT                        E:0090
TOKEN_NUMBER                     E:004E
TOKEN_OF                         E:0085
TOKEN_OR                         E:008A
TOKEN_PROCEDURE                  E:0086
TOKEN_READ                       E:009E
TOKEN_REPEAT                     E:0098
TOKEN_SHIFT_LEFT                 E:004C
TOKEN_SHIFT_RIGHT                E:0052
TOKEN_SHL                        E:008E
TOKEN_SHR                        E:008F
TOKEN_STRING                     E:0022
TOKEN_THEN                       E:0093
TOKEN_TO                         E:009B
TOKEN_UNARY_MINUS                E:004D
TOKEN_UNTIL                      E:0099
TOKEN_VAR                        E:0083
TOKEN_WHILE                      E:0096
TOKEN_WRITE                      E:009D
TOKEN_WRITELN                    E:00FF
TOKEN_XOR                        E:00A4
TRUE                             A:C0F4
TRUE2                            A:C0F6
TWO_OP                           A:B53B
USE_ASSEMBLER                    E:0001
USE_CP437_FONT                   E:0001
USE_PASCAL                       E:0001
VALUE                            S:0000
VALUE2                           S:0003
VAL_1                            E:B0DB
VAL_2                            E:B0E0
VAL_3                            E:B0E9
VAL_5                            E:B0F2
VAL_MOVE                         E:B0D2
VAL_WRK                          E:B852
VARDEC                           A:B12D
VIA_ACR                          E:7FFB
VIA_DDRA                         E:7FF3
VIA_DDRB                         E:7FF2
VIA_FLAG_CB2                     E:0008
VIA_FLAG_DISABLE                 E:0000
VIA_FLAG_ENABLE                  E:0080
VIA_FLAG_TIMER1                  E:0040
VIA_IER                          E:7FFE
VIA_IFR                          E:7FFD
VIA_PCR                          E:7FFC
VIA_PORTA                        E:7FF1
VIA_PORTB                        E:7FF0
VIA_T1C_H                        E:7FF5
VIA_T1C_L                        E:7FF4
WAIT_1                           A:B54E
WHILE                            A:B681
WORK                             S:0037
WORKD                            S:0033
WRIT1                            E:B439
WRIT10                           A:B42C
WRIT2                            A:B429
WRIT5                            A:B449
WRIT9                            A:B410
WRITE                            A:B40D
WRITELN                          A:B3FE
WRITELN9                         E:B408
WRITE_LCD1                       E:B48A
WRITE_LCD2                       A:B47A
WRITE_LCD5                       A:B49A
WRITE_LCD9                       A:B461
WRITE_LCD_STRING                 E:B470
WRITE_LDC_CHR                    E:B4A3
WRITE_LDC_CHR1                   E:B4A5
WRITE_LDC_HEX                    E:B4AB
WRKD_WRK                         E:B0AF
WRKSYM                           E:B075
WRKTKN                           E:94D1
WRK_OPND                         E:B0A4
WRK_VAL                          E:B847
WRK_WRKD                         E:B0BA
W_CHR                            E:B452
W_CHR1                           E:B454
W_HEX                            E:B45A
W_STRING                         E:B41F
ZERRES                           A:AEE2
a_equals_message                 A:C61C
add_assembler_library_functions  A:ACF8
add_assembler_library_functions  A:AD48
add_assembler_library_functions  A:AD00
add_assembler_library_functions  A:AD10
add_pascal_library_functions     A:BBF5
add_pascal_library_functions_do  A:BC4E
add_pascal_library_functions_lo  A:BBFD
add_pascal_library_functions_na  A:BC0D
asm_do_asc                       E:A6A7
asm_do_asc_loop                  A:A6B4
asm_do_asc_next                  A:A6BD
asm_do_asc_ok                    A:A6B2
asm_do_assert                    A:A642
asm_do_assert_failed             A:A651
asm_do_blk                       A:A779
asm_do_blk_done                  A:A796
asm_do_blk_loop                  A:A789
asm_do_constant_expected         A:A6EE
asm_do_constant_expectedJ        A:A656
asm_do_constant_expectedJ2       A:A7AF
asm_do_dfb                       A:A6FC
asm_do_dfb_multiple              A:A70A
asm_do_dfb_multiple_done         A:A728
asm_do_dfb_multiple_loop         A:A717
asm_do_dfb_too_big               A:A729
asm_do_dfw                       A:A73C
asm_do_dfw_multiple              A:A74A
asm_do_dfw_multiple_done         A:A769
asm_do_dfw_multiple_loop         A:A758
asm_do_equ                       A:A6CB
asm_do_equ_have_label            A:A6DC
asm_do_list                      E:A659
asm_do_list1                     A:A697
asm_do_list_first_pass           A:A6A6
asm_do_list_no_operand           A:A679
asm_do_list_not                  A:A693
asm_do_list_ok                   A:A67D
asm_do_nolist                    A:A668
asm_do_nolist_ok                 A:A673
asm_do_org                       A:A6E8
asm_do_org_ok                    A:A6F3
asm_do_reserve                   A:A797
asm_do_string                    A:A6C2
asm_do_sym                       A:A7B2
asm_do_sym_done                  A:A7CB
asm_emit_one_byte                A:A72E
asm_emit_two_bytes               A:A76A
ass_absolute_another_value       A:9D41
ass_added_symbol                 A:9B7E
ass_already_emitted              A:A10B
ass_bad_identifier               A:9B33
ass_bad_indirect                 A:9CA8
ass_bad_zp_indirect_indexed      A:9CE2
ass_branch_backwards             A:A14C
ass_branch_ok                    A:A150
ass_branch_out_of_range          A:A156
ass_check_label_changed          A:9BE8
ass_check_no_more_tokens         A:9E3C
ass_check_no_more_tokens_ok      A:9E47
ass_check_we_have_x_or_y         A:9CE9
ass_check_we_have_x_or_y_ok      A:9D05
ass_current_label                S:0083
ass_done                         A:9DF9
ass_done1                        A:9E1B
ass_done_jump                    A:9AF5
ass_done_message                 A:9E1E
ass_done_second_pass             A:9E03
ass_emit                         A:A0E8
ass_emit1                        A:A123
ass_emit2                        A:A0FC
ass_emit3                        A:A11D
ass_emit4                        A:A116
ass_emit_absolute                A:A185
ass_emit_bytes                   S:0077
ass_emit_immediate               A:A172
ass_emit_immediate_too_high      A:A180
ass_emit_zero_page               A:A15F
ass_emit_zero_page_too_high      A:A16D
ass_error                        A:962E
ass_error1                       A:9635
ass_evaluate_operator            A:A0C1
ass_expression_apply_operator    A:A080
ass_expression_apply_operator_b  A:A0BC
ass_expression_cannot_be_unary   A:A02C
ass_expression_found_value       A:9FBA
ass_expression_loop              A:9F6D
ass_expression_loop1             A:9F9E
ass_expression_loop1a            A:9F87
ass_expression_loop2             A:9FCB
ass_expression_loop3             A:9FDA
ass_expression_loop3a            A:9FE9
ass_expression_loop3b            A:9FDE
ass_expression_loop3c            A:9FEE
ass_expression_loop4             A:9FF4
ass_expression_loop6             A:A052
ass_expression_loop7             A:A03B
ass_expression_loopJ             A:9FF1
ass_expression_loop_initial      A:9F70
ass_expression_not_small_string  A:9F99
ass_expression_number            A:9F74
ass_expression_unary             A:A0A9
ass_finish_line                  A:9AEA
ass_finish_lineJ                 A:9C0E
ass_fixup_bbr_branch             A:A126
ass_fixup_branch                 A:A133
ass_get_value                    A:9F53
ass_identifier                   A:9B38
ass_identifier_operand           A:9C4C
ass_illegal_opcode               A:9B9F
ass_immediate                    A:9C30
ass_indexed                      A:9D1A
ass_indexed_x                    A:9D38
ass_indirect                     A:9C43
ass_indirect_with_bracket        A:9CAD
ass_label_not_found_yet          A:9FB2
ass_line                         A:9AF8
ass_line1                        A:9B07
ass_lookup_existing_label        A:9B68
ass_lookup_loop                  A:A0C4
ass_lookup_save_address          A:9B72
ass_not_colon                    A:9B90
ass_not_colon2                   A:9B97
ass_not_unary_greater_than       A:A016
ass_not_unary_less_than          A:A00C
ass_not_unary_minus              A:A002
ass_not_x_or_y                   A:9CE7
ass_opcode                       A:9BA7
ass_opcode2                      A:9BFD
ass_opcode_found                 A:A0E2
ass_operand                      A:9C11
ass_operand_value                A:9C6D
ass_string                       A:9C23
ass_symbol_address_changed       A:9BF8
ass_value_done                   A:9D11
ass_value_not_indirect           A:9D07
ass_value_not_indirectJ          A:9CA5
ass_zp_indirect_indexed          A:9CC1
assembler_library_functions_tab  A:A838
assertion_failed_message         A:999A
assign_bad_identifier            A:B3BC
atoi                             A:CC8E
atoi_error                       E:CCFD
atoi_loop                        E:CC97
atoi_more                        E:CCA8
atoi_not_running                 E:CD03
atoi_positive                    A:CCA6
bad_command                      A:8248
bad_delimiter_message            A:86C3
bad_flag_message                 A:882D
bcd_output_digit                 A:936D
bcd_positive                     A:935B
bcd_result                       S:0060
bcd_skip_zeroes                  A:9362
bcd_table                        E:92EF
bcd_unpack                       A:92DC
bcd_work                         S:005C
binary_to_decimal                A:9378
binary_to_decimal_loop           A:9383
binary_to_decimal_next           A:93A8
break_message                    A:C601
brk_address                      S:0015
brk_executed                     A:C64D
brk_executed1                    A:C6CB
brk_executed2                    A:C6D8
brk_executed3                    A:C6E8
brk_executed4                    A:C702
brk_executedJ                    A:C714
brk_resumed                      A:8CD6
bytes_message                    A:9278
call_a                           S:0010
call_assembler                   A:9581
call_handler                     A:9147
call_p                           S:0013
call_s                           S:0014
call_x                           S:0011
call_y                           S:0012
cb2_interrupt                    A:C73C
character_types_table            E:8006
compile_finished_message         A:94EF
cp437_font                       A:D3D6
crc16                            E:91FA
crc16_loop                       E:9206
crc16_next                       A:9213
crc16_skip                       A:9219
crc_addr                         E:0000
crc_byte                         E:9222
crc_done                         A:9221
crc_helper1                      A:9252
crc_message                      A:9255
crc_num                          E:0003
crc_source                       E:9280
crc_val                          E:0006
current_line                     S:00A2
delay                            E:92D2
delay_1ms                        E:92C8
delay_1ms_loop                   A:92CB
digitalread                      E:CAEC
digitalread_B                    A:CAFB
digitalread_C                    A:CB03
digitalwrite                     E:CABD
digitalwrite_B                   A:CACE
digitalwrite_C                   A:CAD6
digitalwrite_ONE                 A:CAE4
display_in_decimal               E:934F
display_x_characters             A:BEF6
edit_library_continue            A:90C8
editor_argument_check            A:8B87
editor_argument_check_failed     A:8B99
editor_argument_check_got_argum  A:8BA3
editor_argument_check_loop       A:8B89
editor_assemble                  A:8EF1
editor_bad_delimiter             A:86D2
editor_bad_number                A:8558
editor_bad_range                 A:8613
editor_bad_rangeJ                A:86AC
editor_check_no_more             A:8640
editor_check_no_more_failed      A:8652
editor_check_no_more_loop        A:8642
editor_check_no_more_ok          A:865C
editor_compile                   A:8E2E
editor_debug                     A:8DEE
editor_debug_ok                  A:8E01
editor_default_range             A:853A
editor_delete                    A:8BA4
editor_delete_line_count_done    A:8C12
editor_delete_line_count_loop    A:8BF2
editor_delete_line_count_not_do  A:8BFE
editor_delete_line_count_not_ne  A:8C0A
editor_do_replace                A:89A2
editor_do_replace_copy_done      A:89E7
editor_do_replace_smaller        A:89E4
editor_do_the_replace            A:8908
editor_done_message              A:8DB4
editor_easy_replace              A:8915
editor_easy_replace_done         A:8926
editor_easy_replace_loop         A:8919
editor_find                      A:8757
editor_find_bug                  A:8795
editor_find_case_sensitive       A:88C6
editor_find_found_it             A:88EA
editor_find_found_it1            A:88F0
editor_find_get_flags            A:87EF
editor_find_inner_loop           A:88AF
editor_find_loop                 A:88AB
editor_find_no_match             A:88D4
editor_find_or_replacing         A:88A7
editor_find_problem              A:86D6
editor_find_second_delimiter_lo  A:87A2
editor_find_skip_this            A:88D0
editor_find_test_character       A:88C7
editor_find_third_delimiter_loo  A:87C9
editor_flags                     S:00BC
editor_flags1                    A:880F
editor_flags2                    A:8819
editor_flags3                    A:8823
editor_flags_loop                A:87F1
editor_get_delimiter             A:8700
editor_get_number                A:8562
editor_get_number_done           A:85CA
editor_get_number_end            A:85CE
editor_get_number_none           A:85CC
editor_get_number_not_identifie  A:85A4
editor_get_number_ok             A:85BA
editor_get_range                 A:865D
editor_get_range_done            A:86AB
editor_get_range_hyphen          A:8693
editor_get_range_number          A:8698
editor_handlers                  A:82D6
editor_help                      A:851B
editor_help_done                 A:8537
editor_help_info                 A:838A
editor_help_loop                 A:8526
editor_info                      E:8E1C
editor_insert                    A:8A16
editor_insert_at_start           A:8A30
editor_insert_backspace          A:8ACA
editor_insert_backspace_not_at_  A:8AD6
editor_insert_common             A:8A3E
editor_insert_done               A:8AEC
editor_insert_done_with_newline  A:8AFD
editor_insert_loop               A:8A81
editor_insert_loop1              A:8ABA
editor_insert_no_line_number     A:8A92
editor_insert_not_newline        A:8AB1
editor_jmp                       A:905A
editor_jmp_got_number            A:9064
editor_jmp_number_in_range       A:906B
editor_jsr                       A:9029
editor_jsr_got_number            A:9033
editor_jsr_got_number_execute    A:9057
editor_jsr_number_in_range       A:903A
editor_library                   A:907B
editor_library_done              A:9104
editor_library_filter_loop       A:90B4
editor_library_filter_reject     A:90BF
editor_library_filter_reject_lo  A:90C1
editor_library_loop              A:90A6
editor_library_make_lower_loop   A:9092
editor_library_name_loop         A:90CA
editor_library_name_onto_next    A:90F3
editor_library_no_search         A:909E
editor_library_search            A:9087
editor_line_count_done           A:8EE3
editor_line_count_loop           A:8ECD
editor_line_count_not_newline    A:8EDB
editor_line_number_too_big       A:85FA
editor_list                      A:8763
editor_list_aborted              A:889A
editor_list_check_to_line        A:8956
editor_list_check_to_line_ok     A:8966
editor_list_completely_done      A:899F
editor_list_doing_find           A:8789
editor_list_done                 A:8982
editor_list_doneJ                A:886D
editor_list_fix_target_string    A:883B
editor_list_fixup_loop           A:8843
editor_list_get_on_with_it       A:8856
editor_list_got_from_point       A:87A0
editor_list_have_source          A:8867
editor_list_loop                 A:8873
editor_list_loopJ                A:897F
editor_list_no_line_number       A:8944
editor_list_no_line_numberJ      A:8870
editor_list_not_find             A:8853
editor_list_not_finding          A:8937
editor_list_not_newline          A:896E
editor_list_skip_newline         A:8979
editor_load                      A:8A12
editor_memory                    A:8CEA
editor_memory_aborted            A:8D5D
editor_memory_ascii              A:8D68
editor_memory_done               A:8D5A
editor_memory_loop               A:8D04
editor_memory_loop1              A:8D25
editor_memory_loop2              A:8D37
editor_memory_loop3              A:8D4D
editor_memory_not_control        A:8D70
editor_memory_not_high           A:8D76
editor_memory_show_ascii         A:8D63
editor_memory_show_dot           A:8D74
editor_newline_processing        A:894C
editor_no_closing_delimiter      A:872E
editor_no_closing_delimiterJ     A:879D
editor_no_closing_delimiter_mes  A:8718
editor_no_find_string            A:8749
editor_no_lines                  A:8B30
editor_not_assembler             A:8DF7
editor_poke                      A:8F6C
editor_poke_another              A:8FD3
editor_poke_bad_token            A:8F8D
editor_poke_failed               A:9006
editor_poke_failed_message       A:8FE5
editor_poke_got_all_numbers      A:8FA8
editor_poke_got_enough           A:8FB8
editor_poke_got_number           A:8F90
editor_poke_loop                 A:8F76
editor_poke_message              A:8F44
editor_poke_not_first            A:8F9F
editor_poke_to_message           A:9000
editor_poking_loop               A:8FCB
editor_recover                   A:8D9F
editor_recover_not_needed        A:8DBE
editor_replace                   A:874F
editor_replacement_loop          A:88A9
editor_resume                    A:8F16
editor_resume_ok                 A:8F29
editor_run                       A:8E42
editor_save                      A:875D
editor_syntax                    A:8E38
editor_too_full                  A:8B18
editor_too_full_loop             A:8B1F
editor_trace                     A:8E0A
end_of_rom_routines              A:DC7E
error1                           A:9A37
error_find_next                  A:9A2E
error_found                      A:9A58
error_loop                       A:9A2A
error_next                       A:9A29
error_not_found                  A:9A40
error_not_found_message          A:9A65
errors_table                     A:9638
ex_input_aborted                 A:C52B
execution_aborted_message        A:C517
execution_address_table          E:BDA9
exp_abs_val                      A:AEB2
exp_abs_val2                     A:AECA
exp_abs_val2_done                A:AEE1
exp_abs_val_done                 A:AEC9
exp_add                          A:AD49
exp_bitwise_and                  A:ADEC
exp_bitwise_or                   A:ADD7
exp_bitwise_xor                  A:AE01
exp_divide                       A:AF50
exp_divide_loop                  A:AF6D
exp_divide_not_zero              A:AF60
exp_divide_subtraction_negative  A:AF95
exp_divide_subtraction_positive  A:AF96
exp_done                         A:A063
exp_done_error                   A:A069
exp_done_ok                      A:A06E
exp_eql                          A:AD83
exp_evaluation_function          S:007F
exp_false                        A:AD7C
exp_falseJ                       A:AE19
exp_find_sign                    A:AEEB
exp_fix_sign                     A:AF03
exp_fix_sign_done                A:AF16
exp_geq                          A:ADD0
exp_get_operator                 A:9EBE
exp_get_operator_ok              A:9EC7
exp_get_precedence               A:9F2C
exp_get_precedence_found         A:9F42
exp_get_precedence_loop          A:9F2E
exp_greater_than                 A:ADB2
exp_high_byte                    A:AEA9
exp_leq                          A:ADC1
exp_less_than                    A:ADAB
exp_logical_and                  A:AE2B
exp_logical_or                   A:AE1C
exp_low_byte                     A:AEA4
exp_modulo                       A:AFB0
exp_multiply                     A:AF17
exp_multiply_loop                A:AF1C
exp_multiply_no_add              A:AF3D
exp_negate                       A:AE6F
exp_negate_val                   A:AEB6
exp_negate_val2                  A:AECE
exp_neq                          A:AD97
exp_no_operators_left            A:A05A
exp_not                          A:AE82
exp_operator                     S:007D
exp_operator_precedence          S:007E
exp_operator_stack_count         S:007C
exp_pop_operator                 A:9EAE
exp_pop_operator_ok              A:9EB7
exp_pop_value                    E:9E73
exp_pop_value_ok                 A:9E7C
exp_precedence_table             A:9ECC
exp_precedence_table_end         E:9F2C
exp_push_operator                A:9E9C
exp_push_operator_ok             A:9EA7
exp_push_value                   E:9E48
exp_push_value_memory_full       A:9E4E
exp_push_value_not_full          A:9E62
exp_push_value_ok                A:9E53
exp_shift_left                   A:AE3D
exp_shift_left_done              A:AE55
exp_shift_left_loop              A:AE4C
exp_shift_right                  A:AE56
exp_shift_right_done             A:AE6E
exp_shift_right_loop             A:AE65
exp_subtract                     A:AD5D
exp_true                         A:AD73
exp_trueJ                        A:AE16
exp_unary_minus                  A:AE90
exp_unary_ok                     S:0081
exp_value_stack                  S:0079
exp_value_stack_count            S:007B
find_count                       S:00B9
find_delimiter                   S:00B4
find_flags                       S:00BD
find_from                        S:00B0
find_len                         S:00B3
find_line                        A:8C85
find_line_eof                    A:8CB8
find_line_loop                   A:8C93
find_line_next                   A:8CA2
find_line_same_line              A:8CB0
find_pos                         S:00B2
find_source_end                  A:8CB9
find_source_end_done             E:8CD5
find_source_end_loop             E:8CC1
find_source_end_wrap             E:8CCF
find_string_too_long             A:86FA
find_string_too_longJ            A:879A
find_string_too_long_message     A:86DC
find_to                          S:00B1
found_message                    A:86AF
found_this_line                  S:00BB
from_line                        S:009E
from_msg                         A:86B7
gc_alpha_alpha_only              A:CC1F
gc_alpha_done                    A:CC1B
gc_alpha_loop                    A:CC02
gc_alpha_ok                      A:CC0A
gc_ampersand                     A:D014
gc_assembler_comment_find_end    A:CE23
gc_assembler_comment_keep_looki  A:CE35
gc_assembler_comment_not_eof     A:CE2E
gc_assign                        A:CFB0
gc_backslash_tokens              A:CE3D
gc_backslash_tokens_end          E:CE53
gc_backslash_tokens_length       E:0016
gc_bang                          A:D047
gc_bar                           A:D025
gc_binary_literal                A:CF87
gc_binary_loop                   A:CF8F
gc_colon                         A:CFA5
gc_comment_found_end             A:CDBC
gc_comment_keep_looking          A:CDB4
gc_comment_not_eof               A:CD9C
gc_comment_not_newline           A:CDA5
gc_directive_list                A:CE04
gc_directive_nolist              A:CE11
gc_directive_pcodes              A:CE0B
gc_directive_symbols             A:CDCC
gc_directive_symbols_ok          A:CDD8
gc_directive_symbols_too_late    A:CDFF
gc_dollar                        A:CF21
gc_done                          A:CBE5
gc_equality                      A:D041
gc_equals                        A:D036
gc_fix_hex                       A:CEE5
gc_fix_hex_not_a_to_f            A:CEEE
gc_geq                           A:CFE9
gc_greater_than                  A:CFD9
gc_hex_done                      A:CF71
gc_hex_literal                   A:CF2D
gc_hex_loop                      A:CF36
gc_hex_too_big                   A:CF76
gc_inequality                    A:D052
gc_leq                           A:CFCA
gc_less_than                     A:CFB6
gc_lh_brace                      A:CD60
gc_lh_paren                      A:CD64
gc_logical_and                   A:D01F
gc_logical_or                    A:D030
gc_minus                         A:CFF3
gc_neq                           A:CFCF
gc_newline                       A:CBC2
gc_newline1                      A:CBCF
gc_newline_assembling            A:CBDC
gc_not_alpha                     A:CC28
gc_not_digit                     A:CC34
gc_not_space                     A:CBFD
gc_pascal_comment                A:CD72
gc_pascal_comment_find_end       A:CD91
gc_percent                       A:CF7B
gc_plus                          A:CFF5
gc_quote                         A:CE53
gc_quote_backslash_loop          A:CEBC
gc_quote_bad                     A:CE6A
gc_quote_bad_string              A:CEC7
gc_quote_copied_value            A:CE8F
gc_quote_done                    A:CE98
gc_quote_found_backslash_charac  A:CED0
gc_quote_hex_character           A:CEF2
gc_quote_hex_character_done      A:CECC
gc_quote_hex_character_one_only  A:CF1E
gc_quote_long_string             A:CE84
gc_quote_loop                    A:CE61
gc_quote_loop_not_end_of_line    A:CE6F
gc_quote_not_backslash           A:CED4
gc_quote_not_finished            A:CEAA
gc_quote_too_long                A:CEE0
gc_semicolon                     A:CE1A
gc_shift_left                    A:CFD4
gc_shift_right                   A:CFEE
gc_single_byte_already_known     A:CBE1
gc_single_byte_already_knownJ    A:CD5D
gc_single_byte_already_knownJ2   A:CFE6
gc_single_byte_token             A:CBE3
gc_single_byte_tokenJ            A:CD5A
gc_skip_spaces                   A:CBAD
gen_random                       A:91D7
gen_random1                      A:91F9
get_token                        A:CB9F
get_token_loop                   A:CBA3
gtoken_directive_table           A:CD4D
gtoken_table                     A:CD1C
handlerLookup                    A:9107
handler_find_length              A:910F
handler_found_directive          A:9135
handler_found_length             A:9118
handler_loop                     A:9109
handler_next                     A:911C
handler_same_length              A:912C
handlers_done                    A:9145
hardware_init                    A:CB36
hardware_work                    S:008C
i2c_begin_transmission           A:D1EA
i2c_begin_transmission_loop      A:D1EE
i2c_delay                        A:D1CB
i2c_end_transmission             A:D2AD
i2c_init                         A:D1C0
i2c_read                         A:D257
i2c_read_ack_or_nak              A:D294
i2c_read_ack_or_nak_wait         A:D299
i2c_read_done                    A:D2AB
i2c_read_loop                    A:D260
i2c_read_nak                     A:D28F
i2c_read_next                    A:D279
i2c_read_zero                    A:D275
i2c_receive                      A:D2EF
i2c_receive_done                 A:D312
i2c_receive_fail                 A:D317
i2c_receive_loop                 A:D2FD
i2c_send                         A:D2C6
i2c_send_done                    A:D2E5
i2c_send_fail                    A:D2EA
i2c_send_loop                    A:D2CE
i2c_toggle_clock                 A:D1CF
i2c_toggle_clock_wait            A:D1D7
i2c_write                        A:D211
i2c_write_clock                  A:D22B
i2c_write_clock_wait             A:D23B
i2c_write_got_ack                A:D255
i2c_write_loop                   A:D214
i2c_write_lost_arbitration       A:D253
i2c_write_one                    A:D220
id_equals_message                A:C644
info_message                     A:A7CC
insert_limit                     S:00A4
introduction                     A:DBD6
irq                              A:C717
irq1                             A:C724
irq_done                         A:C79C
is_xxx_fail                      A:8106
is_xxx_pass                      A:810A
isalnum                          E:8162
isalpha                          E:8126
isbin                            A:8176
isbinary                         E:816E
iscntrl                          E:8156
isdigit                          E:8132
islower                          E:811A
isspace                          E:814A
isupper                          E:810E
isxdigit                         E:813E
lcd_clear_display                A:C8E0
lcd_clear_enable                 A:C83C
lcd_data_nibble                  A:C89F
lcd_get_address                  A:C86C
lcd_home                         A:C8F0
lcd_initialise                   A:C79F
lcd_instruction                  A:C88C
lcd_prepare_to_read_register     A:C7F8
lcd_prepare_to_write_data        A:C80B
lcd_prepare_to_write_instructio  A:C820
lcd_print                        A:C901
lcd_print_char                   A:C8AE
lcd_print_char_newline           A:C8CF
lcd_print_char_ok                A:C8CF
lcd_print_char_on_2nd_line       A:C8C8
lcd_print_done                   A:C90B
lcd_print_message                A:C8F8
lcd_print_not_newline            A:C8B9
lcd_read_instruction_nibble      A:C845
lcd_second_line                  A:C8E8
lcd_set_enable                   A:C833
lcd_wait                         A:C851
lcd_wait_timeout                 A:C868
lcd_work                         S:0086
lcd_write_instruction_nibble     A:C880
lcdbusy                          A:C859
library_function_call            A:BC4F
library_function_call_1          A:BC8B
library_function_call_2          A:BC5C
library_function_call_3          A:BC86
library_function_call_5          A:BC8E
line_number_lt_1000              A:8C60
line_number_output_spaces        A:8C6F
lines_deleted_message            A:8C3C
list_symbols                     E:A7D7
list_symbols_check               E:A7F1
list_symbols_done                E:A837
list_symbols_line                E:A800
list_symbols_name                E:A826
list_symbols_next                E:A7E6
list_symbols_user                A:A80C
load_message                     A:89F0
m_alnum                          E:0080
m_alpha                          E:0004
m_cntrl                          E:0040
m_digit                          E:0008
m_lower                          E:0002
m_space                          E:0020
m_upper                          E:0001
m_xdigit                         E:0010
main_loop                        A:828C
main_loop_not_run                A:82B8
main_prompt                      A:8272
main_start                       A:826B
maths_work                       S:008D
mem_move_dest                    S:00A8
mem_move_len                     S:00AA
mem_move_src                     S:00A6
memory_filled_up                 A:8B5E
memory_full                      A:8B43
movedown                         A:817A
movedown1                        A:819D
movedown2                        A:8190
movedown_done                    A:819C
movedown_loop                    A:8186
moveup                           A:81A6
moveup3                          A:81D8
moveup_done                      A:81E4
moveup_loop                      A:81CE
moveup_next                      E:81E5
negate_token_value               A:CD08
no_break_message                 A:8EF7
no_find_message                  A:8734
no_valid_compile_message         A:9525
not_assembler_message            A:8DC8
notbin                           A:8178
number_bad_range_message         A:8604
number_expected_message          A:8547
number_too_large_message         A:85DB
opcode_lookup                    A:9D50
opcode_lookup_correct_length     A:9D7B
opcode_lookup_correct_operand    A:9DA9
opcode_lookup_loop               A:9D62
opcode_lookup_loop_done          A:9DC0
opcode_lookup_loop_unknown       A:9DF5
opcode_lookup_next_table         A:9D6C
opcode_lookup_no_handler         A:9DBF
opcode_lookup_ok                 A:9DF8
p_equals_message                 A:C634
partial_handler_Lookup           A:914A
partial_handler_done             A:918E
partial_handler_found_directive  A:917A
partial_handler_next             A:9163
partial_handler_next_found_item  A:916A
partial_handler_next_item        A:914C
partial_handler_next_loop        A:9154
partial_handler_skipped_string   A:9181
pas_gc_identifier                A:D157
pas_gc_loop                      A:D15F
pas_gc_more                      A:D168
pas_gc_no_match                  E:D190
pas_get_token                    A:D14D
pas_get_token_eof                A:D156
pascal_library_functions_table   A:BB55
pcodes_ended_message             A:94DC
pin_number_to_mask               E:CA7B
pin_number_to_mask_done          A:CA89
pin_number_to_mask_loop          A:CA81
pinmode                          A:CA8E
pinmode_B                        A:CA9F
pinmode_C                        A:CAA7
pinmode_OUTPUT                   A:CAB5
prchar_not_control               A:9495
print                            A:8226
print_done                       A:823E
print_loop                       A:8234
prompt                           A:8245
random                           S:0009
recover_done                     A:8D8D
recover_not_needed               A:8D93
rep_diff                         S:00B7
rep_from                         S:00B5
rep_to                           S:00B6
run_assembler                    A:9574
running_message                  A:DC40
s_equals_message                 A:C63C
serial_available                 E:CB30
serial_in_byte                   S:008A
serial_in_byte_received          S:008B
serial_in_loop                   A:C748
serial_out_bit                   S:0089
serial_out_byte                  S:0087
serial_print                     A:CB94
serial_print_done                A:CB9E
serial_print_message             A:CB8E
serial_send_count_bits           A:C78D
show_current_line                A:9A75
show_current_line_done           A:9ABA
show_current_line_loop           A:9A97
show_current_line_loop_print_on  A:9AAF
show_current_line_number         A:8C47
show_current_line_number_done    A:8C7B
show_source_end                  A:8E73
show_source_lines                A:8EBD
show_source_start                A:8E9B
show_symbol_table_end            A:8E4E
show_symbols                     S:0082
source_ended_message             A:8E60
source_length_message            A:9268
source_line_count                A:8EAD
source_starts_message            A:8E88
spi_init                         A:D31C
spi_init2                        A:D33A
spi_init3                        A:D34C
spi_init_clock_high              A:D335
spi_init_mosi_low                A:D347
spi_mode                         S:0068
spi_read_02_done                 A:D389
spi_read_13_done                 A:D3AC
spi_send2                        A:D37A
spi_send3                        A:D38B
spi_send4                        A:D39D
spi_send_bit_done                A:D3AE
spi_send_clock_high_low          A:D375
spi_send_clock_low_high          A:D398
spi_send_clock_pulse_1           A:D368
spi_send_two_bytes               A:D3C6
spi_send_zero                    A:D363
spi_ss_high                      A:D3BE
spi_ss_low                       A:D3B6
spi_transfer                     A:D352
spi_transfer_loop                A:D357
stack_message                    A:C70C
str_compare                      A:81F0
str_compare_done                 A:81FE
str_ic_compare                   A:8201
str_ic_compare_done              A:8223
str_ic_compare_fixed_dest        A:821E
str_ic_compare_fixed_srce        A:8210
str_work                         S:0085
symbol_table_ended_message       A:950D
system_flags                     S:00BE
this_line                        S:00AC
this_line_addr                   S:00AE
timer1_interrupt                 A:C76D
to_line                          S:00A0
to_msg                           A:86BE
token_address                    S:0090
token_digit                      S:009B
token_length                     S:0092
token_line                       A:CC3F
token_line1                      A:CC45
token_line_done                  A:CC8D
token_line_listing               A:CC60
token_line_loop                  A:CC78
token_line_loop1                 A:CC88
token_line_start                 S:009C
token_sign                       S:0097
token_start                      S:008E
token_type                       S:0093
token_value                      S:0094
token_work                       S:0098
too_much_on_line                 A:861D
typing_latency                   S:000D
write_char                       A:CB69
write_char_loop                  A:CB85
write_function                   S:0017
write_to_lcd                     A:CB14
write_to_serial                  A:CB09
write_zero                       A:C788
wtf_loop                         A:9DE4
x_equals_message                 A:C624
y_equals_message                 A:C62C

Symbols by value:
0000 EMULATOR
0000 OPCODE_LOOKUP_OPCODE_LENGTH
0000 PCODE_LIT
0000 REG
0000 SERIAL_DEBUGGING
0000 SRCE
0000 SYMPRV
0000 VALUE
0000 VIA_FLAG_DISABLE
0000 crc_addr
0001 ASS_OPERAND_ABSOLUTE
0001 EFLAG_SHOW_LINE
0001 FFLAG_IGNORE_CASE
0001 FLAG_COMPILING
0001 LCD_SUPPORT
0001 OPCODE_LOOKUP_OPERAND_TYPE
0001 PCODE_STACK
0001 SPI_SS
0001 USE_ASSEMBLER
0001 USE_CP437_FONT
0001 USE_PASCAL
0001 m_upper
0002 ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
0002 EFLAG_ALLOW_ZERO_FROM
0002 FFLAG_GLOBAL
0002 FLAG_ASSEMBLING
0002 OPCODE_LOOKUP_OPCODE_TABLE
0002 PCODE_NEG
0002 REGB
0002 SERIAL_OUT_MASK
0002 SPI_MOSI
0002 SYMLIB
0002 SYMLVL
0002 m_lower
0003 ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
0003 DEST
0003 KEY_ABORT
0003 PCODE_LIB_CALL
0003 REG2
0003 SYMTYP
0003 VALUE2
0003 crc_num
0004 ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
0004 EFLAG_LOAD
0004 FFLAG_QUIET
0004 FLAG_LIST_SOURCE
0004 I2C_SCL
0004 KEY_DEBUG
0004 OPCODE_LOOKUP_HANDLER
0004 PCODE_ADD
0004 SERIAL_DEBUG1_MASK
0004 SPI_MISO
0004 SYMDSP
0004 m_alpha
0005 ASS_OPERAND_ABSOLUTE_INDIRECT
0005 REG2B
0006 ASS_OPERAND_ACCUMULATOR_A
0006 OPCODE_LOOKUP_TABLE_SIZE
0006 PCODE_SUB
0006 REMAIN
0006 SYMARG
0006 SYMSUB
0006 crc_val
0007 ASS_OPERAND_IMMEDIATE
0008 ASS_OPERAND_IMPLIED
0008 BACKSPACE
0008 EFLAG_SAVE
0008 FLAG_VALID_COMPILE
0008 I2C_SDA
0008 PCODE_MUL
0008 SERIAL_DEBUG2_MASK
0008 SPI_SCK
0008 SYMDAT
0008 VIA_FLAG_CB2
0008 m_digit
0009 SYMLEN
0009 random
000A NL
000A PCODE_DIV
000A SYMNAM
000B ASS_OPERAND_ZERO_PAGE
000B PCODE_MOD
000C ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
000C PCODE_ADRNN
000D ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
000D CR
000D typing_latency
000E ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
000E KEY_STOP_TRACE
000E PCODE_ADRAN
000F ASS_OPERAND_ZERO_PAGE_INDIRECT
0010 ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
0010 EFLAG_FIND
0010 FLAG_VALID_ASSEMBLE
0010 PCODE_EQL
0010 SERIAL_SPARE2_MASK
0010 call_a
0010 m_xdigit
0011 ASS_OPERAND_STRING
0011 PCODE_FINISHD
0011 call_x
0012 ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE
0012 PCODE_NEQ
0012 call_y
0013 call_p
0014 KEY_TRACE
0014 PCODE_LSS
0014 call_s
0015 brk_address
0016 PCODE_GEQ
0016 gc_backslash_tokens_length
0017 write_function
0018 PCODE_GTR
0019 LINE_CNT
0019 PCODE_LEQ
001A PCODE_ORR
001B END_EDITOR_INPUT
001B PCODE_AND
001C PCODE_INP
001D LIST
001E PCODE_OUT
001F PCODE_OUTC
0020 EFLAG_REPLACE
0020 FRAME
0020 LCD_RS
0020 MAX_STK
0020 PCODE_EOR
0020 m_space
0021 PCODE_OUH
0022 LEVEL
0022 PCODE_SHL
0022 TOKEN_STRING
0023 PCODE
0023 PCODE_OUS
0023 SERIAL_DELAY2
0024 PCODE_SHR
0025 ACT_PCDA
0025 PCODE_INS
0026 PCODE_INC
0027 DISPL
0027 PCODE_CLL
0027 SINGLE_QUOTE
0028 PCODE_DEC
0029 OFFSET
0029 PCODE_RTN
002A PCODE_MOV
002B OPND
002B PCODE_CLA
002C PCODE_LOD
002E DCODE
002E PCODE_LDA
002F STARTSYM
0030 PCODE_LDI
0030 SERIAL_DELAY1
0031 ENDSYM
0031 T
0032 PCODE_STO
0033 WORKD
0034 PCODE_STA
0035 ERRNO
0036 BSAVE
0036 PCODE_STI
0037 WORK
0038 PCODE_ABSCLL
0039 PRCITM
003A PCODE_XOR
003B BASE
003B PCODE_INT
003C PCODE_JMP
003D DATA
003D PCODE_JMZ
003E PCODE_JM1
003F RUNNING
0040 EFLAG_SUPPRESS_NEWLINE
0040 FLAG_ONLY_ALPHA
0040 FROM
0040 LCD_RW
0040 PCODE_OUTCR
0040 SYMITM
0040 VIA_FLAG_TIMER1
0040 m_cntrl
0041 SYMBOL_ARRAY
0041 TOKEN_ASSIGN
0042 PCODE_LCD_WRITE_NUM
0042 SYNTAX
0043 END_PCD
0043 PCODE_LCD_WRITE_STR
0043 SYMBOL_CONSTANT
0044 PCODE_LCD_WRITE_HEX
0045 PCODE_LAST
0045 PCODE_LCD_WRITE_CHR
0045 TEMP
0045 TOKEN_EQUALITY
0046 SYMBOL_FUNCTION
0047 CALL
0049 DBGFLG
0049 TOKEN_IDENTIFIER
004A DATTYP
004B COUNT1
004C COUNT2
004C TOKEN_SHIFT_LEFT
004D LASTP
004D TOKEN_UNARY_MINUS
004E TOKEN_NUMBER
0050 SYMBOL_PROCEDURE
0051 SYMBOL_LIBRARY_PROCEDURE
0052 RES
0052 SYMBOL_LIBRARY_FUNCTION
0052 TOKEN_SHIFT_RIGHT
0055 TOKEN_NEQ
0056 SYMBOL_VARIABLE
0056 TOKEN_LOW_BYTE
0057 TOKEN_HIGH_BYTE
0058 TOKEN_LOGICAL_AND
0059 SYMBOL_FUNCTION_RETURN
0059 TOKEN_LOGICAL_OR
005A TOKEN_INEQUALITY
005B RMNDR
005C bcd_work
0060 bcd_result
0068 spi_mode
006B ASS_OPERAND
006C OPCODE
006E OPCODE_LEN
006F ASS_EMIT_COUNT
0070 ASS_OPCODE_WORK
0072 ASS_COUNT
0073 ASS_VALUE
0076 ASS_PASS
0077 ass_emit_bytes
0079 exp_value_stack
007B exp_value_stack_count
007C exp_operator_stack_count
007D exp_operator
007E exp_operator_precedence
007F exp_evaluation_function
0080 EFLAG_NO_LINE_NUMBERS
0080 FLAG_BRK_REACHED
0080 LCD_E
0080 TOKEN_LEQ
0080 VIA_FLAG_ENABLE
0080 m_alnum
0081 TOKEN_GEQ
0081 exp_unary_ok
0082 TOKEN_CONST
0082 show_symbols
0083 TOKEN_VAR
0083 ass_current_label
0084 TOKEN_ARRAY
0085 TOKEN_OF
0085 str_work
0086 TOKEN_PROCEDURE
0086 lcd_work
0087 TOKEN_FUNCTION
0087 serial_out_byte
0088 TOKEN_BEGIN
0089 TOKEN_END
0089 serial_out_bit
008A TOKEN_OR
008A serial_in_byte
008B TOKEN_DIV
008B serial_in_byte_received
008C TOKEN_MOD
008C hardware_work
008D TOKEN_AND
008D maths_work
008E TOKEN_SHL
008E token_start
008F TOKEN_SHR
0090 TOKEN_NOT
0090 token_address
0091 TOKEN_MEM
0092 TOKEN_IF
0092 token_length
0093 TOKEN_THEN
0093 token_type
0094 TOKEN_ELSE
0094 token_value
0095 TOKEN_CASE
0096 TOKEN_WHILE
0097 TOKEN_DO
0097 token_sign
0098 TOKEN_REPEAT
0098 token_work
0099 TOKEN_UNTIL
009A TOKEN_FOR
009B TOKEN_TO
009B token_digit
009C TOKEN_DOWNTO
009C token_line_start
009D TOKEN_WRITE
009E TOKEN_READ
009E from_line
009F TOKEN_CALL
00A0 to_line
00A1 TOKEN_CHAR
00A2 TOKEN_MEMC
00A2 current_line
00A4 TOKEN_XOR
00A4 insert_limit
00A6 mem_move_src
00A8 mem_move_dest
00A9 TOKEN_ADDRESS
00AA mem_move_len
00AB TOKEN_CHR
00AC TOKEN_HEX
00AC this_line
00AE this_line_addr
00B0 find_from
00B1 find_to
00B2 find_pos
00B3 find_len
00B4 find_delimiter
00B5 rep_from
00B6 rep_to
00B7 rep_diff
00B9 find_count
00BB found_this_line
00BC editor_flags
00BD find_flags
00BE system_flags
00CF RUNNING_STACK_TOP
00D0 BIT_INTERVAL
00F1 TOKEN_LCDWRITE
00FE TOKEN_INTEGER
00FF NEW_STK
00FF TOKEN_WRITELN
0100 INBUF_SIZE
0200 INBUF
0300 TEXT_START
12C0 BAUD_RATE
3FFF HIGHEST_RAM
3FFF SYMBOL_TABLE_START
7FF0 SPI_PORT
7FF0 VIA_PORTB
7FF1 I2C_PORT
7FF1 VIA_PORTA
7FF2 SPI_DDR
7FF2 VIA_DDRB
7FF3 I2C_DDR
7FF3 VIA_DDRA
7FF4 VIA_T1C_L
7FF5 VIA_T1C_H
7FFB VIA_ACR
7FFC VIA_PCR
7FFD VIA_IFR
7FFE VIA_IER
8000 START_OF_ROM
8006 character_types_table
8106 is_xxx_fail
810A is_xxx_pass
810E isupper
811A islower
8126 isalpha
8132 isdigit
813E isxdigit
814A isspace
8156 iscntrl
8162 isalnum
816E isbinary
8176 isbin
8178 notbin
817A movedown
8186 movedown_loop
8190 movedown2
819C movedown_done
819D movedown1
81A6 moveup
81CE moveup_loop
81D8 moveup3
81E4 moveup_done
81E5 moveup_next
81F0 str_compare
81FE str_compare_done
8201 str_ic_compare
8210 str_ic_compare_fixed_srce
821E str_ic_compare_fixed_dest
8223 str_ic_compare_done
8226 print
8234 print_loop
823E print_done
8245 prompt
8248 bad_command
826B main_start
8272 main_prompt
828C main_loop
82B8 main_loop_not_run
82D6 editor_handlers
838A editor_help_info
851B editor_help
8526 editor_help_loop
8537 editor_help_done
853A editor_default_range
8547 number_expected_message
8558 editor_bad_number
8562 editor_get_number
85A4 editor_get_number_not_identifier
85BA editor_get_number_ok
85CA editor_get_number_done
85CC editor_get_number_none
85CE editor_get_number_end
85DB number_too_large_message
85FA editor_line_number_too_big
8604 number_bad_range_message
8613 editor_bad_range
861D too_much_on_line
8640 editor_check_no_more
8642 editor_check_no_more_loop
8652 editor_check_no_more_failed
865C editor_check_no_more_ok
865D editor_get_range
8693 editor_get_range_hyphen
8698 editor_get_range_number
86AB editor_get_range_done
86AC editor_bad_rangeJ
86AF found_message
86B7 from_msg
86BE to_msg
86C3 bad_delimiter_message
86D2 editor_bad_delimiter
86D6 editor_find_problem
86DC find_string_too_long_message
86FA find_string_too_long
8700 editor_get_delimiter
8718 editor_no_closing_delimiter_message
872E editor_no_closing_delimiter
8734 no_find_message
8749 editor_no_find_string
874F editor_replace
8757 editor_find
875D editor_save
8763 editor_list
8789 editor_list_doing_find
8795 editor_find_bug
879A find_string_too_longJ
879D editor_no_closing_delimiterJ
87A0 editor_list_got_from_point
87A2 editor_find_second_delimiter_loop
87C9 editor_find_third_delimiter_loop
87EF editor_find_get_flags
87F1 editor_flags_loop
880F editor_flags1
8819 editor_flags2
8823 editor_flags3
882D bad_flag_message
883B editor_list_fix_target_string
8843 editor_list_fixup_loop
8853 editor_list_not_find
8856 editor_list_get_on_with_it
8867 editor_list_have_source
886D editor_list_doneJ
8870 editor_list_no_line_numberJ
8873 editor_list_loop
889A editor_list_aborted
88A7 editor_find_or_replacing
88A9 editor_replacement_loop
88AB editor_find_loop
88AF editor_find_inner_loop
88C6 editor_find_case_sensitive
88C7 editor_find_test_character
88D0 editor_find_skip_this
88D4 editor_find_no_match
88EA editor_find_found_it
88F0 editor_find_found_it1
8908 editor_do_the_replace
8915 editor_easy_replace
8919 editor_easy_replace_loop
8926 editor_easy_replace_done
8937 editor_list_not_finding
8944 editor_list_no_line_number
894C editor_newline_processing
8956 editor_list_check_to_line
8966 editor_list_check_to_line_ok
896E editor_list_not_newline
8979 editor_list_skip_newline
897F editor_list_loopJ
8982 editor_list_done
899F editor_list_completely_done
89A2 editor_do_replace
89E4 editor_do_replace_smaller
89E7 editor_do_replace_copy_done
89F0 load_message
8A12 editor_load
8A16 editor_insert
8A30 editor_insert_at_start
8A3E editor_insert_common
8A81 editor_insert_loop
8A92 editor_insert_no_line_number
8AB1 editor_insert_not_newline
8ABA editor_insert_loop1
8ACA editor_insert_backspace
8AD6 editor_insert_backspace_not_at_start
8AEC editor_insert_done
8AFD editor_insert_done_with_newline
8B18 editor_too_full
8B1F editor_too_full_loop
8B30 editor_no_lines
8B43 memory_full
8B5E memory_filled_up
8B87 editor_argument_check
8B89 editor_argument_check_loop
8B99 editor_argument_check_failed
8BA3 editor_argument_check_got_argument
8BA4 editor_delete
8BF2 editor_delete_line_count_loop
8BFE editor_delete_line_count_not_done
8C0A editor_delete_line_count_not_newline
8C12 editor_delete_line_count_done
8C3C lines_deleted_message
8C47 show_current_line_number
8C60 line_number_lt_1000
8C6F line_number_output_spaces
8C7B show_current_line_number_done
8C85 find_line
8C93 find_line_loop
8CA2 find_line_next
8CB0 find_line_same_line
8CB8 find_line_eof
8CB9 find_source_end
8CC1 find_source_end_loop
8CCF find_source_end_wrap
8CD5 find_source_end_done
8CD6 brk_resumed
8CEA editor_memory
8D04 editor_memory_loop
8D25 editor_memory_loop1
8D37 editor_memory_loop2
8D4D editor_memory_loop3
8D5A editor_memory_done
8D5D editor_memory_aborted
8D63 editor_memory_show_ascii
8D68 editor_memory_ascii
8D70 editor_memory_not_control
8D74 editor_memory_show_dot
8D76 editor_memory_not_high
8D8D recover_done
8D93 recover_not_needed
8D9F editor_recover
8DB4 editor_done_message
8DBE editor_recover_not_needed
8DC8 not_assembler_message
8DEE editor_debug
8DF7 editor_not_assembler
8E01 editor_debug_ok
8E0A editor_trace
8E1C editor_info
8E2E editor_compile
8E38 editor_syntax
8E42 editor_run
8E4E show_symbol_table_end
8E60 source_ended_message
8E73 show_source_end
8E88 source_starts_message
8E9B show_source_start
8EAD source_line_count
8EBD show_source_lines
8ECD editor_line_count_loop
8EDB editor_line_count_not_newline
8EE3 editor_line_count_done
8EF1 editor_assemble
8EF7 no_break_message
8F16 editor_resume
8F29 editor_resume_ok
8F44 editor_poke_message
8F6C editor_poke
8F76 editor_poke_loop
8F8D editor_poke_bad_token
8F90 editor_poke_got_number
8F9F editor_poke_not_first
8FA8 editor_poke_got_all_numbers
8FB8 editor_poke_got_enough
8FCB editor_poking_loop
8FD3 editor_poke_another
8FE5 editor_poke_failed_message
9000 editor_poke_to_message
9006 editor_poke_failed
9029 editor_jsr
9033 editor_jsr_got_number
903A editor_jsr_number_in_range
9057 editor_jsr_got_number_execute
905A editor_jmp
9064 editor_jmp_got_number
906B editor_jmp_number_in_range
907B editor_library
9087 editor_library_search
9092 editor_library_make_lower_loop
909E editor_library_no_search
90A6 editor_library_loop
90B4 editor_library_filter_loop
90BF editor_library_filter_reject
90C1 editor_library_filter_reject_loop
90C8 edit_library_continue
90CA editor_library_name_loop
90F3 editor_library_name_onto_next
9104 editor_library_done
9107 handlerLookup
9109 handler_loop
910F handler_find_length
9118 handler_found_length
911C handler_next
912C handler_same_length
9135 handler_found_directive
9145 handlers_done
9147 call_handler
914A partial_handler_Lookup
914C partial_handler_next_item
9154 partial_handler_next_loop
9163 partial_handler_next
916A partial_handler_next_found_item_length
917A partial_handler_found_directive
9181 partial_handler_skipped_string
918E partial_handler_done
918F TKNJMP
9197 JMP1
919F JMP2
91B4 JMP3
91C1 MAKE_UPPER
91CB MAKE_UPPER_DONE
91CC MAKE_LOWER
91D6 MAKE_LOWER_DONE
91D7 gen_random
91F9 gen_random1
91FA crc16
9206 crc16_loop
9213 crc16_next
9219 crc16_skip
9221 crc_done
9222 crc_byte
9252 crc_helper1
9255 crc_message
9268 source_length_message
9278 bytes_message
9280 crc_source
92C8 delay_1ms
92CB delay_1ms_loop
92D2 delay
92DC bcd_unpack
92EF bcd_table
934F display_in_decimal
935B bcd_positive
9362 bcd_skip_zeroes
936D bcd_output_digit
9378 binary_to_decimal
9383 binary_to_decimal_loop
93A8 binary_to_decimal_next
93C6 NOSCE
93D7 INIT
93E3 INIT_SECOND_PASS
9424 INIT9
9425 CROUT
942A COMSTL
9436 COMS9
9437 COMS8
943A DISHX
9440 DISPAD
945B DISPAD2
945C PSHWRK
946E PSH9
946F PULWRK
9482 PRCHAR
9495 prchar_not_control
949A PRBYTE
94A3 PRHEX
94A5 PRHEXZ
94AD PRHEX1
94B0 PUTSP
94B4 PT
94BC PT6
94C6 TKNWRK
94D1 WRKTKN
94DC pcodes_ended_message
94EF compile_finished_message
950D symbol_table_ended_message
9525 no_valid_compile_message
954F PRBYTECR
9555 CHK_VAL
9567 CHK_VAL9
9568 CHK_RUN
9574 run_assembler
9581 call_assembler
958B GETLN1
958B GET_LINE
958D GET1
95AA GET3
95B0 GETLN_OVERFLOW
95B3 COUT
95BD COUT_CALL
95C0 DM7
95DA BELL1
95E4 RUNERR
95F8 EX_FINISHD
960F FIN_MSG
962E ass_error
9635 ass_error1
9638 errors_table
999A assertion_failed_message
99D4 ERRLIT
99E0 ERROR
99E9 ERR7
99F3 ERR1
9A07 ERR3
9A17 ERR5
9A1D ERR6
9A29 error_next
9A2A error_loop
9A2E error_find_next
9A37 error1
9A40 error_not_found
9A58 error_found
9A65 error_not_found_message
9A75 show_current_line
9A97 show_current_line_loop
9AAF show_current_line_loop_print_one_character
9ABA show_current_line_done
9ABE ASSEMBLE
9ACB ASSEMBLE_SECOND_PASS
9AD0 ASSEMBLE_PASS
9AEA ass_finish_line
9AF5 ass_done_jump
9AF8 ass_line
9B07 ass_line1
9B33 ass_bad_identifier
9B38 ass_identifier
9B68 ass_lookup_existing_label
9B72 ass_lookup_save_address
9B7E ass_added_symbol
9B90 ass_not_colon
9B97 ass_not_colon2
9B9F ass_illegal_opcode
9BA7 ass_opcode
9BE8 ass_check_label_changed
9BF8 ass_symbol_address_changed
9BFD ass_opcode2
9C0E ass_finish_lineJ
9C11 ass_operand
9C23 ass_string
9C30 ass_immediate
9C43 ass_indirect
9C4C ass_identifier_operand
9C6D ass_operand_value
9CA5 ass_value_not_indirectJ
9CA8 ass_bad_indirect
9CAD ass_indirect_with_bracket
9CC1 ass_zp_indirect_indexed
9CE2 ass_bad_zp_indirect_indexed
9CE7 ass_not_x_or_y
9CE9 ass_check_we_have_x_or_y
9D05 ass_check_we_have_x_or_y_ok
9D07 ass_value_not_indirect
9D11 ass_value_done
9D1A ass_indexed
9D38 ass_indexed_x
9D41 ass_absolute_another_value
9D50 opcode_lookup
9D62 opcode_lookup_loop
9D6C opcode_lookup_next_table
9D7B opcode_lookup_correct_length
9DA9 opcode_lookup_correct_operand
9DBF opcode_lookup_no_handler
9DC0 opcode_lookup_loop_done
9DE4 wtf_loop
9DF5 opcode_lookup_loop_unknown
9DF8 opcode_lookup_ok
9DF9 ass_done
9E03 ass_done_second_pass
9E1B ass_done1
9E1E ass_done_message
9E3C ass_check_no_more_tokens
9E47 ass_check_no_more_tokens_ok
9E48 exp_push_value
9E4E exp_push_value_memory_full
9E53 exp_push_value_ok
9E62 exp_push_value_not_full
9E73 exp_pop_value
9E7C exp_pop_value_ok
9E9C exp_push_operator
9EA7 exp_push_operator_ok
9EAE exp_pop_operator
9EB7 exp_pop_operator_ok
9EBE exp_get_operator
9EC7 exp_get_operator_ok
9ECC exp_precedence_table
9F2C exp_get_precedence
9F2C exp_precedence_table_end
9F2E exp_get_precedence_loop
9F42 exp_get_precedence_found
9F53 ass_get_value
9F6D ass_expression_loop
9F70 ass_expression_loop_initial
9F74 ass_expression_number
9F87 ass_expression_loop1a
9F99 ass_expression_not_small_string
9F9E ass_expression_loop1
9FB2 ass_label_not_found_yet
9FBA ass_expression_found_value
9FCB ass_expression_loop2
9FDA ass_expression_loop3
9FDE ass_expression_loop3b
9FE9 ass_expression_loop3a
9FEE ass_expression_loop3c
9FF1 ass_expression_loopJ
9FF4 ass_expression_loop4
A002 ass_not_unary_minus
A00C ass_not_unary_less_than
A016 ass_not_unary_greater_than
A02C ass_expression_cannot_be_unary
A03B ass_expression_loop7
A052 ass_expression_loop6
A05A exp_no_operators_left
A063 exp_done
A069 exp_done_error
A06E exp_done_ok
A080 ass_expression_apply_operator
A0A9 ass_expression_unary
A0BC ass_expression_apply_operator_bug
A0C1 ass_evaluate_operator
A0C4 ass_lookup_loop
A0E2 ass_opcode_found
A0E8 ass_emit
A0FC ass_emit2
A10B ass_already_emitted
A116 ass_emit4
A11D ass_emit3
A123 ass_emit1
A126 ass_fixup_bbr_branch
A133 ass_fixup_branch
A14C ass_branch_backwards
A150 ass_branch_ok
A156 ass_branch_out_of_range
A15F ass_emit_zero_page
A16D ass_emit_zero_page_too_high
A172 ass_emit_immediate
A180 ass_emit_immediate_too_high
A185 ass_emit_absolute
A190 OPCODE_LOOKUP_TABLE
A233 DIRECTIVES
A2A6 OPCODE_4_CHAR_BRANCH
A2F7 OPCODE_3_CHAR_BRANCH
A31C OPCODE_3_CHAR_IMPLIED
A399 OPCODE_4_CHAR_ZERO_PAGE
A3EA OPCODE_ASS_OPERAND_ABSOLUTE
A453 OPCODE_ASS_OPERAND_ABSOLUTE_TOKENISED
A456 OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
A45B OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
A4A0 OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X_TOKENISED
A4A3 OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
A4C8 OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y_TOKENISED
A4CB OPCODE_ASS_OPERAND_ACCUMULATOR_A
A4E4 OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT
A4E9 OPCODE_ASS_OPERAND_IMMEDIATE
A51A OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED
A51D OPCODE_ASS_OPERAND_ZERO_PAGE
A57E OPCODE_ASS_OPERAND_ZERO_PAGE_TOKENISED
A581 OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
A5A2 OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT_TOKENISED
A5A5 OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
A5EE OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X_TOKENISED
A5F1 OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
A5FA OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT
A61B OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_TOKENISED
A61E OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
A63F OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y_TOKENISED
A642 asm_do_assert
A651 asm_do_assert_failed
A656 asm_do_constant_expectedJ
A659 asm_do_list
A668 asm_do_nolist
A673 asm_do_nolist_ok
A679 asm_do_list_no_operand
A67D asm_do_list_ok
A693 asm_do_list_not
A697 asm_do_list1
A6A6 asm_do_list_first_pass
A6A7 asm_do_asc
A6B2 asm_do_asc_ok
A6B4 asm_do_asc_loop
A6BD asm_do_asc_next
A6C2 asm_do_string
A6CB asm_do_equ
A6DC asm_do_equ_have_label
A6E8 asm_do_org
A6EE asm_do_constant_expected
A6F3 asm_do_org_ok
A6FC asm_do_dfb
A70A asm_do_dfb_multiple
A717 asm_do_dfb_multiple_loop
A728 asm_do_dfb_multiple_done
A729 asm_do_dfb_too_big
A72E asm_emit_one_byte
A73C asm_do_dfw
A74A asm_do_dfw_multiple
A758 asm_do_dfw_multiple_loop
A769 asm_do_dfw_multiple_done
A76A asm_emit_two_bytes
A779 asm_do_blk
A789 asm_do_blk_loop
A796 asm_do_blk_done
A797 asm_do_reserve
A7AF asm_do_constant_expectedJ2
A7B2 asm_do_sym
A7CB asm_do_sym_done
A7CC info_message
A7D7 list_symbols
A7E6 list_symbols_next
A7F1 list_symbols_check
A800 list_symbols_line
A80C list_symbols_user
A826 list_symbols_name
A837 list_symbols_done
A838 assembler_library_functions_table
ACF8 add_assembler_library_functions
AD00 add_assembler_library_functions_loop
AD10 add_assembler_library_functions_name_loop
AD48 add_assembler_library_functions_done
AD49 exp_add
AD5D exp_subtract
AD73 exp_true
AD7C exp_false
AD83 exp_eql
AD97 exp_neq
ADAB exp_less_than
ADB2 exp_greater_than
ADC1 exp_leq
ADD0 exp_geq
ADD7 exp_bitwise_or
ADEC exp_bitwise_and
AE01 exp_bitwise_xor
AE16 exp_trueJ
AE19 exp_falseJ
AE1C exp_logical_or
AE2B exp_logical_and
AE3D exp_shift_left
AE4C exp_shift_left_loop
AE55 exp_shift_left_done
AE56 exp_shift_right
AE65 exp_shift_right_loop
AE6E exp_shift_right_done
AE6F exp_negate
AE82 exp_not
AE90 exp_unary_minus
AEA4 exp_low_byte
AEA9 exp_high_byte
AEB2 exp_abs_val
AEB6 exp_negate_val
AEC9 exp_abs_val_done
AECA exp_abs_val2
AECE exp_negate_val2
AEE1 exp_abs_val2_done
AEE2 ZERRES
AEEB exp_find_sign
AF03 exp_fix_sign
AF16 exp_fix_sign_done
AF17 exp_multiply
AF1C exp_multiply_loop
AF3D exp_multiply_no_add
AF50 exp_divide
AF60 exp_divide_not_zero
AF6D exp_divide_loop
AF95 exp_divide_subtraction_negative
AF96 exp_divide_subtraction_positive
AFB0 exp_modulo
AFC0 COMPIL
B00E END_CMP
B011 CHKLHP
B018 CHKRHP
B022 GETSUB
B02B CHKLHB
B035 CHKRHB
B03F CONDEC
B06A SYMWRK
B075 WRKSYM
B080 PSHPCODE
B093 GETEXPR
B099 PCD_WRKD
B0A4 WRK_OPND
B0AF WRKD_WRK
B0BA WRK_WRKD
B0C5 GET_COMM
B0CC GET_ITEM
B0D2 VAL_MOVE
B0DB VAL_1
B0E0 VAL_2
B0E9 VAL_3
B0F2 VAL_5
B0FB CHK_STAK
B102 STK_ERR
B102 STK_FULL
B107 CONST
B11E CONST1
B123 CONST3
B128 CONST2
B12C CONST9
B12D VARDEC
B13F SIMEXP
B149 SIM1
B15A SIM3
B16D SIM4
B183 SIM7
B189 SIM5
B18D SIM6
B191 SIM2
B197 SIM8
B19B TERMT1
B1B1 TERM
B1B4 TERM2
B1BE TERM1
B1CD TERM4
B1CF TERM3
B1D5 TERM5
B1D9 TERM6
B1DD TERM7
B1E1 TERM8
B1E5 TERM9
B1E9 TERMT3
B1FF FACTOR
B210 IDENT
B213 IDENT1
B21B IDENT1A
B220 IDENT2
B239 IDENT2A
B240 IDENT3
B24E FACAD1
B256 IDENT5
B258 IDENT5_A
B263 IDENT6
B269 IDENT7
B26C FACAD2
B274 IDENT4
B276 IDENT4_A
B296 FACADR
B2A9 FACSTR
B2AF FACERR1
B2B4 FACNUM
B2BA PAREN
B2C0 FACMEM
B2C6 FACMMC
B2CA FACM2
B2D6 FACNOT
B2DE GENNOP1
B2E1 FACRND1
B2E7 FACTB1
B2ED FACTQT1
B300 EXPRES
B310 EXPTB1
B323 EXPR1
B332 EXPTB3
B345 EXPR2
B347 EXPR8
B34B EXPR3
B34F EXPR4
B353 EXPR5
B357 EXPR6
B35B EXPR7
B35F STMNT
B36C STMNT1
B397 ASSIGN
B39A ASS1
B3A6 ASSTB1
B3BC assign_bad_identifier
B3C1 ASSARR
B3D3 ASSVAR
B3E2 ASS2
B3FE WRITELN
B408 WRITELN9
B40D WRITE
B410 WRIT9
B41F W_STRING
B429 WRIT2
B42C WRIT10
B439 WRIT1
B449 WRIT5
B452 W_CHR
B454 W_CHR1
B45A W_HEX
B45E STMNT_WRITE_LCD
B461 WRITE_LCD9
B470 WRITE_LCD_STRING
B47A WRITE_LCD2
B48A WRITE_LCD1
B49A WRITE_LCD5
B4A3 WRITE_LDC_CHR
B4A5 WRITE_LDC_CHR1
B4AB WRITE_LDC_HEX
B4AF READ
B4B2 READ8
B4B5 READ2
B4CC READ9
B4CF READ11
B4EE READ7
B4F4 READ7_A
B4FE READ3
B512 READ3_B
B52D READ3_A
B53B TWO_OP
B541 ONE_OP2
B544 ONE_OP
B54B GENNOP2
B54E WAIT_1
B558 MEM
B55D MEMC
B560 MEM2
B573 CALLSB
B580 FNCPRC
B58D FNC2
B5B7 FNC3
B5BD FNC1
B5C0 FNC5
B5DD FNC5A
B5DF FNC5B
B601 FNC4
B602 FNC6
B607 IF
B625 IF2
B62C IF1
B647 BEG
B65D REPEAT
B660 REP1
B681 WHILE
B6B3 CASE
B6C1 CASE7
B6C5 CASE2
B6EC CASE1
B6F8 CASE4
B702 CASE3
B735 CASE5
B753 CASE6
B75E CASE9
B768 CASE8
B76E FOR
B778 FOR1
B785 FOR2
B79E FOR3
B7CF FOR4
B812 FOR5
B834 FOR6
B841 CHKGET
B847 WRK_VAL
B852 VAL_WRK
B85D END_WRK
B868 BLCKT1
B86B BLCKT2
B86E BLCKT3
B878 BLOCK
B88F BLK1A
B8A3 BLK1
B8AB BLK2
B8B5 BLK4
B8BF BLKCNS
B8C2 BLKCN1
B8D6 BLKVAR
B8DA BLKVR1
B8DD BLKVR6
B8E7 BLKVR7
B906 BLKVR8
B909 BLKV10
B925 BLKV10_A
B92C BLKV10_B
B93B BLKVR2
B954 BLKV13
B959 BLKVR4
B993 BLKV11
B99A BLKV12
B9A0 BLKVR9
B9B9 BLKVR5
B9FB BLKVR3
BA13 BLKPRC
BA33 BLKFNC
BA55 BLKPR1
BA71 BLKPR3
BA7E BLKPR6
BA87 BLKPR2
BAA8 BLKPR5
BACF BLKPR4
BAFB BLKBEG
BB05 BLKB3
BB0B BLKB1
BB27 BLKB2
BB34 BLKB5
BB43 BLKB4
BB52 BLKB6
BB55 pascal_library_functions_table
BBF5 add_pascal_library_functions
BBFD add_pascal_library_functions_loop
BC0D add_pascal_library_functions_name_loop
BC4E add_pascal_library_functions_done
BC4F library_function_call
BC5C library_function_call_2
BC86 library_function_call_3
BC8B library_function_call_1
BC8E library_function_call_5
BC9F GENNOP
BCB4 GEN1
BCB8 GENADR
BCEB GEN2
BCED GEN2_B
BCF6 GEN2_A
BD08 GEN_FULL
BD0D DISP9
BD0D GEN2_C
BD0E GENRJMP
BD20 GENNJP
BD22 GENNJM
BD28 GENJMP
BD51 GEN3
BD56 FIXAD
BD93 FIXAD1
BD94 FIXM1
BD9D FIXM2
BDA9 execution_address_table
BE35 DM1
BE3E DM2
BE47 DB11
BE47 DEBUG
BEAF DEBUG_DONE
BEB0 INTERP
BED6 DM5
BEEB DM6
BEF6 display_x_characters
BEFD DIS5
BF07 DIS5_A
BF14 CHK_KBD
BF20 CHK_NOTN
BF2E CHK_NOTT
BF3C CHK_NOTD
BF3E EX_OUTCR
BF44 LOWLIT
BF4A LOWLIT1
BF50 MAINP
BF53 MAIN
BF5A MAIN_2
BF65 MAIN_NOT_ABORT
BF68 MAIN_OK
BF82 MAIN_1
BF91 EX_INVINS
BF95 NOTIM1
BFA2 GETADR
BFAC GET2
BFCD GETADR1
BFE8 GET1_A
BFE9 PULTOP
C004 PUL_END
C00B PULBOTH
C00E PULTOP2
C029 PUL2_END
C030 PSHTOP
C03B PSH1
C04C GETLIT
C062 GET_END
C063 EX_LIT
C072 LIT1
C075 EX_NEG
C07E EX_ADD
C087 EX_SUB
C093 EX_MUL
C09C EX_GETKEY
C0A3 EX_MOD
C0B7 EX_DIVIDE_BY_ZERO
C0BE DIVBY0
C0CE EX_DIV
C0E2 EX_ABS
C0EB EX_EQL
C0F4 TRUE
C0F6 TRUE2
C101 FALSE
C105 EX_NEQ
C10E EX_LSS
C11A EX_GTR
C126 EX_GEQ
C132 EX_LEQ
C13E EX_XOR
C147 EX_ORR
C150 EX_AND
C159 EX_EOR
C162 EX_SHL
C16E EX_SHR
C17A EX_INC
C192 EX_DEC
C1AA EX_MOV
C1BB EX_LODC
C1BE EX_LOD3
C1C0 EX_LOD3_A
C1CD EX_LOD
C1D0 EX_LOD2
C1E3 EX_LDAC
C1EE EX_LDA
C1F8 GETIDC
C201 GETIDX
C215 GETID2
C223 EX_LDIC
C229 EX_LDI
C22F EX_STOC
C237 EX_STO5
C23C EX_STO
C242 EX_STO2
C24F EX_STA
C260 EX_STA5
C265 EX_STAC
C26E EX_STIC
C27C EX_STI
C297 EX_RTN
C2D0 EX_INP
C2E1 EX_INP_OK
C2F8 INP3
C308 BAD_INP
C310 EX_OUT
C315 EX_LCD_WRITE_NUM
C318 OUT_COMMON
C324 EX_OUH
C329 EX_LCD_WRITE_HEX
C32C EX_OUH_COMMON
C344 EX_OUS
C349 EX_LCD_WRITE_STR
C34C EX_OUS_COMMON
C368 EX_OUS1
C377 EX_ABSCLL
C37E EX_CLL
C386 EX_CLL_A
C3A4 EX_CLL4
C3A8 EX_CLL2
C3C9 EX_CLL3
C40A EX_CLL5
C40D EX_CLA
C42A EX_CLL_JMP
C42D EX_INT
C444 INT_ERR
C44B INT_ERRM
C457 EX_NEW_STACK
C469 EX_JMP
C47C EX_JMZ
C487 EX_NOJUMP
C48D EX_JM1
C498 EX_INPC
C4A2 EX_INPC_OK
C4B2 EX_OUTC
C4B7 EX_LCD_WRITE_CHR
C4BA EX_OUTC_COMMON
C4C8 EX_LCDHOME
C4CE EX_LCDCLEAR
C4D4 EX_INS
C4DE EX_INS3
C4F7 EX_INS1
C500 EX_INS2
C50A EX_INS4
C517 execution_aborted_message
C52B ex_input_aborted
C532 EX_ADRNC
C535 EX_ADRNC2
C542 EX_ADRNN
C545 EX_ADRN2
C550 EX_ADRAN
C556 EX_ADRAC
C55C EX_DIGITALREAD
C567 EX_DIGITALREAD_ONE
C56A EX_LCDPOS
C57A EX_LCDPOS_1
C584 EX_RANDOM
C596 EX_LATENCY
C5A5 EX_DELAY
C5B5 EX_RANDOMSEED
C5C5 EX_PINMODE
C5D4 EX_DIGITALWRITE
C5E3 EX_LIB_CALL
C5E9 EX_ASSERT
C5FE EX_ASSERT_OK
C601 break_message
C61C a_equals_message
C624 x_equals_message
C62C y_equals_message
C634 p_equals_message
C63C s_equals_message
C644 id_equals_message
C64D brk_executed
C6CB brk_executed1
C6D8 brk_executed2
C6E8 brk_executed3
C702 brk_executed4
C70C stack_message
C714 brk_executedJ
C717 irq
C724 irq1
C73C cb2_interrupt
C748 serial_in_loop
C76D timer1_interrupt
C788 write_zero
C78D serial_send_count_bits
C79C irq_done
C79F lcd_initialise
C7F8 lcd_prepare_to_read_register
C80B lcd_prepare_to_write_data
C820 lcd_prepare_to_write_instruction
C833 lcd_set_enable
C83C lcd_clear_enable
C845 lcd_read_instruction_nibble
C851 lcd_wait
C859 lcdbusy
C868 lcd_wait_timeout
C86C lcd_get_address
C880 lcd_write_instruction_nibble
C88C lcd_instruction
C89F lcd_data_nibble
C8AE lcd_print_char
C8B9 lcd_print_not_newline
C8C8 lcd_print_char_on_2nd_line
C8CF lcd_print_char_newline
C8CF lcd_print_char_ok
C8E0 lcd_clear_display
C8E8 lcd_second_line
C8F0 lcd_home
C8F8 lcd_print_message
C901 lcd_print
C90B lcd_print_done
C90C SEARCH
C914 SEA_NEXT
C91F SEA1
C92C SEA2
C975 SEA4
C97D SEA5
C980 SEA3
C983 SYM_FULL
C988 ADDSYM
C9BD ADDSYM_NOT_FULL
C9E4 ADD1
CA07 ADD4
CA23 ADD9
CA24 LOOKUP
CA2E LOOK1
CA2F CHKDUP
CA3E DUP9
CA3F GET_OFF
CA5B GETO_1
CA68 GETO_2
CA6A GET_LEV
CA74 GET_DAT
CA7B pin_number_to_mask
CA81 pin_number_to_mask_loop
CA89 pin_number_to_mask_done
CA8E pinmode
CA9F pinmode_B
CAA7 pinmode_C
CAB5 pinmode_OUTPUT
CABD digitalwrite
CACE digitalwrite_B
CAD6 digitalwrite_C
CAE4 digitalwrite_ONE
CAEC digitalread
CAFB digitalread_B
CB03 digitalread_C
CB09 write_to_serial
CB14 write_to_lcd
CB1F CHRIN
CB1F GETIN
CB29 GETIN1
CB30 serial_available
CB33 EMULATOR_DEBUG
CB34 START_TRACE
CB35 STOP_TRACE
CB36 hardware_init
CB69 write_char
CB85 write_char_loop
CB8E serial_print_message
CB94 serial_print
CB9E serial_print_done
CB9F get_token
CBA3 get_token_loop
CBAD gc_skip_spaces
CBC2 gc_newline
CBCF gc_newline1
CBDC gc_newline_assembling
CBE1 gc_single_byte_already_known
CBE3 gc_single_byte_token
CBE5 gc_done
CBFD gc_not_space
CC02 gc_alpha_loop
CC0A gc_alpha_ok
CC1B gc_alpha_done
CC1F gc_alpha_alpha_only
CC28 gc_not_alpha
CC34 gc_not_digit
CC3F token_line
CC45 token_line1
CC60 token_line_listing
CC78 token_line_loop
CC88 token_line_loop1
CC8D token_line_done
CC8E atoi
CC97 atoi_loop
CCA6 atoi_positive
CCA8 atoi_more
CCFD atoi_error
CD03 atoi_not_running
CD08 negate_token_value
CD1C gtoken_table
CD4D gtoken_directive_table
CD5A gc_single_byte_tokenJ
CD5D gc_single_byte_already_knownJ
CD60 gc_lh_brace
CD64 gc_lh_paren
CD72 gc_pascal_comment
CD91 gc_pascal_comment_find_end
CD9C gc_comment_not_eof
CDA5 gc_comment_not_newline
CDB4 gc_comment_keep_looking
CDBC gc_comment_found_end
CDCC gc_directive_symbols
CDD8 gc_directive_symbols_ok
CDFF gc_directive_symbols_too_late
CE04 gc_directive_list
CE0B gc_directive_pcodes
CE11 gc_directive_nolist
CE1A gc_semicolon
CE23 gc_assembler_comment_find_end
CE2E gc_assembler_comment_not_eof
CE35 gc_assembler_comment_keep_looking
CE3D gc_backslash_tokens
CE53 gc_backslash_tokens_end
CE53 gc_quote
CE61 gc_quote_loop
CE6A gc_quote_bad
CE6F gc_quote_loop_not_end_of_line
CE84 gc_quote_long_string
CE8F gc_quote_copied_value
CE98 gc_quote_done
CEAA gc_quote_not_finished
CEBC gc_quote_backslash_loop
CEC7 gc_quote_bad_string
CECC gc_quote_hex_character_done
CED0 gc_quote_found_backslash_character
CED4 gc_quote_not_backslash
CEE0 gc_quote_too_long
CEE5 gc_fix_hex
CEEE gc_fix_hex_not_a_to_f
CEF2 gc_quote_hex_character
CF1E gc_quote_hex_character_one_only
CF21 gc_dollar
CF2D gc_hex_literal
CF36 gc_hex_loop
CF71 gc_hex_done
CF76 gc_hex_too_big
CF7B gc_percent
CF87 gc_binary_literal
CF8F gc_binary_loop
CFA5 gc_colon
CFB0 gc_assign
CFB6 gc_less_than
CFCA gc_leq
CFCF gc_neq
CFD4 gc_shift_left
CFD9 gc_greater_than
CFE6 gc_single_byte_already_knownJ2
CFE9 gc_geq
CFEE gc_shift_right
CFF3 gc_minus
CFF5 gc_plus
D014 gc_ampersand
D01F gc_logical_and
D025 gc_bar
D030 gc_logical_or
D036 gc_equals
D041 gc_equality
D047 gc_bang
D052 gc_inequality
D058 RSVWRD
D14B RSVEND
D14D pas_get_token
D156 pas_get_token_eof
D157 pas_gc_identifier
D15F pas_gc_loop
D168 pas_gc_more
D190 pas_gc_no_match
D1A1 GETCHK
D1AC CHKNOK
D1AF CHKOK
D1B1 CHKTKN
D1B6 GET_LOOK
D1C0 i2c_init
D1CB i2c_delay
D1CF i2c_toggle_clock
D1D7 i2c_toggle_clock_wait
D1EA i2c_begin_transmission
D1EE i2c_begin_transmission_loop
D211 i2c_write
D214 i2c_write_loop
D220 i2c_write_one
D22B i2c_write_clock
D23B i2c_write_clock_wait
D253 i2c_write_lost_arbitration
D255 i2c_write_got_ack
D257 i2c_read
D260 i2c_read_loop
D275 i2c_read_zero
D279 i2c_read_next
D28F i2c_read_nak
D294 i2c_read_ack_or_nak
D299 i2c_read_ack_or_nak_wait
D2AB i2c_read_done
D2AD i2c_end_transmission
D2C6 i2c_send
D2CE i2c_send_loop
D2E5 i2c_send_done
D2EA i2c_send_fail
D2EF i2c_receive
D2FD i2c_receive_loop
D312 i2c_receive_done
D317 i2c_receive_fail
D31C spi_init
D335 spi_init_clock_high
D33A spi_init2
D347 spi_init_mosi_low
D34C spi_init3
D352 spi_transfer
D357 spi_transfer_loop
D363 spi_send_zero
D368 spi_send_clock_pulse_1
D375 spi_send_clock_high_low
D37A spi_send2
D389 spi_read_02_done
D38B spi_send3
D398 spi_send_clock_low_high
D39D spi_send4
D3AC spi_read_13_done
D3AE spi_send_bit_done
D3B6 spi_ss_low
D3BE spi_ss_high
D3C6 spi_send_two_bytes
D3D6 cp437_font
DBD6 introduction
DC21 LCD_welcome
DC40 running_message
DC49 START
DC65 RESTART
DC7E end_of_rom_routines
4240 CLOCK_RATE
