Sections:
00: "seg8000" (8000-CF6E)
01: "segfffa" (FFFA-0)


Source: "gpascal.asm"
                        	     1: ;***********************************************
                        	     2: ; G-PASCAL COMPILER
                        	     3: ; for Ben Eater's breadboard computer
                        	     4: ;
                        	     5: ; Author: Nick Gammon
                        	     6: ; Date: 20 January 2022
                        	     7: ;
                        	     8: ; To compile:
                        	     9: ;
                        	    10: ;  vasm6502_oldstyle gpascal.asm -wdc02 -esc -Fbin -o gpascal.bin -dotdir -L gpascal.list
                        	    11: ;
                        	    12: ; To program EEPROM:
                        	    13: ;
                        	    14: ;  minipro -p AT28C256 -w gpascal.bin
                        	    15: ;
                        	    16: ;
                        	    17: ;
                        	    18: ; To communicate, I suggest: miniterm /dev/ttyUSB0 4800 -e
                        	    19: ;
                        	    20: ;   Miniterm: Ctrl+]        : to exit.
                        	    21: ;             Ctrl+T Ctrl+H : help
                        	    22: ;             Ctrl+T Ctrl+E : toggle local echo
                        	    23: ;
                        	    24: ;
                        	    25: ;  Copyright 2022 by Nick Gammon
                        	    26: ;
                        	    27: ;  Permission is hereby granted, free of charge, to any person obtaining a copy
                        	    28: ;  of this software and associated documentation files (the "Software"), to deal
                        	    29: ;  in the Software without restriction, including without limitation the rights
                        	    30: ;  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                        	    31: ;  copies of the Software, and to permit persons to whom the Software is
                        	    32: ;  furnished to do so, subject to the following conditions:
                        	    33: ;
                        	    34: ;  The above copyright notice and this permission notice shall be included in all
                        	    35: ;  copies or substantial portions of the Software.
                        	    36: ;
                        	    37: ;  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                        	    38: ;  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                        	    39: ;  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                        	    40: ;  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                        	    41: ;  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                        	    42: ;  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
                        	    43: ;  SOFTWARE.
                        	    44: ;
                        	    45: ;***********************************************
                        	    46: ;
                        	    47: 
                        	    48: ; Note: BCC == BLT and BCS == BGE
                        	    49: ;
                        	    50: 
                        	    51: ;
                        	    52: ;  CONDITIONAL COMPILES
                        	    53: ;
                        	    54: EMULATOR = 0          ; for testing on a PC running an emulator
                        	    55: LCD_SUPPORT = 1       ; 1 = support LCD, 0 = not. Unset if you have removed the LCD.
                        	    56: SERIAL_DEBUGGING = 0  ; if set, toggle VIA PA2 when reading a bit, and PA3 when writing a bit
                        	    57: 
                        	    58: ;
                        	    59: ;  CONFIGURATION
                        	    60: ;
                        	    61: CLOCK_RATE   = 1000000   ; 1 Mhz
                        	    62: START_OF_ROM = $8000     ; where the ROM chip starts
                        	    63: HIGHEST_RAM = $3FFF      ; original board hardware
                        	    64: ;HIGHEST_RAM  = $5FFF    ; with suggested additional AND gate
                        	    65: 
                        	    66: ;
                        	    67: ;  serial output
                        	    68: ;
                        	    69: BAUD_RATE    = 4800         ; baud
                        	    70: BIT_INTERVAL = CLOCK_RATE / BAUD_RATE ; time between bits in Âµs
                        	    71: 
                        	    72: ;
                        	    73: ;  serial input - input commences on the interrupt generated by the falling edge
                        	    74: ;    of the start bit. Bits are then clocked in with a timed loop.
                        	    75: ;  - these delays can be tweaked if you believe the serial input is not being
                        	    76: ;    sampled at the right moment, confirm by turning SERIAL_DEBUGGING on
                        	    77: ;    and checking the debugging pulses compared to the middle of the bit times
                        	    78: ;    with an oscilloscope or logic analyser
                        	    79: ;
                        	    80: SERIAL_DELAY1 = 32    ; initial delay (count) - lower because of the initial overhead
                        	    81: SERIAL_DELAY2 = 35    ; subsequent delays between bits (count)
                        	    82: 
                        	    83: SYMBOL_TABLE_START = HIGHEST_RAM  ; symbol table pointer (ENDSYM) is decremented before being used
                        	    84: 
                        	    85: STACK            =  $100  ; hardware stack address
                        	    86: SPACE            =  $20   ; uh-huh
                        	    87: SINGLE_QUOTE     =  $27
                        	    88: NL               =  $0A   ; newline
                        	    89: CR               =  $0D   ; carriage-return
                        	    90: BACKSPACE        =  $08   ; backspace
                        	    91: 
                        	    92: MAX_STK          =  32
                        	    93: NEW_STK          =  $FF
                        	    94: 
                        	    95:     .if EMULATOR
                        	    96: END_EDITOR_INPUT =  '`'   ; backtick terminates input
                        	    97:     .else
                        	    98: END_EDITOR_INPUT =  $1B   ; Esc terminates editor input
                        	    99:     .endif
                        	   100: 
                        	   101: KEY_DEBUG      = 'D'-$40   ; Ctrl+D start debugging
                        	   102: KEY_TRACE      = 'T'-$40   ; Ctrl+T start tracing
                        	   103: KEY_STOP_TRACE = 'N'-$40   ; Ctrl+N stop tracing
                        	   104: KEY_ABORT      = 'C'-$40   ; Ctrl+C abort execution
                        	   105: 
                        	   106: 
                        	   107:   .if LCD_SUPPORT
                        	   108: ;
                        	   109: ;  Pins connected from the VIA to the LCD
                        	   110: ;
                        	   111: LCD_RS             = %00100000  ; PA 5 - 0 = instruction, 1 = data
                        	   112: LCD_RW             = %01000000  ; PA 6 - 0 = write, 1 = read
                        	   113: LCD_E              = %10000000  ; PA 7 - toggle (0 -> 1 -> 0) to clock out a command or data
                        	   114:   .endif
                        	   115: 
                        	   116:   .include "zp_variables.inc"

Source: "zp_variables.inc"
                        	     1: ;***********************************************
                        	     2: ;
                        	     3: ; Zero-page variables (currently 64 (decimal) bytes are free for your use).
                        	     4: ;  I suggest using the high ones and working down in case there is a change to the code.
                        	     5: ;  For example, start with 0xFF, then 0xFE and so on.
                        	     6: ;
                        	     7: ;***********************************************
                        	     8: 
                        	     9:   .dsect
                        	    10: 
                        	    11: 
                        	    12: ;
                        	    13: ;  General work-areas for arithmetic routines (eg. add, subtract, divide, multiply)
                        	    14: ;   3-byte signed numbers: -8388608 to +8388607
                        	    15: ;
00:0000 00              	    16: VALUE    reserve 3    ; the current value of the token (ie. if a number)
00:0001 *
00:0003 00              	    17: VALUE2   reserve 3    ; used by the assembler expression evaluator
00:0004 *
                        	    18: 
                        	    19: ; SRCE and DEST used in compiler and editor, particularly for string comparisons
                        	    20: ;   (re-using VALUE and VALUE2)
                        	    21: 
                        	    22: SRCE     =  VALUE
                        	    23: DEST     =  VALUE2
                        	    24: 
00:0006 00              	    25: REMAIN   reserve 3    ; division remainder
00:0007 *
                        	    26: 
                        	    27: ;
                        	    28: ;  work "register" - re-using VALUE and VALUE2 again
                        	    29: ;
                        	    30: REG   = VALUE
                        	    31: REGB  = VALUE+2
                        	    32: REG2  = VALUE2
                        	    33: REG2B = VALUE2+2
                        	    34: 
                        	    35: ;
                        	    36: ;  re-using above for CRC-16 calculations
                        	    37: ;
                        	    38: crc_addr = VALUE      ; the address to take a CRC of (2 bytes)
                        	    39: crc_num  = VALUE2     ; the number of bytes to take a CRC of (2 bytes)
                        	    40: crc_val  = REMAIN     ; the current CRC value (2 bytes)
                        	    41: 
                        	    42: ;
                        	    43: ;  current random number - change this to reseed it
                        	    44: ;
00:0009 00              	    45: random         reserve 4 ; 32-bit random number
00:000A *
00:000D 00              	    46: typing_latency reserve 3 ; incremented while waiting for input
00:000E *
                        	    47: 
                        	    48: ;
                        	    49: ;  Used for seeding registers when calling machine code from Pascal
                        	    50: ;
00:0010 00              	    51: call_a reserve 1      ; used when doing a machine code call:  A register
00:0011 00              	    52: call_x reserve 1      ;  ditto: X register
00:0012 00              	    53: call_y reserve 1      ;  ditto: Y register
00:0013 00              	    54: call_p reserve 1      ;  ditto: status register
00:0014 00              	    55: call_s reserve 1      ; stack register, used by BRK
00:0015 00              	    56: brk_address reserve 2 ; BRK address
00:0016 *
                        	    57: 
                        	    58: ;
                        	    59: ;  address of write function (2 bytes)
                        	    60: ;
                        	    61: ;  This is called by "character out" function COUT. It writes the character in "A" to
                        	    62: ;   serial port or LCD. You could conceivably put another function address here if
                        	    63: ;   you wanted to capture output (eg. from calling DISP_BIN) and putting it somewhere else
                        	    64: ;   like into a series of memory locations, or to output to SPI.
                        	    65: ;  The functions write_to_serial and write_to_lcd
                        	    66: ;   put the appropriate outputting functions into this location.
                        	    67: ;
00:0017 00              	    68: write_function reserve 2  ; address of function to write to serial or LCD
00:0018 *
                        	    69: 
                        	    70: 
00:0019 00              	    71: LINE_CNT  reserve 2   ; line counter during compile
00:001A *
                        	    72: LINE_NO  =  LINE_CNT
                        	    73: 
00:001B 00              	    74: WX       reserve 2    ; 2-byte address used during compilation (reserved word lookup)
00:001C *
00:001D 00              	    75: LIST     reserve 1    ; 0 = no listing, 1 = list source during compile
00:001E 00              	    76: DIGIT    reserve 1    ; used only in GET_NUM to process a decimal number
00:001F 00              	    77: SIGN     reserve 1    ; used in compiling and inputting a number - is there a minus sign?
                        	    78: 
00:0020 00              	    79: FRAME    reserve 2    ; stack frame number - not totally certain but it used for procedure calls at runtime
00:0021 *
00:0022 00              	    80: LEVEL    reserve 1    ; current nested procedure/function level (how far we are nested)
00:0023 00              	    81: PCODE    reserve 2    ; current P-code address (increments during compile and running)
00:0024 *
                        	    82: PNTR     =  PCODE     ; 2-byte work pointer used in editor (eg. in find/replace etc.)
00:0025 00              	    83: ACT_PCDA reserve 2    ; start of P-codes (after source) - does not increment
00:0026 *
00:0027 00              	    84: DISPL    reserve 2    ; level? ahhh ... I don't know
00:0028 *
00:0029 00              	    85: OFFSET   reserve 2    ; variable offset? maybe just a work area
00:002A *
00:002B 00              	    86: OPND     reserve 3    ; jump operand ... not sure
00:002C *
00:002E 00              	    87: DCODE    reserve 1     ; 0 = no display, 1 = display P-codes during compile
00:002F 00              	    88: STARTSYM reserve 2    ; start of symbol table
00:0030 *
00:0031 00              	    89: ENDSYM   reserve 2    ; end of symbol table - used for reverse searching symbols
00:0032 *
                        	    90: T        =  ENDSYM     ; stack pointer 2 bytes
00:0033 00              	    91: WORKD    reserve 2    ; work area for holding P-code address
00:0034 *
00:0035 00              	    92: ERRNO    reserve 1    ; current error number, if ERROR called
00:0036 00              	    93: BSAVE    reserve 1    ; seems to be used to save "A" register, lol
00:0037 00              	    94: WORK     reserve 2    ; work area, used for pushing 2-bytes onto the (processor) stack
00:0038 *
00:0039 00              	    95: PRCITM   reserve 2    ; seems to hold the current procedure/function symbol
00:003A *
00:003B 00              	    96: BASE     reserve 2    ; the base interpreter stack frame (for this procedure)
00:003C *
                        	    97: TO       =  BASE      ; Used in editor (from/to list ranges, and copying text)
00:003D 00              	    98: DATA     reserve 2    ; 2-byte address work-area for calculating the address of a variable at runtime
00:003E *
00:003F 00              	    99: RUNNING  reserve 1    ; 0x40 - in editor, 0x80 - executing - affects stuff like numeric conversion
00:0040 00              	   100: SYMITM   reserve 2    ; current symbol table item (found by searching)
00:0041 *
                        	   101: FROM     =  SYMITM    ; Used in editor (from/to list ranges, and copying text)
00:0042 00              	   102: SYNTAX   reserve 1    ; 0 = full compile, 1 = syntax-only compile (no writing to memory)
00:0043 00              	   103: END_PCD  reserve 2    ; where the P-codes ended after a compile
00:0044 *
00:0045 00              	   104: TEMP     reserve 2    ; temporary work area?
00:0046 *
00:0047 00              	   105: CALL     reserve 2    ; the procedure address we are calling
00:0048 *
00:0049 00              	   106: DBGFLG   reserve 1    ; 0 = not debugging, 1 = debugging, $80 = tracing
00:004A 00              	   107: DATTYP   reserve 1    ; 0 for integers and 1 for characters
00:004B 00              	   108: COUNT1   reserve 1    ; work counter
00:004C 00              	   109: COUNT2   reserve 1    ; and another
00:004D 00              	   110: LASTP    reserve 2    ; 2-byte last P-code address executed at runtime (start of this P-code)
00:004E *
00:004F 00              	   111: IO_A     reserve 1    ; dunno
00:0050 00              	   112: IO_Y     reserve 1    ; seems to be used to save and restore Y
00:0051 00              	   113: IO_X     reserve 1    ;  ditto for X
00:0052 00              	   114: RES      reserve 3    ; multiplication result
00:0053 *
00:0055 00              	   115: MCAND    reserve 3    ; multiplicand
00:0056 *
                        	   116: DIVISOR  = MCAND      ; divisor for division (shares with multiplicand for multiplication)
00:0058 00              	   117: DVDN     reserve 3    ; dividend
00:0059 *
00:005B 00              	   118: RMNDR    reserve 1    ; for division, 0 if positive, 0x80 if negative
00:005C 00              	   119: bcd_work    reserve 4    ; work area for converting binary to decimal (packed)
00:005D *
00:0060 00              	   120: bcd_result  reserve 8    ; work area for turning numbers into printable (unpacked)
00:0061 *
00:0068 00              	   121: QT_TGL   reserve 1    ; quote toggle
00:0069 00              	   122: QUOT_SYM reserve 1     ; current quote symbol
00:006A 00              	   123: QT_SIZE  reserve 1    ; number of characters in reserved words
00:006B 00              	   124: ASS_OPERAND reserve 1 ; assembler operand type = see defines below
00:006C 00              	   125: OPCODE   reserve 2    ; address of opcode in assembler
00:006D *
00:006E 00              	   126: OPCODE_LEN reserve 1  ; length of opcode
00:006F 00              	   127: ASS_EMIT_COUNT reserve 1 ; number of bytes emitted on this line
00:0070 00              	   128: ASS_OPCODE_WORK reserve 2; for opcode lookups
00:0071 *
00:0072 00              	   129: ASS_COUNT reserve 1 ; for counting opcode matches
00:0073 00              	   130: ASS_VALUE reserve 3 ; the assembler operand (address or immediate) will be here
00:0074 *
00:0076 00              	   131: ASS_PASS  reserve 1 ; which assembler pass we are up to
00:0077 00              	   132: ass_emit_bytes reserve 2 ; how many bytes the assembler emitted altogether
00:0078 *
00:0079 00              	   133: exp_value_stack reserve 2  ; address of assembler value stack
00:007A *
00:007B 00              	   134: exp_value_stack_count reserve 1 ; how far through value stack we are (0 = empty)
00:007C 00              	   135: exp_operator_stack_count reserve 1 ;  how far through operator stack we are (0 = empty)
00:007D 00              	   136: exp_operator reserve 1  ; current operator for expression evaluation
00:007E 00              	   137: exp_operator_precedence reserve 1 ; current operator precedence
00:007F 00              	   138: exp_evaluation_function reserve 2 ; function to evaluate an expression
00:0080 *
00:0081 00              	   139: exp_unary_ok reserve 1  ; true if the next token can be a unary operator (like: - < >)
00:0082 00              	   140: show_symbols reserve 1  ; true to list the symbol table after an assemble
00:0083 00              	   141: ass_current_label reserve 2 ; current symbol table address of the label on this line
00:0084 *
00:0085 00              	   142: str_work reserve 1      ; work byte for string compares
                        	   143:   .if LCD_SUPPORT
00:0086 00              	   144: lcd_work  reserve 1 ; used by the LCD routines
                        	   145:   .endif
                        	   146: 
                        	   147: ;
                        	   148: ;  serial work
                        	   149: ;
00:0087 00              	   150: serial_out_byte reserve 2 ; current byte we are sending
00:0088 *
00:0089 00              	   151: serial_out_bit  reserve 1 ; current bit count
00:008A 00              	   152: serial_in_byte  reserve 1 ; current byte we are receiving
00:008B 00              	   153: serial_in_byte_received  reserve 1 ; last received byte
                        	   154: 
                        	   155: ;
                        	   156: ; hardware
                        	   157: ;
00:008C 00              	   158: hardware_work  reserve 1  ; work for use during interpreting
                        	   159: 
                        	   160: ;
                        	   161: ; maths
                        	   162: ;
00:008D 00              	   163: maths_work  reserve 1 ; work for multiply/divide
                        	   164: ;
                        	   165: ;  for get_token
                        	   166: ;
00:008E 00              	   167: token_start      reserve 2  ; where to start looking for a token
00:008F *
00:0090 00              	   168: token_address    reserve 2  ; where the token actually started
00:0091 *
00:0092 00              	   169: token_length     reserve 1  ; length of the token
00:0093 00              	   170: token_type       reserve 1  ; what type of token it is
00:0094 00              	   171: token_value      reserve 3  ; the value of numeric tokens
00:0095 *
00:0097 00              	   172: token_sign       reserve 1  ; non-zero if negative value
00:0098 00              	   173: token_work       reserve 3  ; temporary work area - also used by handlerLookup
00:0099 *
00:009B 00              	   174: token_digit      reserve 1  ; used by get_token
00:009C 00              	   175: token_line_start reserve 2  ; where the current line starts
00:009D *
                        	   176: 
                        	   177: ;
                        	   178: ;  for editor
                        	   179: ;
00:009E 00              	   180: from_line       reserve 2     ; list, delete, modify: FROM line number
00:009F *
00:00A0 00              	   181: to_line         reserve 2     ; list, delete, modify: TO line number
00:00A1 *
00:00A2 00              	   182: current_line    reserve 2     ; current editor line number
00:00A3 *
00:00A4 00              	   183: insert_limit    reserve 2     ; maximum we can input to
00:00A5 *
00:00A6 00              	   184: mem_move_src    reserve 2     ; for copying memory - source of move
00:00A7 *
00:00A8 00              	   185: mem_move_dest   reserve 2     ; for copying memory - destination of move
00:00A9 *
00:00AA 00              	   186: mem_move_len    reserve 2     ; for copying memory - length of move
00:00AB *
00:00AC 00              	   187: this_line       reserve 2     ; which line we are searching for
00:00AD *
00:00AE 00              	   188: this_line_addr  reserve 2     ; address of the "this" line
00:00AF *
00:00B0 00              	   189: find_from       reserve 1     ; editor find: from offset in INBUF (start of target string)
00:00B1 00              	   190: find_to         reserve 1     ; editor find: to offset in INBUF (end of target string)
00:00B2 00              	   191: find_pos        reserve 1     ; which offset in the current line we are currently searching from
00:00B3 00              	   192: find_len        reserve 1     ; the length of the find text
00:00B4 00              	   193: find_delimiter  reserve 1     ; the find/replace delimiter
00:00B5 00              	   194: rep_from        reserve 1     ; editor replace: start of replacement string
00:00B6 00              	   195: rep_to          reserve 1     ; editor replace: end of replacement string
00:00B7 00              	   196: rep_diff        reserve 2     ; difference in find/replace string lengths (signed 2 bytes)
00:00B8 *
00:00B9 00              	   197: find_count      reserve 2     ; count of find/replace
00:00BA *
00:00BB 00              	   198: found_this_line reserve 1     ; did we find something on this line?
                        	   199: insert_last_char = find_from  ; the last character we inserted in INSERT/LOAD mode
                        	   200: 
00:00BC 00              	   201: editor_flags    reserve 1     ; various flags, see below
                        	   202: 
                        	   203: EFLAG_SHOW_LINE        = %00000001    ; set after receiving a newline, so we display the next line
                        	   204: EFLAG_ALLOW_ZERO_FROM  = %00000010    ; for use with MEMORY, allow them to start from $0000
                        	   205: EFLAG_LOAD             = %00000100    ; doing a LOAD, do not show line numbers when inserting
                        	   206: EFLAG_SAVE             = %00001000    ; doing a SAVE, do not show line numbers
                        	   207: EFLAG_FIND             = %00010000    ; doing a FIND
                        	   208: EFLAG_REPLACE          = %00100000    ; doing a REPLACE
                        	   209: EFLAG_SUPPRESS_NEWLINE = %01000000    ; don't show newlines
                        	   210: EFLAG_NO_LINE_NUMBERS  = %10000000    ; don't show line numbers
                        	   211: 
00:00BD 00              	   212: find_flags     reserve 1      ; find/replace flags, see below
                        	   213: 
                        	   214: FFLAG_IGNORE_CASE = %00000001
                        	   215: FFLAG_GLOBAL      = %00000010
                        	   216: FFLAG_QUIET       = %00000100
                        	   217: 
                        	   218: ;
                        	   219: ;  system flags
                        	   220: ;
                        	   221: 
00:00BE 00              	   222: system_flags    reserve 1    ; general flags
                        	   223: 
                        	   224: FLAG_COMPILING      = %00000001
                        	   225: FLAG_ASSEMBLING     = %00000010
                        	   226: FLAG_LIST_SOURCE    = %00000100
                        	   227: FLAG_VALID_COMPILE  = %00001000
                        	   228: FLAG_VALID_ASSEMBLE = %00010000
                        	   229: FLAG_RUNNING        = %00100000
                        	   230: FLAG_ONLY_ALPHA     = %01000000   ; for editor, so you can L5 to do LIST 5
                        	   231: FLAG_ABORTED        = %10000000   ; Ctrl+C pressed during printing
                        	   232: 

Source: "gpascal.asm"
                        	   117: 
                        	   118: ;
                        	   119: ;  A general work-buffer is allocated from $200 to $2FF for use during keyboard input, and also
                        	   120: ;  for converting strings during tokenisation (eg. two quotes in a row to one quote, and handling
                        	   121: ;  string escape sequences). It is also used during assembly as a 256-byte operator stack.
                        	   122: ;
                        	   123:   .org $200
                        	   124: INBUF_SIZE = 256          ; we use this for string storage during tokenisation
01:0200 00              	   125: INBUF  reserve INBUF_SIZE ; and also for preprocessing string literals (eg. backslash expansion)
01:0201 *
                        	   126: TEXT_START = *            ; where source goes in memory (currently $300)
                        	   127:   .dend
                        	   128: 
                        	   129: 
                        	   130: 
                        	   131: ;------------------------------------------
                        	   132: ;  Macros
                        	   133: ;------------------------------------------
                        	   134: 
                        	   135:  .macro tknjmpItem ; tknjmp entry: token, handler
                        	   136:    dfb   \1
                        	   137:    word  \2
                        	   138:  .endmacro
                        	   139: 
                        	   140:  .macro makeHandler ; table of words and handlers: word, handler
                        	   141:    asciiz   \1
                        	   142:    word  \2
                        	   143:  .endmacro
                        	   144: 
                        	   145: ;
                        	   146: ; makePasLibraryFunction NAME (SYMNAM), TYPE (SYMTYP), ARG_COUNT (SYMARG), EXECUTION_ADDRESS (SYMDSP)
                        	   147: ;
                        	   148: ;   TYPE = SYMBOL_LIBRARY_PROCEDURE or SYMBOL_LIBRARY_FUNCTION
                        	   149:    .macro makePasLibraryFunction
                        	   150:      asciiz   \1
                        	   151:      dfb      \2
                        	   152:      dfb      \3
                        	   153:      word     \4
                        	   154:    .endmacro
                        	   155: 
                        	   156: ;
                        	   157: ; makeAsmLibraryFunction NAME (SYMNAM), EXECUTION_ADDRESS (SYMDSP)
                        	   158: ;
                        	   159:    .macro makeAsmLibraryFunction
                        	   160:      asciiz   \1
                        	   161:      word     \2
                        	   162:    .endmacro
                        	   163: 
                        	   164:   ORG  START_OF_ROM   ; normally $8000 in the case of Ben Eater's board
                        	   165: 
00:8000 4C34CF          	   166:   JMP  START   ; where RESET takes us - a cold start
00:8003 4C58CF          	   167:   JMP  RESTART ; where NMI takes us - a warm start
                        	   168: 
                        	   169: ;***********************************************
                        	   170: ; INCLUDES
                        	   171: ;***********************************************
                        	   172: 
                        	   173:   .include "memory.inc"

Source: "memory.inc"
                        	     1: ;---------------------------
                        	     2: ; standard library stuff
                        	     3: ;---------------------------
                        	     4: 
                        	     5: ;
                        	     6: ;  character type masks
                        	     7: ;
                        	     8: m_upper   = %00000001    ; $01
                        	     9: m_lower   = %00000010    ; $02
                        	    10: m_alpha   = %00000100    ; $04
                        	    11: m_digit   = %00001000    ; $08
                        	    12: m_xdigit  = %00010000    ; $10
                        	    13: m_space   = %00100000    ; $20
                        	    14: m_cntrl   = %01000000    ; $40
                        	    15: m_alnum   = %10000000    ; $80
                        	    16: 
                        	    17: ;
                        	    18: ;  for fast checks which corrupt registers
                        	    19: ;
                        	    20: ;    ldx THE_CHARACTER_TO_BE_TESTED
                        	    21: ;    lda character_types_table,X
                        	    22: ;    bne IS_IN_THAT_CLASS
                        	    23: ;
                        	    24: 
                        	    25: character_types_table = *
00:8006 40              	    26:   dfb $40,$40,$40,$40,$40,$40,$40,$40    ; 0x00
00:8007 40
00:8008 40
00:8009 40
00:800A 40
00:800B 40
00:800C 40
00:800D 40
00:800E 40              	    27:   dfb $40,$60,$60,$60,$60,$60,$40,$40    ; 0x08
00:800F 60
00:8010 60
00:8011 60
00:8012 60
00:8013 60
00:8014 40
00:8015 40
00:8016 40              	    28:   dfb $40,$40,$40,$40,$40,$40,$40,$40    ; 0x10
00:8017 40
00:8018 40
00:8019 40
00:801A 40
00:801B 40
00:801C 40
00:801D 40
00:801E 40              	    29:   dfb $40,$40,$40,$40,$40,$40,$40,$40    ; 0x18
00:801F 40
00:8020 40
00:8021 40
00:8022 40
00:8023 40
00:8024 40
00:8025 40
00:8026 20              	    30:   dfb $20,$00,$00,$00,$00,$00,$00,$00    ; 0x20   !"#$%&'
00:8027 00
00:8028 00
00:8029 00
00:802A 00
00:802B 00
00:802C 00
00:802D 00
00:802E 00              	    31:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x28  ()*+,-./
00:802F 00
00:8030 00
00:8031 00
00:8032 00
00:8033 00
00:8034 00
00:8035 00
00:8036 98              	    32:   dfb $98,$98,$98,$98,$98,$98,$98,$98    ; 0x30  01234567
00:8037 98
00:8038 98
00:8039 98
00:803A 98
00:803B 98
00:803C 98
00:803D 98
00:803E 98              	    33:   dfb $98,$98,$00,$00,$00,$00,$00,$00    ; 0x38  89:;<=>?
00:803F 98
00:8040 00
00:8041 00
00:8042 00
00:8043 00
00:8044 00
00:8045 00
00:8046 00              	    34:   dfb $00,$95,$95,$95,$95,$95,$95,$85    ; 0x40  @ABCDEFG
00:8047 95
00:8048 95
00:8049 95
00:804A 95
00:804B 95
00:804C 95
00:804D 85
00:804E 85              	    35:   dfb $85,$85,$85,$85,$85,$85,$85,$85    ; 0x48  HIJKLMNO
00:804F 85
00:8050 85
00:8051 85
00:8052 85
00:8053 85
00:8054 85
00:8055 85
00:8056 85              	    36:   dfb $85,$85,$85,$85,$85,$85,$85,$85    ; 0x50  PQRSTUVW
00:8057 85
00:8058 85
00:8059 85
00:805A 85
00:805B 85
00:805C 85
00:805D 85
00:805E 85              	    37:   dfb $85,$85,$85,$00,$00,$00,$00,$00    ; 0x58  XYZ[\]^_
00:805F 85
00:8060 85
00:8061 00
00:8062 00
00:8063 00
00:8064 00
00:8065 00
00:8066 00              	    38:   dfb $00,$96,$96,$96,$96,$96,$96,$86    ; 0x60  `abcdefg
00:8067 96
00:8068 96
00:8069 96
00:806A 96
00:806B 96
00:806C 96
00:806D 86
00:806E 86              	    39:   dfb $86,$86,$86,$86,$86,$86,$86,$86    ; 0x68  hijklmno
00:806F 86
00:8070 86
00:8071 86
00:8072 86
00:8073 86
00:8074 86
00:8075 86
00:8076 86              	    40:   dfb $86,$86,$86,$86,$86,$86,$86,$86    ; 0x70  pqrstuvw
00:8077 86
00:8078 86
00:8079 86
00:807A 86
00:807B 86
00:807C 86
00:807D 86
00:807E 86              	    41:   dfb $86,$86,$86,$00,$00,$00,$00,$40    ; 0x78  xyz{|}~
00:807F 86
00:8080 86
00:8081 00
00:8082 00
00:8083 00
00:8084 00
00:8085 40
00:8086 00              	    42:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x80
00:8087 00
00:8088 00
00:8089 00
00:808A 00
00:808B 00
00:808C 00
00:808D 00
00:808E 00              	    43:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x88
00:808F 00
00:8090 00
00:8091 00
00:8092 00
00:8093 00
00:8094 00
00:8095 00
00:8096 00              	    44:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x90
00:8097 00
00:8098 00
00:8099 00
00:809A 00
00:809B 00
00:809C 00
00:809D 00
00:809E 00              	    45:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0x98
00:809F 00
00:80A0 00
00:80A1 00
00:80A2 00
00:80A3 00
00:80A4 00
00:80A5 00
00:80A6 00              	    46:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xA0
00:80A7 00
00:80A8 00
00:80A9 00
00:80AA 00
00:80AB 00
00:80AC 00
00:80AD 00
00:80AE 00              	    47:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xA8
00:80AF 00
00:80B0 00
00:80B1 00
00:80B2 00
00:80B3 00
00:80B4 00
00:80B5 00
00:80B6 00              	    48:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xB0
00:80B7 00
00:80B8 00
00:80B9 00
00:80BA 00
00:80BB 00
00:80BC 00
00:80BD 00
00:80BE 00              	    49:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xB8
00:80BF 00
00:80C0 00
00:80C1 00
00:80C2 00
00:80C3 00
00:80C4 00
00:80C5 00
00:80C6 00              	    50:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xC0
00:80C7 00
00:80C8 00
00:80C9 00
00:80CA 00
00:80CB 00
00:80CC 00
00:80CD 00
00:80CE 00              	    51:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xC8
00:80CF 00
00:80D0 00
00:80D1 00
00:80D2 00
00:80D3 00
00:80D4 00
00:80D5 00
00:80D6 00              	    52:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xD0
00:80D7 00
00:80D8 00
00:80D9 00
00:80DA 00
00:80DB 00
00:80DC 00
00:80DD 00
00:80DE 00              	    53:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xD8
00:80DF 00
00:80E0 00
00:80E1 00
00:80E2 00
00:80E3 00
00:80E4 00
00:80E5 00
00:80E6 00              	    54:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xE0
00:80E7 00
00:80E8 00
00:80E9 00
00:80EA 00
00:80EB 00
00:80EC 00
00:80ED 00
00:80EE 00              	    55:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xE8
00:80EF 00
00:80F0 00
00:80F1 00
00:80F2 00
00:80F3 00
00:80F4 00
00:80F5 00
00:80F6 00              	    56:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xF0
00:80F7 00
00:80F8 00
00:80F9 00
00:80FA 00
00:80FB 00
00:80FC 00
00:80FD 00
00:80FE 00              	    57:   dfb $00,$00,$00,$00,$00,$00,$00,$00    ; 0xF8
00:80FF 00
00:8100 00
00:8101 00
00:8102 00
00:8103 00
00:8104 00
00:8105 00
                        	    58: 
                        	    59: ;
                        	    60: ;  character type tests: test character in A, Carry set if true, carry clear if false
                        	    61: ;    -no registers changed
                        	    62: ;
                        	    63: is_xxx_fail:
00:8106 FA              	    64:   plx
00:8107 68              	    65:   pla
00:8108 18              	    66:   clc
00:8109 60              	    67:   rts
                        	    68: 
                        	    69: is_xxx_pass:
00:810A FA              	    70:   plx
00:810B 68              	    71:   pla
00:810C 38              	    72:   sec
00:810D 60              	    73:   rts
                        	    74: 
                        	    75:   .macro isXXX
                        	    76: \1 = *
                        	    77:   pha
                        	    78:   phx
                        	    79:   tax
                        	    80:   lda character_types_table,x
                        	    81:   and #\2
                        	    82:   beq is_xxx_fail
                        	    83:   bra is_xxx_pass
                        	    84:   .endmacro
                        	    85: 
                        	    86: ;
                        	    87: ;  generate the various character type tests - done by fast table lookup
                        	    88: ;
                        	    89:   isXXX isupper,  m_upper
                        	     1M isupper = *
00:810E 48              	     2M   pha
00:810F DA              	     3M   phx
00:8110 AA              	     4M   tax
00:8111 BD0680          	     5M   lda character_types_table,x
00:8114 2901            	     6M   and #m_upper
00:8116 F0EE            	     7M   beq is_xxx_fail
00:8118 80F0            	     8M   bra is_xxx_pass
                        	    90:   isXXX islower,  m_lower
                        	     1M islower = *
00:811A 48              	     2M   pha
00:811B DA              	     3M   phx
00:811C AA              	     4M   tax
00:811D BD0680          	     5M   lda character_types_table,x
00:8120 2902            	     6M   and #m_lower
00:8122 F0E2            	     7M   beq is_xxx_fail
00:8124 80E4            	     8M   bra is_xxx_pass
                        	    91:   isXXX isalpha,  m_alpha
                        	     1M isalpha = *
00:8126 48              	     2M   pha
00:8127 DA              	     3M   phx
00:8128 AA              	     4M   tax
00:8129 BD0680          	     5M   lda character_types_table,x
00:812C 2904            	     6M   and #m_alpha
00:812E F0D6            	     7M   beq is_xxx_fail
00:8130 80D8            	     8M   bra is_xxx_pass
                        	    92:   isXXX isdigit,  m_digit
                        	     1M isdigit = *
00:8132 48              	     2M   pha
00:8133 DA              	     3M   phx
00:8134 AA              	     4M   tax
00:8135 BD0680          	     5M   lda character_types_table,x
00:8138 2908            	     6M   and #m_digit
00:813A F0CA            	     7M   beq is_xxx_fail
00:813C 80CC            	     8M   bra is_xxx_pass
                        	    93:   isXXX isxdigit, m_xdigit
                        	     1M isxdigit = *
00:813E 48              	     2M   pha
00:813F DA              	     3M   phx
00:8140 AA              	     4M   tax
00:8141 BD0680          	     5M   lda character_types_table,x
00:8144 2910            	     6M   and #m_xdigit
00:8146 F0BE            	     7M   beq is_xxx_fail
00:8148 80C0            	     8M   bra is_xxx_pass
                        	    94:   isXXX isspace,  m_space
                        	     1M isspace = *
00:814A 48              	     2M   pha
00:814B DA              	     3M   phx
00:814C AA              	     4M   tax
00:814D BD0680          	     5M   lda character_types_table,x
00:8150 2920            	     6M   and #m_space
00:8152 F0B2            	     7M   beq is_xxx_fail
00:8154 80B4            	     8M   bra is_xxx_pass
                        	    95:   isXXX iscntrl,  m_cntrl
                        	     1M iscntrl = *
00:8156 48              	     2M   pha
00:8157 DA              	     3M   phx
00:8158 AA              	     4M   tax
00:8159 BD0680          	     5M   lda character_types_table,x
00:815C 2940            	     6M   and #m_cntrl
00:815E F0A6            	     7M   beq is_xxx_fail
00:8160 80A8            	     8M   bra is_xxx_pass
                        	    96:   isXXX isalnum,  m_alnum
                        	     1M isalnum = *
00:8162 48              	     2M   pha
00:8163 DA              	     3M   phx
00:8164 AA              	     4M   tax
00:8165 BD0680          	     5M   lda character_types_table,x
00:8168 2980            	     6M   and #m_alnum
00:816A F09A            	     7M   beq is_xxx_fail
00:816C 809C            	     8M   bra is_xxx_pass
                        	    97: 
                        	    98: ;
                        	    99: ;  ran out of bits so implemented this one manually
                        	   100: ;
                        	   101: isbinary   =  *
00:816E C930            	   102:          cmp  #'0'
00:8170 F004            	   103:          beq  isbin
00:8172 C931            	   104:          cmp  #'1'
00:8174 D002            	   105:          bne  notbin
                        	   106: isbin:
00:8176 38              	   107:          sec
00:8177 60              	   108:          rts
                        	   109: notbin:
00:8178 18              	   110:          clc
00:8179 60              	   111:          rts
                        	   112: 
                        	   113: ;
                        	   114: ; Move memory down  (mem_move_dest is < mem_move_src)
                        	   115: ;
                        	   116: ;  Copies first byte first, working upwards
                        	   117: ;
                        	   118: ; mem_move_src = source start address
                        	   119: ; mem_move_dest = destination start address
                        	   120: ; mem_move_len = number of bytes mem_move_dest move
                        	   121: ;
                        	   122: movedown:
00:817A A5AA            	   123:   lda mem_move_len
00:817C 05AB            	   124:   ora mem_move_len+1
00:817E F01C            	   125:   beq movedown_done
00:8180 A000            	   126:   ldy #0
00:8182 8498            	   127:   sty  token_work      ; counter
00:8184 8499            	   128:   sty  token_work+1
                        	   129: ;
                        	   130: ;  copy one byte, increment counter
                        	   131: ;
                        	   132: movedown_loop:
00:8186 B1A6            	   133:   lda (mem_move_src),Y
00:8188 91A8            	   134:   sta (mem_move_dest),Y
00:818A E698            	   135:   inc token_work
00:818C D002            	   136:   bne movedown2
00:818E E699            	   137:   inc token_work+1
                        	   138: ;
                        	   139: ;  see if length reached
                        	   140: ;
                        	   141: movedown2:
                        	   142: 
00:8190 A598            	   143:   lda  token_work
00:8192 C5AA            	   144:   cmp  mem_move_len
00:8194 D007            	   145:   bne  movedown1
00:8196 A599            	   146:   lda  token_work+1
00:8198 C5AB            	   147:   cmp  mem_move_len+1
00:819A D001            	   148:   bne  movedown1
                        	   149: movedown_done:
00:819C 60              	   150:   rts
                        	   151: 
                        	   152: ;
                        	   153: ; increment Y, and increment high-order address bytes if necessary
                        	   154: ;
                        	   155: movedown1:
00:819D C8              	   156:   iny
00:819E D0E6            	   157:   bne  movedown_loop
00:81A0 E6A7            	   158:   inc  mem_move_src+1
00:81A2 E6A9            	   159:   inc  mem_move_dest+1
00:81A4 80E0            	   160:   bra  movedown_loop
                        	   161: 
                        	   162: ; Move memory up (mem_move_dest is > mem_move_src)
                        	   163: ;
                        	   164: ;   Copies last byte first, moving downwards
                        	   165: ;
                        	   166: ; mem_move_src = source start address
                        	   167: ; mem_move_dest = destination start address
                        	   168: ; mem_move_len = number of bytes mem_move_dest move
                        	   169: ;
                        	   170: moveup:
00:81A6 A5AA            	   171:   lda mem_move_len
00:81A8 05AB            	   172:   ora mem_move_len+1
00:81AA F038            	   173:   beq moveup_done
00:81AC A000            	   174:   ldy #0
00:81AE 8498            	   175:   sty  token_work      ; counter
00:81B0 8499            	   176:   sty  token_work+1
                        	   177:   ;
                        	   178:   ;  calculate final address of source
                        	   179:   ;
00:81B2 18              	   180:   clc
00:81B3 A5A6            	   181:   lda mem_move_src
00:81B5 65AA            	   182:   adc mem_move_len
00:81B7 85A6            	   183:   sta mem_move_src
00:81B9 A5A7            	   184:   lda mem_move_src+1
00:81BB 65AB            	   185:   adc mem_move_len+1
00:81BD 85A7            	   186:   sta mem_move_src+1
                        	   187:   ;
                        	   188:   ;  calculate final address of destination
                        	   189:   ;
00:81BF 18              	   190:   clc
00:81C0 A5A8            	   191:   lda mem_move_dest
00:81C2 65AA            	   192:   adc mem_move_len
00:81C4 85A8            	   193:   sta mem_move_dest
00:81C6 A5A9            	   194:   lda mem_move_dest+1
00:81C8 65AB            	   195:   adc mem_move_len+1
00:81CA 85A9            	   196:   sta mem_move_dest+1
00:81CC 8017            	   197:   bra moveup_next   ; have to decrement first
                        	   198: ;
                        	   199: ; move one byte, count moves
                        	   200: ;
                        	   201: moveup_loop:
00:81CE B1A6            	   202:   lda (mem_move_src),Y
00:81D0 91A8            	   203:   sta (mem_move_dest),Y
00:81D2 E698            	   204:   inc token_work
00:81D4 D002            	   205:   bne moveup3
00:81D6 E699            	   206:   inc token_work+1
                        	   207: moveup3:
                        	   208: ;
                        	   209: ;  see if length reached
                        	   210: ;
00:81D8 A598            	   211:   lda token_work
00:81DA C5AA            	   212:   cmp mem_move_len
00:81DC D007            	   213:   bne moveup_next
00:81DE A599            	   214:   lda token_work+1
00:81E0 C5AB            	   215:   cmp mem_move_len+1
00:81E2 D001            	   216:   bne moveup_next
                        	   217: moveup_done:
00:81E4 60              	   218:   rts
                        	   219: ;
                        	   220: ;  decrement Y, and decrement high-order address bytes if necessary
                        	   221: ;
                        	   222: moveup_next   =  *
00:81E5 88              	   223:   dey
00:81E6 C0FF            	   224:   cpy #$FF
00:81E8 D0E4            	   225:   bne moveup_loop
00:81EA C6A7            	   226:   dec mem_move_src+1
00:81EC C6A9            	   227:   dec mem_move_dest+1
00:81EE 80DE            	   228:   bra moveup_loop
                        	   229: 
                        	   230: ;
                        	   231: ;
                        	   232: ; String compare - case significant (max 128 byte strings)
                        	   233: ;
                        	   234: ; SRCE = source start address
                        	   235: ; DEST = destination start address
                        	   236: ; Y    = length of both strings (range 1 to 128)
                        	   237: ;
                        	   238: ;  returns Z set if strings are equal
                        	   239: ;
                        	   240: 
                        	   241: str_compare:
00:81F0 88              	   242:   dey             ; make zero-relative
00:81F1 300B            	   243:   bmi str_compare_done
00:81F3 B100            	   244:   lda (SRCE),y
00:81F5 8585            	   245:   sta str_work
00:81F7 B103            	   246:   lda (DEST),y
00:81F9 C585            	   247:   cmp str_work
00:81FB F0F3            	   248:   beq str_compare
00:81FD 60              	   249:   rts   ; no match, zero flag not set
                        	   250: str_compare_done:
00:81FE A900            	   251:   lda #0    ; set Z flag
00:8200 60              	   252:   rts
                        	   253: 
                        	   254: ;
                        	   255: ; String compare - case NOT significant (max 128 byte strings)
                        	   256: ;
                        	   257: ; SRCE = source start address
                        	   258: ; DEST = destination start address
                        	   259: ; Y    = length of both strings (range 1 to 128)
                        	   260: ;
                        	   261: ;  returns Z set if strings are equal
                        	   262: ;
                        	   263: 
                        	   264: str_ic_compare:
00:8201 88              	   265:   dey
00:8202 301F            	   266:   bmi str_ic_compare_done
00:8204 B100            	   267:   lda (SRCE),y
00:8206 C97B            	   268:   cmp #'z'+1
00:8208 B006            	   269:   bcs str_ic_compare_fixed_srce  ; BGE
00:820A C961            	   270:   cmp #'a'
00:820C 9002            	   271:   bcc str_ic_compare_fixed_srce  ; BLT
00:820E E920            	   272:   sbc #$20    ; make upper-case
                        	   273: str_ic_compare_fixed_srce:
00:8210 8585            	   274:   sta str_work
00:8212 B103            	   275:   lda (DEST),y
00:8214 C97B            	   276:   cmp #'z'+1
00:8216 B006            	   277:   bcs str_ic_compare_fixed_dest  ; BGE
00:8218 C961            	   278:   cmp #'a'
00:821A 9002            	   279:   bcc str_ic_compare_fixed_dest  ; BLT
00:821C E920            	   280:   sbc #$20    ; make upper-case
                        	   281: str_ic_compare_fixed_dest:
00:821E C585            	   282:   cmp str_work
00:8220 F0DF            	   283:   beq str_ic_compare
00:8222 60              	   284:   rts       ; no match, zero flag not set
                        	   285: str_ic_compare_done:
00:8223 A900            	   286:   lda #0    ; set Z flag
00:8225 60              	   287:   rts
                        	   288: 
                        	   289: 

Source: "gpascal.asm"
                        	   174:   .include "editor.inc"

Source: "editor.inc"
                        	     1: ;-------------------------------------------------
                        	     2: ;
                        	     3: ;  Shell, and text editor
                        	     4: ;
                        	     5: ;-------------------------------------------------
                        	     6: 
                        	     7: 
                        	     8: ;-------------------------------------------------
                        	     9: ;  print null-terminated message, message in A (lo) and X (hi)
                        	    10: ;  returns the length of the message in Y
                        	    11: ;-------------------------------------------------
                        	    12: print:
00:8226 A8              	    13:   tay   ; save A
00:8227 A503            	    14:   lda REG2 ; save REG2
00:8229 48              	    15:   pha
00:822A A504            	    16:   lda REG2+1  ; save REG2+1
00:822C 48              	    17:   pha
00:822D 98              	    18:   tya   ; get original A back
00:822E 8503            	    19:   sta REG2
00:8230 8604            	    20:   stx REG2+1
00:8232 A000            	    21:   ldy #0
                        	    22: print_loop:
00:8234 A58B            	    23:   lda  serial_in_byte_received
00:8236 F00A            	    24:   beq  print_not_abort
00:8238 C903            	    25:   cmp  #KEY_ABORT
00:823A D010            	    26:   bne  print_done
00:823C A980            	    27:   lda  #FLAG_ABORTED    ; set aborted flag
00:823E 04BE            	    28:   tsb  system_flags
00:8240 800A            	    29:   bra  print_done
                        	    30: print_not_abort:
00:8242 B103            	    31:   lda (REG2),y
00:8244 F006            	    32:   beq print_done
00:8246 20AF93          	    33:   jsr COUT
00:8249 C8              	    34:   iny
00:824A D0E8            	    35:   bne print_loop  ; give up if we overflow
                        	    36: print_done:
00:824C 648B            	    37:   stz serial_in_byte_received
                        	    38: ;
                        	    39: ;  get REG2 back
                        	    40: ;
00:824E 68              	    41:   pla
00:824F 8504            	    42:   sta REG2+1
00:8251 68              	    43:   pla
00:8252 8503            	    44:   sta REG2
00:8254 60              	    45:   rts
                        	    46: 
00:8255 472D50617363616C	    47: introduction asc    "G-Pascal compiler, version 4.0.\n"
00:825D 20636F6D70696C65
00:8265 722C207665727369
00:826D 6F6E20342E302E0A
00:8275 5772697474656E20	    48:              asciiz "Written by Nick Gammon.\nType H for help.\n"
00:827D 6279204E69636B20
00:8285 47616D6D6F6E2E0A
00:828D 5479706520482066
00:8295 6F722068656C702E
00:829D 0A
00:829E 00
00:829F 3A20            	    49: prompt       asciiz ": "
00:82A1 00
00:82A2 556E6B6E6F776E20	    50: bad_command  asciiz "Unknown command, type H for help.\n"
00:82AA 636F6D6D616E642C
00:82B2 2074797065204820
00:82BA 666F722068656C70
00:82C2 2E0A
00:82C4 00
                        	    51: 
                        	    52: ;-------------------------------------------------
                        	    53: ; Start here after Reset or NMI - show introduction
                        	    54: ;-------------------------------------------------
                        	    55: 
                        	    56: main_start:
00:82C5 A955            	    57:   lda #<introduction
00:82C7 A282            	    58:   ldx #>introduction
00:82C9 202682          	    59:   jsr print
                        	    60: 
                        	    61: main_prompt:
00:82CC A2FF            	    62:   ldx  #NEW_STK
00:82CE 9A              	    63:   txs
00:82CF D8              	    64:   cld
                        	    65: 
00:82D0 A99F            	    66:   lda #<prompt
00:82D2 A282            	    67:   ldx #>prompt
00:82D4 202682          	    68:   jsr print
                        	    69: 
00:82D7 208793          	    70:   jsr  GET_LINE
                        	    71: 
00:82DA A900            	    72:   lda #<INBUF
00:82DC 858E            	    73:   sta token_start
00:82DE A902            	    74:   lda #>INBUF
00:82E0 858F            	    75:   sta token_start+1
                        	    76: 
00:82E2 A901            	    77:   lda #1
00:82E4 853F            	    78:   sta RUNNING
                        	    79: 
                        	    80: ;-------------------------------------------------
                        	    81: ; EDITOR (SHELL) MAIN LOOP
                        	    82: ;-------------------------------------------------
                        	    83: 
                        	    84: main_loop:
00:82E6 64BC            	    85:   stz editor_flags  ; no flags yet
00:82E8 64BD            	    86:   stz find_flags    ;  ditto
00:82EA A901            	    87:   lda #FLAG_COMPILING
00:82EC 0902            	    88:   ora #FLAG_ASSEMBLING
00:82EE 14BE            	    89:   trb system_flags  ; not compiling or assembling now
                        	    90: 
00:82F0 A940            	    91:   lda #FLAG_ONLY_ALPHA
00:82F2 04BE            	    92:   tsb system_flags  ; we only want alpha commands, thus we can enter L1 and be the same as List 1
                        	    93: 
00:82F4 20F5C8          	    94:   jsr get_token
00:82F7 F0D3            	    95:   beq main_prompt   ; no input
                        	    96: 
                        	    97: ;
                        	    98: ;  Shortcut: If the input is "R" or "r" followed directly by a newline, assume they want to Run
                        	    99: ;
00:82F9 C949            	   100:   cmp #TOKEN_IDENTIFIER
00:82FB D015            	   101:   bne main_loop_not_run
                        	   102: 
00:82FD A000            	   103:   ldy #0
00:82FF B190            	   104:   lda (token_address),y
00:8301 20C48F          	   105:   jsr MAKE_UPPER
00:8304 C952            	   106:   cmp #'R'
00:8306 D00A            	   107:   bne main_loop_not_run
00:8308 C8              	   108:   iny
00:8309 B190            	   109:   lda (token_address),y
00:830B C90A            	   110:   cmp #NL
00:830D D003            	   111:   bne main_loop_not_run
00:830F 4C9F8E          	   112:   jmp editor_run
                        	   113: 
                        	   114: ;
                        	   115: ;  Not a RUN shortcut, look up the command in our table
                        	   116: ;
                        	   117: main_loop_not_run:
                        	   118: ;
                        	   119: ;  set up our input line as where to find tokens
                        	   120: ;
00:8312 A590            	   121:   lda token_address
00:8314 8500            	   122:   sta SRCE
00:8316 A591            	   123:   lda token_address+1
00:8318 8501            	   124:   sta SRCE+1
                        	   125: 
                        	   126: ;
                        	   127: ;  get editor handlers
                        	   128: ;
00:831A A930            	   129:   lda #<editor_handlers
00:831C 8503            	   130:   sta DEST
00:831E A983            	   131:   lda #>editor_handlers
00:8320 8504            	   132:   sta DEST+1
                        	   133: 
                        	   134: ;
                        	   135: ;  get the token length and look up the handler
                        	   136: ;
00:8322 A592            	   137:   lda token_length
00:8324 204D8F          	   138:   jsr partial_handler_Lookup
                        	   139: 
                        	   140: ;
                        	   141: ;  if we returned, unknown command
                        	   142: ;
00:8327 A9A2            	   143:   lda #<bad_command
00:8329 A282            	   144:   ldx #>bad_command
00:832B 202682          	   145:   jsr print
00:832E 809C            	   146:   bra  main_prompt
                        	   147: 
                        	   148: 
                        	   149: editor_handlers:
                        	   150:   makeHandler "LIST",    editor_list
00:8330 4C495354        	     1M    asciiz   "LIST"
00:8334 00
00:8335 4787            	     2M    word  editor_list
                        	   151:   makeHandler "INSERT",  editor_insert
00:8337 494E53455254    	     1M    asciiz   "INSERT"
00:833D 00
00:833E FA89            	     2M    word  editor_insert
                        	   152:   makeHandler "LOAD",    editor_load
00:8340 4C4F4144        	     1M    asciiz   "LOAD"
00:8344 00
00:8345 F689            	     2M    word  editor_load
                        	   153:   makeHandler "DELETE",  editor_delete
00:8347 44454C455445    	     1M    asciiz   "DELETE"
00:834D 00
00:834E 6E8B            	     2M    word  editor_delete
                        	   154:   makeHandler "HELP",    editor_help
00:8350 48454C50        	     1M    asciiz   "HELP"
00:8354 00
00:8355 3385            	     2M    word  editor_help
                        	   155:   makeHandler "COMPILE" ,editor_compile
00:8357 434F4D50494C45  	     1M    asciiz   "COMPILE" 
00:835E 00
00:835F 918E            	     2M    word  editor_compile
                        	   156:   makeHandler "SYNTAX",  editor_syntax
00:8361 53594E544158    	     1M    asciiz   "SYNTAX"
00:8367 00
00:8368 988E            	     2M    word  editor_syntax
                        	   157:   makeHandler "SAVE",    editor_save
00:836A 53415645        	     1M    asciiz   "SAVE"
00:836E 00
00:836F 4187            	     2M    word  editor_save
                        	   158: ;  makeHandler "TEST",    editor_test
                        	   159:   makeHandler "MEMORY",  editor_memory
00:8371 4D454D4F5259    	     1M    asciiz   "MEMORY"
00:8377 00
00:8378 CC8C            	     2M    word  editor_memory
                        	   160:  ; makeHandler "SYMTBL", editor_symbol_table_list
                        	   161:   makeHandler "INFO",    editor_info
00:837A 494E464F        	     1M    asciiz   "INFO"
00:837E 00
00:837F 858E            	     2M    word  editor_info
                        	   162:   makeHandler "TRACE",   editor_trace
00:8381 5452414345      	     1M    asciiz   "TRACE"
00:8386 00
00:8387 7C8E            	     2M    word  editor_trace
                        	   163:   makeHandler "DEBUG",   editor_debug
00:8389 4445425547      	     1M    asciiz   "DEBUG"
00:838E 00
00:838F 738E            	     2M    word  editor_debug
                        	   164:   makeHandler "ASSEMBLE",editor_assemble
00:8391 415353454D424C45	     1M    asciiz   "ASSEMBLE"
00:8399 00
00:839A 078F            	     2M    word  editor_assemble
                        	   165:   makeHandler "FIND",    editor_find
00:839C 46494E44        	     1M    asciiz   "FIND"
00:83A0 00
00:83A1 3B87            	     2M    word  editor_find
                        	   166:   makeHandler "REPLACE", editor_replace
00:83A3 5245504C414345  	     1M    asciiz   "REPLACE"
00:83AA 00
00:83AB 3387            	     2M    word  editor_replace
                        	   167:   makeHandler "RUN",     editor_run
00:83AD 52554E          	     1M    asciiz   "RUN"
00:83B0 00
00:83B1 9F8E            	     2M    word  editor_run
                        	   168:   makeHandler "RECOVER", editor_recover
00:83B3 5245434F564552  	     1M    asciiz   "RECOVER"
00:83BA 00
00:83BB 4D8E            	     2M    word  editor_recover
00:83BD 00              	   169:   dfb 0
                        	   170: 
                        	   171: editor_help_info:
00:83BE 417661696C61626C	   172:   asc "Available actions:\n\n"
00:83C6 6520616374696F6E
00:83CE 733A0A0A
00:83D2 4C6973742F534176	   173:   asc "List/SAve   line_number_range\n"
00:83DA 652020206C696E65
00:83E2 5F6E756D6265725F
00:83EA 72616E67650A
00:83F0 44656C6574652020	   174:   asc "Delete      line_number_range\n"
00:83F8 202020206C696E65
00:8400 5F6E756D6265725F
00:8408 72616E67650A
00:840E 496E736572742F4C	   175:   asc "Insert/LOad after_line\n"
00:8416 4F61642061667465
00:841E 725F6C696E650A
00:8425 46696E6420202020	   176:   asc "Find        line_number_range /target/flags\n"
00:842D 202020206C696E65
00:8435 5F6E756D6265725F
00:843D 72616E6765202F74
00:8445 61726765742F666C
00:844D 6167730A
00:8451 5265706C61636520	   177:   asc "Replace     line_number_range /target/replacement/flags\n"
00:8459 202020206C696E65
00:8461 5F6E756D6265725F
00:8469 72616E6765202F74
00:8471 61726765742F7265
00:8479 706C6163656D656E
00:8481 742F666C6167730A
00:8489 0A              	   178:   asc "\n"
00:848A 48656C700A      	   179:   asc "Help\n"
00:848F 494E666F0A      	   180:   asc "INfo\n"
00:8494 4D656D6F72792020	   181:   asc "Memory      first_address last_address\n"
00:849C 2020202066697273
00:84A4 745F616464726573
00:84AC 73206C6173745F61
00:84B4 6464726573730A
00:84BB 436F6D70696C652F	   182:   asc "Compile/Syntax/Assemble\n"
00:84C3 53796E7461782F41
00:84CB 7373656D626C650A
00:84D3 52556E2F44454275	   183:   asc "RUn/DEBug/Trace\n"
00:84DB 672F54726163650A
00:84E3 5245436F7665720A	   184:   asc "RECover\n"
00:84EB 28416374696F6E73	   185:   asc "(Actions may be abbreviated)\n"
00:84F3 206D617920626520
00:84FB 6162627265766961
00:8503 746564290A
00:8508 28466C6167733A20	   186:   asc "(Flags: 'I'gnore case, 'G'lobal, 'Q'uiet)\n"
00:8510 274927676E6F7265
00:8518 20636173652C2027
00:8520 47276C6F62616C2C
00:8528 2027512775696574
00:8530 290A
00:8532 00              	   187:   dfb 0
                        	   188: 
                        	   189: 
                        	   190: ;--------------------------------------------
                        	   191: ;  HELP
                        	   192: ;--------------------------------------------
                        	   193: editor_help:
00:8533 A9BE            	   194:   lda #<editor_help_info
00:8535 8500            	   195:   sta REG
00:8537 A983            	   196:   lda #>editor_help_info
00:8539 8501            	   197:   sta REG+1
                        	   198: editor_help_loop:
00:853B A000            	   199:   ldy #0
00:853D B100            	   200:   lda (REG),Y
00:853F F00B            	   201:   beq editor_help_done
00:8541 20AF93          	   202:   jsr COUT
00:8544 E600            	   203:   inc REG
00:8546 D0F3            	   204:   bne editor_help_loop
00:8548 E601            	   205:   inc REG+1
00:854A 80EF            	   206:   bra editor_help_loop
                        	   207: editor_help_done:
00:854C 4CCC82          	   208:   jmp main_prompt
                        	   209: 
                        	   210: ;
                        	   211: ;  Sets default range from 1 to 65535
                        	   212: ;
                        	   213: editor_default_range:
                        	   214: ;
                        	   215: ;  default to all lines
                        	   216: ;
00:854F A901            	   217:   lda #1
00:8551 859E            	   218:   sta from_line
00:8553 649F            	   219:   stz from_line+1
00:8555 A9FF            	   220:   lda #$FF
00:8557 85A0            	   221:   sta to_line
00:8559 85A1            	   222:   sta to_line+1
00:855B 60              	   223:   rts
                        	   224: 
                        	   225: number_expected_message:
00:855C 4E756D6265722065	   226:   asciiz "Number expected\n"
00:8564 787065637465640A
00:856C 00
                        	   227: 
                        	   228: editor_bad_number:
00:856D A95C            	   229:   lda #<number_expected_message
00:856F A285            	   230:   ldx #>number_expected_message
00:8571 202682          	   231:   jsr print
00:8574 4CCC82          	   232:   jmp main_prompt
                        	   233: 
                        	   234: ;
                        	   235: ;  get a number for the editor: accepts eof or newline as "no number"
                        	   236: ;  otherwise must be a number and in the range 0x0001 to 0xFFFF
                        	   237: ;  returns carry set if a number (in token_value) and carry clear if
                        	   238: ;  no number. Raises an error otherwise
                        	   239: ;
                        	   240: editor_get_number:
00:8577 20F5C8          	   241:   jsr get_token
00:857A F05E            	   242:   beq editor_get_number_none ; no token? return with carry set
00:857C C90A            	   243:   cmp #NL
00:857E F05A            	   244:   beq editor_get_number_none ; newline counts as no token
00:8580 C94E            	   245:   cmp #TOKEN_NUMBER
00:8582 F044            	   246:   beq editor_get_number_ok
00:8584 C949            	   247:   cmp #TOKEN_IDENTIFIER
00:8586 D02A            	   248:   bne editor_get_number_not_identifier
00:8588 A592            	   249:   lda token_length
00:858A C903            	   250:   cmp #3
00:858C D0DF            	   251:   bne editor_bad_number
00:858E A000            	   252:   ldy #0
00:8590 B190            	   253:   lda (token_address),y
00:8592 20C48F          	   254:   jsr MAKE_UPPER
00:8595 C941            	   255:   cmp #'A'
00:8597 D0D4            	   256:   bne editor_bad_number
00:8599 C8              	   257:   iny
00:859A B190            	   258:   lda (token_address),y
00:859C 20C48F          	   259:   jsr MAKE_UPPER
00:859F C94C            	   260:   cmp #'L'
00:85A1 D0CA            	   261:   bne editor_bad_number
00:85A3 C8              	   262:   iny
00:85A4 B190            	   263:   lda (token_address),y
00:85A6 20C48F          	   264:   jsr MAKE_UPPER
00:85A9 C94C            	   265:   cmp #'L'
00:85AB D0C0            	   266:   bne editor_bad_number
00:85AD 204F85          	   267:   jsr editor_default_range
00:85B0 8028            	   268:   bra editor_get_number_none
                        	   269: ;
                        	   270: ;  find / replace can go straight to the delimiter
                        	   271: ;
                        	   272: editor_get_number_not_identifier:
00:85B2 A910            	   273:   lda #EFLAG_FIND
00:85B4 0920            	   274:   ora #EFLAG_REPLACE
00:85B6 25BC            	   275:   and editor_flags
00:85B8 F0B3            	   276:   beq editor_bad_number
00:85BA A592            	   277:   lda token_length
00:85BC C901            	   278:   cmp #1
00:85BE D0AD            	   279:   bne editor_bad_number
                        	   280: ;
                        	   281: ;  go back one character, we need get_token to find this again later
                        	   282: ;
00:85C0 C68E            	   283:   dec token_start
00:85C2 D016            	   284:   bne editor_get_number_none
00:85C4 C68F            	   285:   dec token_start+1
00:85C6 8012            	   286:   bra editor_get_number_none
                        	   287: 
                        	   288: editor_get_number_ok:
00:85C8 A596            	   289:   lda token_value+2         ; must be a number
00:85CA D02F            	   290:   bne editor_line_number_too_big
00:85CC A5BC            	   291:   lda editor_flags
00:85CE 2902            	   292:   and #EFLAG_ALLOW_ZERO_FROM
00:85D0 D006            	   293:   bne editor_get_number_done
00:85D2 A594            	   294:   lda token_value
00:85D4 0595            	   295:   ora token_value+1
00:85D6 F023            	   296:   beq editor_line_number_too_big  ; too small actually
                        	   297: editor_get_number_done:
00:85D8 38              	   298:   sec
00:85D9 60              	   299:   rts
                        	   300: 
                        	   301: editor_get_number_none:
00:85DA 18              	   302:   clc
00:85DB 60              	   303:   rts
                        	   304: 
                        	   305: number_too_large_message:
00:85DC 4E756D6265722074	   306:   asciiz "Number too large or too small\n"
00:85E4 6F6F206C61726765
00:85EC 206F7220746F6F20
00:85F4 736D616C6C0A
00:85FA 00
                        	   307: 
                        	   308: editor_line_number_too_big:
00:85FB A9DC            	   309:   lda #<number_too_large_message
00:85FD A285            	   310:   ldx #>number_too_large_message
00:85FF 202682          	   311:   jsr print
00:8602 4CCC82          	   312:   jmp main_prompt
                        	   313: 
                        	   314: number_bad_range_message:
00:8605 52616E676520696E	   315:   asciiz "Range invalid\n"
00:860D 76616C69640A
00:8613 00
                        	   316: 
                        	   317: editor_bad_range:
00:8614 A905            	   318:   lda #<number_bad_range_message
00:8616 A286            	   319:   ldx #>number_bad_range_message
00:8618 202682          	   320:   jsr print
00:861B 4CCC82          	   321:   jmp main_prompt
                        	   322: 
                        	   323: too_much_on_line:
00:861E 556E657870656374	   324:   asciiz "Unexpected input on line\n"
00:8626 656420696E707574
00:862E 206F6E206C696E65
00:8636 0A
00:8637 00
                        	   325: 
                        	   326: editor_check_no_more:
00:8638 20F5C8          	   327:   jsr get_token
00:863B F00A            	   328:   beq editor_check_no_more_ok
00:863D A91E            	   329:   lda #<too_much_on_line
00:863F A286            	   330:   ldx #>too_much_on_line
00:8641 202682          	   331:   jsr print
00:8644 4CCC82          	   332:   jmp main_prompt
                        	   333: editor_check_no_more_ok:
00:8647 60              	   334:   rts
                        	   335: 
                        	   336: 
                        	   337: 
                        	   338: ;--------------------------------------------
                        	   339: ;  get a range of line numbers (eg. L 1,10; D 4; M 6,10 )
                        	   340: ;--------------------------------------------
                        	   341: 
                        	   342: editor_get_range:
                        	   343: 
                        	   344: 
                        	   345: ;
                        	   346: ;  get the first line number (if any)
                        	   347: ;
00:8648 207785          	   348:   jsr editor_get_number
00:864B 9045            	   349:   bcc editor_get_range_done ; no token? take defaults
                        	   350: ;
                        	   351: ;  store the from line
                        	   352: ;
00:864D A594            	   353:   lda token_value
00:864F 859E            	   354:   sta from_line
00:8651 85A0            	   355:   sta to_line
00:8653 A595            	   356:   lda token_value+1
00:8655 859F            	   357:   sta from_line+1
00:8657 85A1            	   358:   sta to_line+1
                        	   359: 
                        	   360: ;
                        	   361: ;  comma or hyphen?
                        	   362: ;
00:8659 20F5C8          	   363:   jsr get_token
00:865C F034            	   364:   beq editor_get_range_done   ; line done, just the single line wanted
                        	   365: 
00:865E C92D            	   366:   cmp #'-'
00:8660 F018            	   367:   beq editor_get_range_hyphen
00:8662 C94E            	   368:   cmp #TOKEN_NUMBER
00:8664 F019            	   369:   beq editor_get_range_number
00:8666 C92C            	   370:   cmp #','
00:8668 F010            	   371:   beq editor_get_range_hyphen
                        	   372: ;
                        	   373: ;  find and replace may have another character after the first line number
                        	   374: ;  which isn't a second line number or a hyphen/comma
                        	   375: ;
00:866A A910            	   376:   lda #EFLAG_FIND
00:866C 0920            	   377:   ora #EFLAG_REPLACE
00:866E 25BC            	   378:   and editor_flags
00:8670 F0A2            	   379:   beq editor_bad_range
                        	   380: 
                        	   381: ;
                        	   382: ;  go back one character, we need get_token to find this again later
                        	   383: ;
00:8672 C68E            	   384:   dec token_start
00:8674 D01C            	   385:   bne editor_get_range_done
00:8676 C68F            	   386:   dec token_start+1
00:8678 8018            	   387:   bra editor_get_range_done
                        	   388: 
                        	   389: editor_get_range_hyphen:
                        	   390: ;
                        	   391: ;  get the second line number
                        	   392: ;
00:867A 207785          	   393:   jsr editor_get_number
00:867D 9095            	   394:   bcc editor_bad_range
                        	   395: 
                        	   396: editor_get_range_number:
00:867F A594            	   397:   lda token_value
00:8681 85A0            	   398:   sta to_line
00:8683 A595            	   399:   lda token_value+1
00:8685 85A1            	   400:   sta to_line+1
                        	   401: 
                        	   402: ;
                        	   403: ;  make sure range ascends
                        	   404: ;
00:8687 38              	   405:   sec
00:8688 A5A0            	   406:   lda to_line
00:868A E59E            	   407:   sbc from_line
00:868C A5A1            	   408:   lda to_line+1
00:868E E59F            	   409:   sbc from_line+1
00:8690 9082            	   410:   bcc editor_bad_range    ; <sigh> because of the way SBC works
                        	   411: 
                        	   412: editor_get_range_done:
00:8692 60              	   413:   rts
                        	   414: 
                        	   415: 
                        	   416: ;
                        	   417: 
00:8693 20666F756E640A  	   418: found_message asciiz  ' found\n'
00:869A 00
                        	   419: 
                        	   420: 
                        	   421: 
00:869B 46726F6D3A20    	   422: from_msg: asciiz "From: "
00:86A1 00
00:86A2 20746F20        	   423: to_msg:   asciiz " to "
00:86A6 00
                        	   424: 
00:86A7 4261642064656C69	   425: bad_delimiter_message asciiz "Bad delimiter\n"
00:86AF 6D697465720A
00:86B5 00
                        	   426: 
                        	   427: editor_bad_delimiter:
00:86B6 A9A7            	   428:   lda #<bad_delimiter_message
00:86B8 A286            	   429:   ldx #>bad_delimiter_message
                        	   430: editor_find_problem:
00:86BA 202682          	   431:   jsr print
00:86BD 4CCC82          	   432:   jmp main_prompt
                        	   433: 
00:86C0 46696E642F726570	   434: find_string_too_long_message asciiz "Find/replace string too long\n"
00:86C8 6C61636520737472
00:86D0 696E6720746F6F20
00:86D8 6C6F6E670A
00:86DD 00
                        	   435: 
                        	   436: find_string_too_long:
00:86DE A9C0            	   437:   lda #<find_string_too_long_message
00:86E0 A286            	   438:   ldx #>find_string_too_long_message
00:86E2 80D6            	   439:   bra editor_find_problem
                        	   440: 
                        	   441: editor_get_delimiter:
00:86E4 20F5C8          	   442:   jsr get_token
00:86E7 C949            	   443:   cmp #TOKEN_IDENTIFIER
00:86E9 F0CB            	   444:   beq editor_bad_delimiter
00:86EB C94E            	   445:   cmp #TOKEN_NUMBER
00:86ED F0C7            	   446:   beq editor_bad_delimiter
00:86EF C922            	   447:   cmp #TOKEN_STRING
00:86F1 F0C3            	   448:   beq editor_bad_delimiter
00:86F3 A692            	   449:   ldx token_length
00:86F5 E001            	   450:   cpx #1
00:86F7 D0BD            	   451:   bne editor_bad_delimiter
00:86F9 85B4            	   452:   sta find_delimiter
00:86FB 60              	   453:   rts
                        	   454: 
00:86FC 4E6F20636C6F7369	   455: editor_no_closing_delimiter_message asciiz "No closing delimiter\n"
00:8704 6E672064656C696D
00:870C 697465720A
00:8711 00
                        	   456: 
                        	   457: editor_no_closing_delimiter:
00:8712 A9FC            	   458:   lda #<editor_no_closing_delimiter_message
00:8714 A286            	   459:   ldx #>editor_no_closing_delimiter_message
00:8716 80A2            	   460:   bra editor_find_problem
                        	   461: 
00:8718 5461726765742073	   462: no_find_message asciiz "Target string empty\n"
00:8720 7472696E6720656D
00:8728 7074790A
00:872C 00
                        	   463: 
                        	   464: editor_no_find_string:
00:872D A918            	   465:   lda #<no_find_message
00:872F A287            	   466:   ldx #>no_find_message
00:8731 8087            	   467:   bra editor_find_problem
                        	   468: 
                        	   469: ;--------------------------------------------
                        	   470: ;  LIST / SAVE / FIND / REPLACE / MODIFY
                        	   471: ;
                        	   472: ;  This rather complex routine lists the source between from_line and to_line
                        	   473: ;   In the process it can show or omit line numbers  (omit for SAVE)
                        	   474: ;  Also, it can find the target text, and optionally replace it with the replacement text
                        	   475: ;  In find/replace mode the lines are not shown unless they had something found (unless
                        	   476: ;   the Quiet flag is set)
                        	   477: ;
                        	   478: ;--------------------------------------------
                        	   479: 
                        	   480: editor_replace:
00:8733 A920            	   481:   lda #EFLAG_REPLACE
00:8735 0910            	   482:   ora #EFLAG_FIND   ; makes things simpler later on
00:8737 85BC            	   483:   sta editor_flags
00:8739 800C            	   484:   bra editor_list
                        	   485: 
                        	   486: editor_find:
                        	   487: 
00:873B A910            	   488:   lda #EFLAG_FIND
00:873D 85BC            	   489:   sta editor_flags
00:873F 8006            	   490:   bra editor_list
                        	   491: 
                        	   492: editor_save
                        	   493: 
00:8741 A980            	   494:   lda #EFLAG_NO_LINE_NUMBERS
00:8743 0908            	   495:   ora #EFLAG_SAVE
00:8745 85BC            	   496:   sta editor_flags
                        	   497: 
                        	   498: ;
                        	   499: ;  main entry point - get the from and to lines
                        	   500: ;
                        	   501: editor_list:
00:8747 204F85          	   502:   jsr editor_default_range
00:874A 204886          	   503:   jsr editor_get_range
                        	   504: 
                        	   505: ;
                        	   506: ;  turn the from_line into an address and put it into PCODE
                        	   507: ;
00:874D A59E            	   508:   lda from_line
00:874F 85AC            	   509:   sta this_line
00:8751 A59F            	   510:   lda from_line+1
00:8753 85AD            	   511:   sta this_line+1
00:8755 20558C          	   512:   jsr find_line    ; find the "from" line address (this_line in fact)
00:8758 A5AE            	   513:   lda this_line_addr
00:875A 8523            	   514:   sta PCODE
00:875C A5AF            	   515:   lda this_line_addr+1
00:875E 8524            	   516:   sta PCODE+1
00:8760 64B9            	   517:   stz find_count
00:8762 64BA            	   518:   stz find_count+1
                        	   519: 
                        	   520: ;
                        	   521: ;  for FIND and REPLACE, get the first delimiter
                        	   522: ;
00:8764 A5BC            	   523:   lda editor_flags
00:8766 2910            	   524:   and #EFLAG_FIND
00:8768 D003            	   525:   bne editor_list_doing_find
00:876A 4C3788          	   526:   jmp editor_list_not_find
                        	   527: 
                        	   528: editor_list_doing_find:
00:876D 20E486          	   529:   jsr editor_get_delimiter
                        	   530: ;
                        	   531: ;  token_next should now be the start of what we are searching for
                        	   532: ;
00:8770 38              	   533:   sec
00:8771 A58E            	   534:   lda token_start
00:8773 E900            	   535:   sbc #<INBUF
00:8775 85B0            	   536:   sta find_from
00:8777 B00B            	   537:   bcs editor_list_got_from_point ; delimiter should be a single byte
                        	   538: 
                        	   539: editor_find_bug:
00:8779 A214            	   540:   ldx #20  ; ERROR: bug
00:877B 4C6497          	   541:   jmp ERROR
                        	   542: 
00:877E 4CDE86          	   543: find_string_too_longJ         jmp find_string_too_long
00:8781 4C1287          	   544: editor_no_closing_delimiterJ  jmp editor_no_closing_delimiter
                        	   545: 
                        	   546: editor_list_got_from_point:
                        	   547: 
                        	   548: ;
                        	   549: ;  Now find closing delimiter by a simple scan as we will pass who-knows-what on the way
                        	   550: ;
00:8784 A6B0            	   551:   ldx find_from
                        	   552: editor_find_second_delimiter_loop:
00:8786 E8              	   553:   inx
00:8787 BD0002          	   554:   lda INBUF,x
00:878A F0F5            	   555:   beq editor_no_closing_delimiterJ
00:878C C90A            	   556:   cmp #NL
00:878E F0F1            	   557:   beq editor_no_closing_delimiterJ
00:8790 C5B4            	   558:   cmp find_delimiter
00:8792 D0F2            	   559:   bne editor_find_second_delimiter_loop
                        	   560: 
                        	   561: ;
                        	   562: ;  found the closing delimiter
                        	   563: ;
00:8794 86B1            	   564:   stx find_to
00:8796 E4B0            	   565:   cpx find_from
00:8798 F093            	   566:   beq editor_no_find_string
                        	   567: ;
                        	   568: ;  maximum 127 byte find string
                        	   569: ;
00:879A 38              	   570:   sec
00:879B A5B1            	   571:   lda find_to
00:879D E5B0            	   572:   sbc find_from
00:879F 30DD            	   573:   bmi find_string_too_longJ
00:87A1 85B3            	   574:   sta find_len    ; save for later memory move calculations
                        	   575: 
00:87A3 A920            	   576:   lda #EFLAG_REPLACE
00:87A5 25BC            	   577:   and editor_flags
00:87A7 F02A            	   578:   beq editor_find_get_flags
                        	   579: 
                        	   580: ;
                        	   581: ;  doing a replace - find second delimiter
                        	   582: ;
                        	   583: 
00:87A9 86B5            	   584:   stx rep_from
00:87AB E6B5            	   585:   inc rep_from    ; get past the delimiter
                        	   586: 
                        	   587: editor_find_third_delimiter_loop:
00:87AD E8              	   588:   inx
00:87AE BD0002          	   589:   lda INBUF,x
00:87B1 F0CE            	   590:   beq editor_no_closing_delimiterJ
00:87B3 C90A            	   591:   cmp #NL
00:87B5 F0CA            	   592:   beq editor_no_closing_delimiterJ
00:87B7 C5B4            	   593:   cmp find_delimiter
00:87B9 D0F2            	   594:   bne editor_find_third_delimiter_loop
                        	   595: 
                        	   596: ;
                        	   597: ;  found the replacement closing delimiter
00:87BB 86B6            	   598:   stx rep_to
                        	   599: 
                        	   600: ;
                        	   601: ;  maximum 127 byte replacement string
                        	   602: ;
00:87BD 38              	   603:   sec
00:87BE A5B6            	   604:   lda rep_to
00:87C0 E5B5            	   605:   sbc rep_from
00:87C2 30BA            	   606:   bmi find_string_too_longJ
                        	   607: 
                        	   608: ;
                        	   609: ;  now find the signed difference between the find and replace strings
                        	   610: ;  namely: (rep_to - rep_from) - find_len
                        	   611: ;
00:87C4 64B8            	   612:   stz rep_diff+1
00:87C6 38              	   613:   sec
00:87C7 A5B6            	   614:   lda rep_to
00:87C9 E5B5            	   615:   sbc rep_from
00:87CB E5B3            	   616:   sbc find_len
00:87CD 85B7            	   617:   sta rep_diff
00:87CF 1002            	   618:   bpl editor_find_get_flags
00:87D1 C6B8            	   619:   dec rep_diff+1   ; make that $ff
                        	   620: 
                        	   621: ;
                        	   622: ; get any find/replace flags
                        	   623: ;
                        	   624: editor_find_get_flags:
00:87D3 64BD            	   625:   stz find_flags
                        	   626: 
                        	   627: editor_flags_loop:
00:87D5 E8              	   628:   inx
00:87D6 BD0002          	   629:   lda INBUF,X
00:87D9 C90A            	   630:   cmp #NL
00:87DB F042            	   631:   beq editor_list_fix_target_string
00:87DD 204A81          	   632:   jsr isspace
00:87E0 B0F3            	   633:   bcs editor_flags_loop
00:87E2 20C48F          	   634:   jsr MAKE_UPPER
00:87E5 C951            	   635:   cmp #'Q'
00:87E7 D00A            	   636:   bne editor_flags1
00:87E9 A904            	   637:   lda #FFLAG_QUIET
00:87EB 04BD            	   638:   tsb find_flags
00:87ED A980            	   639:   lda #EFLAG_NO_LINE_NUMBERS
00:87EF 04BC            	   640:   tsb editor_flags
00:87F1 80E2            	   641:   bra editor_flags_loop
                        	   642: editor_flags1:
00:87F3 C947            	   643:   cmp #'G'
00:87F5 D006            	   644:   bne editor_flags2
00:87F7 A902            	   645:   lda #FFLAG_GLOBAL
00:87F9 04BD            	   646:   tsb find_flags
00:87FB 80D8            	   647:   bra editor_flags_loop
                        	   648: editor_flags2:
00:87FD C949            	   649:   cmp #'I'
00:87FF D006            	   650:   bne editor_flags3
00:8801 A901            	   651:   lda #FFLAG_IGNORE_CASE
00:8803 04BD            	   652:   tsb find_flags
00:8805 80CE            	   653:   bra editor_flags_loop
                        	   654: editor_flags3:
00:8807 A911            	   655:   lda #<bad_flag_message
00:8809 A288            	   656:   ldx #>bad_flag_message
00:880B 202682          	   657:   jsr print
00:880E 4CCC82          	   658:   jmp main_prompt
                        	   659: 
00:8811 556E6B6E6F776E20	   660: bad_flag_message: asciiz "Unknown flag\n"
00:8819 666C61670A
00:881E 00
                        	   661: 
                        	   662: editor_list_fix_target_string:
                        	   663: 
00:881F A901            	   664:   lda #FFLAG_IGNORE_CASE
00:8821 25BD            	   665:   and find_flags
00:8823 F015            	   666:   beq editor_list_get_on_with_it
                        	   667: 
                        	   668: ;
                        	   669: ;  for case insensitive compare force target to be upper case
                        	   670: ;
00:8825 A6B0            	   671:   ldx find_from
                        	   672: editor_list_fixup_loop:
00:8827 E4B1            	   673:   cpx find_to
00:8829 F00F            	   674:   beq editor_list_get_on_with_it
00:882B BD0002          	   675:   lda INBUF,X
00:882E 20C48F          	   676:   jsr MAKE_UPPER
00:8831 9D0002          	   677:   sta INBUF,X
00:8834 E8              	   678:   inx
00:8835 80F0            	   679:   bra editor_list_fixup_loop
                        	   680: 
                        	   681: 
                        	   682: editor_list_not_find:
                        	   683: ;
                        	   684: ;  we should have no more tokens now
                        	   685: ;
00:8837 203886          	   686:   jsr editor_check_no_more
                        	   687: 
                        	   688: editor_list_get_on_with_it:
                        	   689: ;
                        	   690: ;  make sure current_line is correct
                        	   691: ;
00:883A A59E            	   692:   lda from_line
00:883C 85A2            	   693:   sta current_line
00:883E A59F            	   694:   lda from_line+1
00:8840 85A3            	   695:   sta current_line+1
                        	   696: 
                        	   697: ;
                        	   698: ;  exit immediately if no source from here on
                        	   699: ;
00:8842 A000            	   700:   ldy #0
00:8844 B123            	   701:   lda (PCODE),Y
00:8846 D003            	   702:   bne editor_list_have_source
00:8848 4C6689          	   703:   jmp editor_list_done
                        	   704: 
                        	   705: editor_list_have_source:
00:884B A901            	   706:   lda #EFLAG_SHOW_LINE
00:884D 04BC            	   707:   tsb editor_flags
00:884F 8006            	   708:   bra editor_list_loop
                        	   709: 
00:8851 4C6689          	   710: editor_list_doneJ jmp editor_list_done
00:8854 4C2889          	   711: editor_list_no_line_numberJ jmp editor_list_no_line_number
                        	   712: 
                        	   713: editor_list_loop:
00:8857 A58B            	   714:   lda serial_in_byte_received
00:8859 C903            	   715:   cmp  #KEY_ABORT
00:885B F021            	   716:   beq  editor_list_aborted
00:885D 64BB            	   717:   stz  found_this_line
00:885F A000            	   718:   ldy #0
00:8861 B123            	   719:   lda (PCODE),Y
00:8863 F0EC            	   720:   beq editor_list_doneJ
00:8865 A5BC            	   721:   lda editor_flags
00:8867 2901            	   722:   and #EFLAG_SHOW_LINE
00:8869 F0E9            	   723:   beq  editor_list_no_line_numberJ
00:886B A5BC            	   724:   lda editor_flags
00:886D 2908            	   725:   and #EFLAG_SAVE
00:886F D0E3            	   726:   bne editor_list_no_line_numberJ
                        	   727: ;
                        	   728: ;  At this exact point we know we are at the start of a line
                        	   729: ;  and we aren't doing a Save. Now, if we are doing a Find then
                        	   730: ;  we need to know if this line (from here to the next newline)
                        	   731: ;  matches our find string, and if not, to skip it
                        	   732: 
00:8871 A940            	   733:   lda #EFLAG_SUPPRESS_NEWLINE
00:8873 14BC            	   734:   trb editor_flags              ; we can show newlines now
                        	   735: 
00:8875 A5BC            	   736:   lda editor_flags
00:8877 2910            	   737:   and #EFLAG_FIND
00:8879 D010            	   738:   bne editor_find_or_replacing
                        	   739: 
00:887B 4C1B89          	   740:   jmp  editor_list_not_finding
                        	   741: 
                        	   742: ;
                        	   743: ;  Here when Ctrl+C pressed
                        	   744: ;
                        	   745: editor_list_aborted:
00:887E A232            	   746:   ldx #50
00:8880 A000            	   747:   ldy #0
00:8882 20D590          	   748:   jsr delay   ; 50 ms delay to allow serial to settle
00:8885 202892          	   749:   jsr CROUT
00:8888 4C6689          	   750:   jmp editor_list_done
                        	   751: 
                        	   752: editor_find_or_replacing:
                        	   753: 
                        	   754: ;
                        	   755: ;  here if finding or replacing
                        	   756: ;
                        	   757: 
00:888B A900            	   758:   lda #0
                        	   759: 
                        	   760: ;
                        	   761: ;  we come back here for multiple replacements with a new starting pos
                        	   762: ;
                        	   763: editor_replacement_loop:
00:888D 85B2            	   764:   sta find_pos    ; searching line from beginning (or not, if doing a multiple replace)
                        	   765: 
                        	   766: editor_find_loop:
00:888F A6B0            	   767:   ldx find_from   ; out target string position in INBUF
00:8891 A4B2            	   768:   ldy find_pos    ; where we are on the line
                        	   769: editor_find_inner_loop:
00:8893 E4B1            	   770:   cpx find_to     ; reached end of target, found the string!
00:8895 F037            	   771:   beq editor_find_found_it
00:8897 B123            	   772:   lda (PCODE),Y
00:8899 C90A            	   773:   cmp #NL
00:889B F01B            	   774:   beq editor_find_no_match ; hit end of line without matching
                        	   775: 
                        	   776: ;
                        	   777: ;  force to upper-case if required
                        	   778: ;
00:889D 48              	   779:   pha
00:889E A901            	   780:   lda #FFLAG_IGNORE_CASE
00:88A0 25BD            	   781:   and find_flags
00:88A2 F006            	   782:   beq editor_find_case_sensitive
00:88A4 68              	   783:   pla
00:88A5 20C48F          	   784:   jsr MAKE_UPPER
00:88A8 8001            	   785:   bra editor_find_test_character
                        	   786: editor_find_case_sensitive:
00:88AA 68              	   787:   pla
                        	   788: editor_find_test_character:
00:88AB DD0002          	   789:   cmp INBUF,X     ; does source byte match target byte?
00:88AE D004            	   790:   bne editor_find_skip_this
00:88B0 C8              	   791:   iny
00:88B1 E8              	   792:   inx
00:88B2 80DF            	   793:   bra editor_find_inner_loop
                        	   794: 
                        	   795: editor_find_skip_this:
00:88B4 E6B2            	   796:   inc find_pos
00:88B6 D0D7            	   797:   bne editor_find_loop  ; if it wraps, give up
                        	   798: 
                        	   799: ;
                        	   800: ;  we are at the newline without a match, increment PCODE to match
                        	   801: ;  where we are and go onto newline processing
                        	   802: ;
                        	   803: editor_find_no_match:
00:88B8 A5BB            	   804:    lda found_this_line
00:88BA D05F            	   805:    bne editor_list_not_finding
00:88BC 18              	   806:    clc
00:88BD 98              	   807:    tya
00:88BE 6523            	   808:    adc PCODE
00:88C0 8523            	   809:    sta PCODE
00:88C2 A900            	   810:    lda #0
00:88C4 6524            	   811:    adc PCODE+1
00:88C6 8524            	   812:    sta PCODE+1
00:88C8 A940            	   813:    lda #EFLAG_SUPPRESS_NEWLINE
00:88CA 04BC            	   814:    tsb editor_flags
00:88CC 8062            	   815:    bra editor_newline_processing
                        	   816: 
                        	   817: ;
                        	   818: ;  here when find succeeded
                        	   819: ;
                        	   820: editor_find_found_it:
00:88CE E6B9            	   821:   inc find_count
00:88D0 D002            	   822:   bne editor_find_found_it1
00:88D2 E6BA            	   823:   inc find_count+1
                        	   824: editor_find_found_it1:
00:88D4 A901            	   825:   lda #1
00:88D6 85BB            	   826:   sta found_this_line
00:88D8 A920            	   827:   lda #EFLAG_REPLACE
00:88DA 25BC            	   828:   and editor_flags
00:88DC D00E            	   829:   bne editor_do_the_replace
                        	   830: 
00:88DE A902            	   831:   lda #FFLAG_GLOBAL
00:88E0 25BD            	   832:   and find_flags
00:88E2 F037            	   833:   beq editor_list_not_finding   ; one replace is enough
                        	   834: 
                        	   835: ;
                        	   836: ;  add the find length to Y (moving past what we just found)
                        	   837: ;
                        	   838: ;
00:88E4 18              	   839:   clc
00:88E5 A5B2            	   840:   lda find_pos
00:88E7 65B3            	   841:   adc find_len
00:88E9 4C8D88          	   842:   jmp editor_replacement_loop
                        	   843: 
                        	   844: ;
                        	   845: ;  here when replacing
                        	   846: ;
                        	   847: editor_do_the_replace:
00:88EC A908            	   848:   lda #FLAG_VALID_COMPILE   ; compile or assemble no longer valid
00:88EE 0910            	   849:   ora #FLAG_VALID_ASSEMBLE
00:88F0 14BE            	   850:   trb system_flags
                        	   851: 
00:88F2 A5B7            	   852:   lda rep_diff ; same length?
00:88F4 F003            	   853:   beq editor_easy_replace
00:88F6 4C8689          	   854:   jmp editor_do_replace
                        	   855: 
                        	   856: editor_easy_replace:
00:88F9 A4B2            	   857:   ldy find_pos
00:88FB A6B5            	   858:   ldx rep_from
                        	   859: editor_easy_replace_loop:
00:88FD E4B6            	   860:   cpx rep_to
00:88FF F009            	   861:   beq editor_easy_replace_done
00:8901 BD0002          	   862:   lda INBUF,x
00:8904 9123            	   863:   sta (PCODE),y
00:8906 C8              	   864:   iny
00:8907 E8              	   865:   inx
00:8908 D0F3            	   866:   bne editor_easy_replace_loop  ; keep replacing
                        	   867: 
                        	   868: editor_easy_replace_done:
00:890A A902            	   869:   lda #FFLAG_GLOBAL
00:890C 25BD            	   870:   and find_flags
00:890E F00B            	   871:   beq editor_list_not_finding   ; one replace is enough
                        	   872: 
                        	   873: ;
                        	   874: ;  add the replacement length to Y (moving past what we just replaced)
                        	   875: ;   the replacement length is rep_to - rep_from
                        	   876: ;
00:8910 18              	   877:   clc
00:8911 A5B2            	   878:   lda find_pos
00:8913 65B6            	   879:   adc rep_to
00:8915 38              	   880:   sec
00:8916 E5B5            	   881:   sbc rep_from
00:8918 4C8D88          	   882:   jmp editor_replacement_loop
                        	   883: 
                        	   884: ;
                        	   885: ;
                        	   886: ;  display the line number
                        	   887: ;
                        	   888: editor_list_not_finding:
00:891B A901            	   889:   lda #EFLAG_SHOW_LINE
00:891D 14BC            	   890:   trb editor_flags      ; cancel flag until next newline
00:891F A980            	   891:   lda #EFLAG_NO_LINE_NUMBERS
00:8921 25BC            	   892:   and editor_flags
00:8923 D003            	   893:   bne editor_list_no_line_number
00:8925 201E8C          	   894:   jsr show_current_line_number
                        	   895: 
                        	   896: editor_list_no_line_number:
00:8928 A000            	   897:   ldy  #0
00:892A B123            	   898:   lda  (PCODE),Y
00:892C C90A            	   899:   cmp  #NL
00:892E D022            	   900:   bne  editor_list_not_newline
                        	   901: 
                        	   902: editor_newline_processing:
00:8930 A901            	   903:   lda  #EFLAG_SHOW_LINE
00:8932 04BC            	   904:   tsb  editor_flags
00:8934 E6A2            	   905:   inc  current_line
00:8936 D002            	   906:   bne  editor_list_check_to_line
00:8938 E6A3            	   907:   inc  current_line+1
                        	   908: 
                        	   909: ;
                        	   910: ;  see if we hit the wanted "to" line
                        	   911: ;
                        	   912: editor_list_check_to_line:
00:893A A5A3            	   913:   lda  current_line+1
00:893C C5A1            	   914:   cmp  to_line+1
00:893E 900A            	   915:   bcc  editor_list_check_to_line_ok
00:8940 D024            	   916:   bne  editor_list_done
00:8942 A5A2            	   917:   lda  current_line
00:8944 C5A0            	   918:   cmp  to_line
00:8946 9002            	   919:   bcc  editor_list_check_to_line_ok
00:8948 D01C            	   920:   bne  editor_list_done
                        	   921: 
                        	   922: editor_list_check_to_line_ok:
                        	   923: 
00:894A A940            	   924:   lda #EFLAG_SUPPRESS_NEWLINE
00:894C 25BC            	   925:   and editor_flags
00:894E D00D            	   926:   bne editor_list_skip_newline
00:8950 A90A            	   927:   lda #NL   ; put the newline back
                        	   928: 
                        	   929: ;
                        	   930: ;  just echo the character, and increment the memory address
                        	   931: ;
                        	   932: editor_list_not_newline:
00:8952 AA              	   933:   tax
00:8953 A904            	   934:   lda #FFLAG_QUIET
00:8955 25BD            	   935:   and find_flags
00:8957 D004            	   936:   bne editor_list_skip_newline
00:8959 8A              	   937:   txa
00:895A 208592          	   938:   jsr PRCHAR
                        	   939: 
                        	   940: editor_list_skip_newline:
00:895D E623            	   941:   inc PCODE
00:895F D002            	   942:   bne editor_list_loopJ
00:8961 E624            	   943:   inc PCODE+1
                        	   944: 
                        	   945: editor_list_loopJ:
00:8963 4C5788          	   946:   jmp editor_list_loop
                        	   947: 
                        	   948: editor_list_done:
00:8966 202892          	   949:   jsr CROUT
                        	   950: 
00:8969 A5B9            	   951:   lda find_count
00:896B 05BA            	   952:   ora find_count+1
00:896D F014            	   953:   beq  editor_list_completely_done
00:896F A5B9            	   954:   lda find_count
00:8971 8500            	   955:   sta REG
00:8973 A5BA            	   956:   lda find_count+1
00:8975 8501            	   957:   sta REG+1
00:8977 6402            	   958:   stz REGB
00:8979 205291          	   959:   jsr display_in_decimal
00:897C A993            	   960:   lda #<found_message
00:897E A286            	   961:   ldx #>found_message
00:8980 202682          	   962:   jsr print
                        	   963: 
                        	   964: editor_list_completely_done:
00:8983 4CCC82          	   965:   jmp main_prompt
                        	   966: 
                        	   967: ;
                        	   968: ;  This if for replacing when the lengths differ
                        	   969: ;
                        	   970: editor_do_replace:
                        	   971: ;
                        	   972: ; add our current find_pos to PCODE to get where we are in memory
                        	   973: ;
00:8986 18              	   974:   clc
00:8987 A523            	   975:   lda  PCODE
00:8989 48              	   976:   pha   ; save where we currently are
00:898A 65B2            	   977:   adc  find_pos
00:898C 85A6            	   978:   sta  mem_move_src
00:898E A524            	   979:   lda  PCODE+1
00:8990 48              	   980:   pha
00:8991 6900            	   981:   adc  #0
00:8993 85A7            	   982:   sta  mem_move_src+1
                        	   983: 
                        	   984: ;
                        	   985: ;  add the source string length as we don't need to copy that
                        	   986: ;
00:8995 18              	   987:   clc
00:8996 A5A6            	   988:   lda mem_move_src
00:8998 65B3            	   989:   adc find_len
00:899A 85A6            	   990:   sta mem_move_src
00:899C A5A7            	   991:   lda mem_move_src+1
00:899E 6900            	   992:   adc #0
00:89A0 85A7            	   993:   sta mem_move_src+1
                        	   994: 
                        	   995: ;
                        	   996: ;  the move destination is the source plus the replacement length
                        	   997: ;   (ie. a gap of the difference in bytes)
                        	   998: 
00:89A2 18              	   999:   clc
00:89A3 A5A6            	  1000:   lda mem_move_src
00:89A5 65B7            	  1001:   adc rep_diff
00:89A7 85A8            	  1002:   sta mem_move_dest
00:89A9 A5A7            	  1003:   lda mem_move_src+1
00:89AB 65B8            	  1004:   adc rep_diff+1
00:89AD 85A9            	  1005:   sta mem_move_dest+1
                        	  1006: 
                        	  1007: 
00:89AF 20898C          	  1008:   jsr find_source_end   ; goes into PCODE
                        	  1009: ;
                        	  1010: ;  the length to move will be (the end of the source) - (the start of the move)
                        	  1011: ;
00:89B2 18              	  1012:   clc
00:89B3 A523            	  1013:   lda PCODE
00:89B5 E5A6            	  1014:   sbc mem_move_src
00:89B7 85AA            	  1015:   sta mem_move_len
00:89B9 A524            	  1016:   lda PCODE+1
00:89BB E5A7            	  1017:   sbc mem_move_src+1
00:89BD 85AB            	  1018:   sta mem_move_len+1
                        	  1019: 
00:89BF A5B8            	  1020:   lda rep_diff+1
00:89C1 3005            	  1021:   bmi editor_do_replace_smaller
00:89C3 20A681          	  1022:   jsr moveup      ; replacing with larger string
00:89C6 8003            	  1023:   bra editor_do_replace_copy_done
                        	  1024: 
                        	  1025: editor_do_replace_smaller:
00:89C8 207A81          	  1026:   jsr movedown    ; replacing with smaller string
                        	  1027: 
                        	  1028: editor_do_replace_copy_done:
                        	  1029: ;
                        	  1030: ;  get the current source address back
                        	  1031: ;
00:89CB 68              	  1032:   pla
00:89CC 8524            	  1033:   sta  PCODE+1
00:89CE 68              	  1034:   pla
00:89CF 8523            	  1035:   sta  PCODE
00:89D1 4CF988          	  1036:   jmp  editor_easy_replace    ; now move in new string
                        	  1037: 
                        	  1038: 
00:89D4 456E74657220736F	  1039: load_message asciiz "Enter source, terminate with Esc\n"
00:89DC 757263652C207465
00:89E4 726D696E61746520
00:89EC 7769746820457363
00:89F4 0A
00:89F5 00
                        	  1040: 
                        	  1041: ;--------------------------------------------
                        	  1042: ;  INSERT / LOAD
                        	  1043: ;--------------------------------------------
                        	  1044: editor_load:
                        	  1045: 
00:89F6 A904            	  1046:   lda #EFLAG_LOAD
00:89F8 85BC            	  1047:   sta editor_flags
                        	  1048: 
                        	  1049: editor_insert:
00:89FA 64B0            	  1050:   stz insert_last_char
00:89FC 207785          	  1051:   jsr editor_get_number
00:89FF F015            	  1052:   beq editor_insert_at_start
                        	  1053: 
                        	  1054:   ;
                        	  1055:   ; I really want to insert AFTER this line so I'll add 1 to whatever line number they gave
                        	  1056:   ; To insert at the start use Insert without a line number
                        	  1057:   ;
00:8A01 18              	  1058:   clc
00:8A02 A594            	  1059:   lda token_value
00:8A04 6901            	  1060:   adc #1
00:8A06 85AC            	  1061:   sta this_line
00:8A08 A595            	  1062:   lda token_value+1
00:8A0A 6900            	  1063:   adc #0
00:8A0C 85AD            	  1064:   sta this_line+1
                        	  1065: 
00:8A0E 203886          	  1066:   jsr editor_check_no_more
00:8A11 20558C          	  1067:   jsr find_line    ; find the "from" line address
00:8A14 800E            	  1068:   bra editor_insert_common
                        	  1069: 
                        	  1070: editor_insert_at_start:
00:8A16 A900            	  1071:   lda #<TEXT_START
00:8A18 85AE            	  1072:   sta this_line_addr
00:8A1A A903            	  1073:   lda #>TEXT_START
00:8A1C 85AF            	  1074:   sta this_line_addr+1
00:8A1E A901            	  1075:   lda #1
00:8A20 85A2            	  1076:   sta current_line    ; current line number (1)
00:8A22 64A3            	  1077:   stz current_line+1
                        	  1078: 
                        	  1079: editor_insert_common:
00:8A24 20898C          	  1080:   jsr find_source_end
                        	  1081: 
                        	  1082: ;
                        	  1083: ;  move existing source to end of RAM
                        	  1084: ;
00:8A27 38              	  1085:   sec
00:8A28 A523            	  1086:   lda PCODE
00:8A2A E5AE            	  1087:   sbc this_line_addr
00:8A2C 85AA            	  1088:   sta mem_move_len
00:8A2E A524            	  1089:   lda PCODE+1
00:8A30 E5AF            	  1090:   sbc this_line_addr+1
00:8A32 85AB            	  1091:   sta mem_move_len+1
                        	  1092: 
                        	  1093: ;
                        	  1094: ;  find where to move to
                        	  1095: ;
00:8A34 38              	  1096:   sec
00:8A35 A9FF            	  1097:   lda #<HIGHEST_RAM
00:8A37 E5AA            	  1098:   sbc mem_move_len
00:8A39 85A8            	  1099:   sta mem_move_dest
00:8A3B 85A4            	  1100:   sta insert_limit
00:8A3D A93F            	  1101:   lda #>HIGHEST_RAM
00:8A3F E5AB            	  1102:   sbc mem_move_len+1
00:8A41 85A9            	  1103:   sta mem_move_dest+1
00:8A43 85A5            	  1104:   sta insert_limit+1
                        	  1105: 
                        	  1106: ;
                        	  1107: ;  the source of the move
                        	  1108: ;
00:8A45 A5AE            	  1109:   lda this_line_addr
00:8A47 85A6            	  1110:   sta mem_move_src
00:8A49 A5AF            	  1111:   lda this_line_addr+1
00:8A4B 85A7            	  1112:   sta mem_move_src+1
                        	  1113: 
00:8A4D 20A681          	  1114:   jsr moveup
                        	  1115: 
                        	  1116: ;
                        	  1117: ;  put input at from_line_addr
                        	  1118: ;
                        	  1119: 
00:8A50 A5AE            	  1120:   lda this_line_addr
00:8A52 8523            	  1121:   sta PCODE
00:8A54 A5AF            	  1122:   lda this_line_addr+1
00:8A56 8524            	  1123:   sta PCODE+1
                        	  1124: 
00:8A58 A9D4            	  1125:   lda  #<load_message
00:8A5A A289            	  1126:   ldx  #>load_message
00:8A5C 202682          	  1127:   jsr  print
                        	  1128: 
                        	  1129: ;
                        	  1130: ;  show the first line number
                        	  1131: ;
                        	  1132: 
00:8A5F A901            	  1133:   lda #EFLAG_SHOW_LINE
00:8A61 04BC            	  1134:   tsb editor_flags
                        	  1135: 
                        	  1136: editor_insert_loop:
00:8A63 A904            	  1137:   lda #EFLAG_LOAD         ; no line numbers on load
00:8A65 25BC            	  1138:   and editor_flags
00:8A67 D00B            	  1139:   bne editor_insert_no_line_number
                        	  1140: 
00:8A69 A5BC            	  1141:   lda editor_flags
00:8A6B 2901            	  1142:   and #EFLAG_SHOW_LINE
00:8A6D F005            	  1143:   beq  editor_insert_no_line_number
                        	  1144: ;
                        	  1145: ;  display the line number
                        	  1146: ;
                        	  1147: 
00:8A6F 64BC            	  1148:   stz editor_flags      ; cancel flag until next newline
00:8A71 201E8C          	  1149:   jsr show_current_line_number
                        	  1150: 
                        	  1151: editor_insert_no_line_number:
00:8A74 A000            	  1152:   ldy  #0
00:8A76 2079C8          	  1153:   jsr  CHRIN
00:8A79 C90D            	  1154:   cmp  #CR       ; carriage-return?
00:8A7B F0F7            	  1155:   beq  editor_insert_no_line_number ; yes, ignore
00:8A7D C91B            	  1156:   cmp  #END_EDITOR_INPUT  ; Esc?
00:8A7F F051            	  1157:   beq  editor_insert_done
00:8A81 C903            	  1158:   cmp  #KEY_ABORT         ; let them stop inputting with Ctrl+C
00:8A83 F04D            	  1159:   beq  editor_insert_done
00:8A85 C908            	  1160:   cmp  #BACKSPACE
00:8A87 F02A            	  1161:   beq  editor_insert_backspace
00:8A89 C90A            	  1162:   cmp  #NL
00:8A8B D00C            	  1163:   bne  editor_insert_not_newline
00:8A8D A901            	  1164:   lda  #EFLAG_SHOW_LINE
00:8A8F 04BC            	  1165:   tsb  editor_flags
00:8A91 A90A            	  1166:   lda  #NL            ; get the newline back
00:8A93 E6A2            	  1167:   inc  current_line
00:8A95 D002            	  1168:   bne  editor_insert_not_newline
00:8A97 E6A3            	  1169:   inc  current_line+1
                        	  1170: editor_insert_not_newline
00:8A99 9123            	  1171:   sta  (PCODE),Y
00:8A9B 85B0            	  1172:   sta  insert_last_char       ; for detecting final newline
00:8A9D E623            	  1173:   inc  PCODE
00:8A9F D002            	  1174:   bne  editor_insert_loop1
00:8AA1 E624            	  1175:   inc  PCODE+1
                        	  1176: 
                        	  1177: editor_insert_loop1:
00:8AA3 A5A5            	  1178:   lda  insert_limit+1
00:8AA5 C524            	  1179:   cmp  PCODE+1
00:8AA7 B0BA            	  1180:   bcs  editor_insert_loop   ; carry is SET if we didn't borrow
00:8AA9 D054            	  1181:   bne  editor_too_full
00:8AAB A5A4            	  1182:   lda  insert_limit
00:8AAD C523            	  1183:   cmp  PCODE
00:8AAF F04E            	  1184:   beq  editor_too_full
00:8AB1 80B0            	  1185:   bra  editor_insert_loop
                        	  1186: 
                        	  1187: ;
                        	  1188: ;  backspace reduces our pointer by one, unless we are at the start
                        	  1189: ;
                        	  1190: editor_insert_backspace:
00:8AB3 A523            	  1191:   lda PCODE
00:8AB5 C5AE            	  1192:   cmp this_line_addr
00:8AB7 D006            	  1193:   bne editor_insert_backspace_not_at_start
00:8AB9 A524            	  1194:   lda PCODE+1
00:8ABB C5AF            	  1195:   cmp this_line_addr+1
00:8ABD F0A4            	  1196:   beq editor_insert_loop    ; at start, ignore backspace
                        	  1197: 
                        	  1198: editor_insert_backspace_not_at_start:
00:8ABF 38              	  1199:   sec                       ; move source pointer back one
00:8AC0 A523            	  1200:   lda PCODE
00:8AC2 E901            	  1201:   sbc #1
00:8AC4 8523            	  1202:   sta PCODE
00:8AC6 A524            	  1203:   lda PCODE+1
00:8AC8 E900            	  1204:   sbc #0
00:8ACA 8524            	  1205:   sta PCODE+1
00:8ACC B123            	  1206:   lda (PCODE),y
00:8ACE 85B0            	  1207:   sta insert_last_char       ; this is now the last character we inserted
00:8AD0 8091            	  1208:   bra editor_insert_loop
                        	  1209: 
                        	  1210: editor_insert_done:
00:8AD2 A5B0            	  1211:   lda insert_last_char
00:8AD4 F00E            	  1212:   beq editor_insert_done_with_newline   ; nothing got inserted at all
00:8AD6 C90A            	  1213:   cmp #NL
00:8AD8 F00A            	  1214:   beq editor_insert_done_with_newline  ; skip inserting a newline if we just got a newline
                        	  1215: ;
                        	  1216: ;  They finished inserting, but without a newline ... add one
                        	  1217: ;
00:8ADA A90A            	  1218:   lda #NL
00:8ADC 9123            	  1219:   sta (PCODE),Y
00:8ADE E623            	  1220:   inc PCODE
00:8AE0 D002            	  1221:   bne editor_insert_done_with_newline
00:8AE2 E624            	  1222:   inc PCODE+1
                        	  1223: 
                        	  1224: ;
                        	  1225: ;  they are done - copy the rest back to the end of where they just inserted
                        	  1226: ;
                        	  1227: editor_insert_done_with_newline:
                        	  1228: 
00:8AE4 64BE            	  1229:   stz system_flags     ; compile is not valid any more
                        	  1230: 
00:8AE6 A523            	  1231:   lda PCODE
00:8AE8 85A8            	  1232:   sta mem_move_dest
00:8AEA A524            	  1233:   lda PCODE+1
00:8AEC 85A9            	  1234:   sta mem_move_dest+1
                        	  1235: 
00:8AEE A5A4            	  1236:   lda insert_limit
00:8AF0 85A6            	  1237:   sta mem_move_src
00:8AF2 A5A5            	  1238:   lda insert_limit+1
00:8AF4 85A7            	  1239:   sta mem_move_src+1
                        	  1240: 
00:8AF6 207A81          	  1241:   jsr movedown
                        	  1242: 
00:8AF9 202892          	  1243:   jsr CROUT   ; put a newline after the ESC character
00:8AFC 4CCC82          	  1244:   jmp main_prompt
                        	  1245: 
                        	  1246: editor_too_full:
00:8AFF A92A            	  1247:   lda #<memory_full
00:8B01 A28B            	  1248:   ldx #>memory_full
00:8B03 202682          	  1249:   jsr print
                        	  1250: ;
                        	  1251: ;  consume input so it isn't mistaken for a command
                        	  1252: ;
                        	  1253: editor_too_full_loop:
00:8B06 2079C8          	  1254:   jsr CHRIN
00:8B09 C91B            	  1255:   cmp #END_EDITOR_INPUT
00:8B0B D0F9            	  1256:   bne editor_too_full_loop
                        	  1257: ;
                        	  1258: ;  another message, they may miss the first one during a bulk load
                        	  1259: ;
00:8B0D A945            	  1260:   lda #<memory_filled_up
00:8B0F A28B            	  1261:   ldx #>memory_filled_up
00:8B11 202682          	  1262:   jsr print
00:8B14 4CD28A          	  1263:   jmp editor_insert_done
                        	  1264: 
00:8B17 4E6F2072616E6765	  1265: editor_no_lines  asciiz "No range supplied\n"
00:8B1F 20737570706C6965
00:8B27 640A
00:8B29 00
00:8B2A 0A0A4D656D6F7279	  1266: memory_full      asciiz "\n\nMemory full - press Esc\n"
00:8B32 2066756C6C202D20
00:8B3A 7072657373204573
00:8B42 630A
00:8B44 00
00:8B45 0A0A4E6F20726F6F	  1267: memory_filled_up asciiz "\n\nNo room for source during load/input\n\n"
00:8B4D 6D20666F7220736F
00:8B55 7572636520647572
00:8B5D 696E67206C6F6164
00:8B65 2F696E7075740A0A
00:8B6D 00
                        	  1268: 
                        	  1269: ;--------------------------------------------
                        	  1270: ;  DELETE
                        	  1271: ;--------------------------------------------
                        	  1272: editor_delete:
                        	  1273: ;
                        	  1274: ;  default to no lines
                        	  1275: ;
00:8B6E 649E            	  1276:   stz from_line
00:8B70 649F            	  1277:   stz from_line+1
00:8B72 64A0            	  1278:   stz to_line
00:8B74 64A1            	  1279:   stz to_line+1
                        	  1280: 
00:8B76 64B9            	  1281:   stz find_count      ; delete count in this case
00:8B78 64BA            	  1282:   stz find_count+1
                        	  1283: 
00:8B7A 204886          	  1284:   jsr editor_get_range
00:8B7D 203886          	  1285:   jsr editor_check_no_more
                        	  1286: ;
                        	  1287: ; if no lines given, give up
                        	  1288: ;
00:8B80 A59E            	  1289:   lda from_line
00:8B82 059F            	  1290:   ora from_line+1
00:8B84 D00A            	  1291:   bne editor_delete_have_range
00:8B86 A917            	  1292:   lda #<editor_no_lines
00:8B88 A28B            	  1293:   ldx #>editor_no_lines
00:8B8A 202682          	  1294:   jsr print
00:8B8D 4CCC82          	  1295:   jmp  main_prompt
                        	  1296: 
                        	  1297: editor_delete_have_range:
00:8B90 A59E            	  1298:   lda from_line
00:8B92 85AC            	  1299:   sta this_line
00:8B94 A59F            	  1300:   lda from_line+1
00:8B96 85AD            	  1301:   sta this_line+1
00:8B98 20558C          	  1302:   jsr find_line       ; find the "from" line address
00:8B9B A5AE            	  1303:   lda this_line_addr  ; that becomes the destination of the move
00:8B9D 85A8            	  1304:   sta mem_move_dest
00:8B9F A5AF            	  1305:   lda this_line_addr+1
00:8BA1 85A9            	  1306:   sta mem_move_dest+1
00:8BA3 64AA            	  1307:   stz mem_move_len
00:8BA5 64AB            	  1308:   stz mem_move_len+1
                        	  1309: ;
                        	  1310: ;  now we'll work our way up until we get to the to_line, however we'll
                        	  1311: ;  add one because we want the final address to actually be the start of
                        	  1312: ;  the NEXT line
                        	  1313: ;
00:8BA7 18              	  1314:   clc
00:8BA8 A5A0            	  1315:   lda to_line
00:8BAA 6901            	  1316:   adc #1
00:8BAC 85AC            	  1317:   sta this_line
00:8BAE A5A1            	  1318:   lda to_line+1
00:8BB0 6900            	  1319:   adc #0
00:8BB2 85AD            	  1320:   sta this_line+1
00:8BB4 20638C          	  1321:   jsr find_line_loop    ; find the "to" line address
00:8BB7 A5AE            	  1322:   lda this_line_addr  ; that becomes the destination of the move
00:8BB9 85A6            	  1323:   sta mem_move_src
00:8BBB A5AF            	  1324:   lda this_line_addr+1
00:8BBD 85A7            	  1325:   sta mem_move_src+1
                        	  1326: 
                        	  1327: ;
                        	  1328: ;  count how many lines we delete by counting newlines from
                        	  1329: ;   mem_move_dest to mem_move_src
                        	  1330: ;
                        	  1331: 
00:8BBF A5A8            	  1332:   lda mem_move_dest
00:8BC1 8523            	  1333:   sta PCODE
00:8BC3 A5A9            	  1334:   lda mem_move_dest+1
00:8BC5 8524            	  1335:   sta PCODE+1
00:8BC7 A000            	  1336:   ldy #0
                        	  1337: 
                        	  1338: editor_delete_line_count_loop:
00:8BC9 A523            	  1339:   lda PCODE
00:8BCB C5A6            	  1340:   cmp mem_move_src
00:8BCD D006            	  1341:   bne editor_delete_line_count_not_done
00:8BCF A524            	  1342:   lda PCODE+1
00:8BD1 C5A7            	  1343:   cmp mem_move_src+1
00:8BD3 F014            	  1344:   beq editor_delete_line_count_done
                        	  1345: 
                        	  1346: editor_delete_line_count_not_done:
00:8BD5 B123            	  1347:   lda (PCODE),y
00:8BD7 C90A            	  1348:   cmp #NL
00:8BD9 D006            	  1349:   bne editor_delete_line_count_not_newline
00:8BDB E6B9            	  1350:   inc find_count
00:8BDD D002            	  1351:   bne editor_delete_line_count_not_newline
00:8BDF E6BA            	  1352:   inc find_count+1
                        	  1353: editor_delete_line_count_not_newline:
00:8BE1 E623            	  1354:   inc PCODE
00:8BE3 D0E4            	  1355:   bne editor_delete_line_count_loop
00:8BE5 E624            	  1356:   inc PCODE+1
00:8BE7 80E0            	  1357:   bra editor_delete_line_count_loop
                        	  1358: 
                        	  1359: ;
                        	  1360: ;  now find where the source ends
                        	  1361: ;  PCODE will now be at the first line to not be deleted
                        	  1362: ;
                        	  1363: editor_delete_line_count_done:
                        	  1364: 
00:8BE9 20918C          	  1365:   jsr find_source_end_loop
00:8BEC 38              	  1366:   sec
00:8BED A523            	  1367:   lda PCODE
00:8BEF E5AE            	  1368:   sbc this_line_addr
00:8BF1 85AA            	  1369:   sta mem_move_len
00:8BF3 A524            	  1370:   lda PCODE+1
00:8BF5 E5AF            	  1371:   sbc this_line_addr+1
00:8BF7 85AB            	  1372:   sta mem_move_len+1
00:8BF9 207A81          	  1373:   jsr movedown  ; that should do it
                        	  1374: 
00:8BFC A5B9            	  1375:   lda find_count
00:8BFE 8500            	  1376:   sta REG
00:8C00 A5BA            	  1377:   lda find_count+1
00:8C02 8501            	  1378:   sta REG+1
00:8C04 6402            	  1379:   stz REGB
00:8C06 205291          	  1380:   jsr display_in_decimal
00:8C09 A913            	  1381:   lda #<lines_deleted_message
00:8C0B A28C            	  1382:   ldx #>lines_deleted_message
00:8C0D 202682          	  1383:   jsr print
00:8C10 4CCC82          	  1384:   jmp main_prompt
                        	  1385: 
00:8C13 2064656C65746564	  1386: lines_deleted_message asciiz " deleted.\n"
00:8C1B 2E0A
00:8C1D 00
                        	  1387: 
                        	  1388: ;--------------------------------------------
                        	  1389: ;  show current line number with leading spaces
                        	  1390: ;--------------------------------------------
                        	  1391: show_current_line_number:
                        	  1392: ;
                        	  1393: ;  get the line number into REG ready for printing
                        	  1394: ;
00:8C1E A5A2            	  1395:   lda current_line
00:8C20 8500            	  1396:   sta REG
00:8C22 A6A3            	  1397:   ldx current_line+1
00:8C24 8601            	  1398:   stx REG+1
00:8C26 A000            	  1399:   ldy #0        ; count of leading spaces
00:8C28 8402            	  1400:   sty REGB
00:8C2A E003            	  1401:   cpx #>1000    ; if the number is >= 1000 don't print any spaces
00:8C2C 9006            	  1402:   bcc line_number_lt_1000
00:8C2E D013            	  1403:   bne line_number_output_spaces
00:8C30 C9E8            	  1404:   cmp #<1000
00:8C32 B00F            	  1405:   bcs line_number_output_spaces
                        	  1406: line_number_lt_1000:
00:8C34 C8              	  1407:   iny           ; output one space
00:8C35 E000            	  1408:   cpx  #0       ; if line number > 255 then one space is all we need
00:8C37 D00A            	  1409:   bne  line_number_output_spaces
00:8C39 C964            	  1410:   cmp  #100     ; if line number >= 100 then one space is all we need
00:8C3B B006            	  1411:   bcs  line_number_output_spaces
00:8C3D C8              	  1412:   iny           ; output two spaces
00:8C3E C90A            	  1413:   cmp  #10      ; if line number >= 10 then two spaces are all we need
00:8C40 B001            	  1414:   bcs  line_number_output_spaces
00:8C42 C8              	  1415:   iny           ; output three spaces
                        	  1416: line_number_output_spaces:
00:8C43 C000            	  1417:   cpy #0            ; leading spaces in front of line number
00:8C45 F008            	  1418:   beq  show_current_line_number_done
00:8C47 5A              	  1419:   phy
00:8C48 20B392          	  1420:   jsr  PUTSP      ; output the space
00:8C4B 7A              	  1421:   ply
00:8C4C 88              	  1422:   dey             ; count them
00:8C4D D0F4            	  1423:   bne  line_number_output_spaces  ; more spaces to go
                        	  1424: show_current_line_number_done:
00:8C4F 205291          	  1425:   jsr  display_in_decimal    ; now the actual number
00:8C52 4CB392          	  1426:   jmp  PUTSP      ; and a space after it
                        	  1427: 
                        	  1428: ;--------------------------------------------
                        	  1429: ;  find_line
                        	  1430: ;
                        	  1431: ;  finds address of this_line in memory - returns in this_line_addr
                        	  1432: ;--------------------------------------------
                        	  1433: find_line:
00:8C55 A901            	  1434:   lda #1
00:8C57 85A2            	  1435:   sta current_line    ; current line number (1)
00:8C59 64A3            	  1436:   stz current_line+1
00:8C5B A900            	  1437:   lda #<TEXT_START   ; start at start of source
00:8C5D 85AE            	  1438:   sta this_line_addr
00:8C5F A903            	  1439:   lda #>TEXT_START
00:8C61 85AF            	  1440:   sta this_line_addr+1
                        	  1441: find_line_loop:
00:8C63 A000            	  1442:   ldy #0
00:8C65 A5A2            	  1443:   lda current_line
00:8C67 C5AC            	  1444:   cmp this_line
00:8C69 D007            	  1445:   bne find_line_next
00:8C6B A5A3            	  1446:   lda current_line+1
00:8C6D C5AD            	  1447:   cmp this_line+1
00:8C6F D001            	  1448:   bne find_line_next
00:8C71 60              	  1449:   rts
                        	  1450: find_line_next:
00:8C72 B1AE            	  1451:   lda (this_line_addr),Y
00:8C74 F012            	  1452:   beq find_line_eof
00:8C76 C90A            	  1453:   cmp #NL
00:8C78 D006            	  1454:   bne find_line_same_line
00:8C7A E6A2            	  1455:   inc current_line       ; add 1 to our line number counter
00:8C7C D002            	  1456:   bne find_line_same_line
00:8C7E E6A3            	  1457:   inc current_line+1
                        	  1458: find_line_same_line:
00:8C80 E6AE            	  1459:   inc this_line_addr     ; onto next address - which means that a newline
00:8C82 D0DF            	  1460:   bne find_line_loop     ; will actually end up being the start of the new
00:8C84 E6AF            	  1461:   inc this_line_addr+1   ; line, which is what we want
00:8C86 80DB            	  1462:   bra find_line_loop
                        	  1463: find_line_eof:           ; we are pointing to 0x00 - make that the address
00:8C88 60              	  1464:   rts
                        	  1465: 
                        	  1466: 
                        	  1467: 
                        	  1468: ;***********************************************
                        	  1469: ; Find text end
                        	  1470: ;***********************************************
                        	  1471: find_source_end:
00:8C89 A900            	  1472:   lda  #<TEXT_START        ; start at start of source
00:8C8B 8523            	  1473:   sta  PCODE
00:8C8D A903            	  1474:   lda  #>TEXT_START
00:8C8F 8524            	  1475:   sta  PCODE+1
                        	  1476: find_source_end_loop =  *
00:8C91 A000            	  1477:   ldy  #0
00:8C93 B123            	  1478:   lda  (PCODE),Y             ; keep going until 0x00 indicates end of source
00:8C95 F008            	  1479:   beq  find_source_end_wrap
00:8C97 E623            	  1480:   inc  PCODE
00:8C99 D0F6            	  1481:   bne  find_source_end_loop
00:8C9B E624            	  1482:   inc  PCODE+1
00:8C9D 80F2            	  1483:   bra  find_source_end_loop
                        	  1484: ;
                        	  1485: ;  include final 0x00
                        	  1486: ;
                        	  1487: find_source_end_wrap =  *
00:8C9F E623            	  1488:   inc  PCODE
00:8CA1 D002            	  1489:   bne  find_source_end_done
00:8CA3 E624            	  1490:   inc  PCODE+1
                        	  1491: find_source_end_done =  *
00:8CA5 60              	  1492:   rts
                        	  1493: 
                        	  1494: ;
                        	  1495: ;  testing BRK handling
                        	  1496: ;
00:8CA6 0A526573756D6564	  1497: brk_resumed asciiz "\nResumed after BRK\n"
00:8CAE 2061667465722042
00:8CB6 524B0A
00:8CB9 00
                        	  1498: 
                        	  1499: editor_test:
00:8CBA A912            	  1500:   lda #$12
00:8CBC A223            	  1501:   ldx #$23
00:8CBE A042            	  1502:   ldy #$42
00:8CC0 C912            	  1503:   cmp #$12
00:8CC2 00              	  1504:   brk
00:8CC3 99              	  1505:   dfb $99   ; break number
00:8CC4 A9A6            	  1506:   lda #<brk_resumed
00:8CC6 A28C            	  1507:   ldx #>brk_resumed
00:8CC8 202682          	  1508:   jsr print
00:8CCB 60              	  1509:   rts
                        	  1510: 
                        	  1511: ;
                        	  1512: ;  memory dump
                        	  1513: ;
                        	  1514: editor_memory:
00:8CCC 204F85          	  1515:   jsr editor_default_range
00:8CCF A902            	  1516:   lda #EFLAG_ALLOW_ZERO_FROM
00:8CD1 85BC            	  1517:   sta editor_flags
00:8CD3 204886          	  1518:   jsr editor_get_range
00:8CD6 203886          	  1519:   jsr editor_check_no_more
00:8CD9 64A2            	  1520:   stz current_line      ; count of bytes shown
00:8CDB A59E            	  1521:   lda from_line
00:8CDD 85AE            	  1522:   sta this_line_addr
00:8CDF A59F            	  1523:   lda from_line+1
00:8CE1 85AF            	  1524:   sta this_line_addr+1
                        	  1525: 
                        	  1526: editor_memory_loop:
00:8CE3 A58B            	  1527:   lda serial_in_byte_received
00:8CE5 C903            	  1528:   cmp  #KEY_ABORT
00:8CE7 F050            	  1529:   beq  editor_memory_aborted
                        	  1530: 
00:8CE9 A5A2            	  1531:   lda current_line
00:8CEB D017            	  1532:   bne editor_memory_loop1
                        	  1533: ;
                        	  1534: ;  show address
                        	  1535: ;
00:8CED A924            	  1536:   lda #'$'
00:8CEF 20AF93          	  1537:   jsr COUT
00:8CF2 A59F            	  1538:   lda from_line+1
00:8CF4 209D92          	  1539:   jsr PRBYTE
00:8CF7 A59E            	  1540:   lda from_line
00:8CF9 209D92          	  1541:   jsr PRBYTE
00:8CFC A93A            	  1542:   lda #':'
00:8CFE 20AF93          	  1543:   jsr COUT
00:8D01 20B392          	  1544:   jsr PUTSP
                        	  1545: editor_memory_loop1:
00:8D04 A000            	  1546:   ldy #0
00:8D06 B19E            	  1547:   lda (from_line),Y
00:8D08 209D92          	  1548:   jsr PRBYTE
00:8D0B 20B392          	  1549:   jsr PUTSP
00:8D0E E6A2            	  1550:   inc current_line
00:8D10 E69E            	  1551:   inc from_line
00:8D12 D002            	  1552:   bne editor_memory_loop2
00:8D14 E69F            	  1553:   inc from_line+1
                        	  1554: editor_memory_loop2:
00:8D16 A59F            	  1555:   lda from_line+1
00:8D18 C5A1            	  1556:   cmp to_line+1
00:8D1A 900A            	  1557:   bcc editor_memory_loop3   ; less than
00:8D1C D018            	  1558:   bne editor_memory_done    ; greater than
00:8D1E A59E            	  1559:   lda from_line             ; equal, so try low-order byte
00:8D20 C5A0            	  1560:   cmp to_line
00:8D22 9002            	  1561:   bcc editor_memory_loop3   ; less than
00:8D24 D010            	  1562:   bne editor_memory_done    ; greater than
                        	  1563: editor_memory_loop3:
00:8D26 A5A2            	  1564:   lda current_line
00:8D28 C910            	  1565:   cmp #16
00:8D2A 90B7            	  1566:   bcc editor_memory_loop
00:8D2C 20B392          	  1567:   jsr PUTSP
00:8D2F 203F8D          	  1568:   jsr editor_memory_show_ascii
00:8D32 64A2            	  1569:   stz current_line      ; count of bytes shown
00:8D34 80AD            	  1570:   bra editor_memory_loop
                        	  1571: 
                        	  1572: editor_memory_done:
00:8D36 203F8D          	  1573:   jsr editor_memory_show_ascii
                        	  1574: editor_memory_aborted:
00:8D39 202892          	  1575:   jsr CROUT
00:8D3C 4CCC82          	  1576:   jmp  main_prompt
                        	  1577: 
                        	  1578: editor_memory_show_ascii:
                        	  1579: ;
                        	  1580: ;  now the ASCII equivalents
                        	  1581: ;
00:8D3F A000            	  1582:   ldy #0
                        	  1583: editor_memory_ascii:
00:8D41 B1AE            	  1584:   lda (this_line_addr),Y
00:8D43 C920            	  1585:   cmp #$20
00:8D45 B002            	  1586:   bcs editor_memory_not_control
00:8D47 8004            	  1587:   bra editor_memory_show_dot
                        	  1588: editor_memory_not_control:
00:8D49 C97F            	  1589:   cmp #$7F
00:8D4B 9002            	  1590:   bcc editor_memory_not_high
                        	  1591: editor_memory_show_dot
00:8D4D A92E            	  1592:   lda #'.'
                        	  1593: editor_memory_not_high:
00:8D4F 20AF93          	  1594:   jsr COUT
00:8D52 20B392          	  1595:   jsr PUTSP
00:8D55 C8              	  1596:   iny
00:8D56 C6A2            	  1597:   dec current_line
00:8D58 D0E7            	  1598:   bne editor_memory_ascii
                        	  1599: ;
                        	  1600: ;  adjust the ASCII printing address
                        	  1601: ;
00:8D5A A59E            	  1602:   lda from_line
00:8D5C 85AE            	  1603:   sta this_line_addr
00:8D5E A59F            	  1604:   lda from_line+1
00:8D60 85AF            	  1605:   sta this_line_addr+1
                        	  1606: 
00:8D62 202892          	  1607:   jsr CROUT
00:8D65 60              	  1608:   rts
                        	  1609: 
                        	  1610: 
                        	  1611: 
                        	  1612: 
00:8D66 4164647220507265	  1613: symbol_table_message asciiz "Addr Prev L  T Dsp  Ar Da Ln Name\n"
00:8D6E 76204C2020542044
00:8D76 7370202041722044
00:8D7E 61204C6E204E616D
00:8D86 650A
00:8D88 00
                        	  1614: 
                        	  1615: editor_symbol_table_list  = *
00:8D89 A966            	  1616:   lda #<symbol_table_message
00:8D8B A28D            	  1617:   ldx #>symbol_table_message
00:8D8D 202682          	  1618:   jsr print
                        	  1619: 
00:8D90 A532            	  1620:   lda  ENDSYM+1    ; get the end of the symbol table
00:8D92 8541            	  1621:   sta  SYMITM+1    ; make it the current symbol
00:8D94 A531            	  1622:   lda  ENDSYM
00:8D96 800B            	  1623:   bra  ST_SYMTBL_LIST_CHECK
                        	  1624: 
                        	  1625: ST_SYMTBL_LIST_NEXT =  *
00:8D98 A000            	  1626:   ldy  #SYMPRV
00:8D9A B140            	  1627:   lda  (SYMITM),Y
00:8D9C AA              	  1628:   tax
00:8D9D C8              	  1629:   iny
00:8D9E B140            	  1630:   lda  (SYMITM),Y
00:8DA0 8541            	  1631:   sta  SYMITM+1   ; previous link
00:8DA2 8A              	  1632:   txa
                        	  1633: ;
                        	  1634: ;  go to the previous symbol table item
                        	  1635: ;
                        	  1636: ST_SYMTBL_LIST_CHECK     =  *
00:8DA3 8540            	  1637:   sta  SYMITM
00:8DA5 C9FF            	  1638:   cmp  #<SYMBOL_TABLE_START
00:8DA7 D009            	  1639:   bne  ST_SYMTBL_LIST_LINE
00:8DA9 A541            	  1640:   lda  SYMITM+1
00:8DAB C93F            	  1641:   cmp  #>SYMBOL_TABLE_START
00:8DAD D003            	  1642:   bne  ST_SYMTBL_LIST_LINE       ; more to go
00:8DAF 4C388E          	  1643:   jmp  ST_SYMTBL_LIST_DONE       ; finished if symitm and symitm+1 are both zero
                        	  1644: 
                        	  1645: ST_SYMTBL_LIST_LINE = *
00:8DB2 A541            	  1646:   lda  SYMITM+1
00:8DB4 209D92          	  1647:   jsr  PRBYTE
00:8DB7 A540            	  1648:   lda  SYMITM
00:8DB9 209D92          	  1649:   jsr  PRBYTE
00:8DBC A920            	  1650:   lda  #' '
00:8DBE 208592          	  1651:   jsr  PRCHAR
00:8DC1 A001            	  1652:   ldy  #SYMPRV+1
00:8DC3 B140            	  1653:   lda  (SYMITM),Y
00:8DC5 209D92          	  1654:   jsr  PRBYTE
00:8DC8 88              	  1655:   dey
00:8DC9 B140            	  1656:   lda  (SYMITM),Y
00:8DCB 209D92          	  1657:   jsr  PRBYTE
00:8DCE A920            	  1658:   lda  #' '
00:8DD0 208592          	  1659:   jsr  PRCHAR
00:8DD3 A002            	  1660:   ldy  #SYMLVL
00:8DD5 B140            	  1661:   lda  (SYMITM),Y  ; level
00:8DD7 209D92          	  1662:   jsr  PRBYTE
00:8DDA A920            	  1663:   lda  #' '
00:8DDC 208592          	  1664:   jsr  PRCHAR
00:8DDF A003            	  1665:   ldy  #SYMTYP
00:8DE1 B140            	  1666:   lda  (SYMITM),Y  ; type
00:8DE3 208592          	  1667:   jsr  PRCHAR
00:8DE6 A920            	  1668:   lda  #' '
00:8DE8 208592          	  1669:   jsr  PRCHAR
00:8DEB A004            	  1670:   ldy  #SYMDSP
00:8DED C8              	  1671:   iny
00:8DEE B140            	  1672:   lda  (SYMITM),Y  ; displacement
00:8DF0 209D92          	  1673:   jsr  PRBYTE
00:8DF3 88              	  1674:   dey
00:8DF4 B140            	  1675:   lda  (SYMITM),Y  ; displacement
00:8DF6 209D92          	  1676:   jsr  PRBYTE
00:8DF9 A920            	  1677:   lda  #' '
00:8DFB 208592          	  1678:   jsr  PRCHAR
00:8DFE A006            	  1679:   ldy  #SYMARG
00:8E00 B140            	  1680:   lda  (SYMITM),Y  ; argument count
00:8E02 209D92          	  1681:   jsr  PRBYTE
00:8E05 A920            	  1682:   lda  #' '
00:8E07 208592          	  1683:   jsr  PRCHAR
00:8E0A A008            	  1684:   ldy  #SYMDAT
00:8E0C B140            	  1685:   lda  (SYMITM),Y  ; data type
00:8E0E 209D92          	  1686:   jsr  PRBYTE
00:8E11 A920            	  1687:   lda  #' '
00:8E13 208592          	  1688:   jsr  PRCHAR
00:8E16 A009            	  1689:   ldy  #SYMLEN
00:8E18 B140            	  1690:   lda  (SYMITM),Y  ; length
00:8E1A 48              	  1691:   pha
00:8E1B 209D92          	  1692:   jsr  PRBYTE
00:8E1E A920            	  1693:   lda  #' '
00:8E20 208592          	  1694:   jsr  PRCHAR
00:8E23 A00A            	  1695:   ldy  #SYMNAM
00:8E25 68              	  1696:   pla
00:8E26 AA              	  1697:   tax
                        	  1698: ST_SYMTBL_LIST_NAME = *
00:8E27 B140            	  1699:   lda  (SYMITM),Y  ; name
00:8E29 5A              	  1700:   phy
00:8E2A 208592          	  1701:   jsr  PRCHAR
00:8E2D 7A              	  1702:   ply
00:8E2E C8              	  1703:   iny
00:8E2F CA              	  1704:   dex
00:8E30 D0F5            	  1705:   bne ST_SYMTBL_LIST_NAME
00:8E32 202892          	  1706:   jsr CROUT
00:8E35 4C988D          	  1707:   jmp ST_SYMTBL_LIST_NEXT
                        	  1708: 
                        	  1709: ST_SYMTBL_LIST_DONE = *
                        	  1710: 
00:8E38 4CCC82          	  1711:   jmp main_prompt
                        	  1712: 
                        	  1713: 
00:8E3B 446F6E650A      	  1714: recover_done asciiz "Done\n"
00:8E40 00
00:8E41 4E6F74206E656564	  1715: recover_not_needed asciiz "Not needed\n"
00:8E49 65640A
00:8E4C 00
                        	  1716: 
                        	  1717: ;
                        	  1718: ; Recover: if the first byte of the source is 0x00, change it to a space
                        	  1719: ;
                        	  1720: editor_recover:
00:8E4D A900            	  1721:   lda  #<TEXT_START
00:8E4F 8540            	  1722:   sta  FROM
00:8E51 A903            	  1723:   lda  #>TEXT_START
00:8E53 8541            	  1724:   sta  FROM+1
00:8E55 A000            	  1725:   ldy  #0
00:8E57 B140            	  1726:   lda  (FROM),Y
00:8E59 D00E            	  1727:   bne  editor_recover_not_needed
00:8E5B A920            	  1728:   lda  #' '
00:8E5D 9140            	  1729:   sta  (FROM),Y
00:8E5F A93B            	  1730:   lda #<recover_done
00:8E61 A28E            	  1731:   ldx #>recover_done
00:8E63 202682          	  1732:   jsr print
00:8E66 4CCC82          	  1733:   jmp main_prompt
                        	  1734: 
                        	  1735: editor_recover_not_needed:
00:8E69 A941            	  1736:   lda #<recover_not_needed
00:8E6B A28E            	  1737:   ldx #>recover_not_needed
00:8E6D 202682          	  1738:   jsr print
00:8E70 4CCC82          	  1739:   jmp main_prompt
                        	  1740: 
                        	  1741: 
                        	  1742: editor_debug:
00:8E73 A901            	  1743:   lda #1
00:8E75 8549            	  1744:   sta  DBGFLG
00:8E77 852E            	  1745:   sta  DCODE
00:8E79 4C6B93          	  1746:   jmp  CHK_RUN
                        	  1747: 
                        	  1748: editor_trace:
00:8E7C A980            	  1749:   lda  #$80
00:8E7E 8549            	  1750:   sta  DBGFLG
00:8E80 852E            	  1751:   sta  DCODE
00:8E82 4C6B93          	  1752:   jmp  CHK_RUN
                        	  1753: 
                        	  1754: 
                        	  1755: editor_info  = *
00:8E85 20F58E          	  1756:   jsr show_source_start
00:8E88 20CD8E          	  1757:   jsr show_source_end
00:8E8B 208390          	  1758:   jsr crc_source
00:8E8E 4CCC82          	  1759:   jmp main_prompt
                        	  1760: 
                        	  1761: editor_compile:
00:8E91 A900            	  1762:   lda  #0
00:8E93 8542            	  1763:   sta  SYNTAX
00:8E95 4CB0B9          	  1764:   jmp  COMPIL
                        	  1765: 
                        	  1766: editor_syntax:
00:8E98 A901            	  1767:   lda #1
00:8E9A 8542            	  1768:   sta  SYNTAX
00:8E9C 4CB0B9          	  1769:   jmp  COMPIL
                        	  1770: 
                        	  1771: editor_run:
00:8E9F A900            	  1772:   lda  #0
00:8EA1 8549            	  1773:   sta  DBGFLG
00:8EA3 852E            	  1774:   sta  DCODE
00:8EA5 4C6B93          	  1775:   jmp  CHK_RUN
                        	  1776: 
                        	  1777:   ;
                        	  1778: show_symbol_table_end:
00:8EA8 A910            	  1779:   lda  #<symbol_table_ended_message    ; Symbol table ended at
00:8EAA A293            	  1780:   ldx  #>symbol_table_ended_message
00:8EAC 202682          	  1781:   jsr  print
00:8EAF A532            	  1782:   lda  ENDSYM+1
00:8EB1 209D92          	  1783:   jsr  PRBYTE
00:8EB4 A531            	  1784:   lda  ENDSYM
00:8EB6 205293          	  1785:   jsr  PRBYTECR
00:8EB9 60              	  1786:   rts
                        	  1787: 
                        	  1788: 
00:8EBA 536F757263652065	  1789: source_ended_message asciiz "Source ends   at $"
00:8EC2 6E64732020206174
00:8ECA 2024
00:8ECC 00
                        	  1790: show_source_end:
00:8ECD A9BA            	  1791:   lda #<source_ended_message
00:8ECF A28E            	  1792:   ldx #>source_ended_message
00:8ED1 202682          	  1793:   jsr print
00:8ED4 20898C          	  1794:   jsr find_source_end
00:8ED7 A524            	  1795:   lda PCODE+1
00:8ED9 209D92          	  1796:   jsr PRBYTE
00:8EDC A523            	  1797:   lda PCODE
00:8EDE 205293          	  1798:   jsr PRBYTECR
00:8EE1 60              	  1799:   rts
                        	  1800: 
00:8EE2 536F757263652073	  1801: source_starts_message asciiz "Source starts at $"    ; source starts at
00:8EEA 7461727473206174
00:8EF2 2024
00:8EF4 00
                        	  1802: show_source_start:
00:8EF5 A9E2            	  1803:   lda #<source_starts_message
00:8EF7 A28E            	  1804:   ldx #>source_starts_message
00:8EF9 202682          	  1805:   jsr print
00:8EFC A903            	  1806:   lda #>TEXT_START
00:8EFE 209D92          	  1807:   jsr PRBYTE
00:8F01 A900            	  1808:   lda #<TEXT_START
00:8F03 205293          	  1809:   jsr PRBYTECR
00:8F06 60              	  1810:   rts
                        	  1811: 
                        	  1812: editor_assemble:
00:8F07 4C4298          	  1813:   jmp ASSEMBLE
                        	  1814: 
                        	  1815: 
                        	  1816: 
                        	  1817: 
                        	  1818: ;16-bit number comparison...
                        	  1819: ;
                        	  1820: ;         lda #>x               ; MSB of 1st number
                        	  1821: ;         cmp #>y               ; MSB of 2nd number
                        	  1822: ;         bcc islower           ; X < Y
                        	  1823: ;
                        	  1824: ;         bne ishigher          ; X > Y
                        	  1825: ;
                        	  1826: ;         lda #<x               ; LSB of 1st number
                        	  1827: ;         cmp #<y               ; LSB of 2nd number
                        	  1828: ;         bcc islower           ; X < Y
                        	  1829: ;
                        	  1830: ;         beq issame            ; X = Y
                        	  1831: ;
                        	  1832: ;         bne ishigher          ; X > Y
                        	  1833: ;
                        	  1834: ;
                        	  1835: 

Source: "gpascal.asm"
                        	   175:   .include "utilities.inc"

Source: "utilities.inc"
                        	     1: ;
                        	     2: ;  function to look up a handler for a word (eg. assembler directive)
                        	     3: ;
                        	     4: ;  word in SRCE
                        	     5: ;
                        	     6: ;  table of words/handlers in DEST
                        	     7: ;
                        	     8: ;  length of word in A
                        	     9: ;
                        	    10: ;  see makeHandler for making the table
                        	    11: ;
                        	    12: ;  Basically:
                        	    13: ;    asciiz "foo"
                        	    14: ;    word   foo_handler
                        	    15: ;
                        	    16: ;  In other words:
                        	    17: ;    makeHandler "foo",foo_handler
                        	    18: ;
                        	    19: ;  Returns with carry set if no match, otherwise calls the handler which should clear carry
                        	    20: ;
                        	    21: 
                        	    22: handlerLookup:
00:8F0A 8598            	    23:   sta token_work    ; save length
                        	    24: 
                        	    25: ;
                        	    26: ;  find the length of the word
                        	    27: ;
                        	    28: handler_loop:
00:8F0C A000            	    29:   ldy #0
00:8F0E B103            	    30:   lda (DEST),y
00:8F10 F036            	    31:   beq handlers_done
                        	    32: handler_find_length:
00:8F12 B103            	    33:   lda (DEST),y
00:8F14 F005            	    34:   beq handler_found_length
00:8F16 C8              	    35:   iny
00:8F17 F02F            	    36:   beq handlers_done   ; sanity clause
00:8F19 80F7            	    37:   bra handler_find_length
                        	    38: handler_found_length:
                        	    39: 
                        	    40: ;  lda #'i'
                        	    41: ;  jsr ass_debug_point
                        	    42: 
00:8F1B C498            	    43:   cpy token_work
00:8F1D F010            	    44:   beq handler_same_length
                        	    45: ;
                        	    46: ;  not the same length, or no match on the string
                        	    47: ;
                        	    48: handler_next:
00:8F1F 98              	    49:   tya
00:8F20 18              	    50:   clc
00:8F21 6903            	    51:   adc #3  ; skip the 0x00 and the execution address
00:8F23 6503            	    52:   adc DEST
00:8F25 8503            	    53:   sta DEST
00:8F27 A504            	    54:   lda DEST+1
00:8F29 6900            	    55:   adc #0
00:8F2B 8504            	    56:   sta DEST+1
00:8F2D 80DD            	    57:   bra handler_loop
                        	    58: 
                        	    59: handler_same_length:
                        	    60: 
                        	    61: ;  lda #'j'
                        	    62: ;  jsr ass_debug_point
                        	    63: 
00:8F2F 5A              	    64:   phy  ; save the length
00:8F30 202D92          	    65:   jsr COMSTL
00:8F33 F003            	    66:   beq  handler_found_directive
00:8F35 7A              	    67:   ply
00:8F36 80E7            	    68:   bra handler_next
                        	    69: handler_found_directive:
00:8F38 7A              	    70:   ply  ; get the length back
00:8F39 C8              	    71:   iny  ; skip past the 0x00 byte
00:8F3A B103            	    72:   lda (DEST),y
00:8F3C 8599            	    73:   sta token_work+1
00:8F3E C8              	    74:   iny
00:8F3F B103            	    75:   lda (DEST),y
00:8F41 859A            	    76:   sta token_work+2
00:8F43 204A8F          	    77:   jsr call_handler
00:8F46 18              	    78:   clc
00:8F47 60              	    79:   rts
                        	    80: 
                        	    81: handlers_done:
                        	    82: ;  lda #'h'
                        	    83: ;  jsr ass_debug_point
00:8F48 38              	    84:   sec     ; error flag
00:8F49 60              	    85:   rts
                        	    86: 
                        	    87: call_handler:
                        	    88: ;  lda #'g'
                        	    89: ;  jsr ass_debug_point
                        	    90: 
00:8F4A 6C9900          	    91:   jmp (token_work+1)   ; do handler - it will RTS for us
                        	    92: 
                        	    93: 
                        	    94: ;
                        	    95: ;  function to look up a handler for a word on a partial match (eg. editor command)
                        	    96: ;
                        	    97: ;  word in SRCE
                        	    98: ;
                        	    99: ;  table of words/handlers in DEST - in UPPER CASE
                        	   100: ;
                        	   101: ;  length of word in A
                        	   102: ;
                        	   103: ;  see makeHandler for making the table
                        	   104: ;
                        	   105: ;  Basically:
                        	   106: ;    asciiz "FOO"
                        	   107: ;    word   foo_handler
                        	   108: ;
                        	   109: ;  In other words:
                        	   110: ;    makeHandler "FOO",foo_handler
                        	   111: ;
                        	   112: ;  Returns if no match, otherwise jumps to the handler and thus doesn't return
                        	   113: ;
                        	   114: 
                        	   115: partial_handler_Lookup:
00:8F4D 8598            	   116:   sta token_work    ; save length
                        	   117: ;
                        	   118: ;  here for a new table item
                        	   119: ;
                        	   120: partial_handler_next_item:
00:8F4F A000            	   121:   ldy #0
00:8F51 B103            	   122:   lda (DEST),y
00:8F53 F03C            	   123:   beq partial_handler_done
00:8F55 A698            	   124:   ldx token_work        ; source length
                        	   125: partial_handler_next_loop:
                        	   126: ;
                        	   127: ;  ensure the nth character matches until the source runs out
                        	   128: ;
00:8F57 B100            	   129:   lda (SRCE),y
00:8F59 20C48F          	   130:   jsr MAKE_UPPER
00:8F5C D103            	   131:   cmp (DEST),y
00:8F5E D006            	   132:   bne partial_handler_next
00:8F60 C8              	   133:   iny
00:8F61 CA              	   134:   dex     ; one less count
00:8F62 F019            	   135:   beq partial_handler_found_directive ; source has finished and we found the directive
00:8F64 80F1            	   136:   bra partial_handler_next_loop       ; try matching the next one
                        	   137: ;
                        	   138: ;  no match on the string - advance Y to the end of the destination string
                        	   139: ;
                        	   140: partial_handler_next:
00:8F66 B103            	   141:   lda (DEST),y
00:8F68 F003            	   142:   beq partial_handler_next_found_item_length
00:8F6A C8              	   143:   iny
00:8F6B 80F9            	   144:   bra partial_handler_next
                        	   145: partial_handler_next_found_item_length:
00:8F6D 98              	   146:   tya     ; length of the word in the table
00:8F6E 18              	   147:   clc
00:8F6F 6903            	   148:   adc #3  ; skip the 0x00 and the execution address
00:8F71 6503            	   149:   adc DEST
00:8F73 8503            	   150:   sta DEST
00:8F75 A504            	   151:   lda DEST+1
00:8F77 6900            	   152:   adc #0
00:8F79 8504            	   153:   sta DEST+1
00:8F7B 80D2            	   154:   bra partial_handler_next_item
                        	   155: 
                        	   156: partial_handler_found_directive:
00:8F7D B103            	   157:   lda (DEST),y
00:8F7F F003            	   158:   beq partial_handler_skipped_string
00:8F81 C8              	   159:   iny
00:8F82 80F9            	   160:   bra partial_handler_found_directive
                        	   161: partial_handler_skipped_string:
00:8F84 C8              	   162:   iny  ; skip past the 0x00 byte
00:8F85 B103            	   163:   lda (DEST),y
00:8F87 8599            	   164:   sta token_work+1
00:8F89 C8              	   165:   iny
00:8F8A B103            	   166:   lda (DEST),y
00:8F8C 859A            	   167:   sta token_work+2
00:8F8E 6C9900          	   168:   jmp (token_work+1)   ; do partial_partial_handler_ - it will RTS for us
                        	   169: 
                        	   170: partial_handler_done:
00:8F91 60              	   171:   rts
                        	   172: 
                        	   173: ;***********************************************
                        	   174: ; JUMP ON TOKEN
                        	   175: ; X/Y = START OF TABLE
                        	   176: ; END OF TABLE IS A NULL
                        	   177: ; A = TOKEN
                        	   178: ;***********************************************
                        	   179: TKNJMP   =  *
00:8F92 8600            	   180:          stx  REG     ; save table address
00:8F94 8401            	   181:          sty  REG+1
                        	   182: 
00:8F96 20C48F          	   183:          jsr MAKE_UPPER
00:8F99 AA              	   184:          tax          ; save the token
                        	   185: JMP1     =  *
00:8F9A A000            	   186:          ldy  #0
00:8F9C B100            	   187:          lda  (REG),Y
00:8F9E D002            	   188:          bne  JMP2
                        	   189: ; failed to find the token
00:8FA0 8A              	   190:          txa          ; retore the token
00:8FA1 60              	   191:          rts
                        	   192: JMP2     =  *
00:8FA2 8A              	   193:          txa          ; get token back
00:8FA3 D100            	   194:          cmp  (REG),Y
00:8FA5 D010            	   195:          bne  JMP3    ; branch if not found
00:8FA7 68              	   196:          pla
00:8FA8 68              	   197:          pla          ; remove return address for TKNJMP call
00:8FA9 C8              	   198:          iny          ; move Y on to routine address
00:8FAA B100            	   199:          lda  (REG),Y ; get low order byte of routine
00:8FAC 8503            	   200:          sta  REG2
00:8FAE C8              	   201:          iny          ; next byte
00:8FAF B100            	   202:          lda  (REG),Y ; get high order byte
00:8FB1 8504            	   203:          sta  REG2+1
00:8FB3 8A              	   204:          txa          ; get token back
00:8FB4 6C0300          	   205:          jmp  (REG2)  ; go to routine
                        	   206: JMP3     =  *
00:8FB7 A500            	   207:          lda  REG     ; skip this token sequence
00:8FB9 18              	   208:          clc
00:8FBA 6903            	   209:          adc  #3
00:8FBC 8500            	   210:          sta  REG
00:8FBE 90DA            	   211:          bcc  JMP1
00:8FC0 E601            	   212:          inc  REG+1
00:8FC2 80D6            	   213:          bra  JMP1    ; try again
                        	   214: 
                        	   215: ;
                        	   216: 
                        	   217: 
                        	   218: ;***********************************************
                        	   219: ;
                        	   220: ; Case conversion
                        	   221: ;
                        	   222: ;***********************************************
                        	   223: 
                        	   224: 
                        	   225: MAKE_UPPER = *
00:8FC4 C97B            	   226:          CMP  #('z'+1)
00:8FC6 B006            	   227:          BCS  MAKE_UPPER_DONE
00:8FC8 C961            	   228:          CMP  #'a'
00:8FCA 9002            	   229:          BCC  MAKE_UPPER_DONE
00:8FCC E920            	   230:          SBC  #$20  ; make upper-case - we want carry set so there is no borrow
                        	   231: MAKE_UPPER_DONE = *
00:8FCE 60              	   232:          RTS
                        	   233: 
                        	   234: MAKE_LOWER = *
00:8FCF C941            	   235:          CMP  #'A'
00:8FD1 9006            	   236:          BCC  MAKE_LOWER_DONE
00:8FD3 C95B            	   237:          CMP  #('Z'+1)
00:8FD5 B002            	   238:          BCS  MAKE_LOWER_DONE
00:8FD7 6920            	   239:          ADC  #$20  ; make upper-case - we want carry clear so there is no carry
                        	   240: MAKE_LOWER_DONE = *
00:8FD9 60              	   241:          RTS
                        	   242: 
                        	   243: 
                        	   244: ;
                        	   245: ;  generate the next random number
                        	   246: ;
                        	   247: gen_random:
00:8FDA 0609            	   248:     asl random
00:8FDC 260A            	   249:     rol random+1
00:8FDE 260B            	   250:     rol random+2
00:8FE0 260C            	   251:     rol random+3
00:8FE2 9018            	   252:     bcc gen_random1
00:8FE4 A509            	   253:     lda random
00:8FE6 49B7            	   254:     eor #$B7
00:8FE8 8509            	   255:     sta random
00:8FEA A50A            	   256:     lda random+1
00:8FEC 491D            	   257:     eor #$1D
00:8FEE 850A            	   258:     sta random+1
00:8FF0 A50B            	   259:     lda random+2
00:8FF2 49C1            	   260:     eor #$C1
00:8FF4 850B            	   261:     sta random+2
00:8FF6 A50C            	   262:     lda random+3
00:8FF8 4904            	   263:     eor #$04
00:8FFA 850C            	   264:     sta random+3
                        	   265: gen_random1:
00:8FFC 60              	   266:     rts
                        	   267: 
                        	   268: 
                        	   269: 
                        	   270: ;
                        	   271: ;  From: http://www.6502.org/source/integers/crc-more.html
                        	   272: ;
                        	   273: ;   jacksum  -a crc:16,1021,FFFF,false,false,0 -X SOME_FILE
                        	   274: ;
                        	   275: ;   https://jacksum.net/en/index.html
                        	   276: ;
                        	   277: ;   With a starting CRC of $FFFF, the binary string $01 $02 $03 $04 should evaluate to $89C3.
                        	   278: ;
                        	   279: ;   Start at crc_addr, for crc_num bytes
                        	   280: ;
                        	   281: crc16 = *
                        	   282: ;
                        	   283: ;  initialise CRC
                        	   284: ;
00:8FFD A9FF            	   285:   lda #$FF
00:8FFF 8506            	   286:   sta crc_val
00:9001 8507            	   287:   sta crc_val+1
00:9003 A503            	   288:   lda crc_num
00:9005 0504            	   289:   ora crc_num+1
00:9007 F01B            	   290:   beq crc_done
                        	   291: 
                        	   292: ;
                        	   293: ;  here for each byte
                        	   294: ;
                        	   295: crc16_loop  = *
00:9009 A000            	   296:   ldy #0
00:900B B100            	   297:   lda (crc_addr),y  ; get next byte
00:900D 202590          	   298:   jsr crc_byte
                        	   299:   ;
                        	   300:   ;  onto next address
                        	   301:   ;
00:9010 E600            	   302:   inc crc_addr
00:9012 D002            	   303:   bne crc16_next
00:9014 E601            	   304:   inc crc_addr+1       ; Step to next byte
                        	   305: crc16_next:
                        	   306:   ;
                        	   307:   ; now do a 16-bit decrement
                        	   308:   ;
00:9016 A503            	   309:   LDA crc_num
00:9018 D002            	   310:   BNE crc16_skip    ; decrement the high-order byte if we are about to wrap
00:901A C604            	   311:   DEC crc_num+1
                        	   312: crc16_skip:
00:901C C603            	   313:   DEC crc_num       ; decrement the low-order byte
00:901E D0E9            	   314:   BNE crc16_loop    ; not zero, keep going
00:9020 A504            	   315:   LDA crc_num+1     ; are we zero here too?
00:9022 D0E5            	   316:   BNE crc16_loop    ; not yet
                        	   317: 
                        	   318: crc_done:
00:9024 60              	   319:   rts
                        	   320: 
                        	   321: ;
                        	   322: ;  do a CRC of one byte (in A) updating crc_val
                        	   323: ;
                        	   324: crc_byte = *
00:9025 4507            	   325:   eor crc_val+1     ; A contained the data
00:9027 8507            	   326:   sta crc_val+1     ; XOR it into high byte
00:9029 4A              	   327:   lsr               ; right shift A 4 bits
00:902A 4A              	   328:   lsr               ; to make top of x^12 term
00:902B 4A              	   329:   lsr               ; ($1...)
00:902C 4A              	   330:   lsr
00:902D AA              	   331:   tax               ; save it
00:902E 0A              	   332:   asl               ; then make top of x^5 term
00:902F 4506            	   333:   eor crc_val       ; and XOR that with low byte
00:9031 8506            	   334:   sta crc_val       ; and save
00:9033 8A              	   335:   txa               ; restore partial term
00:9034 4507            	   336:   eor crc_val+1     ; and update high byte
00:9036 8507            	   337:   sta crc_val+1     ; and save
00:9038 0A              	   338:   asl               ; left shift three
00:9039 0A              	   339:   asl               ; the rest of the terms
00:903A 0A              	   340:   asl               ; have feedback from x^12
00:903B AA              	   341:   tax               ; save bottom of x^12
00:903C 0A              	   342:   asl               ; left shift two more
00:903D 0A              	   343:   asl               ; watch the carry flag
00:903E 4507            	   344:   eor crc_val+1     ; bottom of x^5 ($..2.)
00:9040 A8              	   345:   tay               ; save high byte
00:9041 8A              	   346:   txa               ; fetch temp value
00:9042 2A              	   347:   rol               ; bottom of x^12, middle of x^5!
00:9043 4506            	   348:   eor crc_val       ; finally update low byte
00:9045 8507            	   349:   sta crc_val+1     ; then swap high and low bytes
00:9047 8406            	   350:   sty crc_val
00:9049 60              	   351:   rts
                        	   352: 
                        	   353: 
                        	   354: crc_helper = *
00:904A 5A              	   355:   phy
00:904B DA              	   356:   phx
00:904C 202590          	   357:   jsr crc_byte
00:904F E603            	   358:   inc crc_num
00:9051 D002            	   359:   bne crc_helper1
00:9053 E604            	   360:   inc crc_num+1
                        	   361: crc_helper1:
00:9055 FA              	   362:   plx
00:9056 7A              	   363:   ply
00:9057 60              	   364:   rts
                        	   365: 
00:9058 536F757263652043	   366: crc_message asciiz "Source CRC       $"               ; source CRC
00:9060 5243202020202020
00:9068 2024
00:906A 00
00:906B 536F75726365206C	   367: source_length_message asciiz "Source length: "    ; source length
00:9073 656E6774683A20
00:907A 00
00:907B 2062797465730A  	   368: bytes_message asciiz " bytes\n"
00:9082 00
                        	   369: 
                        	   370: crc_source = *
00:9083 20898C          	   371:   jsr find_source_end
                        	   372: 
                        	   373: ;
                        	   374: ;  move existing source to end of RAM
                        	   375: ;
00:9086 18              	   376:   clc             ; don't count the final 0x00 byte
00:9087 A523            	   377:   lda PCODE
00:9089 E900            	   378:   sbc #<TEXT_START
00:908B 8503            	   379:   sta crc_num
00:908D A524            	   380:   lda PCODE+1
00:908F E903            	   381:   sbc #>TEXT_START
00:9091 8504            	   382:   sta crc_num+1
                        	   383: ;
                        	   384: ;  Show the length of the source
                        	   385: ;
00:9093 A96B            	   386:   lda #<source_length_message
00:9095 A290            	   387:   ldx #>source_length_message
00:9097 202682          	   388:   jsr print
00:909A A503            	   389:   lda crc_num
00:909C 8500            	   390:   sta REG
00:909E A504            	   391:   lda crc_num+1
00:90A0 8501            	   392:   sta REG+1
00:90A2 6402            	   393:   stz REGB
00:90A4 205291          	   394:   jsr display_in_decimal
00:90A7 A97B            	   395:   lda #<bytes_message
00:90A9 A290            	   396:   ldx #>bytes_message
00:90AB 202682          	   397:   jsr print
                        	   398: 
                        	   399: ;
                        	   400: ;  now the CRC
                        	   401: ;
00:90AE A900            	   402:   lda #<TEXT_START
00:90B0 8500            	   403:   sta crc_addr
00:90B2 A903            	   404:   lda #>TEXT_START
00:90B4 8501            	   405:   sta crc_addr+1
00:90B6 20FD8F          	   406:   jsr crc16
00:90B9 A958            	   407:   lda  #<crc_message            ;  source CRC
00:90BB A290            	   408:   ldx  #>crc_message            ;
00:90BD 202682          	   409:   jsr  print
00:90C0 A507            	   410:   lda crc_val+1
00:90C2 209D92          	   411:   jsr PRBYTE
00:90C5 A506            	   412:   lda crc_val
00:90C7 205293          	   413:   jsr PRBYTECR
00:90CA 60              	   414:   rts
                        	   415: 
                        	   416: 
                        	   417: ;
                        	   418: ;  delays for roughly 1 ms - changes no registers
                        	   419: ;
                        	   420: delay_1ms = *
00:90CB DA              	   421:          phx
00:90CC A26C            	   422:          ldx #108
                        	   423: delay_1ms_loop:
00:90CE EA              	   424:          nop
00:90CF EA              	   425:          nop
00:90D0 CA              	   426:          dex
00:90D1 D0FB            	   427:          bne delay_1ms_loop
00:90D3 FA              	   428:          plx
00:90D4 60              	   429:          rts
                        	   430: 
                        	   431: ;
                        	   432: ; delay for YYXX ms (Y = high-order byte, X = lo-order byte)
                        	   433: ;  maximum delay 0x7FFF, that is 32767 ms
                        	   434: ;  Changes X and Y
                        	   435: ;
                        	   436: delay = *
00:90D5 20CB90          	   437:   jsr delay_1ms
00:90D8 CA              	   438:   dex
00:90D9 D0FA            	   439:   bne delay
00:90DB 88              	   440:   dey
00:90DC 10F7            	   441:   bpl delay
00:90DE 60              	   442:   rts
                        	   443: 
                        	   444: 
                        	   445: ;--------------------------------------------------------------------------
                        	   446: ;
                        	   447: ;  BINARY TO DECIMAL CONVERSION
                        	   448: ;
                        	   449: ;  This works as follows:
                        	   450: ;
                        	   451: ;  1. First the number is checked if it is negative (sign bit set).
                        	   452: ;  2. If so, a "-" is output and the number subtracted from zero to make it positive.
                        	   453: ;  3. Our next step is to set a BCD (binary coded decimal) output area to all zeroes.
                        	   454: ;      In BCD, the number 1234 is actually stored as 0x1234.
                        	   455: ;      With BCD mode turned on in the processor, doing adds results in an early carry
                        	   456: ;      so that numbers add "the decimal way" rather than the binary way.
                        	   457: ;  4. Then we a loop of 24 iterations (one for each bit) which adds the appropriate number from bcd_table
                        	   458: ;      if that bit was set in the original value.
                        	   459: ;  5. The function bcd_unpack is then called to convert the BCD format into ASCII format. It takes each
                        	   460: ;     nibble and adds 0x30 ('0') to it, and saves that in bcd_result.
                        	   461: ;  6. At this stage bcd_result has a 8-digit ASCII number in it.
                        	   462: ;  7. We then skip leading zeroes in bcd_result.
                        	   463: ;  8. Finally the remaining digits in bcd_result are output.
                        	   464: ;
                        	   465: ;
                        	   466: ;   I'm not sure where the idea for this came from. There was no Internet when this was written in 1979
                        	   467: ;   so it is possibly (probably) my own.
                        	   468: ;   My original implementation, although similar, was more complex than this one, which I found at:
                        	   469: ;              http://www.6502.org/source/integers/hex2dec.htm
                        	   470: ;
                        	   471: ;   Other suggestions for binary to decimal conversion I found recently do not employ this method. One
                        	   472: ;   technique (as described by Ben Eater here: https://www.youtube.com/watch?v=v3-a-zqKfgA ) is to
                        	   473: ;   repeatedly divide by 10 and use the remainder as the digit. This has to be done until the result of
                        	   474: ;   the division is zero. Dividing a 3-byte number by 10 on an 8-bit machine is not particularly fast,
                        	   475: ;   as it involves an inner loop of 24 iterations (one for each bit) and this would have to be done for
                        	   476: ;   each digit, so the number of loops of 24 iterations would increase for each digit. Therefore an
                        	   477: ;   8-digit number (like 80000000) would take 144 iterations in the divide loop. Then the digits have to
                        	   478: ;   be reversed because the remainder gives you the low-order decimal digit first.
                        	   479: ;
                        	   480: ;   Another technique is the "Double dabble" routine.
                        	   481: ;
                        	   482: ;     https://en.wikipedia.org/wiki/Double_dabble
                        	   483: ;
                        	   484: ;   The method below seems fairly efficient, as the inner loop only does anything substantial if a
                        	   485: ;     1-bit is detected. Thus large numbers can be produced quite efficiently, however it would be a
                        	   486: ;     bit slower if the input number had a lot of 1-bits set.
                        	   487: ;
                        	   488: ;   Considering that this is only used when outputting to serial, itself a slow process, speed is not
                        	   489: ;   really the issue here.
                        	   490: ;
                        	   491: ;   - Nick Gammon
                        	   492: ;
                        	   493: ;
                        	   494: ;--------------------------------------------------------------------------
                        	   495: ;
                        	   496: ; Converts BCD to ASCII
                        	   497: ;
                        	   498: bcd_unpack:
00:90DF 48              	   499:   pha  ; save the number for later
                        	   500: ;
                        	   501: ;  shift right 4 bits
                        	   502: ;
00:90E0 4A              	   503:   lsr A
00:90E1 4A              	   504:   lsr A
00:90E2 4A              	   505:   lsr A
00:90E3 4A              	   506:   lsr A
00:90E4 0930            	   507:   ora #'0'          ; make printable
00:90E6 9560            	   508:   sta bcd_result,X  ; save in bcd_result
00:90E8 E8              	   509:   inx
00:90E9 68              	   510:   pla               ; get the original character back
00:90EA 290F            	   511:   and #$0F          ; take low-order bits and make printable
00:90EC 0930            	   512:   ora #'0'
00:90EE 9560            	   513:   sta bcd_result,X  ; save in bcd_result
00:90F0 E8              	   514:   inx
00:90F1 60              	   515:   rts               ; done!
                        	   516: 
                        	   517: ;
                        	   518: ;
                        	   519: ; Table for adding into the BCD result.
                        	   520: ;
                        	   521: bcd_table  =  *
00:90F2 00              	   522:   dfb $00,$00,$00,$01   ; 0000001
00:90F3 00
00:90F4 00
00:90F5 01
00:90F6 00              	   523:   dfb $00,$00,$00,$02   ; 0000002
00:90F7 00
00:90F8 00
00:90F9 02
00:90FA 00              	   524:   dfb $00,$00,$00,$04   ; 0000004
00:90FB 00
00:90FC 00
00:90FD 04
00:90FE 00              	   525:   dfb $00,$00,$00,$08   ; 0000008
00:90FF 00
00:9100 00
00:9101 08
00:9102 00              	   526:   dfb $00,$00,$00,$16   ; 0000016
00:9103 00
00:9104 00
00:9105 16
00:9106 00              	   527:   dfb $00,$00,$00,$32   ; 0000032
00:9107 00
00:9108 00
00:9109 32
00:910A 00              	   528:   dfb $00,$00,$00,$64   ; 0000064
00:910B 00
00:910C 00
00:910D 64
00:910E 00              	   529:   dfb $00,$00,$01,$28   ; 0000128
00:910F 00
00:9110 01
00:9111 28
00:9112 00              	   530:   dfb $00,$00,$02,$56   ; 0000256
00:9113 00
00:9114 02
00:9115 56
00:9116 00              	   531:   dfb $00,$00,$05,$12   ; 0000512
00:9117 00
00:9118 05
00:9119 12
00:911A 00              	   532:   dfb $00,$00,$10,$24   ; 0001024
00:911B 00
00:911C 10
00:911D 24
00:911E 00              	   533:   dfb $00,$00,$20,$48   ; 0002048
00:911F 00
00:9120 20
00:9121 48
00:9122 00              	   534:   dfb $00,$00,$40,$96   ; 0004096
00:9123 00
00:9124 40
00:9125 96
00:9126 00              	   535:   dfb $00,$00,$81,$92   ; 0008192
00:9127 00
00:9128 81
00:9129 92
00:912A 00              	   536:   dfb $00,$01,$63,$84   ; 0016384
00:912B 01
00:912C 63
00:912D 84
00:912E 00              	   537:   dfb $00,$03,$27,$68   ; 0032768
00:912F 03
00:9130 27
00:9131 68
00:9132 00              	   538:   dfb $00,$06,$55,$36   ; 0065536
00:9133 06
00:9134 55
00:9135 36
00:9136 00              	   539:   dfb $00,$13,$10,$72   ; 0131072
00:9137 13
00:9138 10
00:9139 72
00:913A 00              	   540:   dfb $00,$26,$21,$44   ; 0262144
00:913B 26
00:913C 21
00:913D 44
00:913E 00              	   541:   dfb $00,$52,$42,$88   ; 0524288
00:913F 52
00:9140 42
00:9141 88
00:9142 01              	   542:   dfb $01,$04,$85,$76   ; 1048576
00:9143 04
00:9144 85
00:9145 76
00:9146 02              	   543:   dfb $02,$09,$71,$52   ; 2097152
00:9147 09
00:9148 71
00:9149 52
00:914A 04              	   544:   dfb $04,$19,$43,$04   ; 4194304
00:914B 19
00:914C 43
00:914D 04
00:914E 08              	   545:   dfb $08,$38,$86,$08   ; 8388608
00:914F 38
00:9150 86
00:9151 08
                        	   546: 
                        	   547: ;--------------------------------------------------------------------------
                        	   548: ; display_in_decimal - start here - VALUE will be zero after this is executed
                        	   549: ;--------------------------------------------------------------------------
                        	   550: 
                        	   551: display_in_decimal  =  *
00:9152 A502            	   552:   lda  VALUE+2
00:9154 1008            	   553:   bpl  bcd_positive
                        	   554: ;
                        	   555: ;  if the number is negative, output a minus sign and make it positive
                        	   556: ;
00:9156 A92D            	   557:   lda  #'-'
00:9158 20AF93          	   558:   jsr  COUT
00:915B 208DAB          	   559:   jsr  exp_unary_minus
                        	   560: ;
                        	   561: ;  number is now positive
                        	   562: ;
                        	   563: bcd_positive:
                        	   564: 
00:915E 207B91          	   565:   jsr binary_to_decimal   ; do the conversion
                        	   566: 
00:9161 A207            	   567:   ldx  #7         ; zero suppress count (always keep the last zero)
00:9163 A000            	   568:   ldy  #0
                        	   569: ;
                        	   570: ;  this is skipping the leading zeroes
                        	   571: ;
                        	   572: bcd_skip_zeroes:
00:9165 B96000          	   573:   lda  bcd_result,Y
00:9168 C930            	   574:   cmp  #'0'
00:916A D004            	   575:   bne  bcd_output_digit
00:916C C8              	   576:   iny
00:916D CA              	   577:   dex
00:916E D0F5            	   578:   bne  bcd_skip_zeroes
                        	   579: ;
                        	   580: ;  now we have a non-zero, start outputting them
                        	   581: ;
                        	   582: ;  Y points to how far we are through bcd_result
                        	   583: ;  X is how many digits to go
                        	   584: ;
                        	   585: bcd_output_digit:
00:9170 B96000          	   586:   lda  bcd_result,Y
00:9173 20AF93          	   587:   jsr  COUT
00:9176 C8              	   588:   iny
00:9177 CA              	   589:   dex
00:9178 10F6            	   590:   bpl  bcd_output_digit
                        	   591: ;
                        	   592: ;  done!
                        	   593: ;
00:917A 60              	   594:   rts
                        	   595: 
                        	   596: ;--------------------------------------------------------------------------
                        	   597: ;
                        	   598: ;  Binary to decimal routine: Converts VALUE into bcd_result (8 digits)
                        	   599: ;
                        	   600: ;  See: http://www.6502.org/source/integers/hex2dec.htm
                        	   601: ;
                        	   602: ;  - VALUE will be zero after this is executed
                        	   603: ;
                        	   604: ;--------------------------------------------------------------------------
                        	   605: binary_to_decimal:
00:917B F8              	   606:   sed                 ; decimal mode for adds below
00:917C 645C            	   607:   stz  bcd_work       ; zero our result area (4 bytes = 8 digits)
00:917E 645D            	   608:   stz  bcd_work+1
00:9180 645E            	   609:   stz  bcd_work+2
00:9182 645F            	   610:   stz  bcd_work+3
                        	   611: 
00:9184 A25C            	   612:   ldx  #(4*23)        ; X points to the start of the highest entry
                        	   613: 
                        	   614: binary_to_decimal_loop:
00:9186 0600            	   615:   asl VALUE      ;  shift out high-order bit into Carry
00:9188 2601            	   616:   rol VALUE+1
00:918A 2602            	   617:   rol VALUE+2
00:918C 901D            	   618:   bcc binary_to_decimal_next  ; if carry clear, no add needs to be done
                        	   619: ;
                        	   620: ;  that bit was set, so add the appropriate BCD number from the table (eg. 1, 2, 4, 8, 16 and so on)
                        	   621: ;
00:918E 18              	   622:   clc
00:918F A55C            	   623:   lda bcd_work
00:9191 7DF590          	   624:   adc bcd_table+3,X
00:9194 855C            	   625:   sta bcd_work
00:9196 A55D            	   626:   lda bcd_work+1
00:9198 7DF490          	   627:   adc bcd_table+2,X
00:919B 855D            	   628:   sta bcd_work+1
00:919D A55E            	   629:   lda bcd_work+2
00:919F 7DF390          	   630:   adc bcd_table+1,X
00:91A2 855E            	   631:   sta bcd_work+2
00:91A4 A55F            	   632:   lda bcd_work+3
00:91A6 7DF290          	   633:   adc bcd_table,X
00:91A9 855F            	   634:   sta bcd_work+3
                        	   635: 
                        	   636: binary_to_decimal_next:
00:91AB CA              	   637:   dex      ; back to the previous table item
00:91AC CA              	   638:   dex
00:91AD CA              	   639:   dex
00:91AE CA              	   640:   dex
00:91AF 10D5            	   641:   bpl binary_to_decimal_loop
00:91B1 D8              	   642:   cld     ; decimal mode off
                        	   643: 
                        	   644: 
                        	   645: ;
                        	   646: ;  convert BCD to ASCII - note that UNPACK increments x by two each time
                        	   647: ;    - the results are in bcd_result - an 8-character field
                        	   648: ;
                        	   649: ;  We unpack the high-order bytes first, naturally
                        	   650: ;
00:91B2 A200            	   651:   ldx  #0
00:91B4 A55F            	   652:   lda  bcd_work+3
00:91B6 20DF90          	   653:   jsr  bcd_unpack
00:91B9 A55E            	   654:   lda  bcd_work+2
00:91BB 20DF90          	   655:   jsr  bcd_unpack
00:91BE A55D            	   656:   lda  bcd_work+1
00:91C0 20DF90          	   657:   jsr  bcd_unpack
00:91C3 A55C            	   658:   lda  bcd_work
00:91C5 20DF90          	   659:   jsr  bcd_unpack
00:91C8 60              	   660:   rts
                        	   661: 
00:91C9 4E6F20736F757263	   662: NOSCE    asciiz  'No source file.\n'   ; No source file
00:91D1 652066696C652E0A
00:91D9 00
                        	   663: 
                        	   664: ;***********************************************
                        	   665: ;
                        	   666: ; Initialize a compile or assembly
                        	   667: ;
                        	   668: ;***********************************************
                        	   669: 
                        	   670: 
                        	   671: INIT     =  *
                        	   672: ;
                        	   673: ;  set up symbol table pointer
                        	   674: ;
                        	   675: 
00:91DA A93F            	   676:   lda  #>SYMBOL_TABLE_START
00:91DC 8532            	   677:   sta  ENDSYM+1
00:91DE 8530            	   678:   sta  STARTSYM+1
00:91E0 A9FF            	   679:   lda  #<SYMBOL_TABLE_START
00:91E2 8531            	   680:   sta  ENDSYM
00:91E4 852F            	   681:   sta  STARTSYM
                        	   682: 
                        	   683: INIT_SECOND_PASS:   ; for assembler
                        	   684: 
00:91E6 A900            	   685:   lda  #0
00:91E8 851D            	   686:   sta  LIST            ; not listing
00:91EA 8522            	   687:   sta  LEVEL           ; variable level zero
00:91EC 852E            	   688:   sta  DCODE
00:91EE 853F            	   689:   sta  RUNNING         ; not running
00:91F0 8539            	   690:   sta  PRCITM
00:91F2 853A            	   691:   sta  PRCITM+1
00:91F4 8502            	   692:   sta  REGB
00:91F6 8593            	   693:   sta  token_type
00:91F8 64BE            	   694:   stz  system_flags
00:91FA A901            	   695:   lda #1
00:91FC 85A2            	   696:   sta  current_line        ; we are currently on line 1
00:91FE 64A3            	   697:   stz  current_line+1
                        	   698: 
                        	   699: ;
                        	   700: ;  set up for reading first byte of source
                        	   701: ;
00:9200 A900            	   702:   lda  #<TEXT_START
00:9202 858E            	   703:   sta  token_start
00:9204 859C            	   704:   sta  token_line_start
00:9206 A903            	   705:   lda  #>TEXT_START
00:9208 858F            	   706:   sta  token_start+1
00:920A 859D            	   707:   sta  token_line_start+1
00:920C 20898C          	   708:   jsr  find_source_end
00:920F A523            	   709:   lda  PCODE
00:9211 8525            	   710:   sta  ACT_PCDA
00:9213 A524            	   711:   lda  PCODE+1
00:9215 8526            	   712:   sta  ACT_PCDA+1
00:9217 A000            	   713:   ldy  #0
00:9219 B18E            	   714:   lda  (token_start),y
00:921B D00A            	   715:   bne  INIT9
00:921D A9C9            	   716:   lda  #<NOSCE
00:921F A291            	   717:   ldx  #>NOSCE
00:9221 202682          	   718:   jsr  print                      ; No source file
00:9224 4CCC82          	   719:   jmp  main_prompt
00:9227 60              	   720: INIT9    rts
                        	   721: 
                        	   722: 
                        	   723: 
                        	   724: 
                        	   725: ;
                        	   726: CROUT    =  *             ; show a newline
00:9228 A90A            	   727:   lda  #NL         ; was a carriage-return in legacy, now is newline
00:922A 4CAF93          	   728:   jmp  COUT
                        	   729: ;
                        	   730: ;***********************************************
                        	   731: ; COMPARE STRING - compare SRCE to DEST, assumes DEST is upper-case
                        	   732: ;                - length in Y (therefore max 255 characters)
                        	   733: ;                - zero flag set if match (therefore do a BEQ to see if strings match)
                        	   734: ;***********************************************
                        	   735: COMSTL   =  *
00:922D 88              	   736:          dey
00:922E 300A            	   737:          bmi  COMS8
00:9230 B100            	   738:          lda  (SRCE),Y
00:9232 20C48F          	   739:          jsr MAKE_UPPER
00:9235 D103            	   740:          cmp  (DEST),Y
00:9237 F0F4            	   741:          beq  COMSTL
00:9239 60              	   742: COMS9    rts             ; NOT EQUAL
00:923A A900            	   743: COMS8    lda  #0
00:923C 60              	   744:          rts             ; EQUAL
                        	   745: 
                        	   746: ;***********************************************
                        	   747: ; DISPLAY A LINE
                        	   748: ;
                        	   749: 
                        	   750: ;
                        	   751: ; DISPLAY IN HEX
                        	   752: ;
00:923D 209D92          	   753: DISHX    jsr  PRBYTE
00:9240 4CB392          	   754:          jmp  PUTSP
                        	   755: ;
                        	   756: 
                        	   757: ;***********************************************
                        	   758: ; DISPLAY PCODE ADDRESS
                        	   759: ;***********************************************
                        	   760: DISPAD   =  *
00:9243 A52E            	   761:          lda  DCODE
00:9245 F017            	   762:          beq  DISPAD2
                        	   763: DISPAD1  =  *
00:9247 A928            	   764:          lda  #'('
00:9249 20AF93          	   765:          jsr  COUT
00:924C A524            	   766:          lda  PCODE+1
00:924E 209D92          	   767:          jsr  PRBYTE
00:9251 A523            	   768:          lda  PCODE
00:9253 209D92          	   769:          jsr  PRBYTE
00:9256 A929            	   770:          lda  #')'
00:9258 20AF93          	   771:          jsr  COUT
00:925B 4CB392          	   772:          jmp  PUTSP
00:925E 60              	   773: DISPAD2  rts
                        	   774: ;
                        	   775: 
                        	   776: ;***********************************************
                        	   777: ; PUSH 'WORK' ONTO STACK
                        	   778: ;***********************************************
                        	   779: PSHWRK   =  *
00:925F 8536            	   780:          sta  BSAVE
00:9261 68              	   781:          pla
00:9262 AA              	   782:          tax
00:9263 68              	   783:          pla
00:9264 A8              	   784:          tay
00:9265 A538            	   785:          lda  WORK+1
00:9267 48              	   786:          pha
00:9268 A537            	   787:          lda  WORK
00:926A 48              	   788:          pha
00:926B 98              	   789:          tya
00:926C 48              	   790:          pha
00:926D 8A              	   791:          txa
00:926E 48              	   792:          pha
00:926F A536            	   793:          lda  BSAVE
00:9271 60              	   794: PSH9     rts
                        	   795: ;
                        	   796: ;***********************************************
                        	   797: ; PULL 'WORK' FROM STACK
                        	   798: ;***********************************************
                        	   799: PULWRK   =  *
00:9272 8536            	   800:          sta  BSAVE
00:9274 68              	   801:          pla
00:9275 AA              	   802:          tax
00:9276 68              	   803:          pla
00:9277 A8              	   804:          tay
00:9278 68              	   805:          pla
00:9279 8537            	   806:          sta  WORK
00:927B 68              	   807:          pla
00:927C 8538            	   808:          sta  WORK+1
00:927E 98              	   809:          tya
00:927F 48              	   810:          pha
00:9280 8A              	   811:          txa
00:9281 48              	   812:          pha
00:9282 A536            	   813:          lda  BSAVE
00:9284 60              	   814:          rts
                        	   815: ;
                        	   816: ;***********************************************
                        	   817: ; PRINTING SUBROUTINES
                        	   818: ; Control characters print with a ^ in front of them, eg. ^A
                        	   819: ;***********************************************
                        	   820: PRCHAR   =  *
00:9285 48              	   821:   pha
00:9286 C90A            	   822:   cmp #NL
00:9288 F00E            	   823:   beq prchar_not_control
00:928A C920            	   824:   cmp #$20
00:928C B00A            	   825:   bcs prchar_not_control
00:928E 48              	   826:   pha
00:928F A95E            	   827:   lda #'^'
00:9291 20AF93          	   828:   jsr COUT
00:9294 68              	   829:   pla
00:9295 18              	   830:   clc
00:9296 6940            	   831:   adc #$40  ; make 0x01 print as ^A
                        	   832: prchar_not_control:
00:9298 20AF93          	   833:   jsr  COUT
00:929B 68              	   834:   pla
00:929C 60              	   835:   rts
                        	   836: ;
                        	   837: ; Prints A in hex
                        	   838: ;
                        	   839: PRBYTE:
00:929D 48              	   840:   pha
00:929E 4A              	   841:   lsr
00:929F 4A              	   842:   lsr
00:92A0 4A              	   843:   lsr
00:92A1 4A              	   844:   lsr
00:92A2 20A892          	   845:   jsr  PRHEXZ    ; first nibble
00:92A5 68              	   846:   pla            ; now do other nibble
                        	   847: PRHEX:
00:92A6 290F            	   848:   and  #$0F
                        	   849: PRHEXZ:
00:92A8 0930            	   850:   ora  #'0'
00:92AA C93A            	   851:   cmp  #'0' + $0A
00:92AC 9002            	   852:   bcc  PRHEX1
00:92AE 6926            	   853:   adc  #$26  ; (carry is set: adding 7 to make 0x0a become 'a')
                        	   854: PRHEX1:
00:92B0 4C8592          	   855:   jmp  PRCHAR
                        	   856: ;
                        	   857: PUTSP    =  *
00:92B3 A920            	   858:   lda  #' '
00:92B5 80F9            	   859:   bra  PRHEX1
                        	   860: ;
                        	   861: ;
                        	   862: ;  PT - put text
                        	   863: ;   Low-order address in A, high-order address in X, count in Y
                        	   864: ;
                        	   865: ;
                        	   866: PT:
00:92B7 8503            	   867:   sta  REG2
00:92B9 8604            	   868:   stx  REG2+1
00:92BB 98              	   869:   tya    ; count of bytes to print
00:92BC AA              	   870:   tax    ; put that into X
00:92BD A000            	   871:   ldy  #0
                        	   872: PT6:
00:92BF B103            	   873:   lda  (REG2),Y    ; next character
00:92C1 20AF93          	   874:   jsr COUT         ; show it
00:92C4 C8              	   875:   iny
00:92C5 CA              	   876:   dex
00:92C6 D0F7            	   877:   bne  PT6
00:92C8 60              	   878:   rts
                        	   879: ;
                        	   880: ;
                        	   881: ;
                        	   882: ;---- token_address --> WORK
                        	   883: ;
                        	   884: TKNWRK   =  *
00:92C9 48              	   885:          PHA
00:92CA A590            	   886:          LDA  token_address
00:92CC 8537            	   887:          STA  WORK
00:92CE A591            	   888:          LDA  token_address+1
00:92D0 8538            	   889:          STA  WORK+1
00:92D2 68              	   890:          PLA
00:92D3 60              	   891:          RTS
                        	   892: ;
                        	   893: ;---- WORK --> token_address
                        	   894: ;
                        	   895: WRKTKN   =  *
00:92D4 48              	   896:          PHA
00:92D5 A537            	   897:          LDA  WORK
00:92D7 8590            	   898:          STA  token_address
00:92D9 A538            	   899:          LDA  WORK+1
00:92DB 8591            	   900:          STA  token_address+1
00:92DD 68              	   901:          PLA
00:92DE 60              	   902:          RTS
                        	   903: ;
                        	   904: 
                        	   905: 
                        	   906: ;***********************************************
                        	   907: ; MENU, FILE HANDLING
                        	   908: ;***********************************************
                        	   909: ;
00:92DF 502D636F64657320	   910: pcodes_ended_message        asciiz  "P-codes ended at $"
00:92E7 656E646564206174
00:92EF 2024
00:92F1 00
00:92F2 436F6D70696C6520	   911: compile_finished_message    asciiz  "Compile finished: No errors.\n"
00:92FA 66696E6973686564
00:9302 3A204E6F20657272
00:930A 6F72732E0A
00:930F 00
00:9310 53796D626F6C2074	   912: symbol_table_ended_message  asciiz "Symbol table ended at $"
00:9318 61626C6520656E64
00:9320 65642061742024
00:9327 00
00:9328 4E6F2076616C6964	   913: no_valid_compile_message    asciiz  'No valid compile or assemble done before\n'
00:9330 20636F6D70696C65
00:9338 206F722061737365
00:9340 6D626C6520646F6E
00:9348 65206265666F7265
00:9350 0A
00:9351 00
                        	   914: ;
                        	   915: PRBYTECR =  *
00:9352 209D92          	   916:          JSR  PRBYTE
00:9355 4C2892          	   917:          JMP  CROUT
                        	   918: ;
                        	   919: ;
                        	   920: ;
                        	   921: CHK_VAL  =  *
00:9358 A908            	   922:          LDA  #FLAG_VALID_COMPILE
00:935A 0910            	   923:          ORA  #FLAG_VALID_ASSEMBLE
00:935C 25BE            	   924:          and  system_flags
00:935E D00A            	   925:          BNE  CHK_VAL9
00:9360 A928            	   926:          LDA  #<no_valid_compile_message    ; No valid Compile or Assemble done before
00:9362 A293            	   927:          LDX  #>no_valid_compile_message
00:9364 202682          	   928:          JSR  print
00:9367 4CCC82          	   929:          JMP  main_prompt
                        	   930: CHK_VAL9 =  *
                        	   931: BELL1X   =  *          ; no bell yet
00:936A 60              	   932:          RTS
                        	   933: ;
00:936B 205893          	   934: CHK_RUN  JSR  CHK_VAL
00:936E A910            	   935:          lda  #FLAG_VALID_ASSEMBLE
00:9370 25BE            	   936:          and  system_flags
00:9372 D003            	   937:          bne  run_assembler
00:9374 4CCDAD          	   938:          JMP  INTERP
                        	   939: run_assembler:
00:9377 207D93          	   940:          jsr call_assembler
00:937A 4C69AE          	   941:          JMP  EX_FINISHD
                        	   942: ;
                        	   943: ;  let's assume they put a RTS at the end of their code
                        	   944: ;
                        	   945: call_assembler:
00:937D A95B            	   946:          LDA  #<running_message   ; Running
00:937F A2AD            	   947:          LDX  #>running_message
00:9381 202682          	   948:          JSR  print
00:9384 6C2500          	   949:          JMP (ACT_PCDA)
                        	   950: 
                        	   951: ;
                        	   952: 
                        	   953: ;
                        	   954: ; Get a line, read byte by byte until we get a newline, store in INBUF
                        	   955: ;   returns length in Y - handles backspace, ignores carriage-return
                        	   956: ;
                        	   957: GET_LINE =  *
                        	   958: GETLN1   =  *
00:9387 A000            	   959:   ldy  #0
                        	   960: GET1:
00:9389 2079C8          	   961:   jsr  CHRIN
00:938C C90D            	   962:   cmp  #CR       ; carriage-return?
00:938E F0F9            	   963:   beq  GET1       ; ignore it
00:9390 990002          	   964:   sta  INBUF,Y    ; SAVE IN BUFFER
00:9393 C8              	   965:   iny
00:9394 F016            	   966:   beq  GETLN_OVERFLOW       ; overflow
00:9396 C90A            	   967:   cmp  #NL        ; END OF LINE?
00:9398 F00C            	   968:   beq  GET3       ; yes
00:939A C908            	   969:   cmp  #BACKSPACE ; backspace?
00:939C D0EB            	   970:   bne  GET1       ; no - keep adding to buffer
                        	   971: ;
                        	   972: ;  here for backspace
                        	   973: ;
00:939E 88              	   974:   dey  ; get rid of backspace
00:939F 88              	   975:   dey  ; get rid of character we backspaced over
00:93A0 C0FF            	   976:   cpy  #$FF
00:93A2 F0E3            	   977:   beq  GETLN1   ; if Y underflowed, go back to zero
00:93A4 80E3            	   978:   bra GET1
                        	   979: 
                        	   980: GET3:
00:93A6 A900            	   981:   lda  #0
00:93A8 990002          	   982:   sta  INBUF,Y    ; turn newline into 0x00
00:93AB 60              	   983:   rts             ; RETURN
                        	   984: ;
                        	   985: ;  here on INBUF overflow
                        	   986: ;
                        	   987: GETLN_OVERFLOW:
00:93AC 88              	   988:   dey           ; get back to 255 (last byte)
00:93AD 80F7            	   989:   bra  GET3     ; store a zero there
                        	   990: 
                        	   991: 
                        	   992: ;
                        	   993: ;  output a character - saves all registers
                        	   994: ;
                        	   995: COUT:
00:93AF 48              	   996:   pha
00:93B0 DA              	   997:   phx
00:93B1 5A              	   998:   phy
00:93B2 20B993          	   999:   jsr COUT_CALL   ; call the current outputting routine
00:93B5 7A              	  1000:   ply
00:93B6 FA              	  1001:   plx
00:93B7 68              	  1002:   pla
00:93B8 60              	  1003:   rts
                        	  1004: 
                        	  1005: 
                        	  1006: COUT_CALL:
00:93B9 6C1700          	  1007:   jmp (write_function)
                        	  1008: 
                        	  1009: 

Source: "gpascal.asm"
                        	   176:   .include "errors.inc"

Source: "errors.inc"
                        	     1: 
                        	     2: errors_table:
00:93BC 4D656D6F72792066	     3:   asciiz "Memory full"                               ;  1
00:93C4 756C6C
00:93C7 00
00:93C8 436F6E7374616E74	     4:   asciiz "Constant expected"                         ;  2
00:93D0 2065787065637465
00:93D8 64
00:93D9 00
00:93DA 3D20657870656374	     5:   asciiz "= expected"                                ;  3
00:93E2 6564
00:93E4 00
00:93E5 4964656E74696669	     6:   asciiz "Identifier expected"                       ;  4
00:93ED 6572206578706563
00:93F5 746564
00:93F8 00
00:93F9 2C206F72203A2065	     7:   asciiz ", or : expected"                           ;  5
00:9401 78706563746564
00:9408 00
00:9409 427567          	     8:   asciiz "Bug"                                       ;  6
00:940C 00
00:940D 2A29206F72207D20	     9:   asciiz "*) or } expected"                          ;  7
00:9415 6578706563746564
00:941D 00
00:941E 496E636F72726563	    10:   asciiz "Incorrect string"                          ;  8
00:9426 7420737472696E67
00:942E 00
00:942F 2E20657870656374	    11:   asciiz ". expected"                                ;  9
00:9437 6564
00:9439 00
00:943A 3B20657870656374	    12:   asciiz "; expected"                                ; 10
00:9442 6564
00:9444 00
00:9445 556E6465636C6172	    13:   asciiz "Undeclared identifier"                     ; 11
00:944D 6564206964656E74
00:9455 6966696572
00:945A 00
00:945B 496C6C6567616C20	    14:   asciiz "Illegal identifier"                        ; 12
00:9463 6964656E74696669
00:946B 6572
00:946D 00
00:946E 3A3D206578706563	    15:   asciiz ":= expected"                               ; 13
00:9476 746564
00:9479 00
00:947A 4C69746572616C20	    16:   asciiz "Literal string of zero length"             ; 14
00:9482 737472696E67206F
00:948A 66207A65726F206C
00:9492 656E677468
00:9497 00
00:9498 436F6D70696C6572	    17:   asciiz "Compiler limits exceeded"                  ; 15
00:94A0 206C696D69747320
00:94A8 6578636565646564
00:94B0 00
00:94B1 5448454E20657870	    18:   asciiz "THEN expected"                             ; 16
00:94B9 6563746564
00:94BE 00
00:94BF 3B206F7220454E44	    19:   asciiz "; or END expected"                         ; 17
00:94C7 2065787065637465
00:94CF 64
00:94D0 00
00:94D1 444F206578706563	    20:   asciiz "DO expected"                               ; 18
00:94D9 746564
00:94DC 00
00:94DD 496E636F72726563	    21:   asciiz "Incorrect symbol"                          ; 19
00:94E5 742073796D626F6C
00:94ED 00
00:94EE 427567          	    22:   asciiz "Bug"                                       ; 20
00:94F1 00
00:94F2 557365206F662070	    23:   asciiz "Use of procedure identifier in expression" ; 21
00:94FA 726F636564757265
00:9502 206964656E746966
00:950A 69657220696E2065
00:9512 787072657373696F
00:951A 6E
00:951B 00
00:951C 2920657870656374	    24:   asciiz ") expected"                                ; 22
00:9524 6564
00:9526 00
00:9527 496C6C6567616C20	    25:   asciiz "Illegal factor"                            ; 23
00:952F 666163746F72
00:9535 00
00:9536 54797065206D6973	    26:   asciiz "Type mismatch"                             ; 24
00:953E 6D61746368
00:9543 00
00:9544 424547494E206578	    27:   asciiz "BEGIN expected"                            ; 25
00:954C 706563746564
00:9552 00
00:9553 4F46206578706563	    28:   asciiz "OF expected"                               ; 26
00:955B 746564
00:955E 00
00:955F 537461636B206675	    29:   asciiz "Stack full"                                ; 27
00:9567 6C6C
00:9569 00
00:956A 544F206F7220444F	    30:   asciiz "TO or DOWNTO expected"                     ; 28
00:9572 574E544F20657870
00:957A 6563746564
00:957F 00
00:9580 537472696E67206C	    31:   asciiz "String literal too big"                    ; 29
00:9588 69746572616C2074
00:9590 6F6F20626967
00:9596 00
00:9597 4E756D626572206F	    32:   asciiz "Number out of range"                       ; 30
00:959F 7574206F66207261
00:95A7 6E6765
00:95AA 00
00:95AB 2820657870656374	    33:   asciiz "( expected"                                ; 31
00:95B3 6564
00:95B5 00
00:95B6 2C20657870656374	    34:   asciiz ", expected"                                ; 32
00:95BE 6564
00:95C0 00
00:95C1 5B20657870656374	    35:   asciiz "[ expected"                                ; 33
00:95C9 6564
00:95CB 00
00:95CC 5D20657870656374	    36:   asciiz "] expected"                                ; 34
00:95D4 6564
00:95D6 00
00:95D7 506172616D657465	    37:   asciiz "Parameters mismatched"                     ; 35
00:95DF 7273206D69736D61
00:95E7 7463686564
00:95EC 00
00:95ED 4461746120747970	    38:   asciiz "Data type not recognised"                  ; 36
00:95F5 65206E6F74207265
00:95FD 636F676E69736564
00:9605 00
00:9606 53796D626F6C2074	    39:   asciiz "Symbol table full"                         ; 37
00:960E 61626C652066756C
00:9616 6C
00:9617 00
00:9618 4475706C69636174	    40:   asciiz "Duplicate identifier"                      ; 38
00:9620 65206964656E7469
00:9628 66696572
00:962C 00
00:962D 56616C7565206578	    41:   asciiz "Value expected"                            ; 39
00:9635 706563746564
00:963B 00
00:963C 496C6C6567616C20	    42:   asciiz "Illegal opcode"                            ; 40
00:9644 6F70636F6465
00:964A 00
00:964B 496C6C6567616C20	    43:   asciiz "Illegal addressing mode"                   ; 41
00:9653 6164647265737369
00:965B 6E67206D6F6465
00:9662 00
00:9663 4272616E6368206F	    44:   asciiz "Branch out of range"                       ; 42
00:966B 7574206F66207261
00:9673 6E6765
00:9676 00
00:9677 4E656564207A6572	    45:   asciiz "Need zero page address"                    ; 43
00:967F 6F20706167652061
00:9687 646472657373
00:968D 00
00:968E 4F706572616E6420	    46:   asciiz "Operand too large"                         ; 44
00:9696 746F6F206C617267
00:969E 65
00:969F 00
00:96A0 53796D626F6C2061	    47:   asciiz "Symbol address changed"                    ; 45
00:96A8 6464726573732063
00:96B0 68616E676564
00:96B6 00
00:96B7 4578707265737369	    48:   asciiz "Expression too complex"                    ; 46
00:96BF 6F6E20746F6F2063
00:96C7 6F6D706C6578
00:96CD 00
00:96CE 4469766964652062	    49:   asciiz "Divide by zero"                            ; 47
00:96D6 79207A65726F
00:96DC 00
00:96DD 4C6162656C207265	    50:   asciiz "Label required"                            ; 48
00:96E5 717569726564
00:96EB 00
00:96EC 53796D626F6C2074	    51:   asciiz "Symbol table in use"                       ; 49
00:96F4 61626C6520696E20
00:96FC 757365
00:96FF 00
00:9700 4E6F204C4344    	    52:   asciiz "No LCD"                                    ; 50
00:9706 00
00:9707 436F646520616C72	    53:   asciiz "Code already generated"                    ; 51
00:970F 656164792067656E
00:9717 657261746564
00:971D 00
                        	    54: assertion_failed_message:   ; used by Pascal assert function
00:971E 417373657274696F	    55:   asciiz "Assertion failed"                          ; 52
00:9726 6E206661696C6564
00:972E 00
00:972F 557365206F662066	    56:   asciiz "Use of function identifier in statement"   ; 53
00:9737 756E6374696F6E20
00:973F 6964656E74696669
00:9747 657220696E207374
00:974F 6174656D656E74
00:9756 00
00:9757 00              	    57:   dfb 0
                        	    58: 
                        	    59: ;***********************************************
                        	    60: ; DISPLAY ERROR - this does not return to the caller
                        	    61: ;  but to main_prompt
                        	    62: ;  Error number in X
                        	    63: ;***********************************************
00:9758 2A2A2A204572726F	    64: ERRLIT   asciiz  '*** Error: '
00:9760 723A20
00:9763 00
                        	    65: 
00:9764 8635            	    66: ERROR    stx  ERRNO
00:9766 A53F            	    67:          lda  RUNNING
00:9768 F003            	    68:          beq  ERR7
00:976A 4CA197          	    69:          jmp  ERR6
                        	    70: ERR7     =  *
00:976D A51D            	    71:          lda  LIST
00:976F D006            	    72:          bne  ERR1
00:9771 202892          	    73:          jsr  CROUT
00:9774 20F997          	    74:          jsr  show_current_line
                        	    75: ERR1     =  *
00:9777 A590            	    76:          lda  token_address
00:9779 38              	    77:          sec
00:977A E59C            	    78:          sbc  token_line_start  ; TODO: what about high-order byte?
00:977C 48              	    79:          pha             ; CHARS UP TO ERROR POINT
00:977D A958            	    80:          lda  #<ERRLIT   ; *** Error
00:977F A297            	    81:          ldx  #>ERRLIT
00:9781 202682          	    82:          jsr  print
00:9784 68              	    83:          pla
00:9785 18              	    84:          clc
00:9786 6901            	    85:          adc   #1
00:9788 8545            	    86:          sta  TEMP       ; BYTES TO ERROR POINT
00:978A AA              	    87:          tax
                        	    88: ERR3     =  *
00:978B 20B392          	    89:          jsr  PUTSP
00:978E CA              	    90:          dex
00:978F D0FA            	    91:          bne  ERR3
00:9791 A95E            	    92:          lda  #'^'
00:9793 20AF93          	    93:          jsr  COUT
00:9796 202892          	    94:          jsr  CROUT
00:9799 A209            	    95:          ldx  #9
                        	    96: ERR5     =  *
00:979B 20B392          	    97:          jsr  PUTSP
00:979E CA              	    98:          dex
00:979F D0FA            	    99:          bne  ERR5
                        	   100: ERR6     =  *
00:97A1 A9BC            	   101:   lda #<errors_table
00:97A3 8500            	   102:   sta REG
00:97A5 A993            	   103:   lda #>errors_table
00:97A7 8501            	   104:   sta REG+1
00:97A9 A200            	   105:   ldx #0
00:97AB A000            	   106:   ldy #0
                        	   107: error_next:
00:97AD E8              	   108:   inx
                        	   109: error_loop:
00:97AE E435            	   110:   cpx ERRNO
00:97B0 F02A            	   111:   beq error_found
                        	   112: error_find_next:
00:97B2 B100            	   113:   lda (REG),Y
00:97B4 48              	   114:   pha
00:97B5 E600            	   115:   inc REG
00:97B7 D002            	   116:   bne error1
00:97B9 E601            	   117:   inc REG+1
                        	   118: error1:
00:97BB 68              	   119:   pla           ; get the previous byte
00:97BC D0F4            	   120:   bne error_find_next
00:97BE B100            	   121:   lda (REG),Y   ; a null after a null?
00:97C0 F002            	   122:   beq error_not_found
00:97C2 80E9            	   123:   bra error_next  ; we got a null, so add 1 to our current error number (X)
                        	   124: 
                        	   125: error_not_found:
00:97C4 A9E9            	   126:   lda #<error_not_found_message
00:97C6 A297            	   127:   ldx #>error_not_found_message
00:97C8 202682          	   128:   jsr print
00:97CB A535            	   129:   lda ERRNO
00:97CD 8500            	   130:   sta REG
00:97CF 6401            	   131:   stz REG+1
00:97D1 6402            	   132:   stz REGB
00:97D3 205291          	   133:   jsr display_in_decimal
00:97D6 202892          	   134:   jsr CROUT
00:97D9 4CCC82          	   135:   jmp main_prompt
                        	   136: 
                        	   137: error_found:
00:97DC A500            	   138:   lda REG
00:97DE A601            	   139:   ldx REG+1
00:97E0 202682          	   140:   jsr print
00:97E3 202892          	   141:   jsr CROUT
00:97E6 4CCC82          	   142:   jmp  main_prompt
                        	   143: 
00:97E9 556E6B6E6F776E20	   144: error_not_found_message asciiz "Unknown error: "
00:97F1 6572726F723A20
00:97F8 00
                        	   145: 
                        	   146: show_current_line:
00:97F9 A928            	   147:   lda #'('
00:97FB 20AF93          	   148:   jsr COUT
00:97FE A524            	   149:   lda PCODE+1
00:9800 209D92          	   150:   jsr PRBYTE
00:9803 A523            	   151:   lda PCODE
00:9805 209D92          	   152:   jsr PRBYTE
00:9808 A929            	   153:   lda #')'
00:980A 20AF93          	   154:   jsr COUT
00:980D 20B392          	   155:   jsr PUTSP
00:9810 201E8C          	   156:   jsr show_current_line_number
00:9813 A59C            	   157:   lda token_line_start
00:9815 85A6            	   158:   sta mem_move_src
00:9817 A59D            	   159:   lda token_line_start+1
00:9819 85A7            	   160:   sta mem_move_src+1
                        	   161: 
                        	   162: show_current_line_loop:
00:981B A000            	   163:   ldy #0
00:981D B1A6            	   164:   lda (mem_move_src),Y
00:981F F01D            	   165:   beq show_current_line_done
00:9821 C90A            	   166:   cmp #NL
00:9823 F019            	   167:   beq show_current_line_done
00:9825 C920            	   168:   cmp #$20
00:9827 B00A            	   169:   bcs show_current_line_loop_print_one_character
00:9829 48              	   170:   pha
00:982A A95E            	   171:   lda #'^'
00:982C 20AF93          	   172:   jsr COUT
00:982F 68              	   173:   pla
00:9830 18              	   174:   clc
00:9831 6940            	   175:   adc #$40  ; make 0x01 print as ^A
                        	   176: show_current_line_loop_print_one_character:
00:9833 20AF93          	   177:   jsr COUT    ; show that byte
00:9836 E6A6            	   178:   inc mem_move_src
00:9838 D0E1            	   179:   bne show_current_line_loop
00:983A E6A7            	   180:   inc mem_move_src+1
00:983C 80DD            	   181:   bra show_current_line_loop
                        	   182: 
                        	   183: show_current_line_done:
00:983E 202892          	   184:   jsr CROUT
00:9841 60              	   185:   rts
                        	   186: 

Source: "gpascal.asm"
                        	   177:   .include "assembler.inc"

Source: "assembler.inc"
                        	     1: ;***********************************************
                        	     2: ;
                        	     3: ; Assembler
                        	     4: ;
                        	     5: ;***********************************************
                        	     6: 
                        	     7: ;***********************************************
                        	     8: ; Assembler operand types
                        	     9: ;***********************************************
                        	    10: 
                        	    11: ASS_OPERAND_ABSOLUTE                           =  1      ; a
                        	    12: ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT          =  2      ; (a,x)
                        	    13: ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X            =  3      ; a,x
                        	    14: ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y            =  4      ; a,y
                        	    15: ASS_OPERAND_ABSOLUTE_INDIRECT                  =  5      ; (a)
                        	    16: ASS_OPERAND_ACCUMULATOR_A                      =  6      ; A
                        	    17: ASS_OPERAND_IMMEDIATE                          =  7      ; #
                        	    18: ASS_OPERAND_IMPLIED                            =  8      ; i
                        	    19: ASS_OPERAND_PROGRAM_COUNTER_RELATIVE           =  9      ; r
                        	    20: ASS_OPERAND_STACK                              = 10      ; s
                        	    21: ASS_OPERAND_ZERO_PAGE                          = 11      ; zp
                        	    22: ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT         = 12      ; (zp,x)
                        	    23: ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X           = 13      ; zp,x
                        	    24: ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y           = 14      ; zp,y
                        	    25: ASS_OPERAND_ZERO_PAGE_INDIRECT                 = 15      ; (zp)
                        	    26: ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y  = 16      ; (zp),y
                        	    27: ASS_OPERAND_STRING                             = 17      ; "But does it get goat's blood out?"
                        	    28: ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE             = 18      ; zp,r
                        	    29: 
                        	    30: ;
                        	    31: ;  Entry point for assembler
                        	    32: ;
                        	    33: ASSEMBLE:
                        	    34: 
00:9842 A2FF            	    35:    ldx  #NEW_STK
00:9844 9A              	    36:    txs    ; set stack back to 0xFF
00:9845 6476            	    37:    stz  ASS_PASS  ; first pass
00:9847 20DA91          	    38:    jsr  INIT       ; sets up pointers, calls LINE
00:984A 20FBA9          	    39:    jsr  add_assembler_library_functions  ; add our inbuilt functions to the symbol table
00:984D 8005            	    40:    bra  ASSEMBLE_PASS
                        	    41: 
                        	    42: ASSEMBLE_SECOND_PASS:
00:984F E676            	    43:    inc  ASS_PASS
00:9851 20E691          	    44:    jsr  INIT_SECOND_PASS    ; don't re-initialise the symbol table
                        	    45: ASSEMBLE_PASS:
00:9854 64A2            	    46:    stz  current_line  ; we'll got for zero, not one
                        	    47: 
00:9856 A902            	    48:    lda  #FLAG_ASSEMBLING
00:9858 04BE            	    49:    tsb  system_flags
                        	    50: 
                        	    51: ;
                        	    52: ;  no listing yet
                        	    53: ;
00:985A 642E            	    54:    stz  DCODE
00:985C 641D            	    55:    stz  LIST
00:985E 6442            	    56:    stz  SYNTAX
00:9860 6482            	    57:    stz  show_symbols
                        	    58: ;
                        	    59: ; zero line count
                        	    60: ;
00:9862 6419            	    61:    stz  LINE_CNT
00:9864 641A            	    62:    stz  LINE_CNT+1
                        	    63: 
                        	    64: ;
                        	    65: ;  and emitted bytes count
                        	    66: ;
00:9866 6477            	    67:    stz ass_emit_bytes
00:9868 6478            	    68:    stz ass_emit_bytes+1
                        	    69: 
                        	    70: ;
                        	    71: ; no previous token
                        	    72: ;
00:986A 6493            	    73:    stz  token_type
00:986C 800E            	    74:    bra ass_line
                        	    75: 
                        	    76: ass_finish_line:
00:986E A593            	    77:    lda token_type
00:9870 C90A            	    78:    cmp #NL
00:9872 F008            	    79:    beq ass_line
00:9874 A213            	    80:    ldx #19    ; Incorrect Symbol
00:9876 4CB79E          	    81:    jmp ass_error
                        	    82: 
                        	    83: ass_done_jump:
00:9879 4C9E9B          	    84:    jmp ass_done
                        	    85: ;
                        	    86: ;  here for the start of a line
                        	    87: ;
                        	    88: ass_line:
00:987C A576            	    89:   lda ASS_PASS    ; only showing codes on 2nd pass
00:987E F00B            	    90:   beq ass_line1
00:9880 A56F            	    91:   lda ASS_EMIT_COUNT  ; only need a newline if we actually output a code
00:9882 F007            	    92:   beq ass_line1
00:9884 A52E            	    93:   lda DCODE           ; is showing codes on?
00:9886 F003            	    94:   beq ass_line1
00:9888 202892          	    95:   jsr CROUT
                        	    96: ass_line1:
00:988B A000            	    97:   ldy #0
00:988D B18E            	    98:   lda (token_start),y ; quick test so we don't list a non-existent line
00:988F F0E8            	    99:   beq ass_done_jump
                        	   100: 
00:9891 A58E            	   101:   lda token_start
00:9893 859C            	   102:   sta token_line_start
00:9895 A58F            	   103:   lda token_start+1
00:9897 859D            	   104:   sta token_line_start+1
00:9899 2095C9          	   105:   jsr token_line        ; list the next line
                        	   106: 
00:989C 646B            	   107:   stz ASS_OPERAND   ; no operand yet
00:989E 646F            	   108:   stz ASS_EMIT_COUNT
00:98A0 6483            	   109:   stz ass_current_label
00:98A2 6484            	   110:   stz ass_current_label+1
                        	   111: 
00:98A4 20F5C8          	   112:   jsr get_token
                        	   113: 
00:98A7 C949            	   114:   cmp #TOKEN_IDENTIFIER  ; could be a label if in column 1
00:98A9 F015            	   115:   beq ass_identifier
00:98AB C93D            	   116:   cmp #'='               ; = directive is OK
00:98AD F011            	   117:   beq ass_identifier
                        	   118: 
00:98AF C93B            	   119:   cmp #';'
00:98B1 F0BB            	   120:   beq ass_finish_line
                        	   121: 
00:98B3 C90A            	   122:   cmp #NL
00:98B5 F0C5            	   123:   beq ass_line
                        	   124: 
00:98B7 C900            	   125:   cmp #0
00:98B9 F0BE            	   126:   beq ass_done_jump
                        	   127: 
                        	   128: ass_bad_identifier:
00:98BB A204            	   129:   ldx #4      ; Identifier expected
00:98BD 4CB79E          	   130:   JMP ass_error
                        	   131: 
                        	   132: ass_identifier:
                        	   133: 
                        	   134: ;
                        	   135: ;  if the identifier is at the start of the line, it is a label, not an opcode
                        	   136: ;
00:98C0 A590            	   137:   lda token_address
00:98C2 C59C            	   138:   cmp token_line_start
00:98C4 D067            	   139:   bne ass_opcode
00:98C6 A591            	   140:   lda token_address+1
00:98C8 C59D            	   141:   cmp token_line_start+1
00:98CA D061            	   142:   bne ass_opcode
                        	   143: 
00:98CC A593            	   144:   lda token_type         ; can't have = as an identifier
00:98CE C93D            	   145:   cmp #'='               ; or "="
00:98D0 F0E9            	   146:   beq ass_bad_identifier
                        	   147: 
                        	   148: ;
                        	   149: ;  here for label - on the first pass, add it to the symbol table, on the second pass look it up
                        	   150: ;
00:98D2 A576            	   151:   lda ASS_PASS
00:98D4 D014            	   152:   bne ass_lookup_existing_label
                        	   153: ;
                        	   154: ;  here for first pass
                        	   155: ;
00:98D6 20A0B9          	   156:   jsr CHKDUP
                        	   157: ;
                        	   158: ; not a duplicate - add it
                        	   159: ;
00:98D9 A523            	   160:   lda PCODE
00:98DB 8594            	   161:   sta token_value
00:98DD A524            	   162:   lda PCODE+1
00:98DF 8595            	   163:   sta token_value+1
00:98E1 6496            	   164:   stz token_value+2
00:98E3 A943            	   165:   lda #SYMBOL_CONSTANT
00:98E5 20F9B8          	   166:   jsr ADDSYM
00:98E8 8016            	   167:   bra ass_added_symbol
                        	   168: 
                        	   169: ;
                        	   170: ;  here for second pass
                        	   171: ;
                        	   172: ass_lookup_existing_label:
00:98EA 207DB8          	   173:   jsr SEARCH  ; look it up
00:98ED D005            	   174:   bne ass_lookup_save_address  ; it should be!
00:98EF A206            	   175:   ldx #6  ; ERROR: bug
00:98F1 4CB79E          	   176:   jmp ass_error
                        	   177: 
                        	   178: ass_lookup_save_address:
00:98F4 A594            	   179:   lda token_value
00:98F6 8573            	   180:   sta ASS_VALUE
00:98F8 A595            	   181:   lda token_value+1
00:98FA 8574            	   182:   sta ASS_VALUE+1
00:98FC A596            	   183:   lda token_value+2
00:98FE 8575            	   184:   sta ASS_VALUE+2
                        	   185: 
                        	   186: ;
                        	   187: ;  the symbol has either been added, or looked up to make sure it is still there
                        	   188: ;
                        	   189: ass_added_symbol:
                        	   190: 
                        	   191: ;
                        	   192: ;  remember its address in case we have an EQU directive
                        	   193: ;
00:9900 A540            	   194:   lda SYMITM
00:9902 8583            	   195:   sta ass_current_label
00:9904 A541            	   196:   lda SYMITM+1
00:9906 8584            	   197:   sta ass_current_label+1
                        	   198: 
                        	   199: ;
                        	   200: ;  get whatever is after the label
                        	   201: ;
00:9908 20F5C8          	   202:   jsr get_token
00:990B C93A            	   203:   cmp #':'
00:990D D003            	   204:   bne ass_not_colon
00:990F 20F5C8          	   205:   jsr get_token  ; skip the colon
                        	   206: ass_not_colon:
00:9912 C90A            	   207:   cmp #NL     ; newline means this is just a label line
00:9914 F004            	   208:   beq ass_finish_lineJ2
00:9916 C93B            	   209:   cmp #';'    ; ditto for comment
00:9918 D003            	   210:   bne ass_not_colon2
00:991A 4C6E98          	   211: ass_finish_lineJ2  jmp ass_finish_line
                        	   212: ass_not_colon2:
00:991D C949            	   213:   cmp #TOKEN_IDENTIFIER  ; should be an opcode now
00:991F F00C            	   214:   beq ass_opcode
00:9921 C93D            	   215:   cmp #'='               ; = directive is OK
00:9923 F008            	   216:   beq ass_opcode
                        	   217: 
                        	   218: ass_illegal_opcode:
00:9925 209D92          	   219:   jsr PRBYTE
00:9928 A228            	   220:   ldx #40      ; ERROR: illegal opcode
00:992A 4CB79E          	   221:   JMP ass_error
                        	   222: 
                        	   223: ass_opcode:
                        	   224: 
                        	   225: ;
                        	   226: ;  this will be our assembler mnemonic or directive so save its start point and length
                        	   227: ;
                        	   228: 
00:992D A690            	   229:   ldx token_address
00:992F 866C            	   230:   stx OPCODE
00:9931 A691            	   231:   ldx token_address+1
00:9933 866D            	   232:   stx OPCODE+1
00:9935 A692            	   233:   ldx token_length
00:9937 866E            	   234:   stx OPCODE_LEN
                        	   235: 
                        	   236: ;
                        	   237: ;  if we had a label on the line, check its address hasn't changed (on the second pass)
                        	   238: ;   UNLESS it is an EQU directive in which case it probably did change
                        	   239: ;
00:9939 A576            	   240:   lda ASS_PASS
00:993B F046            	   241:   beq ass_opcode2
00:993D A583            	   242:   lda ass_current_label
00:993F 0584            	   243:   ora ass_current_label+1   ; was there a label?
00:9941 F040            	   244:   beq ass_opcode2    ; nope
00:9943 A593            	   245:   lda token_type
00:9945 C93D            	   246:   cmp #'='
00:9947 F03A            	   247:   beq ass_opcode2   ; don't check on "=" directive
00:9949 A592            	   248:   lda token_length
00:994B C903            	   249:   cmp #3
00:994D D034            	   250:   bne ass_opcode2   ; can't be EQU
                        	   251: ;
                        	   252: ; this is truly crap, but I am feeling lazy
                        	   253: ;
00:994F A000            	   254:   ldy #0
00:9951 B190            	   255:   lda (token_address),y
00:9953 20C48F          	   256:   jsr MAKE_UPPER
00:9956 C945            	   257:   cmp #'E'
00:9958 D014            	   258:   bne ass_check_label_changed
00:995A C8              	   259:   iny
00:995B B190            	   260:   lda (token_address),y
00:995D 20C48F          	   261:   jsr MAKE_UPPER
00:9960 C951            	   262:   cmp #'Q'
00:9962 D00A            	   263:   bne ass_check_label_changed
00:9964 C8              	   264:   iny
00:9965 B190            	   265:   lda (token_address),y
00:9967 20C48F          	   266:   jsr MAKE_UPPER
00:996A C955            	   267:   cmp #'U'
00:996C F015            	   268:   beq ass_opcode2
                        	   269: 
                        	   270: ;
                        	   271: ;  we looked up the label earlier, when it was the current token,
                        	   272: ;   and we saved its value in ASS_VALUE
                        	   273: ;
                        	   274: 
                        	   275: ass_check_label_changed:
00:996E A523            	   276:   lda PCODE
00:9970 C573            	   277:   cmp ASS_VALUE
00:9972 D00A            	   278:   bne ass_symbol_address_changed
00:9974 A524            	   279:   lda PCODE+1
00:9976 C574            	   280:   cmp ASS_VALUE+1
00:9978 D004            	   281:   bne ass_symbol_address_changed
00:997A A575            	   282:   lda ASS_VALUE+2   ; 3rd byte should be zero
00:997C F005            	   283:   beq ass_opcode2
                        	   284: 
                        	   285: ass_symbol_address_changed:
00:997E A22D            	   286:   ldx #45     ; ERROR: Symbol address changed
00:9980 4CB79E          	   287:   jmp ass_error
                        	   288: 
                        	   289: 
                        	   290: 
                        	   291: ass_opcode2:
                        	   292: ;
                        	   293: ;  look up operand
                        	   294: ;
                        	   295: 
00:9983 20F5C8          	   296:   jsr get_token
00:9986 C93B            	   297:   cmp #';'          ; hit a comment?
00:9988 F004            	   298:   beq ass_no_operand
00:998A C90A            	   299:   cmp #NL           ; or end of line?
00:998C D00D            	   300:   bne ass_operand
                        	   301: 
                        	   302: ;
                        	   303: ;  here when the opcode is followed by (spaces), a comment or a newline
                        	   304: ;
                        	   305: ass_no_operand:
00:998E A908            	   306:   lda #ASS_OPERAND_IMPLIED
00:9990 856B            	   307:   sta ASS_OPERAND
00:9992 20F59A          	   308:   jsr opcode_lookup
00:9995 20E19B          	   309:   jsr ass_check_no_more_tokens
                        	   310: ass_finish_lineJ:
00:9998 4C6E98          	   311:   jmp ass_finish_line
                        	   312: 
                        	   313: ass_operand:
00:999B C923            	   314:   cmp #'#'  ; immediate?
00:999D F036            	   315:   beq ass_immediate
00:999F C928            	   316:   cmp #'('  ; indirect?
00:99A1 F045            	   317:   beq ass_indirect
00:99A3 C949            	   318:   cmp #TOKEN_IDENTIFIER
00:99A5 F04A            	   319:   beq ass_identifier_operand
00:99A7 C922            	   320:   cmp #TOKEN_STRING
00:99A9 F006            	   321:   beq ass_string
00:99AB C92A            	   322:   cmp #'*'
00:99AD F00F            	   323:   beq ass_asterisk
                        	   324: ;
                        	   325: ;  here for some kind of numeric address
                        	   326: ;
00:99AF 8061            	   327:   bra ass_operand_value
                        	   328: 
                        	   329: ;
                        	   330: ;  Here for a string as an operand, should be a compiler directive, eg.  ASC "Hello, world"
                        	   331: ;
                        	   332: ass_string:
00:99B1 A911            	   333:   lda #ASS_OPERAND_STRING
00:99B3 856B            	   334:   sta ASS_OPERAND
00:99B5 20F59A          	   335:   jsr opcode_lookup
00:99B8 20F5C8          	   336:   jsr get_token  ; NOW get the next token
00:99BB 4C6E98          	   337:   jmp ass_finish_line
                        	   338: 
                        	   339: ;
                        	   340: ;  an asterisk as the operand evaluates to the current P-code address
                        	   341: ;
                        	   342: ass_asterisk:
00:99BE A901            	   343:   lda #ASS_OPERAND_ABSOLUTE
00:99C0 856B            	   344:   sta ASS_OPERAND
00:99C2 A523            	   345:   lda PCODE
00:99C4 8573            	   346:   sta ASS_VALUE
00:99C6 A524            	   347:   lda PCODE+1
00:99C8 8574            	   348:   sta ASS_VALUE+1
00:99CA 6475            	   349:   stz ASS_VALUE+2
00:99CC 20F59A          	   350:   jsr opcode_lookup
00:99CF 20F5C8          	   351:   jsr get_token  ; NOW get the next token
00:99D2 4C6E98          	   352:   jmp ass_finish_line
                        	   353: 
                        	   354: ;
                        	   355: ;  immediate, that is:  #<expression>
                        	   356: ;
                        	   357: ass_immediate:
00:99D5 A907            	   358:   lda #ASS_OPERAND_IMMEDIATE
00:99D7 856B            	   359:   sta ASS_OPERAND
00:99D9 20F5C8          	   360:   jsr get_token
00:99DC 20FC9C          	   361:   jsr ass_get_value
00:99DF 20E19B          	   362:   jsr ass_check_no_more_tokens
00:99E2 20F59A          	   363:   jsr opcode_lookup
00:99E5 4C6E98          	   364:   jmp ass_finish_line
                        	   365: 
                        	   366: ;
                        	   367: ;  indirect, that is: (expression) OR (expression,X) OR (expression),Y
                        	   368: ;
                        	   369: ass_indirect:
00:99E8 A905            	   370:   lda #ASS_OPERAND_ABSOLUTE_INDIRECT  ; first guess
00:99EA 856B            	   371:   sta ASS_OPERAND
00:99EC 20F5C8          	   372:   jsr get_token    ; skip the bracket
00:99EF 8021            	   373:   bra ass_operand_value
                        	   374: 
                        	   375: ;
                        	   376: ;  some sort of identifier, possibly the start of an expression or maybe just "A"
                        	   377: ;
                        	   378: ass_identifier_operand:
                        	   379: 
                        	   380: ;
                        	   381: ;  see if the operand is just the letter "A"
                        	   382: ;
00:99F1 A592            	   383:   lda token_length
00:99F3 C901            	   384:   cmp #1
00:99F5 D01B            	   385:   bne ass_operand_value
00:99F7 A000            	   386:   ldy #0
00:99F9 B190            	   387:   lda (token_address),Y
00:99FB 20C48F          	   388:   jsr MAKE_UPPER
00:99FE C941            	   389:   cmp #'A'
00:9A00 D010            	   390:   bne ass_operand_value
00:9A02 A906            	   391:   lda #ASS_OPERAND_ACCUMULATOR_A
00:9A04 856B            	   392:   sta ASS_OPERAND
00:9A06 20F5C8          	   393:   jsr get_token  ; skip past A
00:9A09 20E19B          	   394:   jsr ass_check_no_more_tokens
00:9A0C 20F59A          	   395:   jsr opcode_lookup
00:9A0F 4C6E98          	   396:   jmp ass_finish_line
                        	   397: 
                        	   398: ;
                        	   399: ;  a number or identifier - evaluate as an expression
                        	   400: ;
                        	   401: ass_operand_value:
                        	   402: 
00:9A12 A593            	   403:   lda token_type ; get token back
00:9A14 20FC9C          	   404:   jsr ass_get_value  ; should have some sort of address now in VALUE
                        	   405: ;
                        	   406: ;  we come back with the first non-value token loaded in TOKEN
                        	   407: ;  now see if we originally had a bracket, so this must be one of those indirect things
                        	   408: ;
00:9A17 A56B            	   409:   lda ASS_OPERAND
00:9A19 C905            	   410:   cmp #ASS_OPERAND_ABSOLUTE_INDIRECT
00:9A1B D02D            	   411:   bne ass_value_not_indirectJ
00:9A1D A593            	   412:   lda token_type   ; now we should have a comma or a bracket
00:9A1F C929            	   413:   cmp #')'
00:9A21 F02F            	   414:   beq ass_indirect_with_bracket
                        	   415: ;
                        	   416: ;  We had an opening bracket but not a closing bracket. Must be a comma then
                        	   417: ;
                        	   418: 
00:9A23 A92C            	   419:   lda #','
00:9A25 A220            	   420:   ldx #32  ; ERROR: , expected
00:9A27 2007CF          	   421:   jsr CHKTKN
                        	   422: ;
                        	   423: ;  now we must have X
                        	   424: ;
00:9A2A 208E9A          	   425:   jsr ass_check_we_have_x_or_y
00:9A2D 901E            	   426:   bcc ass_bad_indirect
00:9A2F C958            	   427:   cmp #'X'
00:9A31 D01A            	   428:   bne ass_bad_indirect
00:9A33 A902            	   429:   lda #ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
00:9A35 856B            	   430:   sta ASS_OPERAND
00:9A37 A929            	   431:   lda #')'
00:9A39 A216            	   432:   ldx #22  ; ERROR: ) expected
00:9A3B 20F7CE          	   433:   jsr GETCHK
00:9A3E 20F5C8          	   434:   jsr get_token
00:9A41 20E19B          	   435:   jsr ass_check_no_more_tokens
00:9A44 20F59A          	   436:   jsr opcode_lookup
00:9A47 4C6E98          	   437:   jmp ass_finish_line
                        	   438: 
00:9A4A 4CAC9A          	   439: ass_value_not_indirectJ jmp ass_value_not_indirect
                        	   440: 
                        	   441: ass_bad_indirect:
00:9A4D A229            	   442:   ldx #41  ; ERROR: illegal addressing mode
00:9A4F 4CB79E          	   443:   jmp ass_error
                        	   444: 
                        	   445: 
                        	   446: ;
                        	   447: ;  we have some sort of indirect expression followed by a bracket, so see if there is ",Y" after it
                        	   448: ;
                        	   449: ass_indirect_with_bracket:
                        	   450: ;
                        	   451: ;  can only be (a), (zp) or (zp),y
                        	   452: ;
00:9A52 20F5C8          	   453:   jsr get_token
00:9A55 C92C            	   454:   cmp #','
00:9A57 F00D            	   455:   beq ass_zp_indirect_indexed
00:9A59 20E19B          	   456:   jsr ass_check_no_more_tokens
00:9A5C A905            	   457:   lda #ASS_OPERAND_ABSOLUTE_INDIRECT
00:9A5E 856B            	   458:   sta ASS_OPERAND
00:9A60 20F59A          	   459:   jsr opcode_lookup
00:9A63 4C6E98          	   460:   jmp ass_finish_line
                        	   461: 
                        	   462: 
                        	   463: ;
                        	   464: ;  For indirect followed by a comma, we must have Y and nothing else
                        	   465: ;  Also, the operand must be a zero-page address
                        	   466: ;
                        	   467: ass_zp_indirect_indexed:
00:9A66 208E9A          	   468:   jsr ass_check_we_have_x_or_y
00:9A69 90E2            	   469:   bcc ass_bad_indirect
00:9A6B C959            	   470:   cmp #'Y'
00:9A6D D0DE            	   471:   bne ass_bad_indirect
00:9A6F A574            	   472:   lda ASS_VALUE+1
00:9A71 D014            	   473:   bne ass_bad_zp_indirect_indexed
00:9A73 A575            	   474:   lda ASS_VALUE+2
00:9A75 D010            	   475:   bne ass_bad_zp_indirect_indexed
00:9A77 A910            	   476:   lda #ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
00:9A79 856B            	   477:   sta ASS_OPERAND
00:9A7B 20F5C8          	   478:   jsr get_token  ; skip the Y
00:9A7E 20E19B          	   479:   jsr ass_check_no_more_tokens
00:9A81 20F59A          	   480:   jsr opcode_lookup
00:9A84 4C6E98          	   481:   jmp ass_finish_line
                        	   482: 
                        	   483: ass_bad_zp_indirect_indexed:
00:9A87 A22B            	   484:   ldx #43
00:9A89 4CB79E          	   485:   jmp ass_error
                        	   486: 
                        	   487: ass_not_x_or_y:
00:9A8C 18              	   488:   clc
00:9A8D 60              	   489:   rts
                        	   490: 
                        	   491: ;
                        	   492: ;  we had (<expression>),<something> so check that <something> is X or Y
                        	   493: ;   sets carry if it is
                        	   494: ;
                        	   495: ass_check_we_have_x_or_y:
00:9A8E 20F5C8          	   496:   jsr get_token
00:9A91 C949            	   497:   cmp #TOKEN_IDENTIFIER
00:9A93 D0F7            	   498:   bne ass_not_x_or_y
00:9A95 A592            	   499:   lda token_length
00:9A97 C901            	   500:   cmp #1
00:9A99 D0F1            	   501:   bne ass_not_x_or_y
00:9A9B A000            	   502:   ldy #0
00:9A9D B190            	   503:   lda (token_address),y
00:9A9F 20C48F          	   504:   jsr MAKE_UPPER
00:9AA2 C959            	   505:   cmp #'Y'
00:9AA4 F004            	   506:   beq ass_check_we_have_x_or_y_ok
00:9AA6 C958            	   507:   cmp #'X'
00:9AA8 D0E2            	   508:   bne ass_not_x_or_y
                        	   509: ass_check_we_have_x_or_y_ok:
00:9AAA 38              	   510:   sec
00:9AAB 60              	   511:   rts
                        	   512: 
                        	   513: ;
                        	   514: ;  we had a non-indirect expression, so was it followed by a comma?
                        	   515: ;
                        	   516: 
                        	   517: ass_value_not_indirect:
00:9AAC A593            	   518:   lda token_type
00:9AAE C92C            	   519:   cmp #','
00:9AB0 F00D            	   520:   beq ass_indexed
00:9AB2 A901            	   521:   lda #ASS_OPERAND_ABSOLUTE
00:9AB4 856B            	   522:   sta ASS_OPERAND
                        	   523: ass_value_done:
00:9AB6 20E19B          	   524:   jsr ass_check_no_more_tokens
00:9AB9 20F59A          	   525:   jsr opcode_lookup
00:9ABC 4C6E98          	   526:   jmp ass_finish_line
                        	   527: 
                        	   528: ;
                        	   529: ;  <expression>,X or <expression>,Y is what we are expecting here
                        	   530: ;
                        	   531: ;  OR: in the case of BBR0 ... BBR7 and BBS0 ... BBS7 : another expression
                        	   532: ;
                        	   533: 
                        	   534: ass_indexed:
                        	   535: ;
                        	   536: ;  save the value in case we find a second one
                        	   537: ;
                        	   538: ;  checking for another one may change VALUE so we do this now
                        	   539: ;
00:9ABF A500            	   540:   lda VALUE
00:9AC1 8506            	   541:   sta REMAIN
00:9AC3 A501            	   542:   lda VALUE+1
00:9AC5 8507            	   543:   sta REMAIN+1
00:9AC7 A502            	   544:   lda VALUE+2
00:9AC9 8508            	   545:   sta REMAIN+2
00:9ACB 208E9A          	   546:   jsr ass_check_we_have_x_or_y
00:9ACE 9016            	   547:   bcc ass_absolute_another_value
00:9AD0 C958            	   548:   cmp #'X'
00:9AD2 F009            	   549:   beq ass_indexed_x
00:9AD4 A904            	   550:   lda #ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
00:9AD6 856B            	   551:   sta ASS_OPERAND
00:9AD8 20F5C8          	   552:   jsr get_token ; skip the Y
00:9ADB 80D9            	   553:   bra ass_value_done
                        	   554: ass_indexed_x:
00:9ADD A903            	   555:   lda #ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
00:9ADF 856B            	   556:   sta ASS_OPERAND
00:9AE1 20F5C8          	   557:   jsr get_token ; skip the X
00:9AE4 80D0            	   558:   bra ass_value_done
                        	   559: 
                        	   560: ;
                        	   561: ;  this is hopefully something like BBR0 $42,foo
                        	   562: ;   so we need to evaluate foo
                        	   563: ;
                        	   564: ass_absolute_another_value:
00:9AE6 A593            	   565:   lda token_type ; get token back
00:9AE8 20FC9C          	   566:   jsr ass_get_value  ; should have some sort of address now in VALUE
                        	   567: ;  jsr ass_check_no_more_tokens
00:9AEB A912            	   568:   lda #ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE
00:9AED 856B            	   569:   sta ASS_OPERAND
00:9AEF 20F59A          	   570:   jsr opcode_lookup
00:9AF2 4C6E98          	   571:   jmp ass_finish_line
                        	   572: 
                        	   573: 
                        	   574: ;
                        	   575: ;  look up opcode
                        	   576: ;
                        	   577: opcode_lookup:
                        	   578:   ; the opcode we are looking up
00:9AF5 A56C            	   579:   lda OPCODE
00:9AF7 8500            	   580:   sta SRCE
00:9AF9 A56D            	   581:   lda OPCODE+1
00:9AFB 8501            	   582:   sta SRCE+1
00:9AFD 6472            	   583:   stz ASS_COUNT   ; count of matches
                        	   584: ;
                        	   585: ;  get the address of our table of tables
                        	   586: ;
00:9AFF A92B            	   587:   lda #<OPCODE_LOOKUP_TABLE
00:9B01 8570            	   588:   sta ASS_OPCODE_WORK
00:9B03 A99F            	   589:   lda #>OPCODE_LOOKUP_TABLE
00:9B05 8571            	   590:   sta ASS_OPCODE_WORK+1
                        	   591: opcode_lookup_loop:
00:9B07 A000            	   592:   ldy #OPCODE_LOOKUP_OPCODE_LENGTH
00:9B09 B170            	   593:   lda (ASS_OPCODE_WORK),Y       ; get opcode length
00:9B0B F058            	   594:   beq opcode_lookup_loop_done   ; end of table
00:9B0D C56E            	   595:   cmp OPCODE_LEN                ; right length?
00:9B0F F00F            	   596:   beq opcode_lookup_correct_length ; yes
                        	   597: ;
                        	   598: ; no, try the next table item
                        	   599: ;
                        	   600: opcode_lookup_next_table:
00:9B11 18              	   601:   clc
00:9B12 A570            	   602:   lda ASS_OPCODE_WORK
00:9B14 6906            	   603:   adc #OPCODE_LOOKUP_TABLE_SIZE  ; onto next item
00:9B16 8570            	   604:   sta ASS_OPCODE_WORK
00:9B18 A571            	   605:   lda ASS_OPCODE_WORK+1
00:9B1A 6900            	   606:   adc #0
00:9B1C 8571            	   607:   sta ASS_OPCODE_WORK+1
00:9B1E 80E7            	   608:   bra opcode_lookup_loop
                        	   609: opcode_lookup_correct_length:
00:9B20 A002            	   610:   ldy #OPCODE_LOOKUP_OPCODE_TABLE
00:9B22 B170            	   611:   lda (ASS_OPCODE_WORK),Y ; get table address low-order byte
00:9B24 8503            	   612:   sta DEST
00:9B26 C8              	   613:   iny
00:9B27 B170            	   614:   lda (ASS_OPCODE_WORK),Y ; get table address high-order byte
00:9B29 8504            	   615:   sta DEST+1
00:9B2B 20559E          	   616:   jsr ass_lookup_loop
00:9B2E 90E1            	   617:   bcc opcode_lookup_next_table  ; not found
00:9B30 AA              	   618:   tax   ; save the machine code byte
00:9B31 E672            	   619:   inc ASS_COUNT
00:9B33 A001            	   620:   ldy #OPCODE_LOOKUP_OPERAND_TYPE
00:9B35 A56B            	   621:   lda ASS_OPERAND         ; get wanted type of operand?
00:9B37 D170            	   622:   cmp (ASS_OPCODE_WORK),Y ; compare to operand type in table
00:9B39 F013            	   623:   beq opcode_lookup_correct_operand  ; yes
00:9B3B C906            	   624:   cmp #ASS_OPERAND_ACCUMULATOR_A  ; see if in range 1 to 5
00:9B3D B0D2            	   625:   bcs opcode_lookup_next_table
                        	   626: ;
                        	   627: ;  so if we have a so-called ASS_OPERAND_ABSOLUTE (with various indexing modes)
                        	   628: ;  see if we can match on ASS_OPERAND_ZERO_PAGE by adding 10 to the operand type
                        	   629: ;  - also applies to all the absolute modes (1 to 5)
                        	   630: ;
00:9B3F 18              	   631:   clc
00:9B40 690A            	   632:   adc #10
00:9B42 D170            	   633:   cmp (ASS_OPCODE_WORK),Y
00:9B44 D0CB            	   634:   bne opcode_lookup_next_table
                        	   635: ;
                        	   636: ;  plus, the operand has to be in the zero page
                        	   637: ;
00:9B46 A574            	   638:   lda ASS_VALUE+1
00:9B48 D0C7            	   639:   bne opcode_lookup_next_table
00:9B4A A575            	   640:   lda ASS_VALUE+2
00:9B4C D0C3            	   641:   bne opcode_lookup_next_table
                        	   642: opcode_lookup_correct_operand:
00:9B4E 8A              	   643:   txa   ; get the byte to emit back
                        	   644: 
                        	   645: ;
                        	   646: ; we have a match! emit the opcode
                        	   647: ;
00:9B4F 20799E          	   648:   jsr ass_emit            ; emit it
00:9B52 A004            	   649:   ldy #OPCODE_LOOKUP_HANDLER  ; offset of handler
00:9B54 B170            	   650:   lda (ASS_OPCODE_WORK),Y ; get opcode handler address low-order byte
00:9B56 AA              	   651:   tax
00:9B57 C8              	   652:   iny
00:9B58 B170            	   653:   lda (ASS_OPCODE_WORK),Y ; get opcode handler address high-order byte
00:9B5A F008            	   654:   beq opcode_lookup_no_handler
00:9B5C 8571            	   655:   sta ASS_OPCODE_WORK+1
00:9B5E 8A              	   656:   txa
00:9B5F 8570            	   657:   sta ASS_OPCODE_WORK
00:9B61 6C7000          	   658:   jmp (ASS_OPCODE_WORK)   ; do handler - it will RTS for us
                        	   659: 
                        	   660: opcode_lookup_no_handler:
                        	   661: ; put nothing here as it won't be done if there is a handler
00:9B64 60              	   662:   rts    ; done!
                        	   663: 
                        	   664: opcode_lookup_loop_done:
                        	   665: ;
                        	   666: ;  look for assembler directives
                        	   667: ;
00:9B65 A9CE            	   668:   lda #<DIRECTIVES
00:9B67 8503            	   669:   sta DEST
00:9B69 A99F            	   670:   lda #>DIRECTIVES
00:9B6B 8504            	   671:   sta DEST+1
00:9B6D A56E            	   672:   lda OPCODE_LEN
                        	   673: 
                        	   674: ;  pha
                        	   675: ;   lda #'c'
                        	   676: ;   jsr ass_debug_point
                        	   677: ;   pla
                        	   678: 
00:9B6F 200A8F          	   679:   jsr handlerLookup
00:9B72 9029            	   680:   bcc opcode_lookup_ok
                        	   681: 
                        	   682: ;   lda #'d'
                        	   683: ;   jsr ass_debug_point
                        	   684: 
                        	   685: ;
                        	   686: ;  here for unknown opcode
                        	   687: ;
00:9B74 A56C            	   688:   lda OPCODE
00:9B76 8590            	   689:   sta token_address
00:9B78 A56D            	   690:   lda OPCODE+1
00:9B7A 8591            	   691:   sta token_address+1
00:9B7C A56E            	   692:   lda OPCODE_LEN
00:9B7E 8592            	   693:   sta token_length
                        	   694: 
                        	   695: ;
                        	   696: ;  if we NEVER found a match, this is an illegal opcode
                        	   697: ;
00:9B80 A921            	   698:   lda #'!'
00:9B82 20AF93          	   699:   jsr COUT
00:9B85 A66E            	   700:   ldx OPCODE_LEN
00:9B87 A000            	   701:   ldy #0
                        	   702: wtf_loop:
00:9B89 B16C            	   703:    lda (OPCODE),Y
00:9B8B 20AF93          	   704:    jsr COUT
00:9B8E C8              	   705:    iny
00:9B8F CA              	   706:    dex
00:9B90 D0F7            	   707:    bne wtf_loop
                        	   708: 
                        	   709: 
00:9B92 A228            	   710:   ldx  #40    ; illegal opcode
00:9B94 A572            	   711:   lda ASS_COUNT
00:9B96 F002            	   712:   beq opcode_lookup_loop_unknown
                        	   713: ;
                        	   714: ;  if we found a match, but not for this addressing mode, they used an illegal mode
                        	   715: ;
00:9B98 A229            	   716:   ldx  #41   ; illegal addressing mode
                        	   717: opcode_lookup_loop_unknown:
00:9B9A 4CB79E          	   718:   JMP  ass_error
                        	   719: 
                        	   720: opcode_lookup_ok:
                        	   721: 
                        	   722: ;   lda #'e'
                        	   723: ; jsr ass_debug_point
                        	   724: 
00:9B9D 60              	   725:   rts
                        	   726: 
                        	   727: ass_done:
00:9B9E 202892          	   728:   jsr  CROUT
00:9BA1 A576            	   729:   LDA  ASS_PASS
00:9BA3 D003            	   730:   bne  ass_done_second_pass
00:9BA5 4C4F98          	   731:   jmp  ASSEMBLE_SECOND_PASS
                        	   732: ass_done_second_pass:
00:9BA8 A9C3            	   733:   LDA  #<ass_done_message  ; Assemble finished: No Errors
00:9BAA A29B            	   734:   LDX  #>ass_done_message
00:9BAC 202682          	   735:   JSR  print
00:9BAF A910            	   736:   lda  #FLAG_VALID_ASSEMBLE
00:9BB1 04BE            	   737:   tsb  system_flags
00:9BB3 20A88E          	   738:   jsr  show_symbol_table_end
00:9BB6 20CD8E          	   739:   jsr  show_source_end
00:9BB9 A582            	   740:   lda  show_symbols
00:9BBB F003            	   741:   beq  ass_done1
00:9BBD 2072A5          	   742:   jsr  list_symbols
                        	   743: ass_done1:
00:9BC0 4CCC82          	   744:   JMP  main_prompt
                        	   745: 
00:9BC3 417373656D626C65	   746: ass_done_message asciiz "Assemble finished: No errors\n"
00:9BCB 2066696E69736865
00:9BD3 643A204E6F206572
00:9BDB 726F72730A
00:9BE0 00
                        	   747: 
                        	   748: ass_check_no_more_tokens:
00:9BE1 A593            	   749:   lda token_type
00:9BE3 C93B            	   750:   cmp #';'          ; hit a comment?
00:9BE5 F009            	   751:   beq ass_check_no_more_tokens_ok
00:9BE7 C90A            	   752:   cmp #NL           ; or end of line?
00:9BE9 F005            	   753:   beq ass_check_no_more_tokens_ok
00:9BEB A213            	   754:   ldx #19    ; ERROR: incorrect symbol
00:9BED 4CB79E          	   755:   jmp ass_error
                        	   756: 
                        	   757: ass_check_no_more_tokens_ok:
00:9BF0 60              	   758:   rts
                        	   759: 
                        	   760: ;
                        	   761: ;  push a 3-byte value (in VALUE) onto the evaluation stack
                        	   762: ;    changes A and Y
                        	   763: ;
                        	   764: exp_push_value = *
00:9BF1 A57B            	   765:   lda exp_value_stack_count
00:9BF3 C9FF            	   766:   cmp #$FF
00:9BF5 D005            	   767:   bne exp_push_value_ok
                        	   768: exp_push_value_memory_full:
00:9BF7 A22E            	   769:   ldx #46   ; ERROR: Expression too complex
00:9BF9 4CB79E          	   770:   jmp ass_error
                        	   771: exp_push_value_ok:
00:9BFC E67B            	   772:   inc exp_value_stack_count
00:9BFE 38              	   773:   sec
00:9BFF A579            	   774:   lda exp_value_stack
00:9C01 E903            	   775:   sbc #3
00:9C03 8579            	   776:   sta exp_value_stack
00:9C05 A57A            	   777:   lda exp_value_stack+1
00:9C07 E900            	   778:   sbc #0
00:9C09 857A            	   779:   sta exp_value_stack+1
                        	   780: ;
                        	   781: ;  has our expression value fallen down into our P-codes?
                        	   782: ;
                        	   783: ;  This doesn't work if the output (PCODE) has been relocated to above
                        	   784: ;  the symbol table and I can't think of an easy solution, so let's ignore
                        	   785: ;  it and hope it doesn't happen.
                        	   786: ;
                        	   787: ;
                        	   788: ; lda  PCODE+1               ; see if P-codes full
                        	   789: ; cmp  exp_value_stack+1     ; in other words, have we hit the symbol table?
                        	   790: ; bcc  exp_push_value_not_full      ; less than
                        	   791: ; bne  exp_push_value_memory_full   ; greater than
                        	   792: ; lda  PCODE
                        	   793: ; cmp  exp_value_stack
                        	   794: ; bcs  exp_push_value_memory_full   ; BGE
                        	   795: 
                        	   796: exp_push_value_not_full:
00:9C0B A000            	   797:   ldy #0
00:9C0D A500            	   798:   lda VALUE
00:9C0F 9179            	   799:   sta (exp_value_stack),y
00:9C11 C8              	   800:   iny
00:9C12 A501            	   801:   lda VALUE+1
00:9C14 9179            	   802:   sta (exp_value_stack),y
00:9C16 C8              	   803:   iny
00:9C17 A502            	   804:   lda VALUE+2
00:9C19 9179            	   805:   sta (exp_value_stack),y
00:9C1B 60              	   806:   rts
                        	   807: 
                        	   808: ;
                        	   809: ;  pop a 3-byte value (into VALUE) from the evaluation stack
                        	   810: ;    changes A and Y
                        	   811: ;
                        	   812: exp_pop_value = *
00:9C1C A57B            	   813:   lda exp_value_stack_count
00:9C1E D005            	   814:   bne exp_pop_value_ok
00:9C20 A217            	   815:   ldx #23    ; ERROR: illegal factor
00:9C22 4CB79E          	   816:   jmp ass_error
                        	   817: exp_pop_value_ok:
00:9C25 C67B            	   818:   dec exp_value_stack_count
00:9C27 A000            	   819:   ldy #0
00:9C29 B179            	   820:   lda (exp_value_stack),y
00:9C2B 8500            	   821:   sta VALUE
00:9C2D C8              	   822:   iny
00:9C2E B179            	   823:   lda (exp_value_stack),y
00:9C30 8501            	   824:   sta VALUE+1
00:9C32 C8              	   825:   iny
00:9C33 B179            	   826:   lda (exp_value_stack),y
00:9C35 8502            	   827:   sta VALUE+2
00:9C37 18              	   828:   clc
00:9C38 A579            	   829:   lda exp_value_stack
00:9C3A 6903            	   830:   adc #3
00:9C3C 8579            	   831:   sta exp_value_stack
00:9C3E A57A            	   832:   lda exp_value_stack+1
00:9C40 6900            	   833:   adc #0
00:9C42 857A            	   834:   sta exp_value_stack+1
00:9C44 60              	   835:   rts
                        	   836: 
                        	   837: ;
                        	   838: ;  I needed a work area for operators, and initially used INBUF however that got
                        	   839: ;  repurposed for managing strings (in particular handling \Xnn and double quotes)
                        	   840: ;  so now I am using the memory at the current PCODE address as a work area.
                        	   841: ;  It is only needed during expression evaluation, and should hopefully be available.
                        	   842: ;
                        	   843: ;
                        	   844: ;  push an operator (A) onto the operator stack
                        	   845: ;   changes X and Y
                        	   846: ;
                        	   847: exp_push_operator:
00:9C45 A67C            	   848:   ldx exp_operator_stack_count
00:9C47 E0FA            	   849:   cpx #250  ; make sure we don't overflow our operator stack
00:9C49 9005            	   850:   bcc exp_push_operator_ok
00:9C4B A22E            	   851:   ldx #46   ; ERROR: Expression too complex
00:9C4D 4CB79E          	   852:   jmp ass_error
                        	   853: exp_push_operator_ok:
00:9C50 E67C            	   854:   inc exp_operator_stack_count  ; add, then store
00:9C52 A47C            	   855:   ldy exp_operator_stack_count
00:9C54 9123            	   856:   sta (PCODE),Y
00:9C56 60              	   857:   rts
                        	   858: 
                        	   859: ;
                        	   860: ;  pop an operator (into A) from the operator stack
                        	   861: ;   changes X and Y
                        	   862: ;
                        	   863: exp_pop_operator:
00:9C57 A67C            	   864:   ldx exp_operator_stack_count
00:9C59 D005            	   865:   bne exp_pop_operator_ok
00:9C5B A217            	   866:   ldx #23   ; ERROR: Illegal factor
00:9C5D 4CB79E          	   867:   jmp ass_error
                        	   868: exp_pop_operator_ok:
00:9C60 A47C            	   869:   ldy exp_operator_stack_count  ; retrieve, then decrement
00:9C62 B123            	   870:   lda (PCODE),Y
00:9C64 C67C            	   871:   dec exp_operator_stack_count
00:9C66 60              	   872:   rts
                        	   873: 
                        	   874: ;
                        	   875: ;  get an operator (into A) from the operator stack (without removing it)
                        	   876: ;   changes X and Y
                        	   877: ;
                        	   878: exp_get_operator:
00:9C67 A67C            	   879:   ldx exp_operator_stack_count
00:9C69 D005            	   880:   bne exp_get_operator_ok
00:9C6B A217            	   881:   ldx #23   ; ERROR: Illegal factor
00:9C6D 4CB79E          	   882:   jmp ass_error
                        	   883: exp_get_operator_ok:
00:9C70 A47C            	   884:   ldy exp_operator_stack_count
00:9C72 B123            	   885:   lda (PCODE),Y
00:9C74 60              	   886:   rts
                        	   887: 
                        	   888:  .macro makePrecedenceTable ; table of operators, precedence, handler
                        	   889:    dfb   \1
                        	   890:    dfb   \2
                        	   891:    word  \3
                        	   892:  .endmacro
                        	   893: 
                        	   894: ; cannot have more than 64 entries because we index into this with X
                        	   895: exp_precedence_table:
                        	   896:   makePrecedenceTable '~', 1, exp_negate
00:9C75 7E              	     1M    dfb   '~'
00:9C76 01              	     2M    dfb   1
00:9C77 6CAB            	     3M    word  exp_negate
                        	   897:   makePrecedenceTable '!', 1, exp_not
00:9C79 21              	     1M    dfb   '!'
00:9C7A 01              	     2M    dfb   1
00:9C7B 7FAB            	     3M    word  exp_not
                        	   898:   makePrecedenceTable TOKEN_UNARY_MINUS, 1, exp_unary_minus
00:9C7D 4D              	     1M    dfb   TOKEN_UNARY_MINUS
00:9C7E 01              	     2M    dfb   1
00:9C7F 8DAB            	     3M    word  exp_unary_minus
                        	   899:   makePrecedenceTable TOKEN_LOW_BYTE, 1, exp_low_byte
00:9C81 56              	     1M    dfb   TOKEN_LOW_BYTE
00:9C82 01              	     2M    dfb   1
00:9C83 A1AB            	     3M    word  exp_low_byte
                        	   900:   makePrecedenceTable TOKEN_HIGH_BYTE, 1, exp_high_byte
00:9C85 57              	     1M    dfb   TOKEN_HIGH_BYTE
00:9C86 01              	     2M    dfb   1
00:9C87 A6AB            	     3M    word  exp_high_byte
                        	   901:   makePrecedenceTable TOKEN_SHIFT_LEFT, 2, exp_shift_left
00:9C89 4C              	     1M    dfb   TOKEN_SHIFT_LEFT
00:9C8A 02              	     2M    dfb   2
00:9C8B 3AAB            	     3M    word  exp_shift_left
                        	   902:   makePrecedenceTable TOKEN_SHIFT_RIGHT, 2, exp_shift_right
00:9C8D 52              	     1M    dfb   TOKEN_SHIFT_RIGHT
00:9C8E 02              	     2M    dfb   2
00:9C8F 53AB            	     3M    word  exp_shift_right
                        	   903:   makePrecedenceTable '&', 3, exp_bitwise_and
00:9C91 26              	     1M    dfb   '&'
00:9C92 03              	     2M    dfb   3
00:9C93 E9AA            	     3M    word  exp_bitwise_and
                        	   904:   makePrecedenceTable '^', 4, exp_bitwise_xor
00:9C95 5E              	     1M    dfb   '^'
00:9C96 04              	     2M    dfb   4
00:9C97 FEAA            	     3M    word  exp_bitwise_xor
                        	   905:   makePrecedenceTable '|', 5, exp_bitwise_or
00:9C99 7C              	     1M    dfb   '|'
00:9C9A 05              	     2M    dfb   5
00:9C9B D4AA            	     3M    word  exp_bitwise_or
                        	   906:   makePrecedenceTable '*', 6, exp_multiply
00:9C9D 2A              	     1M    dfb   '*'
00:9C9E 06              	     2M    dfb   6
00:9C9F 14AC            	     3M    word  exp_multiply
                        	   907:   makePrecedenceTable '/', 6, exp_divide
00:9CA1 2F              	     1M    dfb   '/'
00:9CA2 06              	     2M    dfb   6
00:9CA3 4DAC            	     3M    word  exp_divide
                        	   908:   makePrecedenceTable '%', 6, exp_modulo
00:9CA5 25              	     1M    dfb   '%'
00:9CA6 06              	     2M    dfb   6
00:9CA7 ADAC            	     3M    word  exp_modulo
                        	   909:   makePrecedenceTable '+', 7, exp_add
00:9CA9 2B              	     1M    dfb   '+'
00:9CAA 07              	     2M    dfb   7
00:9CAB 46AA            	     3M    word  exp_add
                        	   910:   makePrecedenceTable '-', 7, exp_subtract
00:9CAD 2D              	     1M    dfb   '-'
00:9CAE 07              	     2M    dfb   7
00:9CAF 5AAA            	     3M    word  exp_subtract
                        	   911:   makePrecedenceTable '<', 8, exp_less_than
00:9CB1 3C              	     1M    dfb   '<'
00:9CB2 08              	     2M    dfb   8
00:9CB3 A8AA            	     3M    word  exp_less_than
                        	   912:   makePrecedenceTable '>', 8, exp_greater_than
00:9CB5 3E              	     1M    dfb   '>'
00:9CB6 08              	     2M    dfb   8
00:9CB7 AFAA            	     3M    word  exp_greater_than
                        	   913:   makePrecedenceTable TOKEN_LEQ, 8, exp_leq
00:9CB9 80              	     1M    dfb   TOKEN_LEQ
00:9CBA 08              	     2M    dfb   8
00:9CBB BEAA            	     3M    word  exp_leq
                        	   914:   makePrecedenceTable TOKEN_GEQ, 8, exp_geq
00:9CBD 81              	     1M    dfb   TOKEN_GEQ
00:9CBE 08              	     2M    dfb   8
00:9CBF CDAA            	     3M    word  exp_geq
                        	   915:   makePrecedenceTable TOKEN_EQUALITY, 9, exp_eql
00:9CC1 45              	     1M    dfb   TOKEN_EQUALITY
00:9CC2 09              	     2M    dfb   9
00:9CC3 80AA            	     3M    word  exp_eql
                        	   916:   makePrecedenceTable TOKEN_NEQ, 9, exp_neq     ; <>
00:9CC5 55              	     1M    dfb   TOKEN_NEQ
00:9CC6 09              	     2M    dfb   9
00:9CC7 94AA            	     3M    word  exp_neq     
                        	   917:   makePrecedenceTable TOKEN_INEQUALITY, 9, exp_neq  ; !=
00:9CC9 5A              	     1M    dfb   TOKEN_INEQUALITY
00:9CCA 09              	     2M    dfb   9
00:9CCB 94AA            	     3M    word  exp_neq  
                        	   918:   makePrecedenceTable TOKEN_LOGICAL_AND, 10, exp_logical_and
00:9CCD 58              	     1M    dfb   TOKEN_LOGICAL_AND
00:9CCE 0A              	     2M    dfb   10
00:9CCF 28AB            	     3M    word  exp_logical_and
                        	   919:   makePrecedenceTable TOKEN_LOGICAL_OR, 11, exp_logical_or
00:9CD1 59              	     1M    dfb   TOKEN_LOGICAL_OR
00:9CD2 0B              	     2M    dfb   11
00:9CD3 19AB            	     3M    word  exp_logical_or
                        	   920: 
                        	   921: exp_precedence_table_end = *
                        	   922: 
                        	   923: ;
                        	   924: ;  finds precedence of operator in A, returns it in Y (returns 0 if not found)
                        	   925: ;    changes X, A
                        	   926: ;  also stores the operator evaluation function (eg. exp_add) in exp_evaluation_function
                        	   927: ;
                        	   928: exp_get_precedence:
00:9CD5 A200            	   929:   ldx #0
                        	   930: exp_get_precedence_loop:
00:9CD7 DD759C          	   931:   cmp exp_precedence_table,x
00:9CDA F00F            	   932:   beq exp_get_precedence_found
00:9CDC E8              	   933:   inx   ; skip operator
00:9CDD E8              	   934:   inx   ; skip precedence
00:9CDE E8              	   935:   inx   ; skip evaluation function
00:9CDF E8              	   936:   inx   ;  (2 bytes)
00:9CE0 E060            	   937:   cpx #exp_precedence_table_end - exp_precedence_table
00:9CE2 90F3            	   938:   bcc exp_get_precedence_loop
00:9CE4 A000            	   939:   ldy #0
00:9CE6 647F            	   940:   stz exp_evaluation_function
00:9CE8 6480            	   941:   stz exp_evaluation_function+1
00:9CEA 60              	   942:   rts
                        	   943: exp_get_precedence_found:
00:9CEB E8              	   944:   inx
00:9CEC BC759C          	   945:   ldy exp_precedence_table,x
00:9CEF E8              	   946:   inx
00:9CF0 BD759C          	   947:   lda exp_precedence_table,x
00:9CF3 857F            	   948:   sta exp_evaluation_function
00:9CF5 E8              	   949:   inx
00:9CF6 BD759C          	   950:   lda exp_precedence_table,x
00:9CF9 8580            	   951:   sta exp_evaluation_function+1
00:9CFB 60              	   952:   rts
                        	   953: 
                        	   954: ;
                        	   955: ;  Convert an expression into a value
                        	   956: ;
                        	   957: ;   Ideas from https://www.geeksforgeeks.org/expression-evaluation/
                        	   958: ;
                        	   959: ass_get_value:
                        	   960: ;
                        	   961: ;  set up expression evaluation stack
                        	   962: ;
00:9CFC 647B            	   963:   stz exp_value_stack_count
00:9CFE 647C            	   964:   stz exp_operator_stack_count
00:9D00 A531            	   965:   lda ENDSYM
00:9D02 8579            	   966:   sta exp_value_stack
00:9D04 A532            	   967:   lda ENDSYM+1
00:9D06 857A            	   968:   sta exp_value_stack+1
                        	   969: 
00:9D08 6473            	   970:   stz ASS_VALUE
00:9D0A 6474            	   971:   stz ASS_VALUE+1
00:9D0C 6475            	   972:   stz ASS_VALUE+2
00:9D0E A901            	   973:   lda #1
00:9D10 8581            	   974:   sta exp_unary_ok  ; unary operators can appear at the start of the expression
00:9D12 A593            	   975:   lda token_type
                        	   976: ;  jsr START_TRACE
                        	   977: ;
                        	   978: ;  one token lookahead
                        	   979: ;
00:9D14 8003            	   980:   bra ass_expression_loop_initial
                        	   981: 
                        	   982: ;
                        	   983: ;  1.1 Get the next token
                        	   984: ;
                        	   985: ass_expression_loop:
00:9D16 20F5C8          	   986:   jsr get_token
                        	   987: ass_expression_loop_initial:
                        	   988: 
                        	   989: ;
                        	   990: ;  1.2.1 If it's a number, push onto the value stack
                        	   991: ;
00:9D19 C94E            	   992:   cmp #TOKEN_NUMBER
00:9D1B D013            	   993:   bne ass_expression_loop1a
                        	   994: ass_expression_number:
00:9D1D A594            	   995:   lda token_value
00:9D1F 8500            	   996:   sta VALUE
00:9D21 A595            	   997:   lda token_value+1
00:9D23 8501            	   998:   sta VALUE+1
00:9D25 A596            	   999:   lda token_value+2
00:9D27 8502            	  1000:   sta VALUE+2
00:9D29 20F19B          	  1001:   jsr exp_push_value
00:9D2C 6481            	  1002:   stz exp_unary_ok          ; don't have unary operators after numbers
00:9D2E 80E6            	  1003:   bra ass_expression_loop
                        	  1004: ;
                        	  1005: ;  if it's a string and only 1 or 2 bytes, consider as a number
                        	  1006: ;
                        	  1007: ass_expression_loop1a:
00:9D30 C922            	  1008:   cmp #TOKEN_STRING
00:9D32 D013            	  1009:   bne ass_expression_loop1
00:9D34 A592            	  1010:   lda token_length
00:9D36 C903            	  1011:   cmp #3
00:9D38 B008            	  1012:   bcs ass_expression_not_small_string  ; too long?
                        	  1013: ;
                        	  1014: ;  one or two character string - is this an immediate operand?
                        	  1015: ;
00:9D3A A56B            	  1016:   lda ASS_OPERAND
00:9D3C C907            	  1017:   cmp #ASS_OPERAND_IMMEDIATE
00:9D3E D002            	  1018:   bne ass_expression_not_small_string
00:9D40 80DB            	  1019:   bra ass_expression_number   ; treat as a number (its value should be in VALUE)
                        	  1020: 
                        	  1021: ass_expression_not_small_string:
00:9D42 A21D            	  1022:   ldx #29     ; string literal too big
00:9D44 4CB79E          	  1023:   jmp ass_error
                        	  1024: 
                        	  1025: ;
                        	  1026: ;  1.2.2 If it's an identifier, get its value and push onto the value stack
                        	  1027: ;
                        	  1028: ass_expression_loop1:
00:9D47 C949            	  1029:   cmp #TOKEN_IDENTIFIER
00:9D49 D029            	  1030:   bne ass_expression_loop2
00:9D4B 6481            	  1031:   stz exp_unary_ok          ; don't have unary operators after identifiers
                        	  1032: 
00:9D4D 207DB8          	  1033:   jsr SEARCH    ; should be in symbol table as a constant, and the value in VALUE
00:9D50 D011            	  1034:   bne ass_expression_found_value
00:9D52 A576            	  1035:   lda ASS_PASS
00:9D54 F005            	  1036:   beq ass_label_not_found_yet
                        	  1037: 
                        	  1038: ;
                        	  1039: ; it's an error if it isn't there on the second pass
                        	  1040: ;
00:9D56 A20B            	  1041:   ldx #11  ; ERROR: Undeclared Identifier
00:9D58 4CB79E          	  1042:   jmp ass_error
                        	  1043: 
                        	  1044: ;
                        	  1045: ;  label not found on first pass, make the value 0x6666 for now
                        	  1046: ;   - we don't want a zero-page address assumption because that
                        	  1047: ;     will throw out opcode lengths (it might assume a zero page opcode
                        	  1048: ;     which is shorter and then change it to a longer one)
                        	  1049: ;
                        	  1050: ass_label_not_found_yet:
00:9D5B A966            	  1051:   lda #$66
00:9D5D 8500            	  1052:   sta VALUE
00:9D5F 8501            	  1053:   sta VALUE+1
00:9D61 6402            	  1054:   stz VALUE+2
                        	  1055: ass_expression_found_value:
00:9D63 A594            	  1056:   lda token_value
00:9D65 8500            	  1057:   sta VALUE
00:9D67 A595            	  1058:   lda token_value+1
00:9D69 8501            	  1059:   sta VALUE+1
00:9D6B A596            	  1060:   lda token_value+2
00:9D6D 8502            	  1061:   sta VALUE+2
00:9D6F 20F19B          	  1062:   jsr exp_push_value
00:9D72 80A2            	  1063:   bra ass_expression_loop
                        	  1064: 
                        	  1065: ;
                        	  1066: ; 1.2.3 If it's a left parenthesis: push it onto the operator stack.
                        	  1067: ;
                        	  1068: ass_expression_loop2:
00:9D74 C928            	  1069:   cmp #'('
00:9D76 D00B            	  1070:   bne ass_expression_loop3
00:9D78 48              	  1071:   pha
00:9D79 A901            	  1072:   lda  #1
00:9D7B 8581            	  1073:   sta exp_unary_ok          ; unary operators can follow left parentheses
00:9D7D 68              	  1074:   pla
                        	  1075: 
00:9D7E 20459C          	  1076:   jsr exp_push_operator
00:9D81 8093            	  1077:   bra ass_expression_loop
                        	  1078: 
                        	  1079: ;
                        	  1080: ;  1.2.4 A right parenthesis:
                        	  1081: ;       1 While the thing on top of the operator stack is not a
                        	  1082: ;         left parenthesis,
                        	  1083: ;           1 Pop the operator from the operator stack.
                        	  1084: ;           2 Pop the value stack twice, getting two operands.
                        	  1085: ;           3 Apply the operator to the operands, in the correct order.
                        	  1086: ;           4 Push the result onto the value stack.
                        	  1087: ;        2 Pop the left parenthesis from the operator stack, and discard it.
                        	  1088: 
                        	  1089: 
                        	  1090: ass_expression_loop3:
00:9D83 C929            	  1091:   cmp #')'
00:9D85 D016            	  1092:   bne ass_expression_loop4
                        	  1093: ass_expression_loop3b:
                        	  1094: ;
                        	  1095: ;  a RH parenthesis with an empty operator stack is probably the end of the expression, eg. ($1234),x
                        	  1096: ;  where the ")" belongs to the indexed operand stuff and not the expression
                        	  1097: ;
00:9D87 A57C            	  1098:   lda exp_operator_stack_count
00:9D89 F060            	  1099:   beq exp_no_operators_left
00:9D8B 20679C          	  1100:   jsr exp_get_operator
00:9D8E C928            	  1101:   cmp #'('
00:9D90 F005            	  1102:   beq ass_expression_loop3c
                        	  1103: ;
                        	  1104: ;  not a left parenthesis
                        	  1105: ;
                        	  1106: ass_expression_loop3a:
00:9D92 20119E          	  1107:   jsr ass_expression_apply_operator ; pop the operator and two values, apply the operator and push the result
00:9D95 80F0            	  1108:   bra ass_expression_loop3b          ; keep going until we don't have a left parenthesis
                        	  1109: 
                        	  1110: ass_expression_loop3c:
00:9D97 20579C          	  1111:   jsr exp_pop_operator              ;  2 Pop the left parenthesis from the operator stack, and discard it.
                        	  1112: ass_expression_loopJ:
00:9D9A 4C169D          	  1113:   jmp ass_expression_loop
                        	  1114: 
                        	  1115: ;       1.2.5 An operator (call it thisOp):
                        	  1116: ;         1 While the operator stack is not empty, and the top thing on the
                        	  1117: ;           operator stack has the same or greater precedence as thisOp,
                        	  1118: ;           1 Pop the operator from the operator stack.
                        	  1119: ;           2 Pop the value stack twice, getting two operands.
                        	  1120: ;           3 Apply the operator to the operands, in the correct order.
                        	  1121: ;           4 Push the result onto the value stack.
                        	  1122: ;         2 Push thisOp onto the operator stack.
                        	  1123: 
                        	  1124: ass_expression_loop4:
                        	  1125: ;
                        	  1126: ;  look for unary operators
                        	  1127: ;
00:9D9D A681            	  1128:   ldx exp_unary_ok
00:9D9F F01C            	  1129:   beq ass_expression_cannot_be_unary
00:9DA1 C92D            	  1130:   cmp #'-'
00:9DA3 D006            	  1131:   bne ass_not_unary_minus
00:9DA5 A94D            	  1132:   lda #TOKEN_UNARY_MINUS
00:9DA7 8593            	  1133:   sta token_type
00:9DA9 8012            	  1134:   bra ass_expression_cannot_be_unary
                        	  1135: ass_not_unary_minus:
00:9DAB C93C            	  1136:   cmp #'<'
00:9DAD D006            	  1137:   bne ass_not_unary_less_than
00:9DAF A956            	  1138:   lda #TOKEN_LOW_BYTE
00:9DB1 8593            	  1139:   sta token_type
00:9DB3 8008            	  1140:   bra ass_expression_cannot_be_unary
                        	  1141: ass_not_unary_less_than:
00:9DB5 C93E            	  1142:   cmp #'>'
00:9DB7 D004            	  1143:   bne ass_expression_cannot_be_unary
00:9DB9 A957            	  1144:   lda #TOKEN_HIGH_BYTE
00:9DBB 8593            	  1145:   sta token_type
                        	  1146: ass_expression_cannot_be_unary:
00:9DBD 48              	  1147:   pha
00:9DBE A901            	  1148:   lda #1
00:9DC0 8581            	  1149:   sta exp_unary_ok          ; can have unary operators after operators
00:9DC2 68              	  1150:   pla
                        	  1151: 
00:9DC3 20D59C          	  1152:   jsr exp_get_precedence
00:9DC6 847E            	  1153:   sty exp_operator_precedence ; thisOp's precedence
00:9DC8 C000            	  1154:   cpy #0
00:9DCA F01F            	  1155:   beq exp_no_operators_left
                        	  1156: 
                        	  1157: ass_expression_loop7:         ; 1 While the operator stack is not empty
00:9DCC A57C            	  1158:   lda exp_operator_stack_count
00:9DCE F013            	  1159:   beq ass_expression_loop6    ; stack empty
00:9DD0 20679C          	  1160:   jsr exp_get_operator    ; find the top thing on the operator stack
00:9DD3 C928            	  1161:   cmp #'('                ; if a bracket, consider that low precedence
00:9DD5 F00C            	  1162:   beq ass_expression_loop6
00:9DD7 20D59C          	  1163:   jsr exp_get_precedence  ; and its precedence
00:9DDA C47E            	  1164:   cpy exp_operator_precedence
00:9DDC B005            	  1165:   bcs ass_expression_loop6  ; thing on top has less precedence (a higher value) than thisOp
00:9DDE 20119E          	  1166:   jsr ass_expression_apply_operator  ; pop the operator and two values, apply the operator and push the result
00:9DE1 80E9            	  1167:   bra ass_expression_loop7
                        	  1168: 
                        	  1169: ass_expression_loop6:
00:9DE3 A593            	  1170:   lda token_type       ; thisOp
00:9DE5 20459C          	  1171:   jsr exp_push_operator
00:9DE8 4C169D          	  1172:   jmp ass_expression_loop
                        	  1173: 
                        	  1174: 
                        	  1175: ; 2. While the operator stack is not empty,
                        	  1176: ;     1 Pop the operator from the operator stack.
                        	  1177: ;     2 Pop the value stack twice, getting two operands.
                        	  1178: ;     3 Apply the operator to the operands, in the correct order.
                        	  1179: ;     4 Push the result onto the value stack.
                        	  1180: 
                        	  1181: 
                        	  1182: exp_no_operators_left:
00:9DEB A57C            	  1183:     lda exp_operator_stack_count
00:9DED F005            	  1184:     beq exp_done
00:9DEF 20119E          	  1185:     jsr ass_expression_apply_operator ; pop the operator and two values, apply the operator and push the result
00:9DF2 80F7            	  1186:     bra exp_no_operators_left
                        	  1187: 
                        	  1188: exp_done:
00:9DF4 A57B            	  1189:       lda exp_value_stack_count
00:9DF6 C901            	  1190:       cmp #1
00:9DF8 F005            	  1191:       beq exp_done_ok
                        	  1192: exp_done_error:
00:9DFA A217            	  1193:       ldx #23       ; ERROR: Illegal factor
00:9DFC 4CB79E          	  1194:       jmp ass_error
                        	  1195: 
                        	  1196: exp_done_ok:
00:9DFF A57C            	  1197:       lda exp_operator_stack_count
00:9E01 D0F7            	  1198:       bne exp_done_error
00:9E03 201C9C          	  1199:       jsr exp_pop_value   ; pop the finished value
00:9E06 A500            	  1200:       lda VALUE
00:9E08 8573            	  1201:       sta ASS_VALUE
00:9E0A A501            	  1202:       lda VALUE+1
00:9E0C 8574            	  1203:       sta ASS_VALUE+1
00:9E0E 6475            	  1204:       stz ASS_VALUE+2   ; make high-order byte zero just in case
00:9E10 60              	  1205:       rts
                        	  1206: 
                        	  1207: ;
                        	  1208: ;
                        	  1209: ;     1 Pop the operator from the operator stack.
                        	  1210: ;     2 Pop the value stack twice, getting two operands.
                        	  1211: ;     3 Apply the operator to the operands, in the correct order.
                        	  1212: ;     4 Push the result onto the value stack.
                        	  1213: 
                        	  1214: ;
                        	  1215: ass_expression_apply_operator:
00:9E11 201C9C          	  1216:   jsr exp_pop_value         ; 2 Pop the value stack twice, getting two operands.
00:9E14 20679C          	  1217:   jsr exp_get_operator
00:9E17 C97E            	  1218:   cmp #'~'
00:9E19 F01F            	  1219:   beq ass_expression_unary
00:9E1B C921            	  1220:   cmp #'!'
00:9E1D F01B            	  1221:   beq ass_expression_unary
00:9E1F C94D            	  1222:   cmp #TOKEN_UNARY_MINUS
00:9E21 F017            	  1223:   beq ass_expression_unary
00:9E23 C956            	  1224:   cmp #TOKEN_LOW_BYTE
00:9E25 F013            	  1225:   beq ass_expression_unary
00:9E27 C957            	  1226:   cmp #TOKEN_HIGH_BYTE
00:9E29 F00F            	  1227:   beq ass_expression_unary
                        	  1228: 
                        	  1229: ;
                        	  1230: ;  if a binary operator get the second value
                        	  1231: ;
00:9E2B A500            	  1232:   lda VALUE                 ; copy top value to VALUE2
00:9E2D 8503            	  1233:   sta VALUE2
00:9E2F A501            	  1234:   lda VALUE+1
00:9E31 8504            	  1235:   sta VALUE2+1
00:9E33 A502            	  1236:   lda VALUE+2
00:9E35 8505            	  1237:   sta VALUE2+2
00:9E37 201C9C          	  1238:   jsr exp_pop_value         ; second pop
                        	  1239: ass_expression_unary:
                        	  1240: 
                        	  1241: ;
                        	  1242: ;  now we have the top two values in VALUE (and VALUE2 in the case of binary operators)
                        	  1243: ;
00:9E3A 20579C          	  1244:   jsr exp_pop_operator      ; 1 Pop the operator from the operator stack.
00:9E3D 857D            	  1245:   sta exp_operator
00:9E3F 20D59C          	  1246:   jsr exp_get_precedence    ; find the evaluation function
00:9E42 C000            	  1247:   cpy #0
00:9E44 F0CB            	  1248:   beq ass_expression_apply_operator ; should not be here if the operator isn't in the table
00:9E46 20529E          	  1249:   jsr ass_evaluate_operator ; do the evaluation
00:9E49 20F19B          	  1250:   jsr exp_push_value        ; 4 Push the result onto the value stack.
00:9E4C 60              	  1251:   rts
                        	  1252: 
                        	  1253: ass_expression_apply_operator_bug:
00:9E4D A206            	  1254:   ldx #6
00:9E4F 4CB79E          	  1255:   jmp ass_error
                        	  1256: 
                        	  1257: ass_evaluate_operator:
00:9E52 6C7F00          	  1258:   jmp (exp_evaluation_function)
                        	  1259: 
                        	  1260: 
                        	  1261: ;
                        	  1262: ;  look up opcodes in a table
                        	  1263: ;  returns carry set if found, carry clear if not found
                        	  1264: ;
                        	  1265: ass_lookup_loop:
00:9E55 A46E            	  1266:   ldy OPCODE_LEN
00:9E57 202D92          	  1267:   jsr COMSTL
00:9E5A F017            	  1268:   beq ass_opcode_found
                        	  1269: ;
                        	  1270: ;  add the opcode length, plus 1 to DEST
                        	  1271: ;
00:9E5C 18              	  1272:   clc
00:9E5D A46E            	  1273:   ldy OPCODE_LEN
00:9E5F C8              	  1274:   iny
00:9E60 98              	  1275:   tya
00:9E61 6503            	  1276:   adc DEST
00:9E63 8503            	  1277:   sta DEST
00:9E65 A504            	  1278:   lda DEST+1
00:9E67 6900            	  1279:   adc #0
00:9E69 8504            	  1280:   sta DEST+1
                        	  1281: ;
                        	  1282: ;  end of table?
                        	  1283: ;
00:9E6B A000            	  1284:   ldy #0
00:9E6D B103            	  1285:   lda (DEST),Y
00:9E6F D0E4            	  1286:   bne ass_lookup_loop   ; not yet
00:9E71 18              	  1287:   clc
00:9E72 60              	  1288:   rts
                        	  1289: 
                        	  1290: 
                        	  1291: ass_opcode_found:
00:9E73 A46E            	  1292:   ldy OPCODE_LEN
00:9E75 B103            	  1293:   lda (DEST),Y
00:9E77 38              	  1294:   sec   ; indicate found
00:9E78 60              	  1295:   rts
                        	  1296: 
                        	  1297: ass_emit:
00:9E79 A476            	  1298:   ldy ASS_PASS
00:9E7B F031            	  1299:   beq ass_emit3  ; only emit codes on 2nd pass
                        	  1300:   ;
                        	  1301:   ;  first time for this line of code, indent by two spaces
                        	  1302:   ;
00:9E7D A46F            	  1303:   ldy ASS_EMIT_COUNT
00:9E7F D00C            	  1304:   bne ass_emit2
00:9E81 A42E            	  1305:   ldy DCODE
00:9E83 F008            	  1306:   beq ass_emit2
00:9E85 48              	  1307:   pha
00:9E86 20B392          	  1308:   jsr PUTSP
00:9E89 20B392          	  1309:   jsr PUTSP
00:9E8C 68              	  1310:   pla
                        	  1311: ass_emit2:
                        	  1312: ;
                        	  1313: ;  if this is the *first* byte we emitted, then make that the start address
                        	  1314: ;  for running the code. That is, if you relocate the code, the first byte
                        	  1315: ;  actually emitted will be considered the runtime address.
                        	  1316: ;
                        	  1317: ;  this lets you relocate code (eg. to $4500) and have it run from there if
                        	  1318: ;  you happen to hit Run.
                        	  1319: ;
00:9E8D 48              	  1320:   pha
00:9E8E A577            	  1321:   lda ass_emit_bytes
00:9E90 0578            	  1322:   ora ass_emit_bytes+1
00:9E92 D008            	  1323:   bne ass_already_emitted
00:9E94 A523            	  1324:   lda PCODE
00:9E96 8525            	  1325:   sta ACT_PCDA
00:9E98 A524            	  1326:   lda PCODE+1
00:9E9A 8526            	  1327:   sta ACT_PCDA+1
                        	  1328: ass_already_emitted:
00:9E9C 68              	  1329:   pla
                        	  1330: ;
                        	  1331: ;  write the byte to memory
                        	  1332: ;
00:9E9D A000            	  1333:   ldy #0
00:9E9F 9123            	  1334:   sta (PCODE),Y
00:9EA1 E677            	  1335:   inc ass_emit_bytes
00:9EA3 D002            	  1336:   bne ass_emit4
00:9EA5 E678            	  1337:   inc ass_emit_bytes+1
                        	  1338: ass_emit4:
                        	  1339: 
                        	  1340: ;
                        	  1341: ;  if displaying codes, show the emitted byte
                        	  1342: ;
00:9EA7 A42E            	  1343:   ldy DCODE
00:9EA9 F003            	  1344:   beq ass_emit3
00:9EAB 203D92          	  1345:   jsr DISHX
                        	  1346: ;
                        	  1347: ;  increment the PCODE (output) address
                        	  1348: ;
                        	  1349: ass_emit3:
00:9EAE E623            	  1350:   inc PCODE
00:9EB0 D002            	  1351:   bne ass_emit1
00:9EB2 E624            	  1352:   inc PCODE+1
                        	  1353: ass_emit1:
00:9EB4 E66F            	  1354:   inc ASS_EMIT_COUNT
00:9EB6 60              	  1355:   rts
                        	  1356: 
                        	  1357: ass_error:
00:9EB7 A56F            	  1358:   lda ASS_EMIT_COUNT
00:9EB9 F003            	  1359:   beq ass_error1
00:9EBB 202892          	  1360:   jsr CROUT
                        	  1361: ass_error1:
00:9EBE 4C6497          	  1362:   jmp ERROR
                        	  1363: 
                        	  1364: ass_fixup_bbr_branch:
00:9EC1 A507            	  1365:   lda REMAIN+1
00:9EC3 D043            	  1366:   bne ass_emit_zero_page_too_high
00:9EC5 A508            	  1367:   lda REMAIN+2
00:9EC7 D03F            	  1368:   bne ass_emit_zero_page_too_high
00:9EC9 A506            	  1369:   lda REMAIN
00:9ECB 20799E          	  1370:   jsr ass_emit  ; output zero page address
                        	  1371: 
                        	  1372: ;
                        	  1373: ;  now fall down and emit the branch
                        	  1374: ;
                        	  1375: 
                        	  1376: ass_fixup_branch:
00:9ECE 18              	  1377:   clc         ; I want to subtract one more, so I CLEAR carry <sigh>
00:9ECF A573            	  1378:   lda ASS_VALUE
00:9ED1 E523            	  1379:   sbc PCODE
00:9ED3 8573            	  1380:   sta ASS_VALUE
                        	  1381: 
00:9ED5 A574            	  1382:   lda ASS_VALUE+1
00:9ED7 E524            	  1383:   sbc PCODE+1
00:9ED9 C9FF            	  1384:   cmp #$FF  ; backwards branch
00:9EDB F00A            	  1385:   beq ass_branch_backwards
00:9EDD C900            	  1386:   cmp #0
00:9EDF D010            	  1387:   bne ass_branch_out_of_range
00:9EE1 A573            	  1388:   lda ASS_VALUE ; must be 0x00 to 0x7F
00:9EE3 300C            	  1389:   bmi ass_branch_out_of_range
00:9EE5 8004            	  1390:   bra ass_branch_ok
                        	  1391: 
                        	  1392: ass_branch_backwards:
00:9EE7 A573            	  1393:   lda ASS_VALUE   ; must be 0x80 to 0xFF
00:9EE9 1006            	  1394:   bpl ass_branch_out_of_range
                        	  1395: 
                        	  1396: ass_branch_ok:
00:9EEB A573            	  1397:   lda ASS_VALUE
00:9EED 20799E          	  1398:   jsr ass_emit  ; output relative address
00:9EF0 60              	  1399:   rts
                        	  1400: 
                        	  1401: ass_branch_out_of_range:
00:9EF1 A576            	  1402:   lda ASS_PASS
00:9EF3 F0F6            	  1403:   beq ass_branch_ok   ; out of range is OK on first pass, we don't know how far the branch is
00:9EF5 A22A            	  1404:   ldx #42
00:9EF7 4CB79E          	  1405:   jmp ass_error  ; branch out of range
                        	  1406: 
                        	  1407: ass_emit_zero_page:
00:9EFA A574            	  1408:   lda ASS_VALUE+1
00:9EFC D00A            	  1409:   bne ass_emit_zero_page_too_high
00:9EFE A575            	  1410:   lda ASS_VALUE+2
00:9F00 D006            	  1411:   bne ass_emit_zero_page_too_high
00:9F02 A573            	  1412:   lda ASS_VALUE
00:9F04 20799E          	  1413:   jsr ass_emit  ; output zero page address
00:9F07 60              	  1414:   rts
                        	  1415: 
                        	  1416: 
                        	  1417: ass_emit_zero_page_too_high:
00:9F08 A22B            	  1418:   ldx #43       ; Need zero page address
00:9F0A 4CB79E          	  1419:   jmp ass_error
                        	  1420: 
                        	  1421: ass_emit_immediate:
00:9F0D A574            	  1422:   lda ASS_VALUE+1
00:9F0F D00A            	  1423:   bne ass_emit_immediate_too_high
00:9F11 A575            	  1424:   lda ASS_VALUE+2
00:9F13 D006            	  1425:   bne ass_emit_immediate_too_high
00:9F15 A573            	  1426:   lda ASS_VALUE
00:9F17 20799E          	  1427:   jsr ass_emit  ; output immediate operand
00:9F1A 60              	  1428:   rts
                        	  1429: 
                        	  1430: ass_emit_immediate_too_high:
00:9F1B A22C            	  1431:   ldx #44
00:9F1D 4CB79E          	  1432:   jmp ass_error
                        	  1433: 
                        	  1434: 
                        	  1435: ass_emit_absolute:
00:9F20 A573            	  1436:   lda ASS_VALUE
00:9F22 20799E          	  1437:   jsr ass_emit  ; output absolute address - low-order byte
00:9F25 A574            	  1438:   lda ASS_VALUE+1
00:9F27 20799E          	  1439:   jsr ass_emit  ; output absolute address - high-order byte
00:9F2A 60              	  1440:   rts
                        	  1441: 
                        	  1442: 
                        	  1443: ;------------------------------------
                        	  1444: ;  Opcode master table
                        	  1445: ;------------------------------------
                        	  1446: 
                        	  1447:    .macro makeOpcodeLookup ; table of opcodes, length of opcode, wanted operand type, special handler
                        	  1448:      dfb   \1
                        	  1449:      dfb   \2
                        	  1450:      word  \3
                        	  1451:      word   \4
                        	  1452:    .endmacro
                        	  1453: 
                        	  1454: ;
                        	  1455: ;  So, for an opcode to match, it has to:
                        	  1456: ;     a) be the right length (usually 3 or 4 characters)
                        	  1457: ;     b) have the right type of operand (eg. ASS_OPERAND_IMMEDIATE)
                        	  1458: ;     c) the opcode must match the name in the list
                        	  1459: ;
                        	  1460: ;   If those conditions are met we output the corresponding opcode,
                        	  1461: ;   return with the operand type in A
                        	  1462: ;
                        	  1463: ;   Otherwise, we return 0 in A
                        	  1464: ;
                        	  1465: 
                        	  1466: OPCODE_LOOKUP_OPCODE_LENGTH = 0
                        	  1467: OPCODE_LOOKUP_OPERAND_TYPE = 1
                        	  1468: OPCODE_LOOKUP_OPCODE_TABLE = 2    ; 2 bytes
                        	  1469: OPCODE_LOOKUP_HANDLER = 4         ; 2 bytes
                        	  1470: OPCODE_LOOKUP_TABLE_SIZE = 6      ; all of the above
                        	  1471: 
                        	  1472: OPCODE_LOOKUP_TABLE = *
                        	  1473: ;
                        	  1474: ;  zero-page opcodes go first as they are preferred if we are accessing a zero-page address
                        	  1475: ;
                        	  1476:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE, OPCODE_ASS_OPERAND_ZERO_PAGE, ass_emit_zero_page ; (11)
00:9F2B 03              	     1M      dfb   3
00:9F2C 0B              	     2M      dfb   ASS_OPERAND_ZERO_PAGE
00:9F2D B8A2            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE
00:9F2F FA9E            	     4M      word   ass_emit_zero_page 
                        	  1477:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE, OPCODE_ASS_OPERAND_ZERO_PAGE_TOKENISED, ass_emit_zero_page ; (11)
00:9F31 01              	     1M      dfb   1
00:9F32 0B              	     2M      dfb   ASS_OPERAND_ZERO_PAGE
00:9F33 19A3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_TOKENISED
00:9F35 FA9E            	     4M      word   ass_emit_zero_page 
                        	  1478:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT, ass_em
00:9F37 03              	     1M      dfb   3
00:9F38 0C              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
00:9F39 1CA3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
00:9F3B FA9E            	     4M      word   ass_emit_zero_page 
                        	  1479:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT_TOKENIS
00:9F3D 01              	     1M      dfb   1
00:9F3E 0C              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
00:9F3F 3DA3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT_TOKENISED
00:9F41 FA9E            	     4M      word   ass_emit_zero_page 
                        	  1480:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X, ass_emit_z
00:9F43 03              	     1M      dfb   3
00:9F44 0D              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
00:9F45 40A3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
00:9F47 FA9E            	     4M      word   ass_emit_zero_page 
                        	  1481:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X_TOKENISED, 
00:9F49 01              	     1M      dfb   1
00:9F4A 0D              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
00:9F4B 89A3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X_TOKENISED
00:9F4D FA9E            	     4M      word   ass_emit_zero_page 
                        	  1482:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y, ass_emit_z
00:9F4F 03              	     1M      dfb   3
00:9F50 0E              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
00:9F51 8CA3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
00:9F53 FA9E            	     4M      word   ass_emit_zero_page 
                        	  1483:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDIRECT, OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT, ass_emit_zero_page ; (
00:9F55 03              	     1M      dfb   3
00:9F56 0F              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDIRECT
00:9F57 95A3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT
00:9F59 FA9E            	     4M      word   ass_emit_zero_page 
                        	  1484:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE_INDIRECT, OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_TOKENISED, ass_emit_zer
00:9F5B 01              	     1M      dfb   1
00:9F5C 0F              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDIRECT
00:9F5D B6A3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_TOKENISED
00:9F5F FA9E            	     4M      word   ass_emit_zero_page 
                        	  1485:     makeOpcodeLookup  3,  ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_
00:9F61 03              	     1M      dfb   3
00:9F62 10              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
00:9F63 B9A3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
00:9F65 FA9E            	     4M      word   ass_emit_zero_page 
                        	  1486:     makeOpcodeLookup  1,  ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_
00:9F67 01              	     1M      dfb   1
00:9F68 10              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
00:9F69 DAA3            	     3M      word  OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y_TOKENISED
00:9F6B FA9E            	     4M      word   ass_emit_zero_page 
                        	  1487: 
                        	  1488: ;
                        	  1489: ;  non zero-page opcodes
                        	  1490: ;
                        	  1491:     makeOpcodeLookup  4,  ASS_OPERAND_ABSOLUTE, OPCODE_4_CHAR_ZERO_PAGE,  ass_emit_zero_page  ; (11)
00:9F6D 04              	     1M      dfb   4
00:9F6E 01              	     2M      dfb   ASS_OPERAND_ABSOLUTE
00:9F6F 34A1            	     3M      word  OPCODE_4_CHAR_ZERO_PAGE
00:9F71 FA9E            	     4M      word   ass_emit_zero_page  
                        	  1492:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE, OPCODE_ASS_OPERAND_ABSOLUTE,  ass_emit_absolute  ; (1)
00:9F73 03              	     1M      dfb   3
00:9F74 01              	     2M      dfb   ASS_OPERAND_ABSOLUTE
00:9F75 85A1            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE
00:9F77 209F            	     4M      word   ass_emit_absolute  
                        	  1493:     makeOpcodeLookup  1,  ASS_OPERAND_ABSOLUTE, OPCODE_ASS_OPERAND_ABSOLUTE_TOKENISED,  ass_emit_absolute  ; (1)
00:9F79 01              	     1M      dfb   1
00:9F7A 01              	     2M      dfb   ASS_OPERAND_ABSOLUTE
00:9F7B EEA1            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_TOKENISED
00:9F7D 209F            	     4M      word   ass_emit_absolute  
                        	  1494: 
                        	  1495:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT, ass_emit
00:9F7F 03              	     1M      dfb   3
00:9F80 02              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
00:9F81 F1A1            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
00:9F83 209F            	     4M      word   ass_emit_absolute 
                        	  1496:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X, ass_emit_abs
00:9F85 03              	     1M      dfb   3
00:9F86 03              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
00:9F87 F6A1            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
00:9F89 209F            	     4M      word   ass_emit_absolute 
                        	  1497:     makeOpcodeLookup  1,  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X_TOKENISED, as
00:9F8B 01              	     1M      dfb   1
00:9F8C 03              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
00:9F8D 3BA2            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X_TOKENISED
00:9F8F 209F            	     4M      word   ass_emit_absolute 
                        	  1498:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y, ass_emit_abs
00:9F91 03              	     1M      dfb   3
00:9F92 04              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
00:9F93 3EA2            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
00:9F95 209F            	     4M      word   ass_emit_absolute 
                        	  1499:     makeOpcodeLookup  1,  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y, OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y_TOKENISED, as
00:9F97 01              	     1M      dfb   1
00:9F98 04              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
00:9F99 63A2            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y_TOKENISED
00:9F9B 209F            	     4M      word   ass_emit_absolute 
                        	  1500:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE_INDIRECT, OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT, ass_emit_absolute ; (5)
00:9F9D 03              	     1M      dfb   3
00:9F9E 05              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDIRECT
00:9F9F 7FA2            	     3M      word  OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT
00:9FA1 209F            	     4M      word   ass_emit_absolute 
                        	  1501:     makeOpcodeLookup  1,  ASS_OPERAND_ABSOLUTE_INDIRECT, OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED, ass_emit_absolute ; (5
00:9FA3 01              	     1M      dfb   1
00:9FA4 05              	     2M      dfb   ASS_OPERAND_ABSOLUTE_INDIRECT
00:9FA5 B5A2            	     3M      word  OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED
00:9FA7 209F            	     4M      word   ass_emit_absolute 
                        	  1502:     makeOpcodeLookup  3,  ASS_OPERAND_ACCUMULATOR_A, OPCODE_ASS_OPERAND_ACCUMULATOR_A, 0 ; (6)
00:9FA9 03              	     1M      dfb   3
00:9FAA 06              	     2M      dfb   ASS_OPERAND_ACCUMULATOR_A
00:9FAB 66A2            	     3M      word  OPCODE_ASS_OPERAND_ACCUMULATOR_A
00:9FAD 0000            	     4M      word   0 
                        	  1503:     makeOpcodeLookup  3,  ASS_OPERAND_IMMEDIATE, OPCODE_ASS_OPERAND_IMMEDIATE, ass_emit_immediate ; (7)
00:9FAF 03              	     1M      dfb   3
00:9FB0 07              	     2M      dfb   ASS_OPERAND_IMMEDIATE
00:9FB1 84A2            	     3M      word  OPCODE_ASS_OPERAND_IMMEDIATE
00:9FB3 0D9F            	     4M      word   ass_emit_immediate 
                        	  1504:     makeOpcodeLookup  1,  ASS_OPERAND_IMMEDIATE, OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED, ass_emit_immediate ; (7)
00:9FB5 01              	     1M      dfb   1
00:9FB6 07              	     2M      dfb   ASS_OPERAND_IMMEDIATE
00:9FB7 B5A2            	     3M      word  OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED
00:9FB9 0D9F            	     4M      word   ass_emit_immediate 
                        	  1505:     makeOpcodeLookup  3,  ASS_OPERAND_IMPLIED,  OPCODE_3_CHAR_IMPLIED,    0  ; (8) and (10)
00:9FBB 03              	     1M      dfb   3
00:9FBC 08              	     2M      dfb   ASS_OPERAND_IMPLIED
00:9FBD B7A0            	     3M      word  OPCODE_3_CHAR_IMPLIED
00:9FBF 0000            	     4M      word   0  
                        	  1506:     makeOpcodeLookup  4,  ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE, OPCODE_4_CHAR_BRANCH,     ass_fixup_bbr_branch  ; (9)
00:9FC1 04              	     1M      dfb   4
00:9FC2 12              	     2M      dfb   ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE
00:9FC3 41A0            	     3M      word  OPCODE_4_CHAR_BRANCH
00:9FC5 C19E            	     4M      word   ass_fixup_bbr_branch  
                        	  1507:     makeOpcodeLookup  3,  ASS_OPERAND_ABSOLUTE, OPCODE_3_CHAR_BRANCH,     ass_fixup_branch  ; (9)
00:9FC7 03              	     1M      dfb   3
00:9FC8 01              	     2M      dfb   ASS_OPERAND_ABSOLUTE
00:9FC9 92A0            	     3M      word  OPCODE_3_CHAR_BRANCH
00:9FCB CE9E            	     4M      word   ass_fixup_branch  
00:9FCD 00              	  1508:     dfb 0
                        	  1509: 
                        	  1510: 
                        	  1511: ;------------------------------------
                        	  1512: ;  directives
                        	  1513: ;------------------------------------
                        	  1514: 
                        	  1515: 
                        	  1516: DIRECTIVES = *
                        	  1517:   makeHandler "ASSERT",   asm_do_assert
00:9FCE 415353455254    	     1M    asciiz   "ASSERT"
00:9FD4 00
00:9FD5 DDA3            	     2M    word  asm_do_assert
                        	  1518:   makeHandler "LIST",     asm_do_list
00:9FD7 4C495354        	     1M    asciiz   "LIST"
00:9FDB 00
00:9FDC F4A3            	     2M    word  asm_do_list
                        	  1519:   makeHandler "NOLIST",   asm_do_nolist
00:9FDE 4E4F4C495354    	     1M    asciiz   "NOLIST"
00:9FE4 00
00:9FE5 03A4            	     2M    word  asm_do_nolist
                        	  1520:   makeHandler "ASC",      asm_do_asc
00:9FE7 415343          	     1M    asciiz   "ASC"
00:9FEA 00
00:9FEB 42A4            	     2M    word  asm_do_asc
                        	  1521:   makeHandler "ASCII",    asm_do_asc
00:9FED 4153434949      	     1M    asciiz   "ASCII"
00:9FF2 00
00:9FF3 42A4            	     2M    word  asm_do_asc
                        	  1522:   makeHandler "ASCIIZ",   asm_do_string
00:9FF5 41534349495A    	     1M    asciiz   "ASCIIZ"
00:9FFB 00
00:9FFC 5DA4            	     2M    word  asm_do_string
                        	  1523:   makeHandler "STRING",   asm_do_string
00:9FFE 535452494E47    	     1M    asciiz   "STRING"
00:A004 00
00:A005 5DA4            	     2M    word  asm_do_string
                        	  1524:   makeHandler "EQU",      asm_do_equ
00:A007 455155          	     1M    asciiz   "EQU"
00:A00A 00
00:A00B 66A4            	     2M    word  asm_do_equ
                        	  1525:   makeHandler "=",        asm_do_equ
00:A00D 3D              	     1M    asciiz   "="
00:A00E 00
00:A00F 66A4            	     2M    word  asm_do_equ
                        	  1526:   makeHandler "ORG",      asm_do_org
00:A011 4F5247          	     1M    asciiz   "ORG"
00:A014 00
00:A015 83A4            	     2M    word  asm_do_org
                        	  1527:   makeHandler "DFB",      asm_do_dfb
00:A017 444642          	     1M    asciiz   "DFB"
00:A01A 00
00:A01B 97A4            	     2M    word  asm_do_dfb
                        	  1528:   makeHandler "DFW",      asm_do_dfw
00:A01D 444657          	     1M    asciiz   "DFW"
00:A020 00
00:A021 D7A4            	     2M    word  asm_do_dfw
                        	  1529:   makeHandler "WORD",     asm_do_dfw
00:A023 574F5244        	     1M    asciiz   "WORD"
00:A027 00
00:A028 D7A4            	     2M    word  asm_do_dfw
                        	  1530:   makeHandler "BLK",      asm_do_blk
00:A02A 424C4B          	     1M    asciiz   "BLK"
00:A02D 00
00:A02E 14A5            	     2M    word  asm_do_blk
                        	  1531:   makeHandler "RESERVE",  asm_do_reserve
00:A030 52455345525645  	     1M    asciiz   "RESERVE"
00:A037 00
00:A038 32A5            	     2M    word  asm_do_reserve
                        	  1532:   makeHandler "SYM",      asm_do_sym
00:A03A 53594D          	     1M    asciiz   "SYM"
00:A03D 00
00:A03E 4DA5            	     2M    word  asm_do_sym
                        	  1533: 
00:A040 00              	  1534:   dfb 0
                        	  1535: 
                        	  1536: ;------------------------------------
                        	  1537: ;  4-character branch opcodes
                        	  1538: ;------------------------------------
                        	  1539: 
                        	  1540: 
                        	  1541: OPCODE_4_CHAR_BRANCH = *
00:A041 42425230        	  1542:   asc "BBR0",$0F
00:A045 0F
00:A046 42425231        	  1543:   asc "BBR1",$1F
00:A04A 1F
00:A04B 42425232        	  1544:   asc "BBR2",$2F
00:A04F 2F
00:A050 42425233        	  1545:   asc "BBR3",$3F
00:A054 3F
00:A055 42425234        	  1546:   asc "BBR4",$4F
00:A059 4F
00:A05A 42425235        	  1547:   asc "BBR5",$5F
00:A05E 5F
00:A05F 42425236        	  1548:   asc "BBR6",$6F
00:A063 6F
00:A064 42425237        	  1549:   asc "BBR7",$7F
00:A068 7F
00:A069 42425330        	  1550:   asc "BBS0",$8F
00:A06D 8F
00:A06E 42425331        	  1551:   asc "BBS1",$9F
00:A072 9F
00:A073 42425332        	  1552:   asc "BBS2",$AF
00:A077 AF
00:A078 42425333        	  1553:   asc "BBS3",$BF
00:A07C BF
00:A07D 42425334        	  1554:   asc "BBS4",$CF
00:A081 CF
00:A082 42425335        	  1555:   asc "BBS5",$DF
00:A086 DF
00:A087 42425336        	  1556:   asc "BBS6",$EF
00:A08B EF
00:A08C 42425337        	  1557:   asc "BBS7",$FF
00:A090 FF
00:A091 00              	  1558:   dfb 0
                        	  1559: 
                        	  1560: ;------------------------------------
                        	  1561: ;  3-character branch opcodes
                        	  1562: ;------------------------------------
                        	  1563: 
                        	  1564: 
                        	  1565: OPCODE_3_CHAR_BRANCH = *
00:A092 424343          	  1566:   asc "BCC",$90
00:A095 90
00:A096 424353          	  1567:   asc "BCS",$B0
00:A099 B0
00:A09A 424551          	  1568:   asc "BEQ",$F0
00:A09D F0
00:A09E 424D49          	  1569:   asc "BMI",$30
00:A0A1 30
00:A0A2 424E45          	  1570:   asc "BNE",$D0
00:A0A5 D0
00:A0A6 42504C          	  1571:   asc "BPL",$10
00:A0A9 10
00:A0AA 425241          	  1572:   asc "BRA",$80
00:A0AD 80
00:A0AE 425643          	  1573:   asc "BVC",$50
00:A0B1 50
00:A0B2 425653          	  1574:   asc "BVS",$70
00:A0B5 70
00:A0B6 00              	  1575:   dfb 0
                        	  1576: 
                        	  1577: 
                        	  1578: ;------------------------------------
                        	  1579: ;  3-character implied opcodes (no operand)
                        	  1580: ;------------------------------------
                        	  1581: 
                        	  1582: OPCODE_3_CHAR_IMPLIED = *
00:A0B7 42524B          	  1583:   asc "BRK",$00
00:A0BA 00
00:A0BB 434C43          	  1584:   asc "CLC",$18
00:A0BE 18
00:A0BF 434C44          	  1585:   asc "CLD",$D8
00:A0C2 D8
00:A0C3 434C49          	  1586:   asc "CLI",$58
00:A0C6 58
00:A0C7 434C56          	  1587:   asc "CLV",$B8
00:A0CA B8
00:A0CB 444558          	  1588:   asc "DEX",$CA
00:A0CE CA
00:A0CF 444559          	  1589:   asc "DEY",$88
00:A0D2 88
00:A0D3 494E58          	  1590:   asc "INX",$E8
00:A0D6 E8
00:A0D7 494E59          	  1591:   asc "INY",$C8
00:A0DA C8
00:A0DB 4E4F50          	  1592:   asc "NOP",$EA
00:A0DE EA
00:A0DF 504841          	  1593:   asc "PHA",$48
00:A0E2 48
00:A0E3 504850          	  1594:   asc "PHP",$08
00:A0E6 08
00:A0E7 504858          	  1595:   asc "PHX",$DA
00:A0EA DA
00:A0EB 504859          	  1596:   asc "PHY",$5A
00:A0EE 5A
00:A0EF 504C41          	  1597:   asc "PLA",$68
00:A0F2 68
00:A0F3 504C50          	  1598:   asc "PLP",$28
00:A0F6 28
00:A0F7 504C58          	  1599:   asc "PLX",$FA
00:A0FA FA
00:A0FB 504C59          	  1600:   asc "PLY",$7A
00:A0FE 7A
00:A0FF 525449          	  1601:   asc "RTI",$40
00:A102 40
00:A103 525453          	  1602:   asc "RTS",$60
00:A106 60
00:A107 534543          	  1603:   asc "SEC",$38
00:A10A 38
00:A10B 534544          	  1604:   asc "SED",$F8
00:A10E F8
00:A10F 534549          	  1605:   asc "SEI",$78
00:A112 78
00:A113 535450          	  1606:   asc "STP",$DB
00:A116 DB
00:A117 544158          	  1607:   asc "TAX",$AA
00:A11A AA
00:A11B 544159          	  1608:   asc "TAY",$A8
00:A11E A8
00:A11F 545358          	  1609:   asc "TSX",$BA
00:A122 BA
00:A123 545841          	  1610:   asc "TXA",$8A
00:A126 8A
00:A127 545853          	  1611:   asc "TXS",$9A
00:A12A 9A
00:A12B 545941          	  1612:   asc "TYA",$98
00:A12E 98
00:A12F 574149          	  1613:   asc "WAI",$CB
00:A132 CB
00:A133 00              	  1614:   dfb 0
                        	  1615: 
                        	  1616: ;------------------------------------
                        	  1617: ;  4-character zero page opcodes (operand must be zero-page address)
                        	  1618: ;------------------------------------
                        	  1619: OPCODE_4_CHAR_ZERO_PAGE = *
00:A134 534D4230        	  1620:   asc "SMB0",$87
00:A138 87
00:A139 534D4231        	  1621:   asc "SMB1",$97
00:A13D 97
00:A13E 534D4232        	  1622:   asc "SMB2",$A7
00:A142 A7
00:A143 534D4233        	  1623:   asc "SMB3",$B7
00:A147 B7
00:A148 534D4234        	  1624:   asc "SMB4",$C7
00:A14C C7
00:A14D 534D4235        	  1625:   asc "SMB5",$D7
00:A151 D7
00:A152 534D4236        	  1626:   asc "SMB6",$E7
00:A156 E7
00:A157 534D4237        	  1627:   asc "SMB7",$F7
00:A15B F7
00:A15C 524D4230        	  1628:   asc "RMB0",$07
00:A160 07
00:A161 524D4231        	  1629:   asc "RMB1",$17
00:A165 17
00:A166 524D4232        	  1630:   asc "RMB2",$27
00:A16A 27
00:A16B 524D4233        	  1631:   asc "RMB3",$37
00:A16F 37
00:A170 524D4234        	  1632:   asc "RMB4",$47
00:A174 47
00:A175 524D4235        	  1633:   asc "RMB5",$57
00:A179 57
00:A17A 524D4236        	  1634:   asc "RMB6",$67
00:A17E 67
00:A17F 524D4237        	  1635:   asc "RMB7",$77
00:A183 77
00:A184 00              	  1636:   dfb 0
                        	  1637: 
                        	  1638: ;------------------------------------
                        	  1639: ;  ASS_OPERAND_ABSOLUTE
                        	  1640: ;------------------------------------
                        	  1641: OPCODE_ASS_OPERAND_ABSOLUTE = *
00:A185 414443          	  1642:   asc "ADC",$6D
00:A188 6D
00:A189 414E44          	  1643:   asc "AND",$2D
00:A18C 2D
00:A18D 41534C          	  1644:   asc "ASL",$0E
00:A190 0E
00:A191 424954          	  1645:   asc "BIT",$2C
00:A194 2C
00:A195 434D50          	  1646:   asc "CMP",$CD
00:A198 CD
00:A199 435058          	  1647:   asc "CPX",$EC
00:A19C EC
00:A19D 435059          	  1648:   asc "CPY",$CC
00:A1A0 CC
00:A1A1 444543          	  1649:   asc "DEC",$CE
00:A1A4 CE
00:A1A5 454F52          	  1650:   asc "EOR",$4D
00:A1A8 4D
00:A1A9 494E43          	  1651:   asc "INC",$EE
00:A1AC EE
00:A1AD 4A4D50          	  1652:   asc "JMP",$4C
00:A1B0 4C
00:A1B1 4A5352          	  1653:   asc "JSR",$20
00:A1B4 20
00:A1B5 4C4441          	  1654:   asc "LDA",$AD
00:A1B8 AD
00:A1B9 4C4458          	  1655:   asc "LDX",$AE
00:A1BC AE
00:A1BD 4C4459          	  1656:   asc "LDY",$AC
00:A1C0 AC
00:A1C1 4C5352          	  1657:   asc "LSR",$4E
00:A1C4 4E
00:A1C5 4F5241          	  1658:   asc "ORA",$0D
00:A1C8 0D
00:A1C9 524F4C          	  1659:   asc "ROL",$2E
00:A1CC 2E
00:A1CD 524F52          	  1660:   asc "ROR",$6E
00:A1D0 6E
00:A1D1 534243          	  1661:   asc "SBC",$ED
00:A1D4 ED
00:A1D5 535441          	  1662:   asc "STA",$8D
00:A1D8 8D
00:A1D9 535458          	  1663:   asc "STX",$8E
00:A1DC 8E
00:A1DD 535459          	  1664:   asc "STY",$8C
00:A1E0 8C
00:A1E1 53545A          	  1665:   asc "STZ",$9C
00:A1E4 9C
00:A1E5 545242          	  1666:   asc "TRB",$1C
00:A1E8 1C
00:A1E9 545342          	  1667:   asc "TSB",$0C
00:A1EC 0C
00:A1ED 00              	  1668:   dfb 0
                        	  1669: 
                        	  1670: ;------------------------------------
                        	  1671: ;  ASS_OPERAND_ABSOLUTE - for tokenised opcodes like AND
                        	  1672: ;------------------------------------
                        	  1673: OPCODE_ASS_OPERAND_ABSOLUTE_TOKENISED = *
00:A1EE 8D              	  1674:   dfb TOKEN_AND,$2D
00:A1EF 2D
00:A1F0 00              	  1675:   dfb 0
                        	  1676: 
                        	  1677: 
                        	  1678: ;------------------------------------
                        	  1679: ;  ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
                        	  1680: ;------------------------------------
                        	  1681: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT = *
00:A1F1 4A4D50          	  1682:   asc "JMP",$7C
00:A1F4 7C
00:A1F5 00              	  1683:   dfb 0
                        	  1684: 
                        	  1685: ;------------------------------------
                        	  1686: ;  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
                        	  1687: ;------------------------------------
                        	  1688: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X = *
00:A1F6 414443          	  1689:   asc "ADC",$7D
00:A1F9 7D
00:A1FA 414E44          	  1690:   asc "AND",$3D
00:A1FD 3D
00:A1FE 41534C          	  1691:   asc "ASL",$1E
00:A201 1E
00:A202 424954          	  1692:   asc "BIT",$3C
00:A205 3C
00:A206 434D50          	  1693:   asc "CMP",$DD
00:A209 DD
00:A20A 444543          	  1694:   asc "DEC",$DE
00:A20D DE
00:A20E 454F52          	  1695:   asc "EOR",$5D
00:A211 5D
00:A212 494E43          	  1696:   asc "INC",$FE
00:A215 FE
00:A216 4C4441          	  1697:   asc "LDA",$BD
00:A219 BD
00:A21A 4C4459          	  1698:   asc "LDY",$BC
00:A21D BC
00:A21E 4C5352          	  1699:   asc "LSR",$5E
00:A221 5E
00:A222 4F5241          	  1700:   asc "ORA",$1D
00:A225 1D
00:A226 524F4C          	  1701:   asc "ROL",$3E
00:A229 3E
00:A22A 524F52          	  1702:   asc "ROR",$7E
00:A22D 7E
00:A22E 534243          	  1703:   asc "SBC",$FD
00:A231 FD
00:A232 535441          	  1704:   asc "STA",$9D
00:A235 9D
00:A236 53545A          	  1705:   asc "STZ",$9E
00:A239 9E
00:A23A 00              	  1706:   dfb 0
                        	  1707: 
                        	  1708: ;------------------------------------
                        	  1709: ;  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X - for tokenised opcodes like AND
                        	  1710: ;------------------------------------
                        	  1711: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X_TOKENISED = *
00:A23B 8D              	  1712:   dfb TOKEN_AND,$3D
00:A23C 3D
00:A23D 00              	  1713:   dfb 0
                        	  1714: 
                        	  1715: ;------------------------------------
                        	  1716: ;  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
                        	  1717: ;------------------------------------
                        	  1718: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y = *
00:A23E 414443          	  1719:   asc "ADC",$79
00:A241 79
00:A242 414E44          	  1720:   asc "AND",$39
00:A245 39
00:A246 434D50          	  1721:   asc "CMP",$D9
00:A249 D9
00:A24A 454F52          	  1722:   asc "EOR",$59
00:A24D 59
00:A24E 4C4441          	  1723:   asc "LDA",$B9
00:A251 B9
00:A252 4C4458          	  1724:   asc "LDX",$BE
00:A255 BE
00:A256 4F5241          	  1725:   asc "ORA",$19
00:A259 19
00:A25A 534243          	  1726:   asc "SBC",$F9
00:A25D F9
00:A25E 535441          	  1727:   asc "STA",$99
00:A261 99
00:A262 00              	  1728:   dfb 0
                        	  1729: 
                        	  1730: ;------------------------------------
                        	  1731: ;  ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y - for tokenised opcodes like AND
                        	  1732: ;------------------------------------
                        	  1733: OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y_TOKENISED = *
00:A263 8D              	  1734:   dfb TOKEN_AND,$39
00:A264 39
00:A265 00              	  1735:   dfb 0
                        	  1736: 
                        	  1737: ;------------------------------------
                        	  1738: ;  ASS_OPERAND_ACCUMULATOR_A
                        	  1739: ;------------------------------------
                        	  1740: OPCODE_ASS_OPERAND_ACCUMULATOR_A = *
00:A266 41534C          	  1741:   asc "ASL",$0A
00:A269 0A
00:A26A 444543          	  1742:   asc "DEC",$3A
00:A26D 3A
00:A26E 494E43          	  1743:   asc "INC",$1A
00:A271 1A
00:A272 4C5352          	  1744:   asc "LSR",$4A
00:A275 4A
00:A276 524F4C          	  1745:   asc "ROL",$2A
00:A279 2A
00:A27A 524F52          	  1746:   asc "ROR",$6A
00:A27D 6A
00:A27E 00              	  1747:   dfb 0
                        	  1748: 
                        	  1749: ;------------------------------------
                        	  1750: ;  ASS_OPERAND_ABSOLUTE_INDIRECT
                        	  1751: ;------------------------------------
                        	  1752: OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT = *
00:A27F 4A4D50          	  1753:   asc "JMP",$6C
00:A282 6C
00:A283 00              	  1754:   dfb 0
                        	  1755: 
                        	  1756: ;------------------------------------
                        	  1757: ;  ASS_OPERAND_IMMEDIATE
                        	  1758: ;------------------------------------
                        	  1759: OPCODE_ASS_OPERAND_IMMEDIATE = *
00:A284 414443          	  1760:   asc "ADC",$69
00:A287 69
00:A288 414E44          	  1761:   asc "AND",$29
00:A28B 29
00:A28C 424954          	  1762:   asc "BIT",$89
00:A28F 89
00:A290 434D50          	  1763:   asc "CMP",$C9
00:A293 C9
00:A294 435058          	  1764:   asc "CPX",$E0
00:A297 E0
00:A298 435059          	  1765:   asc "CPY",$C0
00:A29B C0
00:A29C 454F52          	  1766:   asc "EOR",$49
00:A29F 49
00:A2A0 4C4441          	  1767:   asc "LDA",$A9
00:A2A3 A9
00:A2A4 4C4458          	  1768:   asc "LDX",$A2
00:A2A7 A2
00:A2A8 4C4459          	  1769:   asc "LDY",$A0
00:A2AB A0
00:A2AC 4F5241          	  1770:   asc "ORA",$09
00:A2AF 09
00:A2B0 534243          	  1771:   asc "SBC",$E9
00:A2B3 E9
00:A2B4 00              	  1772:   dfb 0
                        	  1773: 
                        	  1774: ;------------------------------------
                        	  1775: ;  ASS_OPERAND_IMMEDIATE - for tokenised opcodes like AND
                        	  1776: ;------------------------------------
                        	  1777: OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED = *
00:A2B5 8D              	  1778:   dfb TOKEN_AND,$29
00:A2B6 29
00:A2B7 00              	  1779:   dfb 0
                        	  1780: 
                        	  1781: ;------------------------------------
                        	  1782: ;  ASS_OPERAND_ZERO_PAGE
                        	  1783: ;------------------------------------
                        	  1784: OPCODE_ASS_OPERAND_ZERO_PAGE = *
00:A2B8 414443          	  1785:   asc "ADC",$65
00:A2BB 65
00:A2BC 414E44          	  1786:   asc "AND",$25
00:A2BF 25
00:A2C0 41534C          	  1787:   asc "ASL",$06
00:A2C3 06
00:A2C4 424954          	  1788:   asc "BIT",$24
00:A2C7 24
00:A2C8 434D50          	  1789:   asc "CMP",$C5
00:A2CB C5
00:A2CC 435058          	  1790:   asc "CPX",$E4
00:A2CF E4
00:A2D0 435059          	  1791:   asc "CPY",$C4
00:A2D3 C4
00:A2D4 444543          	  1792:   asc "DEC",$C6
00:A2D7 C6
00:A2D8 454F52          	  1793:   asc "EOR",$45
00:A2DB 45
00:A2DC 494E43          	  1794:   asc "INC",$E6
00:A2DF E6
00:A2E0 4C4441          	  1795:   asc "LDA",$A5
00:A2E3 A5
00:A2E4 4C4458          	  1796:   asc "LDX",$A6
00:A2E7 A6
00:A2E8 4C4459          	  1797:   asc "LDY",$A4
00:A2EB A4
00:A2EC 4C5352          	  1798:   asc "LSR",$46
00:A2EF 46
00:A2F0 4F5241          	  1799:   asc "ORA",$05
00:A2F3 05
00:A2F4 524F4C          	  1800:   asc "ROL",$26
00:A2F7 26
00:A2F8 524F52          	  1801:   asc "ROR",$66
00:A2FB 66
00:A2FC 534243          	  1802:   asc "SBC",$E5
00:A2FF E5
00:A300 535441          	  1803:   asc "STA",$85
00:A303 85
00:A304 535458          	  1804:   asc "STX",$86
00:A307 86
00:A308 535459          	  1805:   asc "STY",$84
00:A30B 84
00:A30C 53545A          	  1806:   asc "STZ",$64
00:A30F 64
00:A310 545242          	  1807:   asc "TRB",$14
00:A313 14
00:A314 545342          	  1808:   asc "TSB",$04
00:A317 04
00:A318 00              	  1809:   dfb 0
                        	  1810: 
                        	  1811: ;------------------------------------
                        	  1812: ;  ASS_OPERAND_ZERO_PAGE  - for tokenised opcodes like AND
                        	  1813: ;------------------------------------
                        	  1814: OPCODE_ASS_OPERAND_ZERO_PAGE_TOKENISED = *
00:A319 8D              	  1815:   dfb TOKEN_AND,$25
00:A31A 25
00:A31B 00              	  1816:   dfb 0
                        	  1817: 
                        	  1818: 
                        	  1819: ;------------------------------------
                        	  1820: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
                        	  1821: ;------------------------------------
                        	  1822: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT = *
00:A31C 414443          	  1823:   asc "ADC",$61
00:A31F 61
00:A320 414E44          	  1824:   asc "AND",$21
00:A323 21
00:A324 434D50          	  1825:   asc "CMP",$C1
00:A327 C1
00:A328 454F52          	  1826:   asc "EOR",$41
00:A32B 41
00:A32C 4C4441          	  1827:   asc "LDA",$A1
00:A32F A1
00:A330 4F5241          	  1828:   asc "ORA",$01
00:A333 01
00:A334 534243          	  1829:   asc "SBC",$E1
00:A337 E1
00:A338 535441          	  1830:   asc "STA",$81
00:A33B 81
00:A33C 00              	  1831:   dfb 0
                        	  1832: 
                        	  1833: ;------------------------------------
                        	  1834: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT  - for tokenised opcodes like AND
                        	  1835: ;------------------------------------
                        	  1836: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT_TOKENISED  = *
00:A33D 8D              	  1837:   dfb TOKEN_AND,$21
00:A33E 21
00:A33F 00              	  1838:   dfb 0
                        	  1839: 
                        	  1840: 
                        	  1841: ;------------------------------------
                        	  1842: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
                        	  1843: ;------------------------------------
                        	  1844: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X = *
00:A340 414443          	  1845:   asc "ADC",$75
00:A343 75
00:A344 414E44          	  1846:   asc "AND",$35
00:A347 35
00:A348 41534C          	  1847:   asc "ASL",$16
00:A34B 16
00:A34C 424954          	  1848:   asc "BIT",$34
00:A34F 34
00:A350 434D50          	  1849:   asc "CMP",$D5
00:A353 D5
00:A354 444543          	  1850:   asc "DEC",$D6
00:A357 D6
00:A358 454F52          	  1851:   asc "EOR",$55
00:A35B 55
00:A35C 494E43          	  1852:   asc "INC",$F6
00:A35F F6
00:A360 4C4441          	  1853:   asc "LDA",$B5
00:A363 B5
00:A364 4C4459          	  1854:   asc "LDY",$B4
00:A367 B4
00:A368 4C5352          	  1855:   asc "LSR",$56
00:A36B 56
00:A36C 4F5241          	  1856:   asc "ORA",$15
00:A36F 15
00:A370 524F4C          	  1857:   asc "ROL",$36
00:A373 36
00:A374 524F52          	  1858:   asc "ROR",$76
00:A377 76
00:A378 534243          	  1859:   asc "SBC",$F5
00:A37B F5
00:A37C 535441          	  1860:   asc "STA",$95
00:A37F 95
00:A380 535459          	  1861:   asc "STY",$94
00:A383 94
00:A384 53545A          	  1862:   asc "STZ",$74
00:A387 74
00:A388 00              	  1863:   dfb 0
                        	  1864: 
                        	  1865: ;------------------------------------
                        	  1866: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X  - for tokenised opcodes like AND
                        	  1867: ;------------------------------------
                        	  1868: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X_TOKENISED = *
00:A389 8D              	  1869:   dfb TOKEN_AND,$35
00:A38A 35
00:A38B 00              	  1870:   dfb 0
                        	  1871: 
                        	  1872: ;------------------------------------
                        	  1873: ;  ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
                        	  1874: ;------------------------------------
                        	  1875: OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y = *
00:A38C 4C4458          	  1876:   asc "LDX",$B6
00:A38F B6
00:A390 535458          	  1877:   asc "STX",$96
00:A393 96
00:A394 00              	  1878:   dfb 0
                        	  1879: 
                        	  1880: ;------------------------------------
                        	  1881: ;  ASS_OPERAND_ZERO_PAGE_INDIRECT
                        	  1882: ;------------------------------------
                        	  1883: OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT = *
00:A395 414443          	  1884:   asc "ADC",$72
00:A398 72
00:A399 414E44          	  1885:   asc "AND",$32
00:A39C 32
00:A39D 434D50          	  1886:   asc "CMP",$D2
00:A3A0 D2
00:A3A1 454F52          	  1887:   asc "EOR",$52
00:A3A4 52
00:A3A5 4C4441          	  1888:   asc "LDA",$B2
00:A3A8 B2
00:A3A9 4F5241          	  1889:   asc "ORA",$12
00:A3AC 12
00:A3AD 534243          	  1890:   asc "SBC",$F2
00:A3B0 F2
00:A3B1 535441          	  1891:   asc "STA",$92
00:A3B4 92
00:A3B5 00              	  1892:   dfb 0
                        	  1893: 
                        	  1894: ;------------------------------------
                        	  1895: ;  ASS_OPERAND_ZERO_PAGE_INDIRECT  - for tokenised opcodes like AND
                        	  1896: ;------------------------------------
                        	  1897: OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_TOKENISED = *
00:A3B6 8D              	  1898:   dfb TOKEN_AND,$32
00:A3B7 32
00:A3B8 00              	  1899:   dfb 0
                        	  1900: 
                        	  1901: ;------------------------------------
                        	  1902: ;  ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
                        	  1903: ;------------------------------------
                        	  1904: OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y = *
00:A3B9 414443          	  1905:   asc "ADC",$71
00:A3BC 71
00:A3BD 414E44          	  1906:   asc "AND",$31
00:A3C0 31
00:A3C1 434D50          	  1907:   asc "CMP",$D1
00:A3C4 D1
00:A3C5 454F52          	  1908:   asc "EOR",$51
00:A3C8 51
00:A3C9 4C4441          	  1909:   asc "LDA",$B1
00:A3CC B1
00:A3CD 4F5241          	  1910:   asc "ORA",$11
00:A3D0 11
00:A3D1 534243          	  1911:   asc "SBC",$F1
00:A3D4 F1
00:A3D5 535441          	  1912:   asc "STA",$91
00:A3D8 91
00:A3D9 00              	  1913:   dfb 0
                        	  1914: 
                        	  1915: ;------------------------------------
                        	  1916: ;  ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y - for tokenised opcodes like AND
                        	  1917: ;------------------------------------
                        	  1918: OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y_TOKENISED  = *
00:A3DA 8D              	  1919:   dfb TOKEN_AND,$31
00:A3DB 31
00:A3DC 00              	  1920:   dfb 0
                        	  1921: 
                        	  1922: 
                        	  1923: ; ---------------------------
                        	  1924: ; Compiler directives
                        	  1925: ; ---------------------------
                        	  1926: 
                        	  1927: ;
                        	  1928: ;  ASSERT <expression>  - raises an error if <expression> is zero
                        	  1929: ;
                        	  1930: asm_do_assert:
00:A3DD A56B            	  1931:   lda ASS_OPERAND
00:A3DF C901            	  1932:   cmp #ASS_OPERAND_ABSOLUTE
00:A3E1 D00E            	  1933:   bne asm_do_constant_expectedJ
00:A3E3 A500            	  1934:   lda VALUE
00:A3E5 0501            	  1935:   ora VALUE+1
00:A3E7 0502            	  1936:   ora VALUE+2
00:A3E9 F001            	  1937:   beq asm_do_assert_failed
00:A3EB 60              	  1938:   rts
                        	  1939: 
                        	  1940: asm_do_assert_failed:
00:A3EC A234            	  1941:   ldx #52
00:A3EE 4CB79E          	  1942:   jmp ass_error
                        	  1943: 
00:A3F1 4C89A4          	  1944: asm_do_constant_expectedJ jmp asm_do_constant_expected
                        	  1945: 
                        	  1946: ;
                        	  1947: ; LIST (0= none, 1=source, 2=opcodes, 4=symbols, can OR these together)
                        	  1948: ; LIST  is the same as LIST 3
                        	  1949: 
                        	  1950: asm_do_list = *
                        	  1951: 
                        	  1952: ;   lda #'f'
                        	  1953: ;   jsr ass_debug_point
                        	  1954: 
00:A3F4 A56B            	  1955:   lda ASS_OPERAND
00:A3F6 C908            	  1956:   cmp #ASS_OPERAND_IMPLIED      ; implied (ie. no operand) will resolve to be the same as LIST 3
00:A3F8 F01A            	  1957:   beq asm_do_list_no_operand
00:A3FA C901            	  1958:   cmp #ASS_OPERAND_ABSOLUTE
00:A3FC F01A            	  1959:   beq asm_do_list_ok
00:A3FE A202            	  1960:   ldx #2    ; ERROR: constant expected
00:A400 4CB79E          	  1961:   jmp ass_error
                        	  1962: 
                        	  1963: ;
                        	  1964: ;  NOLIST is the same as LIST 0
                        	  1965: ;
                        	  1966: asm_do_nolist:
00:A403 A56B            	  1967:   lda ASS_OPERAND
00:A405 C908            	  1968:   cmp #ASS_OPERAND_IMPLIED
00:A407 F005            	  1969:   beq asm_do_nolist_ok              ; should have no operand
00:A409 A217            	  1970:   ldx #23   ; ERROR: Illegal factor
00:A40B 4CB79E          	  1971:   jmp ass_error
                        	  1972: asm_do_nolist_ok:
00:A40E A900            	  1973:   lda #0
00:A410 8500            	  1974:   sta VALUE
00:A412 8004            	  1975:   bra asm_do_list_ok
                        	  1976: 
                        	  1977: asm_do_list_no_operand:
00:A414 A903            	  1978:   lda #3
00:A416 8573            	  1979:   sta ASS_VALUE
                        	  1980: asm_do_list_ok:
00:A418 A576            	  1981:   lda ASS_PASS
00:A41A F025            	  1982:   beq asm_do_list_first_pass  ; ignore on first pass
                        	  1983: 
                        	  1984: ;  lda ASS_VALUE
                        	  1985: ;  clc
                        	  1986: ;  adc #'0'
                        	  1987: ;  jsr ass_debug_point
                        	  1988: 
00:A41C A573            	  1989:   lda ASS_VALUE
00:A41E 2901            	  1990:   and #$01
00:A420 F00C            	  1991:   beq asm_do_list_not    ; no listing wanted
00:A422 A904            	  1992:   lda #FLAG_LIST_SOURCE ; already listing?
00:A424 25BE            	  1993:   and system_flags
00:A426 D00A            	  1994:   bne  asm_do_list1   ; yep
00:A428 A904            	  1995:   lda #FLAG_LIST_SOURCE
00:A42A 04BE            	  1996:   tsb system_flags
                        	  1997: ;  jsr token_line        ; list the current line  TODO: don't know, I think it bumps the line number wrongly
00:A42C 8004            	  1998:   bra asm_do_list1
                        	  1999: 
                        	  2000: ;
                        	  2001: ;  turn off list flag
                        	  2002: ;
                        	  2003: asm_do_list_not:
00:A42E A904            	  2004:   lda #FLAG_LIST_SOURCE
00:A430 14BE            	  2005:   trb system_flags
                        	  2006: 
                        	  2007: asm_do_list1:
                        	  2008: 
                        	  2009: 
00:A432 A573            	  2010:   lda ASS_VALUE
00:A434 2902            	  2011:   and #$02
00:A436 852E            	  2012:   sta DCODE
                        	  2013: 
                        	  2014: 
00:A438 A573            	  2015:   lda ASS_VALUE
00:A43A 2904            	  2016:   and #$04
00:A43C 8582            	  2017:   sta show_symbols
                        	  2018: ;
                        	  2019: ;  output a newline, to get past the asterisks
                        	  2020: ;
00:A43E 202892          	  2021:   jsr CROUT
                        	  2022: asm_do_list_first_pass:
00:A441 60              	  2023:   rts
                        	  2024: 
                        	  2025: ;
                        	  2026: ;  ASC "String"
                        	  2027: ;
                        	  2028: asm_do_asc = *
00:A442 A56B            	  2029:   lda ASS_OPERAND
00:A444 C911            	  2030:   cmp #ASS_OPERAND_STRING
00:A446 F005            	  2031:   beq asm_do_asc_ok
00:A448 A208            	  2032:   ldx #8    ; ERROR: incorrect string
00:A44A 4CB79E          	  2033:   jmp ass_error
                        	  2034: ;
                        	  2035: ;  now emit the string
                        	  2036: ;
                        	  2037: asm_do_asc_ok:
00:A44D A000            	  2038:   ldy  #0
                        	  2039: asm_do_asc_loop:
00:A44F B90002          	  2040:   lda  INBUF,Y
00:A452 C8              	  2041:   iny         ; onto next character in the string
00:A453 5A              	  2042:   phy
00:A454 20799E          	  2043:   jsr ass_emit
00:A457 7A              	  2044:   ply
                        	  2045: 
                        	  2046: asm_do_asc_next:
00:A458 C692            	  2047:   dec token_length
00:A45A D0F3            	  2048:   bne asm_do_asc_loop
00:A45C 60              	  2049:   rts
                        	  2050: 
                        	  2051: 
                        	  2052: ;
                        	  2053: ;  ASCIIZ / STRING - output a string with a null terminator
                        	  2054: ;
                        	  2055: 
                        	  2056: asm_do_string:
00:A45D 2042A4          	  2057:   jsr asm_do_asc    ; do the string
00:A460 A900            	  2058:   lda #0            ; and the terminator
00:A462 20799E          	  2059:   jsr ass_emit
00:A465 60              	  2060:   rts
                        	  2061: 
                        	  2062: 
                        	  2063: ;
                        	  2064: ;  EQU
                        	  2065: ;
                        	  2066: ;  The label, which must be present, takes on the value of the expression
                        	  2067: ;
                        	  2068: 
                        	  2069: asm_do_equ:
00:A466 A56B            	  2070:   lda ASS_OPERAND
00:A468 C901            	  2071:   cmp #ASS_OPERAND_ABSOLUTE
00:A46A D01D            	  2072:   bne asm_do_constant_expected
00:A46C A583            	  2073:   lda ass_current_label
00:A46E 0584            	  2074:   ora ass_current_label+1
00:A470 D005            	  2075:   bne asm_do_equ_have_label
00:A472 A230            	  2076:   ldx #48    ; ERROR: label required
00:A474 4CB79E          	  2077:   jmp ass_error
                        	  2078: 
                        	  2079: asm_do_equ_have_label:
00:A477 A004            	  2080:   ldy #SYMDSP
00:A479 A573            	  2081:   lda ASS_VALUE
00:A47B 9183            	  2082:   sta (ass_current_label),y
00:A47D C8              	  2083:   iny
00:A47E A574            	  2084:   lda ASS_VALUE+1
00:A480 9183            	  2085:   sta (ass_current_label),y
00:A482 60              	  2086:   rts
                        	  2087: 
                        	  2088: ;
                        	  2089: ;  ORG
                        	  2090: ;
                        	  2091: ;  The program counter becomes the value of the expression
                        	  2092: ;
                        	  2093: 
                        	  2094: asm_do_org:
00:A483 A56B            	  2095:   lda ASS_OPERAND
00:A485 C901            	  2096:   cmp #ASS_OPERAND_ABSOLUTE
00:A487 F005            	  2097:   beq asm_do_org_ok
                        	  2098: asm_do_constant_expected:
00:A489 A202            	  2099:   ldx #2    ; ERROR: constant expected
00:A48B 4CB79E          	  2100:   jmp ass_error
                        	  2101: 
                        	  2102: asm_do_org_ok:
00:A48E A573            	  2103:   lda ASS_VALUE
00:A490 8523            	  2104:   sta PCODE
00:A492 A574            	  2105:   lda ASS_VALUE+1
00:A494 8524            	  2106:   sta PCODE+1
00:A496 60              	  2107:   rts
                        	  2108: 
                        	  2109: ;
                        	  2110: ;  DFB - define one byte (value being the expression)
                        	  2111: ;
                        	  2112: 
                        	  2113: asm_do_dfb:
00:A497 A56B            	  2114:   lda ASS_OPERAND
00:A499 C912            	  2115:   cmp #ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE  ; multiple values?
00:A49B F008            	  2116:   beq asm_do_dfb_multiple
00:A49D C901            	  2117:   cmp #ASS_OPERAND_ABSOLUTE
00:A49F D0E8            	  2118:   bne asm_do_constant_expected
00:A4A1 20C9A4          	  2119:   jsr asm_emit_one_byte
00:A4A4 60              	  2120:   rts
                        	  2121: 
                        	  2122: ;
                        	  2123: ;  so if we got here we thought we had two values (like a BBR0 $12,foo)
                        	  2124: ;  - the first is in REMAIN and the other in VALUE
                        	  2125: ;
                        	  2126: ;  let's emit REMAIN, then VALUE, then look for other values
                        	  2127: ;
                        	  2128: asm_do_dfb_multiple:
00:A4A5 A507            	  2129:   lda REMAIN+1
00:A4A7 D01B            	  2130:   bne asm_do_dfb_too_big
00:A4A9 A508            	  2131:   lda REMAIN+2
00:A4AB D017            	  2132:   bne asm_do_dfb_too_big
00:A4AD A506            	  2133:   lda REMAIN
00:A4AF 20799E          	  2134:   jsr ass_emit  ; emit REMAIN
                        	  2135: asm_do_dfb_multiple_loop:
00:A4B2 20C9A4          	  2136:   jsr asm_emit_one_byte  ; emit VALUE
00:A4B5 A593            	  2137:   lda token_type
00:A4B7 C92C            	  2138:   cmp #','      ; another?
00:A4B9 D008            	  2139:   bne asm_do_dfb_multiple_done
00:A4BB 20F5C8          	  2140:   jsr get_token
00:A4BE 20FC9C          	  2141:   jsr ass_get_value  ; should have some sort of address now in VALUE
00:A4C1 80EF            	  2142:   bra asm_do_dfb_multiple_loop
                        	  2143: 
                        	  2144: asm_do_dfb_multiple_done:
00:A4C3 60              	  2145:   rts
                        	  2146: 
                        	  2147: 
                        	  2148: asm_do_dfb_too_big:
00:A4C4 A22C            	  2149:   ldx #44
00:A4C6 4CB79E          	  2150:   jmp ass_error
                        	  2151: 
                        	  2152: asm_emit_one_byte:
00:A4C9 A574            	  2153:   lda ASS_VALUE+1
00:A4CB D0F7            	  2154:   bne asm_do_dfb_too_big
00:A4CD A575            	  2155:   lda ASS_VALUE+2
00:A4CF D0F3            	  2156:   bne asm_do_dfb_too_big
00:A4D1 A573            	  2157:   lda ASS_VALUE
00:A4D3 20799E          	  2158:   jsr ass_emit
00:A4D6 60              	  2159:   rts
                        	  2160: 
                        	  2161: 
                        	  2162: ;
                        	  2163: ;  DFW - define two bytes (value being the expression)
                        	  2164: ;
                        	  2165: 
                        	  2166: asm_do_dfw:
00:A4D7 A56B            	  2167:   lda ASS_OPERAND
00:A4D9 C912            	  2168:   cmp #ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE  ; multiple values?
00:A4DB F008            	  2169:   beq asm_do_dfw_multiple
00:A4DD C901            	  2170:   cmp #ASS_OPERAND_ABSOLUTE
00:A4DF D0A8            	  2171:   bne asm_do_constant_expected
00:A4E1 2005A5          	  2172:   jsr asm_emit_two_bytes
00:A4E4 60              	  2173:   rts
                        	  2174: 
                        	  2175: ;
                        	  2176: ;  so if we got here we thought we had two values (like a BBR0 $12,foo)
                        	  2177: ;  - the first is in REMAIN and the other in VALUE
                        	  2178: ;
                        	  2179: ;  let's emit REMAIN, then VALUE, then look for other values
                        	  2180: ;
                        	  2181: asm_do_dfw_multiple:
00:A4E5 A508            	  2182:   lda REMAIN+2
00:A4E7 D0DB            	  2183:   bne asm_do_dfb_too_big
00:A4E9 A506            	  2184:   lda REMAIN
00:A4EB 20799E          	  2185:   jsr ass_emit  ; emit REMAIN
00:A4EE A507            	  2186:   lda REMAIN+1
00:A4F0 20799E          	  2187:   jsr ass_emit  ; emit REMAIN+1
                        	  2188: asm_do_dfw_multiple_loop:
00:A4F3 2005A5          	  2189:   jsr asm_emit_two_bytes  ; emit VALUE
00:A4F6 A593            	  2190:   lda token_type
00:A4F8 C92C            	  2191:   cmp #','      ; another?
00:A4FA D008            	  2192:   bne asm_do_dfw_multiple_done
00:A4FC 20F5C8          	  2193:   jsr get_token
00:A4FF 20FC9C          	  2194:   jsr ass_get_value  ; should have some sort of address now in VALUE
00:A502 80EF            	  2195:   bra asm_do_dfw_multiple_loop
                        	  2196: 
                        	  2197: asm_do_dfw_multiple_done:
00:A504 60              	  2198:   rts
                        	  2199: 
                        	  2200: 
                        	  2201: asm_emit_two_bytes:
00:A505 A575            	  2202:   lda ASS_VALUE+2
00:A507 D0BB            	  2203:   bne asm_do_dfb_too_big
00:A509 A573            	  2204:   lda ASS_VALUE
00:A50B 20799E          	  2205:   jsr ass_emit
00:A50E A574            	  2206:   lda ASS_VALUE+1
00:A510 20799E          	  2207:   jsr ass_emit
00:A513 60              	  2208:   rts
                        	  2209: 
                        	  2210: 
                        	  2211: 
                        	  2212: ;
                        	  2213: ;  BLK - zero fill <expression> bytes (eg. BLK 5 output 5 zeroes)
                        	  2214: ;
                        	  2215: 
                        	  2216: asm_do_blk:
00:A514 A56B            	  2217:   lda ASS_OPERAND
00:A516 C901            	  2218:   cmp #ASS_OPERAND_ABSOLUTE
00:A518 D030            	  2219:   bne asm_do_constant_expectedJ2
00:A51A A575            	  2220:   lda ASS_VALUE+2
00:A51C D0A6            	  2221:   bne asm_do_dfb_too_big
                        	  2222: ;
                        	  2223: ; handle (obscure) case of them defining zero bytes
                        	  2224: ;
00:A51E A573            	  2225:   lda ASS_VALUE
00:A520 0574            	  2226:   ora ASS_VALUE+1
00:A522 F00D            	  2227:   beq asm_do_blk_done
                        	  2228: asm_do_blk_loop:
                        	  2229: ;
                        	  2230: ;  emit one zero
                        	  2231: ;
00:A524 A900            	  2232:   lda #0
00:A526 20799E          	  2233:   jsr ass_emit
00:A529 C673            	  2234:   dec ASS_VALUE
00:A52B D0F7            	  2235:   bne asm_do_blk_loop
00:A52D C674            	  2236:   dec ASS_VALUE+1
00:A52F 10F3            	  2237:   bpl asm_do_blk_loop
                        	  2238: asm_do_blk_done:
00:A531 60              	  2239:   rts
                        	  2240: 
                        	  2241: ;
                        	  2242: ;  RESERVE - reserve <expression> bytes without writing to them
                        	  2243: ;   useful for leaving a gap (eg. for zero-page variables)
                        	  2244: ;
                        	  2245: 
                        	  2246: asm_do_reserve:
00:A532 A56B            	  2247:   lda ASS_OPERAND
00:A534 C901            	  2248:   cmp #ASS_OPERAND_ABSOLUTE
00:A536 D012            	  2249:   bne asm_do_constant_expectedJ2
00:A538 A575            	  2250:   lda ASS_VALUE+2
00:A53A D088            	  2251:   bne asm_do_dfb_too_big
00:A53C 18              	  2252:   clc
00:A53D A523            	  2253:   lda PCODE
00:A53F 6573            	  2254:   adc ASS_VALUE
00:A541 8523            	  2255:   sta PCODE
00:A543 A524            	  2256:   lda PCODE+1
00:A545 6574            	  2257:   adc ASS_VALUE+1
00:A547 8524            	  2258:   sta PCODE+1
00:A549 60              	  2259:   rts
                        	  2260: 
00:A54A 4C89A4          	  2261: asm_do_constant_expectedJ2 jmp asm_do_constant_expected
                        	  2262: 
                        	  2263: ;
                        	  2264: ;  SYM <address> symbol table relocation
                        	  2265: ;
                        	  2266: asm_do_sym:
00:A54D A56B            	  2267:   lda ASS_OPERAND
00:A54F C901            	  2268:   cmp #ASS_OPERAND_ABSOLUTE
00:A551 D0F7            	  2269:   bne asm_do_constant_expectedJ2
                        	  2270: ;
                        	  2271: ;  only relocate symbol table on the first pass
                        	  2272: ;
00:A553 A576            	  2273:   lda ASS_PASS
00:A555 D00F            	  2274:   bne asm_do_sym_done
                        	  2275: 
00:A557 A573            	  2276:   lda  ASS_VALUE
00:A559 8531            	  2277:   sta  ENDSYM
00:A55B 852F            	  2278:   sta  STARTSYM
00:A55D A574            	  2279:   lda  ASS_VALUE+1
00:A55F 8532            	  2280:   sta  ENDSYM+1        ; store symbol table address
00:A561 8530            	  2281:   sta  STARTSYM+1
                        	  2282: ;
                        	  2283: ;  put our library functions back into the symbol table
                        	  2284: ;
00:A563 20FBA9          	  2285:   jsr  add_assembler_library_functions  ; add our inbuilt functions to the symbol table
                        	  2286: 
                        	  2287: asm_do_sym_done:
00:A566 60              	  2288:   rts
                        	  2289: ;
                        	  2290: 
                        	  2291: 
00:A567 41646472204E616D	  2292: info_message asciiz "Addr Name\n"
00:A56F 650A
00:A571 00
                        	  2293: 
                        	  2294: list_symbols  = *
00:A572 A967            	  2295:          lda #<info_message
00:A574 A2A5            	  2296:          ldx #>info_message
00:A576 202682          	  2297:          jsr print
                        	  2298: 
00:A579 A532            	  2299:          lda  ENDSYM+1    ; get the end of the symbol table
00:A57B 8541            	  2300:          sta  SYMITM+1    ; make it the current symbol
00:A57D A531            	  2301:          lda  ENDSYM
00:A57F 800B            	  2302:          bra  list_symbols_check
                        	  2303: 
                        	  2304: list_symbols_next =  *
00:A581 A000            	  2305:          ldy  #SYMPRV
00:A583 B140            	  2306:          lda  (SYMITM),Y
00:A585 AA              	  2307:          tax
00:A586 C8              	  2308:          iny
00:A587 B140            	  2309:          lda  (SYMITM),Y
00:A589 8541            	  2310:          sta  SYMITM+1   ; previous link
00:A58B 8A              	  2311:          txa
                        	  2312: ;
                        	  2313: ;  go to the previous symbol table item
                        	  2314: ;
                        	  2315: list_symbols_check     =  *
00:A58C 8540            	  2316:          sta  SYMITM
00:A58E C52F            	  2317:          cmp  STARTSYM
00:A590 D009            	  2318:          bne  list_symbols_line
00:A592 A541            	  2319:          lda  SYMITM+1
00:A594 C530            	  2320:          cmp  STARTSYM+1
00:A596 D003            	  2321:          bne  list_symbols_line       ; more to go
00:A598 4CC6A5          	  2322:          jmp  list_symbols_done       ; finished if symitm and symitm+1 are both zero
                        	  2323: 
                        	  2324: list_symbols_line = *
00:A59B A004            	  2325:          ldy  #SYMDSP
00:A59D C8              	  2326:          iny
00:A59E B140            	  2327:          lda  (SYMITM),Y  ; displacement
00:A5A0 209D92          	  2328:          jsr  PRBYTE
00:A5A3 88              	  2329:          dey
00:A5A4 B140            	  2330:          lda  (SYMITM),Y  ; displacement
00:A5A6 209D92          	  2331:          jsr  PRBYTE
00:A5A9 A920            	  2332:          lda  #' '
00:A5AB 208592          	  2333:          jsr  PRCHAR
00:A5AE A009            	  2334:          ldy  #SYMLEN
00:A5B0 B140            	  2335:          lda  (SYMITM),Y  ; length
00:A5B2 AA              	  2336:          tax
00:A5B3 A00A            	  2337:          ldy  #SYMNAM
                        	  2338: list_symbols_name = *
00:A5B5 B140            	  2339:          lda  (SYMITM),Y  ; name
00:A5B7 5A              	  2340:          phy
00:A5B8 208592          	  2341:          jsr  PRCHAR
00:A5BB 7A              	  2342:          ply
00:A5BC C8              	  2343:          iny
00:A5BD CA              	  2344:          dex
00:A5BE D0F5            	  2345:          bne list_symbols_name
00:A5C0 202892          	  2346:          jsr CROUT
00:A5C3 4C81A5          	  2347:          jmp list_symbols_next
                        	  2348: 
                        	  2349: list_symbols_done = *
00:A5C6 60              	  2350:          rts
                        	  2351: 
                        	  2352: assembler_library_functions_table:
                        	  2353: ;
                        	  2354: ;  put them in reverse alphabetic order so they come out in alphabetic
                        	  2355: ;  order if you request a symbols list
                        	  2356: ;
                        	  2357:   makeAsmLibraryFunction "write_to_serial",      write_to_serial
00:A5C7 77726974655F746F	     1M      asciiz   "write_to_serial"
00:A5CF 5F73657269616C
00:A5D6 00
00:A5D7 63C8            	     2M      word     write_to_serial
                        	  2358:   makeAsmLibraryFunction "write_to_lcd",         write_to_lcd
00:A5D9 77726974655F746F	     1M      asciiz   "write_to_lcd"
00:A5E1 5F6C6364
00:A5E5 00
00:A5E6 6EC8            	     2M      word     write_to_lcd
                        	  2359:   makeAsmLibraryFunction "write_function",       write_function
00:A5E8 77726974655F6675	     1M      asciiz   "write_function"
00:A5F0 6E6374696F6E
00:A5F6 00
00:A5F7 1700            	     2M      word     write_function
                        	  2360:   makeAsmLibraryFunction "write_char",           write_char
00:A5F9 77726974655F6368	     1M      asciiz   "write_char"
00:A601 6172
00:A603 00
00:A604 BFC8            	     2M      word     write_char
                        	  2361:   makeAsmLibraryFunction "value",                VALUE
00:A606 76616C7565      	     1M      asciiz   "value"
00:A60B 00
00:A60C 0000            	     2M      word     VALUE
                        	  2362:   makeAsmLibraryFunction "value2",               VALUE2
00:A60E 76616C756532    	     1M      asciiz   "value2"
00:A614 00
00:A615 0300            	     2M      word     VALUE2
                        	  2363:   makeAsmLibraryFunction "typing_latency",       typing_latency
00:A617 747970696E675F6C	     1M      asciiz   "typing_latency"
00:A61F 6174656E6379
00:A625 00
00:A626 0D00            	     2M      word     typing_latency
                        	  2364:   makeAsmLibraryFunction "tknjmp",               TKNJMP
00:A628 746B6E6A6D70    	     1M      asciiz   "tknjmp"
00:A62E 00
00:A62F 928F            	     2M      word     TKNJMP
                        	  2365:   makeAsmLibraryFunction "start",                START
00:A631 7374617274      	     1M      asciiz   "start"
00:A636 00
00:A637 34CF            	     2M      word     START
                        	  2366:   makeAsmLibraryFunction "srce",                 SRCE
00:A639 73726365        	     1M      asciiz   "srce"
00:A63D 00
00:A63E 0000            	     2M      word     SRCE
                        	  2367:   makeAsmLibraryFunction "serial_print_message", serial_print_message
00:A640 73657269616C5F70	     1M      asciiz   "serial_print_message"
00:A648 72696E745F6D6573
00:A650 73616765
00:A654 00
00:A655 E4C8            	     2M      word     serial_print_message
                        	  2368:   makeAsmLibraryFunction "serial_available",     serial_available
00:A657 73657269616C5F61	     1M      asciiz   "serial_available"
00:A65F 7661696C61626C65
00:A667 00
00:A668 8AC8            	     2M      word     serial_available
                        	  2369:   makeAsmLibraryFunction "restart",              RESTART
00:A66A 72657374617274  	     1M      asciiz   "restart"
00:A671 00
00:A672 58CF            	     2M      word     RESTART
                        	  2370:   makeAsmLibraryFunction "remain",               REMAIN
00:A674 72656D61696E    	     1M      asciiz   "remain"
00:A67A 00
00:A67B 0600            	     2M      word     REMAIN
                        	  2371:   makeAsmLibraryFunction "random",               random
00:A67D 72616E646F6D    	     1M      asciiz   "random"
00:A683 00
00:A684 0900            	     2M      word     random
                        	  2372:   makeAsmLibraryFunction "putsp",                PUTSP
00:A686 7075747370      	     1M      asciiz   "putsp"
00:A68B 00
00:A68C B392            	     2M      word     PUTSP
                        	  2373:   makeAsmLibraryFunction "print",                print
00:A68E 7072696E74      	     1M      asciiz   "print"
00:A693 00
00:A694 2682            	     2M      word     print
                        	  2374:   makeAsmLibraryFunction "prchar",               PRCHAR
00:A696 707263686172    	     1M      asciiz   "prchar"
00:A69C 00
00:A69D 8592            	     2M      word     PRCHAR
                        	  2375:   makeAsmLibraryFunction "prbyte",               PRBYTE
00:A69F 707262797465    	     1M      asciiz   "prbyte"
00:A6A5 00
00:A6A6 9D92            	     2M      word     PRBYTE
                        	  2376:   makeAsmLibraryFunction "pinmode",              pinmode
00:A6A8 70696E6D6F6465  	     1M      asciiz   "pinmode"
00:A6AF 00
00:A6B0 E8C7            	     2M      word     pinmode
                        	  2377:   makeAsmLibraryFunction "lcd_wait",             lcd_wait
00:A6B2 6C63645F77616974	     1M      asciiz   "lcd_wait"
00:A6BA 00
00:A6BB C9B7            	     2M      word     lcd_wait
                        	  2378:   makeAsmLibraryFunction "lcd_second_line",      lcd_second_line
00:A6BD 6C63645F7365636F	     1M      asciiz   "lcd_second_line"
00:A6C5 6E645F6C696E65
00:A6CC 00
00:A6CD 59B8            	     2M      word     lcd_second_line
                        	  2379:   makeAsmLibraryFunction "lcd_print_message",    lcd_print_message
00:A6CF 6C63645F7072696E	     1M      asciiz   "lcd_print_message"
00:A6D7 745F6D6573736167
00:A6DF 65
00:A6E0 00
00:A6E1 69B8            	     2M      word     lcd_print_message
                        	  2380:   makeAsmLibraryFunction "lcd_print_char",       lcd_print_char
00:A6E3 6C63645F7072696E	     1M      asciiz   "lcd_print_char"
00:A6EB 745F63686172
00:A6F1 00
00:A6F2 1FB8            	     2M      word     lcd_print_char
                        	  2381:   makeAsmLibraryFunction "lcd_instruction",      lcd_instruction
00:A6F4 6C63645F696E7374	     1M      asciiz   "lcd_instruction"
00:A6FC 72756374696F6E
00:A703 00
00:A704 FDB7            	     2M      word     lcd_instruction
                        	  2382:   makeAsmLibraryFunction "lcd_home",             lcd_home
00:A706 6C63645F686F6D65	     1M      asciiz   "lcd_home"
00:A70E 00
00:A70F 61B8            	     2M      word     lcd_home
                        	  2383:   makeAsmLibraryFunction "lcd_get_address",      lcd_get_address
00:A711 6C63645F6765745F	     1M      asciiz   "lcd_get_address"
00:A719 61646472657373
00:A720 00
00:A721 DDB7            	     2M      word     lcd_get_address
                        	  2384:   makeAsmLibraryFunction "lcd_clear_display",    lcd_clear_display
00:A723 6C63645F636C6561	     1M      asciiz   "lcd_clear_display"
00:A72B 725F646973706C61
00:A733 79
00:A734 00
00:A735 51B8            	     2M      word     lcd_clear_display
                        	  2385:   makeAsmLibraryFunction "isxdigit",             isxdigit
00:A737 6973786469676974	     1M      asciiz   "isxdigit"
00:A73F 00
00:A740 3E81            	     2M      word     isxdigit
                        	  2386:   makeAsmLibraryFunction "isupper",              isupper
00:A742 69737570706572  	     1M      asciiz   "isupper"
00:A749 00
00:A74A 0E81            	     2M      word     isupper
                        	  2387:   makeAsmLibraryFunction "isspace",              isspace
00:A74C 69737370616365  	     1M      asciiz   "isspace"
00:A753 00
00:A754 4A81            	     2M      word     isspace
                        	  2388:   makeAsmLibraryFunction "islower",              islower
00:A756 69736C6F776572  	     1M      asciiz   "islower"
00:A75D 00
00:A75E 1A81            	     2M      word     islower
                        	  2389:   makeAsmLibraryFunction "isdigit",              isdigit
00:A760 69736469676974  	     1M      asciiz   "isdigit"
00:A767 00
00:A768 3281            	     2M      word     isdigit
                        	  2390:   makeAsmLibraryFunction "iscntrl",              iscntrl
00:A76A 6973636E74726C  	     1M      asciiz   "iscntrl"
00:A771 00
00:A772 5681            	     2M      word     iscntrl
                        	  2391:   makeAsmLibraryFunction "isalpha",              isalpha
00:A774 6973616C706861  	     1M      asciiz   "isalpha"
00:A77B 00
00:A77C 2681            	     2M      word     isalpha
                        	  2392:   makeAsmLibraryFunction "isalnum",              isalnum
00:A77E 6973616C6E756D  	     1M      asciiz   "isalnum"
00:A785 00
00:A786 6281            	     2M      word     isalnum
                        	  2393:   makeAsmLibraryFunction "hardware_init",        hardware_init
00:A788 6861726477617265	     1M      asciiz   "hardware_init"
00:A790 5F696E6974
00:A795 00
00:A796 90C8            	     2M      word     hardware_init
                        	  2394:   makeAsmLibraryFunction "getin",                GETIN
00:A798 676574696E      	     1M      asciiz   "getin"
00:A79D 00
00:A79E 79C8            	     2M      word     GETIN
                        	  2395:   makeAsmLibraryFunction "gen_random",           gen_random
00:A7A0 67656E5F72616E64	     1M      asciiz   "gen_random"
00:A7A8 6F6D
00:A7AA 00
00:A7AB DA8F            	     2M      word     gen_random
                        	  2396:   makeAsmLibraryFunction "exp_unary_minus",      exp_unary_minus
00:A7AD 6578705F756E6172	     1M      asciiz   "exp_unary_minus"
00:A7B5 795F6D696E7573
00:A7BC 00
00:A7BD 8DAB            	     2M      word     exp_unary_minus
                        	  2397:   makeAsmLibraryFunction "exp_true",             exp_true
00:A7BF 6578705F74727565	     1M      asciiz   "exp_true"
00:A7C7 00
00:A7C8 70AA            	     2M      word     exp_true
                        	  2398:   makeAsmLibraryFunction "exp_subtract",         exp_subtract
00:A7CA 6578705F73756274	     1M      asciiz   "exp_subtract"
00:A7D2 72616374
00:A7D6 00
00:A7D7 5AAA            	     2M      word     exp_subtract
                        	  2399:   makeAsmLibraryFunction "exp_shift_right",      exp_shift_right
00:A7D9 6578705F73686966	     1M      asciiz   "exp_shift_right"
00:A7E1 745F7269676874
00:A7E8 00
00:A7E9 53AB            	     2M      word     exp_shift_right
                        	  2400:   makeAsmLibraryFunction "exp_shift_left",       exp_shift_left
00:A7EB 6578705F73686966	     1M      asciiz   "exp_shift_left"
00:A7F3 745F6C656674
00:A7F9 00
00:A7FA 3AAB            	     2M      word     exp_shift_left
                        	  2401:   makeAsmLibraryFunction "exp_not",              exp_not
00:A7FC 6578705F6E6F74  	     1M      asciiz   "exp_not"
00:A803 00
00:A804 7FAB            	     2M      word     exp_not
                        	  2402:   makeAsmLibraryFunction "exp_neq",              exp_neq
00:A806 6578705F6E6571  	     1M      asciiz   "exp_neq"
00:A80D 00
00:A80E 94AA            	     2M      word     exp_neq
                        	  2403:   makeAsmLibraryFunction "exp_negate",           exp_negate
00:A810 6578705F6E656761	     1M      asciiz   "exp_negate"
00:A818 7465
00:A81A 00
00:A81B 6CAB            	     2M      word     exp_negate
                        	  2404:   makeAsmLibraryFunction "exp_multiply",         exp_multiply
00:A81D 6578705F6D756C74	     1M      asciiz   "exp_multiply"
00:A825 69706C79
00:A829 00
00:A82A 14AC            	     2M      word     exp_multiply
                        	  2405:   makeAsmLibraryFunction "exp_modulo",           exp_modulo
00:A82C 6578705F6D6F6475	     1M      asciiz   "exp_modulo"
00:A834 6C6F
00:A836 00
00:A837 ADAC            	     2M      word     exp_modulo
                        	  2406:   makeAsmLibraryFunction "exp_low_byte",         exp_low_byte
00:A839 6578705F6C6F775F	     1M      asciiz   "exp_low_byte"
00:A841 62797465
00:A845 00
00:A846 A1AB            	     2M      word     exp_low_byte
                        	  2407:   makeAsmLibraryFunction "exp_logical_or",       exp_logical_or
00:A848 6578705F6C6F6769	     1M      asciiz   "exp_logical_or"
00:A850 63616C5F6F72
00:A856 00
00:A857 19AB            	     2M      word     exp_logical_or
                        	  2408:   makeAsmLibraryFunction "exp_logical_and",      exp_logical_and
00:A859 6578705F6C6F6769	     1M      asciiz   "exp_logical_and"
00:A861 63616C5F616E64
00:A868 00
00:A869 28AB            	     2M      word     exp_logical_and
                        	  2409:   makeAsmLibraryFunction "exp_less_than",        exp_less_than
00:A86B 6578705F6C657373	     1M      asciiz   "exp_less_than"
00:A873 5F7468616E
00:A878 00
00:A879 A8AA            	     2M      word     exp_less_than
                        	  2410:   makeAsmLibraryFunction "exp_leq",              exp_leq
00:A87B 6578705F6C6571  	     1M      asciiz   "exp_leq"
00:A882 00
00:A883 BEAA            	     2M      word     exp_leq
                        	  2411:   makeAsmLibraryFunction "exp_high_byte",        exp_high_byte
00:A885 6578705F68696768	     1M      asciiz   "exp_high_byte"
00:A88D 5F62797465
00:A892 00
00:A893 A6AB            	     2M      word     exp_high_byte
                        	  2412:   makeAsmLibraryFunction "exp_greater_than",     exp_greater_than
00:A895 6578705F67726561	     1M      asciiz   "exp_greater_than"
00:A89D 7465725F7468616E
00:A8A5 00
00:A8A6 AFAA            	     2M      word     exp_greater_than
                        	  2413:   makeAsmLibraryFunction "exp_geq",              exp_geq
00:A8A8 6578705F676571  	     1M      asciiz   "exp_geq"
00:A8AF 00
00:A8B0 CDAA            	     2M      word     exp_geq
                        	  2414:   makeAsmLibraryFunction "exp_false",            exp_false
00:A8B2 6578705F66616C73	     1M      asciiz   "exp_false"
00:A8BA 65
00:A8BB 00
00:A8BC 79AA            	     2M      word     exp_false
                        	  2415:   makeAsmLibraryFunction "exp_eql",              exp_eql
00:A8BE 6578705F65716C  	     1M      asciiz   "exp_eql"
00:A8C5 00
00:A8C6 80AA            	     2M      word     exp_eql
                        	  2416:   makeAsmLibraryFunction "exp_divide",           exp_divide
00:A8C8 6578705F64697669	     1M      asciiz   "exp_divide"
00:A8D0 6465
00:A8D2 00
00:A8D3 4DAC            	     2M      word     exp_divide
                        	  2417:   makeAsmLibraryFunction "exp_bitwise_xor",      exp_bitwise_xor
00:A8D5 6578705F62697477	     1M      asciiz   "exp_bitwise_xor"
00:A8DD 6973655F786F72
00:A8E4 00
00:A8E5 FEAA            	     2M      word     exp_bitwise_xor
                        	  2418:   makeAsmLibraryFunction "exp_bitwise_or",       exp_bitwise_or
00:A8E7 6578705F62697477	     1M      asciiz   "exp_bitwise_or"
00:A8EF 6973655F6F72
00:A8F5 00
00:A8F6 D4AA            	     2M      word     exp_bitwise_or
                        	  2419:   makeAsmLibraryFunction "exp_bitwise_and",      exp_bitwise_and
00:A8F8 6578705F62697477	     1M      asciiz   "exp_bitwise_and"
00:A900 6973655F616E64
00:A907 00
00:A908 E9AA            	     2M      word     exp_bitwise_and
                        	  2420:   makeAsmLibraryFunction "exp_add",              exp_add
00:A90A 6578705F616464  	     1M      asciiz   "exp_add"
00:A911 00
00:A912 46AA            	     2M      word     exp_add
                        	  2421:   makeAsmLibraryFunction "exp_abs_val",          exp_abs_val
00:A914 6578705F6162735F	     1M      asciiz   "exp_abs_val"
00:A91C 76616C
00:A91F 00
00:A920 AFAB            	     2M      word     exp_abs_val
                        	  2422:   makeAsmLibraryFunction "display_in_decimal",   display_in_decimal
00:A922 646973706C61795F	     1M      asciiz   "display_in_decimal"
00:A92A 696E5F646563696D
00:A932 616C
00:A934 00
00:A935 5291            	     2M      word     display_in_decimal
                        	  2423:   makeAsmLibraryFunction "digitalwrite",         digitalwrite
00:A937 6469676974616C77	     1M      asciiz   "digitalwrite"
00:A93F 72697465
00:A943 00
00:A944 17C8            	     2M      word     digitalwrite
                        	  2424:   makeAsmLibraryFunction "digitalread",          digitalread
00:A946 6469676974616C72	     1M      asciiz   "digitalread"
00:A94E 656164
00:A951 00
00:A952 46C8            	     2M      word     digitalread
                        	  2425:   makeAsmLibraryFunction "dest",                 DEST
00:A954 64657374        	     1M      asciiz   "dest"
00:A958 00
00:A959 0300            	     2M      word     DEST
                        	  2426:   makeAsmLibraryFunction "delay",                delay
00:A95B 64656C6179      	     1M      asciiz   "delay"
00:A960 00
00:A961 D590            	     2M      word     delay
                        	  2427:   makeAsmLibraryFunction "delay_1ms",            delay_1ms
00:A963 64656C61795F316D	     1M      asciiz   "delay_1ms"
00:A96B 73
00:A96C 00
00:A96D CB90            	     2M      word     delay_1ms
                        	  2428:   makeAsmLibraryFunction "crout",                CROUT
00:A96F 63726F7574      	     1M      asciiz   "crout"
00:A974 00
00:A975 2892            	     2M      word     CROUT
                        	  2429:   makeAsmLibraryFunction "crc_val",              crc_val
00:A977 6372635F76616C  	     1M      asciiz   "crc_val"
00:A97E 00
00:A97F 0600            	     2M      word     crc_val
                        	  2430:   makeAsmLibraryFunction "crc_num",              crc_num
00:A981 6372635F6E756D  	     1M      asciiz   "crc_num"
00:A988 00
00:A989 0300            	     2M      word     crc_num
                        	  2431:   makeAsmLibraryFunction "crc_byte",             crc_byte
00:A98B 6372635F62797465	     1M      asciiz   "crc_byte"
00:A993 00
00:A994 2590            	     2M      word     crc_byte
                        	  2432:   makeAsmLibraryFunction "crc_addr",             crc_addr
00:A996 6372635F61646472	     1M      asciiz   "crc_addr"
00:A99E 00
00:A99F 0000            	     2M      word     crc_addr
                        	  2433:   makeAsmLibraryFunction "crc16",                crc16
00:A9A1 6372633136      	     1M      asciiz   "crc16"
00:A9A6 00
00:A9A7 FD8F            	     2M      word     crc16
                        	  2434:   makeAsmLibraryFunction "cout",                 COUT
00:A9A9 636F7574        	     1M      asciiz   "cout"
00:A9AD 00
00:A9AE AF93            	     2M      word     COUT
                        	  2435:   makeAsmLibraryFunction "comstl",               COMSTL
00:A9B0 636F6D73746C    	     1M      asciiz   "comstl"
00:A9B6 00
00:A9B7 2D92            	     2M      word     COMSTL
                        	  2436:   makeAsmLibraryFunction "call_y",               call_y
00:A9B9 63616C6C5F79    	     1M      asciiz   "call_y"
00:A9BF 00
00:A9C0 1200            	     2M      word     call_y
                        	  2437:   makeAsmLibraryFunction "call_x",               call_x
00:A9C2 63616C6C5F78    	     1M      asciiz   "call_x"
00:A9C8 00
00:A9C9 1100            	     2M      word     call_x
                        	  2438:   makeAsmLibraryFunction "call_s",               call_s
00:A9CB 63616C6C5F73    	     1M      asciiz   "call_s"
00:A9D1 00
00:A9D2 1400            	     2M      word     call_s
                        	  2439:   makeAsmLibraryFunction "call_p",               call_p
00:A9D4 63616C6C5F70    	     1M      asciiz   "call_p"
00:A9DA 00
00:A9DB 1300            	     2M      word     call_p
                        	  2440:   makeAsmLibraryFunction "call_a",               call_a
00:A9DD 63616C6C5F61    	     1M      asciiz   "call_a"
00:A9E3 00
00:A9E4 1000            	     2M      word     call_a
                        	  2441:   makeAsmLibraryFunction "binary_to_decimal",    binary_to_decimal
00:A9E6 62696E6172795F74	     1M      asciiz   "binary_to_decimal"
00:A9EE 6F5F646563696D61
00:A9F6 6C
00:A9F7 00
00:A9F8 7B91            	     2M      word     binary_to_decimal
                        	  2442: 
00:A9FA 00              	  2443:   dfb 0   ; end of table
                        	  2444: 
                        	  2445: 
                        	  2446: add_assembler_library_functions:
00:A9FB A9C7            	  2447:   lda #<assembler_library_functions_table
00:A9FD 8500            	  2448:   sta REG
00:A9FF A9A5            	  2449:   lda #>assembler_library_functions_table
00:AA01 8501            	  2450:   sta REG+1
                        	  2451: add_assembler_library_functions_loop:
00:AA03 A000            	  2452:   ldy #0
00:AA05 B100            	  2453:   lda (REG),Y
00:AA07 F03C            	  2454:   beq add_assembler_library_functions_done
00:AA09 A500            	  2455:   lda REG
00:AA0B 8590            	  2456:   sta token_address
00:AA0D A501            	  2457:   lda REG+1
00:AA0F 8591            	  2458:   sta token_address+1
00:AA11 6492            	  2459:   stz token_length
                        	  2460: ;
                        	  2461: ;  find name length
                        	  2462: ;
                        	  2463: add_assembler_library_functions_name_loop
00:AA13 C8              	  2464:   iny
00:AA14 E692            	  2465:   inc token_length
00:AA16 B100            	  2466:   lda (REG),Y
00:AA18 D0F9            	  2467:   bne add_assembler_library_functions_name_loop
00:AA1A 5A              	  2468:   phy
00:AA1B 20A0B9          	  2469:   jsr CHKDUP
00:AA1E A943            	  2470:   lda #SYMBOL_CONSTANT  ; add the symbol as a constant for now
00:AA20 20F9B8          	  2471:   jsr ADDSYM
00:AA23 7A              	  2472:   ply
                        	  2473: 
00:AA24 C8              	  2474:   iny             ; get next byte
00:AA25 B100            	  2475:   lda (REG),Y     ; get function address low-byte
00:AA27 5A              	  2476:   phy
00:AA28 A004            	  2477:   ldy #SYMDSP
00:AA2A 9140            	  2478:   sta (SYMITM),Y  ; save function address low-byte
00:AA2C 7A              	  2479:   ply
                        	  2480: 
00:AA2D C8              	  2481:   iny             ; get next byte
00:AA2E B100            	  2482:   lda (REG),Y     ; get function address high-byte
00:AA30 5A              	  2483:   phy
00:AA31 A005            	  2484:   ldy #SYMDSP+1
00:AA33 9140            	  2485:   sta (SYMITM),Y  ; save function address high-byte
00:AA35 7A              	  2486:   ply
                        	  2487: 
00:AA36 C8              	  2488:   iny         ; get past that last byte
00:AA37 98              	  2489:   tya         ; move REG onto next entry
00:AA38 18              	  2490:   clc
00:AA39 6500            	  2491:   adc REG
00:AA3B 8500            	  2492:   sta REG
00:AA3D A900            	  2493:   lda #0
00:AA3F 6501            	  2494:   adc REG+1
00:AA41 8501            	  2495:   sta REG+1
00:AA43 80BE            	  2496:   bra add_assembler_library_functions_loop
                        	  2497: 
                        	  2498: add_assembler_library_functions_done:
00:AA45 60              	  2499:   rts
                        	  2500: 

Source: "gpascal.asm"
                        	   178:   .include "math.inc"

Source: "math.inc"
                        	     1: ;--------------------------------------------------
                        	     2: ; Maths routines. 3-byte operations on VALUE and VALUE2
                        	     3: ;
                        	     4: ;--------------------------------------------------
                        	     5: exp_add:
00:AA46 18              	     6:   clc
00:AA47 A500            	     7:   lda VALUE
00:AA49 6503            	     8:   adc VALUE2
00:AA4B 8500            	     9:   sta VALUE
00:AA4D A501            	    10:   lda VALUE+1
00:AA4F 6504            	    11:   adc VALUE2+1
00:AA51 8501            	    12:   sta VALUE+1
00:AA53 A502            	    13:   lda VALUE+2
00:AA55 6505            	    14:   adc VALUE2+2
00:AA57 8502            	    15:   sta VALUE+2
00:AA59 60              	    16:   rts
                        	    17: 
                        	    18: ;
                        	    19: ;  subtract VALUE2 from VALUE, store in VALUE, also set the sign bit
                        	    20: ;   and put the low order two bytes in X and Y
                        	    21: ;
                        	    22: exp_subtract:
00:AA5A 38              	    23:   sec
00:AA5B A500            	    24:   lda VALUE
00:AA5D E503            	    25:   sbc VALUE2
00:AA5F 8500            	    26:   sta VALUE
00:AA61 A8              	    27:   tay
00:AA62 A501            	    28:   lda VALUE+1
00:AA64 E504            	    29:   sbc VALUE2+1
00:AA66 AA              	    30:   tax
00:AA67 8501            	    31:   sta VALUE+1
00:AA69 A502            	    32:   lda VALUE+2
00:AA6B E505            	    33:   sbc VALUE2+2
00:AA6D 8502            	    34:   sta VALUE+2
00:AA6F 60              	    35:   rts
                        	    36: 
                        	    37: exp_true:
00:AA70 A901            	    38:   lda #1
00:AA72 8500            	    39:   sta VALUE
00:AA74 6401            	    40:   stz VALUE+1
00:AA76 6402            	    41:   stz VALUE+2
00:AA78 60              	    42:   rts
                        	    43: 
                        	    44: exp_false:
00:AA79 6400            	    45:   stz VALUE
00:AA7B 6401            	    46:   stz VALUE+1
00:AA7D 6402            	    47:   stz VALUE+2
00:AA7F 60              	    48:   rts
                        	    49: 
                        	    50: exp_eql:
00:AA80 A500            	    51:   lda VALUE
00:AA82 C503            	    52:   cmp VALUE2
00:AA84 D0F3            	    53:   bne exp_false
00:AA86 A501            	    54:   lda VALUE+1
00:AA88 C504            	    55:   cmp VALUE2+1
00:AA8A D0ED            	    56:   bne exp_false
00:AA8C A502            	    57:   lda VALUE+2
00:AA8E C505            	    58:   cmp VALUE2+2
00:AA90 D0E7            	    59:   bne exp_false
00:AA92 80DC            	    60:   bra exp_true
                        	    61: 
                        	    62: exp_neq:
00:AA94 A500            	    63:   lda VALUE
00:AA96 C503            	    64:   cmp VALUE2
00:AA98 D0D6            	    65:   bne exp_true
00:AA9A A501            	    66:   lda VALUE+1
00:AA9C C504            	    67:   cmp VALUE2+1
00:AA9E D0D0            	    68:   bne exp_true
00:AAA0 A502            	    69:   lda VALUE+2
00:AAA2 C505            	    70:   cmp VALUE2+2
00:AAA4 D0CA            	    71:   bne exp_true
00:AAA6 80D1            	    72:   bra exp_false
                        	    73: 
                        	    74: exp_less_than:
00:AAA8 205AAA          	    75:   jsr exp_subtract
00:AAAB 30C3            	    76:   bmi exp_true
00:AAAD 10CA            	    77:   bpl exp_false
                        	    78: 
                        	    79: exp_greater_than:
00:AAAF 205AAA          	    80:   jsr exp_subtract
00:AAB2 30C5            	    81:   bmi exp_false
00:AAB4 D0BA            	    82:   bne exp_true
00:AAB6 98              	    83:   tya
00:AAB7 D0B7            	    84:   bne exp_true
00:AAB9 8A              	    85:   txa
00:AABA D0B4            	    86:   bne exp_true
00:AABC 10BB            	    87:   bpl exp_false
                        	    88: 
                        	    89: exp_leq:
00:AABE 205AAA          	    90:   jsr exp_subtract
00:AAC1 30AD            	    91:   bmi exp_true
00:AAC3 D0B4            	    92:   bne exp_false
00:AAC5 98              	    93:   tya
00:AAC6 D0B1            	    94:   bne exp_false
00:AAC8 8A              	    95:   txa
00:AAC9 D0AE            	    96:   bne exp_false
00:AACB 10A3            	    97:   bpl exp_true
                        	    98: 
                        	    99: exp_geq:
00:AACD 205AAA          	   100:   jsr exp_subtract
00:AAD0 30A7            	   101:   bmi exp_false
00:AAD2 109C            	   102:   bpl exp_true
                        	   103: 
                        	   104: exp_bitwise_or:
00:AAD4 A500            	   105:   lda VALUE
00:AAD6 0503            	   106:   ora VALUE2
00:AAD8 8500            	   107:   sta VALUE
00:AADA A8              	   108:   tay
00:AADB A501            	   109:   lda VALUE+1
00:AADD 0504            	   110:   ora VALUE2+1
00:AADF 8501            	   111:   sta VALUE+1
00:AAE1 AA              	   112:   tax
00:AAE2 A502            	   113:   lda VALUE+2
00:AAE4 0505            	   114:   ora VALUE2+2
00:AAE6 8502            	   115:   sta VALUE+2
00:AAE8 60              	   116:   rts
                        	   117: 
                        	   118: exp_bitwise_and:
00:AAE9 A500            	   119:   lda VALUE
00:AAEB 2503            	   120:   and VALUE2
00:AAED 8500            	   121:   sta VALUE
00:AAEF A8              	   122:   tay
00:AAF0 A501            	   123:   lda VALUE+1
00:AAF2 2504            	   124:   and VALUE2+1
00:AAF4 8501            	   125:   sta VALUE+1
00:AAF6 AA              	   126:   tax
00:AAF7 A502            	   127:   lda VALUE+2
00:AAF9 2505            	   128:   and VALUE2+2
00:AAFB 8502            	   129:   sta VALUE+2
00:AAFD 60              	   130:   rts
                        	   131: 
                        	   132: exp_bitwise_xor:
00:AAFE A500            	   133:   lda VALUE
00:AB00 4503            	   134:   eor VALUE2
00:AB02 8500            	   135:   sta VALUE
00:AB04 A8              	   136:   tay
00:AB05 A501            	   137:   lda VALUE+1
00:AB07 4504            	   138:   eor VALUE2+1
00:AB09 8501            	   139:   sta VALUE+1
00:AB0B AA              	   140:   tax
00:AB0C A502            	   141:   lda VALUE+2
00:AB0E 4505            	   142:   eor VALUE2+2
00:AB10 8502            	   143:   sta VALUE+2
00:AB12 60              	   144:   rts
                        	   145: 
                        	   146: 
00:AB13 4C70AA          	   147: exp_trueJ jmp exp_true
00:AB16 4C79AA          	   148: exp_falseJ jmp exp_false
                        	   149: 
                        	   150: exp_logical_or:
00:AB19 20D4AA          	   151:   jsr exp_bitwise_or
00:AB1C D0F5            	   152:   bne exp_trueJ
00:AB1E E000            	   153:   cpx #0
00:AB20 D0F1            	   154:   bne exp_trueJ
00:AB22 C000            	   155:   cpy #0
00:AB24 D0ED            	   156:   bne exp_trueJ
00:AB26 80EE            	   157:   bra exp_falseJ
                        	   158: 
                        	   159: exp_logical_and:
00:AB28 A500            	   160:   lda VALUE
00:AB2A 0501            	   161:   ora VALUE+1
00:AB2C 0502            	   162:   ora VALUE+2
00:AB2E F0E6            	   163:   beq exp_falseJ  ; if VALUE has all bits zero the logical "and" must be false
                        	   164: ;
                        	   165: ;  VALUE is non-zero, how about VALUE2?
                        	   166: ;
00:AB30 A503            	   167:   lda VALUE2
00:AB32 0504            	   168:   ora VALUE2+1
00:AB34 0505            	   169:   ora VALUE2+2
00:AB36 F0DE            	   170:   beq exp_falseJ  ; if VALUE2 has all bits zero the logical "and" must be false
00:AB38 80D9            	   171:   bra exp_trueJ   ; both are non-zero, therefore the result is true
                        	   172: 
                        	   173: exp_shift_left:
00:AB3A A504            	   174:   lda VALUE2+1
00:AB3C 0505            	   175:   ora VALUE2+2
00:AB3E D0D6            	   176:   bne exp_falseJ  ; big shifts will return zero
00:AB40 A503            	   177:   lda VALUE2
00:AB42 F00E            	   178:   beq exp_shift_left_done ; shift by zero? we are done then
00:AB44 AA              	   179:   tax
00:AB45 29E0            	   180:   and #$E0        ; maximum of 32 shifts
00:AB47 D0CD            	   181:   bne exp_falseJ
                        	   182: exp_shift_left_loop:
00:AB49 0600            	   183:   asl VALUE
00:AB4B 2601            	   184:   rol VALUE+1
00:AB4D 2602            	   185:   rol VALUE+2
00:AB4F CA              	   186:   dex
00:AB50 D0F7            	   187:   bne exp_shift_left_loop
                        	   188: exp_shift_left_done:
00:AB52 60              	   189:   rts
                        	   190: 
                        	   191: exp_shift_right:
00:AB53 A504            	   192:   lda VALUE2+1
00:AB55 0505            	   193:   ora VALUE2+2
00:AB57 D0BD            	   194:   bne exp_falseJ  ; big shifts will return zero
00:AB59 A503            	   195:   lda VALUE2
00:AB5B F00E            	   196:   beq exp_shift_right_done ; shift by zero? we are done then
00:AB5D AA              	   197:   tax
00:AB5E 29E0            	   198:   and #$E0        ; maximum of 32 shifts
00:AB60 D0B4            	   199:   bne exp_falseJ
                        	   200: exp_shift_right_loop:
00:AB62 4602            	   201:   lsr VALUE+2
00:AB64 6601            	   202:   ror VALUE+1
00:AB66 6600            	   203:   ror VALUE
00:AB68 CA              	   204:   dex
00:AB69 D0F7            	   205:   bne exp_shift_right_loop
                        	   206: exp_shift_right_done:
00:AB6B 60              	   207:   rts
                        	   208: 
                        	   209: exp_negate:
00:AB6C A500            	   210:   lda VALUE
00:AB6E 49FF            	   211:   eor #$FF
00:AB70 8500            	   212:   sta VALUE
00:AB72 A501            	   213:   lda VALUE+1
00:AB74 49FF            	   214:   eor #$FF
00:AB76 8501            	   215:   sta VALUE+1
00:AB78 A502            	   216:   lda VALUE+2
00:AB7A 49FF            	   217:   eor #$FF
00:AB7C 8502            	   218:   sta VALUE+2
00:AB7E 60              	   219:   rts
                        	   220: 
                        	   221: exp_not:
00:AB7F A500            	   222:   lda VALUE
00:AB81 D093            	   223:   bne exp_falseJ
00:AB83 A501            	   224:   lda VALUE+1
00:AB85 D08F            	   225:   bne exp_falseJ
00:AB87 A502            	   226:   lda VALUE+2
00:AB89 D08B            	   227:   bne exp_falseJ
00:AB8B 8086            	   228:   bra exp_trueJ
                        	   229: 
                        	   230: exp_unary_minus:
00:AB8D 38              	   231:   sec
00:AB8E A900            	   232:   lda #0
00:AB90 E500            	   233:   sbc VALUE
00:AB92 8500            	   234:   sta VALUE
00:AB94 A900            	   235:   lda #0
00:AB96 E501            	   236:   sbc VALUE+1
00:AB98 8501            	   237:   sta VALUE+1
00:AB9A A900            	   238:   lda #0
00:AB9C E502            	   239:   sbc VALUE+2
00:AB9E 8502            	   240:   sta VALUE+2
00:ABA0 60              	   241:   rts
                        	   242: 
                        	   243: 
                        	   244: exp_low_byte:
00:ABA1 6401            	   245:   stz VALUE+1
00:ABA3 6402            	   246:   stz VALUE+2
00:ABA5 60              	   247:   rts
                        	   248: 
                        	   249: exp_high_byte:
00:ABA6 A501            	   250:   lda VALUE+1
00:ABA8 8500            	   251:   sta VALUE
00:ABAA 6401            	   252:   stz VALUE+1
00:ABAC 6402            	   253:   stz VALUE+2
00:ABAE 60              	   254:   rts
                        	   255: 
                        	   256: ;
                        	   257: ;  make VALUE positive
                        	   258: ;
                        	   259: exp_abs_val:
00:ABAF A502            	   260:   lda  VALUE+2  ; check high-order byte, see if negative
00:ABB1 1013            	   261:   bpl  exp_abs_val_done
                        	   262: exp_negate_val:
00:ABB3 38              	   263:   sec
00:ABB4 A900            	   264:   lda  #0
00:ABB6 E500            	   265:   sbc  VALUE
00:ABB8 8500            	   266:   sta  VALUE
00:ABBA A900            	   267:   lda  #0
00:ABBC E501            	   268:   sbc  VALUE+1
00:ABBE 8501            	   269:   sta  VALUE+1
00:ABC0 A900            	   270:   lda  #0
00:ABC2 E502            	   271:   sbc  VALUE+2
00:ABC4 8502            	   272:   sta  VALUE+2
                        	   273: exp_abs_val_done:
00:ABC6 60              	   274:   rts
                        	   275: 
                        	   276: ;
                        	   277: ;  make VALUE2 positive
                        	   278: ;
                        	   279: exp_abs_val2:
00:ABC7 A505            	   280:   lda  VALUE2+2  ; check high-order byte, see if negative
00:ABC9 1013            	   281:   bpl  exp_abs_val2_done
                        	   282: exp_negate_val2:
00:ABCB 38              	   283:   sec
00:ABCC A900            	   284:   lda  #0
00:ABCE E503            	   285:   sbc  VALUE2
00:ABD0 8503            	   286:   sta  VALUE2
00:ABD2 A900            	   287:   lda  #0
00:ABD4 E504            	   288:   sbc  VALUE2+1
00:ABD6 8504            	   289:   sta  VALUE2+1
00:ABD8 A900            	   290:   lda  #0
00:ABDA E505            	   291:   sbc  VALUE2+2
00:ABDC 8505            	   292:   sta  VALUE2+2
                        	   293: exp_abs_val2_done:
00:ABDE 60              	   294:   rts
                        	   295: 
                        	   296: 
                        	   297: ZERRES:
00:ABDF A900            	   298:   lda  #0
00:ABE1 8552            	   299:   sta  RES
00:ABE3 8553            	   300:   sta  RES+1
00:ABE5 8554            	   301:   sta  RES+2
00:ABE7 60              	   302:   rts
                        	   303: 
                        	   304: exp_find_sign:
00:ABE8 20DFAB          	   305:    jsr  ZERRES     ; zero result
00:ABEB A502            	   306:    lda  VALUE+2
00:ABED 2980            	   307:    and  #$80
00:ABEF 855B            	   308:    sta  RMNDR
00:ABF1 A505            	   309:    lda  VALUE2+2
00:ABF3 2980            	   310:    and  #$80
00:ABF5 455B            	   311:    eor  RMNDR
00:ABF7 855B            	   312:    sta  RMNDR     ; RMNDR is 0x80 if the result needs to be negative
00:ABF9 20AFAB          	   313:    jsr  exp_abs_val
00:ABFC 20C7AB          	   314:    jsr  exp_abs_val2
00:ABFF 60              	   315:    rts
                        	   316: ;
                        	   317: 
                        	   318: exp_fix_sign:
00:AC00 A55B            	   319:   lda  RMNDR
00:AC02 100F            	   320:   bpl  exp_fix_sign_done      ; nothing needs to be changed
00:AC04 38              	   321:   sec                         ; subtract result from zero
00:AC05 A900            	   322:   lda  #0
00:AC07 E552            	   323:   sbc  RES
00:AC09 AA              	   324:   tax
00:AC0A A900            	   325:   lda  #0
00:AC0C E553            	   326:   sbc  RES+1
00:AC0E A8              	   327:   tay
00:AC0F A900            	   328:   lda  #0
00:AC11 E554            	   329:   sbc  RES+2
                        	   330: exp_fix_sign_done:
00:AC13 60              	   331:   rts
                        	   332: 
                        	   333: 
                        	   334: ;
                        	   335: ;  multiply VALUE1 by VALUE2 and store in VALUE
                        	   336: ;
                        	   337: ;  see: https://llx.com/Neil/a2/mult.html for a discussion
                        	   338: ;
                        	   339: 
                        	   340: exp_multiply:
00:AC14 20E8AB          	   341:   jsr exp_find_sign
00:AC17 A218            	   342:   ldx  #24       ; for all 24 bits
                        	   343: exp_multiply_loop:
00:AC19 0652            	   344:   asl  RES
00:AC1B 2653            	   345:   rol  RES+1
00:AC1D 2654            	   346:   rol  RES+2                    ; shift RES left one bit
00:AC1F 0600            	   347:   asl  VALUE
00:AC21 2601            	   348:   rol  VALUE+1
00:AC23 2602            	   349:   rol  VALUE+2                  ; shift one argument left one bit and get the low-order bit into carry
00:AC25 9013            	   350:   bcc  exp_multiply_no_add      ; if no low-order bit, don't add anything
00:AC27 18              	   351:   clc                           ; add the other argument to the result
00:AC28 A503            	   352:   lda  VALUE2
00:AC2A 6552            	   353:   adc  RES
00:AC2C 8552            	   354:   sta  RES
00:AC2E A504            	   355:   lda  VALUE2+1
00:AC30 6553            	   356:   adc  RES+1
00:AC32 8553            	   357:   sta  RES+1
00:AC34 A505            	   358:   lda  VALUE2+2
00:AC36 6554            	   359:   adc  RES+2
00:AC38 8554            	   360:   sta  RES+2
                        	   361: exp_multiply_no_add:
00:AC3A CA              	   362:   dex                      ; count bits
00:AC3B D0DC            	   363:   bne  exp_multiply_loop   ; go back if more to go
00:AC3D 2000AC          	   364:   jsr  exp_fix_sign
00:AC40 A552            	   365:   lda  RES
00:AC42 8500            	   366:   sta  VALUE
00:AC44 A553            	   367:   lda  RES+1
00:AC46 8501            	   368:   sta  VALUE+1
00:AC48 A554            	   369:   lda  RES+2
00:AC4A 8502            	   370:   sta  VALUE+2
00:AC4C 60              	   371:   rts
                        	   372: 
                        	   373: ;
                        	   374: ;  divide VALUE by VALUE2, store result in VALUE
                        	   375: ;
                        	   376: exp_divide:
00:AC4D 20E8AB          	   377:   jsr exp_find_sign
                        	   378: 
00:AC50 A503            	   379:   lda  VALUE2
00:AC52 0504            	   380:   ora  VALUE2+1
00:AC54 0505            	   381:   ora  VALUE2+2
00:AC56 D005            	   382:   bne  exp_divide_not_zero  ; check not dividing by zero
00:AC58 A22F            	   383:   ldx  #47                  ; ERROR: divide by zero
00:AC5A 4CB79E          	   384:   jmp  ass_error
                        	   385:   ;
                        	   386: exp_divide_not_zero:
00:AC5D 20DFAB          	   387:   jsr  ZERRES     ; zero result (RES) - leaves zero in A register
00:AC60 8506            	   388:   sta  REMAIN
00:AC62 8507            	   389:   sta  REMAIN+1
00:AC64 8508            	   390:   sta  REMAIN+2
00:AC66 A918            	   391:   lda  #24       ; for all 24 bits of the operands ...
00:AC68 858D            	   392:   sta  maths_work
                        	   393: exp_divide_loop:
00:AC6A 0600            	   394:   asl  VALUE
00:AC6C 2601            	   395:   rol  VALUE+1
00:AC6E 2602            	   396:   rol  VALUE+2    ; shift the dividend left one bit
00:AC70 2606            	   397:   rol  REMAIN    ; the low-order bit of the dividend is shifted into the remainder
00:AC72 2607            	   398:   rol  REMAIN+1
00:AC74 2608            	   399:   rol  REMAIN+2
00:AC76 38              	   400:   sec
00:AC77 A506            	   401:   lda  REMAIN    ; do a trial subtraction of: remainder - divisor
00:AC79 E503            	   402:   sbc  VALUE2
00:AC7B AA              	   403:   tax
00:AC7C A507            	   404:   lda  REMAIN+1
00:AC7E E504            	   405:   sbc  VALUE2+1
00:AC80 A8              	   406:   tay
00:AC81 A508            	   407:   lda  REMAIN+2
00:AC83 E505            	   408:   sbc  VALUE2+2
00:AC85 300B            	   409:   bmi  exp_divide_subtraction_negative      ; if the subtraction fails (is negative) then discard the result
00:AC87 8508            	   410:   sta  REMAIN+2  ; if it succeeds then the result of the subtraction is our new remainder
00:AC89 98              	   411:   tya
00:AC8A 8507            	   412:   sta  REMAIN+1
00:AC8C 8A              	   413:   txa
00:AC8D 8506            	   414:   sta  REMAIN
00:AC8F 38              	   415:   sec            ; shift a one-bit into the quotient
00:AC90 B001            	   416:   bcs  exp_divide_subtraction_positive
                        	   417: exp_divide_subtraction_negative:
00:AC92 18              	   418:   clc            ; here if subtraction failed, quotient (RES) gets a 0-bit shifted in
                        	   419: exp_divide_subtraction_positive:
00:AC93 2652            	   420:   rol  RES       ; the carry bit (from above) is shifted into the quotient
00:AC95 2653            	   421:   rol  RES+1
00:AC97 2654            	   422:   rol  RES+2
00:AC99 C68D            	   423:   dec  maths_work      ; one less bit to go
00:AC9B D0CD            	   424:   bne  exp_divide_loop      ; repeat until 24 bits done
00:AC9D 2000AC          	   425:   jsr  exp_fix_sign
00:ACA0 A552            	   426:   lda  RES
00:ACA2 8500            	   427:   sta  VALUE
00:ACA4 A553            	   428:   lda  RES+1
00:ACA6 8501            	   429:   sta  VALUE+1
00:ACA8 A554            	   430:   lda  RES+2
00:ACAA 8502            	   431:   sta  VALUE+2
00:ACAC 60              	   432:   rts
                        	   433: 
                        	   434: exp_modulo:
00:ACAD 204DAC          	   435:   jsr exp_divide
00:ACB0 A506            	   436:   lda REMAIN
00:ACB2 8500            	   437:   sta VALUE
00:ACB4 A507            	   438:   lda REMAIN+1
00:ACB6 8501            	   439:   sta VALUE+1
00:ACB8 A508            	   440:   lda REMAIN+2
00:ACBA 8502            	   441:   sta VALUE+2
00:ACBC 60              	   442:   rts
                        	   443: 

Source: "gpascal.asm"
                        	   179:   .include "interpreter.inc"

Source: "interpreter.inc"
                        	     1: ;--------------------------------------------------
                        	     2: ; Runtime P-code interpreter
                        	     3: ;
                        	     4: ;--------------------------------------------------
                        	     5: 
                        	     6: 
                        	     7: ;--------------------------------
                        	     8: ; P-codes - these are generated in the compilation phase and looked up
                        	     9: ;           in execution_address_table at runtime
                        	    10: ;
                        	    11: ; Note: some P-codes must appear in sequence, eg. PCODE_STO and PCODE_STOC
                        	    12: ;       That is because one refers to integers (STO) and one refers to characters (STOC)
                        	    13: ;       The code in various places is virtually identical except it adds 1 to the P-code
                        	    14: ;       for characters. These generally are the Load/Store operations.
                        	    15: ;--------------------------------
                        	    16: 
                        	    17: ; Not implemented yet: $05, $13, $15, $39
                        	    18: 
                        	    19: ;                 Code            Description                         Arguments
                        	    20: ;                 ----            -----------------------------       -----------------------
                        	    21: PCODE_LIT     = 	$00 ; Dec:  0 - Load constant                     - 3-byte literal (number)
                        	    22: PCODE_STACK   =   $01 ; Dec:  1 - Alter runtime stack to address    - 2-byte stack address
                        	    23: PCODE_NEG     = 	$02 ; Dec:  2 - Unary minus 0 - (sp)              - none
                        	    24: PCODE_LIB_CALL =  $03 ; Dec:  3 - Call library function/procedure   - absolute address
                        	    25: PCODE_ADD     = 	$04 ; Dec:  4 - Add (sp) to (sp - 1)              - none
                        	    26: PCODE_SUB     = 	$06 ; Dec:  6 - Subtract (sp) from (sp - 1)       - none
                        	    27: PCODE_MUL     = 	$08 ; Dec:  8 - Multiply (sp) * (sp - 1)          - none
                        	    28: PCODE_DIV     = 	$0A ; Dec: 10 - Divide (sp - 1) / (sp)            - none
                        	    29: PCODE_MOD     = 	$0B ; Dec: 11 - Modulus (sp - 1) MOD (sp)         - none
                        	    30: PCODE_ADRNN   = 	$0C ; Dec: 12 - Address of integer                - level, displ
                        	    31: PCODE_ADRNC   = 	$0D ; Dec: 13 - Address of character              - level, displ
                        	    32: PCODE_ADRAN   = 	$0E ; Dec: 14 - Address of integer array          - level, displ
                        	    33: PCODE_ADRAC   = 	$0F ; Dec: 15 - Address of character array        - level, displ
                        	    34: PCODE_EQL     = 	$10 ; Dec: 16 - Test (sp - 1) == (sp)             - none
                        	    35: PCODE_FINISHD = 	$11 ; Dec: 17 - Stop run (end program)            - none
                        	    36: PCODE_NEQ     = 	$12 ; Dec: 18 - Test (sp - 1) != (sp)             - none
                        	    37: PCODE_LSS     = 	$14 ; Dec: 20 - Test (sp - 1) < (sp)              - none
                        	    38: PCODE_GEQ     = 	$16 ; Dec: 22 - Test (sp - 1) >= (sp)             - none
                        	    39: PCODE_GTR     = 	$18 ; Dec: 24 - Test (sp - 1) > (sp)              - none
                        	    40: PCODE_LEQ     = 	$19 ; Dec: 25 - Test (sp - 1) <= (sp)             - none
                        	    41: PCODE_ORR     = 	$1A ; Dec: 26 - OR  (sp - 1) | (sp)               - none
                        	    42: PCODE_AND     = 	$1B ; Dec: 27 - AND (sp - 1) & (sp)               - none
                        	    43: PCODE_INP     = 	$1C ; Dec: 28 - Input number                      - none
                        	    44: PCODE_INPC    = 	$1D ; Dec: 29 - Input character                   - none
                        	    45: PCODE_OUT     = 	$1E ; Dec: 30 - Output number                     - none
                        	    46: PCODE_OUTC    = 	$1F ; Dec: 31 - Output character                  - none
                        	    47: PCODE_EOR     = 	$20 ; Dec: 32 - Not (sp) (logical negate)         - none
                        	    48: PCODE_OUH     = 	$21 ; Dec: 33 - Output hex number                 - none
                        	    49: PCODE_SHL     = 	$22 ; Dec: 34 - Shift left (sp) bits              - none
                        	    50: PCODE_OUS     = 	$23 ; Dec: 35 - Output string                     - length, string
                        	    51: PCODE_SHR     = 	$24 ; Dec: 36 - Shift right (sp) bits             - none
                        	    52: PCODE_INS     = 	$25 ; Dec: 37 - Input string into array           - max, level, displ
                        	    53: PCODE_INC     = 	$26 ; Dec: 38 - Increment (sp) by 1               - none
                        	    54: PCODE_CLL     = 	$27 ; Dec: 39 - Relative procedure/function call  - level, relative address
                        	    55: PCODE_DEC     = 	$28 ; Dec: 40 - Decrement (sp) by 1               - none
                        	    56: PCODE_RTN     = 	$29 ; Dec: 41 - Procedure/function return         - none
                        	    57: PCODE_MOV     = 	$2A ; Dec: 42 - Copy (sp) to (sp + 1)             - none
                        	    58: PCODE_CLA     = 	$2B ; Dec: 43 - Call absolute address             - none
                        	    59: PCODE_LOD     = 	$2C ; Dec: 44 - Load integer onto stack           - level, displ
                        	    60: PCODE_LODC    = 	$2D ; Dec: 45 - Load character onto stack         - level, displ
                        	    61: PCODE_LDA     = 	$2E ; Dec: 46 - Load absolute address integer     - none
                        	    62: PCODE_LDAC    = 	$2F ; Dec: 47 - Load absolute address character   - none
                        	    63: PCODE_LDI     = 	$30 ; Dec: 48 - Load integer indexed              - level, displ
                        	    64: PCODE_LDIC    = 	$31 ; Dec: 49 - Load character indexed            - level, displ
                        	    65: PCODE_STO     = 	$32 ; Dec: 50 - Store integer                     - level, displ
                        	    66: PCODE_STOC    = 	$33 ; Dec: 51 - Store character                   - level, displ
                        	    67: PCODE_STA     = 	$34 ; Dec: 52 - Store integer absolute address    - none
                        	    68: PCODE_STAC    = 	$35 ; Dec: 53 - Store character absolute address  - none
                        	    69: PCODE_STI     = 	$36 ; Dec: 54 - Store integer indexed             - level, displ
                        	    70: PCODE_STIC    = 	$37 ; Dec: 55 - Store character indexed           - level, displ
                        	    71: PCODE_ABSCLL  = 	$38 ; Dec: 56 - Absolute procedure/function call  - level, absolute address
                        	    72: PCODE_XOR     = 	$3A ; Dec: 58 - XOR (sp - 1) ^ (sp)               - none
                        	    73: PCODE_INT     = 	$3B ; Dec: 59 - Increment stack pointer           - increment
                        	    74: PCODE_JMP     = 	$3C ; Dec: 60 - Jump unconditionally              - relative address
                        	    75: PCODE_JMZ     = 	$3D ; Dec: 61 - Jump if (sp) zero                 - relative address
                        	    76: PCODE_JM1     = 	$3E ; Dec: 62 - Jump if (sp) not zero             - relative address
                        	    77: PCODE_OUTCR   =   $40 ; Dec: 64 - Output a carriage-return          - none
                        	    78: PCODE_LCD_WRITE_NUM = $42 ; Dec: 66 - Write number to LCD           - none
                        	    79: PCODE_LCD_WRITE_STR = $43 ; Dec: 67 - Write string to LCD           - none
                        	    80: PCODE_LCD_WRITE_HEX = $44 ; Dec: 68 - Write hex number to LCD       - none
                        	    81: PCODE_LCD_WRITE_CHR = $45 ; Dec: 69 - Write character to LCD        - none
                        	    82: 
                        	    83: PCODE_LAST    =   PCODE_LCD_WRITE_CHR  ; PUT THIS LAST! (error check)                  -
                        	    84: 
                        	    85: ; 0x80 to 0xFF - Load low literal (onto stack), where literal is P-code with 8-bit clear (ie. P-code & 0x7F)
                        	    86: 
                        	    87: 
                        	    88: ;
                        	    89: ;  P-code execution routine lookup.
                        	    90: ;  For symbolic version see list above
                        	    91: ;
                        	    92: ;  Y is zero when starting to execute these routines
                        	    93: ;
                        	    94: execution_address_table  =  *
00:ACBD EEAF            	    95:   word  EX_LIT             ; $00 = LIT     	Load constant
00:ACBF E2B3            	    96:   word  EX_NEW_STACK       ; $01 =          Change stack to addr
00:ACC1 00B0            	    97:   word  EX_NEG             ; $02 = NEG     	Unary minus: 0 - (sp)
00:ACC3 6EB5            	    98:   word  EX_LIB_CALL        ; $03 = LIB_CALL Library function call
00:ACC5 09B0            	    99:   word  EX_ADD             ; $04 = ADD     	Add (sp) to (sp - 1)
00:ACC7 1CAF            	   100:   word  EX_INVINS          ; $05 =          NOT IMPLEMENTED
00:ACC9 12B0            	   101:   word  EX_SUB             ; $06 = SUB     	Subtract (sp) from (sp - 1)
00:ACCB 1CAF            	   102:   word  EX_INVINS          ; $07 =          NOT IMPLEMENTED
00:ACCD 1EB0            	   103:   word  EX_MUL             ; $08 = MUL     	Multiply (sp) * (sp - 1)
00:ACCF 1CAF            	   104:   word  EX_INVINS          ; $09 =          NOT IMPLEMENTED
00:ACD1 59B0            	   105:   word  EX_DIV             ; $0A = DIV     	Divide (sp - 1) / (sp)
00:ACD3 2EB0            	   106:   word  EX_MOD             ; $0B = MOD     	Modulus (sp - 1) MOD (sp)
00:ACD5 CDB4            	   107:   word  EX_ADRNN           ; $0C = ADRNN   	Address of integer
00:ACD7 BDB4            	   108:   word  EX_ADRNC           ; $0D = ADRNC   	Address of character
00:ACD9 DBB4            	   109:   word  EX_ADRAN           ; $0E = ADRAN   	Address of integer array
00:ACDB E1B4            	   110:   word  EX_ADRAC           ; $0F = ADRAC   	Address of character array
00:ACDD 76B0            	   111:   word  EX_EQL             ; $10 = EQL     	Test (sp - 1) == (sp)
00:ACDF 69AE            	   112:   word  EX_FINISHD         ; $11 = FINISHD 	Stop run (end program)
00:ACE1 90B0            	   113:   word  EX_NEQ             ; $12 = NEQ     	Test (sp - 1) != (sp)
00:ACE3 1CAF            	   114:   word  EX_INVINS          ; $13 =          NOT IMPLEMENTED
00:ACE5 99B0            	   115:   word  EX_LSS             ; $14 = LSS     	Test (sp - 1) < (sp)
00:ACE7 1CAF            	   116:   word  EX_INVINS          ; $15 =          NOT IMPLEMENTED
00:ACE9 B1B0            	   117:   word  EX_GEQ             ; $16 = GEQ     	Test (sp - 1) >= (sp)
00:ACEB 1CAF            	   118:   word  EX_INVINS          ; $17 =          NOT IMPLEMENTED
00:ACED A5B0            	   119:   word  EX_GTR             ; $18 = GTR     	Test (sp - 1) > (sp)
00:ACEF BDB0            	   120:   word  EX_LEQ             ; $19 = LEQ     	Test (sp - 1) <= (sp)
00:ACF1 D2B0            	   121:   word  EX_ORR             ; $1A = ORR     	OR  (sp - 1) | (sp)
00:ACF3 DBB0            	   122:   word  EX_AND             ; $1B = AND     	AND (sp - 1) & (sp)
00:ACF5 5BB2            	   123:   word  EX_INP             ; $1C = INP     	Input number
00:ACF7 23B4            	   124:   word  EX_INPC            ; $1D = INPC    	Input character
00:ACF9 9BB2            	   125:   word  EX_OUT             ; $1E = OUT     	Output number
00:ACFB 3DB4            	   126:   word  EX_OUTC            ; $1F = OUTC    	Output character
00:ACFD E4B0            	   127:   word  EX_EOR             ; $20 = EOR     	Not (sp) (logical negate)
00:ACFF AFB2            	   128:   word  EX_OUH             ; $21 = OUH     	Output hex number
00:AD01 EDB0            	   129:   word  EX_SHL             ; $22 = SHL     	Shift left (sp) bits
00:AD03 CFB2            	   130:   word  EX_OUS             ; $23 = OUS     	Output string
00:AD05 F9B0            	   131:   word  EX_SHR             ; $24 = SHR     	Shift right (sp) bits
00:AD07 5FB4            	   132:   word  EX_INS             ; $25 = INS     	Input string into array
00:AD09 05B1            	   133:   word  EX_INC             ; $26 = INC     	Increment (sp) by 1
00:AD0B 09B3            	   134:   word  EX_CLL             ; $27 = CLL     	Relative procedure/function call
00:AD0D 1DB1            	   135:   word  EX_DEC             ; $28 = DEC     	Decrement (sp) by 1
00:AD0F 22B2            	   136:   word  EX_RTN             ; $29 = RTN     	Procedure/function return
00:AD11 35B1            	   137:   word  EX_MOV             ; $2A = MOV     	Copy (sp) to (sp + 1)
00:AD13 98B3            	   138:   word  EX_CLA             ; $2B = CLA     	Call absolute address
00:AD15 58B1            	   139:   word  EX_LOD             ; $2C = LOD     	Load integer onto stack
00:AD17 46B1            	   140:   word  EX_LODC            ; $2D = LODC    	Load character onto stack
00:AD19 79B1            	   141:   word  EX_LDA             ; $2E = LDA     	Load absolute address integer
00:AD1B 6EB1            	   142:   word  EX_LDAC            ; $2F = LDAC    	Load absolute address character
00:AD1D B4B1            	   143:   word  EX_LDI             ; $30 = LDI     	Load integer indexed
00:AD1F AEB1            	   144:   word  EX_LDIC            ; $31 = LDIC    	Load character indexed
00:AD21 C7B1            	   145:   word  EX_STO             ; $32 = STO     	Store integer
00:AD23 BAB1            	   146:   word  EX_STOC            ; $33 = STOC    	Store character
00:AD25 DAB1            	   147:   word  EX_STA             ; $34 = STA     	Store integer absolute address
00:AD27 F0B1            	   148:   word  EX_STAC            ; $35 = STAC    	Store character absolute address
00:AD29 07B2            	   149:   word  EX_STI             ; $36 = STI     	Store integer indexed
00:AD2B F9B1            	   150:   word  EX_STIC            ; $37 = STIC    	Store character indexed
00:AD2D 02B3            	   151:   word  EX_ABSCLL          ; $38 = ABSCLL  	Absolute procedure/function call
00:AD2F 1CAF            	   152:   word  EX_INVINS          ; $39 =          NOT IMPLEMENTED
00:AD31 C9B0            	   153:   word  EX_XOR             ; $3A = XOR     	XOR (sp - 1) ^ (sp)
00:AD33 B8B3            	   154:   word  EX_INT             ; $3B = INT     	Increment stack pointer
00:AD35 F4B3            	   155:   word  EX_JMP             ; $3C = JMP     	Jump unconditionally
00:AD37 07B4            	   156:   word  EX_JMZ             ; $3D = JMZ     	Jump if (sp) zero
00:AD39 18B4            	   157:   word  EX_JM1             ; $3E = JM1     	Jump if (sp) not zero
00:AD3B 1CAF            	   158:   word  EX_INVINS          ; $3F =          NOT IMPLEMENTED
00:AD3D C9AE            	   159:   word  EX_OUTCR           ; $40 = OUTCR   	Output a carriage-return
00:AD3F 1CAF            	   160:   word  EX_INVINS          ; $41 =          NOT IMPLEMENTED
00:AD41 A0B2            	   161:   word  EX_LCD_WRITE_NUM   ; $42 = LCD_WRITE_NUM  Write number to LCD
00:AD43 D4B2            	   162:   word  EX_LCD_WRITE_STR   ; $43 = LCD_WRITE_STR  Write string to LCD
00:AD45 B4B2            	   163:   word  EX_LCD_WRITE_HEX   ; $44 = LCD_WRITE_HEX  Write hex to LCD
00:AD47 42B4            	   164:   word  EX_LCD_WRITE_CHR   ; $45 = LCD_WRITE_CHR  Write character to LCD
                        	   165: 
                        	   166: ;--------------------------------------------------------------------------
                        	   167: ;
                        	   168: ;  STACK FRAMES
                        	   169: ;
                        	   170: ;  The compiler can't know where variables are actually going to be stored because
                        	   171: ;  they will be relative to the (interpreter) stack (not the processor stack) which
                        	   172: ;  is an unknown address because procedures/functions can be called directly or from
                        	   173: ;  other procedures/functions.
                        	   174: ;
                        	   175: ;  Hence variables are referenced to BASE which is the base of the current stack frame,
                        	   176: ;  thus a variable will be a certain offset from that. However in the case of nested
                        	   177: ;  calls we need to go back to a previous stack frame. That is what the 6-byte "stack
                        	   178: ;  frame linkage data" is about.
                        	   179: ;
                        	   180: ;  Variables are referred to by a "level difference" and a displacement. For the current
                        	   181: ;  procedure the level difference will be zero, and thus the variable will be BASE +
                        	   182: ;  the offset for this particular variable.
                        	   183: ;
                        	   184: ;  For variables in earlier procedures/functions (ones which called this one) there will
                        	   185: ;  be a level difference, being the depth (lexically) between the called function and the
                        	   186: ;  one with the variable. For example, if foo calls bar, and bar recurses five times, foo
                        	   187: ;  and bar are still only one level apart, from the point of view of accessing foo's
                        	   188: ;  variables.
                        	   189: ;
                        	   190: ;  Thus, to find an address we need to "walk" back through the STATIC stack frame links
                        	   191: ;  (bytes 5 and 6 of the stack frame data) to find the appropriate stack frame, and then
                        	   192: ;  take the offset from that.
                        	   193: ;
                        	   194: ;  However for recursive calls, once a recursed call ends, we need to get back the stack
                        	   195: ;  frame of the caller, which will be different from the static frame. So, to restore the
                        	   196: ;  stack frame after a procedure/function ends, we must take the DYNAMIC stack frame address
                        	   197: ;  (bytes 3 and 4 of the stack frame data) to get back the previous stack frame. In fact,
                        	   198: ;  all procedures/functions do this, it's just that the static and dynamic stack frames will
                        	   199: ;  be the same if the procedure/function does not recurse.
                        	   200: ;
                        	   201: ;  Finally, the return address (in the P-codes) for the procedure/function call is also
                        	   202: ;  stored in the stack frame data (bytes 1 and 2 of the stack frame data) so that, after
                        	   203: ;  doing a return, we can restore the P-code address to the PCODE variable after the call.
                        	   204: ;
                        	   205: ;  When a procedure/function is called these 6 bytes are pushed onto the stack. Then, for
                        	   206: ;  some reason, the code moves the stack pointer back 6 (adds to it). Then as part of the
                        	   207: ;  procedure/function initialisation the stack pointer has 6 or 9 added to it, to allow
                        	   208: ;  for not overwriting this stack frame data, and in the case of functions, the extra 3
                        	   209: ;  bytes are for the returned value.
                        	   210: ;
                        	   211: ;  Note that the stack grows downwards, as it starts at "high memory" (whatever that is
                        	   212: ;  defined as, and grows downwards, taking the gap between the end of the P-codes and the
                        	   213: ;  end of memory.
                        	   214: ;
                        	   215: ;  Then the function will add additional spaces to the stack (ie. by subtracting from the
                        	   216: ;  stack pointer) to make room for variables declared in that procedure/function. Now we
                        	   217: ;  are ready to push data onto the stack as part of normal expression evalution. It follows
                        	   218: ;  from this that variables initially have undefined values, as they will contain whatever
                        	   219: ;  happened to be in the stack when this space was allocated.
                        	   220: ;
                        	   221: ;  The function GETADR resolves these addresses by starting with BASE, the stack frame base
                        	   222: ;  for the current procedure/function, and then using the static stack frame link to load a
                        	   223: ;  (temporary) new base, and repeating that until the level difference is zero. Then it adds
                        	   224: ;  the offset of the wanted variable to the stack base to derive the actual variable address.
                        	   225: ;
                        	   226: ;--------------------------------------------------------------------------
                        	   227: 
                        	   228: 
                        	   229: ;
00:AD49 20537461636B3A20	   230: DM1               asciiz  ' Stack: '
00:AD51 00
00:AD52 20426173653A2020	   231: DM2               asciiz  ' Base:  '
00:AD5A 00
00:AD5B 52756E6E696E670A	   232: running_message   asciiz  'Running\n'
00:AD63 00
                        	   233: 
                        	   234: ;
                        	   235: DEBUG    =  *
00:AD64 204392          	   236: DB11     jsr  DISPAD    ; display P-code address
00:AD67 A523            	   237:          lda  PCODE
00:AD69 8537            	   238:          sta  WORK
00:AD6B A524            	   239:          lda  PCODE+1
00:AD6D 8538            	   240:          sta  WORK+1
00:AD6F A204            	   241:          ldx  #4
00:AD71 202DAE          	   242:          jsr  display_x_characters      ; display 4 bytes from WORK (ie. the P-codes)
00:AD74 202892          	   243:          jsr  CROUT
00:AD77 A649            	   244:          ldx  DBGFLG
00:AD79 3051            	   245:          bmi  DEBUG_DONE        ; trace only
00:AD7B A949            	   246:          lda  #<DM1             ; ' Stack: '
00:AD7D A2AD            	   247:          ldx  #>DM1
00:AD7F 202682          	   248:          jsr  print
00:AD82 A532            	   249:          lda  T+1
00:AD84 209D92          	   250:          jsr  PRBYTE        ; display the stack pointer address
00:AD87 A531            	   251:          lda  T
00:AD89 203D92          	   252:          jsr  DISHX         ; display hex and a space after
00:AD8C A93D            	   253:          lda  #'='
00:AD8E 20AF93          	   254:          jsr  COUT
00:AD91 A531            	   255:          lda  T
00:AD93 8537            	   256:          sta  WORK
00:AD95 A532            	   257:          lda  T+1
00:AD97 8538            	   258:          sta  WORK+1
00:AD99 A209            	   259:          ldx  #9         ; show 9 bytes on stack, namely 3 variables
00:AD9B 202DAE          	   260:          jsr  display_x_characters
00:AD9E 202892          	   261:          jsr  CROUT
00:ADA1 A952            	   262:          lda  #<DM2       ; ' Base:  '
00:ADA3 A2AD            	   263:          ldx  #>DM2
00:ADA5 202682          	   264:          jsr  print
00:ADA8 A53C            	   265:          lda  BASE+1
00:ADAA 209D92          	   266:          jsr  PRBYTE      ; display the base pointer address
00:ADAD A53B            	   267:          lda  BASE
00:ADAF 203D92          	   268:          jsr  DISHX
00:ADB2 A93D            	   269:          lda  #'='
00:ADB4 20AF93          	   270:          jsr  COUT
00:ADB7 A53B            	   271:          lda  BASE
00:ADB9 38              	   272:          sec
00:ADBA E906            	   273:          sbc  #6    ; the linkage data is 6 bytes below the base
00:ADBC 8537            	   274:          sta  WORK
00:ADBE A53C            	   275:          lda  BASE+1
00:ADC0 E900            	   276:          sbc  #0
00:ADC2 8538            	   277:          sta  WORK+1
00:ADC4 A206            	   278:          ldx  #6    ; show 6 bytes of base linkage data (return, dynamic link, static link)
00:ADC6 202DAE          	   279:          jsr  display_x_characters
00:ADC9 4C2892          	   280:          jmp  CROUT
                        	   281: 
00:ADCC 60              	   282: DEBUG_DONE rts
                        	   283: 
                        	   284: 
                        	   285: ;***********************************************
                        	   286: ; Interpreter initialization
                        	   287: ;***********************************************
                        	   288: 
                        	   289: INTERP   =  *
00:ADCD 08              	   290:   php
00:ADCE 68              	   291:   pla
00:ADCF 8513            	   292:   sta  call_p   ; make sure call_p has some reasonable value in it
                        	   293: ;
                        	   294: ;  Move the start of where the P-codes start into PCODE (our first P-code)
                        	   295: ;
00:ADD1 A525            	   296:   lda  ACT_PCDA
00:ADD3 8523            	   297:   sta  PCODE
00:ADD5 A526            	   298:   lda  ACT_PCDA+1
00:ADD7 8524            	   299:   sta  PCODE+1
                        	   300: ;
                        	   301: ;  Running message
                        	   302: ;
00:ADD9 A95B            	   303:   lda  #<running_message   ; Running
00:ADDB A2AD            	   304:   ldx  #>running_message
00:ADDD 202682          	   305:   jsr  print
                        	   306: ;
                        	   307: ;  Running flag
                        	   308: ;
00:ADE0 A00C            	   309:   ldy  #$0C
00:ADE2 843F            	   310:   sty  RUNNING
                        	   311: ;
                        	   312: ;  Set up the runtime stack pointer which is also our first stack frame base
                        	   313: ;
00:ADE4 A9FF            	   314:   lda  #<HIGHEST_RAM
00:ADE6 8531            	   315:   sta  T
00:ADE8 853B            	   316:   sta  BASE
00:ADEA A93F            	   317:   lda  #>HIGHEST_RAM
00:ADEC 8532            	   318:   sta  T+1
00:ADEE 853C            	   319:   sta  BASE+1
                        	   320: 
00:ADF0 4CDEAE          	   321:   jmp  MAIN ; start interpreting
                        	   322: ;
                        	   323: ;
                        	   324: ;
                        	   325: 
                        	   326: 
                        	   327: ;***********************************************
                        	   328: ;  INTERPRETER
                        	   329: ;***********************************************
                        	   330: 
                        	   331: ;
                        	   332: ;
00:ADF3 496C6C6567616C20	   333: DM5      asciiz  "Illegal instruction\n"
00:ADFB 696E737472756374
00:AE03 696F6E0A
00:AE07 00
00:AE08 427265616B202E2E	   334: DM6      asciiz  'Break ...\n'
00:AE10 2E0A
00:AE12 00
00:AE13 4572726F72206F63	   335: DM7      asciiz  "Error occurred at P-code "
00:AE1B 6375727265642061
00:AE23 7420502D636F6465
00:AE2B 20
00:AE2C 00
                        	   336: 
                        	   337: ;
                        	   338: ; DISPLAY (X) CHARACTERS FROM (WORK)
                        	   339: ;
                        	   340: display_x_characters:
00:AE2D 8A              	   341:          txa
00:AE2E 48              	   342:          pha
00:AE2F 20B392          	   343:          jsr  PUTSP
00:AE32 68              	   344:          pla
00:AE33 AA              	   345:          tax
00:AE34 A000            	   346: DIS5     ldy  #0
00:AE36 B137            	   347:          lda  (WORK),Y
00:AE38 E637            	   348:          inc  WORK
00:AE3A D002            	   349:          bne  DIS5_A
00:AE3C E638            	   350:          inc  WORK+1
                        	   351: DIS5_A   =  *
00:AE3E A8              	   352:          tay
00:AE3F 8A              	   353:          txa
00:AE40 48              	   354:          pha
00:AE41 98              	   355:          tya
00:AE42 203D92          	   356:          jsr  DISHX
00:AE45 68              	   357:          pla
00:AE46 AA              	   358:          tax
00:AE47 CA              	   359:          dex
00:AE48 D0EA            	   360:          bne  DIS5
00:AE4A 60              	   361:          rts
                        	   362: 
                        	   363: ;
                        	   364: ; Ding a bell - however we don't have it on this board
                        	   365: ;
                        	   366: BELL1    =  *
00:AE4B 48              	   367:          pha
00:AE4C A900            	   368:          lda  #0
00:AE4E 853F            	   369:          sta  RUNNING
00:AE50 202892          	   370:          jsr  CROUT
00:AE53 68              	   371:          pla
00:AE54 60              	   372:          rts
                        	   373: ;
                        	   374: ;
00:AE55 204BAE          	   375: RUNERR   jsr  BELL1
00:AE58 A913            	   376:          lda  #<DM7  ; Error occurred at P-code
00:AE5A A2AE            	   377:          ldx  #>DM7
00:AE5C 202682          	   378:          jsr  print
00:AE5F A54E            	   379:          lda  LASTP+1
00:AE61 209D92          	   380:          jsr  PRBYTE
00:AE64 A54D            	   381:          lda  LASTP
00:AE66 203D92          	   382:          jsr  DISHX
                        	   383: EX_FINISHD  =  *
00:AE69 A900            	   384:          lda  #0
00:AE6B 202892          	   385:          jsr  CROUT
00:AE6E A980            	   386:          lda  #<FIN_MSG
00:AE70 A2AE            	   387:          ldx  #>FIN_MSG
00:AE72 202682          	   388:          jsr  print
00:AE75 648B            	   389:          stz  serial_in_byte_received  ; get rid of read-ahead
00:AE77 2079C8          	   390:          jsr  GETIN      ; wait till message seen
00:AE7A 202892          	   391:          jsr  CROUT      ; output a newline in case they press space or something
00:AE7D 4C58CF          	   392:          jmp  RESTART
                        	   393: ;
00:AE80 52756E2066696E69	   394: FIN_MSG  asciiz  'Run finished - press a key ...'
00:AE88 73686564202D2070
00:AE90 726573732061206B
00:AE98 6579202E2E2E
00:AE9E 00
                        	   395: ;
                        	   396: ;
                        	   397: CHK_KBD  =  *
00:AE9F C90E            	   398:          cmp  #KEY_STOP_TRACE       ; Ctrl+N - stop tracing
00:AEA1 D008            	   399:          bne  CHK_NOTN
00:AEA3 648B            	   400:          stz  serial_in_byte_received
00:AEA5 A900            	   401:          lda  #0
00:AEA7 8549            	   402:          sta  DBGFLG
00:AEA9 38              	   403:          sec
00:AEAA 60              	   404:          rts
00:AEAB C914            	   405: CHK_NOTN cmp  #KEY_TRACE      ; Ctrl+T - start tracing
00:AEAD D00A            	   406:          bne  CHK_NOTT
00:AEAF 648B            	   407:          stz  serial_in_byte_received
00:AEB1 A980            	   408:          lda  #$80
00:AEB3 8549            	   409:          sta  DBGFLG
00:AEB5 852E            	   410:          sta  DCODE
00:AEB7 38              	   411:          sec
00:AEB8 60              	   412:          rts
00:AEB9 C904            	   413: CHK_NOTT cmp  #KEY_DEBUG      ; Ctrl+D - start debugging
00:AEBB D00A            	   414:          bne  CHK_NOTD
00:AEBD 648B            	   415:          stz  serial_in_byte_received
00:AEBF A901            	   416:          lda  #1
00:AEC1 8549            	   417:          sta  DBGFLG
00:AEC3 852E            	   418:          sta  DCODE
00:AEC5 38              	   419:          sec
00:AEC6 60              	   420:          rts
00:AEC7 18              	   421: CHK_NOTD clc
00:AEC8 60              	   422:          rts
                        	   423: ;
                        	   424: EX_OUTCR    =  *
00:AEC9 202892          	   425:   jsr  CROUT      ; OUTPUT C/R
00:AECC 4CDEAE          	   426:   jmp  MAIN
                        	   427: ;
                        	   428: ;  Here for a "low literal" - a P-code with the 0x80 bit set. Clear that bit and push
                        	   429: ;   the resulting number onto the stack
                        	   430: ;
                        	   431: LOWLIT:
00:AECF E623            	   432:   inc  PCODE     ; increment P-code past the low literal
00:AED1 D002            	   433:   bne  LOWLIT1
00:AED3 E624            	   434:   inc  PCODE+1
                        	   435: LOWLIT1:
00:AED5 8401            	   436:   sty  REG+1     ; Y and REGB were cleared below
00:AED7 297F            	   437:   and  #$7F
00:AED9 8500            	   438:   sta  REG
                        	   439: ;
                        	   440: ;  fall down to push this value
                        	   441: ;
                        	   442: 
                        	   443: 
                        	   444: ;
                        	   445: ; Push previous result (REG) and then drop down to do the next instruction
                        	   446: ;
                        	   447: MAINP:
00:AEDB 20BBAF          	   448:  jsr  PSHTOP    ; push REG onto stack and go back to MAIN
                        	   449: 
                        	   450: ;
                        	   451: ;  Main interpreter loop - each instruction jumps back here (or to MAINP above if it
                        	   452: ;              needs to push a previous calculation result)
                        	   453: ;
                        	   454: MAIN:
00:AEDE A549            	   455:   lda  DBGFLG   ; debugging?
00:AEE0 F003            	   456:   beq  MAIN_2   ; no
00:AEE2 2064AD          	   457:   jsr  DEBUG    ; yes - show debug info
                        	   458: MAIN_2   =  *
                        	   459: ; check if key pressed here, to abort, or turn on/off tracing or debugging
00:AEE5 A58B            	   460:   lda  serial_in_byte_received
00:AEE7 F00A            	   461:   beq  MAIN_OK
00:AEE9 C903            	   462:   cmp  #KEY_ABORT
00:AEEB D003            	   463:   bne  MAIN_NOT_ABORT
00:AEED 4C69AE          	   464:   jmp  EX_FINISHD
                        	   465: MAIN_NOT_ABORT = *
00:AEF0 209FAE          	   466:   jsr  CHK_KBD          ; check for turning on trace, debug, etc.
                        	   467: MAIN_OK  =  *
00:AEF3 A523            	   468:   lda  PCODE             ; save P-code address as LASTP (for errors I presume)
00:AEF5 854D            	   469:   sta  LASTP
00:AEF7 A524            	   470:   lda  PCODE+1
00:AEF9 854E            	   471:   sta  LASTP+1
                        	   472: ;
                        	   473: ;  now grab the P-code
                        	   474: ;
00:AEFB A000            	   475:   ldy  #0
00:AEFD 8402            	   476:   sty  REGB
00:AEFF B123            	   477:   lda  (PCODE),Y         ; get the P-code from the P-codes
00:AF01 30CC            	   478:   bmi  LOWLIT            ; low literal - just handle it
00:AF03 C946            	   479:   cmp  #PCODE_LAST+1
00:AF05 B015            	   480:   bcs  EX_INVINS         ; error if off end of table
                        	   481: ;
                        	   482: ;  increment past this P-code
                        	   483: ;
                        	   484: MAIN_5   =  *
00:AF07 E623            	   485:   inc  PCODE
00:AF09 D002            	   486:   bne  MAIN_1
00:AF0B E624            	   487:   inc  PCODE+1
                        	   488: ;
                        	   489: ;  grab the execution handler from the execution_address_table
                        	   490: ;
                        	   491: MAIN_1   =  *
00:AF0D 0A              	   492:   asl  A             ; double the P-code because each address takes 2 bytes
00:AF0E AA              	   493:   tax
00:AF0F BDBDAC          	   494:   lda  execution_address_table,X      ; otherwise get the execution address
00:AF12 8537            	   495:   sta  WORK
00:AF14 BDBEAC          	   496:   lda  execution_address_table+1,X    ; and the high-order byte
00:AF17 8538            	   497:   sta  WORK+1
00:AF19 6C3700          	   498:   jmp  (WORK)        ; execute the appropriate P-code implementation routine
                        	   499: 
                        	   500: ;
                        	   501: NOTIMP   =  *
                        	   502: EX_INVINS   =  *
00:AF1C A9F3            	   503:          LDA  #<DM5   ; Illegal Instruction
00:AF1E A2AD            	   504:          LDX  #>DM5
                        	   505: NOTIM1   =  *
00:AF20 202682          	   506:          JSR  print
00:AF23 4C55AE          	   507:          JMP  RUNERR
                        	   508: ;
                        	   509: BREAK    =  *
00:AF26 A908            	   510:          LDA  #<DM6  ; Break ...
00:AF28 A2AE            	   511:          LDX  #>DM6
00:AF2A 4C20AF          	   512:          JMP  NOTIM1
                        	   513: 
                        	   514: 
00:AF2D A000            	   515: GETADR   LDY  #0
00:AF2F B123            	   516:          LDA  (PCODE),Y     ; level
00:AF31 854B            	   517:          STA  COUNT1        ; count of levels to work through
00:AF33 A53C            	   518:          LDA  BASE+1        ; start with our stack base address
00:AF35 A63B            	   519:          LDX  BASE
                        	   520: GET2     =  *
00:AF37 853E            	   521:          STA  DATA+1        ; our data is relative to the stack base
00:AF39 863D            	   522:          STX  DATA
00:AF3B A8              	   523:          TAY
00:AF3C A54B            	   524:          LDA  COUNT1        ; any levels left?
00:AF3E F018            	   525:          BEQ  GETADR1       ; no, we can continue
00:AF40 38              	   526:          SEC                ; yes
00:AF41 8A              	   527:          TXA                ; subtract 2 from the base to get the static link
00:AF42 E902            	   528:          SBC  #2
00:AF44 8537            	   529:          STA  WORK
00:AF46 98              	   530:          TYA
00:AF47 E900            	   531:          SBC  #0
00:AF49 8538            	   532:          STA  WORK+1        ; BASE - 2 -> WORK
00:AF4B A000            	   533:          LDY  #0
00:AF4D B137            	   534:          LDA  (WORK),Y      ; grab contents of BASE-2
00:AF4F C8              	   535:          INY
00:AF50 AA              	   536:          TAX
00:AF51 B137            	   537:          LDA  (WORK),Y
00:AF53 C64B            	   538:          DEC  COUNT1        ; one less level
00:AF55 4C37AF          	   539:          JMP  GET2          ; keep going until we used all levels
                        	   540: 
                        	   541: GETADR1     =  *
00:AF58 A001            	   542:          LDY  #1            ; now get the offset
00:AF5A 18              	   543:          CLC
00:AF5B B123            	   544:          LDA  (PCODE),Y     ; offset low-order byte
00:AF5D 653D            	   545:          ADC  DATA          ; add base
00:AF5F 853D            	   546:          STA  DATA
00:AF61 C8              	   547:          INY
00:AF62 B123            	   548:          LDA  (PCODE),Y     ; offset high-order byte
00:AF64 653E            	   549:          ADC  DATA+1        ; add base
00:AF66 853E            	   550:          STA  DATA+1        ; DATA now holds the data address
00:AF68 A523            	   551:          LDA  PCODE         ; add 3 to PCODE to skip level and offset
00:AF6A 18              	   552:          CLC
00:AF6B 6903            	   553:          ADC  #3
00:AF6D 8523            	   554:          STA  PCODE
00:AF6F 9002            	   555:          BCC  GET1_A
00:AF71 E624            	   556:          INC  PCODE+1
                        	   557: GET1_A   =  *
00:AF73 60              	   558:          RTS                ; done - we can use DATA to access whatever-it-is
                        	   559: 
                        	   560: ;
                        	   561: ;  Pull the top item on the runtime stack into REG (aka VALUE)
                        	   562: ;
                        	   563: PULTOP   =  *
00:AF74 A000            	   564:          LDY  #0
00:AF76 B131            	   565:          LDA  (T),Y
00:AF78 8500            	   566:          STA  REG
00:AF7A C8              	   567:          INY
00:AF7B B131            	   568:          LDA  (T),Y
00:AF7D 8501            	   569:          STA  REG+1
00:AF7F C8              	   570:          INY
00:AF80 B131            	   571:          LDA  (T),Y
00:AF82 8502            	   572:          STA  REGB
00:AF84 A531            	   573:          LDA  T
00:AF86 18              	   574:          CLC      ; add 3 to the stack because we removed one integer from it
00:AF87 6903            	   575:          ADC  #3
00:AF89 8531            	   576:          STA  T
00:AF8B 9002            	   577:          BCC  PUL_END
00:AF8D E632            	   578:          INC  T+1
                        	   579: PUL_END  =  *
00:AF8F A500            	   580:          LDA  REG
00:AF91 A601            	   581:          LDX  REG+1
00:AF93 A402            	   582:          LDY  REGB
00:AF95 60              	   583:          RTS
                        	   584: 
00:AF96 2074AF          	   585: PULBOTH  JSR  PULTOP     ; Pulls both of them - do one and then fall through to do the other
                        	   586: 
                        	   587: ;
                        	   588: ;  Pull the top item on the runtime stack into REG2 (aka VALUE2)
                        	   589: ;
                        	   590: PULTOP2  =  *
00:AF99 A000            	   591:          LDY  #0
00:AF9B B131            	   592:          LDA  (T),Y
00:AF9D 8503            	   593:          STA  REG2
00:AF9F C8              	   594:          INY
00:AFA0 B131            	   595:          LDA  (T),Y
00:AFA2 8504            	   596:          STA  REG2+1
00:AFA4 C8              	   597:          INY
00:AFA5 B131            	   598:          LDA  (T),Y
00:AFA7 8505            	   599:          STA  REG2B
00:AFA9 A531            	   600:          LDA  T
00:AFAB 18              	   601:          CLC         ; add 3 to the stack because we removed one integer from it
00:AFAC 6903            	   602:          ADC  #3
00:AFAE 8531            	   603:          STA  T
00:AFB0 9002            	   604:          BCC  PUL2_END
00:AFB2 E632            	   605:          INC  T+1
                        	   606: PUL2_END =  *
00:AFB4 A503            	   607:          LDA  REG2
00:AFB6 A604            	   608:          LDX  REG2+1
00:AFB8 A405            	   609:          LDY  REG2B
00:AFBA 60              	   610:          RTS
                        	   611: 
                        	   612: ;
                        	   613: ;  Push REG (aka VALUE) onto the runtime stack
                        	   614: ;
                        	   615: PSHTOP   =  *
00:AFBB 38              	   616:          SEC        ;  subtract 3 from the stack because we are about to add one integer to it
00:AFBC A531            	   617:          LDA  T
00:AFBE E903            	   618:          SBC  #3
00:AFC0 8531            	   619:          STA  T
00:AFC2 B002            	   620:          BCS  PSH1
00:AFC4 C632            	   621:          DEC  T+1
                        	   622: PSH1     =  *
00:AFC6 A000            	   623:          LDY  #0
00:AFC8 A500            	   624:          LDA  REG
00:AFCA 9131            	   625:          STA  (T),Y
00:AFCC C8              	   626:          INY
00:AFCD A501            	   627:          LDA  REG+1
00:AFCF 9131            	   628:          STA  (T),Y
00:AFD1 C8              	   629:          INY
00:AFD2 A502            	   630:          LDA  REGB
00:AFD4 9131            	   631:          STA  (T),Y
00:AFD6 60              	   632:          RTS
                        	   633: ;
                        	   634: ;  get a literal (2 bytes) from the P-codes and put it into REG
                        	   635: ;
                        	   636: GETLIT   =  *
00:AFD7 A000            	   637:   ldy  #0
00:AFD9 B123            	   638:   lda  (PCODE),Y
00:AFDB 8500            	   639:   sta  REG
00:AFDD C8              	   640:   iny
00:AFDE B123            	   641:   lda  (PCODE),Y
00:AFE0 8501            	   642:   sta  REG+1
00:AFE2 A523            	   643:   lda  PCODE
00:AFE4 18              	   644:   clc         ; P-code address goes up by 2
00:AFE5 6902            	   645:   adc  #2
00:AFE7 8523            	   646:   sta  PCODE
00:AFE9 9002            	   647:   bcc  GET_END
00:AFEB E624            	   648:   inc  PCODE+1
                        	   649: GET_END:
00:AFED 60              	   650:   rts
                        	   651: ;
                        	   652: ; load literal onto the stack (the literal is the next 3 bytes after the P-code)
                        	   653: ;
                        	   654: EX_LIT:
00:AFEE 20D7AF          	   655:   jsr  GETLIT   ; get the first 2 bytes
00:AFF1 A000            	   656:   ldy  #0
00:AFF3 B123            	   657:   lda  (PCODE),Y    ; now the third byte
00:AFF5 8502            	   658:   sta  REGB
00:AFF7 E623            	   659:   inc  PCODE
00:AFF9 D002            	   660:   bne  LIT1
00:AFFB E624            	   661:   inc  PCODE+1
                        	   662: LIT1:
00:AFFD 4CDBAE          	   663:   jmp  MAINP    ; now we can push it
                        	   664: ;
                        	   665: ;  Negate (0 - (sp) )
                        	   666: ;
                        	   667: EX_NEG:
00:B000 2074AF          	   668:   jsr PULTOP
00:B003 208DAB          	   669:   jsr exp_unary_minus
00:B006 4CDBAE          	   670:   jmp MAINP
                        	   671: ;
                        	   672: ;  Add (sp) to (sp -1)
                        	   673: ;
                        	   674: EX_ADD:
00:B009 2096AF          	   675:   JSR  PULBOTH
00:B00C 2046AA          	   676:   jsr  exp_add
00:B00F 4CDBAE          	   677:   JMP  MAINP
                        	   678: ;
                        	   679: ;
                        	   680: ;  Add (sp) from (sp - 1)
                        	   681: ;
                        	   682: EX_SUB:
00:B012 2099AF          	   683:   JSR  PULTOP2
00:B015 2074AF          	   684:   jsr  PULTOP
00:B018 205AAA          	   685:   jsr  exp_subtract
00:B01B 4CDBAE          	   686:   JMP  MAINP
                        	   687: ;
                        	   688: ;  Multiply (sp) by (sp - 1)
                        	   689: ;
                        	   690: EX_MUL:
00:B01E 2096AF          	   691:   jsr PULBOTH
00:B021 2014AC          	   692:   jsr exp_multiply
00:B024 4CDBAE          	   693:   jmp MAINP
                        	   694: 
                        	   695: ;
                        	   696: ;  we will take the current key (and return to the user)
                        	   697: ;  and zero it out anyway, so that consumes the key
                        	   698: ;
                        	   699: EX_GETKEY   =  *
00:B027 A58B            	   700:   lda  serial_in_byte_received
00:B029 648B            	   701:   stz  serial_in_byte_received
00:B02B 4C81B0          	   702:   jmp  TRUE2
                        	   703: ;
                        	   704: ;  Modulus (remainder)
                        	   705: ;
                        	   706: EX_MOD:
00:B02E 2099AF          	   707:   jsr PULTOP2
                        	   708: ;
                        	   709: ;  check for divide by zero because I want a run-time error message
                        	   710: ;
00:B031 A503            	   711:   lda VALUE2
00:B033 0504            	   712:   ora VALUE2+1
00:B035 0505            	   713:   ora VALUE2+2
00:B037 F009            	   714:   beq EX_DIVIDE_BY_ZERO
00:B039 2074AF          	   715:   jsr PULTOP
00:B03C 20ADAC          	   716:   jsr exp_modulo
00:B03F 4CDBAE          	   717:   jmp MAINP
                        	   718: ;
                        	   719: 
                        	   720: EX_DIVIDE_BY_ZERO:
00:B042 A949            	   721:   lda  #<DIVBY0
00:B044 A2B0            	   722:   ldx  #>DIVBY0
00:B046 4C20AF          	   723:   jmp  NOTIM1
                        	   724: 
00:B049 4469766964652062	   725: DIVBY0   asciiz  'Divide by zero\n'
00:B051 79207A65726F0A
00:B058 00
                        	   726: ;
                        	   727: ;  Divide (sp - 1) by (sp)
                        	   728: ;
                        	   729: EX_DIV:
00:B059 2099AF          	   730:   jsr PULTOP2
00:B05C A503            	   731:   lda VALUE2
00:B05E 0504            	   732:   ora VALUE2+1
00:B060 0505            	   733:   ora VALUE2+2
00:B062 F0DE            	   734:   beq EX_DIVIDE_BY_ZERO
00:B064 2074AF          	   735:   jsr PULTOP
00:B067 204DAC          	   736:   jsr exp_divide
00:B06A 4CDBAE          	   737:   jmp MAINP
                        	   738: 
                        	   739: ;
                        	   740: ;  Absolute value of (sp)
                        	   741: ;
                        	   742: EX_ABS:
00:B06D 2074AF          	   743:   jsr  PULTOP
00:B070 20AFAB          	   744:   jsr exp_abs_val
00:B073 4CDBAE          	   745:   jmp  MAINP
                        	   746: 
                        	   747: ; Equal
                        	   748: ;
                        	   749: EX_EQL:
00:B076 2096AF          	   750:   jsr PULBOTH
00:B079 2080AA          	   751:   jsr exp_eql
00:B07C 4CDBAE          	   752:   jmp MAINP
                        	   753: 
                        	   754: ;
                        	   755: ;  Push 1
                        	   756: ;
                        	   757: TRUE:
00:B07F A901            	   758:   lda  #1
                        	   759: ;
                        	   760: ;  Push A into low-order byte, zero other two bytes
                        	   761: ;
                        	   762: TRUE2:
00:B081 8500            	   763:   sta  REG
00:B083 A900            	   764:   lda  #0
00:B085 8501            	   765:   sta  REG+1
00:B087 8502            	   766:   sta  REGB
00:B089 4CDBAE          	   767:   jmp  MAINP
                        	   768: 
                        	   769: ;
                        	   770: ;  Push 0
                        	   771: ;
                        	   772: FALSE:
00:B08C A900            	   773:   lda  #0
00:B08E 80F1            	   774:   bra TRUE2
                        	   775: ;
                        	   776: ;  Not equal
                        	   777: ;
                        	   778: EX_NEQ:
00:B090 2096AF          	   779:     jsr PULBOTH
00:B093 2094AA          	   780:     jsr exp_neq
00:B096 4CDBAE          	   781:     jmp MAINP
                        	   782: 
                        	   783: ;
                        	   784: ;  Less than
                        	   785: ;
                        	   786: EX_LSS:
00:B099 2099AF          	   787:   jsr PULTOP2
00:B09C 2074AF          	   788:   jsr PULTOP
00:B09F 20A8AA          	   789:   jsr exp_less_than
00:B0A2 4CDBAE          	   790:   jmp MAINP
                        	   791: 
                        	   792: ;
                        	   793: ;  Greater than
                        	   794: ;
                        	   795: EX_GTR:
00:B0A5 2099AF          	   796:   jsr PULTOP2
00:B0A8 2074AF          	   797:   jsr PULTOP
00:B0AB 20AFAA          	   798:   jsr exp_greater_than
00:B0AE 4CDBAE          	   799:   jmp MAINP
                        	   800: 
                        	   801: ;
                        	   802: ;  Greater than or equal
                        	   803: ;
                        	   804: EX_GEQ:
00:B0B1 2099AF          	   805:   jsr PULTOP2
00:B0B4 2074AF          	   806:   jsr PULTOP
00:B0B7 20CDAA          	   807:   jsr exp_geq
00:B0BA 4CDBAE          	   808:   jmp MAINP
                        	   809: 
                        	   810: ;
                        	   811: ;  Less than or equal
                        	   812: ;
                        	   813: EX_LEQ:
00:B0BD 2099AF          	   814:   jsr PULTOP2
00:B0C0 2074AF          	   815:   jsr PULTOP
00:B0C3 20BEAA          	   816:   jsr exp_leq
00:B0C6 4CDBAE          	   817:   jmp MAINP
                        	   818: 
                        	   819: ;
                        	   820: ;  Exclusive OR
                        	   821: ;
                        	   822: EX_XOR:
00:B0C9 2096AF          	   823:   jsr PULBOTH
00:B0CC 20FEAA          	   824:   jsr exp_bitwise_xor
00:B0CF 4CDBAE          	   825:   jmp MAINP
                        	   826: ;
                        	   827: ;  Or
                        	   828: ;
                        	   829: EX_ORR:
00:B0D2 2096AF          	   830:   jsr PULBOTH
00:B0D5 20D4AA          	   831:   jsr exp_bitwise_or
00:B0D8 4CDBAE          	   832:   jmp MAINP
                        	   833: 
                        	   834: ;
                        	   835: ;  And
                        	   836: ;
                        	   837: EX_AND:
00:B0DB 2096AF          	   838:   jsr  PULBOTH
00:B0DE 20E9AA          	   839:   jsr exp_bitwise_and
00:B0E1 4CDBAE          	   840:   jmp MAINP
                        	   841: 
                        	   842: ;
                        	   843: ;  Not
                        	   844: ;
                        	   845: EX_EOR:
00:B0E4 2074AF          	   846:   jsr PULTOP
00:B0E7 207FAB          	   847:   jsr exp_not
00:B0EA 4CDBAE          	   848:   jmp MAINP
                        	   849: ;
                        	   850: ; Shift left
                        	   851: ;
                        	   852: EX_SHL:
00:B0ED 2099AF          	   853:   jsr PULTOP2
00:B0F0 2074AF          	   854:   jsr PULTOP
00:B0F3 203AAB          	   855:   jsr exp_shift_left
00:B0F6 4CDBAE          	   856:   jmp MAINP
                        	   857: 
                        	   858: ;
                        	   859: ;  Shift right
                        	   860: ;
                        	   861: EX_SHR:
00:B0F9 2099AF          	   862:   jsr PULTOP2
00:B0FC 2074AF          	   863:   jsr PULTOP
00:B0FF 2053AB          	   864:   jsr exp_shift_right
00:B102 4CDBAE          	   865:   jmp MAINP
                        	   866: 
                        	   867: ;
                        	   868: ;  increment number on top of stack by one
                        	   869: ;
                        	   870: EX_INC:
00:B105 18              	   871:   clc
00:B106 B131            	   872:   lda  (T),Y
00:B108 6901            	   873:   adc  #1
00:B10A 9131            	   874:   sta  (T),Y
00:B10C C8              	   875:   iny
00:B10D B131            	   876:   lda  (T),Y
00:B10F 6900            	   877:   adc  #0
00:B111 9131            	   878:   sta  (T),Y
00:B113 C8              	   879:   iny
00:B114 B131            	   880:   lda  (T),Y
00:B116 6900            	   881:   adc  #0
00:B118 9131            	   882:   sta  (T),Y
00:B11A 4CDEAE          	   883:   jmp  MAIN
                        	   884: ;
                        	   885: ;  decrement number on top of stack by one
                        	   886: ;
                        	   887: 
                        	   888: EX_DEC:
00:B11D 38              	   889:   sec
00:B11E B131            	   890:   lda  (T),Y
00:B120 E901            	   891:   sbc  #1
00:B122 9131            	   892:   sta  (T),Y
00:B124 C8              	   893:   iny
00:B125 B131            	   894:   lda  (T),Y
00:B127 E900            	   895:   sbc  #0
00:B129 9131            	   896:   sta  (T),Y
00:B12B C8              	   897:   iny
00:B12C B131            	   898:   lda  (T),Y
00:B12E E900            	   899:   sbc  #0
00:B130 9131            	   900:   sta  (T),Y
00:B132 4CDEAE          	   901:   jmp  MAIN
                        	   902: 
                        	   903: ;
                        	   904: ;  Copy (sp) to (sp + 1)
                        	   905: ;
                        	   906: EX_MOV:
00:B135 B131            	   907:   lda  (T),Y  ; get item at top of stack
00:B137 8500            	   908:   sta REG
00:B139 C8              	   909:   iny
00:B13A B131            	   910:   lda  (T),Y
00:B13C 8501            	   911:   sta REG+1
00:B13E C8              	   912:   iny
00:B13F B131            	   913:   lda  (T),Y
00:B141 8502            	   914:   sta REGB
00:B143 4CDBAE          	   915:   jmp MAINP   ; push it
                        	   916: 
                        	   917: ;
                        	   918: ;  Load a single-character value (variable) onto the stack
                        	   919: ;
                        	   920: 
                        	   921: EX_LODC:
00:B146 202DAF          	   922:   jsr  GETADR
                        	   923: EX_LOD3:
00:B149 A002            	   924:   ldy  #2
                        	   925: EX_LOD3_A:
00:B14B A900            	   926:   lda  #0      ; since this is a character zero out the high-order bytes
00:B14D 8501            	   927:   sta  REG+1
00:B14F 8502            	   928:   sta  REGB
00:B151 B13D            	   929:   lda  (DATA),Y  ; (DATA) contains the lower-order byte
00:B153 8500            	   930:   sta  REG       ; REG will be pushed
00:B155 4CDBAE          	   931:   jmp  MAINP     ; push REG and go to MAIN
                        	   932: ;
                        	   933: ;  Load a 3-byte value (variable) onto the stack
                        	   934: ;
                        	   935: EX_LOD:
00:B158 202DAF          	   936:   jsr  GETADR
                        	   937: EX_LOD2:
00:B15B A000            	   938:   ldy  #0
00:B15D B13D            	   939:   lda  (DATA),Y    ; (DATA) contains the variable value
00:B15F 8500            	   940:   sta  REG
00:B161 C8              	   941:   iny
00:B162 B13D            	   942:   lda  (DATA),Y
00:B164 8501            	   943:   sta  REG+1
00:B166 C8              	   944:   iny
00:B167 B13D            	   945:   lda  (DATA),Y
00:B169 8502            	   946:   sta REGB
00:B16B 4CDBAE          	   947:   jmp MAINP   ; push it
                        	   948: 
                        	   949: ;
                        	   950: ;  Load absolute address character
                        	   951: ;
                        	   952: EX_LDAC:
00:B16E 2074AF          	   953:   jsr  PULTOP
00:B171 853D            	   954:   sta  DATA
00:B173 863E            	   955:   stx  DATA+1
00:B175 A000            	   956:   ldy  #0
00:B177 F0D2            	   957:   beq  EX_LOD3_A
                        	   958: ;
                        	   959: ;  Load absolute address integer
                        	   960: ;
                        	   961: EX_LDA:
00:B179 2074AF          	   962:   jsr  PULTOP
00:B17C 853D            	   963:   sta  DATA
00:B17E 863E            	   964:   stx  DATA+1
00:B180 4C5BB1          	   965:   jmp  EX_LOD2
                        	   966: ;
                        	   967: ;  Get address of indexed character
                        	   968: ;
                        	   969: GETIDC:
00:B183 2099AF          	   970:   jsr  PULTOP2    ; pull index into REG2
00:B186 202DAF          	   971:   jsr  GETADR
00:B189 4CA0B1          	   972:   jmp  GETID2
                        	   973: ;
                        	   974: ;  Get address of indexed integer
                        	   975: ;
                        	   976: GETIDX   =  *
00:B18C 2099AF          	   977:   jsr  PULTOP2  ; pull index into REG2
00:B18F 0603            	   978:   asl  REG2     ; now multiply by 3
00:B191 2604            	   979:   rol  REG2+1
00:B193 18              	   980:   clc
00:B194 6503            	   981:   adc  REG2
00:B196 8503            	   982:   sta  REG2
00:B198 8A              	   983:   txa
00:B199 6504            	   984:   adc  REG2+1
00:B19B 8504            	   985:   sta  REG2+1     ; TIMES 3
00:B19D 202DAF          	   986:   jsr  GETADR
                        	   987: ;
                        	   988: ;  Get address of indexed integer/character
                        	   989: ;
                        	   990: ;  It looks like arrays expand downwards
                        	   991: ;
                        	   992: GETID2:
00:B1A0 A53D            	   993:   lda  DATA     ; initial address
00:B1A2 38              	   994:   sec           ; subtract subscript
00:B1A3 E503            	   995:   sbc  REG2
00:B1A5 853D            	   996:   sta  DATA
00:B1A7 A53E            	   997:   lda  DATA+1
00:B1A9 E504            	   998:   sbc  REG2+1
00:B1AB 853E            	   999:   sta  DATA+1
00:B1AD 60              	  1000:   rts
                        	  1001: ;
                        	  1002: ;  Load indexed character
                        	  1003: ;
                        	  1004: EX_LDIC:
00:B1AE 2083B1          	  1005:   jsr  GETIDC
00:B1B1 4C49B1          	  1006:   jmp  EX_LOD3
                        	  1007: ;
                        	  1008: ;  Load indexed integer
                        	  1009: ;
                        	  1010: EX_LDI:
00:B1B4 208CB1          	  1011:   jsr  GETIDX
00:B1B7 4C5BB1          	  1012:   jmp  EX_LOD2
                        	  1013: ;
                        	  1014: ;  Store character
                        	  1015: ;
                        	  1016: EX_STOC:
00:B1BA 202DAF          	  1017:   jsr  GETADR
00:B1BD 2074AF          	  1018:   jsr  PULTOP
00:B1C0 A002            	  1019:   ldy  #2   ; why?
                        	  1020: EX_STO5:
00:B1C2 913D            	  1021:   sta  (DATA),Y
00:B1C4 4CDEAE          	  1022:   jmp  MAIN
                        	  1023: ;
                        	  1024: ;  Store integer
                        	  1025: ;
                        	  1026: EX_STO:
00:B1C7 202DAF          	  1027:   jsr  GETADR   ; get its address
00:B1CA 2074AF          	  1028:   jsr  PULTOP   ; get the value to store
                        	  1029: EX_STO2:
00:B1CD A000            	  1030:   ldy  #0
00:B1CF 913D            	  1031:   sta  (DATA),Y
00:B1D1 C8              	  1032:   iny
00:B1D2 8A              	  1033:   txa
00:B1D3 913D            	  1034:   sta  (DATA),Y
00:B1D5 A502            	  1035:   lda  REGB
00:B1D7 C8              	  1036:   iny
00:B1D8 D0E8            	  1037:   bne  EX_STO5
                        	  1038: ;
                        	  1039: ;  Store integer at absolute address
                        	  1040: ;
                        	  1041: EX_STA:
00:B1DA 2096AF          	  1042:   jsr  PULBOTH  ; get address into REG2 and value into REG
00:B1DD A000            	  1043:   ldy  #0
00:B1DF A500            	  1044:   lda  REG
00:B1E1 9103            	  1045:   sta  (REG2),Y
00:B1E3 C8              	  1046:   iny
00:B1E4 A501            	  1047:   lda  REG+1
00:B1E6 9103            	  1048:   sta  (REG2),Y
00:B1E8 C8              	  1049:   iny
00:B1E9 A502            	  1050:   lda  REGB
                        	  1051: EX_STA5:
00:B1EB 9103            	  1052:   sta  (REG2),Y
00:B1ED 4CDEAE          	  1053:   jmp  MAIN
                        	  1054: ;
                        	  1055: ;  Store character at absolute address
                        	  1056: ;
                        	  1057: EX_STAC:
00:B1F0 2096AF          	  1058:   jsr  PULBOTH  ; get address into REG2 and value into REG
00:B1F3 A500            	  1059:   lda  REG
00:B1F5 A000            	  1060:   ldy  #0
00:B1F7 F0F2            	  1061:   beq  EX_STA5
                        	  1062: ;
                        	  1063: ;   	Store character indexed
                        	  1064: ;
                        	  1065: EX_STIC:
00:B1F9 2074AF          	  1066:   jsr  PULTOP
00:B1FC 8545            	  1067:   sta  TEMP
00:B1FE 2083B1          	  1068:   jsr  GETIDC
00:B201 A545            	  1069:   lda  TEMP
00:B203 A002            	  1070:   ldy  #2
00:B205 D0BB            	  1071:   bne  EX_STO5
                        	  1072: ;
                        	  1073: ;   	Store integer indexed
                        	  1074: ;
                        	  1075: EX_STI :
00:B207 2074AF          	  1076:   jsr  PULTOP
00:B20A 8545            	  1077:   sta  TEMP
00:B20C 8646            	  1078:   stx  TEMP+1
00:B20E 98              	  1079:   tya
00:B20F 48              	  1080:   pha
00:B210 208CB1          	  1081:   jsr  GETIDX
00:B213 A000            	  1082:   ldy  #0
00:B215 A545            	  1083:   lda  TEMP
00:B217 913D            	  1084:   sta  (DATA),Y
00:B219 A546            	  1085:   lda  TEMP+1
00:B21B C8              	  1086:   iny
00:B21C 913D            	  1087:   sta  (DATA),Y
00:B21E 68              	  1088:   pla
00:B21F C8              	  1089:   iny
00:B220 D0A0            	  1090:   bne  EX_STO5
                        	  1091: ;
                        	  1092: ;  Procedure/function return
                        	  1093: ;
                        	  1094: ;  Stack frame linkage data:
                        	  1095: ;
                        	  1096: ;    (from low to high address)
                        	  1097: ;
                        	  1098: ;    Return address <-- P-code to return to when function/procedure exits
                        	  1099: ;    Dynamic link   <-- The previous stack frame from the earlier function call
                        	  1100: ;    Static link    <-- The stack frame of the previous static function
                        	  1101: ;
                        	  1102: ;  Static and dynamic links will be the same except for recursive calls.
                        	  1103: ;
                        	  1104: ;  To unwind the stack we have to go back to the previous dynamic link (on a return)
                        	  1105: ;
                        	  1106: ;  However to find variables in previous lexical declarations we have to use the static link.
                        	  1107: ;
                        	  1108: ;
                        	  1109: EX_RTN:
                        	  1110: ;
                        	  1111: ;  Subtract 6 from the base address, put result into WORK
                        	  1112: ;
00:B222 38              	  1113:   sec
00:B223 A53B            	  1114:   lda  BASE
00:B225 E906            	  1115:   sbc  #6
00:B227 8537            	  1116:   sta  WORK
00:B229 A53C            	  1117:   lda  BASE+1
00:B22B E900            	  1118:   sbc  #0
00:B22D 8538            	  1119:   sta  WORK+1
                        	  1120: ;
                        	  1121: ;  The return address was at the bottom of BASE, so put that into PCODE
                        	  1122: ;
00:B22F A000            	  1123:   ldy  #0
00:B231 B137            	  1124:   lda  (WORK),Y
00:B233 8523            	  1125:   sta  PCODE
00:B235 C8              	  1126:   iny
00:B236 B137            	  1127:   lda  (WORK),Y
00:B238 8524            	  1128:   sta  PCODE+1
                        	  1129: 
                        	  1130: ;
                        	  1131: ;  The base address becomes our new top of runtime stack
                        	  1132: ;
00:B23A A53C            	  1133:   lda  BASE+1
00:B23C 8532            	  1134:   sta  T+1
00:B23E A53B            	  1135:   lda  BASE
00:B240 8531            	  1136:   sta  T
                        	  1137: ;
                        	  1138: ;  The dynamic stack frame address is 4 bytes down from the BASE - put that into WORK
                        	  1139: ;
00:B242 38              	  1140:   sec
00:B243 E904            	  1141:   sbc  #4
00:B245 8537            	  1142:   sta  WORK
00:B247 A53C            	  1143:   lda  BASE+1
00:B249 E900            	  1144:   sbc  #0
00:B24B 8538            	  1145:   sta  WORK+1
                        	  1146: ;
                        	  1147: ;  Get the previous dynamic stack frame address and put it into BASE (in case of
                        	  1148: ;   recursive function calls)
                        	  1149: ;
00:B24D A000            	  1150:   ldy  #0
00:B24F B137            	  1151:   lda  (WORK),Y
00:B251 853B            	  1152:   sta  BASE
00:B253 C8              	  1153:   iny
00:B254 B137            	  1154:   lda  (WORK),Y
00:B256 853C            	  1155:   sta  BASE+1
                        	  1156: ;
                        	  1157: ;  Stack, base and Pcode all changed, ready for next instruction
                        	  1158: ;
00:B258 4CDEAE          	  1159:   jmp  MAIN
                        	  1160: 
                        	  1161: ;
                        	  1162: ; Input a number into a variable
                        	  1163: ;
                        	  1164: EX_INP      =  *
00:B25B A980            	  1165:   lda #$80
00:B25D 853F            	  1166:   sta  RUNNING
00:B25F 208793          	  1167:   JSR  GET_LINE
00:B262 AD0002          	  1168:   lda  INBUF
00:B265 C903            	  1169:   cmp  #KEY_ABORT   ; check for aborting with Ctrl+C
00:B267 D003            	  1170:   bne  EX_INP_OK
00:B269 4CB6B4          	  1171:   jmp  ex_input_aborted
                        	  1172: 
                        	  1173: EX_INP_OK:
00:B26C A900            	  1174:   lda #<INBUF
00:B26E 858E            	  1175:   sta token_start
00:B270 A902            	  1176:   lda #>INBUF
00:B272 858F            	  1177:   sta token_start+1
00:B274 6493            	  1178:   stz token_type
00:B276 20F5C8          	  1179:   jsr get_token
00:B279 C94E            	  1180:   cmp #TOKEN_NUMBER
00:B27B D016            	  1181:   bne BAD_INP
00:B27D A694            	  1182:   LDX  token_value
00:B27F A495            	  1183:   LDY  token_value+1
00:B281 A596            	  1184:   LDA  token_value+2
                        	  1185: INP3:
00:B283 8401            	  1186:   sty  REG+1
00:B285 8600            	  1187:   stx  REG
00:B287 8502            	  1188:   sta  REGB
00:B289 20BBAF          	  1189:   jsr  PSHTOP
00:B28C A20C            	  1190:   ldx  #12
00:B28E 863F            	  1191:   stx  RUNNING
00:B290 4CDEAE          	  1192:   jmp  MAIN
                        	  1193: ;
                        	  1194: ;  bad number: set it to $800000
                        	  1195: ;
                        	  1196: BAD_INP:
00:B293 A980            	  1197:   lda #$80
00:B295 A200            	  1198:   ldx #0
00:B297 A000            	  1199:   ldy #0
00:B299 F0E8            	  1200:   beq INP3
                        	  1201: ;
                        	  1202: ; write a number to output
                        	  1203: ;
                        	  1204: EX_OUT:
00:B29B 2063C8          	  1205:   jsr write_to_serial
00:B29E 8003            	  1206:   bra OUT_COMMON
                        	  1207: 
                        	  1208: EX_LCD_WRITE_NUM:
00:B2A0 206EC8          	  1209:   jsr write_to_lcd
                        	  1210: 
                        	  1211: OUT_COMMON:
00:B2A3 2074AF          	  1212:   jsr  PULTOP
00:B2A6 205291          	  1213:   jsr  display_in_decimal
00:B2A9 2063C8          	  1214:   jsr  write_to_serial
00:B2AC 4CDEAE          	  1215:   jmp  MAIN
                        	  1216: ;
                        	  1217: ;
                        	  1218: ; Output 6 hex characters (3 bytes)
                        	  1219: ;
                        	  1220: EX_OUH:
00:B2AF 2063C8          	  1221:   jsr write_to_serial
00:B2B2 8003            	  1222:   bra EX_OUH_COMMON
                        	  1223: 
                        	  1224: EX_LCD_WRITE_HEX:
00:B2B4 206EC8          	  1225:   jsr write_to_lcd
                        	  1226: 
                        	  1227: EX_OUH_COMMON:
00:B2B7 2074AF          	  1228:   jsr  PULTOP
00:B2BA A502            	  1229:   lda  REGB
00:B2BC 209D92          	  1230:   jsr  PRBYTE
00:B2BF A501            	  1231:   lda  REG+1
00:B2C1 209D92          	  1232:   jsr  PRBYTE
00:B2C4 A500            	  1233:   lda  REG
00:B2C6 209D92          	  1234:   jsr  PRBYTE
00:B2C9 2063C8          	  1235:   jsr  write_to_serial
00:B2CC 4CDEAE          	  1236:   jmp  MAIN
                        	  1237: ;
                        	  1238: ;  write a string to output
                        	  1239: ;
                        	  1240: EX_OUS      =  *
00:B2CF 2063C8          	  1241:   jsr write_to_serial
00:B2D2 8003            	  1242:   bra EX_OUS_COMMON
                        	  1243: 
                        	  1244: EX_LCD_WRITE_STR:
00:B2D4 206EC8          	  1245:   jsr write_to_lcd
                        	  1246: 
                        	  1247: EX_OUS_COMMON:
00:B2D7 A523            	  1248:   lda  PCODE
00:B2D9 18              	  1249:   clc
00:B2DA 6901            	  1250:   adc  #1
00:B2DC 8537            	  1251:   sta  WORK
00:B2DE A524            	  1252:   lda  PCODE+1
00:B2E0 6900            	  1253:   adc  #0
00:B2E2 8538            	  1254:   sta  WORK+1
00:B2E4 B123            	  1255:   lda  (PCODE),Y
00:B2E6 854B            	  1256:   sta  COUNT1     ; NO. OF CHARS
00:B2E8 18              	  1257:   clc
00:B2E9 6901            	  1258:   adc  #1
00:B2EB 6523            	  1259:   adc  PCODE
00:B2ED 8523            	  1260:   sta  PCODE
00:B2EF 9002            	  1261:   bcc  EX_OUS1
00:B2F1 E624            	  1262:   inc  PCODE+1
                        	  1263: EX_OUS1:
00:B2F3 A537            	  1264:   lda  WORK
00:B2F5 A638            	  1265:   ldx  WORK+1
00:B2F7 A44B            	  1266:   ldy  COUNT1
00:B2F9 20B792          	  1267:   jsr  PT
00:B2FC 2063C8          	  1268:   jsr write_to_serial
00:B2FF 4CDEAE          	  1269:   jmp  MAIN
                        	  1270: 
                        	  1271: 
                        	  1272: 
                        	  1273: ;
                        	  1274: ;  Stack frame linkage data:
                        	  1275: ;
                        	  1276: ;    (from low to high address)
                        	  1277: ;
                        	  1278: ;    Return address <-- P-code to return to when function/procedure exits
                        	  1279: ;    Dynamic link   <-- The previous stack frame from the earlier function call
                        	  1280: ;    Static link    <-- The stack frame of the previous static function
                        	  1281: ;
                        	  1282: ;  Static and dynamic links will be the same except for recursive calls.
                        	  1283: ;
                        	  1284: ;  To unwind the stack we have to go back to the previous dynamic link (on a return)
                        	  1285: ;
                        	  1286: ;  However to find variables in previous lexical declarations we have to use the static link.
                        	  1287: ;
                        	  1288: ;
                        	  1289: ; Call absolute procedure - I don't think this is used in this version TBH
                        	  1290: ;
                        	  1291: ; Note: Y is zero when entering
                        	  1292: ;
                        	  1293: EX_ABSCLL   =  *
00:B302 8447            	  1294:   sty  CALL      ; zero out address to be called
00:B304 8448            	  1295:   sty  CALL+1    ; (offset therefore becomes absolute address)
00:B306 4C11B3          	  1296:   jmp  EX_CLL_A
                        	  1297: ;
                        	  1298: ; Call relative procedure
                        	  1299: ;
                        	  1300: ; Note: Y is zero when entering
                        	  1301: ;
                        	  1302: EX_CLL      =  *
00:B309 A54D            	  1303:   lda  LASTP
00:B30B 8547            	  1304:   sta  CALL
00:B30D A54E            	  1305:   lda  LASTP+1
00:B30F 8548            	  1306:   sta  CALL+1
                        	  1307: EX_CLL_A    =  *
00:B311 B123            	  1308:   lda  (PCODE),Y     ; level
00:B313 854B            	  1309:   sta  COUNT1
00:B315 C8              	  1310:   iny
00:B316 18              	  1311:   clc
00:B317 B123            	  1312:   lda  (PCODE),Y     ; relative address
00:B319 6547            	  1313:   adc  CALL          ; add to current P-code address
00:B31B 8547            	  1314:   sta  CALL
00:B31D C8              	  1315:   iny
00:B31E B123            	  1316:   lda  (PCODE),Y
00:B320 6548            	  1317:   adc  CALL+1
00:B322 8548            	  1318:   sta  CALL+1
00:B324 A523            	  1319:   lda  PCODE         ; add 3 to P-code to bypass level / address
00:B326 18              	  1320:   clc                ; this will become our return address
00:B327 6903            	  1321:   adc  #3
00:B329 8523            	  1322:   sta  PCODE
00:B32B 9002            	  1323:   bcc  EX_CLL4
00:B32D E624            	  1324:   inc  PCODE+1
                        	  1325: EX_CLL4     =  *
00:B32F A53C            	  1326:   lda  BASE+1
00:B331 A63B            	  1327:   ldx  BASE
                        	  1328: EX_CLL2     =  *
00:B333 853E            	  1329:   sta  DATA+1      ; this was BASE
00:B335 863D            	  1330:   stx  DATA
00:B337 A8              	  1331:   tay
00:B338 A54B            	  1332:   lda  COUNT1      ; this was the level
00:B33A F018            	  1333:   beq  EX_CLL3
00:B33C 38              	  1334:   sec
00:B33D 8A              	  1335:   txa
00:B33E E902            	  1336:   sbc  #2          ; subtract 2 from BASE, store in WORK
00:B340 8537            	  1337:   sta  WORK
00:B342 98              	  1338:   tya
00:B343 E900            	  1339:   sbc  #0
00:B345 8538            	  1340:   sta  WORK+1
00:B347 A000            	  1341:   ldy  #0
00:B349 B137            	  1342:   lda  (WORK),Y
00:B34B C8              	  1343:   iny
00:B34C AA              	  1344:   tax
00:B34D B137            	  1345:   lda  (WORK),Y
00:B34F C64B            	  1346:   dec  COUNT1
00:B351 4C33B3          	  1347:   jmp  EX_CLL2
                        	  1348: EX_CLL3     =  *
00:B354 A531            	  1349:   lda  T         ; our stack pointer
00:B356 8545            	  1350:   sta  TEMP      ; save it
00:B358 A532            	  1351:   lda  T+1
00:B35A 8546            	  1352:   sta  TEMP+1
                        	  1353: ;
                        	  1354: ; this is as confusing as all-get-out but it looks like we
                        	  1355: ; are pushing onto the stack: DATA / BASE / PCODE (return address)
                        	  1356: ;  (which is why we saved T into TEMP so it didn't change during the pushes)
                        	  1357: ;
                        	  1358: 
00:B35C A53D            	  1359:   lda  DATA      ; put DATA into REG
00:B35E 8501            	  1360:   sta  REG+1
00:B360 A53E            	  1361:   lda  DATA+1
00:B362 8502            	  1362:   sta  REGB
00:B364 A53C            	  1363:   lda  BASE+1
00:B366 8500            	  1364:   sta  REG
00:B368 20BBAF          	  1365:   jsr  PSHTOP      ; push REG (DATA + BASE[1])
00:B36B A53B            	  1366:   lda  BASE
00:B36D 8502            	  1367:   sta  REGB
00:B36F A545            	  1368:   lda  TEMP        ; old stack pointer
00:B371 853B            	  1369:   sta  BASE        ; becomes BASE
00:B373 A546            	  1370:   lda  TEMP+1      ; ditto for other byte
00:B375 853C            	  1371:   sta  BASE+1
00:B377 A523            	  1372:   lda  PCODE       ; get ready to push current P-Code
00:B379 8500            	  1373:   sta  REG
00:B37B A524            	  1374:   lda  PCODE+1
00:B37D 8501            	  1375:   sta  REG+1
00:B37F 20BBAF          	  1376:   jsr  PSHTOP     ; push REG (BASE[0] + PCODE)
00:B382 A547            	  1377:   lda  CALL       ; now get the address of the place we want to call
00:B384 8523            	  1378:   sta  PCODE      ; and put it into PCODE
00:B386 A548            	  1379:   lda  CALL+1
00:B388 8524            	  1380:   sta  PCODE+1
00:B38A 18              	  1381:   clc             ; add 6 to the stack pointer because we later emit the code to INT 6 (leave room for base stuff)
00:B38B A531            	  1382:   lda  T
00:B38D 6906            	  1383:   adc  #6
00:B38F 8531            	  1384:   sta  T
00:B391 9002            	  1385:   bcc  EX_CLL5
00:B393 E632            	  1386:   inc  T+1
                        	  1387: EX_CLL5     =  *
00:B395 4CDEAE          	  1388:   jmp  MAIN        ; we are done, MAIN will now go to the called subroutine
                        	  1389: ;
                        	  1390: ;  Here for calling machine code from Pascal
                        	  1391: ;
                        	  1392: EX_CLA:
00:B398 2074AF          	  1393:   jsr  PULTOP      ; pull the address to be called from the stack
00:B39B A513            	  1394:   lda  call_p      ; status register
00:B39D 48              	  1395:   pha
00:B39E A510            	  1396:   lda  call_a      ; A register
00:B3A0 A611            	  1397:   ldx  call_x      ; X register
00:B3A2 A412            	  1398:   ldy  call_y      ; Y register
00:B3A4 28              	  1399:   plp              ; get status register back
00:B3A5 20B5B3          	  1400:   jsr  EX_CLL_JMP  ; call the subroutine
00:B3A8 08              	  1401:   php              ; save the status register
00:B3A9 8510            	  1402:   sta  call_a      ; store the A/X/Y register
00:B3AB 8611            	  1403:   stx  call_x
00:B3AD 8412            	  1404:   sty  call_y
00:B3AF 68              	  1405:   pla              ; get status register back
00:B3B0 8513            	  1406:   sta  call_p      ; save it
00:B3B2 4CDEAE          	  1407:   jmp  MAIN        ; done!
                        	  1408: 
00:B3B5 6C0000          	  1409: EX_CLL_JMP  jmp  (REG)
                        	  1410: ;
                        	  1411: ;
                        	  1412: ; increment stack pointer (that is, subtract the literal from it, as it grows downwards)
                        	  1413: ;
                        	  1414: EX_INT:
00:B3B8 20D7AF          	  1415:   jsr  GETLIT
00:B3BB 38              	  1416:   sec
00:B3BC A531            	  1417:   lda  T
00:B3BE E500            	  1418:   sbc  REG
00:B3C0 8531            	  1419:   sta  T
00:B3C2 A532            	  1420:   lda  T+1
00:B3C4 E501            	  1421:   sbc  REG+1
00:B3C6 8532            	  1422:   sta  T+1
00:B3C8 C544            	  1423:   cmp  END_PCD+1
00:B3CA 9003            	  1424:   bcc  INT_ERR
00:B3CC 4CDEAE          	  1425:   jmp  MAIN
                        	  1426: ;
                        	  1427: INT_ERR  =  *
00:B3CF A9D6            	  1428:   lda  #<INT_ERRM    ; stack full
00:B3D1 A2B3            	  1429:   ldx  #>INT_ERRM
00:B3D3 4C20AF          	  1430:   jmp  NOTIM1
                        	  1431: ;
00:B3D6 537461636B206675	  1432: INT_ERRM asciiz "Stack full\n"    ; stack full
00:B3DE 6C6C0A
00:B3E1 00
                        	  1433: ;
                        	  1434: 
                        	  1435: ;
                        	  1436: ;  Change the runtime stack to the address given (assuming stack is empty)
                        	  1437: ;   Done by the {%S nnnn} compiler directive.
                        	  1438: ;
                        	  1439: EX_NEW_STACK:
00:B3E2 20D7AF          	  1440:   jsr GETLIT
00:B3E5 A500            	  1441:   lda REG
00:B3E7 8531            	  1442:   sta T
00:B3E9 853B            	  1443:   sta BASE
00:B3EB A501            	  1444:   lda REG+1
00:B3ED 8532            	  1445:   sta T+1
00:B3EF 853C            	  1446:   sta BASE+1
00:B3F1 4CDEAE          	  1447:   jmp MAIN
                        	  1448: 
                        	  1449: ;
                        	  1450: ;  Jump to the address following the P-code
                        	  1451: ;
                        	  1452: EX_JMP:
00:B3F4 20D7AF          	  1453:   jsr  GETLIT   ; get the address
00:B3F7 18              	  1454:   clc
00:B3F8 A500            	  1455:   lda  REG
00:B3FA 654D            	  1456:   adc  LASTP
00:B3FC 8523            	  1457:   sta  PCODE
00:B3FE A501            	  1458:   lda  REG+1
00:B400 654E            	  1459:   adc  LASTP+1
00:B402 8524            	  1460:   sta  PCODE+1
00:B404 4CDEAE          	  1461:   jmp  MAIN
                        	  1462: ;
                        	  1463: ;  Jump if the top of the stack is zero
                        	  1464: ;
                        	  1465: EX_JMZ:
00:B407 2074AF          	  1466:   jsr  PULTOP   ; puts REG into A
00:B40A 0501            	  1467:   ora  REG+1
00:B40C 0502            	  1468:   ora  REGB
00:B40E D002            	  1469:   bne  EX_NOJUMP
00:B410 F0E2            	  1470:   beq  EX_JMP
                        	  1471: ;
                        	  1472: ;  Don't jump, just move past the address (TODO: just add 2?)
                        	  1473: ;
                        	  1474: EX_NOJUMP:
00:B412 20D7AF          	  1475:   jsr  GETLIT
00:B415 4CDEAE          	  1476:   jmp  MAIN
                        	  1477: ;
                        	  1478: ;  Jump if the top of the stack is non-zero
                        	  1479: ;
                        	  1480: EX_JM1:
00:B418 2074AF          	  1481:   jsr  PULTOP    ; puts REG into A
00:B41B 0501            	  1482:   ora  REG+1
00:B41D 0502            	  1483:   ora  REGB
00:B41F D0D3            	  1484:   bne  EX_JMP
00:B421 F0EF            	  1485:   beq  EX_NOJUMP
                        	  1486: ;
                        	  1487: ;
                        	  1488: EX_INPC:
00:B423 2079C8          	  1489:   jsr GETIN
00:B426 C903            	  1490:   cmp  #KEY_ABORT   ; check for aborting with Ctrl+C
00:B428 D003            	  1491:   bne  EX_INPC_OK
00:B42A 4CB6B4          	  1492:   jmp  ex_input_aborted
                        	  1493: 
                        	  1494: EX_INPC_OK:
00:B42D 209FAE          	  1495:   jsr CHK_KBD
00:B430 B0F1            	  1496:   bcs EX_INPC
00:B432 8500            	  1497:   sta REG
00:B434 A900            	  1498:   lda #0
00:B436 8501            	  1499:   sta REG+1
00:B438 8502            	  1500:   sta REGB
00:B43A 4CDBAE          	  1501:   jmp  MAINP
                        	  1502: ;
                        	  1503: EX_OUTC:
00:B43D 2063C8          	  1504:   jsr write_to_serial
00:B440 8003            	  1505:   bra EX_OUTC_COMMON
                        	  1506: 
                        	  1507: EX_LCD_WRITE_CHR:
00:B442 206EC8          	  1508:   jsr write_to_lcd
                        	  1509: 
                        	  1510: EX_OUTC_COMMON:
00:B445 2074AF          	  1511:   jsr  PULTOP
00:B448 A500            	  1512:   lda  REG
00:B44A 20AF93          	  1513:   jsr  COUT
00:B44D 2063C8          	  1514:   jsr write_to_serial
00:B450 4CDEAE          	  1515:   jmp  MAIN
                        	  1516:   ;
                        	  1517: 
                        	  1518: EX_LCDHOME:
00:B453 2061B8          	  1519:   jsr lcd_home
00:B456 4CDEAE          	  1520:   JMP MAIN
                        	  1521: 
                        	  1522: 
                        	  1523: EX_LCDCLEAR:
00:B459 2051B8          	  1524:   jsr lcd_clear_display
00:B45C 4CDEAE          	  1525:   JMP MAIN
                        	  1526: 
                        	  1527: EX_INS      =  *
00:B45F B123            	  1528:   lda  (PCODE),Y   ; wanted length
00:B461 8545            	  1529:   sta  TEMP
00:B463 E623            	  1530:   inc  PCODE
00:B465 D002            	  1531:   bne  EX_INS3
00:B467 E624            	  1532:   inc  PCODE+1
                        	  1533: EX_INS3     =  *
00:B469 208793          	  1534:   jsr  GET_LINE
00:B46C AD0002          	  1535:   lda  INBUF
00:B46F C903            	  1536:   cmp  #KEY_ABORT     ; check for them aborting the run on input
00:B471 F043            	  1537:   beq  ex_input_aborted
00:B473 209FAE          	  1538:   jsr  CHK_KBD
00:B476 B0F1            	  1539:   bcs  EX_INS3      ; we turned on/off tracing etc, ignore this line
00:B478 98              	  1540:   tya               ; length of line
00:B479 18              	  1541:   clc
00:B47A 6901            	  1542:   adc  #1        ; why?
00:B47C C545            	  1543:   cmp  TEMP
00:B47E 9002            	  1544:   bcc  EX_INS1
00:B480 A545            	  1545:   lda  TEMP      ; use max allowed length rather than received length
                        	  1546: EX_INS1     =  *
00:B482 8546            	  1547:   sta  TEMP+1    ; this is the length we are copying
00:B484 202DAF          	  1548:   jsr  GETADR    ; get address to put the line
00:B487 A003            	  1549:   ldy  #3        ; why?
00:B489 A200            	  1550:   ldx  #0
                        	  1551: ;
                        	  1552: ;  copying loop - arrays are stored downwards, so we subtract from DATA each time
                        	  1553: ;
                        	  1554: EX_INS2     =  *
00:B48B C63D            	  1555:   dec  DATA
00:B48D A53D            	  1556:   lda  DATA
00:B48F C9FF            	  1557:   cmp  #$FF
00:B491 D002            	  1558:   bne  EX_INS4
00:B493 C63E            	  1559:   dec  DATA+1
                        	  1560: EX_INS4     =  *
00:B495 BD0002          	  1561:   lda  INBUF,X
00:B498 913D            	  1562:   sta  (DATA),Y
00:B49A E8              	  1563:   inx
00:B49B C646            	  1564:   dec  TEMP+1      ; count of bytes to copy
00:B49D D0EC            	  1565:   bne  EX_INS2
00:B49F 4CDEAE          	  1566:   jmp  MAIN        ; stop now
                        	  1567:   ;
                        	  1568: 
00:B4A2 0A45786563757469	  1569: execution_aborted_message asciiz "\nExecution aborted\n"
00:B4AA 6F6E2061626F7274
00:B4B2 65640A
00:B4B5 00
                        	  1570: 
                        	  1571: ex_input_aborted:
00:B4B6 A9A2            	  1572:   lda #<execution_aborted_message
00:B4B8 A2B4            	  1573:   ldx #>execution_aborted_message
00:B4BA 4C20AF          	  1574:   jmp NOTIM1
                        	  1575: ;
                        	  1576: ;
                        	  1577: EX_ADRNC    =  *
00:B4BD 202DAF          	  1578:   jsr  GETADR
                        	  1579: EX_ADRNC2   =  *
00:B4C0 A53D            	  1580:   lda  DATA
00:B4C2 18              	  1581:   clc
00:B4C3 6902            	  1582:   adc  #2
00:B4C5 853D            	  1583:   sta  DATA
00:B4C7 9007            	  1584:   bcc  EX_ADRN2
00:B4C9 E63E            	  1585:   inc  DATA+1
00:B4CB B003            	  1586:   bcs  EX_ADRN2
                        	  1587: EX_ADRNN    =  *
00:B4CD 202DAF          	  1588:   jsr  GETADR
                        	  1589: EX_ADRN2    =  *
00:B4D0 A53D            	  1590:   lda  DATA
00:B4D2 8500            	  1591:   sta  REG
00:B4D4 A53E            	  1592:   lda  DATA+1
00:B4D6 8501            	  1593:   sta  REG+1
00:B4D8 4CDBAE          	  1594:   jmp  MAINP
                        	  1595: ;
                        	  1596: EX_ADRAN    =  *
00:B4DB 208CB1          	  1597:   jsr  GETIDX
00:B4DE 4CD0B4          	  1598:   jmp  EX_ADRN2
                        	  1599: ;
                        	  1600: EX_ADRAC    =  *
00:B4E1 2083B1          	  1601:    jsr  GETIDC
00:B4E4 4CC0B4          	  1602:    jmp  EX_ADRNC2
                        	  1603: ;
                        	  1604: ;
                        	  1605: ;
                        	  1606: 
                        	  1607: 
                        	  1608: ;
                        	  1609: ;  DIGITALREAD (pin) pin:0 to 15; pushes 0 or 1
                        	  1610: ;
                        	  1611: EX_DIGITALREAD = *
00:B4E7 2074AF          	  1612:   jsr PULTOP  ; which pin
00:B4EA 2046C8          	  1613:   jsr digitalread
00:B4ED D003            	  1614:   bne EX_DIGITALREAD_ONE
00:B4EF 4C8CB0          	  1615:   jmp FALSE
                        	  1616: EX_DIGITALREAD_ONE:
00:B4F2 4C7FB0          	  1617:   jmp TRUE    ; done
                        	  1618: 
                        	  1619: ;
                        	  1620: ;  LCDPOS (line, column)
                        	  1621: ;
                        	  1622: 
                        	  1623: EX_LCDPOS = *
00:B4F5 2074AF          	  1624:   jsr PULTOP   ; x
00:B4F8 290F            	  1625:   and #$0F     ; max 15
00:B4FA 858C            	  1626:   sta hardware_work  ; save it
00:B4FC 2074AF          	  1627:   jsr PULTOP   ; y
00:B4FF 2901            	  1628:   and #1       ; can be 0 or 1
00:B501 D002            	  1629:   bne EX_LCDPOS_1
00:B503 A940            	  1630:   lda #$40
                        	  1631: EX_LCDPOS_1:
00:B505 058C            	  1632:   ora hardware_work  ; or in the column
00:B507 0980            	  1633:   ora #$80     ; command to set the address
00:B509 20FDB7          	  1634:   jsr lcd_instruction
00:B50C 4CDEAE          	  1635:   jmp MAIN
                        	  1636: 
                        	  1637: ;
                        	  1638: ;  RANDOM
                        	  1639: ;
                        	  1640: EX_RANDOM:
00:B50F 20DA8F          	  1641:   jsr gen_random
00:B512 A509            	  1642:   lda random
00:B514 8500            	  1643:   sta REG
00:B516 A50A            	  1644:   lda random+1
00:B518 8501            	  1645:   sta REG+1
00:B51A A50B            	  1646:   lda random+2
00:B51C 8502            	  1647:   sta REGB
00:B51E 4CDBAE          	  1648:   jmp MAINP
                        	  1649: 
                        	  1650: 
                        	  1651: ;
                        	  1652: ;  LATENCY
                        	  1653: ;
                        	  1654: EX_LATENCY:
00:B521 A50D            	  1655:   lda typing_latency
00:B523 8500            	  1656:   sta REG
00:B525 A50E            	  1657:   lda typing_latency+1
00:B527 8501            	  1658:   sta REG+1
00:B529 A50F            	  1659:   lda typing_latency+2
00:B52B 8502            	  1660:   sta REGB
00:B52D 4CDBAE          	  1661:   jmp MAINP
                        	  1662: 
                        	  1663: ; PULTOP puts stuff here thus:
                        	  1664: ;
                        	  1665: ;        LDA  REG
                        	  1666: ;        LDX  REG+1
                        	  1667: ;        LDY  REGB
                        	  1668: 
                        	  1669: EX_DELAY = *
00:B530 2074AF          	  1670:   JSR  PULTOP  ; get the time interval in ms
                        	  1671:   ; (Y = high-order byte, X = lo-order byte)
00:B533 A600            	  1672:   ldx REG
00:B535 A501            	  1673:   lda REG+1
00:B537 297F            	  1674:   and #$7F
00:B539 A8              	  1675:   tay
00:B53A 20D590          	  1676:   jsr delay
00:B53D 4CDEAE          	  1677:   jmp MAIN
                        	  1678: 
                        	  1679: ;
                        	  1680: ;  RANDOMSEED
                        	  1681: ;
                        	  1682: EX_RANDOMSEED = *
00:B540 2074AF          	  1683:   JSR  PULTOP  ; get the seed
00:B543 850A            	  1684:   sta random+1
00:B545 860B            	  1685:   stx random+2
00:B547 840C            	  1686:   sty random+3
00:B549 A9FF            	  1687:   lda #$FF     ; ensure seed has some 1 bits
00:B54B 8509            	  1688:   sta random
00:B54D 4CDEAE          	  1689:   jmp MAIN
                        	  1690: 
                        	  1691: ;
                        	  1692: ;  PINMODE (pin, mode) pin:0 to 15; mode: 0=read, 1=write
                        	  1693: ;
                        	  1694: EX_PINMODE = *
00:B550 2074AF          	  1695:   jsr PULTOP  ; the mode
00:B553 AA              	  1696:   tax         ; input or output?
00:B554 DA              	  1697:   phx         ; save the mode
00:B555 2074AF          	  1698:   jsr PULTOP  ; which pin
00:B558 FA              	  1699:   plx         ; get mode back
00:B559 20E8C7          	  1700:   jsr pinmode ; pin in A, mode in X
00:B55C 4CDEAE          	  1701:   jmp MAIN    ; done
                        	  1702: 
                        	  1703: ;
                        	  1704: ;  DIGITALWRITE (pin, value) pin:0 to 15; value: 0 or 1
                        	  1705: ;
                        	  1706: EX_DIGITALWRITE = *
00:B55F 2074AF          	  1707:   jsr PULTOP  ; the value
00:B562 AA              	  1708:   tax         ;
00:B563 DA              	  1709:   phx         ; save the value
00:B564 2074AF          	  1710:   jsr PULTOP  ; which pin
00:B567 FA              	  1711:   plx         ; get mode back
00:B568 2017C8          	  1712:   jsr digitalwrite ; pin in A, value in X
00:B56B 4CDEAE          	  1713:   jmp MAIN    ; done
                        	  1714: 
                        	  1715: EX_LIB_CALL:
00:B56E 20D7AF          	  1716:   JSR  GETLIT
00:B571 6C0000          	  1717:   jmp  (REG)
                        	  1718: 
                        	  1719: ;
                        	  1720: ;  Assert (expression)
                        	  1721: ;
                        	  1722: 
                        	  1723: EX_ASSERT:
00:B574 2074AF          	  1724:   jsr PULTOP  ; the value
00:B577 A500            	  1725:   lda REG
00:B579 0501            	  1726:   ora REG+1
00:B57B 0502            	  1727:   ora REGB
00:B57D D00A            	  1728:   bne EX_ASSERT_OK
00:B57F A91E            	  1729:   lda #<assertion_failed_message  ; "Assertion failed"
00:B581 A297            	  1730:   ldx #>assertion_failed_message
00:B583 202682          	  1731:   jsr print
00:B586 4C55AE          	  1732:   jmp RUNERR
                        	  1733: 
                        	  1734: EX_ASSERT_OK:
00:B589 4CDEAE          	  1735:   jmp MAIN
                        	  1736: 

Source: "gpascal.asm"
                        	   180:   .include "interrupts.inc"

Source: "interrupts.inc"
                        	     1: 
00:B58C 0A42524B20657865	     2: break_message     asciiz "\nBRK executed at address $"
00:B594 6375746564206174
00:B59C 2061646472657373
00:B5A4 2024
00:B5A6 00
00:B5A7 2C2041203D2024  	     3: a_equals_message  asciiz ", A = $"
00:B5AE 00
00:B5AF 2C2058203D2024  	     4: x_equals_message  asciiz ", X = $"
00:B5B6 00
00:B5B7 2C2059203D2024  	     5: y_equals_message  asciiz ", Y = $"
00:B5BE 00
00:B5BF 2C2050203D2024  	     6: p_equals_message  asciiz ", P = $"
00:B5C6 00
00:B5C7 2C2053203D2024  	     7: s_equals_message  asciiz ", S = $"
00:B5CE 00
00:B5CF 2C206964203D2024	     8: id_equals_message asciiz ", id = $"
00:B5D7 00
                        	     9: 
                        	    10: ;--------------------------------------------------
                        	    11: ;  IRQ - here on BRK interrupt
                        	    12: ;--------------------------------------------------
                        	    13: brk_executed:
00:B5D8 8412            	    14:   sty call_y    ; save Y - we didn't touch that
00:B5DA 8614            	    15:   stx call_s    ; X still has the stack pointer in it
00:B5DC FA              	    16:   plx           ; get X back
00:B5DD 8611            	    17:   stx call_x
00:B5DF 68              	    18:   pla           ; get A back
00:B5E0 8510            	    19:   sta call_a    ; save A
00:B5E2 68              	    20:   pla           ; get the processor flags from the stack
00:B5E3 8513            	    21:   sta call_p
00:B5E5 68              	    22:   pla           ; low-order address of BRK
00:B5E6 8515            	    23:   sta brk_address
00:B5E8 68              	    24:   pla           ; high order address of BRK
00:B5E9 8516            	    25:   sta brk_address+1
00:B5EB 58              	    26:   cli           ; allow interrupts now so we can print
                        	    27: 
                        	    28: ;
                        	    29: ;  display BRK info for the user
                        	    30: ;
                        	    31:   ;
                        	    32:   ;  subtract 2 from brk_address to get where it actually was
                        	    33:   ;
00:B5EC 38              	    34:   sec
00:B5ED A515            	    35:   lda brk_address
00:B5EF E902            	    36:   sbc #2
00:B5F1 8515            	    37:   sta brk_address
00:B5F3 A516            	    38:   lda brk_address+1
00:B5F5 E900            	    39:   sbc #0
00:B5F7 8516            	    40:   sta brk_address+1
00:B5F9 A98C            	    41:   lda #<break_message
00:B5FB A2B5            	    42:   ldx #>break_message
00:B5FD 202682          	    43:   jsr print
00:B600 A516            	    44:   lda brk_address+1
00:B602 209D92          	    45:   jsr PRBYTE
00:B605 A515            	    46:   lda brk_address
00:B607 209D92          	    47:   jsr PRBYTE
                        	    48: ;
                        	    49: ;  show A, X, Y, P, S
                        	    50: ;
00:B60A A9A7            	    51:   lda #<a_equals_message
00:B60C A2B5            	    52:   ldx #>a_equals_message
00:B60E 202682          	    53:   jsr print
00:B611 A510            	    54:   lda call_a
00:B613 209D92          	    55:   jsr PRBYTE
00:B616 A9AF            	    56:   lda #<x_equals_message
00:B618 A2B5            	    57:   ldx #>x_equals_message
00:B61A 202682          	    58:   jsr print
00:B61D A511            	    59:   lda call_x
00:B61F 209D92          	    60:   jsr PRBYTE
00:B622 A9B7            	    61:   lda #<y_equals_message
00:B624 A2B5            	    62:   ldx #>y_equals_message
00:B626 202682          	    63:   jsr print
00:B629 A512            	    64:   lda call_y
00:B62B 209D92          	    65:   jsr PRBYTE
00:B62E A9BF            	    66:   lda #<p_equals_message
00:B630 A2B5            	    67:   ldx #>p_equals_message
00:B632 202682          	    68:   jsr print
00:B635 A513            	    69:   lda call_p
00:B637 209D92          	    70:   jsr PRBYTE
00:B63A A9C7            	    71:   lda #<s_equals_message
00:B63C A2B5            	    72:   ldx #>s_equals_message
00:B63E 202682          	    73:   jsr print
00:B641 A514            	    74:   lda call_s
00:B643 209D92          	    75:   jsr PRBYTE
00:B646 A9CF            	    76:   lda #<id_equals_message
00:B648 A2B5            	    77:   ldx #>id_equals_message
00:B64A 202682          	    78:   jsr print
                        	    79: ;
                        	    80: ;  advance one byte to get the break ID (byte after the BRK)
                        	    81: ;
00:B64D E615            	    82:   inc brk_address
00:B64F D002            	    83:   bne brk_executed1
00:B651 E616            	    84:   inc brk_address+1
                        	    85: brk_executed1:
00:B653 A000            	    86:   ldy #0
00:B655 B115            	    87:   lda (brk_address),Y
00:B657 209D92          	    88:   jsr PRBYTE
                        	    89: ;
                        	    90: ;  put brk_address back to where we should resume from
                        	    91: ;
00:B65A E615            	    92:   inc brk_address
00:B65C D002            	    93:   bne brk_executed2
00:B65E E616            	    94:   inc brk_address+1
                        	    95: brk_executed2:
                        	    96: 
00:B660 202892          	    97:   jsr CROUT
                        	    98: ;
                        	    99: ;  display stack
                        	   100: ;
00:B663 A984            	   101:   lda #<stack_message
00:B665 A2B6            	   102:   ldx #>stack_message
00:B667 202682          	   103:   jsr print
00:B66A A514            	   104:   lda call_s
00:B66C 18              	   105:   clc
00:B66D 6906            	   106:   adc #6  ; the interrupt pushed 3 we pushed 2, plus the stack points to the first UNUSED spot
00:B66F AA              	   107:   tax
                        	   108: brk_executed3:
00:B670 BD0001          	   109:   lda $100,x
00:B673 DA              	   110:   phx
00:B674 209D92          	   111:   jsr PRBYTE
00:B677 20B392          	   112:   jsr PUTSP
00:B67A FA              	   113:   plx
00:B67B E8              	   114:   inx
00:B67C D0F2            	   115:   bne brk_executed3
                        	   116: 
                        	   117: ;
                        	   118: ;  we are done now
                        	   119: ;
00:B67E 202892          	   120:   jsr CROUT
00:B681 4CCC82          	   121:   jmp main_prompt
                        	   122: 
00:B684 537461636B3A20  	   123: stack_message asciiz "Stack: "
00:B68B 00
                        	   124: 
00:B68C 4CD8B5          	   125: brk_executedJ jmp brk_executed
                        	   126: 
                        	   127: ;--------------------------------------------------
                        	   128: ;  IRQ - here on maskable interrupt
                        	   129: ;--------------------------------------------------
                        	   130: 
                        	   131: irq:
00:B68F 48              	   132:   pha       ; save A and X
00:B690 DA              	   133:   phx
00:B691 BA              	   134:   tsx       ; get stack pointer
00:B692 E0FB            	   135:   cpx #$FB  ; should be lesss than $FB (since the interrupt pushed 3 and we pushed 2)
00:B694 9006            	   136:   bcc irq1
00:B696 A21B            	   137:   ldx #27   ; ERROR: stack full
00:B698 58              	   138:   cli       ; allow interrupts or error won't print
00:B699 4C6497          	   139:   jmp ERROR
                        	   140: 
                        	   141: irq1:
00:B69C BD0301          	   142:   lda $103,X    ; this will be the processor flags on the stack (3 up from where we are now)
00:B69F 2910            	   143:   and #$10      ; check BRK flag
00:B6A1 D0E9            	   144:   bne brk_executedJ
                        	   145: ;
                        	   146: ;  here for a hardware IRQ
                        	   147: ;
00:B6A3 ADFD7F          	   148:   lda VIA_IFR
00:B6A6 2940            	   149:   and #VIA_FLAG_TIMER1     ; Time out of T1
00:B6A8 D03B            	   150:   bne timer1_interrupt
                        	   151: 
00:B6AA ADFD7F          	   152:   lda VIA_IFR
00:B6AD 2908            	   153:   and #VIA_FLAG_CB2        ; CB2 active edge
00:B6AF D003            	   154:   bne cb2_interrupt
                        	   155: 
00:B6B1 4C14B7          	   156:   jmp irq_done
                        	   157: 
                        	   158: ;
                        	   159: ;  here for incoming start bit
                        	   160: ;
                        	   161: cb2_interrupt:
                        	   162: 
00:B6B4 8DFE7F          	   163:   sta VIA_IER           ; turn off that interrupt
00:B6B7 8DFD7F          	   164:   sta VIA_IFR           ; indicate we noticed it
                        	   165: 
00:B6BA DA              	   166:   phx
00:B6BB 5A              	   167:   phy
                        	   168: 
00:B6BC A208            	   169:   ldx #8              ; count of bits
00:B6BE A020            	   170:   ldy #SERIAL_DELAY1  ; delay interval for first bit (allow for code above) TODO - probably needs to be less now
                        	   171: serial_in_loop:
                        	   172: ;
                        	   173: ; wait for bit time to be up
                        	   174: ;
00:B6C0 88              	   175:   dey
00:B6C1 D0FD            	   176:   bne serial_in_loop
                        	   177: 
                        	   178:   .if SERIAL_DEBUGGING
                        	   179:     lda #SERIAL_DEBUG1_MASK     ; toggle debug flag (2 cycles)
                        	   180:     tsb VIA_PORTA               ; (6 cycles)
                        	   181:     trb VIA_PORTA               ; (6 cycles)
                        	   182:   .else
00:B6C3 EA              	   183:     NOP    ; take the same time so the timing isn't thrown out
00:B6C4 EA              	   184:     NOP    ; 2 cycles each
00:B6C5 EA              	   185:     NOP
00:B6C6 EA              	   186:     NOP
00:B6C7 EA              	   187:     NOP
00:B6C8 EA              	   188:     NOP
00:B6C9 EA              	   189:     NOP    ; total of 14 cycles
                        	   190:   .endif  ; SERIAL_DEBUGGING
                        	   191: 
00:B6CA ADF17F          	   192:   lda VIA_PORTA
00:B6CD 6A              	   193:   ror A                 ; put incoming bit into carry
00:B6CE 668A            	   194:   ror serial_in_byte    ; shift one bit in
00:B6D0 A023            	   195:   ldy #SERIAL_DELAY2    ; delay interval for remaining bits
00:B6D2 CA              	   196:   dex
00:B6D3 D0EB            	   197:   bne serial_in_loop
                        	   198: 
00:B6D5 7A              	   199:   ply
00:B6D6 FA              	   200:   plx
                        	   201: ;
                        	   202: ;  re-enable interrupts on the falling edge
                        	   203: ;
00:B6D7 A988            	   204:   lda #VIA_FLAG_ENABLE | VIA_FLAG_CB2
00:B6D9 8DFE7F          	   205:   sta VIA_IER
00:B6DC 8DFD7F          	   206:   sta VIA_IFR   ; indicate we know about previous falling edges
                        	   207: 
                        	   208: ;
                        	   209: ;  move to place that we know it will be noticed
                        	   210: ;
00:B6DF A58A            	   211:   lda serial_in_byte
00:B6E1 858B            	   212:   sta serial_in_byte_received
                        	   213: 
00:B6E3 802F            	   214:   bra irq_done
                        	   215: 
                        	   216: ;
                        	   217: ;  here for time to send another outgoing bit
                        	   218: ;
                        	   219: timer1_interrupt :
                        	   220: 
00:B6E5 8DFD7F          	   221:   sta VIA_IFR           ; indicate we noticed it
00:B6E8 A589            	   222:   lda serial_out_bit    ; are we in fact sending a byte?
00:B6EA F028            	   223:   beq irq_done          ; no, just exit
                        	   224: 
                        	   225:   .if SERIAL_DEBUGGING
                        	   226: 
                        	   227:   lda #SERIAL_DEBUG2_MASK     ; toggle debug flag (2 cycles)
                        	   228:   tsb VIA_PORTA               ; wash on   (6 cycles)
                        	   229:   trb VIA_PORTA               ; wash off  (6 cycles)
                        	   230:                               ; now, sand the floor
                        	   231:  .else
00:B6EC EA              	   232:      NOP    ; take the same time so the timing isn't thrown out
00:B6ED EA              	   233:      NOP    ; 2 cycles each
00:B6EE EA              	   234:      NOP
00:B6EF EA              	   235:      NOP
00:B6F0 EA              	   236:      NOP
00:B6F1 EA              	   237:      NOP
00:B6F2 EA              	   238:      NOP    ; total of 14 cycles
                        	   239:   .endif  ; SERIAL_DEBUGGING
                        	   240: 
00:B6F3 6688            	   241:   ror serial_out_byte+1  ; we don't care about the high-order bit
00:B6F5 6687            	   242:   ror serial_out_byte    ; get the low-order bit into Carry
00:B6F7 9007            	   243:   bcc write_zero
00:B6F9 A902            	   244:   lda #SERIAL_OUT_MASK   ; (send a 1 bit)
00:B6FB 0DF17F          	   245:   ora VIA_PORTA
00:B6FE 8005            	   246:   bra serial_send_count_bits
                        	   247: 
                        	   248: write_zero:
00:B700 A9FD            	   249:   lda #~SERIAL_OUT_MASK  ; (send a 0 bit)
00:B702 2DF17F          	   250:   and VIA_PORTA
                        	   251: 
                        	   252: serial_send_count_bits:
00:B705 8DF17F          	   253:   sta VIA_PORTA          ; output this bit
00:B708 C689            	   254:   dec serial_out_bit     ; remember bit count for later
00:B70A D008            	   255:   bne irq_done
                        	   256: 
                        	   257: ; here when all bits have been sent
                        	   258: ; disable the timer as we don't need it any more
                        	   259: ; and this will be a flag that we can send another byte
                        	   260: 
00:B70C A940            	   261:   lda #VIA_FLAG_DISABLE | VIA_FLAG_TIMER1  ; cancel interrupt on T1 timeout
00:B70E 8DFE7F          	   262:   sta VIA_IER
00:B711 ADF47F          	   263:   lda VIA_T1C_L     ; clear interrupt flag
                        	   264: 
                        	   265: irq_done:
00:B714 FA              	   266:   plx   ; restore X
00:B715 68              	   267:   pla   ; restore A
00:B716 40              	   268:   rti
                        	   269: 

Source: "gpascal.asm"
                        	   181:   .include "lcd.inc"

Source: "lcd.inc"
                        	     1:   .if !EMULATOR
                        	     2:   .if LCD_SUPPORT
                        	     3: 
                        	     4: ;
                        	     5: ;  LCD stuff
                        	     6: ;
                        	     7: 
                        	     8: lcd_initialise:
                        	     9: ;
                        	    10: ;  LCD initialise
                        	    11: ;
                        	    12: 
00:B717 ADF37F          	    13:   lda VIA_DDRA
00:B71A 09E0            	    14:   ora #(LCD_RW|LCD_RS|LCD_E)    ; set appropriate pins on Port A to output
00:B71C 8DF37F          	    15:   sta VIA_DDRA
                        	    16: 
                        	    17:   ; see HD44780U documentation: "Initializing by Instruction" (page 46)
00:B71F 2098B7          	    18:   jsr lcd_prepare_to_write_instruction
00:B722 A930            	    19:   lda #$30
00:B724 20F1B7          	    20:   jsr lcd_write_instruction_nibble
                        	    21:   ; wait > 4.1 ms
00:B727 A214            	    22:   ldx #20
00:B729 A000            	    23:   ldy #0
00:B72B 20D590          	    24:   jsr delay      ; 20 ms delay (in case of faster board clock speeds)
00:B72E 20F1B7          	    25:   jsr lcd_write_instruction_nibble
00:B731 20CB90          	    26:   jsr delay_1ms  ; do it 4 times in case of faster board clock speeds
00:B734 20CB90          	    27:   jsr delay_1ms
00:B737 20CB90          	    28:   jsr delay_1ms
00:B73A 20CB90          	    29:   jsr delay_1ms
00:B73D 20F1B7          	    30:   jsr lcd_write_instruction_nibble
00:B740 20CB90          	    31:   jsr delay_1ms  ; do it 4 times in case of faster board clock speeds
00:B743 20CB90          	    32:   jsr delay_1ms
00:B746 20CB90          	    33:   jsr delay_1ms
00:B749 20CB90          	    34:   jsr delay_1ms
00:B74C A920            	    35:   lda #$20    ; switch to 4-bit mode
00:B74E 20F1B7          	    36:   jsr lcd_write_instruction_nibble
00:B751 20CB90          	    37:   jsr delay_1ms  ; do it 4 times in case of faster board clock speeds
00:B754 20CB90          	    38:   jsr delay_1ms
00:B757 20CB90          	    39:   jsr delay_1ms
00:B75A 20CB90          	    40:   jsr delay_1ms
                        	    41: ;
                        	    42: ;  now we can switch to sending 8-bits in two nibbles
                        	    43: ;
00:B75D A928            	    44:   lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
00:B75F 20FDB7          	    45:   jsr lcd_instruction
00:B762 A90E            	    46:   lda #%00001110 ; Display on; cursor on; blink off
00:B764 20FDB7          	    47:   jsr lcd_instruction
00:B767 A906            	    48:   lda #%00000110 ; Increment and shift cursor; don't shift display
00:B769 20FDB7          	    49:   jsr lcd_instruction
00:B76C 2051B8          	    50:   jsr lcd_clear_display
00:B76F 60              	    51:   rts
                        	    52: 
                        	    53: lcd_prepare_to_read_register:
00:B770 ADF17F          	    54:   lda VIA_PORTA
00:B773 0940            	    55:   ora #LCD_RW             ; set RW bit  (ie. enable reading)
00:B775 295F            	    56:   and #<(~(LCD_RS|LCD_E)) ; Clear RS/E bits
00:B777 8DF17F          	    57:   sta VIA_PORTA
00:B77A ADF27F          	    58:   lda VIA_DDRB
00:B77D 290F            	    59:   and #$0F
00:B77F 8DF27F          	    60:   sta VIA_DDRB            ; we are reading from DDRB
00:B782 60              	    61:   rts
                        	    62: 
                        	    63: lcd_prepare_to_write_data:
00:B783 48              	    64:   pha
00:B784 ADF17F          	    65:   lda VIA_PORTA
00:B787 293F            	    66:   and #<(~(LCD_RW|LCD_E))  ; clear RW and E (enable writing)
00:B789 0920            	    67:   ora #LCD_RS              ; setting this means we write a character
00:B78B 8DF17F          	    68:   sta VIA_PORTA
00:B78E ADF27F          	    69:   lda VIA_DDRB
00:B791 09F0            	    70:   ora #$F0      ; Set high-order pins on port B to output
00:B793 8DF27F          	    71:   sta VIA_DDRB
00:B796 68              	    72:   pla
00:B797 60              	    73:   rts
                        	    74: 
                        	    75: lcd_prepare_to_write_instruction:
00:B798 48              	    76:   pha
00:B799 ADF17F          	    77:   lda VIA_PORTA
00:B79C 291F            	    78:   and #<(~(LCD_RW|LCD_RS|LCD_E))  ; clear RW, RS and E (enable writing)
00:B79E 8DF17F          	    79:   sta VIA_PORTA
00:B7A1 ADF27F          	    80:   lda VIA_DDRB
00:B7A4 09F0            	    81:   ora #$F0      ; Set high-order pins on port B to output
00:B7A6 8DF27F          	    82:   sta VIA_DDRB
00:B7A9 68              	    83:   pla
00:B7AA 60              	    84:   rts
                        	    85: 
                        	    86: lcd_set_enable:
00:B7AB ADF17F          	    87:   lda VIA_PORTA
00:B7AE 0980            	    88:   ora #LCD_E
00:B7B0 8DF17F          	    89:   sta VIA_PORTA   ; Set enable (E)
00:B7B3 60              	    90:   rts
                        	    91: 
                        	    92: lcd_clear_enable:
00:B7B4 ADF17F          	    93:   lda VIA_PORTA
00:B7B7 297F            	    94:   and #<(~LCD_E)  ; Clear enable (E)
00:B7B9 8DF17F          	    95:   sta VIA_PORTA
00:B7BC 60              	    96:   rts
                        	    97: 
                        	    98: lcd_read_instruction_nibble:
00:B7BD 20ABB7          	    99:   jsr lcd_set_enable
00:B7C0 ADF07F          	   100:   lda VIA_PORTB   ; read the data on port B
00:B7C3 48              	   101:   pha             ; save the data
00:B7C4 20B4B7          	   102:   jsr lcd_clear_enable
00:B7C7 68              	   103:   pla             ; get the data back
00:B7C8 60              	   104:   rts
                        	   105: 
                        	   106: ;
                        	   107: ; wait until LCD is not busy
                        	   108: ;
                        	   109: lcd_wait:
00:B7C9 5A              	   110:   phy
00:B7CA 48              	   111:   pha
00:B7CB 2070B7          	   112:   jsr lcd_prepare_to_read_register
                        	   113: lcdbusy:
00:B7CE 20BDB7          	   114:   jsr lcd_read_instruction_nibble
00:B7D1 2980            	   115:   and #$80        ; get busy flag
00:B7D3 A8              	   116:   tay             ; save busy status
00:B7D4 20BDB7          	   117:   jsr lcd_read_instruction_nibble   ; do second nibble
00:B7D7 98              	   118:   tya             ; get busy status back
00:B7D8 D0F4            	   119:   bne lcdbusy     ; if busy go back
                        	   120: ;
                        	   121: ;  here when not busy any more
                        	   122: ;
00:B7DA 68              	   123:   pla
00:B7DB 7A              	   124:   ply
00:B7DC 60              	   125:   rts
                        	   126: 
                        	   127: ;
                        	   128: ;  Find the current LCD (cursor) address - useful for knowing
                        	   129: ;  if we exceed the limit of line 1
                        	   130: ;
                        	   131: lcd_get_address:
00:B7DD 2070B7          	   132:   jsr lcd_prepare_to_read_register
00:B7E0 20BDB7          	   133:   jsr lcd_read_instruction_nibble
00:B7E3 2970            	   134:   and #$70        ; ignore busy bit, mask out other junk
00:B7E5 8586            	   135:   sta lcd_work
00:B7E7 20BDB7          	   136:   jsr lcd_read_instruction_nibble
00:B7EA 4A              	   137:   lsr A   ; shift this lot into low-order bits
00:B7EB 4A              	   138:   lsr A
00:B7EC 4A              	   139:   lsr A
00:B7ED 4A              	   140:   lsr A
00:B7EE 0586            	   141:   ora lcd_work    ; get the high-order bits back
00:B7F0 60              	   142:   rts
                        	   143: 
                        	   144: lcd_write_instruction_nibble:
00:B7F1 48              	   145:   pha
00:B7F2 8DF07F          	   146:   sta VIA_PORTB         ; set up the data
00:B7F5 20ABB7          	   147:   jsr lcd_set_enable    ; toggle enable
00:B7F8 20B4B7          	   148:   jsr lcd_clear_enable
00:B7FB 68              	   149:   pla
00:B7FC 60              	   150:   rts
                        	   151: 
                        	   152: ;
                        	   153: ;  send an instruction to the LCD
                        	   154: ;
                        	   155: lcd_instruction:
00:B7FD 20C9B7          	   156:   jsr lcd_wait
00:B800 2098B7          	   157:   jsr lcd_prepare_to_write_instruction
00:B803 20F1B7          	   158:   jsr lcd_write_instruction_nibble
00:B806 48              	   159:   pha
00:B807 0A              	   160:   asl a   ; move the low-order bits into the high-order bits
00:B808 0A              	   161:   asl a   ; because the high-order 4 bits are the active ones
00:B809 0A              	   162:   asl a
00:B80A 0A              	   163:   asl a
00:B80B 20F1B7          	   164:   jsr lcd_write_instruction_nibble
00:B80E 68              	   165:   pla
00:B80F 60              	   166:   rts
                        	   167: 
                        	   168: lcd_data_nibble:
00:B810 48              	   169:   pha
00:B811 2083B7          	   170:   jsr lcd_prepare_to_write_data
00:B814 8DF07F          	   171:   sta VIA_PORTB
00:B817 20ABB7          	   172:   jsr lcd_set_enable
00:B81A 20B4B7          	   173:   jsr lcd_clear_enable
00:B81D 68              	   174:   pla
00:B81E 60              	   175:   rts
                        	   176: 
                        	   177: ;
                        	   178: ;  print a character to the LCD
                        	   179: ;
                        	   180: lcd_print_char:
00:B81F 20C9B7          	   181:   jsr lcd_wait  ; wait for previous write to finish
00:B822 C90A            	   182:   cmp #NL
00:B824 D004            	   183:   bne lcd_print_not_newline ; newline jumps to 2nd line
00:B826 2059B8          	   184:   jsr lcd_second_line       ; go to second line
00:B829 60              	   185:   rts                       ; and don't print the newline :)
                        	   186: 
                        	   187: lcd_print_not_newline:
00:B82A 48              	   188:   pha                   ; save the character we want to print
00:B82B 20DDB7          	   189:   jsr lcd_get_address
00:B82E C910            	   190:   cmp #16         ; 16 characters on the first line
00:B830 900E            	   191:   bcc lcd_print_char_ok ; not there yet
00:B832 D005            	   192:   bne lcd_print_char_on_2nd_line  ; not < 16 and not == 16, must be > 16
                        	   193:   ; we have exactly 16, so drop down to address 64
00:B834 2059B8          	   194:   jsr lcd_second_line  ; at char 16 go to 2nd line (address 64)
00:B837 8007            	   195:   bra lcd_print_char_ok
                        	   196: 
                        	   197: lcd_print_char_on_2nd_line:
00:B839 C950            	   198:   cmp #80                  ; more than 16 characters on in 2nd line? (64 + 16)
00:B83B 9003            	   199:   bcc lcd_print_char_ok    ; nah
00:B83D 2051B8          	   200:   jsr lcd_clear_display    ; yes, clear display then and start again
                        	   201: lcd_print_char_ok:
                        	   202: lcd_print_char_newline:
00:B840 2083B7          	   203:   jsr lcd_prepare_to_write_data
00:B843 68              	   204:   pla                      ; get the character back
00:B844 2010B8          	   205:   jsr lcd_data_nibble
00:B847 48              	   206:   pha
00:B848 0A              	   207:   asl a     ; now send the low-order bits
00:B849 0A              	   208:   asl a
00:B84A 0A              	   209:   asl a
00:B84B 0A              	   210:   asl a
00:B84C 2010B8          	   211:   jsr lcd_data_nibble
00:B84F 68              	   212:   pla
00:B850 60              	   213:   rts
                        	   214: 
                        	   215: lcd_clear_display:
00:B851 48              	   216:   pha
00:B852 A901            	   217:   lda #%00000001 ; Clear display
00:B854 20FDB7          	   218:   jsr lcd_instruction
00:B857 68              	   219:   pla
00:B858 60              	   220:   rts
                        	   221: 
                        	   222: lcd_second_line:
00:B859 48              	   223:   pha
00:B85A A9C0            	   224:   lda #$C0 ; set output address to 0x40 (set DDRAM address)
00:B85C 20FDB7          	   225:   jsr lcd_instruction
00:B85F 68              	   226:   pla
00:B860 60              	   227:   rts
                        	   228: 
                        	   229: lcd_home:
00:B861 48              	   230:   pha
00:B862 A980            	   231:   lda #$80 ; set output address to 0 (set DDRAM address)
00:B864 20FDB7          	   232:   jsr lcd_instruction
00:B867 68              	   233:   pla
00:B868 60              	   234:   rts
                        	   235: 
                        	   236: 
                        	   237: ;
                        	   238: ;  print null-terminated message on LCD, message in A (lo) and X (hi)
                        	   239: ;  returns the length of the message in Y
                        	   240: ;
                        	   241: lcd_print_message:
00:B869 8503            	   242:   sta REG2
00:B86B 8604            	   243:   stx REG2+1
00:B86D A000            	   244:   ldy #0
00:B86F 2051B8          	   245:   jsr lcd_clear_display
                        	   246: lcd_print:
00:B872 B103            	   247:   lda (REG2),y
00:B874 F006            	   248:   beq lcd_print_done
00:B876 201FB8          	   249:   jsr lcd_print_char
00:B879 C8              	   250:   iny
00:B87A 80F6            	   251:   bra lcd_print
                        	   252: 
00:B87C 60              	   253: lcd_print_done rts
                        	   254: 
                        	   255:   .else ; LCD_SUPPORT
                        	   256: 
                        	   257: lcd_print_char :
                        	   258: lcd_clear_display :
                        	   259: lcd_second_line:
                        	   260: lcd_print_message:
                        	   261: lcd_instruction:
                        	   262: lcd_get_address:
                        	   263: lcd_home:
                        	   264: lcd_wait:
                        	   265:     ldx #50     ; No LCD
                        	   266:     jmp ERROR
                        	   267: 
                        	   268: 
                        	   269:   .endif  ; (no) LCD_SUPPORT
                        	   270: 
                        	   271:   .endif  ; not emulator
                        	   272: 

Source: "gpascal.asm"
                        	   182:   .include "symbols.inc"

Source: "symbols.inc"
                        	     1: ;***********************************************
                        	     2: ; SYMBOL TABLE STUFF: Offsets from the start of a particular symbol
                        	     3: ; Stored as a linked list, where you search backwards so the more local one is found first
                        	     4: ;***********************************************
                        	     5: 
                        	     6: SYMPRV   =  0         ; address of previous symbol (for working backwards through symbols)
                        	     7: SYMLVL   =  2         ; nested level (eg. entering a procedure/function increments the level,
                        	     8:                       ;                   and leaving it decrements the level)
                        	     9:                       ; - used to detect duplicate symbols at the same level
                        	    10: SYMTYP   =  3         ; Symbol type: C = constant, V = variable, Y = function return value
                        	    11:                       ;              P = procedure, F = function, A = array
                        	    12:                       ;              p = library procedure, f = library function
                        	    13:                       ;  See defines below.
                        	    14: SYMDSP   =  4         ; if the symbol is a constant, what the value is (3 bytes)
                        	    15:                       ; if the symbol is a variable, array or function return then this is the offset (2 bytes)
                        	    16: SYMARG   =  6         ; if the symbol is a procedure/function, count of arguments (can be zero)
                        	    17: SYMSUB   =  6         ; MAX SUBSCRIPT+1 - for arrays, so this is the actual array length
                        	    18: SYMDAT   =  8         ; data type: 0 = integer, 1 = char
                        	    19: SYMLEN   =  9         ; length of the name, der
                        	    20: SYMNAM   =  10        ; name of symbol for SYMLEN characters, stored in upper-case
                        	    21: 
                        	    22: ;
                        	    23: ; Symbol types
                        	    24: ;
                        	    25: 
                        	    26: SYMBOL_CONSTANT          = 'C'
                        	    27: SYMBOL_VARIABLE          = 'V'
                        	    28: SYMBOL_FUNCTION_RETURN   = 'Y'
                        	    29: SYMBOL_PROCEDURE         = 'P'
                        	    30: SYMBOL_FUNCTION          = 'F'
                        	    31: SYMBOL_LIBRARY_PROCEDURE = 'Q'  ; library procedures and functions are implemented in assembler
                        	    32: SYMBOL_LIBRARY_FUNCTION  = 'R'
                        	    33: SYMBOL_ARRAY             = 'A'
                        	    34: 
                        	    35: 
                        	    36: 
                        	    37: ;
                        	    38: ;***********************************************
                        	    39: ;SEARCH SYMBOL TABLE - returns Z if not found (BEQ <not found>)
                        	    40: ;***********************************************
                        	    41: SEARCH   =  *
00:B87D A532            	    42:          lda  ENDSYM+1    ; get the end of the symbol table
00:B87F 8541            	    43:          sta  SYMITM+1    ; make it the current symbol
00:B881 A531            	    44:          lda  ENDSYM
00:B883 800B            	    45:          bra  SEA1
                        	    46: 
                        	    47: SEA_NEXT =  *
00:B885 A000            	    48:          ldy  #SYMPRV
00:B887 B140            	    49:          lda  (SYMITM),Y
00:B889 AA              	    50:          tax
00:B88A C8              	    51:          iny
00:B88B B140            	    52:          lda  (SYMITM),Y
00:B88D 8541            	    53:          sta  SYMITM+1   ; previous link
00:B88F 8A              	    54:          txa
                        	    55: ;
                        	    56: ;  go to the previous symbol table item
                        	    57: ;
                        	    58: SEA1     =  *
00:B890 8540            	    59:          sta  SYMITM
00:B892 C52F            	    60:          cmp  STARTSYM
00:B894 D007            	    61:          bne  SEA2
00:B896 A541            	    62:          lda  SYMITM+1
00:B898 C530            	    63:          cmp  STARTSYM+1
00:B89A D001            	    64:          bne  SEA2       ; more to go
00:B89C 60              	    65:          rts             ; finished if we are back at the start of the symbol table
                        	    66: 
                        	    67: SEA2     =  *
00:B89D A009            	    68:          ldy  #SYMLEN
00:B89F B140            	    69:          lda  (SYMITM),Y  ; get this item's length
00:B8A1 C592            	    70:          cmp  token_length      ; compare to the token legnth we got
00:B8A3 D0E0            	    71:          bne  SEA_NEXT    ; wrong length - try another
00:B8A5 A540            	    72:          lda  SYMITM      ; back to this symbol's start address
00:B8A7 18              	    73:          clc
00:B8A8 690A            	    74:          adc  #SYMNAM     ; add the offset of the name to it
00:B8AA 8503            	    75:          sta  DEST
00:B8AC A541            	    76:          lda  SYMITM+1
00:B8AE 6900            	    77:          adc  #0
00:B8B0 8504            	    78:          sta  DEST+1      ; the memory location of the symbol name is in DEST
00:B8B2 A590            	    79:          lda  token_address      ; now put the token's address into SRCE
00:B8B4 8500            	    80:          sta  SRCE
00:B8B6 A591            	    81:          lda  token_address+1
00:B8B8 8501            	    82:          sta  SRCE+1
00:B8BA A492            	    83:          ldy  token_length
00:B8BC 202D92          	    84:          jsr  COMSTL      ; compare SRCE to DEST
00:B8BF D0C4            	    85:          bne  SEA_NEXT    ; not that one - try another
00:B8C1 2039BA          	    86:          jsr  GET_DAT     ; get the symbol's data type into DATTYP
00:B8C4 A002            	    87:          ldy  #SYMLVL     ; and level - why isn't this a function, huh?
00:B8C6 B140            	    88:          lda  (SYMITM),Y
00:B8C8 AA              	    89:          tax              ; level into X
00:B8C9 A003            	    90:          ldy  #SYMTYP
00:B8CB B140            	    91:          lda  (SYMITM),Y  ; get type of symbol
00:B8CD 8536            	    92:          sta  BSAVE       ; symbol type -> BSAVE
00:B8CF C943            	    93:          cmp  #SYMBOL_CONSTANT       ; constant?
00:B8D1 D013            	    94:          bne  SEA4        ; nah
                        	    95: ;
                        	    96: ;  symbol is a constant
                        	    97: ;
00:B8D3 A004            	    98:          ldy  #SYMDSP     ; if a constant, this is the value
00:B8D5 B140            	    99:          lda  (SYMITM),Y
00:B8D7 8594            	   100:          sta  token_value
00:B8D9 C8              	   101:          iny
00:B8DA B140            	   102:          lda  (SYMITM),Y
00:B8DC 8595            	   103:          sta  token_value+1
00:B8DE C8              	   104:          iny
00:B8DF B140            	   105:          lda  (SYMITM),Y
00:B8E1 8596            	   106:          sta  token_value+2     ; token_value (3 bytes) now has the value in it
00:B8E3 4CF1B8          	   107:          jmp  SEA3
                        	   108: ;
                        	   109: ;  symbol is not a constant
                        	   110: ;
                        	   111: SEA4     =  *                           ; not constant
00:B8E6 C956            	   112:          cmp  #SYMBOL_VARIABLE          ; variable?
00:B8E8 F004            	   113:          beq  SEA5                      ; yes
00:B8EA C959            	   114:          cmp  #SYMBOL_FUNCTION_RETURN   ; argument?
00:B8EC D003            	   115:          bne  SEA3                      ; no - must be SYMBOL_ARRAY, SYMBOL_PROCEDURE or SYMBOL_FUNCTION
                        	   116: ;
                        	   117: ;  here for variables and function return values
                        	   118: ;
                        	   119: SEA5     =  *
00:B8EE 2094BA          	   120:          jsr  GET_OFF    ; get the variable's offset
                        	   121: SEA3     =  *
00:B8F1 A536            	   122:          lda  BSAVE      ; A now has the symbol type in it
                        	   123: 
                        	   124: ; Types are: SYMBOL_CONSTANT, SYMBOL_VARIABLE, SYMBOL_FUNCTION_RETURN,
                        	   125: ;            SYMBOL_PROCEDURE, SYMBOL_FUNCTION, SYMBOL_ARRAY
                        	   126: 
00:B8F3 60              	   127:          rts             ; SHOULD SET 'NEQ' FLAG
                        	   128: 
                        	   129: 
00:B8F4 A225            	   130: SYM_FULL ldx  #37     ; ERROR: Symbol table full
00:B8F6 4C6497          	   131:          jmp  ERROR
                        	   132: 
                        	   133: ;***********************************************
                        	   134: ; ADD SYMBOL TO SYMBOL TABLE - going downwards until we hit the P-codes
                        	   135: ;  A = the symbol type
                        	   136: ;***********************************************
                        	   137: ADDSYM   =  *
00:B8F9 48              	   138:          pha            ; save the symbol type
                        	   139: 
00:B8FA A631            	   140:          ldx  ENDSYM    ; get the end of the symbol table
00:B8FC 8640            	   141:          stx  SYMITM    ; make it the current symbol
00:B8FE A632            	   142:          ldx  ENDSYM+1
00:B900 8641            	   143:          stx  SYMITM+1
                        	   144: ;
                        	   145: ;  since we are going downwards, we need to subtract the fixed size of a symbol table item,
                        	   146: ;  plus the symbol length, from SYMITM
                        	   147: ;
00:B902 38              	   148:          sec            ; first subtract the token length
00:B903 A540            	   149:          lda  SYMITM
00:B905 E592            	   150:          sbc  token_length
00:B907 8540            	   151:          sta  SYMITM
00:B909 8503            	   152:          sta  DEST      ; put this spot into DEST for copying the name
00:B90B A541            	   153:          lda  SYMITM+1
00:B90D E900            	   154:          sbc  #0
00:B90F 8541            	   155:          sta  SYMITM+1
00:B911 8504            	   156:          sta  DEST+1
00:B913 38              	   157:          sec            ; and now the fixed size
00:B914 A540            	   158:          lda  SYMITM
00:B916 E90A            	   159:          sbc  #SYMNAM
00:B918 8540            	   160:          sta  SYMITM
00:B91A A541            	   161:          lda  SYMITM+1
00:B91C E900            	   162:          sbc  #0
00:B91E 8541            	   163:          sta  SYMITM+1
                        	   164: ;
                        	   165: ;  check we haven't hit the P-codes
                        	   166: ;
00:B920 A902            	   167:          lda  #FLAG_ASSEMBLING
00:B922 25BE            	   168:          and  system_flags
00:B924 D008            	   169:          bne  ADDSYM_NOT_FULL
00:B926 A524            	   170:          lda  PCODE+1
00:B928 C541            	   171:          cmp  SYMITM+1
00:B92A 9002            	   172:          bcc  ADDSYM_NOT_FULL   ; less than - ok
00:B92C 80C6            	   173:          bra  SYM_FULL          ; greater than or equal (high-order byte) - uh oh
                        	   174: ;
                        	   175: ;  ah, for assembling it is a pain to know whether the symbol table has overflowed, so I'm going
                        	   176: ;  to ignore that as a problem for now. Checking against PCODE will not work if the assembler output
                        	   177: ;  has been relocated to above the symbol table, and the only other thing we can compare against is
                        	   178: ;  the end of the source which we don't necessarily know.
                        	   179: ;
                        	   180: ;
                        	   181: ;  now put the previous start in as the link for the previous one for this item
                        	   182: ;
                        	   183: ADDSYM_NOT_FULL:
00:B92E A000            	   184:          ldy  #SYMPRV
00:B930 A531            	   185:          lda  ENDSYM
00:B932 9140            	   186:          sta  (SYMITM),Y
00:B934 A532            	   187:          lda  ENDSYM+1
00:B936 C8              	   188:          iny
00:B937 9140            	   189:          sta  (SYMITM),Y
                        	   190: ;
                        	   191: ;  SYMITM now becomes the start of the symbol table
                        	   192: ;
00:B939 A540            	   193:          lda  SYMITM
00:B93B 8531            	   194:          sta  ENDSYM
00:B93D A541            	   195:          lda  SYMITM+1
00:B93F 8532            	   196:          sta  ENDSYM+1
                        	   197: ;
                        	   198: ;  OK, we should be done linking it in.
                        	   199: ;  SYMITM now points to this (as yet unfilled-in) item and the first two bytes now point to
                        	   200: ;   where the symbols previously ended
                        	   201: ;
00:B941 68              	   202:          pla                ; get symbol type back
00:B942 A003            	   203:          ldy  #SYMTYP
00:B944 9140            	   204:          sta  (SYMITM),Y    ; store the type which was in A
00:B946 A002            	   205:          ldy  #SYMLVL
00:B948 48              	   206:          pha                ; save symbol type again
00:B949 A522            	   207:          lda  LEVEL
00:B94B 9140            	   208:          sta  (SYMITM),Y    ; store the level
00:B94D A009            	   209:          ldy  #SYMLEN
00:B94F A592            	   210:          lda  token_length
00:B951 9140            	   211:          sta  (SYMITM),Y    ; store the token length
00:B953 A8              	   212:          tay
00:B954 88              	   213:          dey                ; make zero-relative
                        	   214: ADD1     =  *               ; copy the name across, in upper case
00:B955 B190            	   215:          lda  (token_address),Y
00:B957 20C48F          	   216:          jsr  MAKE_UPPER
00:B95A 9103            	   217:          sta  (DEST),Y
00:B95C 88              	   218:          dey
00:B95D 10F6            	   219:          bpl  ADD1      ; keep copying
                        	   220: 
                        	   221: ;
                        	   222: ;  we have added name to the table, now do the rest
                        	   223: ;
00:B95F 68              	   224:          pla                     ; get symbol type back again
00:B960 AA              	   225:          tax                     ; symbol type
00:B961 C943            	   226:          cmp  #SYMBOL_CONSTANT   ; CONSTANT??
00:B963 D013            	   227:          bne  ADD4
                        	   228: ;
                        	   229: ;  constant
                        	   230: ;
00:B965 A004            	   231:          ldy  #SYMDSP            ; put this token's value into SYMDSP offset from SYMITM (for 3 bytes)
00:B967 A594            	   232:          lda  token_value
00:B969 9140            	   233:          sta  (SYMITM),Y
00:B96B C8              	   234:          iny
00:B96C A595            	   235:          lda  token_value+1
00:B96E 9140            	   236:          sta  (SYMITM),Y
00:B970 C8              	   237:          iny
00:B971 A596            	   238:          lda  token_value+2
00:B973 9140            	   239:          sta  (SYMITM),Y
00:B975 4C94B9          	   240:          jmp  ADD9
                        	   241: ;
                        	   242: ;  not a constant
                        	   243: ;
                        	   244: ADD4     =  *
00:B978 A008            	   245:          ldy  #SYMDAT
00:B97A A901            	   246:          lda  #1            ; char type (?)
00:B97C 9140            	   247:          sta  (SYMITM),Y
00:B97E 8A              	   248:          txa                ; get symbol type back
00:B97F C956            	   249:          cmp  #SYMBOL_VARIABLE
00:B981 D011            	   250:          bne  ADD9
                        	   251: ;
                        	   252: ;  variable type
                        	   253: ;
00:B983 A005            	   254:          ldy  #SYMDSP+1
00:B985 A521            	   255:          lda  FRAME+1       ; save frame
00:B987 9140            	   256:          sta  (SYMITM),Y
00:B989 88              	   257:          dey
00:B98A A520            	   258:          lda  FRAME
00:B98C 9140            	   259:          sta  (SYMITM),Y
00:B98E E620            	   260:          inc  FRAME         ; add 1 to frame number
00:B990 D002            	   261:          bne  ADD9
00:B992 E621            	   262:          inc  FRAME+1
                        	   263: ADD9     =  *
00:B994 60              	   264:          rts
                        	   265: ;
                        	   266: 
                        	   267: ;
                        	   268: LOOKUP   =  *
00:B995 207DB8          	   269:          JSR  SEARCH
00:B998 D005            	   270:          BNE  LOOK1
00:B99A A20B            	   271:          LDX  #11     ; ERROR: Undeclared Identifier
00:B99C 4C6497          	   272:          jmp  ERROR
00:B99F 60              	   273: LOOK1    RTS
                        	   274: ;
00:B9A0 207DB8          	   275: CHKDUP   JSR  SEARCH
00:B9A3 F00A            	   276:          BEQ  DUP9
00:B9A5 8A              	   277:          TXA
00:B9A6 C522            	   278:          CMP  LEVEL
00:B9A8 D005            	   279:          BNE  DUP9
00:B9AA A226            	   280:          LDX  #38   ; ERROR: Duplicate Identifier
00:B9AC 4C6497          	   281:          jmp  ERROR
00:B9AF 60              	   282: DUP9     RTS
                        	   283: 

Source: "gpascal.asm"
                        	   183:   .include "compiler.inc"

Source: "compiler.inc"
                        	     1: 
                        	     2: ;***********************************************
                        	     3: ; COMPILER
                        	     4: ;***********************************************
                        	     5: 
                        	     6: 
                        	     7: ;
                        	     8: ;
                        	     9: ;  Compiler directives:
                        	    10: ;
                        	    11: ;    {%L} - list during compile (source code and current P-code address)
                        	    12: ;    {%P} - show generated P-codes during compile - only works during compile (not syntax check)
                        	    13: ;    {%N} - stop listing during compile (cancels %L and %P)
                        	    14: ;    {%S <address>} - relocate symbol table to <address> - must be done before defining symbols
                        	    15: ;                     also generates an opcode to relocate the runtime stack
                        	    16: ;
                        	    17: ;   The % must directly follow the start of the comment.
                        	    18: ;
                        	    19: ;
                        	    20: ;  Comments:  (* some comment *) or { some comment }
                        	    21: ;             "(*" / "{", and "*)" / "}" are treated interchangeably so (* some comment } would work
                        	    22: ;  Comments cannot be nested.
                        	    23: ;
                        	    24: ;  Tips:
                        	    25: ;
                        	    26: ;   Procedures and functions must be declared at the START of a block, not in the middle.
                        	    27: ;   The order is important. CONST first, then VAR, then procedure/function declarations, then BEGIN
                        	    28: 
                        	    29: ;    eg.
                        	    30: ;
                        	    31: ;    const limit = 10;   { <-- this is the start of a block: CONST before VAR }
                        	    32: ;    var k: integer;     { we declare variables and constants here - BEFORE "begin" }
                        	    33: ;    line : array [100] of char;  { array }
                        	    34: ;    function foo;       { and functions and procedures - this is the start of another block}
                        	    35: ;    begin
                        	    36: ;      foo := 42         { assign to function return value }
                        	    37: ;    end;                { end of the function block - note semicolon }
                        	    38: ;    begin               { end of declarations - now we have the block statements }
                        	    39: ;     for k := 1 to limit do
                        	    40: ;       writeln ("square of ", k, " is ", k * k);
                        	    41: ;     write (foo)        { call function }
                        	    42: ;    end.
                        	    43: ;
                        	    44: ;    ARGUMENTS: If the procedure or function does not take arguments OMIT THE BRACKETS.
                        	    45: ;               Likewise, omit the brackets if you call the procedure or function (unlike C)
                        	    46: ;
                        	    47: ;    Semicolons SEPARATE statements, they don't terminate them.
                        	    48: ;
                        	    49: ; Warnings: * Functions which do not assign to the function return value give undefined results.
                        	    50: ;           * Multiplication discards high-order bits if result is too large.
                        	    51: ;           * Divide remainder is always positive (ie. MOD always gives a positive result, regardless of operand signs)
                        	    52: ;           * Function arguments are always integers and always return an integer.
                        	    53: ;           * One to three-byte strings can be used as integer constants
                        	    54: ;               eg. a := "abc"; write (a);   --> Result: 6513249 (ie. 0x636261 or "abc")
                        	    55: ;               The first character is the low-order byte in the number, explaining the above results.
                        	    56: ;           * Strings can start with single or double quotes, whatever starts the string must terminate it.
                        	    57: ;           * String literals can have the same character that started the string embedded, to do that put it twice.
                        	    58: ;             eg. 'Nick''s cat'
                        	    59: ;           * Array access it not range-checked.
                        	    60: ;           * Arrays start at zero. The array size declared is the maximum index (unlike C) so foo: array [10] of integ
                        	    61: ;               would declare an array of 11 elements, numbered from foo [0] to foo [10]
                        	    62: ;           * Maximum arguments to a procedure/function is 85 (255 / 3) due to internal coding
                        	    63: ;
                        	    64: 
                        	    65: 
                        	    66: ;
00:B9B0 A2FF            	    67: COMPIL   LDX  #NEW_STK
00:B9B2 9A              	    68:   txs    ; set stack back to 0xFF
                        	    69: 
00:B9B3 20DA91          	    70:   jsr  INIT
00:B9B6 A901            	    71:   lda  #FLAG_COMPILING
00:B9B8 04BE            	    72:   tsb  system_flags
00:B9BA 2021C6          	    73:   jsr  add_pascal_library_functions
00:B9BD 20A3CE          	    74:   jsr  pas_get_token
00:B9C0 20A4C2          	    75:   jsr  BLOCK
00:B9C3 A92E            	    76:   lda  #'.'
00:B9C5 A209            	    77:   ldx  #9        ; ERROR: . expected
00:B9C7 2007CF          	    78:   jsr  CHKTKN
00:B9CA A900            	    79:   lda  #0
00:B9CC A213            	    80:   ldx  #19       ; ERROR: Incorrect Symbol
00:B9CE 20F7CE          	    81:   jsr  GETCHK
00:B9D1 202892          	    82:   jsr  CROUT
00:B9D4 A9DF            	    83:   lda  #<pcodes_ended_message  ; P-codes ended at
00:B9D6 A292            	    84:   ldx  #>pcodes_ended_message
00:B9D8 202682          	    85:   jsr  print
00:B9DB A524            	    86:   lda  PCODE+1
00:B9DD 8544            	    87:   sta  END_PCD+1
00:B9DF 209D92          	    88:   jsr  PRBYTE
00:B9E2 A523            	    89:   lda  PCODE
00:B9E4 8543            	    90:   sta  END_PCD
00:B9E6 205293          	    91:   jsr  PRBYTECR
00:B9E9 20A88E          	    92:   jsr  show_symbol_table_end
00:B9EC 20CD8E          	    93:   jsr  show_source_end
                        	    94: 
00:B9EF A9F2            	    95:   lda  #<compile_finished_message  ; <C>ompile finished: No Errors
00:B9F1 A292            	    96:   ldx  #>compile_finished_message
00:B9F3 202682          	    97:   jsr  print
00:B9F6 A642            	    98:   ldx  SYNTAX
00:B9F8 D004            	    99:   bne  END_CMP
00:B9FA A908            	   100:   lda  #FLAG_VALID_COMPILE
00:B9FC 04BE            	   101:   tsb  system_flags
                        	   102: END_CMP  =  *
00:B9FE 4CCC82          	   103:   jmp  main_prompt
                        	   104: ;
                        	   105: 
                        	   106: ;
                        	   107: CHKLHP   =  *
00:BA01 A928            	   108:          LDA  #'('
00:BA03 A21F            	   109:          LDX  #31     ; ERROR: ( expected
00:BA05 4CF7CE          	   110:          JMP  GETCHK
                        	   111: ;
                        	   112: CHKRHP   =  *
00:BA08 A929            	   113:          LDA  #')'
00:BA0A A216            	   114:          LDX  #22     ; ERROR: ) expected
00:BA0C 2007CF          	   115:          JSR  CHKTKN
00:BA0F 4CA3CE          	   116:          JMP  pas_get_token
                        	   117: ;
                        	   118: GETSUB   =  *
00:BA12 201BBA          	   119:          JSR  CHKLHB
00:BA15 202CBD          	   120:          JSR  EXPRES
00:BA18 4C25BA          	   121:          JMP  CHKRHB
                        	   122: ;
                        	   123: CHKLHB   =  *
00:BA1B A95B            	   124:          LDA  #'['
00:BA1D A221            	   125:          LDX  #33     ; ERROR: [ expected
00:BA1F 20F7CE          	   126:          JSR  GETCHK
00:BA22 4CA3CE          	   127:          JMP  pas_get_token
                        	   128: ;
                        	   129: CHKRHB   =  *
00:BA25 A95D            	   130:          LDA  #']'
00:BA27 A222            	   131:          LDX  #34     ; ERROR: ] expected
00:BA29 2007CF          	   132:          JSR  CHKTKN
00:BA2C 4CA3CE          	   133:          JMP  pas_get_token
                        	   134: ;
                        	   135: GET_LEV  =  *
00:BA2F A522            	   136:          LDA  LEVEL
00:BA31 A002            	   137:          LDY  #SYMLVL
00:BA33 38              	   138:          SEC
00:BA34 F140            	   139:          SBC  (SYMITM),Y
00:BA36 8527            	   140:          STA  DISPL
00:BA38 60              	   141:          RTS
                        	   142: ;
                        	   143: GET_DAT  =  *
00:BA39 A008            	   144:          LDY  #SYMDAT
00:BA3B B140            	   145:          LDA  (SYMITM),Y
00:BA3D 854A            	   146:          STA  DATTYP
00:BA3F 60              	   147:          RTS
                        	   148: ;
                        	   149: 
                        	   150: 
                        	   151: 
                        	   152: ; CONSTANT DEC
                        	   153: ;
                        	   154: CONDEC   =  *
00:BA40 A949            	   155:          LDA  #TOKEN_IDENTIFIER
00:BA42 A204            	   156:          LDX  #4        ; ERROR: Identifier expected
00:BA44 2007CF          	   157:          JSR  CHKTKN
00:BA47 20C992          	   158:          JSR  TKNWRK
00:BA4A A592            	   159:          LDA  token_length
00:BA4C 48              	   160:          PHA
00:BA4D A93D            	   161:          LDA  #'='
00:BA4F A203            	   162:          LDX  #3        ; ERROR: = expected
00:BA51 20F7CE          	   163:          JSR  GETCHK
00:BA54 20A3CE          	   164:          JSR  pas_get_token
00:BA57 2033BB          	   165:          JSR  CONST
00:BA5A 20D492          	   166:          JSR  WRKTKN
00:BA5D 68              	   167:          PLA
00:BA5E 8592            	   168:          STA  token_length
00:BA60 20A0B9          	   169:          JSR  CHKDUP
00:BA63 A943            	   170:          LDA  #SYMBOL_CONSTANT
00:BA65 20F9B8          	   171:          JSR  ADDSYM
00:BA68 4CA3CE          	   172:          JMP  pas_get_token
                        	   173: ;
                        	   174: ;
                        	   175: ;--- SYMITM --> WORK
                        	   176: ;
                        	   177: SYMWRK   =  *
00:BA6B 48              	   178:          PHA
00:BA6C A540            	   179:          LDA  SYMITM
00:BA6E 8537            	   180:          STA  WORK
00:BA70 A541            	   181:          LDA  SYMITM+1
00:BA72 8538            	   182:          STA  WORK+1
00:BA74 68              	   183:          PLA
00:BA75 60              	   184:          RTS
                        	   185: ;
                        	   186: ;--- WORK --> SYMITM
                        	   187: ;
                        	   188: WRKSYM   =  *
00:BA76 48              	   189:          PHA
00:BA77 A537            	   190:          LDA  WORK
00:BA79 8540            	   191:          STA  SYMITM
00:BA7B A538            	   192:          LDA  WORK+1
00:BA7D 8541            	   193:          STA  SYMITM+1
00:BA7F 68              	   194:          PLA
00:BA80 60              	   195:          RTS
                        	   196: ;
                        	   197: ; PUSH PCODE ONTO STACK
                        	   198: ;
                        	   199: PSHPCODE =  *
00:BA81 8536            	   200:          STA  BSAVE
00:BA83 68              	   201:          PLA
00:BA84 AA              	   202:          TAX
00:BA85 68              	   203:          PLA
00:BA86 A8              	   204:          TAY
00:BA87 A524            	   205:          LDA  PCODE+1
00:BA89 48              	   206:          PHA
00:BA8A A523            	   207:          LDA  PCODE
00:BA8C 48              	   208:          PHA
00:BA8D 98              	   209:          TYA
00:BA8E 48              	   210:          PHA
00:BA8F 8A              	   211:          TXA
00:BA90 48              	   212:          PHA
00:BA91 A536            	   213:          LDA  BSAVE
00:BA93 60              	   214:          RTS
                        	   215: ;
                        	   216: ;  Get the offset of this current symbol into OFFSET
                        	   217: ;
                        	   218: GET_OFF  =  *
00:BA94 48              	   219:          PHA
00:BA95 A004            	   220:          LDY  #SYMDSP
00:BA97 B140            	   221:          LDA  (SYMITM),Y
00:BA99 8529            	   222:          STA  OFFSET
00:BA9B C8              	   223:          INY
00:BA9C B140            	   224:          LDA  (SYMITM),Y
00:BA9E 852A            	   225:          STA  OFFSET+1
00:BAA0 A003            	   226:          LDY  #SYMTYP
00:BAA2 B140            	   227:          LDA  (SYMITM),Y
00:BAA4 C956            	   228:          CMP  #SYMBOL_VARIABLE
00:BAA6 F008            	   229:          BEQ  GETO_1
00:BAA8 C941            	   230:          CMP  #SYMBOL_ARRAY
00:BAAA F004            	   231:          BEQ  GETO_1
00:BAAC C959            	   232:          CMP  #SYMBOL_FUNCTION_RETURN
00:BAAE D00D            	   233:          BNE  GETO_2
                        	   234: ;
                        	   235: ;  here if the symbol is a variable, array or function return value
                        	   236: ;   subtract the offset from -3
                        	   237: ;
                        	   238: GETO_1   =  *
00:BAB0 38              	   239:          SEC
00:BAB1 A9FD            	   240:          LDA  #$FD
00:BAB3 E529            	   241:          SBC  OFFSET
00:BAB5 8529            	   242:          STA  OFFSET
00:BAB7 A9FF            	   243:          LDA  #$FF
00:BAB9 E52A            	   244:          SBC  OFFSET+1
00:BABB 852A            	   245:          STA  OFFSET+1
                        	   246: GETO_2   =  *
00:BABD 68              	   247:          PLA
00:BABE 60              	   248:          RTS
                        	   249: ;
                        	   250: GETEXPR  =  *
00:BABF 20A3CE          	   251:          JSR  pas_get_token
00:BAC2 4C2CBD          	   252:          JMP  EXPRES
                        	   253: ;
                        	   254: ;
                        	   255: PCD_WRKD =  *
00:BAC5 48              	   256:          PHA
00:BAC6 A523            	   257:          LDA  PCODE
00:BAC8 8533            	   258:          STA  WORKD
00:BACA A524            	   259:          LDA  PCODE+1
00:BACC 8534            	   260:          STA  WORKD+1
00:BACE 68              	   261:          PLA
00:BACF 60              	   262:          RTS
                        	   263: ;
                        	   264: WRK_OPND =  *
00:BAD0 48              	   265:          PHA
00:BAD1 A537            	   266:          LDA  WORK
00:BAD3 852B            	   267:          STA  OPND
00:BAD5 A538            	   268:          LDA  WORK+1
00:BAD7 852C            	   269:          STA  OPND+1
00:BAD9 68              	   270:          PLA
00:BADA 60              	   271:          RTS
                        	   272: ;
                        	   273: WRKD_WRK =  *
00:BADB 48              	   274:          PHA
00:BADC A533            	   275:          LDA  WORKD
00:BADE 8537            	   276:          STA  WORK
00:BAE0 A534            	   277:          LDA  WORKD+1
00:BAE2 8538            	   278:          STA  WORK+1
00:BAE4 68              	   279:          PLA
00:BAE5 60              	   280:          RTS
                        	   281: ;
                        	   282: WRK_WRKD =  *
00:BAE6 48              	   283:          PHA
00:BAE7 A537            	   284:          LDA  WORK
00:BAE9 8533            	   285:          STA  WORKD
00:BAEB A538            	   286:          LDA  WORK+1
00:BAED 8534            	   287:          STA  WORKD+1
00:BAEF 68              	   288:          PLA
00:BAF0 60              	   289:          RTS
                        	   290: ;
                        	   291: GET_COMM =  *
00:BAF1 A92C            	   292:          LDA  #','
00:BAF3 A220            	   293:          LDX  #32     ; ERROR: , expected
00:BAF5 4C07CF          	   294:          JMP  CHKTKN
                        	   295: ;
                        	   296: GET_ITEM =  *
00:BAF8 20F1BA          	   297:          JSR  GET_COMM   ; check for comma
00:BAFB 4CBFBA          	   298:          JMP  GETEXPR
                        	   299: ;
                        	   300: ;  Load (push) a constant (ie. a literal number)
                        	   301: ;
                        	   302: ;  Numbers in the range 0 to 0x7F are turned into a "low literal" which is a P-code
                        	   303: ;  with the 0x80 bit set. These then become a single-byte P-code which simply pushes
                        	   304: ;  that number onto the stack, thus saving having to have a 4-byte P-code being PCODE_LIT
                        	   305: ;  followed by a 3-byte number, 2 bytes of which would be zero.
                        	   306: ;
                        	   307: VAL_MOVE =  *
00:BAFE 48              	   308:          PHA
00:BAFF 18              	   309:          CLC
00:BB00 A594            	   310:          LDA  token_value
00:BB02 8527            	   311:          STA  DISPL   ; why?
00:BB04 1001            	   312:          BPL  VAL_1   ; is it 0x00 to 0x7F?
00:BB06 38              	   313:          SEC          ; no, set carry bit
                        	   314: VAL_1    =  *
00:BB07 A595            	   315:          LDA  token_value+1
00:BB09 F001            	   316:          BEQ  VAL_2   ; is second byte 0x00?
00:BB0B 38              	   317:          SEC          ; no, set carry bit
                        	   318: VAL_2    =  *
00:BB0C 8529            	   319:          STA  OFFSET
00:BB0E A596            	   320:          LDA  token_value+2
00:BB10 852A            	   321:          STA  OFFSET+1
00:BB12 F001            	   322:          BEQ  VAL_3   ; is third byte 0x00?
00:BB14 38              	   323:          SEC          ; no, set carry bit
                        	   324: VAL_3    =  *
00:BB15 9007            	   325:          BCC  VAL_5   ; did we ever set the carry bit?
00:BB17 A900            	   326:          LDA  #PCODE_LIT  ; yes, so just generate a "load literal"
00:BB19 20E4C6          	   327:          JSR  GENADR
00:BB1C 68              	   328:          PLA
00:BB1D 60              	   329:          RTS
                        	   330: VAL_5    =  *
00:BB1E A594            	   331:          LDA  token_value   ; get the low-order byte back
00:BB20 0980            	   332:          ORA  #$80    ; set the 0x80 bit as a flag
00:BB22 20CBC6          	   333:          JSR  GENNOP  ; output one P-code
00:BB25 68              	   334:          PLA
00:BB26 60              	   335:          RTS
                        	   336: ;
                        	   337: ;
                        	   338: CHK_STAK =  *
00:BB27 BA              	   339:          TSX
00:BB28 8A              	   340:          TXA
00:BB29 C920            	   341:          CMP  #MAX_STK
00:BB2B 9001            	   342:          BCC  STK_FULL
00:BB2D 60              	   343:          RTS
                        	   344: STK_FULL =  *
00:BB2E A21B            	   345: STK_ERR  LDX  #27     ; ERROR: Stack full
00:BB30 4C6497          	   346:          jmp  ERROR      ; FULL
                        	   347: ;
                        	   348: ;
                        	   349: ; CONST get the value into token_value
                        	   350: ;
                        	   351: CONST    =  *
00:BB33 A593            	   352:          LDA  token_type
00:BB35 C94E            	   353:          CMP  #TOKEN_NUMBER
00:BB37 F01F            	   354:          BEQ  CONST9
00:BB39 C949            	   355:          CMP  #TOKEN_IDENTIFIER
00:BB3B F00D            	   356:          BEQ  CONST1
00:BB3D C922            	   357:          CMP  #TOKEN_STRING
00:BB3F D00E            	   358:          BNE  CONST3
00:BB41 A692            	   359:          LDX  token_length
00:BB43 E004            	   360:          CPX  #4
00:BB45 9011            	   361:          BCC  CONST9
00:BB47 4CDBBC          	   362:          JMP  FACERR1    ; STRING TOO BIG
00:BB4A 207DB8          	   363: CONST1   JSR  SEARCH
00:BB4D D005            	   364:          BNE  CONST2
                        	   365: CONST3   =  *
00:BB4F A202            	   366:          LDX  #2        ; ERROR: Constant expected
00:BB51 4C6497          	   367:          jmp  ERROR
00:BB54 C943            	   368: CONST2   CMP  #SYMBOL_CONSTANT
00:BB56 D0F7            	   369:          BNE  CONST3
00:BB58 60              	   370: CONST9   RTS
                        	   371: ;
                        	   372: ; VARIABLE DEC
                        	   373: ;
00:BB59 A949            	   374: VARDEC   LDA  #TOKEN_IDENTIFIER
00:BB5B A204            	   375:          LDX  #4      ; ERROR: Identifier expected
00:BB5D 2007CF          	   376:          JSR  CHKTKN
00:BB60 20A0B9          	   377:          JSR  CHKDUP
00:BB63 A956            	   378:          LDA  #SYMBOL_VARIABLE
00:BB65 20F9B8          	   379:          JSR  ADDSYM
00:BB68 4CA3CE          	   380:          JMP  pas_get_token
                        	   381: ;
                        	   382: ; SIMPLE EXPRESSION
                        	   383: ;
                        	   384: SIMEXP   =  *
00:BB6B A593            	   385:          LDA  token_type
00:BB6D C92B            	   386:          CMP  #'+'
00:BB6F F004            	   387:          BEQ  SIM1
00:BB71 C92D            	   388:          CMP  #'-'
00:BB73 D048            	   389:          BNE  SIM2
00:BB75 48              	   390: SIM1     PHA
00:BB76 20A3CE          	   391:          JSR  pas_get_token
00:BB79 20DDBB          	   392:          JSR  TERM
00:BB7C 68              	   393:          PLA
00:BB7D C92D            	   394:          CMP  #'-'
00:BB7F D005            	   395:          BNE  SIM3
00:BB81 A902            	   396:          LDA  #PCODE_NEG      ; NEG     	Negate (sp)
00:BB83 20CBC6          	   397:          JSR  GENNOP     ; NEGATE
00:BB86 A593            	   398: SIM3     LDA  token_type
00:BB88 C92B            	   399:          CMP  #'+'
00:BB8A F00D            	   400:          BEQ  SIM4
00:BB8C C92D            	   401:          CMP  #'-'
00:BB8E F009            	   402:          BEQ  SIM4
00:BB90 C98A            	   403:          CMP  #TOKEN_OR       ; OR
00:BB92 F005            	   404:          BEQ  SIM4
00:BB94 C9A4            	   405:          CMP  #TOKEN_XOR      ; XOR
00:BB96 F001            	   406:          BEQ  SIM4
00:BB98 60              	   407:          RTS
00:BB99 48              	   408: SIM4     PHA
00:BB9A 20A3CE          	   409:          JSR  pas_get_token
00:BB9D 20DDBB          	   410:          JSR  TERM
00:BBA0 68              	   411:          PLA
00:BBA1 C92D            	   412:          CMP  #'-'
00:BBA3 F010            	   413:          BEQ  SIM5
00:BBA5 C92B            	   414:          CMP  #'+'
00:BBA7 F010            	   415:          BEQ  SIM6
00:BBA9 C9A4            	   416:          CMP  #TOKEN_XOR          ; XOR
00:BBAB F016            	   417:          BEQ  SIM8
00:BBAD A91A            	   418:          LDA  #PCODE_ORR          ; ORR     	OR  (sp - 1) | (sp)
00:BBAF 20CBC6          	   419: SIM7     JSR  GENNOP
00:BBB2 4C86BB          	   420:          JMP  SIM3
00:BBB5 A906            	   421: SIM5     LDA  #PCODE_SUB          ; MINUS
00:BBB7 D0F6            	   422:          BNE  SIM7
00:BBB9 A904            	   423: SIM6     LDA  #PCODE_ADD          ; PLUS
00:BBBB D0F2            	   424:          BNE  SIM7
00:BBBD 20DDBB          	   425: SIM2     JSR  TERM
00:BBC0 4C86BB          	   426:          JMP  SIM3
00:BBC3 A93A            	   427: SIM8     LDA  #PCODE_XOR         ; XOR
00:BBC5 D0E8            	   428:          BNE  SIM7
                        	   429: ;
                        	   430: ; TERM
                        	   431: ;
00:BBC7 2A              	   432: TERMT1   ASC    '*'
00:BBC8 EABB            	   433:          word   TERM1
00:BBCA 8B              	   434:          DFB    TOKEN_DIV    ; div
00:BBCB EABB            	   435:          word   TERM1
00:BBCD 2F              	   436:          ASC    '/'
00:BBCE EABB            	   437:          word   TERM1
00:BBD0 8D              	   438:          DFB    TOKEN_AND    ; and
00:BBD1 EABB            	   439:          word   TERM1
00:BBD3 8C              	   440:          DFB    TOKEN_MOD    ; mod
00:BBD4 EABB            	   441:          word   TERM1
00:BBD6 8E              	   442:          DFB    TOKEN_SHL    ; shl
00:BBD7 EABB            	   443:          word   TERM1
00:BBD9 8F              	   444:          DFB    TOKEN_SHR    ; shr
00:BBDA EABB            	   445:          word   TERM1
00:BBDC 00              	   446:          DFB    0
                        	   447: ;
00:BBDD 202BBC          	   448: TERM     JSR  FACTOR
00:BBE0 A2C7            	   449: TERM2    LDX  #<TERMT1
00:BBE2 A0BB            	   450:          LDY  #>TERMT1
00:BBE4 A593            	   451:          LDA  token_type
00:BBE6 20928F          	   452:          JSR  TKNJMP
00:BBE9 60              	   453:          RTS
                        	   454: ;
00:BBEA 48              	   455: TERM1    PHA
00:BBEB 20A3CE          	   456:          JSR  pas_get_token
00:BBEE 202BBC          	   457:          JSR  FACTOR
00:BBF1 68              	   458:          PLA
00:BBF2 A215            	   459:          LDX  #<TERMT3
00:BBF4 A0BC            	   460:          LDY  #>TERMT3
00:BBF6 20928F          	   461:          JSR  TKNJMP
                        	   462: ;
00:BBF9 A90A            	   463: TERM4    LDA  #PCODE_DIV       ; Divide (sp - 1) / (sp)
00:BBFB 20CBC6          	   464: TERM3    JSR  GENNOP
00:BBFE 4CE0BB          	   465:          JMP  TERM2
00:BC01 A91B            	   466: TERM5    LDA  #PCODE_AND        ; AND
00:BC03 D0F6            	   467:          BNE  TERM3
00:BC05 A90B            	   468: TERM6    LDA  #PCODE_MOD        ; MOD
00:BC07 D0F2            	   469:          BNE  TERM3
00:BC09 A922            	   470: TERM7    LDA  #PCODE_SHL       ; Shift left (sp) bits
00:BC0B D0EE            	   471:          BNE  TERM3
00:BC0D A924            	   472: TERM8    LDA  #PCODE_SHR       ; Shift right (sp) bits
00:BC0F D0EA            	   473:          BNE  TERM3
00:BC11 A908            	   474: TERM9    LDA  #PCODE_MUL        ; Multiply (sp) * (sp - 1)
00:BC13 D0E6            	   475:          BNE  TERM3
                        	   476: ;
00:BC15 8B              	   477: TERMT3   DFB    TOKEN_DIV     ; div
00:BC16 F9BB            	   478:          word   TERM4
00:BC18 2F              	   479:          ASC    '/'
00:BC19 F9BB            	   480:          word   TERM4
00:BC1B 8D              	   481:          DFB    TOKEN_AND     ; and
00:BC1C 01BC            	   482:          word   TERM5
00:BC1E 8C              	   483:          DFB    TOKEN_MOD     ; mod
00:BC1F 05BC            	   484:          word   TERM6
00:BC21 8E              	   485:          DFB    TOKEN_SHL     ; shl
00:BC22 09BC            	   486:          word   TERM7
00:BC24 8F              	   487:          DFB    TOKEN_SHR     ; shr
00:BC25 0DBC            	   488:          word   TERM8
00:BC27 2A              	   489:          ASC    '*'
00:BC28 11BC            	   490:          word   TERM9
00:BC2A 00              	   491:          DFB  0
                        	   492: ;
                        	   493: ; FACTOR
                        	   494: ;
00:BC2B 2027BB          	   495: FACTOR   JSR  CHK_STAK
00:BC2E A593            	   496:          LDA  token_type
00:BC30 A213            	   497:          LDX  #<FACTB1
00:BC32 A0BD            	   498:          LDY  #>FACTB1
00:BC34 20928F          	   499:          JSR  TKNJMP
00:BC37 A217            	   500:          LDX  #23     ; ERROR: Illegal factor
00:BC39 4C6497          	   501:          jmp  ERROR
                        	   502: ;
00:BC3C 2095B9          	   503: IDENT    JSR  LOOKUP
00:BC3F C950            	   504: IDENT1   CMP  #SYMBOL_PROCEDURE
00:BC41 F004            	   505:          beq  IDENT1A
00:BC43 C951            	   506:          CMP  #SYMBOL_LIBRARY_PROCEDURE
00:BC45 D005            	   507:          BNE  IDENT2
                        	   508: IDENT1A:
00:BC47 A215            	   509:          LDX  #21     ; ERROR: Use of procedure Identifier in expression
00:BC49 4C6497          	   510:          jmp  ERROR
00:BC4C C959            	   511: IDENT2   CMP  #SYMBOL_FUNCTION_RETURN
00:BC4E D015            	   512:          BNE  IDENT2A
00:BC50 A000            	   513:          LDY  #SYMPRV      ; this symbol is actually the function return value symbol
00:BC52 B140            	   514:          LDA  (SYMITM),Y   ; so go to the previous symbol which will be the function
00:BC54 AA              	   515:          TAX               ; declaration symbol with the address of the function to be called
00:BC55 C8              	   516:          INY
00:BC56 B140            	   517:          LDA  (SYMITM),Y
00:BC58 8541            	   518:          STA  SYMITM+1
00:BC5A 8A              	   519:          TXA
00:BC5B 8540            	   520:          STA  SYMITM
00:BC5D A980            	   521:          lda  #$80       ; push 0 onto the stack which will be the default function return value
00:BC5F 20CBC6          	   522:          jsr  GENNOP     ; when the function returns this will be left on the top of the stack
00:BC62 4CACBF          	   523:          JMP  FNCPRC     ; with the function's assigned value in it (or zero if nothing assigned);
                        	   524: 
00:BC65 C952            	   525: IDENT2A  CMP #SYMBOL_LIBRARY_FUNCTION
00:BC67 D003            	   526:          bne IDENT3
00:BC69 4C7BC6          	   527:          jmp  library_function_call
                        	   528: 
00:BC6C C941            	   529: IDENT3   CMP  #SYMBOL_ARRAY
00:BC6E F030            	   530:          BEQ  IDENT4
00:BC70 C943            	   531:          CMP  #SYMBOL_CONSTANT
00:BC72 D00E            	   532:          BNE  IDENT5
00:BC74 20FEBA          	   533:          JSR  VAL_MOVE
00:BC77 4C95BC          	   534:          JMP  IDENT7
                        	   535: ;
                        	   536: ;   Here for address of integer variable
                        	   537: ;
00:BC7A A90C            	   538: FACAD1   LDA  #PCODE_ADRNN
00:BC7C 2084BC          	   539:          JSR  IDENT5_A
00:BC7F 4C08BA          	   540:          JMP  CHKRHP
                        	   541: ;
00:BC82 A92C            	   542: IDENT5   LDA  #PCODE_LOD   ; load integer onto stack
00:BC84 48              	   543: IDENT5_A PHA
                        	   544: ;
00:BC85 8636            	   545:          STX  BSAVE
00:BC87 A522            	   546:          LDA  LEVEL
00:BC89 38              	   547:          SEC
00:BC8A E536            	   548:          SBC  BSAVE
00:BC8C 8527            	   549:          STA  DISPL
00:BC8E 68              	   550:          PLA
00:BC8F 18              	   551: IDENT6   CLC
00:BC90 654A            	   552:          ADC  DATTYP
00:BC92 20E4C6          	   553:          JSR  GENADR
00:BC95 4CA3CE          	   554: IDENT7   JMP  pas_get_token
                        	   555: ;
00:BC98 A90E            	   556: FACAD2   LDA  #PCODE_ADRAN  ; address of integer array
00:BC9A 20A2BC          	   557:          JSR  IDENT4_A
00:BC9D 4C08BA          	   558:          JMP  CHKRHP
                        	   559: ;
                        	   560: ;    Here for load indexed integer
                        	   561: ;
00:BCA0 A930            	   562: IDENT4   LDA  #PCODE_LDI         ; Load integer indexed
00:BCA2 48              	   563: IDENT4_A PHA
                        	   564: ;
00:BCA3 206BBA          	   565:          JSR  SYMWRK
00:BCA6 205F92          	   566:          JSR  PSHWRK
00:BCA9 2012BA          	   567:          JSR  GETSUB
00:BCAC 207292          	   568:          JSR  PULWRK
00:BCAF 2076BA          	   569:          JSR  WRKSYM
00:BCB2 2039BA          	   570:          JSR  GET_DAT
00:BCB5 202FBA          	   571:          JSR  GET_LEV
00:BCB8 2094BA          	   572:          JSR  GET_OFF
00:BCBB 68              	   573:          PLA
00:BCBC 18              	   574:          CLC
00:BCBD 654A            	   575:          ADC  DATTYP
00:BCBF 4CE4C6          	   576:          JMP  GENADR
                        	   577: ;
                        	   578: ; ADDRESS (IDENTIFIER)
                        	   579: ;
                        	   580: ;
                        	   581: FACADR   =  *
00:BCC2 2001BA          	   582:          JSR  CHKLHP
00:BCC5 200CCF          	   583:          JSR  GET_LOOK
00:BCC8 C956            	   584:          CMP  #SYMBOL_VARIABLE
00:BCCA F0AE            	   585:          BEQ  FACAD1
00:BCCC C941            	   586:          CMP  #SYMBOL_ARRAY
00:BCCE F0C8            	   587:          BEQ  FACAD2
00:BCD0 A217            	   588:          LDX  #23     ; ERROR: Illegal factor
00:BCD2 4C6497          	   589:          jmp  ERROR
                        	   590: ;
                        	   591: ;
00:BCD5 A592            	   592: FACSTR   LDA  token_length
00:BCD7 C904            	   593:          CMP  #4
00:BCD9 9005            	   594:          BCC  FACNUM    ; BLT
00:BCDB A21D            	   595: FACERR1  LDX  #29        ; ERROR: string literal too big
00:BCDD 4C6497          	   596:          jmp  ERROR
                        	   597: FACNUM   =  *
00:BCE0 20FEBA          	   598:          JSR  VAL_MOVE
00:BCE3 4C95BC          	   599:          JMP  IDENT7
                        	   600: ;
00:BCE6 20BFBA          	   601: PAREN    JSR  GETEXPR
00:BCE9 4C08BA          	   602:          JMP  CHKRHP
                        	   603: ;
00:BCEC A900            	   604: FACMEM   LDA  #0          ; add zero below to get PCODE_LDA
00:BCEE 854A            	   605:          STA  DATTYP
00:BCF0 F004            	   606:          BEQ  FACM2
00:BCF2 A901            	   607: FACMMC   LDA  #1          ; add one below to get PCODE_LDAC
00:BCF4 854A            	   608:          STA  DATTYP
00:BCF6 A54A            	   609: FACM2    LDA  DATTYP
00:BCF8 48              	   610:          PHA
00:BCF9 2012BA          	   611:          JSR  GETSUB
00:BCFC 68              	   612:          PLA
00:BCFD 18              	   613:          CLC
00:BCFE 692E            	   614:          ADC  #PCODE_LDA    ; Load absolute address integer or PCODE_LDAC if we added 1
00:BD00 D008            	   615:          BNE  GENNOP1
                        	   616: ;
00:BD02 20A3CE          	   617: FACNOT   JSR  pas_get_token
00:BD05 202BBC          	   618:          JSR  FACTOR
00:BD08 A920            	   619:          LDA  #PCODE_EOR     ; Not (sp) (logical negate)
00:BD0A 4CCBC6          	   620: GENNOP1  JMP  GENNOP
                        	   621: ;
00:BD0D 20CBC6          	   622: FACRND1  JSR  GENNOP
00:BD10 4CA3CE          	   623:          JMP  pas_get_token
                        	   624: ;
                        	   625: ;
                        	   626: ;
00:BD13 49              	   627: FACTB1   DFB    TOKEN_IDENTIFIER
00:BD14 3CBC            	   628:          word   IDENT
00:BD16 4E              	   629:          ASC    TOKEN_NUMBER
00:BD17 E0BC            	   630:          word   FACNUM
00:BD19 22              	   631: FACTQT1  DFB    TOKEN_STRING        ; QUOTE SYMBOL
00:BD1A D5BC            	   632:          word   FACSTR
00:BD1C 28              	   633:          ASC    '('
00:BD1D E6BC            	   634:          word   PAREN
00:BD1F 91              	   635:          DFB    TOKEN_MEM
00:BD20 ECBC            	   636:          word   FACMEM     ; MEM
00:BD22 90              	   637:          DFB    TOKEN_NOT
00:BD23 02BD            	   638:          word   FACNOT
00:BD25 A2              	   639:          DFB    TOKEN_MEMC
00:BD26 F2BC            	   640:          word   FACMMC     ; MEMC
00:BD28 A9              	   641:          DFB    TOKEN_ADDRESS
00:BD29 C2BC            	   642:          word   FACADR
00:BD2B 00              	   643:          DFB  0
                        	   644: ;
                        	   645: ; EXPRESSION
                        	   646: ;
00:BD2C 2027BB          	   647: EXPRES   JSR  CHK_STAK
00:BD2F 206BBB          	   648:          JSR  SIMEXP
00:BD32 A593            	   649:          LDA  token_type
00:BD34 A23C            	   650:          LDX  #<EXPTB1
00:BD36 A0BD            	   651:          LDY  #>EXPTB1
00:BD38 20928F          	   652:          JSR  TKNJMP
00:BD3B 60              	   653:          RTS
                        	   654: ;
00:BD3C 3D              	   655: EXPTB1   ASC    '='
00:BD3D 4FBD            	   656:          word   EXPR1
00:BD3F 55              	   657:          DFB    TOKEN_NEQ
00:BD40 4FBD            	   658:          word   EXPR1
00:BD42 3C              	   659:          ASC    '<'
00:BD43 4FBD            	   660:          word   EXPR1
00:BD45 80              	   661:          DFB    TOKEN_LEQ
00:BD46 4FBD            	   662:          word   EXPR1
00:BD48 81              	   663:          DFB    TOKEN_GEQ
00:BD49 4FBD            	   664:          word   EXPR1
00:BD4B 3E              	   665:          ASC    '>'
00:BD4C 4FBD            	   666:          word   EXPR1
00:BD4E 00              	   667:          DFB  0
                        	   668: ;
00:BD4F 48              	   669: EXPR1    PHA
00:BD50 20A3CE          	   670:          JSR  pas_get_token
00:BD53 206BBB          	   671:          JSR  SIMEXP
00:BD56 68              	   672:          PLA
00:BD57 A25E            	   673:          LDX  #<EXPTB3
00:BD59 A0BD            	   674:          LDY  #>EXPTB3
00:BD5B 20928F          	   675:          JSR  TKNJMP
                        	   676: ;
00:BD5E 3D              	   677: EXPTB3   ASC    '='
00:BD5F 71BD            	   678:          word   EXPR2
00:BD61 55              	   679:          ASC    TOKEN_NEQ
00:BD62 77BD            	   680:          word   EXPR3
00:BD64 3C              	   681:          ASC    '<'
00:BD65 7BBD            	   682:          word   EXPR4
00:BD67 81              	   683:          DFB    TOKEN_GEQ
00:BD68 7FBD            	   684:          word   EXPR5
00:BD6A 3E              	   685:          ASC    '>'
00:BD6B 83BD            	   686:          word   EXPR6
00:BD6D 80              	   687:          DFB    TOKEN_LEQ
00:BD6E 87BD            	   688:          word   EXPR7
00:BD70 00              	   689:          DFB  0
                        	   690: ;
00:BD71 A910            	   691: EXPR2    LDA  #PCODE_EQL       ; EQL     	Test (sp - 1) == (sp)
00:BD73 20CBC6          	   692: EXPR8    JSR  GENNOP
00:BD76 60              	   693:          RTS
00:BD77 A912            	   694: EXPR3    LDA  #PCODE_NEQ       ; NEQ     	Test (sp - 1) != (sp)
00:BD79 D0F8            	   695:          BNE  EXPR8
00:BD7B A914            	   696: EXPR4    LDA  #PCODE_LSS       ; LSS     	Test (sp - 1) < (sp)
00:BD7D D0F4            	   697:          BNE  EXPR8
00:BD7F A916            	   698: EXPR5    LDA  #PCODE_GEQ       ; GEQ     	Test (sp - 1) >= (sp)
00:BD81 D0F0            	   699:          BNE  EXPR8
00:BD83 A918            	   700: EXPR6    LDA  #PCODE_GTR       ; GTR     	Test (sp - 1) > (sp)
00:BD85 D0EC            	   701:          BNE  EXPR8
00:BD87 A919            	   702: EXPR7    LDA  #PCODE_LEQ       ; LEQ     	Test (sp - 1) <= (sp)
00:BD89 D0E8            	   703:          BNE  EXPR8
                        	   704: ;
                        	   705: ; STATEMENT
                        	   706: ;
00:BD8B 2027BB          	   707: STMNT    JSR  CHK_STAK
00:BD8E A593            	   708:          LDA  token_type
00:BD90 A298            	   709:          LDX  #<STMNT1
00:BD92 A0BD            	   710:          LDY  #>STMNT1
00:BD94 20928F          	   711:          JSR  TKNJMP
00:BD97 60              	   712:          RTS
                        	   713: ;
00:BD98 49              	   714: STMNT1   DFB    TOKEN_IDENTIFIER
00:BD99 C3BD            	   715:          word   ASSIGN
00:BD9B 92              	   716:          DFB    TOKEN_IF
00:BD9C 33C0            	   717:          word   IF
00:BD9E 9A              	   718:          DFB    TOKEN_FOR
00:BD9F 9AC1            	   719:          word   FOR
00:BDA1 96              	   720:          DFB    TOKEN_WHILE
00:BDA2 ADC0            	   721:          word   WHILE
00:BDA4 95              	   722:          DFB    TOKEN_CASE
00:BDA5 DFC0            	   723:          word   CASE
00:BDA7 98              	   724:          DFB    TOKEN_REPEAT
00:BDA8 89C0            	   725:          word   REPEAT
00:BDAA 88              	   726:          DFB    TOKEN_BEGIN
00:BDAB 73C0            	   727:          word   BEG
00:BDAD 9E              	   728:          DFB    TOKEN_READ
00:BDAE DBBE            	   729:          word   READ
00:BDB0 9D              	   730:          DFB    TOKEN_WRITE
00:BDB1 39BE            	   731:          word   WRITE
00:BDB3 91              	   732:          DFB    TOKEN_MEM
00:BDB4 84BF            	   733:          word   MEM
00:BDB6 9F              	   734:          DFB    TOKEN_CALL
00:BDB7 9FBF            	   735:          word   CALLSB
00:BDB9 A2              	   736:          DFB    TOKEN_MEMC
00:BDBA 89BF            	   737:          word   MEMC
00:BDBC FF              	   738:          DFB    TOKEN_WRITELN
00:BDBD 2ABE            	   739:          word   WRITELN
00:BDBF F1              	   740:          DB     TOKEN_LCDWRITE
00:BDC0 8ABE            	   741:          word   STMNT_WRITE_LCD
00:BDC2 00              	   742:          DFB  0
                        	   743: ;
                        	   744: ; ASSIGNMENT - this is where we store an integer/char into a variable or array index
                        	   745: ;
00:BDC3 2095B9          	   746: ASSIGN   JSR  LOOKUP
00:BDC6 A2D2            	   747: ASS1     LDX  #<ASSTB1
00:BDC8 A0BD            	   748:          LDY  #>ASSTB1
00:BDCA 20928F          	   749:          JSR  TKNJMP
00:BDCD A218            	   750:          LDX  #24     ; ERROR: Type mismatch
00:BDCF 4C6497          	   751:          jmp  ERROR
                        	   752: ;
00:BDD2 41              	   753: ASSTB1   DFB   SYMBOL_ARRAY
00:BDD3 EDBD            	   754:          word  ASSARR
00:BDD5 56              	   755:          DFB   SYMBOL_VARIABLE
00:BDD6 FFBD            	   756:          word  ASSVAR
00:BDD8 59              	   757:          DFB   SYMBOL_FUNCTION_RETURN
00:BDD9 FFBD            	   758:          word  ASSVAR
00:BDDB 50              	   759:          DFB   SYMBOL_PROCEDURE
00:BDDC ACBF            	   760:          word  FNCPRC
00:BDDE 51              	   761:          DFB   SYMBOL_LIBRARY_PROCEDURE
00:BDDF 7BC6            	   762:          word  library_function_call
00:BDE1 46              	   763:          DFB   SYMBOL_FUNCTION
00:BDE2 E8BD            	   764:          word  assign_bad_identifier
00:BDE4 52              	   765:          DFB   SYMBOL_LIBRARY_FUNCTION
00:BDE5 E8BD            	   766:          word  assign_bad_identifier
00:BDE7 00              	   767:          DFB  0
                        	   768: 
                        	   769: assign_bad_identifier:
00:BDE8 A235            	   770:           ldx #53   ; ERROR: Use of function identifier in statement
00:BDEA 4C6497          	   771:           jmp ERROR
                        	   772: ;
00:BDED 206BBA          	   773: ASSARR   JSR  SYMWRK
00:BDF0 205F92          	   774:          JSR  PSHWRK
00:BDF3 A936            	   775:          LDA  #PCODE_STI    ; Store integer indexed
00:BDF5 18              	   776:          CLC
00:BDF6 654A            	   777:          ADC  DATTYP        ; A becomes PCODE_STIC (Store character indexed) if DATTYP == 1
00:BDF8 48              	   778:          PHA
00:BDF9 2012BA          	   779:          JSR  GETSUB
00:BDFC 4C0EBE          	   780:          JMP  ASS2
                        	   781: ;
00:BDFF 206BBA          	   782: ASSVAR   JSR  SYMWRK
00:BE02 205F92          	   783:          JSR  PSHWRK
00:BE05 A932            	   784:          LDA  #PCODE_STO    ;  Store integer
00:BE07 18              	   785:          CLC
00:BE08 654A            	   786:          ADC  DATTYP        ; A becomes PCODE_STOC (Store character indexed) if DATTYP == 1
00:BE0A 48              	   787:          PHA
00:BE0B 20A3CE          	   788:          JSR  pas_get_token
00:BE0E A941            	   789: ASS2     LDA  #TOKEN_ASSIGN
00:BE10 A20D            	   790:          LDX  #13       ; ERROR: := expected
00:BE12 2007CF          	   791:          JSR  CHKTKN
00:BE15 20BFBA          	   792:          JSR  GETEXPR
00:BE18 68              	   793:          PLA
00:BE19 207292          	   794:          JSR  PULWRK
00:BE1C 2076BA          	   795:          JSR  WRKSYM
00:BE1F 48              	   796:          PHA
00:BE20 202FBA          	   797:          JSR  GET_LEV
00:BE23 2094BA          	   798:          JSR  GET_OFF
00:BE26 68              	   799:          PLA
00:BE27 4CE4C6          	   800:          JMP  GENADR
                        	   801: ;
                        	   802: 
                        	   803: ;
                        	   804: ;
                        	   805: ; WRITELN
                        	   806: ;
00:BE2A 20A3CE          	   807: WRITELN  JSR  pas_get_token     ; SEE IF ( PRESENT
00:BE2D C928            	   808:          CMP  #'('
00:BE2F D003            	   809:          BNE  WRITELN9   ; NOPE
00:BE31 203CBE          	   810:          JSR  WRIT9
                        	   811: WRITELN9 =  *
00:BE34 A940            	   812:          LDA  #PCODE_OUTCR   ; OUTPUT C/R
00:BE36 4CCBC6          	   813:          JMP  GENNOP
                        	   814: ;
                        	   815: ;
                        	   816: ; WRITE
                        	   817: ;
00:BE39 2001BA          	   818: WRITE    JSR  CHKLHP
00:BE3C 20A3CE          	   819: WRIT9    JSR  pas_get_token
00:BE3F C922            	   820:          CMP  #TOKEN_STRING
00:BE41 D022            	   821:          BNE  WRIT1
00:BE43 A923            	   822:          LDA  #PCODE_OUS    ; Output string
00:BE45 204BBE          	   823:          JSR  W_STRING
00:BE48 4C75BE          	   824:          JMP  WRIT5
                        	   825: ;
                        	   826: W_STRING =  *
00:BE4B 20CBC6          	   827:          JSR  GENNOP
00:BE4E A592            	   828:          LDA  token_length
00:BE50 20CBC6          	   829:          JSR  GENNOP
00:BE53 A000            	   830:          LDY  #0
00:BE55 B90002          	   831: WRIT2    LDA  INBUF,Y
00:BE58 C8              	   832: WRIT10   INY
00:BE59 5A              	   833:          phy
00:BE5A 20CBC6          	   834:          JSR  GENNOP
00:BE5D 7A              	   835:          ply
00:BE5E C692            	   836:          DEC  token_length
00:BE60 D0F3            	   837:          BNE  WRIT2
00:BE62 4CA3CE          	   838:          JMP  pas_get_token
                        	   839: ;
                        	   840: WRIT1    =  *          ; here if not string
00:BE65 C9AB            	   841:          CMP  #TOKEN_CHR       ; CHR?
00:BE67 F015            	   842:          BEQ  W_CHR      ; yes
00:BE69 C9AC            	   843:          CMP  #TOKEN_HEX       ; HEX?
00:BE6B F019            	   844:          BEQ  W_HEX      ; yes
00:BE6D 202CBD          	   845:          JSR  EXPRES     ; just ordinary number - get it
00:BE70 A91E            	   846:          LDA  #PCODE_OUT        ; OUT     	Output number
00:BE72 20CBC6          	   847:          JSR  GENNOP
00:BE75 A593            	   848: WRIT5    LDA  token_type
00:BE77 C92C            	   849:          CMP  #','
00:BE79 F0C1            	   850:          BEQ  WRIT9
00:BE7B 4C08BA          	   851:          JMP  CHKRHP
                        	   852: ;
                        	   853: ; here for write (chr(x))
                        	   854: ;
                        	   855: W_CHR    =  *
00:BE7E A91F            	   856:          LDA  #PCODE_OUTC   ; OUTC    	Output character
                        	   857: W_CHR1   =  *
00:BE80 207ABF          	   858:          JSR  WAIT_1     ; process expression in parentheses
00:BE83 4C75BE          	   859:          JMP  WRIT5      ; back for next item
                        	   860: ;
                        	   861: ; here for write (hex(x))
                        	   862: ;
                        	   863: W_HEX    =  *
00:BE86 A921            	   864:          LDA  #PCODE_OUH        ; OUH     	Output hex number
00:BE88 D0F6            	   865:          BNE  W_CHR1
                        	   866: 
                        	   867: ;
                        	   868: ;
                        	   869: ; WRITELCD: can write number, string, hex or chr
                        	   870: ;
00:BE8A 2001BA          	   871: STMNT_WRITE_LCD    JSR  CHKLHP
00:BE8D 20A3CE          	   872: WRITE_LCD9    JSR  pas_get_token
00:BE90 C922            	   873:          CMP  #TOKEN_STRING
00:BE92 D022            	   874:          BNE  WRITE_LCD1
00:BE94 A943            	   875:          LDA  #PCODE_LCD_WRITE_STR    ; Output string
00:BE96 209CBE          	   876:          JSR  WRITE_LCD_STRING
00:BE99 4CC6BE          	   877:          JMP  WRITE_LCD5
                        	   878: ;
                        	   879: WRITE_LCD_STRING =  *
00:BE9C 20CBC6          	   880:          JSR  GENNOP
00:BE9F A592            	   881:          LDA  token_length
00:BEA1 20CBC6          	   882:          JSR  GENNOP
00:BEA4 A000            	   883:          LDY  #0
00:BEA6 B90002          	   884: WRITE_LCD2    LDA  INBUF,Y    ; strings are placed in INBUF during parsing
00:BEA9 C8              	   885:          INY
00:BEAA 5A              	   886:          phy
00:BEAB 20CBC6          	   887:          JSR  GENNOP
00:BEAE 7A              	   888:          ply
00:BEAF C692            	   889:          DEC  token_length
00:BEB1 D0F3            	   890:          BNE  WRITE_LCD2
00:BEB3 4CA3CE          	   891:          JMP  pas_get_token
                        	   892: ;
                        	   893: WRITE_LCD1    =  *            ; here if not string
00:BEB6 C9AB            	   894:          CMP  #TOKEN_CHR      ; CHR?
00:BEB8 F015            	   895:          BEQ  WRITE_LDC_CHR   ; yes
00:BEBA C9AC            	   896:          CMP  #TOKEN_HEX      ; HEX?
00:BEBC F019            	   897:          BEQ  WRITE_LDC_HEX   ; yes
00:BEBE 202CBD          	   898:          JSR  EXPRES          ; just ordinary number - get it
00:BEC1 A942            	   899:          LDA  #PCODE_LCD_WRITE_NUM        ; OUT     	Output number
00:BEC3 20CBC6          	   900:          JSR  GENNOP
00:BEC6 A593            	   901: WRITE_LCD5    LDA  token_type
00:BEC8 C92C            	   902:          CMP  #','
00:BECA F0C1            	   903:          BEQ  WRITE_LCD9
00:BECC 4C08BA          	   904:          JMP  CHKRHP
                        	   905: ;
                        	   906: ; here for lcdwrite (chr(x))
                        	   907: ;
                        	   908: WRITE_LDC_CHR    =  *
00:BECF A945            	   909:          LDA  #PCODE_LCD_WRITE_CHR   ; OUTC    	Output character
                        	   910: WRITE_LDC_CHR1   =  *
00:BED1 207ABF          	   911:          JSR  WAIT_1          ; process expression in parentheses
00:BED4 4CC6BE          	   912:          JMP  WRITE_LCD5      ; back for next item
                        	   913: ;
                        	   914: ; here for lcdwrite (hex(x))
                        	   915: ;
                        	   916: WRITE_LDC_HEX    =  *
00:BED7 A944            	   917:          LDA  #PCODE_LCD_WRITE_HEX        ; OUH     	Output hex number
00:BED9 D0F6            	   918:          BNE  WRITE_LDC_CHR1
                        	   919: 
                        	   920: ;
                        	   921: ;
                        	   922: ; READ
                        	   923: ;
00:BEDB 2001BA          	   924: READ     jsr  CHKLHP    ; check for "("
00:BEDE 200CCF          	   925: READ8    jsr  GET_LOOK
00:BEE1 206BBA          	   926: READ2    jsr  SYMWRK      ; SYMITM --> WORK
00:BEE4 205F92          	   927:          jsr  PSHWRK
00:BEE7 A200            	   928:          ldx  #0
00:BEE9 864B            	   929:          stx  COUNT1      ; this will have 1 in it if we are reading into an array element
00:BEEB C941            	   930:          cmp  #SYMBOL_ARRAY
00:BEED F03B            	   931:          beq  READ3
00:BEEF C956            	   932:          cmp  #SYMBOL_VARIABLE
00:BEF1 F005            	   933:          beq  READ9
00:BEF3 A20C            	   934:          ldx  #12     ; ERROR: Illegal Identifier
00:BEF5 4C6497          	   935:          jmp  ERROR
                        	   936: 
00:BEF8 20F5C8          	   937: READ9    jsr get_token
00:BEFB A91C            	   938: READ11   lda  #PCODE_INP  ; Input number
00:BEFD 18              	   939:          clc
00:BEFE 654A            	   940:          adc  DATTYP      ; becomes PCODE_INPC (input character) if DATTYP == 1
00:BF00 20CBC6          	   941:          jsr  GENNOP
00:BF03 207292          	   942:          jsr  PULWRK
00:BF06 2076BA          	   943:          jsr  WRKSYM      ; WORK --> SYMITM
00:BF09 2039BA          	   944:          jsr  GET_DAT
00:BF0C 202FBA          	   945:          jsr  GET_LEV
00:BF0F 2094BA          	   946:          jsr  GET_OFF
00:BF12 A932            	   947:          lda  #PCODE_STO    ; Store integer
00:BF14 A64B            	   948:          ldx  COUNT1
00:BF16 F002            	   949:          beq  READ7
00:BF18 A936            	   950:          lda  #PCODE_STI    ; Store integer indexed
00:BF1A 18              	   951: READ7    clc
00:BF1B 654A            	   952:          adc  DATTYP        ; add 1 if a char to become PCODE_STOC / PCODE_STIC
00:BF1D 20E4C6          	   953:          jsr  GENADR
00:BF20 A593            	   954: READ7_A  lda  token_type
00:BF22 C92C            	   955:          cmp  #','
00:BF24 F0B8            	   956:          beq  READ8         ; get another variable to read into
                        	   957: ;
                        	   958: ;  done with READ statement
                        	   959: ;
00:BF26 2008BA          	   960:          jsr  CHKRHP        ; check for ")"
00:BF29 60              	   961:          rts
                        	   962: ;
                        	   963: ;  here for reading into an array
                        	   964: ;
00:BF2A A54A            	   965: READ3    lda  DATTYP
00:BF2C 48              	   966:          pha              ; push data type of array
00:BF2D 20A3CE          	   967:          jsr  pas_get_token
00:BF30 C95B            	   968:          cmp  #'['
00:BF32 F025            	   969:          beq  READ3_A
00:BF34 68              	   970:          pla            ; get back data type of array
00:BF35 854A            	   971:          sta  DATTYP    ; 0 = integer, 1 = char
00:BF37 D005            	   972:          bne  READ3_B
00:BF39 A218            	   973:          ldx  #24       ; ERROR: Type mismatch (cannot read into array of integer)
00:BF3B 4C6497          	   974:          jmp  ERROR
00:BF3E 207292          	   975: READ3_B  jsr  PULWRK
00:BF41 2076BA          	   976:          jsr  WRKSYM     ; WORK --> SYMITM
00:BF44 A925            	   977:          lda  #PCODE_INS        ; READ STRING - Input string into array
00:BF46 20CBC6          	   978:          jsr  GENNOP
00:BF49 202FBA          	   979:          jsr  GET_LEV
00:BF4C 2094BA          	   980:          jsr  GET_OFF
00:BF4F A006            	   981:          ldy  #SYMSUB
00:BF51 B140            	   982:          lda  (SYMITM),Y  ; maximum array size
00:BF53 20E4C6          	   983:          jsr  GENADR     ; A = length, not the P-code which we just output above
00:BF56 4C20BF          	   984:          jmp  READ7_A
                        	   985: ;
                        	   986: ;  read into subscripted item
                        	   987: ;
00:BF59 20BFBA          	   988: READ3_A  jsr  GETEXPR   ; subscript
00:BF5C 2025BA          	   989:          jsr  CHKRHB    ; check for "]"
00:BF5F E64B            	   990:          inc  COUNT1    ; flag for reading into array element
00:BF61 68              	   991:          pla            ; get back data type of array
00:BF62 854A            	   992:          sta  DATTYP    ; save
00:BF64 4CFBBE          	   993:          jmp  READ11
                        	   994: ;
                        	   995: 
                        	   996: ;
                        	   997: ;
00:BF67 2001BA          	   998: TWO_OP   JSR  CHKLHP
00:BF6A 20BFBA          	   999:          JSR  GETEXPR
00:BF6D 20F8BA          	  1000: ONE_OP2  JSR  GET_ITEM
00:BF70 2008BA          	  1001: ONE_OP   JSR  CHKRHP
00:BF73 68              	  1002:          PLA
00:BF74 4CCBC6          	  1003:          JMP  GENNOP
                        	  1004: 
                        	  1005: 
                        	  1006: 
00:BF77 4CCBC6          	  1007: GENNOP2  JMP  GENNOP
                        	  1008: ;
                        	  1009: 
00:BF7A 48              	  1010: WAIT_1   PHA
00:BF7B 2001BA          	  1011:          JSR  CHKLHP
00:BF7E 20BFBA          	  1012:          JSR  GETEXPR
00:BF81 4C70BF          	  1013:          JMP  ONE_OP
                        	  1014: ;
                        	  1015: ; MEM
                        	  1016: ;
00:BF84 A900            	  1017: MEM      LDA  #0        ; integer
00:BF86 48              	  1018:          PHA
00:BF87 F003            	  1019:          BEQ  MEM2
00:BF89 A901            	  1020: MEMC     LDA  #1        ; character
00:BF8B 48              	  1021:          PHA
00:BF8C 2012BA          	  1022: MEM2     JSR  GETSUB
00:BF8F A941            	  1023:          LDA  #TOKEN_ASSIGN
00:BF91 A20D            	  1024:          LDX  #13     ; ERROR: := expected
00:BF93 2007CF          	  1025:          JSR  CHKTKN
00:BF96 20BFBA          	  1026:          JSR  GETEXPR
00:BF99 68              	  1027:          PLA
00:BF9A 18              	  1028:          CLC
00:BF9B 6934            	  1029:          ADC  #PCODE_STA     ; Store integer absolute address (or PCODE_STAC if A == 1)
00:BF9D D0D8            	  1030:          BNE  GENNOP2
                        	  1031: ;
                        	  1032: ; CALL ABSOLUTE ADDRESS
                        	  1033: ;
00:BF9F 2001BA          	  1034: CALLSB   JSR  CHKLHP
00:BFA2 20BFBA          	  1035:          JSR  GETEXPR
00:BFA5 2008BA          	  1036:          JSR  CHKRHP
00:BFA8 A92B            	  1037:          LDA  #PCODE_CLA    ; Call absolute address
00:BFAA D0CB            	  1038:          BNE  GENNOP2
                        	  1039: ;
                        	  1040: ; FUNCTION OR PROCEDURE CALL
                        	  1041: ;
00:BFAC A900            	  1042: FNCPRC   LDA  #0
00:BFAE 854B            	  1043:          STA  COUNT1      ; number of arguments
00:BFB0 A006            	  1044:          LDY  #SYMARG
00:BFB2 B140            	  1045:          LDA  (SYMITM),Y
00:BFB4 F033            	  1046:          BEQ  FNC1
00:BFB6 2001BA          	  1047:          JSR  CHKLHP
00:BFB9 A54B            	  1048: FNC2     LDA  COUNT1    ; save on stack in case the expression calls functions
00:BFBB 48              	  1049:          PHA
00:BFBC 206BBA          	  1050:          JSR  SYMWRK
00:BFBF 205F92          	  1051:          JSR  PSHWRK
00:BFC2 20BFBA          	  1052:          JSR  GETEXPR
00:BFC5 207292          	  1053:          JSR  PULWRK
00:BFC8 2076BA          	  1054:          JSR  WRKSYM
00:BFCB 68              	  1055:          PLA            ; get number of arguments back
00:BFCC 854B            	  1056:          STA  COUNT1
00:BFCE E64B            	  1057:          INC  COUNT1    ; add 1 for the one we just processed
00:BFD0 A593            	  1058:          LDA  token_type
00:BFD2 C92C            	  1059:          CMP  #','
00:BFD4 F0E3            	  1060:          BEQ  FNC2
00:BFD6 A54B            	  1061:          LDA  COUNT1
00:BFD8 A006            	  1062:          LDY  #SYMARG
00:BFDA D140            	  1063:          CMP  (SYMITM),Y   ; check we got the right number of arguments
00:BFDC F005            	  1064:          BEQ  FNC3
00:BFDE A223            	  1065:          LDX  #35     ; ERROR: Parameters mismatched
00:BFE0 4C6497          	  1066:          jmp  ERROR
00:BFE3 2008BA          	  1067: FNC3     JSR  CHKRHP
00:BFE6 4CECBF          	  1068:          JMP  FNC5
00:BFE9 20A3CE          	  1069: FNC1     JSR  pas_get_token
00:BFEC 202FBA          	  1070: FNC5     JSR  GET_LEV
00:BFEF 2094BA          	  1071:          JSR  GET_OFF
00:BFF2 A008            	  1072:          LDY  #SYMDAT
00:BFF4 B140            	  1073:          LDA  (SYMITM),Y
00:BFF6 D011            	  1074:          BNE  FNC5A
00:BFF8 A529            	  1075:          LDA  OFFSET
00:BFFA 38              	  1076:          SEC
00:BFFB E523            	  1077:          SBC  PCODE         ; calculate relative procedure address
00:BFFD 8529            	  1078:          STA  OFFSET
00:BFFF A52A            	  1079:          LDA  OFFSET+1
00:C001 E524            	  1080:          SBC  PCODE+1
00:C003 852A            	  1081:          STA  OFFSET+1
00:C005 A927            	  1082:          LDA  #PCODE_CLL         ; Relative procedure/function call
00:C007 D002            	  1083:          BNE  FNC5B
00:C009 A938            	  1084: FNC5A    LDA  #PCODE_ABSCLL      ; Absolute procedure/function call
00:C00B 20E4C6          	  1085: FNC5B    JSR  GENADR
00:C00E A54B            	  1086:          LDA  COUNT1    ; number of arguments
00:C010 F01B            	  1087:          BEQ  FNC4
00:C012 A54B            	  1088:          LDA  COUNT1     ; TIMES 3
00:C014 0A              	  1089:          ASL             ; multiply by two then add one more COUNT1
00:C015 B017            	  1090:          BCS  FNC6
00:C017 654B            	  1091:          ADC  COUNT1
00:C019 854B            	  1092:          STA  COUNT1
00:C01B B011            	  1093:          BCS  FNC6
00:C01D A900            	  1094:          LDA  #0
00:C01F 38              	  1095:          SEC
00:C020 E54B            	  1096:          SBC  COUNT1
00:C022 852B            	  1097:          STA  OPND
00:C024 A9FF            	  1098:          LDA  #$FF
00:C026 852C            	  1099:          STA  OPND+1      ;  calculate: 0 - (number_of_arguments * 3)
00:C028 A93B            	  1100:          LDA  #PCODE_INT     ; Increment stack pointer (allow for arguments)
00:C02A 2054C7          	  1101:          JSR  GENJMP
00:C02D 60              	  1102: FNC4     RTS
00:C02E A20F            	  1103: FNC6     LDX  #15       ; ERROR: compiler limits exceeded
00:C030 4C6497          	  1104:          jmp  ERROR
                        	  1105: ;
                        	  1106: ;
                        	  1107: ; IF
                        	  1108: ;
00:C033 20BFBA          	  1109: IF       JSR  GETEXPR
00:C036 A993            	  1110:          LDA  #TOKEN_THEN
00:C038 A210            	  1111:          LDX  #16     ; ERROR: THEN expected
00:C03A 2007CF          	  1112:          JSR  CHKTKN
00:C03D 20A3CE          	  1113:          JSR  pas_get_token
00:C040 2081BA          	  1114:          JSR  PSHPCODE
00:C043 A93D            	  1115:          LDA  #PCODE_JMZ     ; JMZ     	Jump if (sp) zero
00:C045 204EC7          	  1116:          JSR  GENNJM
00:C048 208BBD          	  1117:          JSR  STMNT
00:C04B A593            	  1118:          LDA  token_type
00:C04D C994            	  1119:          CMP  #TOKEN_ELSE       ; ELSE
00:C04F F007            	  1120:          BEQ  IF1
00:C051 207292          	  1121: IF2      JSR  PULWRK
00:C054 2082C7          	  1122:          JSR  FIXAD
00:C057 60              	  1123:          RTS
00:C058 207292          	  1124: IF1      JSR  PULWRK     ; HERE FOR ELSE
00:C05B 20E6BA          	  1125:          JSR  WRK_WRKD
00:C05E 2081BA          	  1126:          JSR  PSHPCODE
00:C061 204CC7          	  1127:          JSR  GENNJP
00:C064 20DBBA          	  1128:          JSR  WRKD_WRK
00:C067 2082C7          	  1129:          JSR  FIXAD
00:C06A 20A3CE          	  1130:          JSR  pas_get_token
00:C06D 208BBD          	  1131:          JSR  STMNT
00:C070 4C51C0          	  1132:          JMP  IF2
                        	  1133: ;
                        	  1134: ; BEGIN
                        	  1135: ;
00:C073 20A3CE          	  1136: BEG      JSR  pas_get_token
00:C076 208BBD          	  1137:          JSR  STMNT
00:C079 A593            	  1138:          LDA  token_type
00:C07B C93B            	  1139:          CMP  #';'
00:C07D F0F4            	  1140:          BEQ  BEG
00:C07F A989            	  1141:          LDA  #TOKEN_END       ; END
00:C081 A211            	  1142:          LDX  #17         ; ERROR: ; or END expected
00:C083 2007CF          	  1143:          JSR  CHKTKN
00:C086 4CA3CE          	  1144:          JMP  pas_get_token
                        	  1145: ;
                        	  1146: ; REPEAT
                        	  1147: ;
00:C089 2081BA          	  1148: REPEAT   JSR  PSHPCODE
00:C08C 20A3CE          	  1149: REP1     JSR  pas_get_token
00:C08F 208BBD          	  1150:          JSR  STMNT
00:C092 A593            	  1151:          LDA  token_type
00:C094 C93B            	  1152:          CMP  #';'
00:C096 F0F4            	  1153:          BEQ  REP1
00:C098 A999            	  1154:          LDA  #TOKEN_UNTIL
00:C09A A20A            	  1155:          LDX  #10           ; ERROR: ; expected
00:C09C 2007CF          	  1156:          JSR  CHKTKN
00:C09F 20BFBA          	  1157:          JSR  GETEXPR
00:C0A2 207292          	  1158:          JSR  PULWRK
00:C0A5 20D0BA          	  1159:          JSR  WRK_OPND
00:C0A8 A93D            	  1160:          LDA  #PCODE_JMZ         ; JMZ     	Jump if (sp) zero
00:C0AA 4C3AC7          	  1161:          JMP  GENRJMP
                        	  1162: ;
                        	  1163: ; WHILE
                        	  1164: ;
00:C0AD 2081BA          	  1165: WHILE    JSR  PSHPCODE
00:C0B0 20BFBA          	  1166:          JSR  GETEXPR
00:C0B3 2081BA          	  1167:          JSR  PSHPCODE
00:C0B6 A93D            	  1168:          LDA  #PCODE_JMZ       ; JMZ     	Jump if (sp) zero
00:C0B8 204EC7          	  1169:          JSR  GENNJM
00:C0BB A997            	  1170:          LDA  #TOKEN_DO
00:C0BD A212            	  1171:          LDX  #18             ; ERROR: DO expected
00:C0BF 2007CF          	  1172:          JSR  CHKTKN
00:C0C2 20A3CE          	  1173:          JSR  pas_get_token
00:C0C5 208BBD          	  1174:          JSR  STMNT
00:C0C8 207292          	  1175:          JSR  PULWRK
00:C0CB 20E6BA          	  1176:          JSR  WRK_WRKD
00:C0CE 207292          	  1177:          JSR  PULWRK
00:C0D1 20D0BA          	  1178:          JSR  WRK_OPND
00:C0D4 A93C            	  1179:          LDA  #PCODE_JMP     ; JMP     	Jump unconditionally
00:C0D6 203AC7          	  1180:          JSR  GENRJMP
00:C0D9 20DBBA          	  1181:          JSR  WRKD_WRK
00:C0DC 4C82C7          	  1182:          JMP  FIXAD
                        	  1183: ;
                        	  1184: ; CASE
                        	  1185: ;
00:C0DF 20BFBA          	  1186: CASE     JSR  GETEXPR
00:C0E2 A985            	  1187:          LDA  #TOKEN_OF       ; OF
00:C0E4 A21A            	  1188:          LDX  #26         ; ERROR: "of " expected
00:C0E6 2007CF          	  1189:          JSR  CHKTKN
00:C0E9 A901            	  1190:          LDA  #1
00:C0EB 854B            	  1191:          STA  COUNT1
00:C0ED A900            	  1192: CASE7    LDA  #0
00:C0EF 854C            	  1193:          STA  COUNT2
                        	  1194: CASE2    =  *
00:C0F1 A92A            	  1195:          LDA  #PCODE_MOV  ; make copy of selector:  MOV     	Copy (sp) to (sp + 1)
00:C0F3 20CBC6          	  1196:          JSR  GENNOP
00:C0F6 20BFBA          	  1197:          JSR  GETEXPR    ; next expression to compare
00:C0F9 A910            	  1198:          LDA  #PCODE_EQL       ;  EQL     	Test (sp - 1) == (sp)
00:C0FB 20CBC6          	  1199:          JSR  GENNOP
00:C0FE A593            	  1200:          LDA  token_type
00:C100 C93A            	  1201:          CMP  #':'
00:C102 F014            	  1202:          BEQ  CASE1
00:C104 A92C            	  1203:          LDA  #','
00:C106 A205            	  1204:          LDX  #5      ; ERROR: , or : expected
00:C108 2007CF          	  1205:          JSR  CHKTKN
00:C10B 2081BA          	  1206:          JSR  PSHPCODE
00:C10E A93E            	  1207:          LDA  #PCODE_JM1     ; JM1     	Jump if (sp) not zero
00:C110 204EC7          	  1208:          JSR  GENNJM
00:C113 E64C            	  1209:          INC  COUNT2
00:C115 4CF1C0          	  1210:          JMP  CASE2
00:C118 20C5BA          	  1211: CASE1    JSR  PCD_WRKD
00:C11B A93D            	  1212:          LDA  #PCODE_JMZ     ; JMZ     	Jump if (sp) zero
00:C11D 204EC7          	  1213:          JSR  GENNJM
00:C120 A54C            	  1214:          LDA  COUNT2
00:C122 F00A            	  1215:          BEQ  CASE3
00:C124 207292          	  1216: CASE4    JSR  PULWRK
00:C127 2082C7          	  1217:          JSR  FIXAD
00:C12A C64C            	  1218:          DEC  COUNT2
00:C12C D0F6            	  1219:          BNE  CASE4
00:C12E 20DBBA          	  1220: CASE3    JSR  WRKD_WRK
00:C131 205F92          	  1221:          JSR  PSHWRK
00:C134 20A3CE          	  1222:          JSR  pas_get_token
00:C137 A54B            	  1223:          LDA  COUNT1
00:C139 48              	  1224:          PHA
00:C13A 208BBD          	  1225:          JSR  STMNT
00:C13D 68              	  1226:          PLA
00:C13E 854B            	  1227:          STA  COUNT1
00:C140 A593            	  1228:          LDA  token_type
00:C142 C994            	  1229:          CMP  #TOKEN_ELSE       ; ELSE
00:C144 F01B            	  1230:          BEQ  CASE5
00:C146 C93B            	  1231:          CMP  #';'
00:C148 D035            	  1232:          BNE  CASE6
00:C14A 20C5BA          	  1233:          JSR  PCD_WRKD
00:C14D 204CC7          	  1234:          JSR  GENNJP
00:C150 207292          	  1235:          JSR  PULWRK
00:C153 2082C7          	  1236:          JSR  FIXAD
00:C156 20DBBA          	  1237:          JSR  WRKD_WRK
00:C159 205F92          	  1238:          JSR  PSHWRK
00:C15C E64B            	  1239:          INC  COUNT1
00:C15E 4CEDC0          	  1240:          JMP  CASE7
00:C161 20C5BA          	  1241: CASE5    JSR  PCD_WRKD
00:C164 204CC7          	  1242:          JSR  GENNJP
00:C167 207292          	  1243:          JSR  PULWRK
00:C16A 2082C7          	  1244:          JSR  FIXAD
00:C16D 20DBBA          	  1245:          JSR  WRKD_WRK
00:C170 205F92          	  1246:          JSR  PSHWRK
00:C173 20A3CE          	  1247:          JSR  pas_get_token
00:C176 A54B            	  1248:          LDA  COUNT1
00:C178 48              	  1249:          PHA
00:C179 208BBD          	  1250:          JSR  STMNT
00:C17C 68              	  1251:          PLA
00:C17D 854B            	  1252:          STA  COUNT1
00:C17F A989            	  1253: CASE6    LDA  #TOKEN_END       ; END
00:C181 A211            	  1254:          LDX  #17         ; ERROR: ; or END expected
00:C183 2007CF          	  1255:          JSR  CHKTKN
00:C186 A54B            	  1256:          LDA  COUNT1
00:C188 F00A            	  1257:          BEQ  CASE8
00:C18A 207292          	  1258: CASE9    JSR  PULWRK
00:C18D 2082C7          	  1259:          JSR  FIXAD
00:C190 C64B            	  1260:          DEC  COUNT1
00:C192 D0F6            	  1261:          BNE  CASE9
00:C194 2060C2          	  1262: CASE8    JSR  FOR6
00:C197 4CA3CE          	  1263:          JMP  pas_get_token
                        	  1264: ;
                        	  1265: ; FOR
                        	  1266: ;
00:C19A A949            	  1267: FOR      LDA  #TOKEN_IDENTIFIER
00:C19C A204            	  1268:          LDX  #4      ; ERROR:  Identifier expected
00:C19E 20F7CE          	  1269:          JSR  GETCHK
00:C1A1 2095B9          	  1270:          JSR  LOOKUP
00:C1A4 C956            	  1271: FOR1     CMP  #SYMBOL_VARIABLE
00:C1A6 F009            	  1272:          BEQ  FOR2
00:C1A8 C959            	  1273:          CMP  #SYMBOL_FUNCTION_RETURN
00:C1AA F005            	  1274:          BEQ  FOR2
00:C1AC A20C            	  1275:          LDX  #12   ; ERROR: Illegal Identifier
00:C1AE 4C6497          	  1276:          jmp  ERROR
00:C1B1 20FFBD          	  1277: FOR2     JSR  ASSVAR
00:C1B4 206BBA          	  1278:          JSR  SYMWRK
00:C1B7 A900            	  1279:          LDA  #0
00:C1B9 854B            	  1280:          STA  COUNT1
00:C1BB A593            	  1281:          LDA  token_type
00:C1BD C99B            	  1282:          CMP  #TOKEN_TO       ; TO
00:C1BF F009            	  1283:          BEQ  FOR3
00:C1C1 A99C            	  1284:          LDA  #TOKEN_DOWNTO       ; DOWNTO
00:C1C3 A21C            	  1285:          LDX  #28       ; ERROR: TO or DOWNTO expected
00:C1C5 2007CF          	  1286:          JSR  CHKTKN
00:C1C8 C64B            	  1287:          DEC  COUNT1
00:C1CA A54B            	  1288: FOR3     LDA  COUNT1
00:C1CC 48              	  1289:          PHA
00:C1CD 205F92          	  1290:          JSR  PSHWRK
00:C1D0 20BFBA          	  1291:          JSR  GETEXPR
00:C1D3 207292          	  1292:          JSR  PULWRK
00:C1D6 2076BA          	  1293:          JSR  WRKSYM
00:C1D9 68              	  1294:          PLA
00:C1DA 854B            	  1295:          STA  COUNT1
00:C1DC 2081BA          	  1296:          JSR  PSHPCODE
00:C1DF A92A            	  1297:          LDA  #PCODE_MOV     ; MOV     	Copy (sp) to (sp + 1)
00:C1E1 20CBC6          	  1298:          JSR  GENNOP
00:C1E4 202FBA          	  1299:          JSR  GET_LEV
00:C1E7 2094BA          	  1300:          JSR  GET_OFF
00:C1EA 2039BA          	  1301:          JSR  GET_DAT
00:C1ED 18              	  1302:          CLC
00:C1EE 692C            	  1303:          ADC  #PCODE_LOD  ; Load integer onto stack or PCODE_LODC if a char
00:C1F0 20E4C6          	  1304:          JSR  GENADR
00:C1F3 A916            	  1305:          LDA  #PCODE_GEQ        ; UP (GEQ): GEQ     	Test (sp - 1) >= (sp)
00:C1F5 A64B            	  1306:          LDX  COUNT1
00:C1F7 F002            	  1307:          BEQ  FOR4
00:C1F9 A919            	  1308:          LDA  #PCODE_LEQ        ; DOWN (LEQ): LEQ     	Test (sp - 1) <= (sp)
00:C1FB 20CBC6          	  1309: FOR4     JSR  GENNOP
00:C1FE 2081BA          	  1310:          JSR  PSHPCODE
00:C201 A93D            	  1311:          LDA  #PCODE_JMZ       ;  JMZ     	Jump if (sp) zero
00:C203 204EC7          	  1312:          JSR  GENNJM
00:C206 A54B            	  1313:          LDA  COUNT1
00:C208 48              	  1314:          PHA
00:C209 206BBA          	  1315:          JSR  SYMWRK
00:C20C 205F92          	  1316:          JSR  PSHWRK
00:C20F A997            	  1317:          LDA  #TOKEN_DO
00:C211 A212            	  1318:          LDX  #18       ; ERROR: DO expected
00:C213 2007CF          	  1319:          JSR  CHKTKN
00:C216 20A3CE          	  1320:          JSR  pas_get_token
00:C219 208BBD          	  1321:          JSR  STMNT
00:C21C 207292          	  1322:          JSR  PULWRK
00:C21F 2076BA          	  1323:          JSR  WRKSYM
00:C222 202FBA          	  1324:          JSR  GET_LEV
00:C225 2039BA          	  1325:          JSR  GET_DAT
00:C228 2094BA          	  1326:          JSR  GET_OFF
00:C22B A54A            	  1327:          LDA  DATTYP
00:C22D 18              	  1328:          CLC
00:C22E 692C            	  1329:          ADC  #PCODE_LOD       ; LOD     	Load integer onto stack
00:C230 20E4C6          	  1330:          JSR  GENADR
00:C233 68              	  1331:          PLA
00:C234 854B            	  1332:          STA  COUNT1
00:C236 A926            	  1333:          LDA  #PCODE_INC     ; INC     	Increment (sp) by 1
00:C238 A64B            	  1334:          LDX  COUNT1
00:C23A F002            	  1335:          BEQ  FOR5
00:C23C A928            	  1336:          LDA  #PCODE_DEC        ; DEC     	Decrement (sp) by 1
00:C23E 20CBC6          	  1337: FOR5     JSR  GENNOP
00:C241 A932            	  1338:          LDA  #PCODE_STO       ; STO     	Store integer
00:C243 18              	  1339:          CLC
00:C244 654A            	  1340:          ADC  DATTYP          ; may become PCODE_STOC if a char
00:C246 20E4C6          	  1341:          JSR  GENADR
00:C249 207292          	  1342:          JSR  PULWRK
00:C24C 20E6BA          	  1343:          JSR  WRK_WRKD
00:C24F 207292          	  1344:          JSR  PULWRK
00:C252 20D0BA          	  1345:          JSR  WRK_OPND
00:C255 A93C            	  1346:          LDA  #PCODE_JMP       ; JMP     	Jump unconditionally
00:C257 203AC7          	  1347:          JSR  GENRJMP
00:C25A 20DBBA          	  1348:          JSR  WRKD_WRK
00:C25D 2082C7          	  1349:          JSR  FIXAD
00:C260 A9FF            	  1350: FOR6     LDA  #$FF
00:C262 852C            	  1351:          STA  OPND+1
00:C264 A9FD            	  1352:          LDA  #$FD
00:C266 852B            	  1353:          STA  OPND
00:C268 A93B            	  1354:          LDA  #PCODE_INT       ;  INT     	Increment stack pointer
00:C26A 4C54C7          	  1355:          JMP  GENJMP
                        	  1356: 
                        	  1357: 
                        	  1358: ;***********************************************
                        	  1359: ; MORE OF THE COMPILER (PROCESSING A 'BLOCK')
                        	  1360: ;***********************************************
                        	  1361: 
                        	  1362: CHKGET   =  *
00:C26D 2007CF          	  1363:          JSR  CHKTKN
00:C270 4CA3CE          	  1364:          JMP  pas_get_token
                        	  1365: ;
                        	  1366: ;  copy WORK to token_value
                        	  1367: ;
                        	  1368: WRK_VAL  =  *
00:C273 48              	  1369:          PHA
00:C274 A537            	  1370:          LDA  WORK
00:C276 8594            	  1371:          STA  token_value
00:C278 A538            	  1372:          LDA  WORK+1
00:C27A 8595            	  1373:          STA  token_value+1
00:C27C 68              	  1374:          PLA
00:C27D 60              	  1375:          RTS
                        	  1376: ;
                        	  1377: ;  copy VALUE to WORK
                        	  1378: ;
                        	  1379: VAL_WRK  =  *
00:C27E 48              	  1380:          PHA
00:C27F A594            	  1381:          LDA  token_value
00:C281 8537            	  1382:          STA  WORK
00:C283 A595            	  1383:          LDA  token_value+1
00:C285 8538            	  1384:          STA  WORK+1
00:C287 68              	  1385:          PLA
00:C288 60              	  1386:          RTS
                        	  1387: ;
                        	  1388: ;  copy ENDSYM to WORK
                        	  1389: ;
                        	  1390: END_WRK  =  *
00:C289 48              	  1391:          PHA
00:C28A A531            	  1392:          LDA  ENDSYM
00:C28C 8537            	  1393:          STA  WORK
00:C28E A532            	  1394:          LDA  ENDSYM+1
00:C290 8538            	  1395:          STA  WORK+1
00:C292 68              	  1396:          PLA
00:C293 60              	  1397:          RTS
                        	  1398: ;
                        	  1399: ;***********************************************
                        	  1400: ;
                        	  1401: ;
                        	  1402: ; BLOCK
                        	  1403: ;
00:C294 82              	  1404: BLCKT1   DFB  TOKEN_CONST
00:C295 EBC2            	  1405:          word BLKCNS
00:C297 83              	  1406: BLCKT2   DFB  TOKEN_VAR
00:C298 02C3            	  1407:          word BLKVAR
00:C29A 86              	  1408: BLCKT3   DFB  TOKEN_PROCEDURE
00:C29B 3FC4            	  1409:          word BLKPRC
00:C29D 87              	  1410:          DFB  TOKEN_FUNCTION
00:C29E 5FC4            	  1411:          word BLKFNC
00:C2A0 88              	  1412:          DFB  TOKEN_BEGIN
00:C2A1 27C5            	  1413:          word BLKBEG
00:C2A3 00              	  1414:          DFB  0
                        	  1415: ;
                        	  1416: ;
00:C2A4 2027BB          	  1417: BLOCK    JSR  CHK_STAK
00:C2A7 A900            	  1418:          LDA  #0
00:C2A9 8521            	  1419:          STA  FRAME+1
00:C2AB A906            	  1420:          LDA  #6
00:C2AD 8520            	  1421:          STA  FRAME
00:C2AF A539            	  1422:          LDA  PRCITM
00:C2B1 8537            	  1423:          STA  WORK
00:C2B3 A63A            	  1424:          LDX  PRCITM+1
00:C2B5 8638            	  1425:          STX  WORK+1
00:C2B7 053A            	  1426:          ORA  PRCITM+1
00:C2B9 F014            	  1427:          BEQ  BLK1
                        	  1428: 
                        	  1429: ;
00:C2BB A004            	  1430: BLK1A    LDY  #SYMDSP
00:C2BD A523            	  1431:          LDA  PCODE
00:C2BF 9137            	  1432:          STA  (WORK),Y
00:C2C1 C8              	  1433:          INY
00:C2C2 A524            	  1434:          LDA  PCODE+1
00:C2C4 9137            	  1435:          STA  (WORK),Y
00:C2C6 A900            	  1436:          LDA  #0
00:C2C8 A008            	  1437:          LDY  #SYMDAT
00:C2CA 9137            	  1438:          STA  (WORK),Y   ; FLAG RELATIVE PROCEDURE
00:C2CC 4CD7C2          	  1439:          JMP  BLK2
00:C2CF A523            	  1440: BLK1     LDA  PCODE
00:C2D1 8537            	  1441:          STA  WORK
00:C2D3 A524            	  1442:          LDA  PCODE+1
00:C2D5 8538            	  1443:          STA  WORK+1
00:C2D7 205F92          	  1444: BLK2     JSR  PSHWRK
00:C2DA 204CC7          	  1445:          JSR  GENNJP
00:C2DD A294            	  1446:          LDX  #<BLCKT1
00:C2DF A0C2            	  1447:          LDY  #>BLCKT1
00:C2E1 A593            	  1448: BLK4     LDA  token_type
00:C2E3 20928F          	  1449:          JSR  TKNJMP
00:C2E6 A219            	  1450:          LDX  #25       ; ERROR: BEGIN expected
00:C2E8 4C6497          	  1451:          jmp  ERROR
                        	  1452: ;
                        	  1453: ;
                        	  1454: ; CONSTANT
                        	  1455: ;
00:C2EB 20A3CE          	  1456: BLKCNS   JSR  pas_get_token
00:C2EE 2040BA          	  1457: BLKCN1   JSR  CONDEC
00:C2F1 A93B            	  1458:          LDA  #';'
00:C2F3 A20A            	  1459:          LDX  #10       ; ERROR: ; expected
00:C2F5 206DC2          	  1460:          JSR  CHKGET
00:C2F8 A297            	  1461:          LDX  #<BLCKT2
00:C2FA A0C2            	  1462:          LDY  #>BLCKT2
00:C2FC 20928F          	  1463:          JSR  TKNJMP
00:C2FF 4CEEC2          	  1464:          JMP  BLKCN1
                        	  1465: ;
                        	  1466: ; VARIABLE
                        	  1467: ;
00:C302 A900            	  1468: BLKVAR   LDA  #0
00:C304 854B            	  1469:          STA  COUNT1
00:C306 20A3CE          	  1470: BLKVR1   JSR  pas_get_token
00:C309 2059BB          	  1471: BLKVR6   JSR  VARDEC    ; check we have an identifier, add it to the symbol table, get another token
00:C30C E64B            	  1472:          INC  COUNT1    ; how many variables in this declaration
00:C30E 1003            	  1473:          BPL  BLKVR7
00:C310 4C80C3          	  1474:          JMP  BLKV13     ; ERROR  - compiler limits exceeded (more than 127 variables?)
00:C313 A593            	  1475: BLKVR7   LDA  token_type
00:C315 C92C            	  1476:          CMP  #','
00:C317 F0ED            	  1477:          BEQ  BLKVR1    ; back for another
00:C319 A93A            	  1478:          LDA  #':'
00:C31B A205            	  1479:          LDX  #5        ; ERROR: , or : expected
00:C31D 206DC2          	  1480:          JSR  CHKGET
00:C320 C984            	  1481:          CMP  #TOKEN_ARRAY   ; ARRAY
00:C322 F043            	  1482:          BEQ  BLKVR2
00:C324 C9FE            	  1483:          CMP  #TOKEN_INTEGER ; INTEGER
00:C326 F00A            	  1484:          BEQ  BLKVR8
00:C328 A9A1            	  1485:          LDA  #TOKEN_CHAR    ; CHAR
00:C32A A224            	  1486:          LDX  #36            ; ERROR: Data Type not recognised
00:C32C 2007CF          	  1487:          JSR  CHKTKN
00:C32F 4C27C4          	  1488:          JMP  BLKVR3
                        	  1489: 
                        	  1490: ;
                        	  1491: ;  integer variable
                        	  1492: ;
00:C332 20CCC3          	  1493: BLKVR8   JSR  BLKVR9  ; subtract COUNT1 from FRAME, put WORK into VALUE, put ENDSYM into WORK
                        	  1494: BLKV10   = *
00:C335 A008            	  1495:          LDY  #SYMDAT
00:C337 A900            	  1496:          LDA  #0         ; INTEGER TYPE
00:C339 9137            	  1497:          STA  (WORK),Y
00:C33B A520            	  1498:          LDA  FRAME
00:C33D A004            	  1499:          LDY  #SYMDSP
00:C33F 9137            	  1500:          STA  (WORK),Y
00:C341 C8              	  1501:          INY
00:C342 A521            	  1502:          LDA  FRAME+1
00:C344 9137            	  1503:          STA  (WORK),Y
00:C346 18              	  1504:          CLC
00:C347 A520            	  1505:          LDA  FRAME
00:C349 6903            	  1506:          ADC  #3
00:C34B 8520            	  1507:          STA  FRAME
00:C34D 9002            	  1508:          BCC  BLKV10_A
00:C34F E621            	  1509:          INC  FRAME+1
                        	  1510: BLKV10_A =  *
00:C351 C64B            	  1511:          DEC  COUNT1
00:C353 D003            	  1512:          BNE  BLKV10_B
00:C355 4C27C4          	  1513:          JMP  BLKVR3
                        	  1514: 
                        	  1515: BLKV10_B = *
                        	  1516: ;
                        	  1517: ;  more in the list, go to the previous symbol
                        	  1518: ;
00:C358 A000            	  1519:          LDY  #SYMPRV
00:C35A B137            	  1520:          LDA  (WORK),Y
00:C35C AA              	  1521:          TAX
00:C35D C8              	  1522:          INY
00:C35E B137            	  1523:          LDA  (WORK),Y
00:C360 8538            	  1524:          STA  WORK+1
00:C362 8A              	  1525:          TXA
00:C363 8537            	  1526:          STA  WORK       ; PREVIOUS ITEM
00:C365 80CE            	  1527:          BRA  BLKV10
                        	  1528: 
                        	  1529: ;
                        	  1530: ; ARRAY [ N ] OF ...
                        	  1531: ;
00:C367 201BBA          	  1532: BLKVR2   JSR  CHKLHB
00:C36A 2033BB          	  1533:          JSR  CONST     ; get how many are in the array
00:C36D A596            	  1534:          LDA  token_value+2   ; can't be more than 65536
00:C36F D00F            	  1535:          BNE  BLKV13
00:C371 A594            	  1536:          LDA  token_value     ; add 1 to the count since array [3] of char means 4 elements
00:C373 18              	  1537:          CLC
00:C374 6901            	  1538:          ADC  #1
00:C376 8594            	  1539:          STA  token_value
00:C378 A595            	  1540:          LDA  token_value+1
00:C37A 3004            	  1541:          BMI  BLKV13
00:C37C 6900            	  1542:          ADC  #0
00:C37E 1005            	  1543:          BPL  BLKVR4
00:C380 A20F            	  1544: BLKV13   LDX  #15       ; ERROR: compiler limits exceeded
00:C382 4C6497          	  1545:          jmp  ERROR
00:C385 8595            	  1546: BLKVR4   STA  token_value+1
00:C387 207EC2          	  1547:          JSR  VAL_WRK   ; put the value (array count) in WORK
00:C38A 20A3CE          	  1548:          JSR  pas_get_token
00:C38D 2025BA          	  1549:          JSR  CHKRHB
00:C390 A901            	  1550:          LDA  #1        ; char
00:C392 854A            	  1551:          STA  DATTYP
00:C394 A985            	  1552:          LDA  #TOKEN_OF  ; OF
00:C396 A21A            	  1553:          LDX  #26        ; ERROR: "of " expected
00:C398 206DC2          	  1554:          JSR  CHKGET
00:C39B C9FE            	  1555:          CMP  #TOKEN_INTEGER  ; INTEGER
00:C39D D020            	  1556:          BNE  BLKV11
00:C39F C64A            	  1557:          DEC  DATTYP    ; DATTYP of 0 is integer, and 1 is char
00:C3A1 2073C2          	  1558:          JSR  WRK_VAL   ; get the array count back into token_value
                        	  1559: ;
                        	  1560: ; MULTIPLY token_value BY 3
                        	  1561: ;
00:C3A4 A594            	  1562:          LDA  token_value
00:C3A6 A695            	  1563:          LDX  token_value+1
00:C3A8 0694            	  1564:          ASL  token_value
00:C3AA 2695            	  1565:          ROL  token_value+1
00:C3AC B0D2            	  1566:          BCS  BLKV13
00:C3AE 6594            	  1567:          ADC  token_value
00:C3B0 8594            	  1568:          STA  token_value
00:C3B2 8A              	  1569:          TXA
00:C3B3 6595            	  1570:          ADC  token_value+1
00:C3B5 B0C9            	  1571:          BCS  BLKV13
00:C3B7 8595            	  1572:          STA  token_value+1
00:C3B9 207EC2          	  1573:          JSR  VAL_WRK     ; put the array count (times 3) back into WORK
00:C3BC 4CC6C3          	  1574:          JMP  BLKV12
                        	  1575:  ;
                        	  1576:  ;  here for array of char
                        	  1577:  ;
00:C3BF A9A1            	  1578: BLKV11   LDA  #TOKEN_CHAR       ; CHAR
00:C3C1 A224            	  1579:          LDX  #36           ; ERROR: Data Type not recognised
00:C3C3 2007CF          	  1580:          JSR  CHKTKN
00:C3C6 20CCC3          	  1581: BLKV12   JSR  BLKVR9        ; we are COUNT1 frames back
00:C3C9 4CE5C3          	  1582:          JMP  BLKVR5
                        	  1583: 
                        	  1584: BLKVR9   =  *
00:C3CC A520            	  1585:          LDA  FRAME         ; subtract COUNT1 (the variable position) from the frame number
00:C3CE 38              	  1586:          SEC
00:C3CF E54B            	  1587:          SBC  COUNT1
00:C3D1 8520            	  1588:          STA  FRAME
00:C3D3 A521            	  1589:          LDA  FRAME+1
00:C3D5 E900            	  1590:          SBC  #0
00:C3D7 8521            	  1591:          STA  FRAME+1
00:C3D9 2073C2          	  1592:          JSR  WRK_VAL     ; copy WORK to VALUE (array count, possibly multiplied by 3)
00:C3DC A531            	  1593:          LDA  ENDSYM      ; end of symbol table into WORK
00:C3DE 8537            	  1594:          STA  WORK
00:C3E0 A532            	  1595:          LDA  ENDSYM+1
00:C3E2 8538            	  1596:          STA  WORK+1
00:C3E4 60              	  1597:          RTS
                        	  1598: 
                        	  1599: ;
                        	  1600: ;  we should be here with ENDSYM in WORK (for walking back through the symbol table for all the variables we just decla
                        	  1601: ;  COUNT1 will be the number of symbols we have to fix up
                        	  1602: ;
                        	  1603: BLKVR5   = *
00:C3E5 A003            	  1604:          ldy  #SYMTYP
00:C3E7 A941            	  1605:          lda  #SYMBOL_ARRAY
00:C3E9 9137            	  1606:          sta  (WORK),Y    ; make symbol type array
00:C3EB A004            	  1607:          ldy  #SYMDSP
00:C3ED A520            	  1608:          lda  FRAME       ; FRAME is the displacement
00:C3EF 9137            	  1609:          sta  (WORK),Y
00:C3F1 C8              	  1610:          iny
00:C3F2 A521            	  1611:          lda  FRAME+1
00:C3F4 9137            	  1612:          sta  (WORK),Y
00:C3F6 A594            	  1613:          lda  token_value       ; array count (multiplied by 3 in the case of integers)
00:C3F8 18              	  1614:          clc
00:C3F9 6520            	  1615:          adc  FRAME       ; add to the stack frame address
00:C3FB 8520            	  1616:          sta  FRAME
00:C3FD A595            	  1617:          lda  token_value+1
00:C3FF 6521            	  1618:          adc  FRAME+1
00:C401 8521            	  1619:          sta  FRAME+1
00:C403 A008            	  1620:          ldy  #SYMDAT
00:C405 A54A            	  1621:          lda  DATTYP       ; save the data type in the symbol
00:C407 9137            	  1622:          sta  (WORK),Y
00:C409 A006            	  1623:          ldy  #SYMSUB
00:C40B A594            	  1624:          lda  token_value        ; max subscript + 1
00:C40D 9137            	  1625:          sta  (WORK),Y
00:C40F A595            	  1626:          lda  token_value+1
00:C411 C8              	  1627:          iny
00:C412 9137            	  1628:          sta  (WORK),Y
00:C414 C64B            	  1629:          dec  COUNT1
00:C416 F00F            	  1630:          beq  BLKVR3
                        	  1631: ;
                        	  1632: ;  onto the previous symbol
                        	  1633: ;
00:C418 A000            	  1634:          ldy  #SYMPRV
00:C41A B137            	  1635:          lda  (WORK),Y
00:C41C AA              	  1636:          tax
00:C41D C8              	  1637:          iny
00:C41E B137            	  1638:          lda  (WORK),Y
00:C420 8538            	  1639:          sta  WORK+1
00:C422 8A              	  1640:          txa
00:C423 8537            	  1641:          sta  WORK       ; PREVIOUS ITEM
00:C425 80BE            	  1642:          bra  BLKVR5
                        	  1643: ;
                        	  1644: ;  here at end of variable declaration (after INTEGER / CHAR)
                        	  1645: ;
00:C427 A93B            	  1646: BLKVR3   LDA  #';'
00:C429 A20A            	  1647:          LDX  #10       ; ERROR: ; expected
00:C42B 20F7CE          	  1648:          JSR  GETCHK
00:C42E 20A3CE          	  1649:          JSR  pas_get_token
00:C431 A29A            	  1650:          LDX  #<BLCKT3  ; now look for procedure / function / begin
00:C433 A0C2            	  1651:          LDY  #>BLCKT3
00:C435 20928F          	  1652:          JSR  TKNJMP    ; if not there, look for another variable declaration
00:C438 A900            	  1653:          LDA  #0        ; zero variables in this list so far
00:C43A 854B            	  1654:          STA  COUNT1
00:C43C 4C09C3          	  1655:          JMP  BLKVR6
                        	  1656: ;
                        	  1657: ; PROCEDURE DECLARATION
                        	  1658: ;
00:C43F A949            	  1659: BLKPRC   LDA  #'I'
00:C441 A204            	  1660:          LDX  #4         ; ERROR: Identifier expected
00:C443 20F7CE          	  1661:          JSR  GETCHK
00:C446 A900            	  1662:          LDA  #0
00:C448 854B            	  1663:          STA  COUNT1    ; no function return value
00:C44A 20A0B9          	  1664:          JSR  CHKDUP
00:C44D A950            	  1665:          LDA  #SYMBOL_PROCEDURE
00:C44F 20F9B8          	  1666:          JSR  ADDSYM
00:C452 E622            	  1667:          INC  LEVEL
00:C454 A540            	  1668:          LDA  SYMITM
00:C456 8539            	  1669:          STA  PRCITM    ; PRCITM is the symbol of the procedure/function
00:C458 A541            	  1670:          LDA  SYMITM+1
00:C45A 853A            	  1671:          STA  PRCITM+1
00:C45C 4C81C4          	  1672:          JMP  BLKPR1
                        	  1673: ;
                        	  1674: ; FUNCTION DECLARATION
                        	  1675: ;
00:C45F A949            	  1676: BLKFNC   LDA  #TOKEN_IDENTIFIER
00:C461 A204            	  1677:          LDX  #4      ; ERROR: Identifier expected
00:C463 20F7CE          	  1678:          JSR  GETCHK
00:C466 20A0B9          	  1679:          JSR  CHKDUP
00:C469 A946            	  1680:          LDA  #SYMBOL_FUNCTION
00:C46B 20F9B8          	  1681:          JSR  ADDSYM
00:C46E E622            	  1682:          INC  LEVEL
00:C470 A901            	  1683:          LDA  #1
00:C472 854B            	  1684:          STA  COUNT1    ; we have the function return as a symbol
00:C474 A540            	  1685:          LDA  SYMITM
00:C476 8539            	  1686:          STA  PRCITM   ; PRCITM is the symbol of the procedure/function
00:C478 A541            	  1687:          LDA  SYMITM+1
00:C47A 853A            	  1688:          STA  PRCITM+1
00:C47C A959            	  1689:          LDA  #SYMBOL_FUNCTION_RETURN ; for assigning the results to
00:C47E 20F9B8          	  1690:          JSR  ADDSYM
                        	  1691: ;
                        	  1692: ; PROCEDURE AND FUNCTION COMMON CODE
                        	  1693: ;
00:C481 A54B            	  1694: BLKPR1   LDA  COUNT1
00:C483 854C            	  1695:          STA  COUNT2    ; remember if we had 0 or 1 extra symbols (function return)
00:C485 2089C2          	  1696:          JSR  END_WRK
00:C488 205F92          	  1697:          JSR  PSHWRK
00:C48B A520            	  1698:          LDA  FRAME
00:C48D 8537            	  1699:          STA  WORK
00:C48F A521            	  1700:          LDA  FRAME+1
00:C491 8538            	  1701:          STA  WORK+1
00:C493 205F92          	  1702:          JSR  PSHWRK
00:C496 20A3CE          	  1703:          JSR  pas_get_token
00:C499 C928            	  1704:          CMP  #'('      ; opening bracket after procedure/function name?
00:C49B D016            	  1705:          BNE  BLKPR2
00:C49D 20A3CE          	  1706: BLKPR3   JSR  pas_get_token
00:C4A0 2059BB          	  1707:          JSR  VARDEC
00:C4A3 E64B            	  1708:          INC  COUNT1    ; count arguments
00:C4A5 1003            	  1709:          BPL  BLKPR6
00:C4A7 4C80C3          	  1710:          JMP  BLKV13
00:C4AA A593            	  1711: BLKPR6   LDA  token_type
00:C4AC C92C            	  1712:          CMP  #','
00:C4AE F0ED            	  1713:          BEQ  BLKPR3
00:C4B0 2008BA          	  1714:          JSR  CHKRHP
00:C4B3 A539            	  1715: BLKPR2   LDA  PRCITM      ; here after argument list, if any
00:C4B5 8537            	  1716:          STA  WORK
00:C4B7 A53A            	  1717:          LDA  PRCITM+1
00:C4B9 8538            	  1718:          STA  WORK+1
00:C4BB A006            	  1719:          LDY  #SYMARG
00:C4BD A54B            	  1720:          LDA  COUNT1
00:C4BF 38              	  1721:          SEC
00:C4C0 E54C            	  1722:          SBC  COUNT2      ; subtract 0 or 1 depending on if this is a function or not
00:C4C2 9137            	  1723:          STA  (WORK),Y    ; store the number of arguments to this procedure/function
00:C4C4 A93B            	  1724:          LDA  #';'
00:C4C6 A20A            	  1725:          LDX  #10         ; ERROR: ; expected
00:C4C8 2007CF          	  1726:          JSR  CHKTKN
00:C4CB A54B            	  1727:          LDA  COUNT1
00:C4CD F02C            	  1728:          BEQ  BLKPR4
00:C4CF 2089C2          	  1729:          JSR  END_WRK     ; ENDSYM -> WORK
00:C4D2 A2FD            	  1730:          LDX  #$FD        ; X = -3
                        	  1731: ; WORK starts off pointing to the procedure/function symbol
                        	  1732: BLKPR5   = *
00:C4D4 A008            	  1733:          LDY  #SYMDAT
00:C4D6 A900            	  1734:          LDA  #0
00:C4D8 9137            	  1735:          STA  (WORK),Y    ; data type = integer
00:C4DA A004            	  1736:          LDY  #SYMDSP
00:C4DC 8A              	  1737:          TXA
00:C4DD 9137            	  1738:          STA  (WORK),Y
00:C4DF 38              	  1739:          SEC
00:C4E0 E903            	  1740:          SBC  #3
00:C4E2 AA              	  1741:          TAX
00:C4E3 A9FF            	  1742:          LDA  #$FF
00:C4E5 C8              	  1743:          INY
00:C4E6 9137            	  1744:          STA  (WORK),Y
00:C4E8 C64B            	  1745:          DEC  COUNT1
00:C4EA F00F            	  1746:          beq  BLKPR4
                        	  1747: ;
                        	  1748: ;  back to previous symbol
                        	  1749: ;
00:C4EC A000            	  1750:          LDY  #SYMPRV
00:C4EE B137            	  1751:          LDA  (WORK),Y
00:C4F0 48              	  1752:          PHA
00:C4F1 C8              	  1753:          INY
00:C4F2 B137            	  1754:          LDA  (WORK),Y
00:C4F4 8538            	  1755:          STA  WORK+1
00:C4F6 68              	  1756:          PLA
00:C4F7 8537            	  1757:          STA  WORK
00:C4F9 80D9            	  1758:          bra  BLKPR5
00:C4FB 20A3CE          	  1759: BLKPR4   JSR  pas_get_token
00:C4FE 20A4C2          	  1760:          JSR  BLOCK
00:C501 C622            	  1761:          DEC  LEVEL
00:C503 207292          	  1762:          JSR  PULWRK
00:C506 A537            	  1763:          LDA  WORK
00:C508 8520            	  1764:          STA  FRAME
00:C50A A538            	  1765:          LDA  WORK+1
00:C50C 8521            	  1766:          STA  FRAME+1
00:C50E 207292          	  1767:          JSR  PULWRK
00:C511 A537            	  1768:          LDA  WORK
00:C513 8531            	  1769:          STA  ENDSYM
00:C515 A538            	  1770:          LDA  WORK+1
00:C517 8532            	  1771:          STA  ENDSYM+1
00:C519 A93B            	  1772:          LDA  #';'
00:C51B A20A            	  1773:          LDX  #10       ; ERROR: ; expected
00:C51D 206DC2          	  1774:          JSR  CHKGET
00:C520 A29A            	  1775:          LDX  #<BLCKT3
00:C522 A0C2            	  1776:          LDY  #>BLCKT3
00:C524 4CE1C2          	  1777:          JMP  BLK4
                        	  1778: ;
                        	  1779: ; BEGIN (COMPOUND STATEMENT)
                        	  1780: ;
00:C527 20A3CE          	  1781: BLKBEG   JSR  pas_get_token
00:C52A 207292          	  1782:          JSR  PULWRK
00:C52D A522            	  1783:          LDA  LEVEL
00:C52F D006            	  1784:          BNE  BLKB1
00:C531 2082C7          	  1785: BLKB3    JSR  FIXAD
00:C534 4C53C5          	  1786:          JMP  BLKB2
00:C537 2076BA          	  1787: BLKB1    JSR  WRKSYM
00:C53A A004            	  1788:          LDY  #SYMDSP
00:C53C B140            	  1789:          LDA  (SYMITM),Y
00:C53E 8537            	  1790:          STA  WORK
00:C540 C8              	  1791:          INY
00:C541 B140            	  1792:          LDA  (SYMITM),Y
00:C543 8538            	  1793:          STA  WORK+1
00:C545 A004            	  1794:          LDY  #SYMDSP
00:C547 A523            	  1795:          LDA  PCODE
00:C549 9140            	  1796:          STA  (SYMITM),Y
00:C54B A524            	  1797:          LDA  PCODE+1
00:C54D C8              	  1798:          INY
00:C54E 9140            	  1799:          STA  (SYMITM),Y
00:C550 4C31C5          	  1800:          JMP  BLKB3
00:C553 A520            	  1801: BLKB2    LDA  FRAME
00:C555 852B            	  1802:          STA  OPND
00:C557 A521            	  1803:          LDA  FRAME+1
00:C559 852C            	  1804:          STA  OPND+1
00:C55B A93B            	  1805:          LDA  #PCODE_INT         ; INT     	Increment stack pointer
00:C55D 2054C7          	  1806:          JSR  GENJMP
00:C560 208BBD          	  1807: BLKB5    JSR  STMNT
00:C563 A593            	  1808:          LDA  token_type
00:C565 C93B            	  1809:          CMP  #';'
00:C567 D006            	  1810:          BNE  BLKB4
00:C569 20A3CE          	  1811:          JSR  pas_get_token
00:C56C 4C60C5          	  1812:          JMP  BLKB5
00:C56F A989            	  1813: BLKB4    LDA  #TOKEN_END       ; END
00:C571 A211            	  1814:          LDX  #17         ; ERROR: ; or END expected
00:C573 206DC2          	  1815:          JSR  CHKGET
00:C576 A929            	  1816:          LDA  #PCODE_RTN  ; OK - we are at the end of a block - this is a procedure/function return
00:C578 A622            	  1817:          LDX  LEVEL       ; OR - if we are at level 0, then that is the end of the program
00:C57A D002            	  1818:          BNE  BLKB6
00:C57C A911            	  1819:          LDA  #PCODE_FINISHD        ; Opcode: FINISHED 	Stop run (end program)
                        	  1820: TEST1    =  *
00:C57E 4CCBC6          	  1821: BLKB6    JMP  GENNOP
                        	  1822: ;
                        	  1823: 
                        	  1824: 
                        	  1825: ;
                        	  1826: ;  Writing library functions is quite easy:
                        	  1827: ;
                        	  1828: ;   1. For each of the n arguments that they have (could be zero) do a PULTOP to get
                        	  1829: ;      that value from the runtime stack into REG. Or, PULTOP2 to get the value into REG2.
                        	  1830: ;      For two arguments you can do PULBOTH to get them into REG and REG2.
                        	  1831: ;   2. Do whatever the function/procedure is supposed to do with those arguments
                        	  1832: ;   3. If a procedure, you are finished: JMP MAIN
                        	  1833: ;      For a function, put the result into REG, and then JMP MAINP
                        	  1834: ;      - or - (equivalently): JSR PSHTOP, JMP MAIN
                        	  1835: ;
                        	  1836: ;  Note: PULTOP puts the value into REG and also: A, X and Y registers where A is the low-order
                        	  1837: ;        byte, X the middle byte, and Y the high-order byte.
                        	  1838: ;
                        	  1839: 
                        	  1840: ;                         Name           function or procedure   Args Execution address
                        	  1841: pascal_library_functions_table:
                        	  1842: ;
                        	  1843: ;    functions
                        	  1844: ;
                        	  1845:   makePasLibraryFunction "ABS",          SYMBOL_LIBRARY_FUNCTION,  1, EX_ABS
00:C581 414253          	     1M      asciiz   "ABS"
00:C584 00
00:C585 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:C586 01              	     3M      dfb      1
00:C587 6DB0            	     4M      word     EX_ABS
                        	  1846:   makePasLibraryFunction "DIGITALREAD",  SYMBOL_LIBRARY_FUNCTION,  1, EX_DIGITALREAD
00:C589 4449474954414C52	     1M      asciiz   "DIGITALREAD"
00:C591 454144
00:C594 00
00:C595 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:C596 01              	     3M      dfb      1
00:C597 E7B4            	     4M      word     EX_DIGITALREAD
                        	  1847:   makePasLibraryFunction "GETKEY",       SYMBOL_LIBRARY_FUNCTION,  0, EX_GETKEY
00:C599 4745544B4559    	     1M      asciiz   "GETKEY"
00:C59F 00
00:C5A0 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:C5A1 00              	     3M      dfb      0
00:C5A2 27B0            	     4M      word     EX_GETKEY
                        	  1848:   makePasLibraryFunction "RANDOM",       SYMBOL_LIBRARY_FUNCTION,  0, EX_RANDOM
00:C5A4 52414E444F4D    	     1M      asciiz   "RANDOM"
00:C5AA 00
00:C5AB 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:C5AC 00              	     3M      dfb      0
00:C5AD 0FB5            	     4M      word     EX_RANDOM
                        	  1849:   makePasLibraryFunction "LATENCY",      SYMBOL_LIBRARY_FUNCTION,  0, EX_LATENCY
00:C5AF 4C4154454E4359  	     1M      asciiz   "LATENCY"
00:C5B6 00
00:C5B7 52              	     2M      dfb      SYMBOL_LIBRARY_FUNCTION
00:C5B8 00              	     3M      dfb      0
00:C5B9 21B5            	     4M      word     EX_LATENCY
                        	  1850: ;
                        	  1851: ;      procedures
                        	  1852: ;
                        	  1853:   makePasLibraryFunction "ASSERT",       SYMBOL_LIBRARY_PROCEDURE, 1, EX_ASSERT
00:C5BB 415353455254    	     1M      asciiz   "ASSERT"
00:C5C1 00
00:C5C2 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C5C3 01              	     3M      dfb      1
00:C5C4 74B5            	     4M      word     EX_ASSERT
                        	  1854:   makePasLibraryFunction "DELAY",        SYMBOL_LIBRARY_PROCEDURE, 1, EX_DELAY
00:C5C6 44454C4159      	     1M      asciiz   "DELAY"
00:C5CB 00
00:C5CC 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C5CD 01              	     3M      dfb      1
00:C5CE 30B5            	     4M      word     EX_DELAY
                        	  1855:   makePasLibraryFunction "DIGITALWRITE", SYMBOL_LIBRARY_PROCEDURE, 2, EX_DIGITALWRITE
00:C5D0 4449474954414C57	     1M      asciiz   "DIGITALWRITE"
00:C5D8 52495445
00:C5DC 00
00:C5DD 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C5DE 02              	     3M      dfb      2
00:C5DF 5FB5            	     4M      word     EX_DIGITALWRITE
                        	  1856:   makePasLibraryFunction "LCDCLEAR",     SYMBOL_LIBRARY_PROCEDURE, 0, EX_LCDCLEAR
00:C5E1 4C4344434C454152	     1M      asciiz   "LCDCLEAR"
00:C5E9 00
00:C5EA 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C5EB 00              	     3M      dfb      0
00:C5EC 59B4            	     4M      word     EX_LCDCLEAR
                        	  1857:   makePasLibraryFunction "LCDHOME",      SYMBOL_LIBRARY_PROCEDURE, 0, EX_LCDHOME
00:C5EE 4C4344484F4D45  	     1M      asciiz   "LCDHOME"
00:C5F5 00
00:C5F6 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C5F7 00              	     3M      dfb      0
00:C5F8 53B4            	     4M      word     EX_LCDHOME
                        	  1858:   makePasLibraryFunction "LCDPOS",       SYMBOL_LIBRARY_PROCEDURE, 2, EX_LCDPOS
00:C5FA 4C4344504F53    	     1M      asciiz   "LCDPOS"
00:C600 00
00:C601 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C602 02              	     3M      dfb      2
00:C603 F5B4            	     4M      word     EX_LCDPOS
                        	  1859:   makePasLibraryFunction "PINMODE",      SYMBOL_LIBRARY_PROCEDURE, 2, EX_PINMODE
00:C605 50494E4D4F4445  	     1M      asciiz   "PINMODE"
00:C60C 00
00:C60D 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C60E 02              	     3M      dfb      2
00:C60F 50B5            	     4M      word     EX_PINMODE
                        	  1860:   makePasLibraryFunction "RANDOMSEED",   SYMBOL_LIBRARY_PROCEDURE, 1, EX_RANDOMSEED
00:C611 52414E444F4D5345	     1M      asciiz   "RANDOMSEED"
00:C619 4544
00:C61B 00
00:C61C 51              	     2M      dfb      SYMBOL_LIBRARY_PROCEDURE
00:C61D 01              	     3M      dfb      1
00:C61E 40B5            	     4M      word     EX_RANDOMSEED
00:C620 00              	  1861:   dfb 0   ; end of table
                        	  1862: 
                        	  1863: add_pascal_library_functions:
00:C621 A981            	  1864:   lda #<pascal_library_functions_table
00:C623 8500            	  1865:   sta REG
00:C625 A9C5            	  1866:   lda #>pascal_library_functions_table
00:C627 8501            	  1867:   sta REG+1
                        	  1868: add_pascal_library_functions_loop:
00:C629 A000            	  1869:   ldy #0
00:C62B B100            	  1870:   lda (REG),Y
00:C62D F04B            	  1871:   beq add_pascal_library_functions_done
00:C62F A500            	  1872:   lda REG
00:C631 8590            	  1873:   sta token_address
00:C633 A501            	  1874:   lda REG+1
00:C635 8591            	  1875:   sta token_address+1
00:C637 6492            	  1876:   stz token_length
                        	  1877: ;
                        	  1878: ;  find name length
                        	  1879: ;
                        	  1880: add_pascal_library_functions_name_loop
00:C639 C8              	  1881:   iny
00:C63A E692            	  1882:   inc token_length
00:C63C B100            	  1883:   lda (REG),Y
00:C63E D0F9            	  1884:   bne add_pascal_library_functions_name_loop
00:C640 5A              	  1885:   phy
00:C641 A943            	  1886:   lda #SYMBOL_CONSTANT  ; add the symbol as a constant for now
00:C643 20F9B8          	  1887:   jsr ADDSYM
00:C646 7A              	  1888:   ply
                        	  1889: 
00:C647 C8              	  1890:   iny             ; get past the 0x00
00:C648 B100            	  1891:   lda (REG),Y     ; get symbol type
00:C64A 5A              	  1892:   phy
00:C64B A003            	  1893:   ldy #SYMTYP
00:C64D 9140            	  1894:   sta (SYMITM),Y  ; change symbol type to be correct
00:C64F 7A              	  1895:   ply
                        	  1896: 
00:C650 C8              	  1897:   iny             ; get next byte
00:C651 B100            	  1898:   lda (REG),Y     ; get number of arguments
00:C653 5A              	  1899:   phy
00:C654 A006            	  1900:   ldy #SYMARG
00:C656 9140            	  1901:   sta (SYMITM),Y  ; save number of arguments
00:C658 7A              	  1902:   ply
                        	  1903: 
00:C659 C8              	  1904:   iny             ; get next byte
00:C65A B100            	  1905:   lda (REG),Y     ; get function address low-byte
00:C65C 5A              	  1906:   phy
00:C65D A004            	  1907:   ldy #SYMDSP
00:C65F 9140            	  1908:   sta (SYMITM),Y  ; save function address low-byte
00:C661 7A              	  1909:   ply
                        	  1910: 
00:C662 C8              	  1911:   iny             ; get next byte
00:C663 B100            	  1912:   lda (REG),Y     ; get function address high-byte
00:C665 5A              	  1913:   phy
00:C666 A005            	  1914:   ldy #SYMDSP+1
00:C668 9140            	  1915:   sta (SYMITM),Y  ; save function address high-byte
00:C66A 7A              	  1916:   ply
                        	  1917: 
00:C66B C8              	  1918:   iny         ; get past that last byte
00:C66C 98              	  1919:   tya         ; move REG onto next entry
00:C66D 18              	  1920:   clc
00:C66E 6500            	  1921:   adc REG
00:C670 8500            	  1922:   sta REG
00:C672 A900            	  1923:   lda #0
00:C674 6501            	  1924:   adc REG+1
00:C676 8501            	  1925:   sta REG+1
00:C678 80AF            	  1926:   bra add_pascal_library_functions_loop
                        	  1927: 
                        	  1928: add_pascal_library_functions_done:
00:C67A 60              	  1929:   rts
                        	  1930: 
                        	  1931: 
                        	  1932: library_function_call:
                        	  1933: 
00:C67B A900            	  1934:   lda  #0
00:C67D 854B            	  1935:   sta  COUNT1      ; number of arguments
00:C67F A006            	  1936:   ldy  #SYMARG
00:C681 B140            	  1937:   lda  (SYMITM),Y
00:C683 F032            	  1938:   beq  library_function_call_1
                        	  1939: 
                        	  1940: ;
                        	  1941: ;  here if it has arguments - push them on the stack
                        	  1942: ;
                        	  1943: 
00:C685 2001BA          	  1944:   jsr  CHKLHP
                        	  1945: library_function_call_2
00:C688 A54B            	  1946:   lda  COUNT1    ; save on stack in case the expression calls functions
00:C68A 48              	  1947:   pha
00:C68B 206BBA          	  1948:   jsr  SYMWRK
00:C68E 205F92          	  1949:   jsr  PSHWRK
00:C691 20BFBA          	  1950:   jsr  GETEXPR
00:C694 207292          	  1951:   jsr  PULWRK
00:C697 2076BA          	  1952:   jsr  WRKSYM
00:C69A 68              	  1953:   pla            ; get number of arguments back
00:C69B 854B            	  1954:   sta  COUNT1
00:C69D E64B            	  1955:   inc  COUNT1    ; add 1 for the one we just processed
00:C69F A593            	  1956:   lda  token_type
00:C6A1 C92C            	  1957:   cmp  #','
00:C6A3 F0E3            	  1958:   beq  library_function_call_2
                        	  1959: 
00:C6A5 A54B            	  1960:   lda  COUNT1
00:C6A7 A006            	  1961:   ldy  #SYMARG
00:C6A9 D140            	  1962:   cmp  (SYMITM),Y   ; check we got the right number of arguments
00:C6AB F005            	  1963:   beq  library_function_call_3
                        	  1964: 
00:C6AD A223            	  1965:   ldx  #35     ; ERROR: Parameters mismatched
00:C6AF 4C6497          	  1966:   jmp  ERROR
                        	  1967: library_function_call_3:
00:C6B2 2008BA          	  1968:   jsr  CHKRHP
00:C6B5 8003            	  1969:   bra  library_function_call_5
                        	  1970: 
                        	  1971: ;
                        	  1972: ;  here for no arguments
                        	  1973: ;
                        	  1974: 
                        	  1975: library_function_call_1:
00:C6B7 20A3CE          	  1976:   jsr  pas_get_token      ; one token look-ahead
                        	  1977: 
                        	  1978: library_function_call_5:
00:C6BA A004            	  1979:   ldy  #SYMDSP
00:C6BC B140            	  1980:   lda  (SYMITM),Y
00:C6BE 852B            	  1981:   sta  OPND
00:C6C0 C8              	  1982:   iny
00:C6C1 B140            	  1983:   lda  (SYMITM),Y
00:C6C3 852C            	  1984:   sta  OPND+1
00:C6C5 A903            	  1985:   lda  #PCODE_LIB_CALL
00:C6C7 2054C7          	  1986:   jsr  GENJMP
00:C6CA 60              	  1987:   rts
                        	  1988: 
                        	  1989: 
                        	  1990: ;***********************************************
                        	  1991: ; GENERATE P-CODES - NO OPERANDS
                        	  1992: ;***********************************************
                        	  1993: GENNOP   =  *
00:C6CB A442            	  1994:          LDY  SYNTAX
00:C6CD D011            	  1995:          BNE  GEN1      ; no storing/displaying if syntax-only compile
00:C6CF 9123            	  1996:          STA  (PCODE),Y
00:C6D1 48              	  1997:          PHA
00:C6D2 204392          	  1998:          JSR  DISPAD
00:C6D5 68              	  1999:          PLA
00:C6D6 A62E            	  2000:          LDX  DCODE
00:C6D8 F006            	  2001:          BEQ  GEN1
00:C6DA 203D92          	  2002:          JSR  DISHX
00:C6DD 202892          	  2003:          JSR  CROUT
                        	  2004: GEN1     =  *
00:C6E0 A901            	  2005:          LDA  #1      ; 1-byte P-code
00:C6E2 D035            	  2006:          BNE  GEN2_B
                        	  2007: ;***********************************************
                        	  2008: ; GENERATE P-CODES - WITH ADDRESS (3-bytes stored in DISPL (1)/OFFSET(2))
                        	  2009: ;***********************************************
                        	  2010: GENADR   =  *
00:C6E4 A442            	  2011:          LDY  SYNTAX
00:C6E6 D02F            	  2012:          BNE  GEN2    ; no storing/displaying if syntax-only compile
00:C6E8 9123            	  2013:          STA  (PCODE),Y
00:C6EA 48              	  2014:          PHA
00:C6EB A527            	  2015:          LDA  DISPL
00:C6ED C8              	  2016:          INY
00:C6EE 9123            	  2017:          STA  (PCODE),Y
00:C6F0 A529            	  2018:          LDA  OFFSET
00:C6F2 C8              	  2019:          INY
00:C6F3 9123            	  2020:          STA  (PCODE),Y
00:C6F5 A52A            	  2021:          LDA  OFFSET+1
00:C6F7 C8              	  2022:          INY
00:C6F8 9123            	  2023:          STA  (PCODE),Y
00:C6FA 204392          	  2024:          JSR  DISPAD
00:C6FD 68              	  2025:          PLA
00:C6FE A62E            	  2026:          LDX  DCODE
00:C700 F015            	  2027:          BEQ  GEN2
00:C702 203D92          	  2028:          JSR  DISHX
00:C705 A527            	  2029:          LDA  DISPL
00:C707 203D92          	  2030:          JSR  DISHX
00:C70A A529            	  2031:          LDA  OFFSET
00:C70C 203D92          	  2032:          JSR  DISHX
00:C70F A52A            	  2033:          LDA  OFFSET+1
00:C711 203D92          	  2034:          JSR  DISHX
00:C714 202892          	  2035:          JSR  CROUT
                        	  2036: GEN2     =  *
00:C717 A904            	  2037:          LDA  #4      ; 4-byte P-code
                        	  2038: GEN2_B   =  *
00:C719 18              	  2039:          CLC
00:C71A 6523            	  2040:          ADC  PCODE
00:C71C 8523            	  2041:          STA  PCODE
00:C71E 9002            	  2042:          BCC  GEN2_A
00:C720 E624            	  2043:          INC  PCODE+1
                        	  2044: GEN2_A   =  *
00:C722 A542            	  2045:          LDA  SYNTAX
00:C724 D013            	  2046:          BNE  GEN2_C      ; no storing/displaying if syntax-only compile
00:C726 A524            	  2047:          LDA  PCODE+1     ; see if P-codes full
00:C728 C532            	  2048:          CMP  ENDSYM+1   ; in other words, have we hit the symbol table?
00:C72A 900D            	  2049:          BCC  GEN2_C      ; less than
00:C72C D006            	  2050:          BNE  GEN_FULL
00:C72E A523            	  2051:          LDA  PCODE
00:C730 C531            	  2052:          CMP  ENDSYM   ; TODO - what?
00:C732 9005            	  2053:          BCC  GEN2_C
00:C734 A201            	  2054: GEN_FULL LDX  #1         ; MEM FULL
00:C736 4C6497          	  2055:          jmp  ERROR
                        	  2056: GEN2_C   =  *
00:C739 60              	  2057: DISP9    RTS
                        	  2058: ;***********************************************
                        	  2059: ; GENERATE P-CODES - JUMP ADDRESS (relative to current P-code address in OPND)
                        	  2060: ;***********************************************
                        	  2061: GENRJMP  =  *
00:C73A 48              	  2062:          PHA
00:C73B A52B            	  2063:          LDA  OPND
00:C73D 38              	  2064:          SEC
00:C73E E523            	  2065:          SBC  PCODE
00:C740 852B            	  2066:          STA  OPND      ; subtract P-code address to find difference
00:C742 A52C            	  2067:          LDA  OPND+1
00:C744 E524            	  2068:          SBC  PCODE+1
00:C746 852C            	  2069:          STA  OPND+1
00:C748 68              	  2070:          PLA
00:C749 4C54C7          	  2071:          JMP  GENJMP
                        	  2072: ;
                        	  2073: GENNJP   =  *
00:C74C A93C            	  2074:          LDA  #PCODE_JMP       ; JMP
                        	  2075: 
                        	  2076: ; Generate jump, P-code is in "A" register (eg. PCODE_JMZ, PCODE_JM1)
                        	  2077: ;
                        	  2078: ;  Note: the destination here is 0000, however FIXAD will be called later to fix up
                        	  2079: ;        the jump, once we know what the destination will be (ie. further down the code)
                        	  2080: ;
00:C74E A200            	  2081: GENNJM   LDX  #0
00:C750 862B            	  2082:          STX  OPND
00:C752 862C            	  2083:          STX  OPND+1
                        	  2084: ;
                        	  2085: ;***********************************************
                        	  2086: ; GENERATE P-CODES - JUMP ADDRESS (absolute address in OPND)
                        	  2087: ;   also used in other places, like increment stack address
                        	  2088: ;***********************************************
                        	  2089: GENJMP   =  *
00:C754 A442            	  2090:          LDY  SYNTAX
00:C756 D025            	  2091:          BNE  GEN3     ; no storing/displaying if syntax-only compile
00:C758 9123            	  2092:          STA  (PCODE),Y
00:C75A 48              	  2093:          PHA
00:C75B A52B            	  2094:          LDA  OPND
00:C75D C8              	  2095:          INY
00:C75E 9123            	  2096:          STA  (PCODE),Y
00:C760 A52C            	  2097:          LDA  OPND+1
00:C762 C8              	  2098:          INY
00:C763 9123            	  2099:          STA  (PCODE),Y
00:C765 204392          	  2100:          JSR  DISPAD
00:C768 68              	  2101:          PLA
00:C769 A62E            	  2102:          LDX  DCODE
00:C76B F010            	  2103:          BEQ  GEN3
00:C76D 203D92          	  2104:          JSR  DISHX
00:C770 A52B            	  2105:          LDA  OPND
00:C772 203D92          	  2106:          JSR  DISHX
00:C775 A52C            	  2107:          LDA  OPND+1
00:C777 203D92          	  2108:          JSR  DISHX
00:C77A 202892          	  2109:          JSR  CROUT
                        	  2110: GEN3     =  *
00:C77D A903            	  2111:          LDA  #3        ; 3-byte P-code
00:C77F 4C19C7          	  2112:          JMP  GEN2_B
                        	  2113: 
                        	  2114: ;***********************************************
                        	  2115: ; FIXUP ADDRESSES
                        	  2116: ;***********************************************
                        	  2117: FIXAD    =  *
00:C782 A442            	  2118:          LDY  SYNTAX
00:C784 D039            	  2119:          BNE  FIXAD1
00:C786 A001            	  2120:          LDY  #1
00:C788 A523            	  2121:          LDA  PCODE
00:C78A 38              	  2122:          SEC
00:C78B E537            	  2123:          SBC  WORK
00:C78D 9137            	  2124:          STA  (WORK),Y
00:C78F C8              	  2125:          INY
00:C790 A524            	  2126:          LDA  PCODE+1
00:C792 E538            	  2127:          SBC  WORK+1
00:C794 9137            	  2128:          STA  (WORK),Y
00:C796 A52E            	  2129:          LDA  DCODE
00:C798 F025            	  2130:          BEQ  FIXAD1
00:C79A A9C0            	  2131:          LDA  #<FIXM1
00:C79C A2C7            	  2132:          LDX  #>FIXM1
00:C79E 202682          	  2133:          JSR  print
00:C7A1 A538            	  2134:          LDA  WORK+1
00:C7A3 209D92          	  2135:          JSR  PRBYTE
00:C7A6 A537            	  2136:          LDA  WORK
00:C7A8 203D92          	  2137:          JSR  DISHX
00:C7AB A9C9            	  2138:          LDA  #<FIXM2
00:C7AD A2C7            	  2139:          LDX  #>FIXM2
00:C7AF 202682          	  2140:          JSR  print
00:C7B2 A524            	  2141:          LDA  PCODE+1
00:C7B4 209D92          	  2142:          JSR  PRBYTE
00:C7B7 A523            	  2143:          LDA  PCODE
00:C7B9 203D92          	  2144:          JSR  DISHX
00:C7BC 4C2892          	  2145:          JMP  CROUT
00:C7BF 60              	  2146: FIXAD1    rts
                        	  2147: 
00:C7C0 4A756D7020617420	  2148: FIXM1    asciiz  'Jump at '
00:C7C8 00
00:C7C9 6368616E67656420	  2149: FIXM2    asciiz  'changed to '   ; changed to
00:C7D1 746F20
00:C7D4 00
                        	  2150: 
                        	  2151: 

Source: "gpascal.asm"
                        	   184:   .include "hardware.inc"

Source: "hardware.inc"
                        	     1: 
                        	     2: ; VIA - Versatile Interface Adapter (W65C22) hardware
                        	     3: 
                        	     4: VIA_PORTB   = $7FF0   ; input/output register "B"
                        	     5: VIA_PORTA   = $7FF1   ; input/output register "A"
                        	     6: VIA_DDRB    = $7FF2   ; data direction register "B"
                        	     7: VIA_DDRA    = $7FF3   ; data direction register "A"
                        	     8: VIA_T1C_L   = $7FF4   ; T1 write: latch (L), read: counter (L)
                        	     9: VIA_T1C_H   = $7FF5   ; T1 high_order counter
                        	    10: VIA_T1L_L   = $7FF6   ; T1 low_order latches
                        	    11: VIA_T1L_H   = $7FF7   ; T1 high_order latches
                        	    12: VIA_T2C_L   = $7FF8   ; T2 write: latch (L), read: counter (L)
                        	    13: VIA_T2C_H   = $7FF9   ; T2 high_order counter
                        	    14: VIA_SR      = $7FFA   ; shift register
                        	    15: VIA_ACR     = $7FFB   ; auxilliary control register
                        	    16: VIA_PCR     = $7FFC   ; peripheral control register
                        	    17: VIA_IFR     = $7FFD   ; interrupt flag register
                        	    18: VIA_IER     = $7FFE   ; interrupt enable register
                        	    19: 
                        	    20: VIA_FLAG_ENABLE   = %10000000 ; high-order bit set enables the flag
                        	    21: VIA_FLAG_DISABLE  = %00000000 ; high-order bit clear disables the flag
                        	    22: VIA_FLAG_TIMER1   = %01000000
                        	    23: VIA_FLAG_TIMER2   = %00100000
                        	    24: VIA_FLAG_CB1      = %00010000
                        	    25: VIA_FLAG_CB2      = %00001000
                        	    26: VIA_FLAG_SHIFT    = %00000100
                        	    27: VIA_FLAG_CA1      = %00000010
                        	    28: VIA_FLAG_CA2      = %00000001
                        	    29: 
                        	    30: ;
                        	    31: ; VIA Port A pin masks
                        	    32: ;
                        	    33: 
                        	    34: SERIAL_IN_MASK     = %00000001   ; serial in on PA0 (also connect to CB2) (to FTDI TxD pin - pin 4)
                        	    35: SERIAL_OUT_MASK    = %00000010   ; serial out on PA1 (to FTDI RxD pin - pin 5)
                        	    36: SERIAL_DEBUG1_MASK = %00000100   ; serial debugging on PA2
                        	    37: SERIAL_DEBUG2_MASK = %00001000   ; serial debugging on PA3
                        	    38: SERIAL_SPARE2_MASK = %00010000   ; spare VIA pins (PA4)
                        	    39: 
                        	    40: 
                        	    41: ;***********************************************
                        	    42: ;  Functions added for Ben's Board
                        	    43: ;***********************************************
                        	    44: 
                        	    45: ;
                        	    46: ;  Converts a pin number in the range 0 to 15 to a mask
                        	    47: ;  eg. 00000001, 00000010, 00000100 and so on
                        	    48: ;
                        	    49: ;  Returns mask in Y
                        	    50: ;
                        	    51: ;  Returns with Z set if the range was 0 to 7 an
                        	    52: ;  and Z clear if the range was 8 to 15
                        	    53: ;
                        	    54: pin_number_to_mask = *
00:C7D5 48              	    55:   pha         ; save for a moment
00:C7D6 2907            	    56:   and #$7     ; make in range 0 to 7
00:C7D8 A8              	    57:   tay
00:C7D9 A901            	    58:   lda #1      ; initial mask
                        	    59: pin_number_to_mask_loop:
00:C7DB C000            	    60:   cpy #0
00:C7DD F004            	    61:   beq pin_number_to_mask_done
00:C7DF 0A              	    62:   asl A
00:C7E0 88              	    63:   dey
00:C7E1 80F8            	    64:   bra pin_number_to_mask_loop
                        	    65: pin_number_to_mask_done:
00:C7E3 A8              	    66:   tay         ; save mask in Y
00:C7E4 68              	    67:   pla
00:C7E5 2908            	    68:   and #$8     ; DDRA or DDRB ?
00:C7E7 60              	    69:   rts
                        	    70: 
                        	    71: ;
                        	    72: ;  pin in A, mode in X
                        	    73: ;
                        	    74: pinmode:
00:C7E8 868C            	    75:   stx hardware_work ; input or output
00:C7EA 20D5C7          	    76:   jsr pin_number_to_mask  ; convert to appropriate mask bit
00:C7ED D00A            	    77:   bne pinmode_B        ; Z is clear if it is DDRB
00:C7EF A9F3            	    78:   lda #<VIA_DDRA
00:C7F1 8500            	    79:   sta REG
00:C7F3 A97F            	    80:   lda #>VIA_DDRA
00:C7F5 8501            	    81:   sta REG+1
00:C7F7 8008            	    82:   bra pinmode_C
                        	    83: pinmode_B:
00:C7F9 A9F2            	    84:   lda #<VIA_DDRB
00:C7FB 8500            	    85:   sta REG
00:C7FD A97F            	    86:   lda #>VIA_DDRB
00:C7FF 8501            	    87:   sta REG+1
                        	    88: ;
                        	    89: ;  The DDR register is now in REG
                        	    90: ;
                        	    91: pinmode_C:
00:C801 A58C            	    92:   lda hardware_work     ; input or output?
00:C803 D00A            	    93:   bne pinmode_OUTPUT
                        	    94: ;
                        	    95: ;  here to set input mode
                        	    96: ;
00:C805 98              	    97:   tya       ; get the mask back
00:C806 A000            	    98:   ldy #0
00:C808 49FF            	    99:   eor #$FF  ; negate the mask
00:C80A 3100            	   100:   and (REG),y
00:C80C 9100            	   101:   sta (REG),y
00:C80E 60              	   102:   rts       ; done
                        	   103: ;
                        	   104: ;  here to set output mode
                        	   105: ;
                        	   106: pinmode_OUTPUT:
00:C80F 98              	   107:   tya          ; get the mask back
00:C810 A000            	   108:   ldy #0
00:C812 1100            	   109:   ora (REG),y  ; or in with the existing DDR register
00:C814 9100            	   110:   sta (REG),y  ; and write it back
00:C816 60              	   111:   rts          ; done
                        	   112: 
                        	   113: 
                        	   114: ;
                        	   115: ;  DIGITALWRITE (pin, value) pin:0 to 15; value: 0 or 1 : pin in A, mode in X
                        	   116: ;
                        	   117: digitalwrite = *
00:C817 868C            	   118:   stx hardware_work ; save what to write (0 or 1)
00:C819 20D5C7          	   119:   jsr pin_number_to_mask  ; convert to appropriate mask bit
00:C81C D00A            	   120:   bne digitalwrite_B        ; Z is clear if it is PORTB
00:C81E A9F1            	   121:   lda #<VIA_PORTA
00:C820 8500            	   122:   sta REG
00:C822 A97F            	   123:   lda #>VIA_PORTA
00:C824 8501            	   124:   sta REG+1
00:C826 8008            	   125:   bra digitalwrite_C
                        	   126: digitalwrite_B:
00:C828 A9F0            	   127:   lda #<VIA_PORTB
00:C82A 8500            	   128:   sta REG
00:C82C A97F            	   129:   lda #>VIA_PORTB
00:C82E 8501            	   130:   sta REG+1
                        	   131: ;
                        	   132: ;  The PORT register is now in REG
                        	   133: ;
                        	   134: digitalwrite_C:
00:C830 A58C            	   135:   lda hardware_work
00:C832 D00A            	   136:   bne digitalwrite_ONE  ; any non-zero value is writing a 1
                        	   137: ;
                        	   138: ;  here to write a zero
                        	   139: ;
00:C834 98              	   140:   tya
00:C835 A000            	   141:   ldy #0
00:C837 49FF            	   142:   eor #$FF  ; negate the mask
00:C839 3100            	   143:   and (REG),y
00:C83B 9100            	   144:   sta (REG),y
00:C83D 60              	   145:   rts       ; done
                        	   146: 
                        	   147: ;
                        	   148: ;  here to write a one
                        	   149: ;
                        	   150: digitalwrite_ONE:
00:C83E 98              	   151:   tya          ; get the mask back
00:C83F A000            	   152:   ldy #0
00:C841 1100            	   153:   ora (REG),y  ; or in with the existing DDR register
00:C843 9100            	   154:   sta (REG),y  ; and write it back
00:C845 60              	   155:   rts          ; done
                        	   156: 
                        	   157: 
                        	   158: ;
                        	   159: ;  DIGITALREAD (pin) pin:0 to 15; Pin to read is in in A. returns or non-zero in A.
                        	   160: ;
                        	   161: digitalread = *
00:C846 20D5C7          	   162:   jsr pin_number_to_mask  ; convert to appropriate mask bit
00:C849 D00A            	   163:   bne digitalread_B        ; Z is clear if it is PORTB
00:C84B A9F1            	   164:   lda #<VIA_PORTA
00:C84D 8500            	   165:   sta REG
00:C84F A97F            	   166:   lda #>VIA_PORTA
00:C851 8501            	   167:   sta REG+1
00:C853 8008            	   168:   bra digitalread_C
                        	   169: digitalread_B:
00:C855 A9F0            	   170:   lda #<VIA_PORTB
00:C857 8500            	   171:   sta REG
00:C859 A97F            	   172:   lda #>VIA_PORTB
00:C85B 8501            	   173:   sta REG+1
                        	   174: ;
                        	   175: ;  The PORT register is now in REG
                        	   176: ;
                        	   177: digitalread_C:
00:C85D 98              	   178:   tya         ; get the mask back
00:C85E A000            	   179:   ldy #0
00:C860 3100            	   180:   and (REG),y ; get that bit
00:C862 60              	   181:   rts
                        	   182: 
                        	   183: 
                        	   184: 
                        	   185: ;
                        	   186: ;  Functions to change where writing is done
                        	   187: ;
                        	   188: write_to_serial:
00:C863 48              	   189:   pha
00:C864 A9BF            	   190:   lda  #<write_char
00:C866 8517            	   191:   sta  write_function
00:C868 A9C8            	   192:   lda  #>write_char
00:C86A 8518            	   193:   sta  write_function+1
00:C86C 68              	   194:   pla
00:C86D 60              	   195:   rts
                        	   196: 
                        	   197: write_to_lcd:
00:C86E 48              	   198:   pha
00:C86F A91F            	   199:   lda  #<lcd_print_char
00:C871 8517            	   200:   sta  write_function
00:C873 A9B8            	   201:   lda  #>lcd_print_char
00:C875 8518            	   202:   sta  write_function+1
00:C877 68              	   203:   pla
00:C878 60              	   204:   rts
                        	   205: 
                        	   206: 
                        	   207: 
                        	   208: ; ---------------------------
                        	   209: ; Simulate kernel interfaces
                        	   210: ; ---------------------------
                        	   211: ; We interface by reading/writing to special
                        	   212: ; RAM that is implemented in the emulator
                        	   213: 
                        	   214: 
                        	   215: 
                        	   216:     .if EMULATOR
                        	   217: 
                        	   218: ;
                        	   219: ;  Emulator testing
                        	   220: ;
                        	   221: CHRIN    =  *
                        	   222:          lda  $7F22
                        	   223:          rts
                        	   224: 
                        	   225: write_char   =  *
                        	   226:          sta  $7F23
                        	   227:          rts
                        	   228: 
                        	   229: 
                        	   230: GETIN    =  *
                        	   231:          lda  $7F29
                        	   232:          rts
                        	   233: 
                        	   234: hardware_init rts
                        	   235: 
                        	   236: ;
                        	   237: ;  put debug number in A
                        	   238: ;
                        	   239: EMULATOR_DEBUG = *
                        	   240:          sta $7F46
                        	   241:          rts
                        	   242: 
                        	   243: START_TRACE = *
                        	   244:          sta $7F47
                        	   245:          rts
                        	   246: 
                        	   247: STOP_TRACE = *
                        	   248:          sta $7F48
                        	   249:          rts
                        	   250: ;
                        	   251: ;  not applicable in emulator
                        	   252: ;
                        	   253: lcd_print_message   rts
                        	   254: lcd_clear_display   rts
                        	   255: lcd_print_char      rts
                        	   256: lcd_second_line     rts
                        	   257: lcd_instruction     rts
                        	   258: lcd_get_address     rts
                        	   259: lcd_wait            rts
                        	   260: lcd_home            rts
                        	   261: lcd_initialise      rts
                        	   262: serial_available    rts
                        	   263: serial_print_message rts
                        	   264: 
                        	   265:   .else
                        	   266: 
                        	   267: ;
                        	   268: ;  Ben's Board
                        	   269: ;
                        	   270: 
                        	   271: ;
                        	   272: ;  typing_latency could be used as a seed for the random number generator
                        	   273: ;    - the exact time between keypresses would be somewhat unpredictable
                        	   274: ;
                        	   275: CHRIN  = *
                        	   276: GETIN    =  *
00:C879 E60D            	   277:          inc typing_latency
00:C87B D006            	   278:          bne GETIN1
00:C87D E60E            	   279:          inc typing_latency+1
00:C87F D002            	   280:          bne GETIN1
00:C881 E60F            	   281:          inc typing_latency+2
                        	   282: GETIN1:
00:C883 A58B            	   283:          lda serial_in_byte_received
00:C885 F0F2            	   284:          beq GETIN    ; nothing yet
00:C887 648B            	   285:          stz serial_in_byte_received
00:C889 60              	   286:          rts
                        	   287: 
                        	   288: serial_available = *
00:C88A A58B            	   289:          lda serial_in_byte_received
00:C88C 60              	   290:          rts
                        	   291: 
                        	   292: 
00:C88D 60              	   293: EMULATOR_DEBUG rts
00:C88E 60              	   294: START_TRACE rts
00:C88F 60              	   295: STOP_TRACE rts
                        	   296: 
                        	   297: 
                        	   298: ;
                        	   299: ;  set up serial hardware
                        	   300: ;
                        	   301: 
                        	   302: hardware_init:
                        	   303: 
00:C890 ADF17F          	   304:   lda VIA_PORTA
00:C893 0902            	   305:   ora #SERIAL_OUT_MASK  ; set 1 bit (idle serial comms)
00:C895 8DF17F          	   306:   sta VIA_PORTA
                        	   307: 
                        	   308:   ; set output enable bits
00:C898 A91E            	   309:   lda #(SERIAL_OUT_MASK | SERIAL_DEBUG1_MASK | SERIAL_DEBUG2_MASK | SERIAL_SPARE2_MASK)
00:C89A 8DF37F          	   310:   sta VIA_DDRA
                        	   311: 
00:C89D A940            	   312:   lda #%01000000      ; continuous interrupts on T1
00:C89F 8DFB7F          	   313:   sta VIA_ACR
                        	   314: 
00:C8A2 A9D0            	   315:   lda #<BIT_INTERVAL  ; ie. baud rate interval
00:C8A4 8DF47F          	   316:   sta VIA_T1C_L       ; for sending bits
00:C8A7 A900            	   317:   lda #>BIT_INTERVAL
00:C8A9 8DF57F          	   318:   sta VIA_T1C_H       ; this starts the counter
                        	   319: 
                        	   320:   ; set up for serial input
                        	   321: 
00:C8AC A988            	   322:   lda #VIA_FLAG_ENABLE | VIA_FLAG_CB2  ; interrupt on CB2 falling edge
00:C8AE 8DFE7F          	   323:   sta VIA_IER
                        	   324: 
00:C8B1 A9FF            	   325:   lda #$FF         ; clear all interrupt flags
00:C8B3 8DFD7F          	   326:   sta VIA_IFR
                        	   327: 
                        	   328:   .if LCD_SUPPORT
00:C8B6 2017B7          	   329:   jsr lcd_initialise
                        	   330:   .endif
                        	   331: 
00:C8B9 648A            	   332:   stz serial_in_byte    ; non-zero means an interrupt put in incoming byte there
00:C8BB 6489            	   333:   stz serial_out_bit
                        	   334: 
00:C8BD 58              	   335:   cli         ; enable interrupts
00:C8BE 60              	   336:   rts
                        	   337: 
                        	   338: 
                        	   339: ;
                        	   340: ;  Write a character (in A) to the serial port.
                        	   341: ;   Interrupts MUST be enabled for this to work!
                        	   342: ;
                        	   343: write_char:
00:C8BF 48              	   344:   pha                   ; save original character
00:C8C0 0A              	   345:   asl a                 ; shift in a zero which will be the start bit
00:C8C1 8587            	   346:   sta serial_out_byte
00:C8C3 A9FF            	   347:   lda #0xff             ; will become the stop bit(s)
00:C8C5 2A              	   348:   rol a                 ; rotate in the high-order bit from the data byte
00:C8C6 8588            	   349:   sta serial_out_byte+1
00:C8C8 A90B            	   350:   lda #11               ; 8 data bits, one start bit, two stop bits
00:C8CA 8589            	   351:   sta serial_out_bit    ; number of bits to shift out
00:C8CC A9D0            	   352:   lda #<BIT_INTERVAL    ; ie. baud rate interval
00:C8CE 8DF47F          	   353:   sta VIA_T1C_L         ; for sending bits
00:C8D1 A900            	   354:   lda #>BIT_INTERVAL
00:C8D3 8DF57F          	   355:   sta VIA_T1C_H         ; this starts the counter
00:C8D6 A9C0            	   356:   lda #VIA_FLAG_ENABLE | VIA_FLAG_TIMER1  ; interrupt on T1 timeout
00:C8D8 8DFE7F          	   357:   sta VIA_IER
                        	   358: 
                        	   359: ;
                        	   360: ; wait for this byte to finish - otherwise it might interfere with many things
                        	   361: ;
                        	   362: 
                        	   363: write_char_loop:
00:C8DB ADFE7F          	   364:   lda VIA_IER
00:C8DE 2940            	   365:   and #VIA_FLAG_TIMER1  ; are T1 interrupts enabled?
00:C8E0 D0F9            	   366:   bne write_char_loop   ; loop until this character sent
00:C8E2 68              	   367:   pla                   ; get character back
00:C8E3 60              	   368:   rts
                        	   369: 
                        	   370: 
                        	   371: ;
                        	   372: ;  sends null-terminated message to serial port, message in A (lo) and X (hi)
                        	   373: ;  returns the length of the message in Y
                        	   374: ;
                        	   375: serial_print_message:
00:C8E4 8503            	   376:   sta REG2
00:C8E6 8604            	   377:   stx REG2+1
00:C8E8 A000            	   378:   ldy #0
                        	   379: serial_print:
00:C8EA B103            	   380:   lda (REG2),y
00:C8EC F006            	   381:   beq serial_print_done
00:C8EE 20BFC8          	   382:   jsr write_char
00:C8F1 C8              	   383:   iny
00:C8F2 80F6            	   384:   bra serial_print
                        	   385: 
00:C8F4 60              	   386: serial_print_done rts
                        	   387: 
                        	   388:   .endif  ; not EMULATOR
                        	   389: 
                        	   390: 

Source: "gpascal.asm"
                        	   185:   .include "gtoken.inc"

Source: "gtoken.inc"
                        	     1: ;
                        	     2: ;  get_token
                        	     3: ;
                        	     4: ;  Gets a lexical token from the specified address.
                        	     5: ;
                        	     6: ;  - Start parsing at token_start (this should be the first character of the token)
                        	     7: ;  - The first found character (after spaces, comments, newlines) is in token_address
                        	     8: ;      - this is mainly used for knowing what the identifier is so we can put it in the symbol table
                        	     9: ;      - strings are put into INBUF after processing, so token_address is not as useful in that case
                        	    10: ;  - The length is in token_length (in the case of strings, this is the processed length)
                        	    11: ;  - The type is in token_type - zero would mean end of file
                        	    12: ;
                        	    13: ;  The types are one of the token codes below
                        	    14: ;
                        	    15: ;  Tokens which start with a letter and are possibly followed by letters, numbers, and
                        	    16: ;    the underscore character become TOKEN_IDENTIFIER.
                        	    17: ;
                        	    18: ;  Tokens starting with a number (TOKEN_NUMBER) are parsed for the value which is placed into token_value.
                        	    19: ;
                        	    20: ;  Tokens starting with a single or double quote are parsed for the internal string (TOKEN_STRING)
                        	    21: ;  which is placed in INBUF. The internal string has internal double-quotes turned
                        	    22: ;  into single quotes, and sequences like \n or \x42 turned into their appropriate characters.
                        	    23: ;
                        	    24: ;  String tokens which are up to 3 bytes long also have the 3 bytes placed into token_value.
                        	    25: ;
                        	    26: ;  Hex and binary tokens are parsed for their value which is placed into token_value.
                        	    27: ;
                        	    28: ;  Various 2-character tokens are given their own code (eg. <> == != := << >> and so on).
                        	    29: ;
                        	    30: ;  Spaces and comments are skipped, however Pascal directives inside comments are processed
                        	    31: ;
                        	    32: ;  Newlines are skipped in Pascal but returned as a token in assembler (ASSEMBLING == true)
                        	    33: ;  If newlines are skipped then token_line is called to handle listing the line (the line
                        	    34: ;   we are about to process, not the previous line)
                        	    35: ;
                        	    36: ; Rewritten in February 2022 to be easier to read and have well-defined work variables (zero-page variables)
                        	    37: 
                        	    38: ; multi-byte token codes (single byte tokens are themselves)
                        	    39: 
                        	    40: TOKEN_ASSIGN     = 'A'   ; :=
                        	    41: TOKEN_IDENTIFIER = 'I'   ; alpha-numeric identifiers
                        	    42: TOKEN_NUMBER     = 'N'   ; numbers
                        	    43: TOKEN_STRING     = '"'   ; string literal
                        	    44: TOKEN_LEQ        = $80   ; <=
                        	    45: TOKEN_GEQ        = $81   ; >=
                        	    46: TOKEN_NEQ        = 'U'   ; <>
                        	    47: 
                        	    48: ;
                        	    49: ;  the ones below are used in the assembler
                        	    50: ;
                        	    51: TOKEN_EQUALITY    = 'E'     ; ==
                        	    52: TOKEN_SHIFT_LEFT  = 'L'     ; <<
                        	    53: TOKEN_SHIFT_RIGHT = 'R'     ; >>
                        	    54: TOKEN_UNARY_MINUS = 'M'     ; -
                        	    55: TOKEN_LOW_BYTE    = 'V'     ; eg. lda #<foo
                        	    56: TOKEN_HIGH_BYTE   = 'W'     ; eg. lda #>foo
                        	    57: TOKEN_LOGICAL_AND = 'X'     ; &&
                        	    58: TOKEN_LOGICAL_OR  = 'Y'     ; ||
                        	    59: TOKEN_INEQUALITY  = 'Z'     ; !=
                        	    60: 
                        	    61: 
                        	    62: get_token:
00:C8F5 A593            	    63:   lda token_type      ; remember previous token for checking if + or - stand on their own
00:C8F7 8598            	    64:   sta token_work
                        	    65: get_token_loop:
00:C8F9 A000            	    66:   ldy #0              ; offset into the token address
00:C8FB 8497            	    67:   sty token_sign      ; Y is zero at this point
00:C8FD 8494            	    68:   sty token_value     ; no value yet
00:C8FF 8495            	    69:   sty token_value+1
00:C901 8496            	    70:   sty token_value+2
                        	    71: 
                        	    72: gc_skip_spaces:
00:C903 B18E            	    73:   lda (token_start),y
00:C905 F034            	    74:   beq gc_done         ; 0x00 means end, so return it WITHOUT incrementing the pointer
00:C907 C90A            	    75:   cmp #NL             ; newline need special handling
00:C909 F00D            	    76:   beq gc_newline
00:C90B 204A81          	    77:   jsr isspace
00:C90E 9043            	    78:   bcc gc_not_space
00:C910 E68E            	    79:   inc token_start     ; increment pointer because spaces can be any length
00:C912 D0EF            	    80:   bne gc_skip_spaces
00:C914 E68F            	    81:   inc token_start+1
00:C916 80EB            	    82:   bra gc_skip_spaces
                        	    83: 
                        	    84: ;
                        	    85: ;  got a newline - if assembling, return that so we know where lines end
                        	    86: ;  otherwise just call token_line to display the next line and press on looking
                        	    87: ;  for tokens.
                        	    88: ;
                        	    89: gc_newline:
00:C918 A902            	    90:   lda #FLAG_ASSEMBLING
00:C91A 25BE            	    91:   and system_flags
00:C91C D014            	    92:   bne gc_newline_assembling    ; return the newline as a token
00:C91E C8              	    93:   iny              ; length in Y (ie. one)
00:C91F E68E            	    94:   inc token_start
00:C921 D002            	    95:   bne gc_newline1
00:C923 E68F            	    96:   inc token_start+1
                        	    97: gc_newline1:
00:C925 A58E            	    98:   lda token_start
00:C927 859C            	    99:   sta token_line_start
00:C929 A58F            	   100:   lda token_start+1
00:C92B 859D            	   101:   sta token_line_start+1
00:C92D 2095C9          	   102:   jsr token_line        ; list the next line
00:C930 80C7            	   103:   bra get_token_loop    ; look for another token
                        	   104: 
                        	   105: gc_newline_assembling:
00:C932 A90A            	   106:   lda #NL       ; get the newline back
00:C934 4C39C9          	   107:   jmp gc_single_byte_token
                        	   108: 
                        	   109: ;
                        	   110: ;  wrap up getting a token:
                        	   111: ;
                        	   112: ;   - save the type
                        	   113: ;   - save the current address as token_address
                        	   114: ;   - add the length to token_start ready for next time
                        	   115: ;
                        	   116: gc_single_byte_already_known:
00:C937 A593            	   117:   lda token_type        ; get back saved token type
                        	   118: gc_single_byte_token:
00:C939 A001            	   119:   ldy #1
                        	   120: gc_done:
00:C93B 8492            	   121:   sty token_length      ; Y has our length
00:C93D 8593            	   122:   sta token_type        ; A has our type
00:C93F 18              	   123:   clc
00:C940 A58E            	   124:   lda token_start
00:C942 8590            	   125:   sta token_address     ; save the starting address of the token
00:C944 6592            	   126:   adc token_length      ; now add its length
00:C946 858E            	   127:   sta token_start       ; that gives the ending address
                        	   128: 
00:C948 A58F            	   129:   lda token_start+1     ; repeat for high-order byte
00:C94A 8591            	   130:   sta token_address+1
00:C94C 6900            	   131:   adc #0
00:C94E 858F            	   132:   sta token_start+1
                        	   133: 
00:C950 A593            	   134:   lda token_type        ; get token type back into A
00:C952 60              	   135:   rts
                        	   136: 
                        	   137: ;
                        	   138: ;  not a space (or newline) so this must be the actual start of it
                        	   139: ;
                        	   140: 
                        	   141: gc_not_space:
                        	   142: 
                        	   143: ;
                        	   144: ;  first look for classes of characters (ie. alpha, numeric)
                        	   145: ;
00:C953 202681          	   146:   jsr isalpha
00:C956 9026            	   147:   bcc gc_not_alpha
                        	   148: 
                        	   149: ;
                        	   150: ;  find end of identifier
                        	   151: ;
                        	   152: gc_alpha_loop:
00:C958 C8              	   153:   iny
00:C959 D005            	   154:   bne gc_alpha_ok   ; if it becomes zero now, we have 256+ long identifier
00:C95B A20C            	   155:   ldx #12       ; ERROR: Illegal Identifier (too long)
00:C95D 4C6497          	   156:   jmp ERROR
                        	   157: 
                        	   158: gc_alpha_ok:
00:C960 A940            	   159:   lda #FLAG_ONLY_ALPHA
00:C962 24BE            	   160:   bit system_flags
00:C964 D00F            	   161:   bne gc_alpha_alpha_only
00:C966 B18E            	   162:   lda (token_start),y
00:C968 206281          	   163:   jsr isalnum
00:C96B B0EB            	   164:   bcs gc_alpha_loop
00:C96D C95F            	   165:   cmp #'_'
00:C96F F0E7            	   166:   beq gc_alpha_loop
                        	   167: 
                        	   168: ;
                        	   169: ; end of identifier
                        	   170: ;
                        	   171: gc_alpha_done:
00:C971 A949            	   172:   lda #TOKEN_IDENTIFIER
00:C973 80C6            	   173:   bra gc_done
                        	   174: 
                        	   175: 
                        	   176: gc_alpha_alpha_only:
00:C975 B18E            	   177:   lda (token_start),y
00:C977 202681          	   178:   jsr isalpha
00:C97A B0DC            	   179:   bcs gc_alpha_loop
00:C97C 80F3            	   180:   bra gc_alpha_done
                        	   181: 
                        	   182: ;
                        	   183: ; now see if it is a digit
                        	   184: ;
                        	   185: gc_not_alpha:
00:C97E 203281          	   186:   jsr isdigit
00:C981 9007            	   187:   bcc gc_not_digit
                        	   188: 
00:C983 20E4C9          	   189:   jsr atoi
00:C986 A94E            	   190:   lda  #TOKEN_NUMBER
00:C988 80B1            	   191:   bra  gc_done
                        	   192: 
                        	   193: ;
                        	   194: ;  not alpha and not digit - so let's consider:
                        	   195: ;   * prefixes: $ for hex and % for binary
                        	   196: ;   *  + or - in front of numbers or on their own
                        	   197: ;   * single character tokens, eg. =, (, ) and so on
                        	   198: ;   * double-character tokens, eg. ==, >= << and so on
                        	   199: ;   * strings, eg. "foo"
                        	   200: ;
                        	   201: ;  we'll do a jump on the first character
                        	   202: ;
                        	   203: gc_not_digit:
00:C98A 8593            	   204:   sta token_type            ; remember it in case of possible two-byte sequences
00:C98C A272            	   205:   ldx #<gtoken_table
00:C98E A0CA            	   206:   ldy #>gtoken_table
00:C990 20928F          	   207:   jsr TKNJMP
00:C993 80A2            	   208:   bra gc_single_byte_already_known  ; it is what it is
                        	   209: 
                        	   210: ;
                        	   211: ;  here when get_token discovers a newline - print the next line if wanted
                        	   212: ;
                        	   213: 
                        	   214: token_line:
                        	   215: ;
                        	   216: ;  count lines
                        	   217: ;
00:C995 E6A2            	   218:   inc current_line
00:C997 D002            	   219:   bne token_line1
00:C999 E6A3            	   220:   inc current_line+1
                        	   221: token_line1:
                        	   222: ;
                        	   223: ;  compiling or assembling?
                        	   224: ;
00:C99B A901            	   225:   lda #FLAG_COMPILING
00:C99D 0902            	   226:   ora #FLAG_ASSEMBLING
00:C99F 25BE            	   227:   and system_flags
00:C9A1 F040            	   228:   beq token_line_done ; no - no listing
                        	   229: ;
                        	   230: ;  listing wanted?
                        	   231: ;
00:C9A3 A904            	   232:   lda #FLAG_LIST_SOURCE
00:C9A5 25BE            	   233:   and system_flags
00:C9A7 D00D            	   234:   bne token_line_listing ; yes
                        	   235: 
                        	   236: ;
                        	   237: ;  no listing - show an asterisk every 15 lines
                        	   238: ;
00:C9A9 A5A2            	   239:   lda current_line
00:C9AB 290F            	   240:   and #$0F
00:C9AD D034            	   241:   bne token_line_done
00:C9AF A92A            	   242:   lda #'*'
00:C9B1 20AF93          	   243:   jsr COUT
00:C9B4 802D            	   244:   bra token_line_done
                        	   245: 
                        	   246: token_line_listing:
00:C9B6 A52E            	   247:   lda DCODE
00:C9B8 48              	   248:   pha
00:C9B9 A901            	   249:   lda #1
00:C9BB 852E            	   250:   sta DCODE
00:C9BD 204392          	   251:   jsr DISPAD
00:C9C0 68              	   252:   pla
00:C9C1 852E            	   253:   sta DCODE
00:C9C3 201E8C          	   254:   jsr show_current_line_number
                        	   255: 
00:C9C6 A59C            	   256:   lda token_line_start
00:C9C8 8598            	   257:   sta token_work
00:C9CA A59D            	   258:   lda token_line_start+1
00:C9CC 8599            	   259:   sta token_work+1
                        	   260: 
                        	   261: token_line_loop:
00:C9CE A000            	   262:   ldy #0
00:C9D0 B198            	   263:   lda (token_work),Y
00:C9D2 F00F            	   264:   beq token_line_done
00:C9D4 48              	   265:   pha
00:C9D5 20AF93          	   266:   jsr COUT
00:C9D8 E698            	   267:   inc token_work
00:C9DA D002            	   268:   bne token_line_loop1
00:C9DC E699            	   269:   inc token_work+1
                        	   270: token_line_loop1:
00:C9DE 68              	   271:   pla
00:C9DF C90A            	   272:   cmp #NL
00:C9E1 D0EB            	   273:   bne token_line_loop
                        	   274: 
                        	   275: token_line_done:
00:C9E3 60              	   276:   rts
                        	   277: 
                        	   278: 
                        	   279: ;
                        	   280: ;  atoi
                        	   281: ;
                        	   282: ; get a decimal number - returns carry flag set if bad number and running
                        	   283: ;   (if compiling and a bad number gives an error)
                        	   284: ;
                        	   285: ;  token_start : the start address of the number
                        	   286: ;  Y : offset into token_start
                        	   287: ;  token_sign : non-zero if negative
                        	   288: ;
                        	   289: ;  returns: token_value  and carry clear (if no error)
                        	   290: ;           carry set if error (for use at runtime)
                        	   291: ;           Y at offset of first non-numeric character
                        	   292: 
                        	   293: atoi:
00:C9E4 38              	   294:   sec
00:C9E5 E930            	   295:   sbc  #'0'   ;  ; subtract out ASCII stuff, save first digit
00:C9E7 8594            	   296:   sta  token_value
00:C9E9 6495            	   297:   stz  token_value+1
00:C9EB 6496            	   298:   stz  token_value+2
                        	   299: atoi_loop    =  *
00:C9ED C8              	   300:   iny
00:C9EE B18E            	   301:   lda  (token_start),y
00:C9F0 203281          	   302:   jsr  isdigit
00:C9F3 B009            	   303:   bcs  atoi_more      ; more digits
                        	   304: ;
                        	   305: ; end of number - make negative if we got a sign earlier
                        	   306: ;
00:C9F5 A597            	   307:   lda  token_sign
00:C9F7 F003            	   308:   beq  atoi_positive    ; not signed
                        	   309: ;
                        	   310: ;  make negative
                        	   311: ;
00:C9F9 205ECA          	   312:   jsr negate_token_value
                        	   313: ;
                        	   314: ;  done! clear carry and return
                        	   315: ;
                        	   316: atoi_positive:
00:C9FC 18              	   317:   clc                   ; indicate no error for numeric conversion
00:C9FD 60              	   318:   rts
                        	   319: ;
                        	   320: ;  Multiply previous value by 10, add in new digit
                        	   321: ;
                        	   322: atoi_more    =  *
00:C9FE 38              	   323:   sec
00:C9FF E930            	   324:   sbc  #'0'
00:CA01 859B            	   325:   sta  token_digit
00:CA03 0694            	   326:   asl  token_value         ; multiply token_value by 2
00:CA05 2695            	   327:   rol  token_value+1
00:CA07 2696            	   328:   rol  token_value+2
00:CA09 3048            	   329:   bmi  atoi_error
                        	   330: 
00:CA0B A594            	   331:   lda  token_value         ; save token_value*2 in token_work
00:CA0D 8598            	   332:   sta  token_work
00:CA0F A595            	   333:   lda  token_value+1
00:CA11 8599            	   334:   sta  token_work+1
00:CA13 A596            	   335:   lda  token_value+2
00:CA15 859A            	   336:   sta  token_work+2
                        	   337: 
00:CA17 0694            	   338:   asl  token_value         ; now token_value is multiplied by 4
00:CA19 2695            	   339:   rol  token_value+1
00:CA1B 2696            	   340:   rol  token_value+2
00:CA1D 3034            	   341:   bmi  atoi_error
                        	   342: 
00:CA1F 0694            	   343:   asl  token_value         ; now token_value is multiplied by 8
00:CA21 2695            	   344:   rol  token_value+1
00:CA23 2696            	   345:   rol  token_value+2
00:CA25 302C            	   346:   bmi  atoi_error
                        	   347: 
00:CA27 A598            	   348:   lda  token_work          ; now add back in token_value*2 (giving token_value*10)
00:CA29 6594            	   349:   adc  token_value
00:CA2B 8594            	   350:   sta  token_value
00:CA2D A599            	   351:   lda  token_work+1
00:CA2F 6595            	   352:   adc  token_value+1
00:CA31 8595            	   353:   sta  token_value+1
00:CA33 A59A            	   354:   lda  token_work+2
00:CA35 6596            	   355:   adc  token_value+2
00:CA37 8596            	   356:   sta  token_value+2
00:CA39 3018            	   357:   bmi  atoi_error      ; if negative, the number was too big
00:CA3B 18              	   358:   clc
00:CA3C A594            	   359:   lda  token_value     ; now take the value and add in our new digit
00:CA3E 659B            	   360:   adc  token_digit
00:CA40 8594            	   361:   sta  token_value
00:CA42 A900            	   362:   lda #0
00:CA44 6595            	   363:   adc  token_value+1   ; increment next byte if necessary
00:CA46 8595            	   364:   sta  token_value+1
00:CA48 A900            	   365:   lda #0
00:CA4A 6596            	   366:   adc  token_value+2
00:CA4C 8596            	   367:   sta  token_value+2
00:CA4E 3003            	   368:   bmi  atoi_error
00:CA50 4CEDC9          	   369:   jmp  atoi_loop     ; onwards for next digit
                        	   370: 
                        	   371: atoi_error    =  *
00:CA53 A53F            	   372:   lda  RUNNING
00:CA55 1002            	   373:   bpl  atoi_not_running
00:CA57 38              	   374:   sec             ; otherwise set carry and return
00:CA58 60              	   375:   rts
                        	   376: atoi_not_running  =  *
00:CA59 A21E            	   377:   ldx  #30       ; ERROR: Number out of Range
00:CA5B 4C6497          	   378:   jmp  ERROR
                        	   379: 
                        	   380: ;
                        	   381: ;  for negative numbers, subtract token_value from zero
                        	   382: ;
                        	   383: negate_token_value:
00:CA5E 38              	   384:   sec
00:CA5F A900            	   385:   lda  #0
00:CA61 E594            	   386:   sbc  token_value
00:CA63 8594            	   387:   sta  token_value
00:CA65 A900            	   388:   lda  #0
00:CA67 E595            	   389:   sbc  token_value+1
00:CA69 8595            	   390:   sta  token_value+1
00:CA6B A900            	   391:   lda  #0
00:CA6D E596            	   392:   sbc  token_value+2
00:CA6F 8596            	   393:   sta  token_value+2
00:CA71 60              	   394:   rts
                        	   395: 
                        	   396: 
                        	   397: gtoken_table:
                        	   398:   tknjmpItem '(',gc_lh_paren
00:CA72 28              	     1M    dfb   '('
00:CA73 BACA            	     2M    word  gc_lh_paren
                        	   399:   tknjmpItem '{',gc_lh_brace
00:CA75 7B              	     1M    dfb   '{'
00:CA76 B6CA            	     2M    word  gc_lh_brace
                        	   400:   tknjmpItem '"',gc_quote
00:CA78 22              	     1M    dfb   '"'
00:CA79 A9CB            	     2M    word  gc_quote
                        	   401:   tknjmpItem SINGLE_QUOTE,gc_quote
00:CA7B 27              	     1M    dfb   SINGLE_QUOTE
00:CA7C A9CB            	     2M    word  gc_quote
                        	   402:   tknjmpItem '$',gc_dollar
00:CA7E 24              	     1M    dfb   '$'
00:CA7F 77CC            	     2M    word  gc_dollar
                        	   403:   tknjmpItem '%',gc_percent
00:CA81 25              	     1M    dfb   '%'
00:CA82 D1CC            	     2M    word  gc_percent
                        	   404:   tknjmpItem ':',gc_colon
00:CA84 3A              	     1M    dfb   ':'
00:CA85 FBCC            	     2M    word  gc_colon
                        	   405:   tknjmpItem '<',gc_less_than
00:CA87 3C              	     1M    dfb   '<'
00:CA88 0CCD            	     2M    word  gc_less_than
                        	   406:   tknjmpItem '>',gc_greater_than
00:CA8A 3E              	     1M    dfb   '>'
00:CA8B 2FCD            	     2M    word  gc_greater_than
                        	   407:   tknjmpItem '-',gc_minus
00:CA8D 2D              	     1M    dfb   '-'
00:CA8E 49CD            	     2M    word  gc_minus
                        	   408:   tknjmpItem '+',gc_plus
00:CA90 2B              	     1M    dfb   '+'
00:CA91 4BCD            	     2M    word  gc_plus
                        	   409:   tknjmpItem '&',gc_ampersand
00:CA93 26              	     1M    dfb   '&'
00:CA94 6ACD            	     2M    word  gc_ampersand
                        	   410:   tknjmpItem '|',gc_bar
00:CA96 7C              	     1M    dfb   '|'
00:CA97 7BCD            	     2M    word  gc_bar
                        	   411:   tknjmpItem '=',gc_equals
00:CA99 3D              	     1M    dfb   '='
00:CA9A 8CCD            	     2M    word  gc_equals
                        	   412:   tknjmpItem '!',gc_bang
00:CA9C 21              	     1M    dfb   '!'
00:CA9D 9DCD            	     2M    word  gc_bang
                        	   413:   tknjmpItem ';',gc_semicolon
00:CA9F 3B              	     1M    dfb   ';'
00:CAA0 70CB            	     2M    word  gc_semicolon
00:CAA2 00              	   414:   dfb        0   ; end of table
                        	   415: 
                        	   416: gtoken_directive_table:
                        	   417:   tknjmpItem 'S',gc_directive_symbols
00:CAA3 53              	     1M    dfb   'S'
00:CAA4 22CB            	     2M    word  gc_directive_symbols
                        	   418:   tknjmpItem 'L',gc_directive_list
00:CAA6 4C              	     1M    dfb   'L'
00:CAA7 5ACB            	     2M    word  gc_directive_list
                        	   419:   tknjmpItem 'P',gc_directive_pcodes
00:CAA9 50              	     1M    dfb   'P'
00:CAAA 61CB            	     2M    word  gc_directive_pcodes
                        	   420:   tknjmpItem 'N',gc_directive_nolist
00:CAAC 4E              	     1M    dfb   'N'
00:CAAD 67CB            	     2M    word  gc_directive_nolist
00:CAAF 00              	   421:   dfb        0
                        	   422: 
                        	   423: ; single byte token, in A
00:CAB0 4C39C9          	   424: gc_single_byte_tokenJ jmp gc_single_byte_token
                        	   425: ; single byte token in token_type
00:CAB3 4C37C9          	   426: gc_single_byte_already_knownJ jmp gc_single_byte_already_known
                        	   427: 
                        	   428: gc_lh_brace:
00:CAB6 A000            	   429:   ldy #0
00:CAB8 800E            	   430:   bra gc_pascal_comment
                        	   431: gc_lh_paren:
00:CABA A902            	   432:   lda #FLAG_ASSEMBLING
00:CABC 25BE            	   433:   and system_flags
00:CABE D0F3            	   434:   bne gc_single_byte_already_knownJ
00:CAC0 A001            	   435:   ldy #1
00:CAC2 B18E            	   436:   lda (token_start),Y
00:CAC4 C92A            	   437:   cmp #'*'      ; was it: (* ?
00:CAC6 D0EB            	   438:   bne gc_single_byte_already_knownJ  ; nope
                        	   439: 
                        	   440: ;
                        	   441: ;  Y will be 0 or 1 depending on the sort of starting comment
                        	   442: ;  first look for % which indicates a compiler directive
                        	   443: ;
                        	   444: gc_pascal_comment:
00:CAC8 C8              	   445:   iny
00:CAC9 B18E            	   446:   lda (token_start),Y
00:CACB C925            	   447:   cmp #'%'   ; directive?
00:CACD D018            	   448:   bne gc_pascal_comment_find_end
00:CACF C8              	   449:   iny
00:CAD0 B18E            	   450:   lda (token_start),Y ; get the directive: S, L, P or N
00:CAD2 48              	   451:   pha   ; save the directive for now
00:CAD3 98              	   452:   tya
                        	   453: ;
                        	   454: ;  make token_start point to where we are up to, so we can skip the comment, even if it is long
                        	   455: ;
00:CAD4 38              	   456:   sec               ; I actually want to be one past where the directive letter is
00:CAD5 658E            	   457:   adc token_start
00:CAD7 858E            	   458:   sta token_start
00:CAD9 A900            	   459:   lda #0
00:CADB 658F            	   460:   adc token_start+1
00:CADD 858F            	   461:   sta token_start+1
00:CADF 68              	   462:   pla   ; get the directive back
00:CAE0 A2A3            	   463:   ldx #<gtoken_directive_table
00:CAE2 A0CA            	   464:   ldy #>gtoken_directive_table
00:CAE4 20928F          	   465:   jsr TKNJMP  ; do the directive handler
                        	   466: ;
                        	   467: ;  fall through if not found and just find the end of the comment
                        	   468: ;
                        	   469: 
                        	   470: gc_pascal_comment_find_end:
00:CAE7 A000            	   471:   ldy #0    ; we normalised token_start to be where we want to start
00:CAE9 B18E            	   472:   lda (token_start),Y
00:CAEB D005            	   473:   bne gc_comment_not_eof
00:CAED A207            	   474:   ldx  #7           ; NO } FOUND
00:CAEF 4C6497          	   475:   jmp  ERROR
                        	   476: gc_comment_not_eof:
00:CAF2 C90A            	   477:   cmp #NL
00:CAF4 D005            	   478:   bne gc_comment_not_newline
00:CAF6 2095C9          	   479:   jsr token_line    ; handle the newline (we can't be assembling or we wouldn't be here)
00:CAF9 800F            	   480:   bra gc_comment_keep_looking
                        	   481: gc_comment_not_newline:
00:CAFB C97D            	   482:   cmp #'}'
00:CAFD F013            	   483:   beq gc_comment_found_end
00:CAFF C92A            	   484:   cmp #'*'
00:CB01 D007            	   485:   bne gc_comment_keep_looking
00:CB03 C8              	   486:   iny
00:CB04 B18E            	   487:   lda (token_start),Y
00:CB06 C929            	   488:   cmp #')'
00:CB08 F008            	   489:   beq gc_comment_found_end
                        	   490: 
                        	   491: ;
                        	   492: ;  skip this byte and keep looking for the end of comment
                        	   493: ;
                        	   494: gc_comment_keep_looking:
00:CB0A E68E            	   495:   inc token_start
00:CB0C D0D9            	   496:   bne gc_pascal_comment_find_end
00:CB0E E68F            	   497:   inc token_start+1
00:CB10 80D5            	   498:   bra gc_pascal_comment_find_end
                        	   499: 
                        	   500: ;
                        	   501: ;  found end of comment, so move token_start to this character
                        	   502: ;   (the one past the end of the comment) and try again for a token
                        	   503: ;
                        	   504: gc_comment_found_end:
00:CB12 C8              	   505:   iny   ; get past end of comment
00:CB13 98              	   506:   tya
00:CB14 18              	   507:   clc
00:CB15 658E            	   508:   adc token_start
00:CB17 858E            	   509:   sta token_start
00:CB19 A900            	   510:   lda #0
00:CB1B 658F            	   511:   adc token_start+1
00:CB1D 858F            	   512:   sta token_start+1
00:CB1F 4CF9C8          	   513:   jmp get_token_loop
                        	   514: 
                        	   515: ;
                        	   516: ;  {%S $nnnn}
                        	   517: ;  symbol table relocation
                        	   518: ;
                        	   519: gc_directive_symbols:
00:CB22 20F9C8          	   520:    jsr  get_token_loop     ; re-call get_token to find the address
00:CB25 C94E            	   521:    cmp  #TOKEN_NUMBER ; number?
00:CB27 F005            	   522:    beq  gc_directive_symbols_ok      ; yes
00:CB29 A202            	   523:    ldx  #2
00:CB2B 4C6497          	   524:    jmp  ERROR      ; 'Constant expected'
                        	   525: 
                        	   526: gc_directive_symbols_ok:
                        	   527:   ;
                        	   528:   ;  check we haven't generated any code
                        	   529:   ;
00:CB2E A523            	   530:   lda PCODE
00:CB30 C525            	   531:   cmp ACT_PCDA
00:CB32 D021            	   532:   bne gc_directive_symbols_too_late
00:CB34 A524            	   533:   lda PCODE+1
00:CB36 C526            	   534:   cmp ACT_PCDA+1
00:CB38 D01B            	   535:   bne gc_directive_symbols_too_late
                        	   536: 
00:CB3A A594            	   537:   lda  token_value
00:CB3C 8531            	   538:   sta  ENDSYM
00:CB3E 852F            	   539:   sta  STARTSYM
00:CB40 852B            	   540:   sta  OPND
00:CB42 A595            	   541:   lda  token_value+1
00:CB44 8532            	   542:   sta  ENDSYM+1        ; store symbol table address
00:CB46 8530            	   543:   sta  STARTSYM+1
00:CB48 852C            	   544:   sta  OPND+1
00:CB4A A901            	   545:   lda  #PCODE_STACK    ; change runtime stack
00:CB4C 2054C7          	   546:   jsr  GENJMP
                        	   547: ;
                        	   548: ;  put the library functions back
                        	   549: ;
00:CB4F 2021C6          	   550:   jsr  add_pascal_library_functions
                        	   551: 
00:CB52 4CE7CA          	   552:   jmp  gc_pascal_comment_find_end     ; go back and find the end of the comment
                        	   553: ;
                        	   554: 
                        	   555: gc_directive_symbols_too_late:
00:CB55 A233            	   556:   ldx #51        ; code already generated
00:CB57 4C6497          	   557:   JMP  ERROR
                        	   558: 
                        	   559: 
                        	   560: ;
                        	   561: ;  {%L} - list source
                        	   562: ;
                        	   563: gc_directive_list:
00:CB5A A904            	   564:   lda #FLAG_LIST_SOURCE
00:CB5C 04BE            	   565:   tsb system_flags
00:CB5E 4CE7CA          	   566:   jmp gc_pascal_comment_find_end
                        	   567: 
                        	   568: ;
                        	   569: ;  {%P} - list source and P-codes
                        	   570: ;
                        	   571: gc_directive_pcodes:
00:CB61 A901            	   572:   lda #1
00:CB63 852E            	   573:   sta DCODE
00:CB65 80F3            	   574:   bra gc_directive_list   ; also list source
                        	   575: ;
                        	   576: ;  {%N} - do not list source or P-codes
                        	   577: ;
                        	   578: gc_directive_nolist:
00:CB67 A904            	   579:   lda #FLAG_LIST_SOURCE
00:CB69 14BE            	   580:   trb system_flags    ; clear both of the above flags
00:CB6B 642E            	   581:   stz DCODE
00:CB6D 4CE7CA          	   582:   jmp gc_pascal_comment_find_end
                        	   583: 
                        	   584: ;
                        	   585: ;  semicolons start comments in the assembler
                        	   586: ;
                        	   587: gc_semicolon:
00:CB70 A902            	   588:   lda #FLAG_ASSEMBLING
00:CB72 25BE            	   589:   and system_flags
00:CB74 D003            	   590:   bne gc_assembler_comment_find_end
00:CB76 4C37C9          	   591:   jmp gc_single_byte_already_known
                        	   592: 
                        	   593: gc_assembler_comment_find_end:
00:CB79 A000            	   594:   ldy #0
00:CB7B B18E            	   595:   lda (token_start),Y
00:CB7D D005            	   596:   bne gc_assembler_comment_not_eof
00:CB7F A90A            	   597:   lda #NL
00:CB81 8593            	   598:   sta token_type
00:CB83 60              	   599:   rts     ; exit without incrementing token_start
                        	   600: 
                        	   601: gc_assembler_comment_not_eof:
00:CB84 C90A            	   602:   cmp #NL
00:CB86 D003            	   603:   bne gc_assembler_comment_keep_looking
00:CB88 4C39C9          	   604:   jmp gc_single_byte_token
                        	   605: ;
                        	   606: ;  skip this byte and keep looking for the newline at the end of comment
                        	   607: ;
                        	   608: gc_assembler_comment_keep_looking:
00:CB8B E68E            	   609:   inc token_start
00:CB8D D0EA            	   610:   bne gc_assembler_comment_find_end
00:CB8F E68F            	   611:   inc token_start+1
00:CB91 80E6            	   612:   bra gc_assembler_comment_find_end
                        	   613: 
                        	   614: 
                        	   615: gc_backslash_tokens:
00:CB93 41              	   616:          DFB  'A',$07  ; bell ($07)
00:CB94 07
00:CB95 42              	   617:          DFB  'B',$08  ; backspace ($08)
00:CB96 08
00:CB97 45              	   618:          DFB  'E',$1B  ; escape  (0x1B)
00:CB98 1B
00:CB99 46              	   619:          DFB  'F',$0C  ; formfeed ($0C)
00:CB9A 0C
00:CB9B 4E              	   620:          DFB  'N',$0A  ; newline  (0x0A)
00:CB9C 0A
00:CB9D 52              	   621:          DFB  'R',$0D  ; carriage return (0x0D)
00:CB9E 0D
00:CB9F 54              	   622:          DFB  'T',$09  ; horizontal tab (0x09)
00:CBA0 09
00:CBA1 56              	   623:          DFB  'V',$0B  ; vertical tab (0x0B)
00:CBA2 0B
00:CBA3 5C              	   624:          DFB  $5C,$5C  ; backslash
00:CBA4 5C
00:CBA5 22              	   625:          DFB  '"','"'  ; double quote
00:CBA6 22
00:CBA7 27              	   626:          DFB  SINGLE_QUOTE,SINGLE_QUOTE  ; single quote
00:CBA8 27
                        	   627: gc_backslash_tokens_end = *
                        	   628: gc_backslash_tokens_length = gc_backslash_tokens_end - gc_backslash_tokens
                        	   629: 
                        	   630: ;
                        	   631: ;  quoted string
                        	   632: ;
                        	   633: ;  resolve double quotes and backslash sequences and store it in INBUF
                        	   634: ;
                        	   635: ;
                        	   636: gc_quote:
00:CBA9 8598            	   637:   sta token_work    ; remember which sort
00:CBAB A000            	   638:   ldy #0            ; back to the start
00:CBAD 6492            	   639:   stz token_length  ; zero-length string so far
00:CBAF A58E            	   640:   lda token_start
00:CBB1 8590            	   641:   sta token_address   ; save the starting address of the token (not that it matters too much)
00:CBB3 A58F            	   642:   lda token_start+1   ; repeat for high-order byte
00:CBB5 8591            	   643:   sta token_address+1
                        	   644: 
                        	   645: gc_quote_loop:
00:CBB7 C8              	   646:   iny                 ; onto next character
00:CBB8 B18E            	   647:   lda (token_start),Y ; get the next character in the string
00:CBBA F004            	   648:   beq gc_quote_bad
00:CBBC C90A            	   649:   cmp  #NL
00:CBBE D005            	   650:   bne  gc_quote_loop_not_end_of_line
                        	   651: 
                        	   652: gc_quote_bad:
00:CBC0 A208            	   653:   ldx  #8         ; MISSING QUOTE: Incorrect string
00:CBC2 4C6497          	   654:   jmp  ERROR
                        	   655: 
                        	   656: gc_quote_loop_not_end_of_line:
00:CBC5 C598            	   657:   cmp  token_work  ; same as start quote?
00:CBC7 D037            	   658:   bne  gc_quote_not_finished       ; no
00:CBC9 C8              	   659:   iny
00:CBCA B18E            	   660:   lda (token_start),Y ; see if another quote follows
00:CBCC C598            	   661:   cmp  token_work
00:CBCE F05A            	   662:   beq  gc_quote_not_backslash      ; embedded quote (ie. two quotes in a row)? Store a single quote symbol
                        	   663:   ;
                        	   664:   ;  here at end of quoted string
                        	   665:   ;
00:CBD0 8498            	   666:   sty  token_work  ; remember how far through our input we are
00:CBD2 A003            	   667:   ldy  #3          ; OK, we have the final quote, so is the string <= 3 characters long?
00:CBD4 C492            	   668:   cpy  token_length
00:CBD6 9002            	   669:   bcc  gc_quote_long_string   ; BLT - no
00:CBD8 A492            	   670:   ldy  token_length           ; yes - load its actual length into Y (ie. 0, 1, 2, 3)
                        	   671: gc_quote_long_string:
00:CBDA 88              	   672:   dey      ; zero-relative
00:CBDB 3008            	   673:   bmi  gc_quote_copied_value   ; keep going into the length done
00:CBDD B90002          	   674:   lda  INBUF,Y   ; store the (up to) 3 bytes into VALUE as the token value
00:CBE0 999400          	   675:   sta  token_value,Y
00:CBE3 D0F5            	   676:   bne  gc_quote_long_string   ; keep going until we hit the 0x00 at the end
                        	   677: 
                        	   678: gc_quote_copied_value:
00:CBE5 A592            	   679:   lda  token_length    ; now see how long it is?
00:CBE7 D005            	   680:   bne  gc_quote_done     ; don't allow zero length strings
00:CBE9 A20E            	   681:   ldx  #14        ; BAD STRING: literal string of zero length
00:CBEB 4C6497          	   682:   jmp  ERROR
                        	   683: 
                        	   684: gc_quote_done:
00:CBEE 18              	   685:   clc
00:CBEF A58E            	   686:   lda token_start       ; bump up our token_start address to past the quoted string
00:CBF1 6598            	   687:   adc token_work        ; now add its (actual) length, not the length afer mucking around
00:CBF3 858E            	   688:   sta token_start       ; that gives the ending address
00:CBF5 A58F            	   689:   lda token_start+1   ; repeat for high-order byte
00:CBF7 6900            	   690:   adc #0
00:CBF9 858F            	   691:   sta token_start+1
00:CBFB A922            	   692:   lda  #TOKEN_STRING   ; it's a string token
00:CBFD 8593            	   693:   sta  token_type
00:CBFF 60              	   694:   rts
                        	   695: 
                        	   696: 
                        	   697: gc_quote_not_finished:
00:CC00 C95C            	   698:   cmp #$5C    ; backslash?
00:CC02 D026            	   699:   bne  gc_quote_not_backslash
                        	   700: ;
                        	   701: ;  backslash - see what follows
                        	   702: ;
00:CC04 C8              	   703:   iny
00:CC05 B18E            	   704:   lda (token_start),Y ; the character after the backslash
00:CC07 F0B7            	   705:   beq gc_quote_bad    ; nothing? bad
00:CC09 20C48F          	   706:   jsr MAKE_UPPER
00:CC0C C958            	   707:   cmp #'X'
00:CC0E F038            	   708:   beq gc_quote_hex_character
00:CC10 A200            	   709:   ldx #0
                        	   710: gc_quote_backslash_loop:
00:CC12 DD93CB          	   711:   cmp gc_backslash_tokens,X
00:CC15 F00F            	   712:   beq gc_quote_found_backslash_character   ; good match
00:CC17 E8              	   713:   inx
00:CC18 E8              	   714:   inx
00:CC19 E016            	   715:   cpx #gc_backslash_tokens_length
00:CC1B 90F5            	   716:   bcc gc_quote_backslash_loop
                        	   717: gc_quote_bad_string:
00:CC1D A208            	   718:   ldx #8
00:CC1F 4C6497          	   719:   jmp ERROR   ; ERROR: Incorrect string
                        	   720: 
                        	   721: gc_quote_hex_character_done:
00:CC22 A594            	   722:   lda token_value
00:CC24 8004            	   723:   bra gc_quote_not_backslash
                        	   724: 
                        	   725: gc_quote_found_backslash_character:
00:CC26 E8              	   726:   inx
00:CC27 BD93CB          	   727:   lda gc_backslash_tokens,X  ; get its replacement
                        	   728: 
                        	   729: gc_quote_not_backslash:
00:CC2A A692            	   730:   ldx  token_length
00:CC2C 9D0002          	   731:   sta  INBUF,x           ; store it in INBUF
00:CC2F E692            	   732:   inc  token_length
00:CC31 F003            	   733:   beq  gc_quote_too_long
00:CC33 4CB7CB          	   734:   jmp  gc_quote_loop     ; keep adding to string
                        	   735: 
                        	   736: 
                        	   737: gc_quote_too_long:
                        	   738:   ;            string over 255 characters long - error!
00:CC36 A21D            	   739:   ldx   #29  ; ERROR: string literal too big
00:CC38 4C6497          	   740:   jmp  ERROR
                        	   741: 
                        	   742: ;
                        	   743: ;  "fix" a hex digit by making it upper-case, then subtracting 7 if it is A-F
                        	   744: ;   then subtracting '0' so we get a number in the range 0x00 to 0x0F in A
                        	   745: ;
                        	   746: gc_fix_hex:
00:CC3B 20C48F          	   747:   jsr  MAKE_UPPER
00:CC3E C941            	   748:   cmp  #'A'
00:CC40 9002            	   749:   bcc  gc_fix_hex_not_a_to_f
00:CC42 E907            	   750:   sbc  #7
                        	   751: gc_fix_hex_not_a_to_f:
00:CC44 38              	   752:   sec
00:CC45 E930            	   753:   sbc  #'0'
00:CC47 60              	   754:   rts
                        	   755: 
                        	   756: gc_quote_hex_character:
00:CC48 C8              	   757:   iny
00:CC49 F0EB            	   758:   beq  gc_quote_too_long
00:CC4B B18E            	   759:   lda  (token_start),Y ; the character after the backslash
00:CC4D 203E81          	   760:   jsr  isxdigit
00:CC50 90CB            	   761:   bcc  gc_quote_bad_string  ; what? should be hex
00:CC52 203BCC          	   762:   jsr  gc_fix_hex
00:CC55 8594            	   763:   sta  token_value  ; first nibble
00:CC57 C8              	   764:   iny
00:CC58 F0DC            	   765:   beq  gc_quote_too_long
00:CC5A B18E            	   766:   lda  (token_start),Y ; a second hex character?
00:CC5C F0BF            	   767:   beq  gc_quote_bad_string
00:CC5E 203E81          	   768:   jsr  isxdigit
00:CC61 9011            	   769:   bcc  gc_quote_hex_character_one_only
00:CC63 203BCC          	   770:   jsr  gc_fix_hex
00:CC66 0694            	   771:   asl  token_value    ; shift existing value 4 bits left
00:CC68 0694            	   772:   asl  token_value
00:CC6A 0694            	   773:   asl  token_value
00:CC6C 0694            	   774:   asl  token_value
00:CC6E 0594            	   775:   ora  token_value
00:CC70 8594            	   776:   sta  token_value
00:CC72 80AE            	   777:   bra  gc_quote_hex_character_done
                        	   778: 
                        	   779: gc_quote_hex_character_one_only:
00:CC74 88              	   780:   dey         ; undo add since we didn't find another hex character
00:CC75 80AB            	   781:   bra gc_quote_hex_character_done
                        	   782: 
                        	   783: ;
                        	   784: ;  $nnnnnn where nnnnnn is one or more hex digits
                        	   785: ;    if no hex digits, then it is the token '$'
                        	   786: ;
                        	   787: gc_dollar:
00:CC77 A001            	   788:   ldy  #1    ; start with the character after the dollar
00:CC79 B18E            	   789:   lda  (token_start),Y ; followed by a hex character?
00:CC7B 203E81          	   790:   jsr  isxdigit
00:CC7E B003            	   791:   bcs  gc_hex_literal
00:CC80 4C37C9          	   792:   jmp  gc_single_byte_already_known
                        	   793: 
                        	   794: gc_hex_literal:
00:CC83 203BCC          	   795:   jsr gc_fix_hex
00:CC86 8594            	   796:   sta token_value       ; store the first digit
00:CC88 6495            	   797:   stz token_value+1
00:CC8A 6496            	   798:   stz token_value+2
                        	   799: gc_hex_loop:
00:CC8C C8              	   800:   iny
00:CC8D B18E            	   801:   lda (token_start),Y ; followed by another hex character?
00:CC8F 203E81          	   802:   jsr isxdigit
00:CC92 9033            	   803:   bcc gc_hex_done
00:CC94 203BCC          	   804:   jsr gc_fix_hex
                        	   805: ;
                        	   806: ;  shift the existing value left 4 bits to make room for the new nibble
                        	   807: ;
00:CC97 0694            	   808:   asl  token_value        ; token_value shifted left 1 bit
00:CC99 2695            	   809:   rol  token_value+1
00:CC9B 2696            	   810:   rol  token_value+2
00:CC9D B02D            	   811:   bcs  gc_hex_too_big
00:CC9F 0694            	   812:   asl  token_value        ; token_value shifted left 2 bits
00:CCA1 2695            	   813:   rol  token_value+1
00:CCA3 2696            	   814:   rol  token_value+2
00:CCA5 B025            	   815:   bcs  gc_hex_too_big
00:CCA7 0694            	   816:   asl  token_value        ; token_value shifted left 3 bits
00:CCA9 2695            	   817:   rol  token_value+1
00:CCAB 2696            	   818:   rol  token_value+2
00:CCAD B01D            	   819:   bcs  gc_hex_too_big
00:CCAF 0694            	   820:   asl  token_value        ; token_value shifted left 4 bits
00:CCB1 2695            	   821:   rol  token_value+1
00:CCB3 2696            	   822:   rol  token_value+2
00:CCB5 B015            	   823:   bcs  gc_hex_too_big
00:CCB7 6594            	   824:   adc  token_value        ; now add in this last digit (carry will be clear)
00:CCB9 8594            	   825:   sta  token_value        ; store the new result
00:CCBB 90CF            	   826:   bcc  gc_hex_loop
00:CCBD E695            	   827:   inc  token_value+1
00:CCBF 90CB            	   828:   bcc  gc_hex_loop
00:CCC1 E695            	   829:   inc  token_value+1
00:CCC3 B007            	   830:   bcs  gc_hex_too_big
00:CCC5 80C5            	   831:   bra  gc_hex_loop
                        	   832: 
                        	   833: gc_hex_done:
00:CCC7 A94E            	   834:   lda #TOKEN_NUMBER
00:CCC9 4C3BC9          	   835:   jmp gc_done
                        	   836: 
                        	   837: gc_hex_too_big:
00:CCCC A21E            	   838:   ldx  #30       ; ERROR: Number out of Range
00:CCCE 4C6497          	   839:   jmp  ERROR
                        	   840: 
                        	   841: ;
                        	   842: ;  %nnnnnn where nnnnnn is one or more binary digits
                        	   843: ;    if no binary digits, then it is the token '%'
                        	   844: ;
                        	   845: 
                        	   846: gc_percent:
00:CCD1 A001            	   847:   ldy  #1    ; start with the character after the %
00:CCD3 B18E            	   848:   lda  (token_start),Y ; followed by a binary character?
00:CCD5 206E81          	   849:   jsr  isbinary
00:CCD8 B003            	   850:   bcs  gc_binary_literal
00:CCDA 4C37C9          	   851:   jmp  gc_single_byte_already_known
                        	   852: 
                        	   853: gc_binary_literal:
00:CCDD E930            	   854:   sbc #'0'              ; we know carry is set
00:CCDF 8594            	   855:   sta token_value       ; store the first digit
00:CCE1 6495            	   856:   stz token_value+1
00:CCE3 6496            	   857:   stz token_value+2
                        	   858: gc_binary_loop:
00:CCE5 C8              	   859:   iny
00:CCE6 B18E            	   860:   lda (token_start),Y ; followed by another binary character?
00:CCE8 206E81          	   861:   jsr isbinary
00:CCEB 90DA            	   862:   bcc gc_hex_done
00:CCED E930            	   863:   sbc #'0'              ; we know carry is set
                        	   864: 
00:CCEF 6A              	   865:   ror A   ; get the new bit into Carry
00:CCF0 2694            	   866:   rol token_value
00:CCF2 2695            	   867:   rol token_value+1
00:CCF4 2696            	   868:   rol token_value+2
00:CCF6 90ED            	   869:   bcc gc_binary_loop
00:CCF8 4CCCCC          	   870:   jmp gc_hex_too_big   ; number too large
                        	   871: 
                        	   872: ;
                        	   873: ;  token : might be :=
                        	   874: ;
                        	   875: gc_colon:
00:CCFB A001            	   876:   ldy  #1               ; get the next character
00:CCFD B18E            	   877:   lda  (token_start),Y  ; followed by = ?
00:CCFF C93D            	   878:   cmp  #'='
00:CD01 F003            	   879:   beq  gc_assign
00:CD03 4C37C9          	   880:   jmp  gc_single_byte_already_known
                        	   881: 
                        	   882: gc_assign:
00:CD06 A941            	   883:   lda #TOKEN_ASSIGN
00:CD08 C8              	   884:   iny
00:CD09 4C3BC9          	   885:   jmp gc_done
                        	   886: 
                        	   887: ;
                        	   888: ;  token: < might be <=, <>, <<
                        	   889: ;
                        	   890: gc_less_than:
00:CD0C A001            	   891:   ldy  #1               ; get the next character
00:CD0E B18E            	   892:   lda  (token_start),Y  ; followed by = ?
00:CD10 C8              	   893:   iny                   ; make it a 2-byte token
00:CD11 C93D            	   894:   cmp  #'='
00:CD13 F00B            	   895:   beq  gc_leq
00:CD15 C93E            	   896:   cmp  #'>'
00:CD17 F00C            	   897:   beq  gc_neq
00:CD19 C93C            	   898:   cmp  #'<'
00:CD1B F00D            	   899:   beq  gc_shift_left
00:CD1D 4C37C9          	   900:   jmp  gc_single_byte_already_known
                        	   901: 
                        	   902: gc_leq:
00:CD20 A980            	   903:   lda #TOKEN_LEQ
00:CD22 4C3BC9          	   904:   jmp gc_done
                        	   905: 
                        	   906: gc_neq:
00:CD25 A955            	   907:   lda #TOKEN_NEQ
00:CD27 4C3BC9          	   908:   jmp gc_done
                        	   909: 
                        	   910: gc_shift_left:
00:CD2A A94C            	   911:   lda #TOKEN_SHIFT_LEFT
00:CD2C 4C3BC9          	   912:   jmp gc_done
                        	   913: 
                        	   914: ;
                        	   915: ;  token: > might be <>=, >>
                        	   916: ;
                        	   917: gc_greater_than:
00:CD2F A001            	   918:   ldy  #1               ; get the next character
00:CD31 B18E            	   919:   lda  (token_start),Y  ; followed by = ?
00:CD33 C8              	   920:   iny                   ; make it a 2-byte token
00:CD34 C93D            	   921:   cmp  #'='
00:CD36 F007            	   922:   beq  gc_geq
00:CD38 C93E            	   923:   cmp  #'>'
00:CD3A F008            	   924:   beq  gc_shift_right
                        	   925: 
                        	   926: gc_single_byte_already_knownJ2:
00:CD3C 4C37C9          	   927:   jmp  gc_single_byte_already_known
                        	   928: 
                        	   929: gc_geq:
00:CD3F A981            	   930:   lda #TOKEN_GEQ
00:CD41 4C3BC9          	   931:   jmp gc_done
                        	   932: 
                        	   933: gc_shift_right:
00:CD44 A952            	   934:   lda #TOKEN_SHIFT_RIGHT
00:CD46 4C3BC9          	   935:   jmp gc_done
                        	   936: 
                        	   937: 
                        	   938: ;
                        	   939: ;  minus and plus sign
                        	   940: ;
                        	   941: 
                        	   942: gc_minus:
00:CD49 8597            	   943:   sta token_sign
                        	   944: gc_plus:
                        	   945: 
                        	   946: ;
                        	   947: ;  new stuff - treat a sign as a token on its own if the previous token was one of:
                        	   948: ;    a) a number
                        	   949: ;    b) an identifier
                        	   950: ;    c) a RH bracket
                        	   951: ;
                        	   952: ;  So, for example: 2+3 is three tokens, but 2+-5 is also three, as the -5 becomes one token
                        	   953: ;
00:CD4B A598            	   954:   lda  token_work            ; saved previous token on entry to get_token
00:CD4D C94E            	   955:   cmp  #TOKEN_NUMBER
00:CD4F F0EB            	   956:   beq  gc_single_byte_already_knownJ2
00:CD51 C949            	   957:   cmp  #TOKEN_IDENTIFIER
00:CD53 F0E7            	   958:   beq  gc_single_byte_already_knownJ2
00:CD55 C929            	   959:   cmp  #')'
00:CD57 F0E3            	   960:   beq  gc_single_byte_already_knownJ2
                        	   961: ;
                        	   962: ;  if not, see if this is a signed number (ie. it is directly followed by a digit)
                        	   963: ;
00:CD59 A001            	   964:   ldy  #1               ; get the next character
00:CD5B B18E            	   965:   lda  (token_start),Y  ; followed by a digit?
00:CD5D 203281          	   966:   jsr  isdigit
00:CD60 90DA            	   967:   bcc  gc_single_byte_already_knownJ2
00:CD62 20E4C9          	   968:   jsr atoi
00:CD65 A94E            	   969:   lda  #TOKEN_NUMBER
00:CD67 4C3BC9          	   970:   jmp  gc_done
                        	   971: 
                        	   972: 
                        	   973: ;
                        	   974: ;  token: & might be &&
                        	   975: ;
                        	   976: gc_ampersand:
00:CD6A A001            	   977:   ldy  #1               ; get the next character
00:CD6C B18E            	   978:   lda  (token_start),Y  ; followed by & ?
00:CD6E C926            	   979:   cmp  #'&'
00:CD70 F003            	   980:   beq  gc_logical_and
00:CD72 4C37C9          	   981:   jmp  gc_single_byte_already_known
                        	   982: 
                        	   983: gc_logical_and:
00:CD75 A958            	   984:   lda #TOKEN_LOGICAL_AND
00:CD77 C8              	   985:   iny
00:CD78 4C3BC9          	   986:   jmp gc_done
                        	   987: 
                        	   988: ;
                        	   989: ;  token: | might be ||
                        	   990: ;
                        	   991: gc_bar:
00:CD7B A001            	   992:   ldy  #1               ; get the next character
00:CD7D B18E            	   993:   lda  (token_start),Y  ; followed by | ?
00:CD7F C97C            	   994:   cmp  #'|'
00:CD81 F003            	   995:   beq  gc_logical_or
00:CD83 4C37C9          	   996:   jmp  gc_single_byte_already_known
                        	   997: 
                        	   998: gc_logical_or:
00:CD86 A959            	   999:   lda #TOKEN_LOGICAL_OR
00:CD88 C8              	  1000:   iny
00:CD89 4C3BC9          	  1001:   jmp gc_done
                        	  1002: 
                        	  1003: ;
                        	  1004: ;  token: = might be ==
                        	  1005: ;
                        	  1006: gc_equals:
00:CD8C A001            	  1007:   ldy  #1               ; get the next character
00:CD8E B18E            	  1008:   lda  (token_start),Y  ; followed by = ?
00:CD90 C93D            	  1009:   cmp  #'='
00:CD92 F003            	  1010:   beq  gc_equality
00:CD94 4C37C9          	  1011:   jmp  gc_single_byte_already_known
                        	  1012: 
                        	  1013: gc_equality:
00:CD97 A945            	  1014:   lda #TOKEN_EQUALITY
00:CD99 C8              	  1015:   iny
00:CD9A 4C3BC9          	  1016:   jmp gc_done
                        	  1017: 
                        	  1018: ;
                        	  1019: ;  token: ! might be !=
                        	  1020: ;
                        	  1021: gc_bang:
00:CD9D A001            	  1022:   ldy  #1               ; get the next character
00:CD9F B18E            	  1023:   lda  (token_start),Y  ; followed by = ?
00:CDA1 C93D            	  1024:   cmp  #'='
00:CDA3 F003            	  1025:   beq  gc_inequality
00:CDA5 4C37C9          	  1026:   jmp  gc_single_byte_already_known
                        	  1027: 
                        	  1028: gc_inequality:
00:CDA8 A95A            	  1029:   lda #TOKEN_INEQUALITY
00:CDAA C8              	  1030:   iny
00:CDAB 4C3BC9          	  1031:   jmp gc_done
                        	  1032: 
                        	  1033: 
                        	  1034: 
                        	  1035: ; Pascal tokens
                        	  1036: 
                        	  1037: TOKEN_CONST     = $82
                        	  1038: TOKEN_VAR       = $83
                        	  1039: TOKEN_ARRAY     = $84
                        	  1040: TOKEN_OF        = $85
                        	  1041: TOKEN_PROCEDURE = $86
                        	  1042: TOKEN_FUNCTION  = $87
                        	  1043: TOKEN_BEGIN     = $88
                        	  1044: TOKEN_END       = $89
                        	  1045: TOKEN_OR        = $8A
                        	  1046: TOKEN_DIV       = $8B
                        	  1047: TOKEN_MOD       = $8C
                        	  1048: TOKEN_AND       = $8D
                        	  1049: TOKEN_SHL       = $8E
                        	  1050: TOKEN_SHR       = $8F
                        	  1051: TOKEN_NOT       = $90
                        	  1052: TOKEN_MEM       = $91
                        	  1053: TOKEN_IF        = $92
                        	  1054: TOKEN_THEN      = $93
                        	  1055: TOKEN_ELSE      = $94
                        	  1056: TOKEN_CASE      = $95
                        	  1057: TOKEN_WHILE     = $96
                        	  1058: TOKEN_DO        = $97
                        	  1059: TOKEN_REPEAT    = $98
                        	  1060: TOKEN_UNTIL     = $99
                        	  1061: TOKEN_FOR       = $9A
                        	  1062: TOKEN_TO        = $9B
                        	  1063: TOKEN_DOWNTO    = $9C
                        	  1064: TOKEN_WRITE     = $9D
                        	  1065: TOKEN_READ      = $9E
                        	  1066: TOKEN_CALL      = $9F
                        	  1067: TOKEN_CHAR      = $A1
                        	  1068: TOKEN_MEMC      = $A2
                        	  1069: TOKEN_XOR       = $A4
                        	  1070: TOKEN_ADDRESS   = $A9
                        	  1071: TOKEN_CHR       = $AB
                        	  1072: TOKEN_HEX       = $AC
                        	  1073: ; $B0 to $DE used by message tokens
                        	  1074: TOKEN_LCDWRITE  = $F1
                        	  1075: TOKEN_INTEGER   = $FE
                        	  1076: TOKEN_WRITELN   = $FF
                        	  1077: 
                        	  1078: 
                        	  1079: 
                        	  1080: ; RESERVED WORD TABLE
                        	  1081: ;
                        	  1082: ;***********************************************
                        	  1083:          .macro makeToken  ; MACRO DEFINITION FOR TOKENS: Length, token number, token name
                        	  1084:          DFB  \1
                        	  1085:          DFB  \2
                        	  1086:          text  \3
                        	  1087:          .endmacro           ; END OF MACRO
                        	  1088: 
                        	  1089: ;
                        	  1090: ; Reserved words are identified internally by their code (eg. $86 for PROCEDURE)
                        	  1091: ;
                        	  1092: ;  They are also stored "tokenised" and expanded out when you list the source
                        	  1093: ;
                        	  1094: ; Other tokens are:
                        	  1095: ;  * Punctuation (eg. "<", ">", "=", ".", "(", ")", "$", "+", "-"
                        	  1096: ;  * Identifiers: "I"        (eg. MY_VARIABLE)
                        	  1097: ;  * Constant numbers: "N"   (eg. -1234 and $1234)
                        	  1098: ;  * Literal strings:  '"' (quote symbol)  (eg. "Nick")
                        	  1099: ;  * Double-character punctuation:
                        	  1100: ;       <= : $80
                        	  1101: ;       >= : $81
                        	  1102: ;       Unequal (<>) : "U"
                        	  1103: ;       Assignment (:=) : "A"
                        	  1104: ;
                        	  1105: ; Comments are skipped: (* some comment *)
                        	  1106: ;
                        	  1107: ;
                        	  1108: ; However comments can have compiler directives embedded, eg. (*%A $4000) - put P-codes at $4000
                        	  1109: ;    (*%L*) - list during compile
                        	  1110: ;    (*%N*) - stop listing during compile (cancels %L and %P)
                        	  1111: ;    (*%P*) - show P-codes during compile
                        	  1112: ;    (*%A  $nnnn *) - put P-codes at address $nnnn - must be at START of program
                        	  1113: ;
                        	  1114: ;
                        	  1115: 
                        	  1116: ;              Length   Code             Name
                        	  1117: ;                  --   --------------- ---------------
                        	  1118: RSVWRD   =  *
                        	  1119:    makeToken   5, TOKEN_CONST     ,"CONST"
00:CDAE 05              	     1M          DFB  5
00:CDAF 82              	     2M          DFB  TOKEN_CONST     
00:CDB0 434F4E5354      	     3M          text  "CONST"
                        	  1120:    makeToken   3, TOKEN_VAR       ,"VAR"
00:CDB5 03              	     1M          DFB  3
00:CDB6 83              	     2M          DFB  TOKEN_VAR       
00:CDB7 564152          	     3M          text  "VAR"
                        	  1121:    makeToken   5, TOKEN_ARRAY     ,"ARRAY"
00:CDBA 05              	     1M          DFB  5
00:CDBB 84              	     2M          DFB  TOKEN_ARRAY     
00:CDBC 4152524159      	     3M          text  "ARRAY"
                        	  1122:    makeToken   2, TOKEN_OF        ,"OF"
00:CDC1 02              	     1M          DFB  2
00:CDC2 85              	     2M          DFB  TOKEN_OF        
00:CDC3 4F46            	     3M          text  "OF"
                        	  1123:    makeToken   9, TOKEN_PROCEDURE ,"PROCEDURE"
00:CDC5 09              	     1M          DFB  9
00:CDC6 86              	     2M          DFB  TOKEN_PROCEDURE 
00:CDC7 50524F4345445552	     3M          text  "PROCEDURE"
00:CDCF 45
                        	  1124:    makeToken   8, TOKEN_FUNCTION  ,"FUNCTION"
00:CDD0 08              	     1M          DFB  8
00:CDD1 87              	     2M          DFB  TOKEN_FUNCTION  
00:CDD2 46554E4354494F4E	     3M          text  "FUNCTION"
                        	  1125:    makeToken   5, TOKEN_BEGIN     ,"BEGIN"
00:CDDA 05              	     1M          DFB  5
00:CDDB 88              	     2M          DFB  TOKEN_BEGIN     
00:CDDC 424547494E      	     3M          text  "BEGIN"
                        	  1126:    makeToken   3, TOKEN_END       ,"END"
00:CDE1 03              	     1M          DFB  3
00:CDE2 89              	     2M          DFB  TOKEN_END       
00:CDE3 454E44          	     3M          text  "END"
                        	  1127:    makeToken   2, TOKEN_OR        ,"OR"
00:CDE6 02              	     1M          DFB  2
00:CDE7 8A              	     2M          DFB  TOKEN_OR        
00:CDE8 4F52            	     3M          text  "OR"
                        	  1128:    makeToken   3, TOKEN_DIV       ,"DIV"
00:CDEA 03              	     1M          DFB  3
00:CDEB 8B              	     2M          DFB  TOKEN_DIV       
00:CDEC 444956          	     3M          text  "DIV"
                        	  1129:    makeToken   3, TOKEN_MOD       ,"MOD"
00:CDEF 03              	     1M          DFB  3
00:CDF0 8C              	     2M          DFB  TOKEN_MOD       
00:CDF1 4D4F44          	     3M          text  "MOD"
                        	  1130:    makeToken   3, TOKEN_AND       ,"AND"
00:CDF4 03              	     1M          DFB  3
00:CDF5 8D              	     2M          DFB  TOKEN_AND       
00:CDF6 414E44          	     3M          text  "AND"
                        	  1131:    makeToken   3, TOKEN_SHL       ,"SHL"
00:CDF9 03              	     1M          DFB  3
00:CDFA 8E              	     2M          DFB  TOKEN_SHL       
00:CDFB 53484C          	     3M          text  "SHL"
                        	  1132:    makeToken   3, TOKEN_SHR       ,"SHR"
00:CDFE 03              	     1M          DFB  3
00:CDFF 8F              	     2M          DFB  TOKEN_SHR       
00:CE00 534852          	     3M          text  "SHR"
                        	  1133:    makeToken   3, TOKEN_NOT       ,"NOT"
00:CE03 03              	     1M          DFB  3
00:CE04 90              	     2M          DFB  TOKEN_NOT       
00:CE05 4E4F54          	     3M          text  "NOT"
                        	  1134:    makeToken   3, TOKEN_MEM       ,"MEM"
00:CE08 03              	     1M          DFB  3
00:CE09 91              	     2M          DFB  TOKEN_MEM       
00:CE0A 4D454D          	     3M          text  "MEM"
                        	  1135:    makeToken   2, TOKEN_IF        ,"IF"
00:CE0D 02              	     1M          DFB  2
00:CE0E 92              	     2M          DFB  TOKEN_IF        
00:CE0F 4946            	     3M          text  "IF"
                        	  1136:    makeToken   4, TOKEN_THEN      ,"THEN"
00:CE11 04              	     1M          DFB  4
00:CE12 93              	     2M          DFB  TOKEN_THEN      
00:CE13 5448454E        	     3M          text  "THEN"
                        	  1137:    makeToken   4, TOKEN_ELSE      ,"ELSE"
00:CE17 04              	     1M          DFB  4
00:CE18 94              	     2M          DFB  TOKEN_ELSE      
00:CE19 454C5345        	     3M          text  "ELSE"
                        	  1138:    makeToken   4, TOKEN_CASE      ,"CASE"
00:CE1D 04              	     1M          DFB  4
00:CE1E 95              	     2M          DFB  TOKEN_CASE      
00:CE1F 43415345        	     3M          text  "CASE"
                        	  1139:    makeToken   5, TOKEN_WHILE     ,"WHILE"
00:CE23 05              	     1M          DFB  5
00:CE24 96              	     2M          DFB  TOKEN_WHILE     
00:CE25 5748494C45      	     3M          text  "WHILE"
                        	  1140:    makeToken   2, TOKEN_DO        ,"DO"
00:CE2A 02              	     1M          DFB  2
00:CE2B 97              	     2M          DFB  TOKEN_DO        
00:CE2C 444F            	     3M          text  "DO"
                        	  1141:    makeToken   6, TOKEN_REPEAT    ,"REPEAT"
00:CE2E 06              	     1M          DFB  6
00:CE2F 98              	     2M          DFB  TOKEN_REPEAT    
00:CE30 524550454154    	     3M          text  "REPEAT"
                        	  1142:    makeToken   5, TOKEN_UNTIL     ,"UNTIL"
00:CE36 05              	     1M          DFB  5
00:CE37 99              	     2M          DFB  TOKEN_UNTIL     
00:CE38 554E54494C      	     3M          text  "UNTIL"
                        	  1143:    makeToken   3, TOKEN_FOR       ,"FOR"
00:CE3D 03              	     1M          DFB  3
00:CE3E 9A              	     2M          DFB  TOKEN_FOR       
00:CE3F 464F52          	     3M          text  "FOR"
                        	  1144:    makeToken   2, TOKEN_TO        ,"TO"
00:CE42 02              	     1M          DFB  2
00:CE43 9B              	     2M          DFB  TOKEN_TO        
00:CE44 544F            	     3M          text  "TO"
                        	  1145:    makeToken   6, TOKEN_DOWNTO    ,"DOWNTO"
00:CE46 06              	     1M          DFB  6
00:CE47 9C              	     2M          DFB  TOKEN_DOWNTO    
00:CE48 444F574E544F    	     3M          text  "DOWNTO"
                        	  1146:    makeToken   5, TOKEN_WRITE     ,"WRITE"
00:CE4E 05              	     1M          DFB  5
00:CE4F 9D              	     2M          DFB  TOKEN_WRITE     
00:CE50 5752495445      	     3M          text  "WRITE"
                        	  1147:    makeToken   4, TOKEN_READ      ,"READ"
00:CE55 04              	     1M          DFB  4
00:CE56 9E              	     2M          DFB  TOKEN_READ      
00:CE57 52454144        	     3M          text  "READ"
                        	  1148:    makeToken   4, TOKEN_CALL      ,"CALL"
00:CE5B 04              	     1M          DFB  4
00:CE5C 9F              	     2M          DFB  TOKEN_CALL      
00:CE5D 43414C4C        	     3M          text  "CALL"
                        	  1149:    makeToken   4, TOKEN_CHAR      ,"CHAR"
00:CE61 04              	     1M          DFB  4
00:CE62 A1              	     2M          DFB  TOKEN_CHAR      
00:CE63 43484152        	     3M          text  "CHAR"
                        	  1150:    makeToken   4, TOKEN_MEMC      ,"MEMC"
00:CE67 04              	     1M          DFB  4
00:CE68 A2              	     2M          DFB  TOKEN_MEMC      
00:CE69 4D454D43        	     3M          text  "MEMC"
                        	  1151:    makeToken   3, TOKEN_XOR       ,"XOR"
00:CE6D 03              	     1M          DFB  3
00:CE6E A4              	     2M          DFB  TOKEN_XOR       
00:CE6F 584F52          	     3M          text  "XOR"
                        	  1152:    makeToken   7, TOKEN_ADDRESS   ,"ADDRESS"
00:CE72 07              	     1M          DFB  7
00:CE73 A9              	     2M          DFB  TOKEN_ADDRESS   
00:CE74 41444452455353  	     3M          text  "ADDRESS"
                        	  1153:    makeToken   3, TOKEN_CHR       ,"CHR"
00:CE7B 03              	     1M          DFB  3
00:CE7C AB              	     2M          DFB  TOKEN_CHR       
00:CE7D 434852          	     3M          text  "CHR"
                        	  1154:    makeToken   3, TOKEN_HEX       ,"HEX"
00:CE80 03              	     1M          DFB  3
00:CE81 AC              	     2M          DFB  TOKEN_HEX       
00:CE82 484558          	     3M          text  "HEX"
                        	  1155:    makeToken   7, TOKEN_INTEGER   ,"INTEGER"
00:CE85 07              	     1M          DFB  7
00:CE86 FE              	     2M          DFB  TOKEN_INTEGER   
00:CE87 494E5445474552  	     3M          text  "INTEGER"
                        	  1156:    makeToken   7, TOKEN_WRITELN   ,"WRITELN"
00:CE8E 07              	     1M          DFB  7
00:CE8F FF              	     2M          DFB  TOKEN_WRITELN   
00:CE90 57524954454C4E  	     3M          text  "WRITELN"
                        	  1157:    makeToken   8, TOKEN_LCDWRITE  ,"LCDWRITE"
00:CE97 08              	     1M          DFB  8
00:CE98 F1              	     2M          DFB  TOKEN_LCDWRITE  
00:CE99 4C43445752495445	     3M          text  "LCDWRITE"
                        	  1158: 
                        	  1159: 
00:CEA1 00              	  1160: RSVEND   DFB  0,0        ; END OF TABLE
00:CEA2 00
                        	  1161: ;
                        	  1162: 
                        	  1163: ;
                        	  1164: ;  Pascal get_token
                        	  1165: ;
                        	  1166: ;  Used in the Pascal section. Does a get_token, and then if an identifier is found tries to look
                        	  1167: ;  it up.
                        	  1168: ;
                        	  1169: pas_get_token:
00:CEA3 20F5C8          	  1170:   jsr get_token
00:CEA6 F004            	  1171:   beq pas_get_token_eof   ; branch to make sure Z flag stays set
00:CEA8 C949            	  1172:   cmp #TOKEN_IDENTIFIER
00:CEAA F001            	  1173:   beq pas_gc_identifier
                        	  1174: pas_get_token_eof:
00:CEAC 60              	  1175:   rts
                        	  1176: ;
                        	  1177: ;  here if get_token got an identifier
                        	  1178: ;
                        	  1179: pas_gc_identifier:
00:CEAD A9AE            	  1180:   lda  #<RSVWRD
00:CEAF 8598            	  1181:   sta  token_work
00:CEB1 A9CD            	  1182:   lda  #>RSVWRD
00:CEB3 8599            	  1183:   sta  token_work+1
                        	  1184: pas_gc_loop:
00:CEB5 A000            	  1185:   ldy  #0
00:CEB7 B198            	  1186:   lda  (token_work),Y
00:CEB9 D003            	  1187:   bne  pas_gc_more        ; MORE TO GO
00:CEBB A949            	  1188:   lda  #TOKEN_IDENTIFIER
00:CEBD 60              	  1189:   rts
                        	  1190: ;
                        	  1191: ; SEARCH for RESERVED WORD
                        	  1192: ;
                        	  1193: pas_gc_more:
00:CEBE B198            	  1194:   lda  (token_work),Y     ; length of word in table
00:CEC0 C592            	  1195:   cmp  token_length       ; same?
00:CEC2 D022            	  1196:   bne  pas_gc_no_match    ; no - can't be it then
00:CEC4 A8              	  1197:   tay                     ; length
00:CEC5 A590            	  1198:   lda  token_address      ; put token start address into SRCE
00:CEC7 8500            	  1199:   sta  SRCE
00:CEC9 A591            	  1200:   lda  token_address+1
00:CECB 8501            	  1201:   sta  SRCE+1
00:CECD A598            	  1202:   lda  token_work         ; put current token_work+2 into DEST
00:CECF 18              	  1203:   clc
00:CED0 6902            	  1204:   adc  #2
00:CED2 8503            	  1205:   sta  DEST
00:CED4 A599            	  1206:   lda  token_work+1
00:CED6 6900            	  1207:   adc  #0
00:CED8 8504            	  1208:   sta  DEST+1
00:CEDA 200182          	  1209:   jsr  str_ic_compare
00:CEDD D007            	  1210:   bne  pas_gc_no_match      ; NOT FOUND
00:CEDF A001            	  1211:   ldy  #1
00:CEE1 B198            	  1212:   lda  (token_work),Y
00:CEE3 8593            	  1213:   sta  token_type
00:CEE5 60              	  1214:   rts
                        	  1215: pas_gc_no_match    =  *
00:CEE6 A000            	  1216:   ldy  #0
00:CEE8 B198            	  1217:   lda  (token_work),Y     ; token_work points to reserved word entry
00:CEEA 18              	  1218:   clc
00:CEEB 6902            	  1219:   adc  #2         ; add 2 to bypass length and code
00:CEED 6598            	  1220:   adc  token_work
00:CEEF 8598            	  1221:   sta  token_work         ; put it back
00:CEF1 90C2            	  1222:   bcc  pas_gc_loop
00:CEF3 E699            	  1223:   inc  token_work+1       ; handle overflow
00:CEF5 80BE            	  1224:   bra  pas_gc_loop     ; try for another
                        	  1225: 
                        	  1226: 
                        	  1227: 
                        	  1228: ;***********************************************
                        	  1229: ; GET A TOKEN - CHECK THAT IT
                        	  1230: ; IS THE SAME AS IN "A", IF NOT
                        	  1231: ; CALL ERROR "X"
                        	  1232: ;***********************************************
                        	  1233: GETCHK:
00:CEF7 DA              	  1234:   phx   ; save error number
00:CEF8 48              	  1235:   pha   ; save wanted token type
00:CEF9 20A3CE          	  1236:   jsr pas_get_token
00:CEFC 68              	  1237:   pla   ; get it back
00:CEFD C593            	  1238:   cmp token_type
00:CEFF F004            	  1239:   beq CHKOK
00:CF01 FA              	  1240:   plx   ; get error number back
                        	  1241: CHKNOK   =  *
00:CF02 4C6497          	  1242:   jmp ERROR
                        	  1243: CHKOK    =  *
00:CF05 FA              	  1244:   plx   ; get error number back
00:CF06 60              	  1245:   rts
                        	  1246: 
                        	  1247: ;***********************************************
                        	  1248: ; CHECK TOKEN AGREES WITH "A",
                        	  1249: ; IF NOT, GIVE ERROR "X"
                        	  1250: ;***********************************************
                        	  1251: CHKTKN:
00:CF07 C593            	  1252:   cmp  token_type
00:CF09 D0F7            	  1253:   bne  CHKNOK
00:CF0B 60              	  1254:   rts
                        	  1255: 
                        	  1256: ;***********************************************
                        	  1257: ;
                        	  1258: ; GET NEXT TOKEN - MUST BE IDENTIFIER
                        	  1259: ; THEN LOOK IT UP IN SYMBOL TABLE
                        	  1260: ;***********************************************
                        	  1261: 
                        	  1262: GET_LOOK:
00:CF0C A949            	  1263:   lda  #TOKEN_IDENTIFIER
00:CF0E A204            	  1264:   ldx  #4      ; ERROR: Identifier expected
00:CF10 20F7CE          	  1265:   jsr  GETCHK
00:CF13 4C95B9          	  1266:   jmp  LOOKUP
                        	  1267: 

Source: "gpascal.asm"
                        	   186: 
                        	   187: 
                        	   188:   .if LCD_SUPPORT
00:CF16 4E69636B27732047	   189: LCD_welcome asciiz "Nick's G-Pascal\nCompiler v4.0"
00:CF1E 2D50617363616C0A
00:CF26 436F6D70696C6572
00:CF2E 2076342E30
00:CF33 00
                        	   190:   .endif
                        	   191: 
                        	   192: ;
                        	   193: ; here for cold start - clear text file to null etc. etc.
                        	   194: ;
                        	   195: START    =  *
00:CF34 D8              	   196:   cld             ; cancel decimal mode
00:CF35 78              	   197:   sei             ; no interrupts yet
00:CF36 A2FF            	   198:   ldx  #NEW_STK
00:CF38 9A              	   199:   txs             ; set up stack pointer
00:CF39 8609            	   200:   stx random      ; initialise random numbers
00:CF3B 860A            	   201:   stx random+1
00:CF3D 860B            	   202:   stx random+2
00:CF3F 860C            	   203:   stx random+3
00:CF41 2090C8          	   204:   jsr hardware_init
                        	   205: ;
                        	   206: ;  Put 0x00 at start of source
                        	   207: ;
00:CF44 A900            	   208:   lda  #<TEXT_START
00:CF46 8500            	   209:   sta  REG
00:CF48 A903            	   210:   lda  #>TEXT_START
00:CF4A 8501            	   211:   sta  REG+1
00:CF4C A900            	   212:   lda  #0
00:CF4E A8              	   213:   tay
00:CF4F 9100            	   214:   sta  (REG),Y     ; null edit file
00:CF51 84BE            	   215:   sty  system_flags
00:CF53 AA              	   216:   tax
00:CF54 58              	   217:   cli             ; allow interrupts after a reset
00:CF55 4C5DCF          	   218:   jmp  REST1
                        	   219: ;
                        	   220: RESTART  =  *
00:CF58 A2FF            	   221:   ldx  #NEW_STK
00:CF5A 9A              	   222:   txs             ; reset stack
00:CF5B 58              	   223:   cli             ; allow interrupts after a NMI
00:CF5C D8              	   224:   cld             ; cancel decimal mode
                        	   225: ;
                        	   226: REST1    =  *
                        	   227:   .if LCD_SUPPORT
                        	   228:     ;
                        	   229:     ;  put message on the LCD screen to prove it is working
                        	   230:     ;
00:CF5D A916            	   231:     lda  #<LCD_welcome  ; G-pascal compiler
00:CF5F A2CF            	   232:     ldx  #>LCD_welcome
00:CF61 2069B8          	   233:     jsr lcd_print_message
                        	   234:   .endif
                        	   235: 
                        	   236: ;
                        	   237: ;  now direct output to the serial port
                        	   238: ;
00:CF64 2063C8          	   239:   jsr  write_to_serial   ; set up outputting function
00:CF67 A900            	   240:   lda  #0
00:CF69 853F            	   241:   sta  RUNNING
00:CF6B 4CC582          	   242:   jmp  main_start    ; go to "shell"
                        	   243: 
                        	   244: 
                        	   245: ;
                        	   246: ;  processor hardware vectors
                        	   247: ;
                        	   248:   .org $FFFA
01:FFFA 58CF            	   249:   .word RESTART   ; non-maskable interrupt (NMI)
01:FFFC 34CF            	   250:   .word START     ; reset vector
01:FFFE 8FB6            	   251:   .word irq       ; maskable interrupt (IRQ)
                        	   252: 


Symbols by name:
ACT_PCDA                         S:0025
ADD1                             E:B955
ADD4                             E:B978
ADD9                             E:B994
ADDSYM                           E:B8F9
ADDSYM_NOT_FULL                  A:B92E
ASS1                             A:BDC6
ASS2                             A:BE0E
ASSARR                           A:BDED
ASSEMBLE                         A:9842
ASSEMBLE_PASS                    A:9854
ASSEMBLE_SECOND_PASS             A:984F
ASSIGN                           A:BDC3
ASSTB1                           A:BDD2
ASSVAR                           A:BDFF
ASS_COUNT                        S:0072
ASS_EMIT_COUNT                   S:006F
ASS_OPCODE_WORK                  S:0070
ASS_OPERAND                      S:006B
ASS_OPERAND_ABSOLUTE             E:0001
ASS_OPERAND_ABSOLUTE_INDEXED_IN  E:0002
ASS_OPERAND_ABSOLUTE_INDEXED_WI  E:0003
ASS_OPERAND_ABSOLUTE_INDEXED_WI  E:0004
ASS_OPERAND_ABSOLUTE_INDIRECT    E:0005
ASS_OPERAND_ACCUMULATOR_A        E:0006
ASS_OPERAND_IMMEDIATE            E:0007
ASS_OPERAND_IMPLIED              E:0008
ASS_OPERAND_STRING               E:0011
ASS_OPERAND_ZERO_PAGE            E:000B
ASS_OPERAND_ZERO_PAGE_AND_ABSOL  E:0012
ASS_OPERAND_ZERO_PAGE_INDEXED_I  E:000C
ASS_OPERAND_ZERO_PAGE_INDEXED_W  E:000D
ASS_OPERAND_ZERO_PAGE_INDEXED_W  E:000E
ASS_OPERAND_ZERO_PAGE_INDIRECT   E:000F
ASS_OPERAND_ZERO_PAGE_INDIRECT_  E:0010
ASS_PASS                         S:0076
ASS_VALUE                        S:0073
BACKSPACE                        E:0008
BAD_INP                          A:B293
BASE                             S:003B
BAUD_RATE                        E:12C0
BEG                              A:C073
BELL1                            E:AE4B
BIT_INTERVAL                     E:00D0
BLCKT1                           A:C294
BLCKT2                           A:C297
BLCKT3                           A:C29A
BLK1                             A:C2CF
BLK1A                            A:C2BB
BLK2                             A:C2D7
BLK4                             A:C2E1
BLKB1                            A:C537
BLKB2                            A:C553
BLKB3                            A:C531
BLKB4                            A:C56F
BLKB5                            A:C560
BLKB6                            A:C57E
BLKBEG                           A:C527
BLKCN1                           A:C2EE
BLKCNS                           A:C2EB
BLKFNC                           A:C45F
BLKPR1                           A:C481
BLKPR2                           A:C4B3
BLKPR3                           A:C49D
BLKPR4                           A:C4FB
BLKPR5                           E:C4D4
BLKPR6                           A:C4AA
BLKPRC                           A:C43F
BLKV10                           E:C335
BLKV10_A                         E:C351
BLKV10_B                         E:C358
BLKV11                           A:C3BF
BLKV12                           A:C3C6
BLKV13                           A:C380
BLKVAR                           A:C302
BLKVR1                           A:C306
BLKVR2                           A:C367
BLKVR3                           A:C427
BLKVR4                           A:C385
BLKVR5                           E:C3E5
BLKVR6                           A:C309
BLKVR7                           A:C313
BLKVR8                           A:C332
BLKVR9                           E:C3CC
BLOCK                            A:C2A4
BSAVE                            S:0036
CALL                             S:0047
CALLSB                           A:BF9F
CASE                             A:C0DF
CASE1                            A:C118
CASE2                            E:C0F1
CASE3                            A:C12E
CASE4                            A:C124
CASE5                            A:C161
CASE6                            A:C17F
CASE7                            A:C0ED
CASE8                            A:C194
CASE9                            A:C18A
CHKDUP                           A:B9A0
CHKGET                           E:C26D
CHKLHB                           E:BA1B
CHKLHP                           E:BA01
CHKNOK                           E:CF02
CHKOK                            E:CF05
CHKRHB                           E:BA25
CHKRHP                           E:BA08
CHKTKN                           A:CF07
CHK_KBD                          E:AE9F
CHK_NOTD                         A:AEC7
CHK_NOTN                         A:AEAB
CHK_NOTT                         A:AEB9
CHK_RUN                          A:936B
CHK_STAK                         E:BB27
CHK_VAL                          E:9358
CHK_VAL9                         E:936A
CHRIN                            E:C879
CLOCK_RATE                       E:4240
COMPIL                           A:B9B0
COMS8                            A:923A
COMS9                            A:9239
COMSTL                           E:922D
CONDEC                           E:BA40
CONST                            E:BB33
CONST1                           A:BB4A
CONST2                           A:BB54
CONST3                           E:BB4F
CONST9                           A:BB58
COUNT1                           S:004B
COUNT2                           S:004C
COUT                             A:93AF
COUT_CALL                        A:93B9
CR                               E:000D
CROUT                            E:9228
DATA                             S:003D
DATTYP                           S:004A
DB11                             A:AD64
DBGFLG                           S:0049
DCODE                            S:002E
DEBUG                            E:AD64
DEBUG_DONE                       A:ADCC
DEST                             E:0003
DIRECTIVES                       E:9FCE
DIS5                             A:AE34
DIS5_A                           E:AE3E
DISHX                            A:923D
DISP9                            A:C739
DISPAD                           E:9243
DISPAD2                          A:925E
DISPL                            S:0027
DIVBY0                           A:B049
DM1                              A:AD49
DM2                              A:AD52
DM5                              A:ADF3
DM6                              A:AE08
DM7                              A:AE13
DUP9                             A:B9AF
EFLAG_ALLOW_ZERO_FROM            E:0002
EFLAG_FIND                       E:0010
EFLAG_LOAD                       E:0004
EFLAG_NO_LINE_NUMBERS            E:0080
EFLAG_REPLACE                    E:0020
EFLAG_SAVE                       E:0008
EFLAG_SHOW_LINE                  E:0001
EFLAG_SUPPRESS_NEWLINE           E:0040
EMULATOR                         E:0000
EMULATOR_DEBUG                   A:C88D
ENDSYM                           S:0031
END_CMP                          E:B9FE
END_EDITOR_INPUT                 E:001B
END_PCD                          S:0043
END_WRK                          E:C289
ERR1                             E:9777
ERR3                             E:978B
ERR5                             E:979B
ERR6                             E:97A1
ERR7                             E:976D
ERRLIT                           A:9758
ERRNO                            S:0035
ERROR                            A:9764
EXPR1                            A:BD4F
EXPR2                            A:BD71
EXPR3                            A:BD77
EXPR4                            A:BD7B
EXPR5                            A:BD7F
EXPR6                            A:BD83
EXPR7                            A:BD87
EXPR8                            A:BD73
EXPRES                           A:BD2C
EXPTB1                           A:BD3C
EXPTB3                           A:BD5E
EX_ABS                           A:B06D
EX_ABSCLL                        E:B302
EX_ADD                           A:B009
EX_ADRAC                         E:B4E1
EX_ADRAN                         E:B4DB
EX_ADRN2                         E:B4D0
EX_ADRNC                         E:B4BD
EX_ADRNC2                        E:B4C0
EX_ADRNN                         E:B4CD
EX_AND                           A:B0DB
EX_ASSERT                        A:B574
EX_ASSERT_OK                     A:B589
EX_CLA                           A:B398
EX_CLL                           E:B309
EX_CLL2                          E:B333
EX_CLL3                          E:B354
EX_CLL4                          E:B32F
EX_CLL5                          E:B395
EX_CLL_A                         E:B311
EX_CLL_JMP                       A:B3B5
EX_DEC                           A:B11D
EX_DELAY                         E:B530
EX_DIGITALREAD                   E:B4E7
EX_DIGITALREAD_ONE               A:B4F2
EX_DIGITALWRITE                  E:B55F
EX_DIV                           A:B059
EX_DIVIDE_BY_ZERO                A:B042
EX_EOR                           A:B0E4
EX_EQL                           A:B076
EX_FINISHD                       E:AE69
EX_GEQ                           A:B0B1
EX_GETKEY                        E:B027
EX_GTR                           A:B0A5
EX_INC                           A:B105
EX_INP                           E:B25B
EX_INPC                          A:B423
EX_INPC_OK                       A:B42D
EX_INP_OK                        A:B26C
EX_INS                           E:B45F
EX_INS1                          E:B482
EX_INS2                          E:B48B
EX_INS3                          E:B469
EX_INS4                          E:B495
EX_INT                           A:B3B8
EX_INVINS                        E:AF1C
EX_JM1                           A:B418
EX_JMP                           A:B3F4
EX_JMZ                           A:B407
EX_LATENCY                       A:B521
EX_LCDCLEAR                      A:B459
EX_LCDHOME                       A:B453
EX_LCDPOS                        E:B4F5
EX_LCDPOS_1                      A:B505
EX_LCD_WRITE_CHR                 A:B442
EX_LCD_WRITE_HEX                 A:B2B4
EX_LCD_WRITE_NUM                 A:B2A0
EX_LCD_WRITE_STR                 A:B2D4
EX_LDA                           A:B179
EX_LDAC                          A:B16E
EX_LDI                           A:B1B4
EX_LDIC                          A:B1AE
EX_LEQ                           A:B0BD
EX_LIB_CALL                      A:B56E
EX_LIT                           A:AFEE
EX_LOD                           A:B158
EX_LOD2                          A:B15B
EX_LOD3                          A:B149
EX_LOD3_A                        A:B14B
EX_LODC                          A:B146
EX_LSS                           A:B099
EX_MOD                           A:B02E
EX_MOV                           A:B135
EX_MUL                           A:B01E
EX_NEG                           A:B000
EX_NEQ                           A:B090
EX_NEW_STACK                     A:B3E2
EX_NOJUMP                        A:B412
EX_ORR                           A:B0D2
EX_OUH                           A:B2AF
EX_OUH_COMMON                    A:B2B7
EX_OUS                           E:B2CF
EX_OUS1                          A:B2F3
EX_OUS_COMMON                    A:B2D7
EX_OUT                           A:B29B
EX_OUTC                          A:B43D
EX_OUTCR                         E:AEC9
EX_OUTC_COMMON                   A:B445
EX_PINMODE                       E:B550
EX_RANDOM                        A:B50F
EX_RANDOMSEED                    E:B540
EX_RTN                           A:B222
EX_SHL                           A:B0ED
EX_SHR                           A:B0F9
EX_STA                           A:B1DA
EX_STA5                          A:B1EB
EX_STAC                          A:B1F0
EX_STI                           A:B207
EX_STIC                          A:B1F9
EX_STO                           A:B1C7
EX_STO2                          A:B1CD
EX_STO5                          A:B1C2
EX_STOC                          A:B1BA
EX_SUB                           A:B012
EX_XOR                           A:B0C9
FACAD1                           A:BC7A
FACAD2                           A:BC98
FACADR                           E:BCC2
FACERR1                          A:BCDB
FACM2                            A:BCF6
FACMEM                           A:BCEC
FACMMC                           A:BCF2
FACNOT                           A:BD02
FACNUM                           E:BCE0
FACRND1                          A:BD0D
FACSTR                           A:BCD5
FACTB1                           A:BD13
FACTOR                           A:BC2B
FACTQT1                          A:BD19
FALSE                            A:B08C
FFLAG_GLOBAL                     E:0002
FFLAG_IGNORE_CASE                E:0001
FFLAG_QUIET                      E:0004
FIN_MSG                          A:AE80
FIXAD                            E:C782
FIXAD1                           A:C7BF
FIXM1                            A:C7C0
FIXM2                            A:C7C9
FLAG_ABORTED                     E:0080
FLAG_ASSEMBLING                  E:0002
FLAG_COMPILING                   E:0001
FLAG_LIST_SOURCE                 E:0004
FLAG_ONLY_ALPHA                  E:0040
FLAG_VALID_ASSEMBLE              E:0010
FLAG_VALID_COMPILE               E:0008
FNC1                             A:BFE9
FNC2                             A:BFB9
FNC3                             A:BFE3
FNC4                             A:C02D
FNC5                             A:BFEC
FNC5A                            A:C009
FNC5B                            A:C00B
FNC6                             A:C02E
FNCPRC                           A:BFAC
FOR                              A:C19A
FOR1                             A:C1A4
FOR2                             A:C1B1
FOR3                             A:C1CA
FOR4                             A:C1FB
FOR5                             A:C23E
FOR6                             A:C260
FRAME                            S:0020
FROM                             E:0040
GEN1                             E:C6E0
GEN2                             E:C717
GEN2_A                           E:C722
GEN2_B                           E:C719
GEN2_C                           E:C739
GEN3                             E:C77D
GENADR                           E:C6E4
GENJMP                           E:C754
GENNJM                           A:C74E
GENNJP                           E:C74C
GENNOP                           E:C6CB
GENNOP1                          A:BD0A
GENNOP2                          A:BF77
GENRJMP                          E:C73A
GEN_FULL                         A:C734
GET1                             A:9389
GET1_A                           E:AF73
GET2                             E:AF37
GET3                             A:93A6
GETADR                           A:AF2D
GETADR1                          E:AF58
GETCHK                           A:CEF7
GETEXPR                          E:BABF
GETID2                           A:B1A0
GETIDC                           A:B183
GETIDX                           E:B18C
GETIN                            E:C879
GETIN1                           A:C883
GETLIT                           E:AFD7
GETLN1                           E:9387
GETLN_OVERFLOW                   A:93AC
GETO_1                           E:BAB0
GETO_2                           E:BABD
GETSUB                           E:BA12
GET_COMM                         E:BAF1
GET_DAT                          E:BA39
GET_END                          A:AFED
GET_ITEM                         E:BAF8
GET_LEV                          E:BA2F
GET_LINE                         E:9387
GET_LOOK                         A:CF0C
GET_OFF                          E:BA94
HIGHEST_RAM                      E:3FFF
IDENT                            A:BC3C
IDENT1                           A:BC3F
IDENT1A                          A:BC47
IDENT2                           A:BC4C
IDENT2A                          A:BC65
IDENT3                           A:BC6C
IDENT4                           A:BCA0
IDENT4_A                         A:BCA2
IDENT5                           A:BC82
IDENT5_A                         A:BC84
IDENT6                           A:BC8F
IDENT7                           A:BC95
IF                               A:C033
IF1                              A:C058
IF2                              A:C051
INBUF                            S:0200
INBUF_SIZE                       E:0100
INIT                             E:91DA
INIT9                            A:9227
INIT_SECOND_PASS                 A:91E6
INP3                             A:B283
INTERP                           E:ADCD
INT_ERR                          E:B3CF
INT_ERRM                         A:B3D6
JMP1                             E:8F9A
JMP2                             E:8FA2
JMP3                             E:8FB7
KEY_ABORT                        E:0003
KEY_DEBUG                        E:0004
KEY_STOP_TRACE                   E:000E
KEY_TRACE                        E:0014
LASTP                            S:004D
LCD_E                            E:0080
LCD_RS                           E:0020
LCD_RW                           E:0040
LCD_SUPPORT                      E:0001
LCD_welcome                      A:CF16
LEVEL                            S:0022
LINE_CNT                         S:0019
LIST                             S:001D
LIT1                             A:AFFD
LOOK1                            A:B99F
LOOKUP                           E:B995
LOWLIT                           A:AECF
LOWLIT1                          A:AED5
MAIN                             A:AEDE
MAINP                            A:AEDB
MAIN_1                           E:AF0D
MAIN_2                           E:AEE5
MAIN_NOT_ABORT                   E:AEF0
MAIN_OK                          E:AEF3
MAKE_LOWER_DONE                  E:8FD9
MAKE_UPPER                       E:8FC4
MAKE_UPPER_DONE                  E:8FCE
MAX_STK                          E:0020
MCAND                            S:0055
MEM                              A:BF84
MEM2                             A:BF8C
MEMC                             A:BF89
NEW_STK                          E:00FF
NL                               E:000A
NOSCE                            A:91C9
NOTIM1                           E:AF20
OFFSET                           S:0029
ONE_OP                           A:BF70
ONE_OP2                          A:BF6D
OPCODE                           S:006C
OPCODE_3_CHAR_BRANCH             E:A092
OPCODE_3_CHAR_IMPLIED            E:A0B7
OPCODE_4_CHAR_BRANCH             E:A041
OPCODE_4_CHAR_ZERO_PAGE          E:A134
OPCODE_ASS_OPERAND_ABSOLUTE      E:A185
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A1F1
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A1F6
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A23B
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A23E
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A263
OPCODE_ASS_OPERAND_ABSOLUTE_IND  E:A27F
OPCODE_ASS_OPERAND_ABSOLUTE_TOK  E:A1EE
OPCODE_ASS_OPERAND_ACCUMULATOR_  E:A266
OPCODE_ASS_OPERAND_IMMEDIATE     E:A284
OPCODE_ASS_OPERAND_IMMEDIATE_TO  E:A2B5
OPCODE_ASS_OPERAND_ZERO_PAGE     E:A2B8
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A31C
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A33D
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A340
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A389
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A38C
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A395
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A3B9
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A3DA
OPCODE_ASS_OPERAND_ZERO_PAGE_IN  E:A3B6
OPCODE_ASS_OPERAND_ZERO_PAGE_TO  E:A319
OPCODE_LEN                       S:006E
OPCODE_LOOKUP_HANDLER            E:0004
OPCODE_LOOKUP_OPCODE_LENGTH      E:0000
OPCODE_LOOKUP_OPCODE_TABLE       E:0002
OPCODE_LOOKUP_OPERAND_TYPE       E:0001
OPCODE_LOOKUP_TABLE              E:9F2B
OPCODE_LOOKUP_TABLE_SIZE         E:0006
OPND                             S:002B
OUT_COMMON                       A:B2A3
PAREN                            A:BCE6
PCD_WRKD                         E:BAC5
PCODE                            S:0023
PCODE_ABSCLL                     E:0038
PCODE_ADD                        E:0004
PCODE_ADRAN                      E:000E
PCODE_ADRNN                      E:000C
PCODE_AND                        E:001B
PCODE_CLA                        E:002B
PCODE_CLL                        E:0027
PCODE_DEC                        E:0028
PCODE_DIV                        E:000A
PCODE_EOR                        E:0020
PCODE_EQL                        E:0010
PCODE_FINISHD                    E:0011
PCODE_GEQ                        E:0016
PCODE_GTR                        E:0018
PCODE_INC                        E:0026
PCODE_INP                        E:001C
PCODE_INS                        E:0025
PCODE_INT                        E:003B
PCODE_JM1                        E:003E
PCODE_JMP                        E:003C
PCODE_JMZ                        E:003D
PCODE_LAST                       E:0045
PCODE_LCD_WRITE_CHR              E:0045
PCODE_LCD_WRITE_HEX              E:0044
PCODE_LCD_WRITE_NUM              E:0042
PCODE_LCD_WRITE_STR              E:0043
PCODE_LDA                        E:002E
PCODE_LDI                        E:0030
PCODE_LEQ                        E:0019
PCODE_LIB_CALL                   E:0003
PCODE_LIT                        E:0000
PCODE_LOD                        E:002C
PCODE_LSS                        E:0014
PCODE_MOD                        E:000B
PCODE_MOV                        E:002A
PCODE_MUL                        E:0008
PCODE_NEG                        E:0002
PCODE_NEQ                        E:0012
PCODE_ORR                        E:001A
PCODE_OUH                        E:0021
PCODE_OUS                        E:0023
PCODE_OUT                        E:001E
PCODE_OUTC                       E:001F
PCODE_OUTCR                      E:0040
PCODE_RTN                        E:0029
PCODE_SHL                        E:0022
PCODE_SHR                        E:0024
PCODE_STA                        E:0034
PCODE_STACK                      E:0001
PCODE_STI                        E:0036
PCODE_STO                        E:0032
PCODE_SUB                        E:0006
PCODE_XOR                        E:003A
PRBYTE                           A:929D
PRBYTECR                         E:9352
PRCHAR                           E:9285
PRCITM                           S:0039
PRHEX                            A:92A6
PRHEX1                           A:92B0
PRHEXZ                           A:92A8
PSH1                             E:AFC6
PSH9                             A:9271
PSHPCODE                         E:BA81
PSHTOP                           E:AFBB
PSHWRK                           E:925F
PT                               A:92B7
PT6                              A:92BF
PUL2_END                         E:AFB4
PULBOTH                          A:AF96
PULTOP                           E:AF74
PULTOP2                          E:AF99
PULWRK                           E:9272
PUL_END                          E:AF8F
PUTSP                            E:92B3
READ                             A:BEDB
READ11                           A:BEFB
READ2                            A:BEE1
READ3                            A:BF2A
READ3_A                          A:BF59
READ3_B                          A:BF3E
READ7                            A:BF1A
READ7_A                          A:BF20
READ8                            A:BEDE
READ9                            A:BEF8
REG                              E:0000
REG2                             E:0003
REG2B                            E:0005
REGB                             E:0002
REMAIN                           S:0006
REP1                             A:C08C
REPEAT                           A:C089
RES                              S:0052
REST1                            E:CF5D
RESTART                          E:CF58
RMNDR                            S:005B
RSVEND                           A:CEA1
RSVWRD                           E:CDAE
RUNERR                           A:AE55
RUNNING                          S:003F
SEA1                             E:B890
SEA2                             E:B89D
SEA3                             E:B8F1
SEA4                             E:B8E6
SEA5                             E:B8EE
SEARCH                           E:B87D
SEA_NEXT                         E:B885
SERIAL_DEBUG1_MASK               E:0004
SERIAL_DEBUG2_MASK               E:0008
SERIAL_DEBUGGING                 E:0000
SERIAL_DELAY1                    E:0020
SERIAL_DELAY2                    E:0023
SERIAL_OUT_MASK                  E:0002
SERIAL_SPARE2_MASK               E:0010
SIM1                             A:BB75
SIM2                             A:BBBD
SIM3                             A:BB86
SIM4                             A:BB99
SIM5                             A:BBB5
SIM6                             A:BBB9
SIM7                             A:BBAF
SIM8                             A:BBC3
SIMEXP                           E:BB6B
SINGLE_QUOTE                     E:0027
SRCE                             E:0000
START                            E:CF34
STARTSYM                         S:002F
START_OF_ROM                     E:8000
START_TRACE                      A:C88E
STK_ERR                          A:BB2E
STK_FULL                         E:BB2E
STMNT                            A:BD8B
STMNT1                           A:BD98
STMNT_WRITE_LCD                  A:BE8A
STOP_TRACE                       A:C88F
ST_SYMTBL_LIST_CHECK             E:8DA3
ST_SYMTBL_LIST_DONE              E:8E38
ST_SYMTBL_LIST_LINE              E:8DB2
ST_SYMTBL_LIST_NAME              E:8E27
ST_SYMTBL_LIST_NEXT              E:8D98
SYMARG                           E:0006
SYMBOL_ARRAY                     E:0041
SYMBOL_CONSTANT                  E:0043
SYMBOL_FUNCTION                  E:0046
SYMBOL_FUNCTION_RETURN           E:0059
SYMBOL_LIBRARY_FUNCTION          E:0052
SYMBOL_LIBRARY_PROCEDURE         E:0051
SYMBOL_PROCEDURE                 E:0050
SYMBOL_TABLE_START               E:3FFF
SYMBOL_VARIABLE                  E:0056
SYMDAT                           E:0008
SYMDSP                           E:0004
SYMITM                           S:0040
SYMLEN                           E:0009
SYMLVL                           E:0002
SYMNAM                           E:000A
SYMPRV                           E:0000
SYMSUB                           E:0006
SYMTYP                           E:0003
SYMWRK                           E:BA6B
SYM_FULL                         A:B8F4
SYNTAX                           S:0042
T                                E:0031
TEMP                             S:0045
TERM                             A:BBDD
TERM1                            A:BBEA
TERM2                            A:BBE0
TERM3                            A:BBFB
TERM4                            A:BBF9
TERM5                            A:BC01
TERM6                            A:BC05
TERM7                            A:BC09
TERM8                            A:BC0D
TERM9                            A:BC11
TERMT1                           A:BBC7
TERMT3                           A:BC15
TEXT_START                       E:0300
TKNJMP                           E:8F92
TKNWRK                           E:92C9
TOKEN_ADDRESS                    E:00A9
TOKEN_AND                        E:008D
TOKEN_ARRAY                      E:0084
TOKEN_ASSIGN                     E:0041
TOKEN_BEGIN                      E:0088
TOKEN_CALL                       E:009F
TOKEN_CASE                       E:0095
TOKEN_CHAR                       E:00A1
TOKEN_CHR                        E:00AB
TOKEN_CONST                      E:0082
TOKEN_DIV                        E:008B
TOKEN_DO                         E:0097
TOKEN_DOWNTO                     E:009C
TOKEN_ELSE                       E:0094
TOKEN_END                        E:0089
TOKEN_EQUALITY                   E:0045
TOKEN_FOR                        E:009A
TOKEN_FUNCTION                   E:0087
TOKEN_GEQ                        E:0081
TOKEN_HEX                        E:00AC
TOKEN_HIGH_BYTE                  E:0057
TOKEN_IDENTIFIER                 E:0049
TOKEN_IF                         E:0092
TOKEN_INEQUALITY                 E:005A
TOKEN_INTEGER                    E:00FE
TOKEN_LCDWRITE                   E:00F1
TOKEN_LEQ                        E:0080
TOKEN_LOGICAL_AND                E:0058
TOKEN_LOGICAL_OR                 E:0059
TOKEN_LOW_BYTE                   E:0056
TOKEN_MEM                        E:0091
TOKEN_MEMC                       E:00A2
TOKEN_MOD                        E:008C
TOKEN_NEQ                        E:0055
TOKEN_NOT                        E:0090
TOKEN_NUMBER                     E:004E
TOKEN_OF                         E:0085
TOKEN_OR                         E:008A
TOKEN_PROCEDURE                  E:0086
TOKEN_READ                       E:009E
TOKEN_REPEAT                     E:0098
TOKEN_SHIFT_LEFT                 E:004C
TOKEN_SHIFT_RIGHT                E:0052
TOKEN_SHL                        E:008E
TOKEN_SHR                        E:008F
TOKEN_STRING                     E:0022
TOKEN_THEN                       E:0093
TOKEN_TO                         E:009B
TOKEN_UNARY_MINUS                E:004D
TOKEN_UNTIL                      E:0099
TOKEN_VAR                        E:0083
TOKEN_WHILE                      E:0096
TOKEN_WRITE                      E:009D
TOKEN_WRITELN                    E:00FF
TOKEN_XOR                        E:00A4
TRUE                             A:B07F
TRUE2                            A:B081
TWO_OP                           A:BF67
VALUE                            S:0000
VALUE2                           S:0003
VAL_1                            E:BB07
VAL_2                            E:BB0C
VAL_3                            E:BB15
VAL_5                            E:BB1E
VAL_MOVE                         E:BAFE
VAL_WRK                          E:C27E
VARDEC                           A:BB59
VIA_ACR                          E:7FFB
VIA_DDRA                         E:7FF3
VIA_DDRB                         E:7FF2
VIA_FLAG_CB2                     E:0008
VIA_FLAG_DISABLE                 E:0000
VIA_FLAG_ENABLE                  E:0080
VIA_FLAG_TIMER1                  E:0040
VIA_IER                          E:7FFE
VIA_IFR                          E:7FFD
VIA_PORTA                        E:7FF1
VIA_PORTB                        E:7FF0
VIA_T1C_H                        E:7FF5
VIA_T1C_L                        E:7FF4
WAIT_1                           A:BF7A
WHILE                            A:C0AD
WORK                             S:0037
WORKD                            S:0033
WRIT1                            E:BE65
WRIT10                           A:BE58
WRIT2                            A:BE55
WRIT5                            A:BE75
WRIT9                            A:BE3C
WRITE                            A:BE39
WRITELN                          A:BE2A
WRITELN9                         E:BE34
WRITE_LCD1                       E:BEB6
WRITE_LCD2                       A:BEA6
WRITE_LCD5                       A:BEC6
WRITE_LCD9                       A:BE8D
WRITE_LCD_STRING                 E:BE9C
WRITE_LDC_CHR                    E:BECF
WRITE_LDC_CHR1                   E:BED1
WRITE_LDC_HEX                    E:BED7
WRKD_WRK                         E:BADB
WRKSYM                           E:BA76
WRKTKN                           E:92D4
WRK_OPND                         E:BAD0
WRK_VAL                          E:C273
WRK_WRKD                         E:BAE6
W_CHR                            E:BE7E
W_CHR1                           E:BE80
W_HEX                            E:BE86
W_STRING                         E:BE4B
ZERRES                           A:ABDF
a_equals_message                 A:B5A7
add_assembler_library_functions  A:A9FB
add_assembler_library_functions  A:AA45
add_assembler_library_functions  A:AA03
add_assembler_library_functions  A:AA13
add_pascal_library_functions     A:C621
add_pascal_library_functions_do  A:C67A
add_pascal_library_functions_lo  A:C629
add_pascal_library_functions_na  A:C639
asm_do_asc                       E:A442
asm_do_asc_loop                  A:A44F
asm_do_asc_next                  A:A458
asm_do_asc_ok                    A:A44D
asm_do_assert                    A:A3DD
asm_do_assert_failed             A:A3EC
asm_do_blk                       A:A514
asm_do_blk_done                  A:A531
asm_do_blk_loop                  A:A524
asm_do_constant_expected         A:A489
asm_do_constant_expectedJ        A:A3F1
asm_do_constant_expectedJ2       A:A54A
asm_do_dfb                       A:A497
asm_do_dfb_multiple              A:A4A5
asm_do_dfb_multiple_done         A:A4C3
asm_do_dfb_multiple_loop         A:A4B2
asm_do_dfb_too_big               A:A4C4
asm_do_dfw                       A:A4D7
asm_do_dfw_multiple              A:A4E5
asm_do_dfw_multiple_done         A:A504
asm_do_dfw_multiple_loop         A:A4F3
asm_do_equ                       A:A466
asm_do_equ_have_label            A:A477
asm_do_list                      E:A3F4
asm_do_list1                     A:A432
asm_do_list_first_pass           A:A441
asm_do_list_no_operand           A:A414
asm_do_list_not                  A:A42E
asm_do_list_ok                   A:A418
asm_do_nolist                    A:A403
asm_do_nolist_ok                 A:A40E
asm_do_org                       A:A483
asm_do_org_ok                    A:A48E
asm_do_reserve                   A:A532
asm_do_string                    A:A45D
asm_do_sym                       A:A54D
asm_do_sym_done                  A:A566
asm_emit_one_byte                A:A4C9
asm_emit_two_bytes               A:A505
ass_absolute_another_value       A:9AE6
ass_added_symbol                 A:9900
ass_already_emitted              A:9E9C
ass_asterisk                     A:99BE
ass_bad_identifier               A:98BB
ass_bad_indirect                 A:9A4D
ass_bad_zp_indirect_indexed      A:9A87
ass_branch_backwards             A:9EE7
ass_branch_ok                    A:9EEB
ass_branch_out_of_range          A:9EF1
ass_check_label_changed          A:996E
ass_check_no_more_tokens         A:9BE1
ass_check_no_more_tokens_ok      A:9BF0
ass_check_we_have_x_or_y         A:9A8E
ass_check_we_have_x_or_y_ok      A:9AAA
ass_current_label                S:0083
ass_done                         A:9B9E
ass_done1                        A:9BC0
ass_done_jump                    A:9879
ass_done_message                 A:9BC3
ass_done_second_pass             A:9BA8
ass_emit                         A:9E79
ass_emit1                        A:9EB4
ass_emit2                        A:9E8D
ass_emit3                        A:9EAE
ass_emit4                        A:9EA7
ass_emit_absolute                A:9F20
ass_emit_bytes                   S:0077
ass_emit_immediate               A:9F0D
ass_emit_immediate_too_high      A:9F1B
ass_emit_zero_page               A:9EFA
ass_emit_zero_page_too_high      A:9F08
ass_error                        A:9EB7
ass_error1                       A:9EBE
ass_evaluate_operator            A:9E52
ass_expression_apply_operator    A:9E11
ass_expression_apply_operator_b  A:9E4D
ass_expression_cannot_be_unary   A:9DBD
ass_expression_found_value       A:9D63
ass_expression_loop              A:9D16
ass_expression_loop1             A:9D47
ass_expression_loop1a            A:9D30
ass_expression_loop2             A:9D74
ass_expression_loop3             A:9D83
ass_expression_loop3a            A:9D92
ass_expression_loop3b            A:9D87
ass_expression_loop3c            A:9D97
ass_expression_loop4             A:9D9D
ass_expression_loop6             A:9DE3
ass_expression_loop7             A:9DCC
ass_expression_loopJ             A:9D9A
ass_expression_loop_initial      A:9D19
ass_expression_not_small_string  A:9D42
ass_expression_number            A:9D1D
ass_expression_unary             A:9E3A
ass_finish_line                  A:986E
ass_finish_lineJ                 A:9998
ass_finish_lineJ2                A:991A
ass_fixup_bbr_branch             A:9EC1
ass_fixup_branch                 A:9ECE
ass_get_value                    A:9CFC
ass_identifier                   A:98C0
ass_identifier_operand           A:99F1
ass_illegal_opcode               A:9925
ass_immediate                    A:99D5
ass_indexed                      A:9ABF
ass_indexed_x                    A:9ADD
ass_indirect                     A:99E8
ass_indirect_with_bracket        A:9A52
ass_label_not_found_yet          A:9D5B
ass_line                         A:987C
ass_line1                        A:988B
ass_lookup_existing_label        A:98EA
ass_lookup_loop                  A:9E55
ass_lookup_save_address          A:98F4
ass_no_operand                   A:998E
ass_not_colon                    A:9912
ass_not_colon2                   A:991D
ass_not_unary_less_than          A:9DB5
ass_not_unary_minus              A:9DAB
ass_not_x_or_y                   A:9A8C
ass_opcode                       A:992D
ass_opcode2                      A:9983
ass_opcode_found                 A:9E73
ass_operand                      A:999B
ass_operand_value                A:9A12
ass_string                       A:99B1
ass_symbol_address_changed       A:997E
ass_value_done                   A:9AB6
ass_value_not_indirect           A:9AAC
ass_value_not_indirectJ          A:9A4A
ass_zp_indirect_indexed          A:9A66
assembler_library_functions_tab  A:A5C7
assertion_failed_message         A:971E
assign_bad_identifier            A:BDE8
atoi                             A:C9E4
atoi_error                       E:CA53
atoi_loop                        E:C9ED
atoi_more                        E:C9FE
atoi_not_running                 E:CA59
atoi_positive                    A:C9FC
bad_command                      A:82A2
bad_delimiter_message            A:86A7
bad_flag_message                 A:8811
bcd_output_digit                 A:9170
bcd_positive                     A:915E
bcd_result                       S:0060
bcd_skip_zeroes                  A:9165
bcd_table                        E:90F2
bcd_unpack                       A:90DF
bcd_work                         S:005C
binary_to_decimal                A:917B
binary_to_decimal_loop           A:9186
binary_to_decimal_next           A:91AB
break_message                    A:B58C
brk_address                      S:0015
brk_executed                     A:B5D8
brk_executed1                    A:B653
brk_executed2                    A:B660
brk_executed3                    A:B670
brk_executedJ                    A:B68C
brk_resumed                      A:8CA6
bytes_message                    A:907B
call_a                           S:0010
call_assembler                   A:937D
call_handler                     A:8F4A
call_p                           S:0013
call_s                           S:0014
call_x                           S:0011
call_y                           S:0012
cb2_interrupt                    A:B6B4
character_types_table            E:8006
compile_finished_message         A:92F2
crc16                            E:8FFD
crc16_loop                       E:9009
crc16_next                       A:9016
crc16_skip                       A:901C
crc_addr                         E:0000
crc_byte                         E:9025
crc_done                         A:9024
crc_helper1                      A:9055
crc_message                      A:9058
crc_num                          E:0003
crc_source                       E:9083
crc_val                          E:0006
current_line                     S:00A2
delay                            E:90D5
delay_1ms                        E:90CB
delay_1ms_loop                   A:90CE
digitalread                      E:C846
digitalread_B                    A:C855
digitalread_C                    A:C85D
digitalwrite                     E:C817
digitalwrite_B                   A:C828
digitalwrite_C                   A:C830
digitalwrite_ONE                 A:C83E
display_in_decimal               E:9152
display_x_characters             A:AE2D
editor_assemble                  A:8F07
editor_bad_delimiter             A:86B6
editor_bad_number                A:856D
editor_bad_range                 A:8614
editor_check_no_more             A:8638
editor_check_no_more_ok          A:8647
editor_compile                   A:8E91
editor_debug                     A:8E73
editor_default_range             A:854F
editor_delete                    A:8B6E
editor_delete_have_range         A:8B90
editor_delete_line_count_done    A:8BE9
editor_delete_line_count_loop    A:8BC9
editor_delete_line_count_not_do  A:8BD5
editor_delete_line_count_not_ne  A:8BE1
editor_do_replace                A:8986
editor_do_replace_copy_done      A:89CB
editor_do_replace_smaller        A:89C8
editor_do_the_replace            A:88EC
editor_easy_replace              A:88F9
editor_easy_replace_done         A:890A
editor_easy_replace_loop         A:88FD
editor_find                      A:873B
editor_find_bug                  A:8779
editor_find_case_sensitive       A:88AA
editor_find_found_it             A:88CE
editor_find_found_it1            A:88D4
editor_find_get_flags            A:87D3
editor_find_inner_loop           A:8893
editor_find_loop                 A:888F
editor_find_no_match             A:88B8
editor_find_or_replacing         A:888B
editor_find_problem              A:86BA
editor_find_second_delimiter_lo  A:8786
editor_find_skip_this            A:88B4
editor_find_test_character       A:88AB
editor_find_third_delimiter_loo  A:87AD
editor_flags                     S:00BC
editor_flags1                    A:87F3
editor_flags2                    A:87FD
editor_flags3                    A:8807
editor_flags_loop                A:87D5
editor_get_delimiter             A:86E4
editor_get_number                A:8577
editor_get_number_done           A:85D8
editor_get_number_none           A:85DA
editor_get_number_not_identifie  A:85B2
editor_get_number_ok             A:85C8
editor_get_range                 A:8648
editor_get_range_done            A:8692
editor_get_range_hyphen          A:867A
editor_get_range_number          A:867F
editor_handlers                  A:8330
editor_help                      A:8533
editor_help_done                 A:854C
editor_help_info                 A:83BE
editor_help_loop                 A:853B
editor_info                      E:8E85
editor_insert                    A:89FA
editor_insert_at_start           A:8A16
editor_insert_backspace          A:8AB3
editor_insert_backspace_not_at_  A:8ABF
editor_insert_common             A:8A24
editor_insert_done               A:8AD2
editor_insert_done_with_newline  A:8AE4
editor_insert_loop               A:8A63
editor_insert_loop1              A:8AA3
editor_insert_no_line_number     A:8A74
editor_insert_not_newline        A:8A99
editor_line_number_too_big       A:85FB
editor_list                      A:8747
editor_list_aborted              A:887E
editor_list_check_to_line        A:893A
editor_list_check_to_line_ok     A:894A
editor_list_completely_done      A:8983
editor_list_doing_find           A:876D
editor_list_done                 A:8966
editor_list_doneJ                A:8851
editor_list_fix_target_string    A:881F
editor_list_fixup_loop           A:8827
editor_list_get_on_with_it       A:883A
editor_list_got_from_point       A:8784
editor_list_have_source          A:884B
editor_list_loop                 A:8857
editor_list_loopJ                A:8963
editor_list_no_line_number       A:8928
editor_list_no_line_numberJ      A:8854
editor_list_not_find             A:8837
editor_list_not_finding          A:891B
editor_list_not_newline          A:8952
editor_list_skip_newline         A:895D
editor_load                      A:89F6
editor_memory                    A:8CCC
editor_memory_aborted            A:8D39
editor_memory_ascii              A:8D41
editor_memory_done               A:8D36
editor_memory_loop               A:8CE3
editor_memory_loop1              A:8D04
editor_memory_loop2              A:8D16
editor_memory_loop3              A:8D26
editor_memory_not_control        A:8D49
editor_memory_not_high           A:8D4F
editor_memory_show_ascii         A:8D3F
editor_memory_show_dot           A:8D4D
editor_newline_processing        A:8930
editor_no_closing_delimiter      A:8712
editor_no_closing_delimiterJ     A:8781
editor_no_closing_delimiter_mes  A:86FC
editor_no_find_string            A:872D
editor_no_lines                  A:8B17
editor_recover                   A:8E4D
editor_recover_not_needed        A:8E69
editor_replace                   A:8733
editor_replacement_loop          A:888D
editor_run                       A:8E9F
editor_save                      A:8741
editor_syntax                    A:8E98
editor_test                      A:8CBA
editor_too_full                  A:8AFF
editor_too_full_loop             A:8B06
editor_trace                     A:8E7C
error1                           A:97BB
error_find_next                  A:97B2
error_found                      A:97DC
error_loop                       A:97AE
error_next                       A:97AD
error_not_found                  A:97C4
error_not_found_message          A:97E9
errors_table                     A:93BC
ex_input_aborted                 A:B4B6
execution_aborted_message        A:B4A2
execution_address_table          E:ACBD
exp_abs_val                      A:ABAF
exp_abs_val2                     A:ABC7
exp_abs_val2_done                A:ABDE
exp_abs_val_done                 A:ABC6
exp_add                          A:AA46
exp_bitwise_and                  A:AAE9
exp_bitwise_or                   A:AAD4
exp_bitwise_xor                  A:AAFE
exp_divide                       A:AC4D
exp_divide_loop                  A:AC6A
exp_divide_not_zero              A:AC5D
exp_divide_subtraction_negative  A:AC92
exp_divide_subtraction_positive  A:AC93
exp_done                         A:9DF4
exp_done_error                   A:9DFA
exp_done_ok                      A:9DFF
exp_eql                          A:AA80
exp_evaluation_function          S:007F
exp_false                        A:AA79
exp_falseJ                       A:AB16
exp_find_sign                    A:ABE8
exp_fix_sign                     A:AC00
exp_fix_sign_done                A:AC13
exp_geq                          A:AACD
exp_get_operator                 A:9C67
exp_get_operator_ok              A:9C70
exp_get_precedence               A:9CD5
exp_get_precedence_found         A:9CEB
exp_get_precedence_loop          A:9CD7
exp_greater_than                 A:AAAF
exp_high_byte                    A:ABA6
exp_leq                          A:AABE
exp_less_than                    A:AAA8
exp_logical_and                  A:AB28
exp_logical_or                   A:AB19
exp_low_byte                     A:ABA1
exp_modulo                       A:ACAD
exp_multiply                     A:AC14
exp_multiply_loop                A:AC19
exp_multiply_no_add              A:AC3A
exp_negate                       A:AB6C
exp_negate_val                   A:ABB3
exp_negate_val2                  A:ABCB
exp_neq                          A:AA94
exp_no_operators_left            A:9DEB
exp_not                          A:AB7F
exp_operator                     S:007D
exp_operator_precedence          S:007E
exp_operator_stack_count         S:007C
exp_pop_operator                 A:9C57
exp_pop_operator_ok              A:9C60
exp_pop_value                    E:9C1C
exp_pop_value_ok                 A:9C25
exp_precedence_table             A:9C75
exp_precedence_table_end         E:9CD5
exp_push_operator                A:9C45
exp_push_operator_ok             A:9C50
exp_push_value                   E:9BF1
exp_push_value_memory_full       A:9BF7
exp_push_value_not_full          A:9C0B
exp_push_value_ok                A:9BFC
exp_shift_left                   A:AB3A
exp_shift_left_done              A:AB52
exp_shift_left_loop              A:AB49
exp_shift_right                  A:AB53
exp_shift_right_done             A:AB6B
exp_shift_right_loop             A:AB62
exp_subtract                     A:AA5A
exp_true                         A:AA70
exp_trueJ                        A:AB13
exp_unary_minus                  A:AB8D
exp_unary_ok                     S:0081
exp_value_stack                  S:0079
exp_value_stack_count            S:007B
find_count                       S:00B9
find_delimiter                   S:00B4
find_flags                       S:00BD
find_from                        S:00B0
find_len                         S:00B3
find_line                        A:8C55
find_line_eof                    A:8C88
find_line_loop                   A:8C63
find_line_next                   A:8C72
find_line_same_line              A:8C80
find_pos                         S:00B2
find_source_end                  A:8C89
find_source_end_done             E:8CA5
find_source_end_loop             E:8C91
find_source_end_wrap             E:8C9F
find_string_too_long             A:86DE
find_string_too_longJ            A:877E
find_string_too_long_message     A:86C0
find_to                          S:00B1
found_message                    A:8693
found_this_line                  S:00BB
from_line                        S:009E
from_msg                         A:869B
gc_alpha_alpha_only              A:C975
gc_alpha_done                    A:C971
gc_alpha_loop                    A:C958
gc_alpha_ok                      A:C960
gc_ampersand                     A:CD6A
gc_assembler_comment_find_end    A:CB79
gc_assembler_comment_keep_looki  A:CB8B
gc_assembler_comment_not_eof     A:CB84
gc_assign                        A:CD06
gc_backslash_tokens              A:CB93
gc_backslash_tokens_end          E:CBA9
gc_backslash_tokens_length       E:0016
gc_bang                          A:CD9D
gc_bar                           A:CD7B
gc_binary_literal                A:CCDD
gc_binary_loop                   A:CCE5
gc_colon                         A:CCFB
gc_comment_found_end             A:CB12
gc_comment_keep_looking          A:CB0A
gc_comment_not_eof               A:CAF2
gc_comment_not_newline           A:CAFB
gc_directive_list                A:CB5A
gc_directive_nolist              A:CB67
gc_directive_pcodes              A:CB61
gc_directive_symbols             A:CB22
gc_directive_symbols_ok          A:CB2E
gc_directive_symbols_too_late    A:CB55
gc_dollar                        A:CC77
gc_done                          A:C93B
gc_equality                      A:CD97
gc_equals                        A:CD8C
gc_fix_hex                       A:CC3B
gc_fix_hex_not_a_to_f            A:CC44
gc_geq                           A:CD3F
gc_greater_than                  A:CD2F
gc_hex_done                      A:CCC7
gc_hex_literal                   A:CC83
gc_hex_loop                      A:CC8C
gc_hex_too_big                   A:CCCC
gc_inequality                    A:CDA8
gc_leq                           A:CD20
gc_less_than                     A:CD0C
gc_lh_brace                      A:CAB6
gc_lh_paren                      A:CABA
gc_logical_and                   A:CD75
gc_logical_or                    A:CD86
gc_minus                         A:CD49
gc_neq                           A:CD25
gc_newline                       A:C918
gc_newline1                      A:C925
gc_newline_assembling            A:C932
gc_not_alpha                     A:C97E
gc_not_digit                     A:C98A
gc_not_space                     A:C953
gc_pascal_comment                A:CAC8
gc_pascal_comment_find_end       A:CAE7
gc_percent                       A:CCD1
gc_plus                          A:CD4B
gc_quote                         A:CBA9
gc_quote_backslash_loop          A:CC12
gc_quote_bad                     A:CBC0
gc_quote_bad_string              A:CC1D
gc_quote_copied_value            A:CBE5
gc_quote_done                    A:CBEE
gc_quote_found_backslash_charac  A:CC26
gc_quote_hex_character           A:CC48
gc_quote_hex_character_done      A:CC22
gc_quote_hex_character_one_only  A:CC74
gc_quote_long_string             A:CBDA
gc_quote_loop                    A:CBB7
gc_quote_loop_not_end_of_line    A:CBC5
gc_quote_not_backslash           A:CC2A
gc_quote_not_finished            A:CC00
gc_quote_too_long                A:CC36
gc_semicolon                     A:CB70
gc_shift_left                    A:CD2A
gc_shift_right                   A:CD44
gc_single_byte_already_known     A:C937
gc_single_byte_already_knownJ    A:CAB3
gc_single_byte_already_knownJ2   A:CD3C
gc_single_byte_token             A:C939
gc_single_byte_tokenJ            A:CAB0
gc_skip_spaces                   A:C903
gen_random                       A:8FDA
gen_random1                      A:8FFC
get_token                        A:C8F5
get_token_loop                   A:C8F9
gtoken_directive_table           A:CAA3
gtoken_table                     A:CA72
handlerLookup                    A:8F0A
handler_find_length              A:8F12
handler_found_directive          A:8F38
handler_found_length             A:8F1B
handler_loop                     A:8F0C
handler_next                     A:8F1F
handler_same_length              A:8F2F
handlers_done                    A:8F48
hardware_init                    A:C890
hardware_work                    S:008C
id_equals_message                A:B5CF
info_message                     A:A567
insert_last_char                 E:00B0
insert_limit                     S:00A4
introduction                     A:8255
irq                              A:B68F
irq1                             A:B69C
irq_done                         A:B714
is_xxx_fail                      A:8106
is_xxx_pass                      A:810A
isalnum                          E:8162
isalpha                          E:8126
isbin                            A:8176
isbinary                         E:816E
iscntrl                          E:8156
isdigit                          E:8132
islower                          E:811A
isspace                          E:814A
isupper                          E:810E
isxdigit                         E:813E
lcd_clear_display                A:B851
lcd_clear_enable                 A:B7B4
lcd_data_nibble                  A:B810
lcd_get_address                  A:B7DD
lcd_home                         A:B861
lcd_initialise                   A:B717
lcd_instruction                  A:B7FD
lcd_prepare_to_read_register     A:B770
lcd_prepare_to_write_data        A:B783
lcd_prepare_to_write_instructio  A:B798
lcd_print                        A:B872
lcd_print_char                   A:B81F
lcd_print_char_newline           A:B840
lcd_print_char_ok                A:B840
lcd_print_char_on_2nd_line       A:B839
lcd_print_done                   A:B87C
lcd_print_message                A:B869
lcd_print_not_newline            A:B82A
lcd_read_instruction_nibble      A:B7BD
lcd_second_line                  A:B859
lcd_set_enable                   A:B7AB
lcd_wait                         A:B7C9
lcd_work                         S:0086
lcd_write_instruction_nibble     A:B7F1
lcdbusy                          A:B7CE
library_function_call            A:C67B
library_function_call_1          A:C6B7
library_function_call_2          A:C688
library_function_call_3          A:C6B2
library_function_call_5          A:C6BA
line_number_lt_1000              A:8C34
line_number_output_spaces        A:8C43
lines_deleted_message            A:8C13
list_symbols                     E:A572
list_symbols_check               E:A58C
list_symbols_done                E:A5C6
list_symbols_line                E:A59B
list_symbols_name                E:A5B5
list_symbols_next                E:A581
load_message                     A:89D4
m_alnum                          E:0080
m_alpha                          E:0004
m_cntrl                          E:0040
m_digit                          E:0008
m_lower                          E:0002
m_space                          E:0020
m_upper                          E:0001
m_xdigit                         E:0010
main_loop                        A:82E6
main_loop_not_run                A:8312
main_prompt                      A:82CC
main_start                       A:82C5
maths_work                       S:008D
mem_move_dest                    S:00A8
mem_move_len                     S:00AA
mem_move_src                     S:00A6
memory_filled_up                 A:8B45
memory_full                      A:8B2A
movedown                         A:817A
movedown1                        A:819D
movedown2                        A:8190
movedown_done                    A:819C
movedown_loop                    A:8186
moveup                           A:81A6
moveup3                          A:81D8
moveup_done                      A:81E4
moveup_loop                      A:81CE
moveup_next                      E:81E5
negate_token_value               A:CA5E
no_find_message                  A:8718
no_valid_compile_message         A:9328
notbin                           A:8178
number_bad_range_message         A:8605
number_expected_message          A:855C
number_too_large_message         A:85DC
opcode_lookup                    A:9AF5
opcode_lookup_correct_length     A:9B20
opcode_lookup_correct_operand    A:9B4E
opcode_lookup_loop               A:9B07
opcode_lookup_loop_done          A:9B65
opcode_lookup_loop_unknown       A:9B9A
opcode_lookup_next_table         A:9B11
opcode_lookup_no_handler         A:9B64
opcode_lookup_ok                 A:9B9D
p_equals_message                 A:B5BF
partial_handler_Lookup           A:8F4D
partial_handler_done             A:8F91
partial_handler_found_directive  A:8F7D
partial_handler_next             A:8F66
partial_handler_next_found_item  A:8F6D
partial_handler_next_item        A:8F4F
partial_handler_next_loop        A:8F57
partial_handler_skipped_string   A:8F84
pas_gc_identifier                A:CEAD
pas_gc_loop                      A:CEB5
pas_gc_more                      A:CEBE
pas_gc_no_match                  E:CEE6
pas_get_token                    A:CEA3
pas_get_token_eof                A:CEAC
pascal_library_functions_table   A:C581
pcodes_ended_message             A:92DF
pin_number_to_mask               E:C7D5
pin_number_to_mask_done          A:C7E3
pin_number_to_mask_loop          A:C7DB
pinmode                          A:C7E8
pinmode_B                        A:C7F9
pinmode_C                        A:C801
pinmode_OUTPUT                   A:C80F
prchar_not_control               A:9298
print                            A:8226
print_done                       A:824C
print_loop                       A:8234
print_not_abort                  A:8242
prompt                           A:829F
random                           S:0009
recover_done                     A:8E3B
recover_not_needed               A:8E41
rep_diff                         S:00B7
rep_from                         S:00B5
rep_to                           S:00B6
run_assembler                    A:9377
running_message                  A:AD5B
s_equals_message                 A:B5C7
serial_available                 E:C88A
serial_in_byte                   S:008A
serial_in_byte_received          S:008B
serial_in_loop                   A:B6C0
serial_out_bit                   S:0089
serial_out_byte                  S:0087
serial_print                     A:C8EA
serial_print_done                A:C8F4
serial_print_message             A:C8E4
serial_send_count_bits           A:B705
show_current_line                A:97F9
show_current_line_done           A:983E
show_current_line_loop           A:981B
show_current_line_loop_print_on  A:9833
show_current_line_number         A:8C1E
show_current_line_number_done    A:8C4F
show_source_end                  A:8ECD
show_source_start                A:8EF5
show_symbol_table_end            A:8EA8
show_symbols                     S:0082
source_ended_message             A:8EBA
source_length_message            A:906B
source_starts_message            A:8EE2
stack_message                    A:B684
str_compare                      A:81F0
str_compare_done                 A:81FE
str_ic_compare                   A:8201
str_ic_compare_done              A:8223
str_ic_compare_fixed_dest        A:821E
str_ic_compare_fixed_srce        A:8210
str_work                         S:0085
symbol_table_ended_message       A:9310
symbol_table_message             A:8D66
system_flags                     S:00BE
this_line                        S:00AC
this_line_addr                   S:00AE
timer1_interrupt                 A:B6E5
to_line                          S:00A0
to_msg                           A:86A2
token_address                    S:0090
token_digit                      S:009B
token_length                     S:0092
token_line                       A:C995
token_line1                      A:C99B
token_line_done                  A:C9E3
token_line_listing               A:C9B6
token_line_loop                  A:C9CE
token_line_loop1                 A:C9DE
token_line_start                 S:009C
token_sign                       S:0097
token_start                      S:008E
token_type                       S:0093
token_value                      S:0094
token_work                       S:0098
too_much_on_line                 A:861E
typing_latency                   S:000D
write_char                       A:C8BF
write_char_loop                  A:C8DB
write_function                   S:0017
write_to_lcd                     A:C86E
write_to_serial                  A:C863
write_zero                       A:B700
wtf_loop                         A:9B89
x_equals_message                 A:B5AF
y_equals_message                 A:B5B7

Symbols by value:
0000 EMULATOR
0000 OPCODE_LOOKUP_OPCODE_LENGTH
0000 PCODE_LIT
0000 REG
0000 SERIAL_DEBUGGING
0000 SRCE
0000 SYMPRV
0000 VALUE
0000 VIA_FLAG_DISABLE
0000 crc_addr
0001 ASS_OPERAND_ABSOLUTE
0001 EFLAG_SHOW_LINE
0001 FFLAG_IGNORE_CASE
0001 FLAG_COMPILING
0001 LCD_SUPPORT
0001 OPCODE_LOOKUP_OPERAND_TYPE
0001 PCODE_STACK
0001 m_upper
0002 ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
0002 EFLAG_ALLOW_ZERO_FROM
0002 FFLAG_GLOBAL
0002 FLAG_ASSEMBLING
0002 OPCODE_LOOKUP_OPCODE_TABLE
0002 PCODE_NEG
0002 REGB
0002 SERIAL_OUT_MASK
0002 SYMLVL
0002 m_lower
0003 ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
0003 DEST
0003 KEY_ABORT
0003 PCODE_LIB_CALL
0003 REG2
0003 SYMTYP
0003 VALUE2
0003 crc_num
0004 ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
0004 EFLAG_LOAD
0004 FFLAG_QUIET
0004 FLAG_LIST_SOURCE
0004 KEY_DEBUG
0004 OPCODE_LOOKUP_HANDLER
0004 PCODE_ADD
0004 SERIAL_DEBUG1_MASK
0004 SYMDSP
0004 m_alpha
0005 ASS_OPERAND_ABSOLUTE_INDIRECT
0005 REG2B
0006 ASS_OPERAND_ACCUMULATOR_A
0006 OPCODE_LOOKUP_TABLE_SIZE
0006 PCODE_SUB
0006 REMAIN
0006 SYMARG
0006 SYMSUB
0006 crc_val
0007 ASS_OPERAND_IMMEDIATE
0008 ASS_OPERAND_IMPLIED
0008 BACKSPACE
0008 EFLAG_SAVE
0008 FLAG_VALID_COMPILE
0008 PCODE_MUL
0008 SERIAL_DEBUG2_MASK
0008 SYMDAT
0008 VIA_FLAG_CB2
0008 m_digit
0009 SYMLEN
0009 random
000A NL
000A PCODE_DIV
000A SYMNAM
000B ASS_OPERAND_ZERO_PAGE
000B PCODE_MOD
000C ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
000C PCODE_ADRNN
000D ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
000D CR
000D typing_latency
000E ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
000E KEY_STOP_TRACE
000E PCODE_ADRAN
000F ASS_OPERAND_ZERO_PAGE_INDIRECT
0010 ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
0010 EFLAG_FIND
0010 FLAG_VALID_ASSEMBLE
0010 PCODE_EQL
0010 SERIAL_SPARE2_MASK
0010 call_a
0010 m_xdigit
0011 ASS_OPERAND_STRING
0011 PCODE_FINISHD
0011 call_x
0012 ASS_OPERAND_ZERO_PAGE_AND_ABSOLUTE
0012 PCODE_NEQ
0012 call_y
0013 call_p
0014 KEY_TRACE
0014 PCODE_LSS
0014 call_s
0015 brk_address
0016 PCODE_GEQ
0016 gc_backslash_tokens_length
0017 write_function
0018 PCODE_GTR
0019 LINE_CNT
0019 PCODE_LEQ
001A PCODE_ORR
001B END_EDITOR_INPUT
001B PCODE_AND
001C PCODE_INP
001D LIST
001E PCODE_OUT
001F PCODE_OUTC
0020 EFLAG_REPLACE
0020 FRAME
0020 LCD_RS
0020 MAX_STK
0020 PCODE_EOR
0020 SERIAL_DELAY1
0020 m_space
0021 PCODE_OUH
0022 LEVEL
0022 PCODE_SHL
0022 TOKEN_STRING
0023 PCODE
0023 PCODE_OUS
0023 SERIAL_DELAY2
0024 PCODE_SHR
0025 ACT_PCDA
0025 PCODE_INS
0026 PCODE_INC
0027 DISPL
0027 PCODE_CLL
0027 SINGLE_QUOTE
0028 PCODE_DEC
0029 OFFSET
0029 PCODE_RTN
002A PCODE_MOV
002B OPND
002B PCODE_CLA
002C PCODE_LOD
002E DCODE
002E PCODE_LDA
002F STARTSYM
0030 PCODE_LDI
0031 ENDSYM
0031 T
0032 PCODE_STO
0033 WORKD
0034 PCODE_STA
0035 ERRNO
0036 BSAVE
0036 PCODE_STI
0037 WORK
0038 PCODE_ABSCLL
0039 PRCITM
003A PCODE_XOR
003B BASE
003B PCODE_INT
003C PCODE_JMP
003D DATA
003D PCODE_JMZ
003E PCODE_JM1
003F RUNNING
0040 EFLAG_SUPPRESS_NEWLINE
0040 FLAG_ONLY_ALPHA
0040 FROM
0040 LCD_RW
0040 PCODE_OUTCR
0040 SYMITM
0040 VIA_FLAG_TIMER1
0040 m_cntrl
0041 SYMBOL_ARRAY
0041 TOKEN_ASSIGN
0042 PCODE_LCD_WRITE_NUM
0042 SYNTAX
0043 END_PCD
0043 PCODE_LCD_WRITE_STR
0043 SYMBOL_CONSTANT
0044 PCODE_LCD_WRITE_HEX
0045 PCODE_LAST
0045 PCODE_LCD_WRITE_CHR
0045 TEMP
0045 TOKEN_EQUALITY
0046 SYMBOL_FUNCTION
0047 CALL
0049 DBGFLG
0049 TOKEN_IDENTIFIER
004A DATTYP
004B COUNT1
004C COUNT2
004C TOKEN_SHIFT_LEFT
004D LASTP
004D TOKEN_UNARY_MINUS
004E TOKEN_NUMBER
0050 SYMBOL_PROCEDURE
0051 SYMBOL_LIBRARY_PROCEDURE
0052 RES
0052 SYMBOL_LIBRARY_FUNCTION
0052 TOKEN_SHIFT_RIGHT
0055 MCAND
0055 TOKEN_NEQ
0056 SYMBOL_VARIABLE
0056 TOKEN_LOW_BYTE
0057 TOKEN_HIGH_BYTE
0058 TOKEN_LOGICAL_AND
0059 SYMBOL_FUNCTION_RETURN
0059 TOKEN_LOGICAL_OR
005A TOKEN_INEQUALITY
005B RMNDR
005C bcd_work
0060 bcd_result
006B ASS_OPERAND
006C OPCODE
006E OPCODE_LEN
006F ASS_EMIT_COUNT
0070 ASS_OPCODE_WORK
0072 ASS_COUNT
0073 ASS_VALUE
0076 ASS_PASS
0077 ass_emit_bytes
0079 exp_value_stack
007B exp_value_stack_count
007C exp_operator_stack_count
007D exp_operator
007E exp_operator_precedence
007F exp_evaluation_function
0080 EFLAG_NO_LINE_NUMBERS
0080 FLAG_ABORTED
0080 LCD_E
0080 TOKEN_LEQ
0080 VIA_FLAG_ENABLE
0080 m_alnum
0081 TOKEN_GEQ
0081 exp_unary_ok
0082 TOKEN_CONST
0082 show_symbols
0083 TOKEN_VAR
0083 ass_current_label
0084 TOKEN_ARRAY
0085 TOKEN_OF
0085 str_work
0086 TOKEN_PROCEDURE
0086 lcd_work
0087 TOKEN_FUNCTION
0087 serial_out_byte
0088 TOKEN_BEGIN
0089 TOKEN_END
0089 serial_out_bit
008A TOKEN_OR
008A serial_in_byte
008B TOKEN_DIV
008B serial_in_byte_received
008C TOKEN_MOD
008C hardware_work
008D TOKEN_AND
008D maths_work
008E TOKEN_SHL
008E token_start
008F TOKEN_SHR
0090 TOKEN_NOT
0090 token_address
0091 TOKEN_MEM
0092 TOKEN_IF
0092 token_length
0093 TOKEN_THEN
0093 token_type
0094 TOKEN_ELSE
0094 token_value
0095 TOKEN_CASE
0096 TOKEN_WHILE
0097 TOKEN_DO
0097 token_sign
0098 TOKEN_REPEAT
0098 token_work
0099 TOKEN_UNTIL
009A TOKEN_FOR
009B TOKEN_TO
009B token_digit
009C TOKEN_DOWNTO
009C token_line_start
009D TOKEN_WRITE
009E TOKEN_READ
009E from_line
009F TOKEN_CALL
00A0 to_line
00A1 TOKEN_CHAR
00A2 TOKEN_MEMC
00A2 current_line
00A4 TOKEN_XOR
00A4 insert_limit
00A6 mem_move_src
00A8 mem_move_dest
00A9 TOKEN_ADDRESS
00AA mem_move_len
00AB TOKEN_CHR
00AC TOKEN_HEX
00AC this_line
00AE this_line_addr
00B0 find_from
00B0 insert_last_char
00B1 find_to
00B2 find_pos
00B3 find_len
00B4 find_delimiter
00B5 rep_from
00B6 rep_to
00B7 rep_diff
00B9 find_count
00BB found_this_line
00BC editor_flags
00BD find_flags
00BE system_flags
00D0 BIT_INTERVAL
00F1 TOKEN_LCDWRITE
00FE TOKEN_INTEGER
00FF NEW_STK
00FF TOKEN_WRITELN
0100 INBUF_SIZE
0200 INBUF
0300 TEXT_START
12C0 BAUD_RATE
3FFF HIGHEST_RAM
3FFF SYMBOL_TABLE_START
7FF0 VIA_PORTB
7FF1 VIA_PORTA
7FF2 VIA_DDRB
7FF3 VIA_DDRA
7FF4 VIA_T1C_L
7FF5 VIA_T1C_H
7FFB VIA_ACR
7FFD VIA_IFR
7FFE VIA_IER
8000 START_OF_ROM
8006 character_types_table
8106 is_xxx_fail
810A is_xxx_pass
810E isupper
811A islower
8126 isalpha
8132 isdigit
813E isxdigit
814A isspace
8156 iscntrl
8162 isalnum
816E isbinary
8176 isbin
8178 notbin
817A movedown
8186 movedown_loop
8190 movedown2
819C movedown_done
819D movedown1
81A6 moveup
81CE moveup_loop
81D8 moveup3
81E4 moveup_done
81E5 moveup_next
81F0 str_compare
81FE str_compare_done
8201 str_ic_compare
8210 str_ic_compare_fixed_srce
821E str_ic_compare_fixed_dest
8223 str_ic_compare_done
8226 print
8234 print_loop
8242 print_not_abort
824C print_done
8255 introduction
829F prompt
82A2 bad_command
82C5 main_start
82CC main_prompt
82E6 main_loop
8312 main_loop_not_run
8330 editor_handlers
83BE editor_help_info
8533 editor_help
853B editor_help_loop
854C editor_help_done
854F editor_default_range
855C number_expected_message
856D editor_bad_number
8577 editor_get_number
85B2 editor_get_number_not_identifier
85C8 editor_get_number_ok
85D8 editor_get_number_done
85DA editor_get_number_none
85DC number_too_large_message
85FB editor_line_number_too_big
8605 number_bad_range_message
8614 editor_bad_range
861E too_much_on_line
8638 editor_check_no_more
8647 editor_check_no_more_ok
8648 editor_get_range
867A editor_get_range_hyphen
867F editor_get_range_number
8692 editor_get_range_done
8693 found_message
869B from_msg
86A2 to_msg
86A7 bad_delimiter_message
86B6 editor_bad_delimiter
86BA editor_find_problem
86C0 find_string_too_long_message
86DE find_string_too_long
86E4 editor_get_delimiter
86FC editor_no_closing_delimiter_message
8712 editor_no_closing_delimiter
8718 no_find_message
872D editor_no_find_string
8733 editor_replace
873B editor_find
8741 editor_save
8747 editor_list
876D editor_list_doing_find
8779 editor_find_bug
877E find_string_too_longJ
8781 editor_no_closing_delimiterJ
8784 editor_list_got_from_point
8786 editor_find_second_delimiter_loop
87AD editor_find_third_delimiter_loop
87D3 editor_find_get_flags
87D5 editor_flags_loop
87F3 editor_flags1
87FD editor_flags2
8807 editor_flags3
8811 bad_flag_message
881F editor_list_fix_target_string
8827 editor_list_fixup_loop
8837 editor_list_not_find
883A editor_list_get_on_with_it
884B editor_list_have_source
8851 editor_list_doneJ
8854 editor_list_no_line_numberJ
8857 editor_list_loop
887E editor_list_aborted
888B editor_find_or_replacing
888D editor_replacement_loop
888F editor_find_loop
8893 editor_find_inner_loop
88AA editor_find_case_sensitive
88AB editor_find_test_character
88B4 editor_find_skip_this
88B8 editor_find_no_match
88CE editor_find_found_it
88D4 editor_find_found_it1
88EC editor_do_the_replace
88F9 editor_easy_replace
88FD editor_easy_replace_loop
890A editor_easy_replace_done
891B editor_list_not_finding
8928 editor_list_no_line_number
8930 editor_newline_processing
893A editor_list_check_to_line
894A editor_list_check_to_line_ok
8952 editor_list_not_newline
895D editor_list_skip_newline
8963 editor_list_loopJ
8966 editor_list_done
8983 editor_list_completely_done
8986 editor_do_replace
89C8 editor_do_replace_smaller
89CB editor_do_replace_copy_done
89D4 load_message
89F6 editor_load
89FA editor_insert
8A16 editor_insert_at_start
8A24 editor_insert_common
8A63 editor_insert_loop
8A74 editor_insert_no_line_number
8A99 editor_insert_not_newline
8AA3 editor_insert_loop1
8AB3 editor_insert_backspace
8ABF editor_insert_backspace_not_at_start
8AD2 editor_insert_done
8AE4 editor_insert_done_with_newline
8AFF editor_too_full
8B06 editor_too_full_loop
8B17 editor_no_lines
8B2A memory_full
8B45 memory_filled_up
8B6E editor_delete
8B90 editor_delete_have_range
8BC9 editor_delete_line_count_loop
8BD5 editor_delete_line_count_not_done
8BE1 editor_delete_line_count_not_newline
8BE9 editor_delete_line_count_done
8C13 lines_deleted_message
8C1E show_current_line_number
8C34 line_number_lt_1000
8C43 line_number_output_spaces
8C4F show_current_line_number_done
8C55 find_line
8C63 find_line_loop
8C72 find_line_next
8C80 find_line_same_line
8C88 find_line_eof
8C89 find_source_end
8C91 find_source_end_loop
8C9F find_source_end_wrap
8CA5 find_source_end_done
8CA6 brk_resumed
8CBA editor_test
8CCC editor_memory
8CE3 editor_memory_loop
8D04 editor_memory_loop1
8D16 editor_memory_loop2
8D26 editor_memory_loop3
8D36 editor_memory_done
8D39 editor_memory_aborted
8D3F editor_memory_show_ascii
8D41 editor_memory_ascii
8D49 editor_memory_not_control
8D4D editor_memory_show_dot
8D4F editor_memory_not_high
8D66 symbol_table_message
8D98 ST_SYMTBL_LIST_NEXT
8DA3 ST_SYMTBL_LIST_CHECK
8DB2 ST_SYMTBL_LIST_LINE
8E27 ST_SYMTBL_LIST_NAME
8E38 ST_SYMTBL_LIST_DONE
8E3B recover_done
8E41 recover_not_needed
8E4D editor_recover
8E69 editor_recover_not_needed
8E73 editor_debug
8E7C editor_trace
8E85 editor_info
8E91 editor_compile
8E98 editor_syntax
8E9F editor_run
8EA8 show_symbol_table_end
8EBA source_ended_message
8ECD show_source_end
8EE2 source_starts_message
8EF5 show_source_start
8F07 editor_assemble
8F0A handlerLookup
8F0C handler_loop
8F12 handler_find_length
8F1B handler_found_length
8F1F handler_next
8F2F handler_same_length
8F38 handler_found_directive
8F48 handlers_done
8F4A call_handler
8F4D partial_handler_Lookup
8F4F partial_handler_next_item
8F57 partial_handler_next_loop
8F66 partial_handler_next
8F6D partial_handler_next_found_item_length
8F7D partial_handler_found_directive
8F84 partial_handler_skipped_string
8F91 partial_handler_done
8F92 TKNJMP
8F9A JMP1
8FA2 JMP2
8FB7 JMP3
8FC4 MAKE_UPPER
8FCE MAKE_UPPER_DONE
8FD9 MAKE_LOWER_DONE
8FDA gen_random
8FFC gen_random1
8FFD crc16
9009 crc16_loop
9016 crc16_next
901C crc16_skip
9024 crc_done
9025 crc_byte
9055 crc_helper1
9058 crc_message
906B source_length_message
907B bytes_message
9083 crc_source
90CB delay_1ms
90CE delay_1ms_loop
90D5 delay
90DF bcd_unpack
90F2 bcd_table
9152 display_in_decimal
915E bcd_positive
9165 bcd_skip_zeroes
9170 bcd_output_digit
917B binary_to_decimal
9186 binary_to_decimal_loop
91AB binary_to_decimal_next
91C9 NOSCE
91DA INIT
91E6 INIT_SECOND_PASS
9227 INIT9
9228 CROUT
922D COMSTL
9239 COMS9
923A COMS8
923D DISHX
9243 DISPAD
925E DISPAD2
925F PSHWRK
9271 PSH9
9272 PULWRK
9285 PRCHAR
9298 prchar_not_control
929D PRBYTE
92A6 PRHEX
92A8 PRHEXZ
92B0 PRHEX1
92B3 PUTSP
92B7 PT
92BF PT6
92C9 TKNWRK
92D4 WRKTKN
92DF pcodes_ended_message
92F2 compile_finished_message
9310 symbol_table_ended_message
9328 no_valid_compile_message
9352 PRBYTECR
9358 CHK_VAL
936A CHK_VAL9
936B CHK_RUN
9377 run_assembler
937D call_assembler
9387 GETLN1
9387 GET_LINE
9389 GET1
93A6 GET3
93AC GETLN_OVERFLOW
93AF COUT
93B9 COUT_CALL
93BC errors_table
971E assertion_failed_message
9758 ERRLIT
9764 ERROR
976D ERR7
9777 ERR1
978B ERR3
979B ERR5
97A1 ERR6
97AD error_next
97AE error_loop
97B2 error_find_next
97BB error1
97C4 error_not_found
97DC error_found
97E9 error_not_found_message
97F9 show_current_line
981B show_current_line_loop
9833 show_current_line_loop_print_one_character
983E show_current_line_done
9842 ASSEMBLE
984F ASSEMBLE_SECOND_PASS
9854 ASSEMBLE_PASS
986E ass_finish_line
9879 ass_done_jump
987C ass_line
988B ass_line1
98BB ass_bad_identifier
98C0 ass_identifier
98EA ass_lookup_existing_label
98F4 ass_lookup_save_address
9900 ass_added_symbol
9912 ass_not_colon
991A ass_finish_lineJ2
991D ass_not_colon2
9925 ass_illegal_opcode
992D ass_opcode
996E ass_check_label_changed
997E ass_symbol_address_changed
9983 ass_opcode2
998E ass_no_operand
9998 ass_finish_lineJ
999B ass_operand
99B1 ass_string
99BE ass_asterisk
99D5 ass_immediate
99E8 ass_indirect
99F1 ass_identifier_operand
9A12 ass_operand_value
9A4A ass_value_not_indirectJ
9A4D ass_bad_indirect
9A52 ass_indirect_with_bracket
9A66 ass_zp_indirect_indexed
9A87 ass_bad_zp_indirect_indexed
9A8C ass_not_x_or_y
9A8E ass_check_we_have_x_or_y
9AAA ass_check_we_have_x_or_y_ok
9AAC ass_value_not_indirect
9AB6 ass_value_done
9ABF ass_indexed
9ADD ass_indexed_x
9AE6 ass_absolute_another_value
9AF5 opcode_lookup
9B07 opcode_lookup_loop
9B11 opcode_lookup_next_table
9B20 opcode_lookup_correct_length
9B4E opcode_lookup_correct_operand
9B64 opcode_lookup_no_handler
9B65 opcode_lookup_loop_done
9B89 wtf_loop
9B9A opcode_lookup_loop_unknown
9B9D opcode_lookup_ok
9B9E ass_done
9BA8 ass_done_second_pass
9BC0 ass_done1
9BC3 ass_done_message
9BE1 ass_check_no_more_tokens
9BF0 ass_check_no_more_tokens_ok
9BF1 exp_push_value
9BF7 exp_push_value_memory_full
9BFC exp_push_value_ok
9C0B exp_push_value_not_full
9C1C exp_pop_value
9C25 exp_pop_value_ok
9C45 exp_push_operator
9C50 exp_push_operator_ok
9C57 exp_pop_operator
9C60 exp_pop_operator_ok
9C67 exp_get_operator
9C70 exp_get_operator_ok
9C75 exp_precedence_table
9CD5 exp_get_precedence
9CD5 exp_precedence_table_end
9CD7 exp_get_precedence_loop
9CEB exp_get_precedence_found
9CFC ass_get_value
9D16 ass_expression_loop
9D19 ass_expression_loop_initial
9D1D ass_expression_number
9D30 ass_expression_loop1a
9D42 ass_expression_not_small_string
9D47 ass_expression_loop1
9D5B ass_label_not_found_yet
9D63 ass_expression_found_value
9D74 ass_expression_loop2
9D83 ass_expression_loop3
9D87 ass_expression_loop3b
9D92 ass_expression_loop3a
9D97 ass_expression_loop3c
9D9A ass_expression_loopJ
9D9D ass_expression_loop4
9DAB ass_not_unary_minus
9DB5 ass_not_unary_less_than
9DBD ass_expression_cannot_be_unary
9DCC ass_expression_loop7
9DE3 ass_expression_loop6
9DEB exp_no_operators_left
9DF4 exp_done
9DFA exp_done_error
9DFF exp_done_ok
9E11 ass_expression_apply_operator
9E3A ass_expression_unary
9E4D ass_expression_apply_operator_bug
9E52 ass_evaluate_operator
9E55 ass_lookup_loop
9E73 ass_opcode_found
9E79 ass_emit
9E8D ass_emit2
9E9C ass_already_emitted
9EA7 ass_emit4
9EAE ass_emit3
9EB4 ass_emit1
9EB7 ass_error
9EBE ass_error1
9EC1 ass_fixup_bbr_branch
9ECE ass_fixup_branch
9EE7 ass_branch_backwards
9EEB ass_branch_ok
9EF1 ass_branch_out_of_range
9EFA ass_emit_zero_page
9F08 ass_emit_zero_page_too_high
9F0D ass_emit_immediate
9F1B ass_emit_immediate_too_high
9F20 ass_emit_absolute
9F2B OPCODE_LOOKUP_TABLE
9FCE DIRECTIVES
A041 OPCODE_4_CHAR_BRANCH
A092 OPCODE_3_CHAR_BRANCH
A0B7 OPCODE_3_CHAR_IMPLIED
A134 OPCODE_4_CHAR_ZERO_PAGE
A185 OPCODE_ASS_OPERAND_ABSOLUTE
A1EE OPCODE_ASS_OPERAND_ABSOLUTE_TOKENISED
A1F1 OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_INDIRECT
A1F6 OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X
A23B OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_X_TOKENISED
A23E OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y
A263 OPCODE_ASS_OPERAND_ABSOLUTE_INDEXED_WITH_Y_TOKENISED
A266 OPCODE_ASS_OPERAND_ACCUMULATOR_A
A27F OPCODE_ASS_OPERAND_ABSOLUTE_INDIRECT
A284 OPCODE_ASS_OPERAND_IMMEDIATE
A2B5 OPCODE_ASS_OPERAND_IMMEDIATE_TOKENISED
A2B8 OPCODE_ASS_OPERAND_ZERO_PAGE
A319 OPCODE_ASS_OPERAND_ZERO_PAGE_TOKENISED
A31C OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT
A33D OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_INDIRECT_TOKENISED
A340 OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X
A389 OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_X_TOKENISED
A38C OPCODE_ASS_OPERAND_ZERO_PAGE_INDEXED_WITH_Y
A395 OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT
A3B6 OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_TOKENISED
A3B9 OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y
A3DA OPCODE_ASS_OPERAND_ZERO_PAGE_INDIRECT_INDEXED_WITH_Y_TOKENISED
A3DD asm_do_assert
A3EC asm_do_assert_failed
A3F1 asm_do_constant_expectedJ
A3F4 asm_do_list
A403 asm_do_nolist
A40E asm_do_nolist_ok
A414 asm_do_list_no_operand
A418 asm_do_list_ok
A42E asm_do_list_not
A432 asm_do_list1
A441 asm_do_list_first_pass
A442 asm_do_asc
A44D asm_do_asc_ok
A44F asm_do_asc_loop
A458 asm_do_asc_next
A45D asm_do_string
A466 asm_do_equ
A477 asm_do_equ_have_label
A483 asm_do_org
A489 asm_do_constant_expected
A48E asm_do_org_ok
A497 asm_do_dfb
A4A5 asm_do_dfb_multiple
A4B2 asm_do_dfb_multiple_loop
A4C3 asm_do_dfb_multiple_done
A4C4 asm_do_dfb_too_big
A4C9 asm_emit_one_byte
A4D7 asm_do_dfw
A4E5 asm_do_dfw_multiple
A4F3 asm_do_dfw_multiple_loop
A504 asm_do_dfw_multiple_done
A505 asm_emit_two_bytes
A514 asm_do_blk
A524 asm_do_blk_loop
A531 asm_do_blk_done
A532 asm_do_reserve
A54A asm_do_constant_expectedJ2
A54D asm_do_sym
A566 asm_do_sym_done
A567 info_message
A572 list_symbols
A581 list_symbols_next
A58C list_symbols_check
A59B list_symbols_line
A5B5 list_symbols_name
A5C6 list_symbols_done
A5C7 assembler_library_functions_table
A9FB add_assembler_library_functions
AA03 add_assembler_library_functions_loop
AA13 add_assembler_library_functions_name_loop
AA45 add_assembler_library_functions_done
AA46 exp_add
AA5A exp_subtract
AA70 exp_true
AA79 exp_false
AA80 exp_eql
AA94 exp_neq
AAA8 exp_less_than
AAAF exp_greater_than
AABE exp_leq
AACD exp_geq
AAD4 exp_bitwise_or
AAE9 exp_bitwise_and
AAFE exp_bitwise_xor
AB13 exp_trueJ
AB16 exp_falseJ
AB19 exp_logical_or
AB28 exp_logical_and
AB3A exp_shift_left
AB49 exp_shift_left_loop
AB52 exp_shift_left_done
AB53 exp_shift_right
AB62 exp_shift_right_loop
AB6B exp_shift_right_done
AB6C exp_negate
AB7F exp_not
AB8D exp_unary_minus
ABA1 exp_low_byte
ABA6 exp_high_byte
ABAF exp_abs_val
ABB3 exp_negate_val
ABC6 exp_abs_val_done
ABC7 exp_abs_val2
ABCB exp_negate_val2
ABDE exp_abs_val2_done
ABDF ZERRES
ABE8 exp_find_sign
AC00 exp_fix_sign
AC13 exp_fix_sign_done
AC14 exp_multiply
AC19 exp_multiply_loop
AC3A exp_multiply_no_add
AC4D exp_divide
AC5D exp_divide_not_zero
AC6A exp_divide_loop
AC92 exp_divide_subtraction_negative
AC93 exp_divide_subtraction_positive
ACAD exp_modulo
ACBD execution_address_table
AD49 DM1
AD52 DM2
AD5B running_message
AD64 DB11
AD64 DEBUG
ADCC DEBUG_DONE
ADCD INTERP
ADF3 DM5
AE08 DM6
AE13 DM7
AE2D display_x_characters
AE34 DIS5
AE3E DIS5_A
AE4B BELL1
AE55 RUNERR
AE69 EX_FINISHD
AE80 FIN_MSG
AE9F CHK_KBD
AEAB CHK_NOTN
AEB9 CHK_NOTT
AEC7 CHK_NOTD
AEC9 EX_OUTCR
AECF LOWLIT
AED5 LOWLIT1
AEDB MAINP
AEDE MAIN
AEE5 MAIN_2
AEF0 MAIN_NOT_ABORT
AEF3 MAIN_OK
AF0D MAIN_1
AF1C EX_INVINS
AF20 NOTIM1
AF2D GETADR
AF37 GET2
AF58 GETADR1
AF73 GET1_A
AF74 PULTOP
AF8F PUL_END
AF96 PULBOTH
AF99 PULTOP2
AFB4 PUL2_END
AFBB PSHTOP
AFC6 PSH1
AFD7 GETLIT
AFED GET_END
AFEE EX_LIT
AFFD LIT1
B000 EX_NEG
B009 EX_ADD
B012 EX_SUB
B01E EX_MUL
B027 EX_GETKEY
B02E EX_MOD
B042 EX_DIVIDE_BY_ZERO
B049 DIVBY0
B059 EX_DIV
B06D EX_ABS
B076 EX_EQL
B07F TRUE
B081 TRUE2
B08C FALSE
B090 EX_NEQ
B099 EX_LSS
B0A5 EX_GTR
B0B1 EX_GEQ
B0BD EX_LEQ
B0C9 EX_XOR
B0D2 EX_ORR
B0DB EX_AND
B0E4 EX_EOR
B0ED EX_SHL
B0F9 EX_SHR
B105 EX_INC
B11D EX_DEC
B135 EX_MOV
B146 EX_LODC
B149 EX_LOD3
B14B EX_LOD3_A
B158 EX_LOD
B15B EX_LOD2
B16E EX_LDAC
B179 EX_LDA
B183 GETIDC
B18C GETIDX
B1A0 GETID2
B1AE EX_LDIC
B1B4 EX_LDI
B1BA EX_STOC
B1C2 EX_STO5
B1C7 EX_STO
B1CD EX_STO2
B1DA EX_STA
B1EB EX_STA5
B1F0 EX_STAC
B1F9 EX_STIC
B207 EX_STI
B222 EX_RTN
B25B EX_INP
B26C EX_INP_OK
B283 INP3
B293 BAD_INP
B29B EX_OUT
B2A0 EX_LCD_WRITE_NUM
B2A3 OUT_COMMON
B2AF EX_OUH
B2B4 EX_LCD_WRITE_HEX
B2B7 EX_OUH_COMMON
B2CF EX_OUS
B2D4 EX_LCD_WRITE_STR
B2D7 EX_OUS_COMMON
B2F3 EX_OUS1
B302 EX_ABSCLL
B309 EX_CLL
B311 EX_CLL_A
B32F EX_CLL4
B333 EX_CLL2
B354 EX_CLL3
B395 EX_CLL5
B398 EX_CLA
B3B5 EX_CLL_JMP
B3B8 EX_INT
B3CF INT_ERR
B3D6 INT_ERRM
B3E2 EX_NEW_STACK
B3F4 EX_JMP
B407 EX_JMZ
B412 EX_NOJUMP
B418 EX_JM1
B423 EX_INPC
B42D EX_INPC_OK
B43D EX_OUTC
B442 EX_LCD_WRITE_CHR
B445 EX_OUTC_COMMON
B453 EX_LCDHOME
B459 EX_LCDCLEAR
B45F EX_INS
B469 EX_INS3
B482 EX_INS1
B48B EX_INS2
B495 EX_INS4
B4A2 execution_aborted_message
B4B6 ex_input_aborted
B4BD EX_ADRNC
B4C0 EX_ADRNC2
B4CD EX_ADRNN
B4D0 EX_ADRN2
B4DB EX_ADRAN
B4E1 EX_ADRAC
B4E7 EX_DIGITALREAD
B4F2 EX_DIGITALREAD_ONE
B4F5 EX_LCDPOS
B505 EX_LCDPOS_1
B50F EX_RANDOM
B521 EX_LATENCY
B530 EX_DELAY
B540 EX_RANDOMSEED
B550 EX_PINMODE
B55F EX_DIGITALWRITE
B56E EX_LIB_CALL
B574 EX_ASSERT
B589 EX_ASSERT_OK
B58C break_message
B5A7 a_equals_message
B5AF x_equals_message
B5B7 y_equals_message
B5BF p_equals_message
B5C7 s_equals_message
B5CF id_equals_message
B5D8 brk_executed
B653 brk_executed1
B660 brk_executed2
B670 brk_executed3
B684 stack_message
B68C brk_executedJ
B68F irq
B69C irq1
B6B4 cb2_interrupt
B6C0 serial_in_loop
B6E5 timer1_interrupt
B700 write_zero
B705 serial_send_count_bits
B714 irq_done
B717 lcd_initialise
B770 lcd_prepare_to_read_register
B783 lcd_prepare_to_write_data
B798 lcd_prepare_to_write_instruction
B7AB lcd_set_enable
B7B4 lcd_clear_enable
B7BD lcd_read_instruction_nibble
B7C9 lcd_wait
B7CE lcdbusy
B7DD lcd_get_address
B7F1 lcd_write_instruction_nibble
B7FD lcd_instruction
B810 lcd_data_nibble
B81F lcd_print_char
B82A lcd_print_not_newline
B839 lcd_print_char_on_2nd_line
B840 lcd_print_char_newline
B840 lcd_print_char_ok
B851 lcd_clear_display
B859 lcd_second_line
B861 lcd_home
B869 lcd_print_message
B872 lcd_print
B87C lcd_print_done
B87D SEARCH
B885 SEA_NEXT
B890 SEA1
B89D SEA2
B8E6 SEA4
B8EE SEA5
B8F1 SEA3
B8F4 SYM_FULL
B8F9 ADDSYM
B92E ADDSYM_NOT_FULL
B955 ADD1
B978 ADD4
B994 ADD9
B995 LOOKUP
B99F LOOK1
B9A0 CHKDUP
B9AF DUP9
B9B0 COMPIL
B9FE END_CMP
BA01 CHKLHP
BA08 CHKRHP
BA12 GETSUB
BA1B CHKLHB
BA25 CHKRHB
BA2F GET_LEV
BA39 GET_DAT
BA40 CONDEC
BA6B SYMWRK
BA76 WRKSYM
BA81 PSHPCODE
BA94 GET_OFF
BAB0 GETO_1
BABD GETO_2
BABF GETEXPR
BAC5 PCD_WRKD
BAD0 WRK_OPND
BADB WRKD_WRK
BAE6 WRK_WRKD
BAF1 GET_COMM
BAF8 GET_ITEM
BAFE VAL_MOVE
BB07 VAL_1
BB0C VAL_2
BB15 VAL_3
BB1E VAL_5
BB27 CHK_STAK
BB2E STK_ERR
BB2E STK_FULL
BB33 CONST
BB4A CONST1
BB4F CONST3
BB54 CONST2
BB58 CONST9
BB59 VARDEC
BB6B SIMEXP
BB75 SIM1
BB86 SIM3
BB99 SIM4
BBAF SIM7
BBB5 SIM5
BBB9 SIM6
BBBD SIM2
BBC3 SIM8
BBC7 TERMT1
BBDD TERM
BBE0 TERM2
BBEA TERM1
BBF9 TERM4
BBFB TERM3
BC01 TERM5
BC05 TERM6
BC09 TERM7
BC0D TERM8
BC11 TERM9
BC15 TERMT3
BC2B FACTOR
BC3C IDENT
BC3F IDENT1
BC47 IDENT1A
BC4C IDENT2
BC65 IDENT2A
BC6C IDENT3
BC7A FACAD1
BC82 IDENT5
BC84 IDENT5_A
BC8F IDENT6
BC95 IDENT7
BC98 FACAD2
BCA0 IDENT4
BCA2 IDENT4_A
BCC2 FACADR
BCD5 FACSTR
BCDB FACERR1
BCE0 FACNUM
BCE6 PAREN
BCEC FACMEM
BCF2 FACMMC
BCF6 FACM2
BD02 FACNOT
BD0A GENNOP1
BD0D FACRND1
BD13 FACTB1
BD19 FACTQT1
BD2C EXPRES
BD3C EXPTB1
BD4F EXPR1
BD5E EXPTB3
BD71 EXPR2
BD73 EXPR8
BD77 EXPR3
BD7B EXPR4
BD7F EXPR5
BD83 EXPR6
BD87 EXPR7
BD8B STMNT
BD98 STMNT1
BDC3 ASSIGN
BDC6 ASS1
BDD2 ASSTB1
BDE8 assign_bad_identifier
BDED ASSARR
BDFF ASSVAR
BE0E ASS2
BE2A WRITELN
BE34 WRITELN9
BE39 WRITE
BE3C WRIT9
BE4B W_STRING
BE55 WRIT2
BE58 WRIT10
BE65 WRIT1
BE75 WRIT5
BE7E W_CHR
BE80 W_CHR1
BE86 W_HEX
BE8A STMNT_WRITE_LCD
BE8D WRITE_LCD9
BE9C WRITE_LCD_STRING
BEA6 WRITE_LCD2
BEB6 WRITE_LCD1
BEC6 WRITE_LCD5
BECF WRITE_LDC_CHR
BED1 WRITE_LDC_CHR1
BED7 WRITE_LDC_HEX
BEDB READ
BEDE READ8
BEE1 READ2
BEF8 READ9
BEFB READ11
BF1A READ7
BF20 READ7_A
BF2A READ3
BF3E READ3_B
BF59 READ3_A
BF67 TWO_OP
BF6D ONE_OP2
BF70 ONE_OP
BF77 GENNOP2
BF7A WAIT_1
BF84 MEM
BF89 MEMC
BF8C MEM2
BF9F CALLSB
BFAC FNCPRC
BFB9 FNC2
BFE3 FNC3
BFE9 FNC1
BFEC FNC5
C009 FNC5A
C00B FNC5B
C02D FNC4
C02E FNC6
C033 IF
C051 IF2
C058 IF1
C073 BEG
C089 REPEAT
C08C REP1
C0AD WHILE
C0DF CASE
C0ED CASE7
C0F1 CASE2
C118 CASE1
C124 CASE4
C12E CASE3
C161 CASE5
C17F CASE6
C18A CASE9
C194 CASE8
C19A FOR
C1A4 FOR1
C1B1 FOR2
C1CA FOR3
C1FB FOR4
C23E FOR5
C260 FOR6
C26D CHKGET
C273 WRK_VAL
C27E VAL_WRK
C289 END_WRK
C294 BLCKT1
C297 BLCKT2
C29A BLCKT3
C2A4 BLOCK
C2BB BLK1A
C2CF BLK1
C2D7 BLK2
C2E1 BLK4
C2EB BLKCNS
C2EE BLKCN1
C302 BLKVAR
C306 BLKVR1
C309 BLKVR6
C313 BLKVR7
C332 BLKVR8
C335 BLKV10
C351 BLKV10_A
C358 BLKV10_B
C367 BLKVR2
C380 BLKV13
C385 BLKVR4
C3BF BLKV11
C3C6 BLKV12
C3CC BLKVR9
C3E5 BLKVR5
C427 BLKVR3
C43F BLKPRC
C45F BLKFNC
C481 BLKPR1
C49D BLKPR3
C4AA BLKPR6
C4B3 BLKPR2
C4D4 BLKPR5
C4FB BLKPR4
C527 BLKBEG
C531 BLKB3
C537 BLKB1
C553 BLKB2
C560 BLKB5
C56F BLKB4
C57E BLKB6
C581 pascal_library_functions_table
C621 add_pascal_library_functions
C629 add_pascal_library_functions_loop
C639 add_pascal_library_functions_name_loop
C67A add_pascal_library_functions_done
C67B library_function_call
C688 library_function_call_2
C6B2 library_function_call_3
C6B7 library_function_call_1
C6BA library_function_call_5
C6CB GENNOP
C6E0 GEN1
C6E4 GENADR
C717 GEN2
C719 GEN2_B
C722 GEN2_A
C734 GEN_FULL
C739 DISP9
C739 GEN2_C
C73A GENRJMP
C74C GENNJP
C74E GENNJM
C754 GENJMP
C77D GEN3
C782 FIXAD
C7BF FIXAD1
C7C0 FIXM1
C7C9 FIXM2
C7D5 pin_number_to_mask
C7DB pin_number_to_mask_loop
C7E3 pin_number_to_mask_done
C7E8 pinmode
C7F9 pinmode_B
C801 pinmode_C
C80F pinmode_OUTPUT
C817 digitalwrite
C828 digitalwrite_B
C830 digitalwrite_C
C83E digitalwrite_ONE
C846 digitalread
C855 digitalread_B
C85D digitalread_C
C863 write_to_serial
C86E write_to_lcd
C879 CHRIN
C879 GETIN
C883 GETIN1
C88A serial_available
C88D EMULATOR_DEBUG
C88E START_TRACE
C88F STOP_TRACE
C890 hardware_init
C8BF write_char
C8DB write_char_loop
C8E4 serial_print_message
C8EA serial_print
C8F4 serial_print_done
C8F5 get_token
C8F9 get_token_loop
C903 gc_skip_spaces
C918 gc_newline
C925 gc_newline1
C932 gc_newline_assembling
C937 gc_single_byte_already_known
C939 gc_single_byte_token
C93B gc_done
C953 gc_not_space
C958 gc_alpha_loop
C960 gc_alpha_ok
C971 gc_alpha_done
C975 gc_alpha_alpha_only
C97E gc_not_alpha
C98A gc_not_digit
C995 token_line
C99B token_line1
C9B6 token_line_listing
C9CE token_line_loop
C9DE token_line_loop1
C9E3 token_line_done
C9E4 atoi
C9ED atoi_loop
C9FC atoi_positive
C9FE atoi_more
CA53 atoi_error
CA59 atoi_not_running
CA5E negate_token_value
CA72 gtoken_table
CAA3 gtoken_directive_table
CAB0 gc_single_byte_tokenJ
CAB3 gc_single_byte_already_knownJ
CAB6 gc_lh_brace
CABA gc_lh_paren
CAC8 gc_pascal_comment
CAE7 gc_pascal_comment_find_end
CAF2 gc_comment_not_eof
CAFB gc_comment_not_newline
CB0A gc_comment_keep_looking
CB12 gc_comment_found_end
CB22 gc_directive_symbols
CB2E gc_directive_symbols_ok
CB55 gc_directive_symbols_too_late
CB5A gc_directive_list
CB61 gc_directive_pcodes
CB67 gc_directive_nolist
CB70 gc_semicolon
CB79 gc_assembler_comment_find_end
CB84 gc_assembler_comment_not_eof
CB8B gc_assembler_comment_keep_looking
CB93 gc_backslash_tokens
CBA9 gc_backslash_tokens_end
CBA9 gc_quote
CBB7 gc_quote_loop
CBC0 gc_quote_bad
CBC5 gc_quote_loop_not_end_of_line
CBDA gc_quote_long_string
CBE5 gc_quote_copied_value
CBEE gc_quote_done
CC00 gc_quote_not_finished
CC12 gc_quote_backslash_loop
CC1D gc_quote_bad_string
CC22 gc_quote_hex_character_done
CC26 gc_quote_found_backslash_character
CC2A gc_quote_not_backslash
CC36 gc_quote_too_long
CC3B gc_fix_hex
CC44 gc_fix_hex_not_a_to_f
CC48 gc_quote_hex_character
CC74 gc_quote_hex_character_one_only
CC77 gc_dollar
CC83 gc_hex_literal
CC8C gc_hex_loop
CCC7 gc_hex_done
CCCC gc_hex_too_big
CCD1 gc_percent
CCDD gc_binary_literal
CCE5 gc_binary_loop
CCFB gc_colon
CD06 gc_assign
CD0C gc_less_than
CD20 gc_leq
CD25 gc_neq
CD2A gc_shift_left
CD2F gc_greater_than
CD3C gc_single_byte_already_knownJ2
CD3F gc_geq
CD44 gc_shift_right
CD49 gc_minus
CD4B gc_plus
CD6A gc_ampersand
CD75 gc_logical_and
CD7B gc_bar
CD86 gc_logical_or
CD8C gc_equals
CD97 gc_equality
CD9D gc_bang
CDA8 gc_inequality
CDAE RSVWRD
CEA1 RSVEND
CEA3 pas_get_token
CEAC pas_get_token_eof
CEAD pas_gc_identifier
CEB5 pas_gc_loop
CEBE pas_gc_more
CEE6 pas_gc_no_match
CEF7 GETCHK
CF02 CHKNOK
CF05 CHKOK
CF07 CHKTKN
CF0C GET_LOOK
CF16 LCD_welcome
CF34 START
CF58 RESTART
CF5D REST1
4240 CLOCK_RATE
